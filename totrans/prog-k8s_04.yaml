- en: Chapter 4\. Using Custom Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。使用自定义资源
- en: In this chapter we introduce you to custom resources (CR), one of the central
    extension mechanisms used throughout the Kubernetes ecosystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍自定义资源（CR），这是 Kubernetes 生态系统中广泛使用的核心扩展机制之一。
- en: Custom resources are used for small, in-house configuration objects without
    any corresponding controller logic—purely declaratively defined. But custom resources
    also play a central role for many serious development projects on top of Kubernetes
    that want to offer a Kubernetes-native API experience. Examples are service meshes
    such as Istio, Linkerd 2.0, and AWS App Mesh, all of which have custom resources
    at their heart.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源用于小型内部配置对象，没有对应的控制器逻辑——纯粹以声明方式定义。但是对于许多希望提供 Kubernetes 本地 API 体验的严肃开发项目而言，自定义资源也扮演着核心角色。例如服务网格，如
    Istio、Linkerd 2.0 和 AWS App Mesh，它们都以自定义资源为核心。
- en: 'Remember “A Motivational Example” from [Chapter 1](ch01.html#intro)? At its
    core, it has a CR that looks like this:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得 [第 1 章](ch01.html#intro) 中的“激励性例子”吗？其核心是像这样的 CR：
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Custom resources are available in every Kubernetes cluster since version 1.7\.
    They are stored in the same `etcd` instance as the main Kubernetes API resources
    and served by the same Kubernetes API server. As shown in [Figure 4-1](#apiextensions-apiserver),
    requests fall back to the `apiextensions-apiserver`, which serves the resources
    defined via CRDs, if they are neither of the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Kubernetes 1.7 版本以来，每个 Kubernetes 集群都可以使用自定义资源。它们存储在与主 Kubernetes API 资源相同的
    `etcd` 实例中，并由相同的 Kubernetes API 服务器提供。如 [图 4-1](#apiextensions-apiserver) 所示，如果资源不属于以下任何一种，请求将回退到
    `apiextensions-apiserver`，它通过 CRD 定义的资源。
- en: Handled by aggregated API servers (see [Chapter 8](ch08.html#ch_custom-api-servers)).
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由聚合 API 服务器处理（参见 [第 8 章](ch08.html#ch_custom-api-servers)）。
- en: Native Kubernetes resources.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原生 Kubernetes 资源。
- en: '![API Extensions API server inside of the Kubernetes API server](assets/prku_0401.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Kubernetes API 服务器内部的 API 扩展 API 服务器](assets/prku_0401.png)'
- en: Figure 4-1\. The API Extensions API server inside the Kubernetes API server
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. Kubernetes API 服务器内部的 API 扩展 API 服务器
- en: 'A CustomResourceDefinition (CRD) is a Kubernetes resource itself. It describes
    the available CRs in the cluster. For the preceding example CR, the corresponding
    CRD looks like this:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CustomResourceDefinition（CRD）本身也是 Kubernetes 资源。它描述了集群中可用的 CR。对于前面的示例 CR，相应的
    CRD 如下所示：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The name of the CRD—in this case, `ats.cnat.programming-kubernetes.info`—must
    match the plural name followed by the group name. It defines the kind `At` CR
    in the API group `cnat.programming-kubernetes.info` as a namespaced resource called
    `ats`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: CRD 的名称——在本例中为 `ats.cnat.programming-kubernetes.info`——必须与复数名称和组名匹配。它将 API 组
    `cnat.programming-kubernetes.info` 中的 `At` CR 定义为命名空间资源，称为 `ats`。
- en: 'If this CRD is created in a cluster, `kubectl` will automatically detect the
    resource, and the user can access it via:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此 CRD 在集群中创建，`kubectl` 将自动检测到该资源，用户可以通过以下方式访问它：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Discovery Information
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发现信息
- en: Behind the scenes, `kubectl` uses discovery information from the API server
    to find out about the new resources. Let’s look a bit deeper into this discovery
    mechanism.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`kubectl` 使用来自 API 服务器的发现信息来了解新资源。让我们更深入地了解这个发现机制。
- en: 'After increasing the verbosity level of `kubectl`, we can actually see how
    it learns about the new resource type:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在增加 `kubectl` 的详细级别后，我们可以看到它如何学习有关新资源类型的信息：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The discovery steps in detail are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 发现的详细步骤包括：
- en: Initially, `kubectl` does not know about `ats`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最初，`kubectl` 不知道 `ats`。
- en: Hence, `kubectl` asks the API server about all existing API groups via the */apis*
    discovery endpoint.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，`kubectl` 通过 */apis* 发现端点询问所有现有的 API 组。
- en: Next, `kubectl` asks the API server about resources in all existing API groups
    via the */apis/`group version`* group discovery endpoints.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，`kubectl` 通过 */apis/`group version`* 组发现端点询问所有现有 API 组中的资源。
- en: 'Then, `kubectl` translates the given type, `ats`, to a triple of:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，`kubectl` 将给定的类型 `ats` 转换为三元组：
- en: Group (here `cnat.programming-kubernetes.info`)
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组（这里是 `cnat.programming-kubernetes.info`）
- en: Version (here `v1alpha1`)
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 版本（这里是 `v1alpha1`）
- en: Resource (here `ats`).
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源（这里是 `ats`）。
- en: 'The discovery endpoints provide all the necessary information to do the translation
    in the last step:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 发现端点提供了在最后一步进行转换所需的所有必要信息：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This is all implemented by the discovery `RESTMapper`. We also saw this very
    common type of `RESTMapper` in [“REST Mapping”](ch03.html#RESTMapping).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都由发现 `RESTMapper` 实现。我们还在 [“REST Mapping”](ch03.html#RESTMapping) 中看到了这种非常常见的
    `RESTMapper` 类型。
- en: Warning
  id: totrans-30
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: The `kubectl` CLI also maintains a cache of resource types in *~/.kubectl* so
    that it does not have to re-retrieve the discovery information on every access.
    This cache is invalidated every 10 minutes. Hence, a change in the CRD might show
    up in the CLI of the respective user up to 10 minutes later.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` CLI还在*~/.kubectl*中维护资源类型的缓存，以便在每次访问时无需重新检索发现信息。此缓存每10分钟失效一次。因此，CRD的更改可能会在相应用户的CLI中显示最多10分钟后。'
- en: Type Definitions
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型定义
- en: 'Now let’s look at the CRD and the offered features in more detail: as in the
    `cnat` example, CRDs are Kubernetes resources in the `apiextensions.k8s.io/v1beta1`
    API group provided by the `apiextensions-apiserver` inside the Kubernetes API
    server process.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们更详细地看看CRD和提供的功能：如`cnat`示例中所示，CRD是由Kubernetes API服务器进程内的`apiextensions.k8s.io/v1beta1`
    API组提供的Kubernetes资源。
- en: 'The schema of CRDs looks like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: CRD的模式看起来像这样：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Many of the fields are optional or are defaulted. We will explain the fields
    in more detail in the following sections.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 许多字段是可选的或具有默认值。我们将在以下部分更详细地解释这些字段。
- en: 'After creating a CRD object, the `apiextensions-apiserver` inside of `kube-apiserver`
    will check the names and determine whether they conflict with other resources
    or whether they are consistent in themselves. After a few moments it will report
    the result in the status of the CRD, for example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 创建CRD对象后，`kube-apiserver`内部的`apiextensions-apiserver`将检查名称，并确定它们是否与其他资源冲突或是否在自身中保持一致。几分钟后，它将在CRD的状态中报告结果，例如：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can see that the missing name fields in the spec are defaulted and reflected
    in the status as accepted names. Moreover, the following conditions are set:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到规范中缺少的名称字段被默认，并反映在状态中作为接受的名称。此外，设置了以下条件：
- en: '`NamesAccepted` describes whether the given names in the spec are consistent
    and free of conflicts.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NamesAccepted`描述规范中给定的名称是否一致且无冲突。'
- en: '`Established` describes that the API server serves the given resource under
    the names in `status.acceptedNames`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Established`描述API服务器在`status.acceptedNames`下提供给定资源的名称。'
- en: Note that certain fields can be changed long after the CRD has been created.
    For example, you can add short names or columns. In this case, a CRD can be established—that
    is, served with the old names—although the spec names have conflicts. Hence the
    `NamesAccepted` condition would be false and the spec names and accepted names
    would differ.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，某些字段可以在创建CRD之后很长时间内更改。例如，您可以添加短名称或列。在这种情况下，可以建立一个CRD，即使用旧名称提供服务，尽管规范名称存在冲突。因此，`NamesAccepted`条件将为false，规范名称和接受名称将不同。
- en: Advanced Features of Custom Resources
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义资源的高级特性
- en: In this section we discuss advanced features of custom resources, such as validation
    or subresources.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论自定义资源的高级特性，例如验证或子资源。
- en: Validating Custom Resources
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证自定义资源
- en: CRs can be validated by the API server during creation and updates. This is
    done based on the [OpenAPI v3 schema](http://bit.ly/2RqtN5i) specified in the
    `validation` fields in the CRD spec.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: CR可以在创建和更新期间由API服务器进行验证。这是基于[OpenAPI v3模式](http://bit.ly/2RqtN5i)在CRD规范中的`validation`字段指定的。
- en: When a request creates or mutates a CR, the JSON object in the spec is validated
    against this spec, and in case of errors the conflicting field is returned to
    the user in an HTTP code `400` response. [Figure 4-2](#apiextensions-apiserver-validation)
    shows where validation takes places in the request handler inside the `apiextensions-apiserver`.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当请求创建或改变CR时，规范中的JSON对象将根据此规范进行验证，如果出现错误，则冲突字段将以HTTP代码`400`响应返回给用户。[图 4-2](#apiextensions-apiserver-validation)显示了在`apiextensions-apiserver`内的请求处理程序中进行验证的位置。
- en: More complex validations can be implemented in validating admission webhooks—that
    is, in a Turing-complete programming language. [Figure 4-2](#apiextensions-apiserver-validation)
    shows that these webhooks are called directly after the OpenAPI-based validations
    described in this section. In [“Admission Webhooks”](ch09.html#admission-webhooks),
    we will see how admission webhooks are implemented and deployed. There, we’ll
    look into validations that take other resources into account and therefore go
    far beyond OpenAPI v3 validation. Luckily, for many use cases OpenAPI v3 schemas
    are sufficient.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 更复杂的验证可以通过验证入站 Webhook 实现，即在一个图灵完备的编程语言中。[图 4-2](#apiextensions-apiserver-validation)
    显示了这些 Webhook 在本节描述的基于 OpenAPI 的验证之后直接调用的情况。在 [“Admission Webhooks”](ch09.html#admission-webhooks)
    中，我们将看到如何实现和部署 Admission Webhook。在那里，我们将探讨需要考虑其他资源的验证，因此远远超出了 OpenAPI v3 验证的范围。幸运的是，对于许多用例来说，OpenAPI
    v3 模式已经足够了。
- en: '![Validation step in the handler stack of the `apiextensions-apiserver`](assets/prku_0402.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![apiextensions-apiserver 处理程序堆栈中的验证步骤](assets/prku_0402.png)'
- en: Figure 4-2\. Validation step in the handler stack of the apiextensions-apiserver
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. `apiextensions-apiserver` 处理程序堆栈中的验证步骤。
- en: 'The OpenAPI schema language is based on the [JSON Schema standard](http://bit.ly/2J7aIT7),
    which uses JSON/YAML itself to express a schema. Here’s an example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: OpenAPI 模式语言基于 [JSON Schema 标准](http://bit.ly/2J7aIT7)，它使用 JSON/YAML 来表达模式。以下是一个示例：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This schema specifies that the value is actually a JSON object;^([1](ch04.html#idm46336863073336))
    that is, it is a string map and not a slice or a value like a number. Moreover,
    it has (aside from `metadata`, `kind`, and `apiVersion`, which are implicitly
    defined for custom resources) two additional properties: `spec` and `status`.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式指定该值实际上是一个 JSON 对象；^([1](ch04.html#idm46336863073336)) 也就是说，它是一个字符串映射，而不是一个切片或者像数字那样的值。此外，除了自定义资源隐式定义的
    `metadata`、`kind` 和 `apiVersion` 外，还有两个额外的属性：`spec` 和 `status`。
- en: Each is a JSON object as well. `spec` has the required fields `schedule` and
    `command`, both of which are strings. `schedule` has to match a pattern for an
    ISO date (sketched here with some regular expressions). The optional `status`
    property has a string field called `phase`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 每个也是一个 JSON 对象。`spec` 也有两个必填字段 `schedule` 和 `command`，它们都是字符串。`schedule` 必须匹配
    ISO 日期的模式（这里用一些正则表达式进行了概述）。可选的 `status` 属性有一个称为 `phase` 的字符串字段。
- en: 'Creating OpenAPI schemata manually can be tedious. Luckily, work is underway
    to make this much easier via code generation: the Kubebuilder project—see [“Kubebuilder”](ch06.html#kubebuilder)—has
    developed [`crd-gen` in *sig.k8s.io/controller-tools*](http://bit.ly/2J00kvi),
    and this is being extended step by step so that it’s usable in other contexts.
    The generator [`crd-schema-gen`](http://bit.ly/31N0eQf) is a fork of `crd-gen`
    in this direction.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 手动创建 OpenAPI 模式可能会很繁琐。幸运的是，通过代码生成正在进行的工作使这个过程变得更加简单：Kubebuilder 项目——参见 [“Kubebuilder”](ch06.html#kubebuilder)——开发了
    *sig.k8s.io/controller-tools* 中的 `crd-gen`，并逐步扩展到可以在其他环境中使用。生成器 `crd-schema-gen`
    是 `crd-gen` 在这个方向上的一个分支。
- en: Short Names and Categories
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 短名称和类别
- en: Like native resources, custom resources might have long resource names. They
    are great on the API level but tedious to type in the CLI. CRs can have short
    names as well, like the native resource `daemonsets`, which can be queried with
    `kubectl get ds`. These short names are also known as aliases, and each resource
    can have any number of them.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与原生资源类似，自定义资源可能具有较长的资源名称。它们在 API 级别上非常好用，但在 CLI 中键入时可能很繁琐。CRs 也可以有短名称，比如原生资源
    `daemonsets`，可以使用 `kubectl get ds` 来查询。这些短名称也称为别名，每个资源可以有任意数量的别名。
- en: 'To view all of the available short names, use the `kubectl api-resources` command
    like so:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有可用的短名称，请使用如下命令：`kubectl api-resources`。
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Again, `kubectl` learns about short names via discovery information (see [“Discovery
    Information”](#discovery)). Here is an example:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`kubectl` 通过发现信息了解有关短名称的信息（参见 [“Discovery Information”](#discovery)）。以下是一个示例：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After that, a `kubectl get at` will list all `cnat` CRs in the namespace.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，`kubectl get at` 将列出命名空间中的所有 `cnat` CR。
- en: Further, CRs—as with any other resource—can be part of categories. The most
    common use is the `all` category, as in `kubectl get all`. It lists all user-facing
    resources in a cluster, like pods and services.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，CRs——与任何其他资源一样——可以成为类别的一部分。最常见的用法是 `all` 类别，例如 `kubectl get all`。它列出集群中所有面向用户的资源，如
    pods 和 services。
- en: 'The CRs defined in the cluster can join a category or create their own category
    via the `categories` field:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在集群中定义的 CR 可以通过 `categories` 字段加入类别或创建自己的类别：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: With this, `kubectl get all` will also list the `cnat` CR in the namespace.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，`kubectl get all`还将在命名空间中列出`cnat` CR。
- en: Printer Columns
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印列
- en: The `kubectl` CLI tool uses server-side printing to render the output of `kubectl
    get`. This means that it queries the API server for the columns to display and
    the values in each row.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` CLI工具使用服务器端打印来呈现`kubectl get`的输出。这意味着它查询API服务器以获取要显示的列和每行中的值。'
- en: 'Custom resources support server-side printer columns as well, via `additionalPrinterColumns`.
    They are called “additional” because the first column is always the name of the
    object. These columns are defined like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源还支持通过`additionalPrinterColumns`定义服务器端打印列。它们称为“附加”列，因为第一列始终是对象的名称。这些列定义如下：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `name` field is the column name, the `type` is an OpenAPI type as defined
    in the [data types](http://bit.ly/2N0DSY4) section of the specification, and the
    `format` (as defined in the same document) is optional and might be interpreted
    by `kubectl` or other clients.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`name`字段是列名，`type`是OpenAPI类型，如规范中的[data types](http://bit.ly/2N0DSY4)部分定义，`format`（如同一文档中定义的）是可选的，可能会被`kubectl`或其他客户端解释。'
- en: Further, `description` is an optional human-readable string, used for documentation
    purposes. The `priority` controls in which verbosity mode of `kubectl` the column
    is displayed. At the time of this writing (with Kubernetes 1.14), only zero is
    supported, and all columns with higher priority are hidden.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`description`是一个可选的人类可读字符串，用于文档目的。`priority`控制了`kubectl`的显示详细模式。在撰写本文时（使用Kubernetes
    1.14），仅支持零，并且所有优先级高于零的列都将隐藏。
- en: Finally, `JSONPath` defines which values are to be displayed. It is a simple
    JSON path inside of the CR. Here, “simple” means that it supports object field
    syntax like `.spec.foo.bar`, but not more complex JSON paths that loop over arrays
    or similar.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`JSONPath`定义了要显示的值。它是CR内的简单JSON路径。这里的“简单”意味着它支持对象字段语法，如`.spec.foo.bar`，但不支持更复杂的循环数组或类似的JSON路径。
- en: 'With this, the example CRD from the introduction could be extended with `additionalPrinterColumns`
    like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，可以像这样扩展介绍中的示例CRD，添加`additionalPrinterColumns`：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then `kubectl` would render a `cnat` resource as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后`kubectl`将以以下方式呈现`cnat`资源：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next up, we have a look at subresources.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看子资源。
- en: Subresources
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子资源
- en: 'We briefly mentioned subresources in [“Status Subresources: UpdateStatus”](ch03.html#client-go-subresource).
    Subresources are special HTTP endpoints, using a suffix appended to the HTTP path
    of the normal resource. For example, the pod standard HTTP path is */api/v1/namespace/`namespace`/pods/`name`*.
    Pods have a number of subresources, such as */logs*, */portforward*, */exec*,
    and */status*. The corresponding subresource HTTP paths are:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“状态子资源：UpdateStatus”](ch03.html#client-go-subresource)中简要提到了子资源。子资源是特殊的HTTP端点，使用附加到正常资源的HTTP路径后缀。例如，Pod的标准HTTP路径是*/api/v1/namespace/`namespace`/pods/`name`*。Pod具有多个子资源，如*/logs*、*/portforward*、*/exec*和*/status*。相应的子资源HTTP路径如下：
- en: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/logs*'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/logs*'
- en: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/portforward*'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/portforward*'
- en: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/exec*'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/exec*'
- en: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/status*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*/api/v1/namespace/*`namespace`*/pods/*`name`*/status*'
- en: The subresource endpoints use a different protocol than the main resource endpoint.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 子资源端点使用与主资源端点不同的协议。
- en: 'At the time of this writing, custom resources support two subresources: */scale*
    and */status*. Both are opt-in—that is, they must be explicitly enabled in the
    CRD.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，自定义资源支持两个子资源：*/scale*和*/status*。两者都是选择性的，即在CRD中必须显式启用它们。
- en: Status subresource
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态子资源
- en: 'The */status* subresource is used to split the user-provided specification
    of a CR instance from the controller-provided status. The main motivation for
    this is privilege separation:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*/status*子资源用于将CR实例的用户提供的规范与控制器提供的状态分开。这样做的主要动机是特权分离：'
- en: The user usually should not write status fields.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户通常不应编写状态字段。
- en: The controller should not write specification fields.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制器不应编写规范字段。
- en: 'The RBAC mechanism for access control does not allow rules at that level of
    detail. Those rules are always per resource. The */status* subresource solves
    this by providing two endpoints that are resources on their own. Each can be controlled
    with RBAC rules independently. This is often called a *spec-status split*. Here’s
    an example of such a rule for the `ats` resource, which applies only to the */status*
    subresource (while `"ats"` would match the main resource):'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 访问控制的 RBAC 机制不允许在该级别的规则。这些规则始终是每个资源独立的。*/status* 子资源通过提供两个独立的端点来解决这个问题。每个端点可以独立地通过
    RBAC 规则进行控制。这通常被称为 *spec-status split* 的例子是对 `ats` 资源的规则，仅适用于 */status* 子资源（而
    `"ats"` 将匹配主资源）：
- en: '[PRE14]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Resources (including custom resources) that have a */status* subresource have
    changed semantics, also for the main resource endpoint:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有 */status* 子资源的资源（包括自定义资源）语义发生了变化，同样适用于主资源端点：
- en: They ignore changes to the status on the main HTTP endpoint during create (the
    status is just dropped during a create) and updates.
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建期间（在创建期间状态只是被丢弃）和更新期间，它们忽略在主 HTTP 端点上对状态的更改。
- en: Likewise, the */status* subresource endpoint ignores changes outside of the
    status of the payload. A create operation on the */status* endpoint is not possible.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样地，*/status* 子资源端点忽略负载状态以外的更改。在 */status* 端点上的创建操作是不可能的。
- en: Whenever something outside of `metadata` and outside of `status` changes (this
    especially means changes in the spec), the main resource endpoint will increase
    the `metadata.generation` value. This can be used as a trigger for a controller
    indicating that the user desire has changed.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每当 `metadata` 以外和 `status` 以外的内容发生变化（尤其是规范中的变化），主资源端点将增加 `metadata.generation`
    的值。这可用作控制器的触发器，指示用户的需求已变更。
- en: Note that usually both `spec` and `status` are sent in update requests, but
    technically you could leave out the respective other part in a request payload.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意通常在更新请求中同时发送 `spec` 和 `status`，但从技术上讲，你可以在请求负载中省略另一个相应的部分。
- en: Also note that the */status* endpoint will ignore everything outside of the
    status, including metadata changes like labels or annotations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意 */status* 端点将忽略状态以外的所有内容，包括标签或注解的元数据更改。
- en: 'The spec-status split of a custom resource is enabled as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源的 *spec-status* 分离启用如下：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note here that the `status` field in that YAML fragment is assigned the empty
    object. This is the way to set a field that has no other properties. Just writing
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里注意，在该 YAML 片段中，`status` 字段被分配为空对象。这是设置一个没有其他属性的字段的方法。只需写
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: will result in a validation error because in YAML the result is a `null` value
    for `status`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 会导致验证错误，因为在 YAML 中结果为 `status` 的值是 `null`。
- en: Warning
  id: totrans-104
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Enabling the spec-status split is a breaking change for an API. Old controllers
    will write to the main endpoint. They won’t notice that the status is always ignored
    from the point where the split is activated. Likewise, a new controller can’t
    write to the new */status* endpoint until the split is activated.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 启用 `spec-status` 分离对 API 是一个破坏性的变更。旧控制器将写入主要的端点。他们不会注意到从启用分离的那一刻起状态总是被忽略。同样，新控制器在分离启用之前不能写入新的
    */status* 端点。
- en: 'In Kubernetes 1.13 and later, subresources can be configured per version. This
    allows us to introduce the */status* subresource without a breaking change:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 1.13 及更高版本中，可以按版本配置子资源。这使我们可以引入 */status* 子资源而不会引入破坏性变更：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This enables the */status* subresource for `v1beta1`, but not for `v1alpha1`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得 `v1beta1` 可以使用 */status* 子资源，但 `v1alpha1` 不行。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The optimistic concurrency semantics (see [“Optimistic Concurrency”](ch01.html#optimistic-concurrency))
    are the same as for the main resource endpoints; that is, `status` and `spec`
    share the same resource version counter and */status* updates can conflict due
    to writes to the main resource, and vice versa. In other words, there is no split
    of `spec` and `status` on the storage layer.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 乐观并发语义（参见 [“乐观并发”](ch01.html#optimistic-concurrency)）与主资源端点相同；即 `status` 和 `spec`
    共享相同的资源版本计数器，因此 */status* 更新可能由于对主资源的写入而发生冲突，反之亦然。换句话说，存储层没有 `spec` 和 `status`
    的分离。
- en: Scale subresource
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放子资源
- en: The second subresource available for custom resources is */scale*. The */scale*
    subresource is a (projective)^([2](ch04.html#idm46336862332104)) view on the resource,
    allowing us to view and to modify replica values only. This subresource is well
    known for resources like deployments and replica sets in Kubernetes, which obviously
    can be scaled up and down.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义资源的第二个子资源是*/scale*。*/scale*子资源是资源的（投影）^([2](ch04.html#idm46336862332104))视图，允许我们仅查看和修改复制品值。这个子资源对于Kubernetes中的部署和副本集等资源是众所周知的，这些资源显然可以进行水平扩展和缩减。
- en: 'The `kubectl scale` command makes use of the */scale* subresource; for example,
    the following will modify the specified replica value in the given instance:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl scale`命令使用*/scale*子资源；例如，以下命令将修改给定实例中指定的复制品值：'
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: With this, an update of the replica value is written to `spec.replicas` and
    returned from there during a `GET`.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更新复制品值的过程中，写入了`spec.replicas`并在`GET`期间从那里返回。
- en: The label selector cannot be changed through the */status* subresource, only
    read. Its purpose is to give a controller the information to count the corresponding
    objects. For example, the `ReplicaSet` controller counts the corresponding pods
    that satisfy this selector.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 不能通过*/status*子资源更改标签选择器，只能读取。它的目的是为控制器提供信息，以计算满足此选择器的相应对象。例如，`ReplicaSet`控制器计算满足此选择器的相应Pod数。
- en: The label selector is optional. If your custom resource semantics do not fit
    label selectors, just don’t specify the JSON path for one.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 标签选择器是可选的。如果您的自定义资源语义不适合标签选择器，只需不为其指定JSON路径即可。
- en: In the previous example of `kubectl scale --replicas=3 ...` the value `3` is
    written to `spec.replicas`. Any other simple JSON path can be used, of course;
    for example, `spec.instances` or `spec.size` would be a sensible field name, depending
    on the context.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述`kubectl scale --replicas=3 ...`示例中，值`3`被写入`spec.replicas`。当然也可以使用其他简单的JSON路径；例如，根据上下文，`spec.instances`或`spec.size`将是一个合理的字段名称。
- en: 'The kind of the object read from or written to the endpoint is `Scale` from
    the `autoscaling/v1` API group. Here is what it looks like:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 从端点读取或写入的对象的种类是来自`autoscaling/v1` API组的`Scale`。它的外观如下：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'An instance will look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个实例看起来像这样：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note that the optimistic concurrency semantics are the same for the main resource
    and for the */scale* subresource. That is, main resource writes can conflict with
    */scale* writes, and vice versa.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，乐观并发语义对主资源和*/scale*子资源是相同的。也就是说，主资源的写入可能与*/scale*写入冲突，反之亦然。
- en: A Developer’s View on Custom Resources
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者对自定义资源的看法
- en: 'Custom resources can be accessed from Golang using a number of clients. We
    will concentrate on:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多种客户端从Golang访问自定义资源。我们将集中讨论以下内容：
- en: Using the `client-go` dynamic client (see [“Dynamic Client”](#dynamic-client))
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`client-go`动态客户端（参见[“动态客户端”](#dynamic-client)）
- en: 'Using a typed client:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型化的客户端：
- en: As provided by [kubernetes-sigs/controller-runtime](http://bit.ly/2ZFtDKd) and
    used by the Operator SDK and Kubebuilder (see [“controller-runtime Client of Operator
    SDK and Kubebuilder”](#controller-runtime))
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由[kubernetes-sigs/controller-runtime](http://bit.ly/2ZFtDKd)提供，并由Operator SDK和Kubebuilder使用（参见[“Operator
    SDK和Kubebuilder的controller-runtime客户端”](#controller-runtime)）。
- en: As generated by `client-gen`, like that in [*k8s.io/client-go/kubernetes*](http://bit.ly/2FnmGWA)
    (see [“Typed client created via client-gen”](#clientgen-client))
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由`client-gen`生成，例如[*k8s.io/client-go/kubernetes*](http://bit.ly/2FnmGWA)中的（参见[“通过client-gen创建的类型化客户端”](#clientgen-client)）。
- en: The choice of which client to use depends mainly on the context of the code
    to be written, especially the complexity of implemented logic and the requirements
    (e.g., to be dynamic and to support GVKs unknown at compile time).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哪种客户端主要取决于要编写的代码的上下文，特别是实现逻辑的复杂性和要求（例如，是否需要动态和支持编译时未知的GVK）。
- en: 'The preceding list of clients:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前述客户端列表：
- en: Decreases in the flexibility to handle unknown GVKs.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 降低处理未知GVK的灵活性。
- en: Increases in type safety.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型安全性的增加。
- en: Increases in the completeness of features of the Kubernetes API they provide.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加提供的Kubernetes API功能的完整性。
- en: Dynamic Client
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态客户端
- en: The dynamic client in [*k8s.io/client-go/dynamic*](http://bit.ly/2Y6eeSK) is
    totally agnostic to known GVKs. It does not even use any Go types other than [*unstructured.Unstructured*](http://bit.ly/2WYZ6oS),
    which wraps just `json.Unmarshal` and its output.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[*k8s.io/client-go/dynamic*](http://bit.ly/2Y6eeSK)中的动态客户端完全与已知的GVKs无关。它甚至不使用除[*unstructured.Unstructured*](http://bit.ly/2WYZ6oS)外的任何Go类型，后者仅包装了`json.Unmarshal`及其输出。'
- en: 'The dynamic client makes use of neither a scheme nor a RESTMapper. This means
    that the developer has to provide all the knowledge about types manually by providing
    a resource (see [“Resources”](ch03.html#resources)) in the form of a GVR:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 动态客户端既不使用方案（scheme）也不使用 RESTMapper。这意味着开发者必须通过提供 GVR 形式的资源（参见[“资源”](ch03.html#resources)）手动提供关于类型的所有知识：
- en: '[PRE22]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If a REST client config is available (see [“Creating and Using a Client”](ch03.html#rest-client-config)),
    the dynamic client can be created in one line:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在 REST 客户端配置（参见[“创建和使用客户端”](ch03.html#rest-client-config)），动态客户端可以在一行中创建：
- en: '[PRE23]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The REST access to a given GVR is just as simple:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 对给定 GVR 的 REST 访问同样简单：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This gives you the deployment `foo` in the given namespace.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这为您提供了在给定命名空间中的部署`foo`。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: You must know the scope of the resource (i.e., whether it is namespaced or cluster-scoped).
    Cluster-scoped resources just leave out the `Namespace(namespace)` call.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须了解资源的范围（即它是命名空间范围的还是集群范围的）。集群范围的资源只需省略`Namespace(namespace)`调用。
- en: 'The input and output of the dynamic client is an `*unstructured.Unstructured`—that
    is, an object that contains the same data structure that `json.Unmarshal` would
    output on unmarshaling:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 动态客户端的输入和输出是`*unstructured.Unstructured`—即一个包含与`json.Unmarshal`在解组时输出相同数据结构的对象：
- en: Objects are represented by `map[string]interface{}`.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象由`map[string]interface{}`表示。
- en: Arrays are represented by `[]interface{}`.
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组由`[]interface{}`表示。
- en: Primitive types are `string`, `bool`, `float64`, or `int64`.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原始类型是`string`、`bool`、`float64`或`int64`。
- en: 'The method `UnstructuredContent()` provides access to this data structure inside
    of an unstructured object (we can also just access `Unstructured.Object`). There
    are helpers in the same package to make retrieval of fields easy and manipulation
    of the object possible—for example:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 方法`UnstructuredContent()`提供对非结构化对象内部数据结构的访问（我们也可以直接访问`Unstructured.Object`）。同一包中有助手函数使得字段的检索变得容易，并且可以对对象进行操作，例如：
- en: '[PRE25]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'which returns the name of the deployment—`"foo"` in this case. `found` is true
    if the field was actually found (not only empty, but actually existing). `err`
    reports if the type of an existing field is unexpected (i.e., not a string in
    this case). Other helpers are the generic ones, once with a deep copy of the result
    and once without:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 返回部署名称——在这种情况下是`"foo"`。如果字段确实存在（不仅仅是空的，而是确实存在），则`found`为`true`。`err`报告如果现有字段的类型是意外的（在这种情况下不是字符串）。其他帮助函数是通用的，一次是结果的深度拷贝，一次没有：
- en: '[PRE26]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'There are other typed variants that do a type-cast and return an error if that
    fails:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他的类型化变体，如果类型转换失败则返回错误：
- en: '[PRE27]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And finally a generic setter:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是一个通用的设置器：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The dynamic client is used in Kubernetes itself for controllers that are generic,
    like the garbage collection controller, which deletes objects whose parents have
    disappeared. The garbage collection controller works with any resource in the
    system and hence makes extensive use of the dynamic client.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 动态客户端在 Kubernetes 中本身用于通用控制器，例如垃圾回收控制器，它删除其父对象消失的对象。垃圾回收控制器可以处理系统中的任何资源，因此广泛使用动态客户端。
- en: Typed Clients
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型化客户端
- en: Typed clients do not use `map[string]interface{}`-like generic data structures
    but instead use real Golang types, which are different and specific for each GVK.
    They are much easier to use, have considerably increased type safety, and make
    code much more concise and readable. On the downside, they are less flexible because
    the processed types have to be known at compile time, and those clients are generated,
    and this adds complexity.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 类型化客户端不使用类似`map[string]interface{}`的通用数据结构，而是使用真正的 Golang 类型，这些类型对于每个 GVK 都是不同的和特定的。它们更容易使用，具有显著增加的类型安全性，并且使代码更加简洁和可读。但缺点是，它们不太灵活，因为处理的类型必须在编译时已知，并且这些客户端是生成的，这增加了复杂性。
- en: Before going into two implementations of typed clients, let’s look into the
    representation of kinds in the Golang type system (see [“API Machinery in Depth”](ch03.html#api-machinery-core)
    for the theory behind the Kubernetes type system).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入类型化客户端的两个实现之前，让我们深入了解 Golang 类型系统中的种类表示（参见[“深入理解 API 机制”](ch03.html#api-machinery-core)了解
    Kubernetes 类型系统背后的理论）。
- en: Anatomy of a type
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 类型的解剖
- en: 'Kinds are represented as Golang structs. Usually the struct is named as the
    kind (though technically it doesn’t have to be) and is placed in a package corresponding
    to the group and version of the GVK at hand. A common convention is to place the
    GVK *`group`*/*`version`*.*`Kind`* into a Go package:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 类型以Golang结构体表示。通常，结构体的命名与其类型相同（尽管从技术上讲不一定如此），并且放置在与手头GVK的组和版本对应的包中。一个常见的约定是将GVK
    *`group`*/*`version`*.*`Kind`*放入一个Go包中：
- en: '[PRE29]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: and define a Golang struct *`Kind`* in the file *types.go*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 并在文件*types.go*中定义一个Golang结构体*`Kind`*。
- en: 'Every Golang type corresponding to a GVK embeds the `TypeMeta` struct from
    the package [*k8s.io/apimachinery/pkg/apis/meta/v1*](http://bit.ly/2Y5HdWT). `TypeMeta`
    just consists of the `Kind` and `ApiVersion` fields:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 每个对应于GVK的Golang类型都嵌入来自包[*k8s.io/apimachinery/pkg/apis/meta/v1*](http://bit.ly/2Y5HdWT)的`TypeMeta`结构体。
    `TypeMeta`仅由`Kind`和`ApiVersion`字段组成：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In addition, every top-level kind—that is, one that has its own endpoint and
    therefore one (or more) corresponding GVRs (see [“REST Mapping”](ch03.html#RESTMapping))—has
    to store a name, a namespace for namespaced resources, and a pretty long number
    of further metalevel fields. All these are stored in a struct called `ObjectMeta`
    in the package [*k8s.io/apimachinery/pkg/apis/meta/v1*](http://bit.ly/2XSt8eo):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个顶级类型——即具有自己的端点和因此一个（或多个）对应的GVR（参见[“REST映射”](ch03.html#RESTMapping)）——必须存储名称，对于命名空间资源的命名空间，以及一系列非常多的进一步的元层字段。所有这些都存储在一个名为`ObjectMeta`的结构体中，位于包[*k8s.io/apimachinery/pkg/apis/meta/v1*](http://bit.ly/2XSt8eo)中：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There are a number of additional fields. We highly recommend you read through
    the [extensive inline documentation](http://bit.ly/2IutNyh), because it gives
    a good picture of the core functionality of Kubernetes objects.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些额外的字段。我们强烈建议您仔细阅读[详细的内联文档](http://bit.ly/2IutNyh)，因为它很好地展示了Kubernetes对象的核心功能。
- en: 'Kubernetes top-level types (i.e., those that have an embedded `TypeMeta`, and
    an embedded `ObjectMeta`, and—in this case—are persisted into `etcd`) look very
    similar to each other in the sense that they usually have a `spec` and a `status`.
    See this example of a deployment from [*k8s.io/kubernetes/apps/v1/types.go*](http://bit.ly/2RroTFb):'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes顶层类型（即具有嵌入的`TypeMeta`和`ObjectMeta`，并且在这种情况下被持久化到`etcd`中）在外观上非常相似，因为它们通常具有一个`spec`和一个`status`。参见来自[*k8s.io/kubernetes/apps/v1/types.go*](http://bit.ly/2RroTFb)的部署示例：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: While the actual content of the types for `spec` and `status` differs significantly
    between different types, this split into `spec` and `status` is a common theme
    or even a convention in Kubernetes, though it’s not technically required. Hence,
    it is good practice to follow this structure of CRDs as well. Some CRD features
    even require this structure; for example, the */status* subresource for custom
    resources (see [“Status subresource”](#status-subresource))—when enabled—always
    applies to the `status` substructure only of the custom resource instance. It
    cannot be renamed.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`spec`和`status`类型的实际内容在不同类型之间有显著差异，但是将其分为`spec`和`status`在Kubernetes中是一个常见的主题或约定，尽管从技术上讲并非必须如此。因此，跟随CRD的这种结构是一个良好的做法。某些CRD功能甚至要求这种结构；例如，用于自定义资源的*/status*子资源（见[“状态子资源”](#status-subresource)）——当启用时——始终仅适用于自定义资源实例的`status`子结构。它无法重命名。
- en: Golang package structure
  id: totrans-175
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Golang包结构
- en: As we have seen, the Golang types are traditionally placed in a file called
    *types.go* in the package *pkg/apis/`group`/`version`*. In addition to that file,
    there are a couple more files we want to go through now. Some of them are manually
    written by the developer, while some are generated with code generators. See [Chapter 5](ch05.html#ch_autocodegen)
    for details.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Golang类型传统上放置在包*pkg/apis/`group`/`version`*的文件*types.go*中。除了该文件外，我们还要浏览几个文件。一些是由开发人员手动编写的，而一些是使用代码生成器生成的。有关详细信息，请参阅[第5章](ch05.html#ch_autocodegen)。
- en: 'The *doc.go* file describes the API’s purpose and includes a number of package-global
    code generation tags:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '*doc.go*文件描述了API的目的，并包含一些包全局的代码生成标签：'
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, *register.go* includes helpers to register the custom resource Golang
    types into a scheme (see [“Scheme”](ch03.html#scheme)):'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，*register.go*包括帮助程序，将自定义资源的Golang类型注册到方案中（参见[“Scheme”](ch03.html#scheme)）：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Then, *zz_generated.deepcopy.go* defines deep-copy methods on the custom resource
    Golang top-level types (i.e., `SomeKind` and `SomeKindList` in the preceding example
    code). In addition, all substructs (like those for the `spec` and `status`) become
    deep-copyable as well.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，*zz_generated.deepcopy.go* 在自定义资源的 Golang 顶层类型上定义了深度复制方法（例如，在前面的示例代码中的 `SomeKind`
    和 `SomeKindList`）。此外，所有子结构（如 `spec` 和 `status`）也变得可以深度复制。
- en: Because the example uses the tag `+k8s:deepcopy-gen=package` in *doc.go*, the
    deep-copy generation is on an opt-out basis; that is, `DeepCopy` methods are generated
    for every type in the package that does not opt out with `+k8s:deepcopy-gen=false`.
    See [Chapter 5](ch05.html#ch_autocodegen) and especially [“deepcopy-gen Tags”](ch05.html#deepcopy-tags)
    for more details.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因为示例中在 *doc.go* 中使用了标签 `+k8s:deepcopy-gen=package`，所以深度复制生成是基于 opt-out 基础的；也就是说，对于不使用
    `+k8s:deepcopy-gen=false` 退出的包中的每种类型，都会生成 `DeepCopy` 方法。详见 [第五章](ch05.html#ch_autocodegen)
    和特别是 [“deepcopy-gen Tags”](ch05.html#deepcopy-tags) 获取更多细节。
- en: Typed client created via client-gen
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过 client-gen 生成的类型化客户端
- en: With the API package *pkg/apis/`group`/`version`* in place, the client generator
    `client-gen` creates a typed client (see [Chapter 5](ch05.html#ch_autocodegen)
    for details, especially [“client-gen Tags”](ch05.html#clientgen-tags)), in *pkg/generated/clientset/versioned*
    by default (pkg/client/clientset/versioned in old versions of the generator).
    More precisely, the generated top-level object is a client set. It subsumes a
    number of API groups, versions, and resources.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 API 包 *pkg/apis/`group`/`version`*，客户端生成器 `client-gen` 创建了一个类型化的客户端（详见 [第五章](ch05.html#ch_autocodegen)，特别是
    [“client-gen Tags”](ch05.html#clientgen-tags)），默认情况下在 *pkg/generated/clientset/versioned*
    中（在旧版生成器中是 pkg/client/clientset/versioned）。更准确地说，生成的顶层对象是一个客户端集。它涵盖了多个 API 组、版本和资源。
- en: 'The [top-level file](http://bit.ly/2GdcikH) looks like the following:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '[顶层文件](http://bit.ly/2GdcikH) 如下所示：'
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The client set is represented by the interface `Interface` and gives access
    to the API group client interface for each version—for example, `CnatV1alpha1Interface`
    in this sample code:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端集由接口 `Interface` 表示，并为每个版本的 API 组客户端接口提供访问，例如，在此示例代码中是 `CnatV1alpha1Interface`：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'An instance of a client set can be created with the `NewForConfig` helper function.
    This is analogous to the clients for core Kubernetes resources discussed in [“Creating
    and Using a Client”](ch03.html#rest-client-config):'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `NewForConfig` 辅助函数创建客户端集的实例。这类似于讨论的核心 Kubernetes 资源的客户端，详见 [“Creating
    and Using a Client”](ch03.html#rest-client-config)：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, the code generation machinery allows us to program logic for
    custom resources in the very same way as for core Kubernetes resources. Higher-level
    tools like informers are also available; see `informer-gen` in [Chapter 5](ch05.html#ch_autocodegen).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，代码生成机制使我们可以以与核心 Kubernetes 资源完全相同的方式编写自定义资源的逻辑。还提供了像 informers 这样的高级工具；在
    [第五章](ch05.html#ch_autocodegen) 中查看 `informer-gen`。
- en: controller-runtime Client of Operator SDK and Kubebuilder
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Operator SDK 和 Kubebuilder 的 controller-runtime 客户端
- en: For the sake of completeness, we want to take a quick look at the third client,
    which is listed as the second option in [“A Developer’s View on Custom Resources”](#crd-dev).
    The `controller-runtime` project provides the basis for the operator solutions
    Operator SDK and Kubebuilder presented in [Chapter 6](ch06.html#ch_operator-solutions).
    It includes a client that uses the Go types presented in [“Anatomy of a type”](#anatomy-of-CRD-types).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完整起见，我们想快速查看第三个客户端，它被列为 [“A Developer’s View on Custom Resources”](#crd-dev)
    中的第二个选项。`controller-runtime` 项目提供了操作员解决方案 Operator SDK 和 Kubebuilder 的基础，包括一个使用在
    [“Anatomy of a type”](#anatomy-of-CRD-types) 中介绍的 Go 类型的客户端。
- en: In contrast to the `client-gen`–generated client of the previous [“Typed client
    created via client-gen”](#clientgen-client), and similarly to the [“Dynamic Client”](#dynamic-client),
    this client is one instance, capable of handling any kind that is registered in
    a given scheme.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 与以前 [“Typed client created via client-gen”](#clientgen-client) 生成的客户端相比，以及与
    [“Dynamic Client”](#dynamic-client) 类似，这个客户端是一个实例，能够处理注册在给定方案中的任何类型。
- en: It uses discovery information from the API server to map the kinds to HTTP paths.
    Note that [Chapter 6](ch06.html#ch_operator-solutions) will go into greater detail
    on how this client is used as part of those two operator solutions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用来自 API 服务器的发现信息将种类映射到 HTTP 路径。请注意，[第六章](ch06.html#ch_operator-solutions)
    将更详细地讨论此客户端作为这两个操作员解决方案的一部分的使用方式。
- en: 'Here is a quick example of how to use `controller-runtime`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用 `controller-runtime` 的快速示例：
- en: '[PRE38]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The client object’s `List()` method accepts any `runtime.Object` registered
    in the given scheme, which in this case is the one borrowed from `client-go` with
    all standard Kubernetes kinds being registered. Internally, the client uses the
    given scheme to map the Golang type `*corev1.PodList` to a GVK. In a second step,
    the `List()` method uses discovery information to get the GVR for pods, which
    is `schema.GroupVersionResource{"", "v1", "pods"}`, and therefore accesses */api/v1/namespace/default/pods*
    to get the list of pods in the passed namespace.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端对象的`List()`方法接受任何在给定方案中注册的`runtime.Object`，在这种情况下，是从`client-go`借用的所有标准 Kubernetes
    种类。在内部，客户端使用给定的方案将 Golang 类型`*corev1.PodList`映射到 GVK。在第二步中，`List()`方法使用发现信息来获取
    pods 的 GVR，即`schema.GroupVersionResource{"", "v1", "pods"}`，因此访问*/api/v1/namespace/default/pods*来获取传递命名空间中
    pods 的列表。
- en: 'The same logic can be used with custom resources. The main difference is to
    use a custom scheme that contains the passed Go type:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的逻辑可以用于自定义资源。主要区别在于使用包含传递的 Go 类型的自定义方案：
- en: '[PRE39]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Note how the invocation of the `List()` command does not change at all.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`List()`命令的调用方式完全没有变化。
- en: Imagine you write an operator that accesses many different kinds using this
    client. With the typed client of [“Typed client created via client-gen”](#clientgen-client),
    you would have to pass many different clients into the operator, making the plumbing
    code pretty complex. In contrast, the `controller-runtime` client presented here
    is just one object for all kinds, assuming all of them are in one scheme.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，您编写了一个操作器，该操作器使用此客户端访问许多不同种类的资源。使用[“通过 client-gen 创建的类型化客户端”](#clientgen-client)，您将不得不将许多不同的客户端传递给操作器，使得管道代码非常复杂。相比之下，这里介绍的`controller-runtime`客户端只是一个适用于所有种类的对象。
- en: All three types of clients have their uses, with advantages and disadvantages
    depending on the context in which they are used. In generic controllers that handle
    unknown objects, only the dynamic client can be used. In controllers where type
    safety helps a lot to enforce code correctness, the generated clients are a good
    fit. The Kubernetes project itself has so many contributors that stability of
    the code is very important, even when it is extended and rewritten by so many
    people. If convenience and high velocity with minimal plumbing is important, the
    `controller-runtime` client is a good fit.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三种类型的客户端都有它们的用途，具体取决于它们被使用的上下文中的优势和劣势。在处理未知对象的通用控制器中，只能使用动态客户端。在类型安全性对于强制代码正确性有很大帮助的控制器中，生成的客户端非常合适。Kubernetes
    项目本身有很多贡献者，因此代码的稳定性非常重要，即使它被许多人扩展和重写。如果方便性和高速度以及最小化的管道代码是重要的话，`controller-runtime`客户端就非常适合。
- en: Summary
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We introduced you to custom resources, the central extension mechanisms used
    in the Kubernetes ecosystem, in this chapter. By now you should have a good understanding
    of their features and limitations as well as the available clients.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章向您介绍了自定义资源，这是 Kubernetes 生态系统中使用的中心扩展机制。到目前为止，您应该对它们的特性和限制以及可用的客户端有了很好的理解。
- en: Let’s now move on to code generation for managing said resources.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续进行用于管理上述资源的代码生成。
- en: ^([1](ch04.html#idm46336863073336-marker)) Do not confuse Kubernetes and JSON
    objects here. The latter is just another term for a string map, used in the context
    of JSON and in OpenAPI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch04.html#idm46336863073336-marker)) 不要在这里混淆 Kubernetes 和 JSON 对象。后者只是
    JSON 上下文中字符串映射的另一个术语，在 OpenAPI 中使用。
- en: ^([2](ch04.html#idm46336862332104-marker)) “Projective” here means that the
    `scale` object is a projection of the main resource in the sense that it shows
    only certain fields and hides everything else.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch04.html#idm46336862332104-marker)) 这里的“投影”意味着`scale`对象是主资源的投影，它仅显示特定字段并隐藏其他所有内容。
