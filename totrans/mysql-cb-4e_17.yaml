- en: Chapter 17\. Statistical Techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 17.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covers several topics that relate to basic statistical techniques.
    For the most part, these recipes build on those described in earlier chapters,
    such as the summary techniques discussed in [Chapter 10](ch10.xhtml#nch-sum),
    and join techniques from [Chapter 16](ch16.xhtml#nch-multi). The examples here
    thus show additional ways to apply the material from those chapters. Broadly speaking,
    the topics discussed in this chapter include:'
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for characterizing a dataset, such as calculating descriptive statistics,
    generating frequency distributions, counting missing values, and calculating least-squares
    regressions or correlation coefficients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Randomization methods, such as how to generate random numbers and apply them
    to randomizing a set of rows or to selecting individual items randomly from the
    rows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Techniques for calculating successive-observation differences, cumulative sums,
    and running averages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Methods for producing rank assignments and generating team standings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistics covers such a large and diverse array of topics that this chapter
    necessarily only scratches the surface and simply illustrates a few of the potential
    areas in which MySQL may be applied to statistical analysis. Note that some statistical
    measures can be defined in different ways (for example, do you calculate standard
    deviation based on *`n`* degrees of freedom, or *`n`*–1?). If the definition I
    use for a given term doesn’t match the one you prefer, adapt the queries or algorithms
    shown here appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: You can find scripts related to the examples discussed here in the *stats* directory
    of the `recipes` distribution, and scripts for creating example tables in the
    *tables* directory.
  prefs: []
  type: TYPE_NORMAL
- en: 17.1 Calculating Descriptive Statistics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to characterize a dataset by computing general descriptive or summary
    statistics.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many common descriptive statistics, such as mean and standard deviation, are
    obtained by applying aggregate functions to your data. Others, such as median
    or mode, are calculated based on counting queries.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose that a `testscore` table contains observations representing subject
    ID, age, sex, and test score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A good first step in analyzing a set of observations is to generate some descriptive
    statistics that summarize their general characteristics as a whole. Common statistical
    values of this kind include:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of observations, their sum, and their range (minimum and maximum)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measures of central tendency, such as mean, median, and mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measures of variation, such as standard deviation and variance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aside from the median and mode, all of these can be calculated easily by invoking
    aggregate functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `STDDEV_SAMP()` and `VAR_SAMP()` functions produce sample measures rather
    than population measures. That is, for a set of *`n`* values, they produce a result
    that is based on *`n`*–1 degrees of freedom. For the population measures, which
    are based on *`n`* degrees of freedom, use `STDDEV_POP()` and `VAR_POP()` instead.
    `STDDEV()` and `VARIANCE()` are synonyms for `STDDEV_POP()` and `VAR_POP()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Standard deviation can be used to identify outliers—values that are uncharacteristically
    far from the mean. For example, to select values that lie more than a standard
    deviation from the mean, do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'MySQL has no built-in function for computing the mode or median of a set of
    values, but you can compute them yourself. To determine the mode (the value that
    occurs most frequently), count each value and see which is most common:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this case, 9 is the modal score value.
  prefs: []
  type: TYPE_NORMAL
- en: The median of a set of ordered values can be calculated like this:^([1](ch17.xhtml#idm45820338373088))
  prefs: []
  type: TYPE_NORMAL
- en: If the number of values is odd, the median is the middle value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the number of values is even, the median is the average of the two middle
    values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Based on that definition, use the following procedure to determine the median
    of a set of observations stored in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: Issue a query to count the number of observations. From the count, you can determine
    whether the median calculation requires one or two values, and what their indexes
    are within the ordered set of observations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Issue a query that includes an `ORDER` `BY` clause to sort the observations
    and a `LIMIT` clause to pull out the middle value or values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there is a single middle value, it is the median. Otherwise, take the average
    of the middle values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Suppose that a table `t` contains a `score` column with 37 values (an odd number).
    To get the median, select a single value using a statement like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the column contains 38 values (an even number), select two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Then take the values returned by the statement and compute the median from their
    average.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Perl function implements a median calculation. It takes a database
    handle and the names of the database, table, and column that contain the set of
    observations. Then it generates the statement that retrieves the relevant values
    and returns their average:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding technique works for a set of values stored in the database. If
    you have already fetched an ordered set of values into an array `@val`, compute
    the median like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The code works for arrays that have an initial subscript of 0; for languages
    that use 1-based array indexes, adjust the algorithm accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 17.2 Calculating Descriptive Statistics for Groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to produce descriptive statistics for each subgroup of a set of observations.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use aggregate functions, but employ a `GROUP` `BY` clause to arrange observations
    into the appropriate groups.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 17.1](#nch-stats-stats-descriptive) shows how to compute descriptive
    statistics for the entire set of scores in the `testscore` table. To be more specific,
    use `GROUP` `BY` to divide the observations into groups and calculate statistics
    for each of them. For example, the subjects in the `testscore` table are listed
    by age and sex, so it’s possible to calculate similar statistics by age or sex
    (or both) by application of appropriate `GROUP` `BY` clauses.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to calculate by age:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By sex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'By age and sex:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 17.3 Generating Frequency Distributions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to know the frequency of occurrence for each value in a table.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Derive a frequency distribution that summarizes the contents of your dataset.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common application for per-group summary techniques is to generate a *frequency
    distribution* that shows how often each value occurs. For the `testscore` table,
    the frequency distribution looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Expressing the results in percentages rather than counts yields relative frequency
    distribution. To show each count as a percentage of the total, use one query to
    get the total number of observations and another to calculate the percentages
    for each group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The distributions just shown summarize the number of values for individual scores.
    However, if the dataset contains a large number of distinct values and you want
    a distribution that shows only a small number of categories, you may want to lump
    values into categories and produce a count for each category. [Recipe 10.13](ch10.xhtml#nch-sum-sum-noncat)
    discusses <q>lumping</q> techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'One typical use of frequency distributions is to export the results for use
    in a graphing program. But MySQL itself can generate a simple ASCII chart as a
    visual representation of the distribution. To display an ASCII bar chart of the
    test score counts, convert the counts to strings of `*` characters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To chart the relative frequency distribution instead, use the percentage values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The ASCII chart method is crude, obviously, but it’s a quick way to get a picture
    of the distribution of observations and requires no other tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you generate a frequency distribution for a range of categories where some
    of the categories are not represented in your observations, the missing categories
    do not appear in the output. To force each category to be displayed, use a reference
    table and a `LEFT` `JOIN` (a technique discussed in [Recipe 16.8](ch16.xhtml#nch-multi-multi-fill-hole)).
    For the `testscore` table, the possible scores range from 0 to 10, so a reference
    table should contain each of those values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then join the reference table to the test scores to generate the frequency
    distribution. This query shows the counts as well as the histogram:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This distribution includes rows for scores 0 through 3, none of which appear
    in the frequency distribution shown earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same principle applies to relative frequency distributions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 17.4 Counting Missing Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A set of observations is incomplete. You want to find out how many values are
    missing.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Count the number of `NULL` values in the set.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Values can be missing from a set of observations for any number of reasons:
    a test may not yet have been administered, something may have gone wrong during
    the test that requires invalidating the observation, and so forth. You can represent
    such observations in a dataset as `NULL` values to signify that they’re missing
    or otherwise invalid, then use summary statements to characterize the completeness
    of the dataset.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a table `testscore_withmisses` contains values to be summarized along a
    single dimension, a simple summary suffices to characterize the missing values.
    Suppose that `testscore_withmisses` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`COUNT(*)` counts the total number of rows, and `COUNT(score)` counts the number
    of nonmissing scores. The difference between the two values is the number of missing
    scores, and that difference in relation to the total provides the percentage of
    missing scores. Perform these calculations as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As an alternative to counting `NULL` values as the difference between counts,
    count them directly using `SUM(ISNULL(score))`. The `ISNULL()` function returns
    1 if its argument is `NULL`, zero otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If values are arranged in groups, occurrences of `NULL` values can be assessed
    on a per-group basis. Suppose that `testscore_withmisses2` contains scores for
    subjects that are distributed among conditions for two factors A and B, each of
    which has two levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To produce a summary for each combination of conditions, use a `GROUP` `BY`
    clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 17.5 Calculating Linear Regressions or Correlation Coefficients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to calculate the least-squares regression line for two variables or
    the correlation coefficient that expresses the strength of the relationship between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apply summary functions to make these calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When the data values for two variables X and Y are stored in a database, the
    least-squares regression for them can be calculated easily using aggregate functions.
    The same is true for the correlation coefficient. The two calculations are actually
    fairly similar, and many terms for performing the computations are common to the
    two procedures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that you want to calculate a least-squares regression using the age
    and test score values for the observations in the `testscore` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following equation expresses the regression line, where `a` and `b` are
    the intercept and slope of the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Letting `age` be *`X`* and `score` be *`Y`*, begin by computing the terms needed
    for the regression equation. These include the number of observations; the means,
    sums, and sums of squares for each variable; and the sum of the products of each
    variable:^([2](ch17.xhtml#idm45820337870752))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'From those terms, calculate the regression slope and intercept as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The regression equation then is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'To compute the correlation coefficient, use many of the same terms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 17.6 Generating Random Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a source of random numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `RAND()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL has a `RAND()` function that produces random numbers between 0 and 1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When invoked with an integer argument, `RAND()` uses that value to seed the
    random number generator. You can use this feature to produce a repeatable series
    of numbers for a column of a query result. The following example shows that `RAND()`
    without an argument produces a different column of values per query, whereas `RAND(`*`N`*`)`
    produces a repeatable column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'To seed `RAND()` randomly, pick a seed value based on a source of entropy.
    Possible sources are the current timestamp or connection identifier, alone or
    perhaps in combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: However, it’s probably better to use other seed value sources if you have them.
    For example, if your system has a */dev/random* or */dev/urandom* device, read
    the device and use it to generate a value for seeding `RAND()`.
  prefs: []
  type: TYPE_NORMAL
- en: 17.7 Randomizing a Set of Rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to randomize a set of rows or values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `ORDER` `BY` `RAND()`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL’s `RAND()` function can be used to randomize the order in which a query
    returns its rows. Somewhat paradoxically, this randomization is achieved by adding
    an `ORDER` `BY` clause to the query. The technique is roughly equivalent to a
    spreadsheet randomization method. Suppose that a spreadsheet contains this set
    of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To place these in random order, first add another column that contains randomly
    chosen numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then sort the rows according to the values of the random numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the original values have been placed in random order; the effect
    of sorting the random numbers is to randomize the values associated with them.
    To rerandomize the values, choose another set of random numbers, and sort the
    rows again.
  prefs: []
  type: TYPE_NORMAL
- en: 'In MySQL, achieve a similar effect by associating a set of random numbers with
    a query result and sorting the result by those numbers. To do this, add an `ORDER`
    `BY` `RAND()` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Applications for randomizing a set of rows include any scenario that uses selection
    without replacement (choosing each item from a set of items until there are no
    more items left). Some examples of this are:'
  prefs: []
  type: TYPE_NORMAL
- en: Determining the starting order for participants in an event. List the participants
    in a table, and select them in random order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assigning starting lanes or gates to participants in a race. List the lanes
    in a table, and select a random lane order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the order in which to present a set of quiz questions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shuffling a deck of cards. Represent each card by a row in a table, and shuffle
    the deck by selecting the rows in random order. Deal them one by one until the
    deck is exhausted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the last example as an illustration, let’s implement a card deck-shuffling
    algorithm. Shuffling and dealing cards is randomization plus selection without
    replacement: each card is dealt once before any is dealt twice; when the deck
    is used up, it is reshuffled to rerandomize it for a new dealing order. Within
    a program, this task can be performed with MySQL using a table named `deck` that
    has 52 rows, assuming a set of cards with each combination of 13 face values and
    4 suits:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the entire table, and store it into an array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each time a card is needed, take the next element from the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the array is exhausted, all the cards have been dealt. <q>Reshuffle</q>
    the table to generate a new card order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Setting up the `deck` table is a tedious task if you insert the 52 card records
    by writing all the `INSERT` statements manually. The `deck` contents can be generated
    more easily in combinatorial fashion within a program by generating each pairing
    of face value with suit. Here’s some PHP code that creates a `deck` table with
    `face` and `suit` columns, then populates the table using nested loops to generate
    the pairings for the `INSERT` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Shuffling the cards is a matter of issuing this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'To do that and store the results in an array within a script, write a `shuffle_deck()`
    function that issues the query and returns the resulting values in an array (again
    shown in PHP):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Deal the cards by keeping a counter that ranges from 0 to 51 to indicate which
    card to select. When the counter reaches 52, the deck is exhausted and should
    be shuffled again.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Use this method only for tables with small number of rows. Ordering by `RAND()`
    does not allow MySQL to use indexes to resolve `ORDER BY`, therefore such queries
    will be slow on large tables.
  prefs: []
  type: TYPE_NORMAL
- en: 17.8 Selecting Random Items from a Set of Rows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to pick an item or items randomly from a set of values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Randomize the values, then pick the first one (or the first few, if you need
    more than one).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a set of items is stored in MySQL, choose one at random as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the items in the set in random order, using `ORDER` `BY` `RAND()` as
    described in [Recipe 17.7](#nch-stats-stats-rand-rows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `LIMIT` `1` to the query to pick the first item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, to perform a simple simulation of tossing a die, create a `die`
    table containing rows with values from 1 to 6 corresponding to the six faces of
    a die cube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Then pick rows from the table at random:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As you repeat this operation, you pick a random sequence of items from the
    set. This is a form of selection with replacement: an item is chosen from a pool
    of items and then returned to the pool for the next pick. Because items are replaced,
    it’s possible to pick the same item multiple times when making successive choices
    this way. Other examples of selection with replacement include:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting a banner ad to display on a web page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking a row for a <q>quote of the day</q> application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <q>Pick a card, any card</q> magic tricks that begin with a full deck of cards
    each time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To pick more than one item, change the `LIMIT` argument. For example, to draw
    five winning entries at random from a table named `drawing` that contains contest
    entries, use `RAND()` in combination with `LIMIT`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'A special case occurs when you pick a single row from a table that you know
    contains a column with values in the range from 1 to *`n`* in unbroken sequence.
    Under these circumstances, it’s possible to avoid performing an `ORDER` `BY` operation
    on the entire table. Pick a random number in that range and select the matching
    row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This is much quicker than `ORDER` `BY` `RAND()` `LIMIT` `1` as the table size
    increases.
  prefs: []
  type: TYPE_NORMAL
- en: 17.9 Calculating Successive-Row Differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A table contains successive cumulative values in its rows, and you want to compute
    the differences between pairs of successive rows.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a self-join that matches pairs of adjacent rows and calculates the differences
    between members of each pair.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Self-joins are useful when you have a set of absolute (or cumulative) values
    that you want to convert to relative values representing the differences between
    successive pairs of rows. For example, if you take an automobile trip and write
    down the total miles traveled at each stopping point, you can compute the difference
    between successive points to determine the distance from one stop to the next.
    Here is such a table that shows the stops for a trip from San Antonio, Texas to
    Madison, Wisconsin. Each row shows the total miles driven as of each stop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A self-join can convert these cumulative values to successive differences that
    represent the distances from each city to the next. The following statement shows
    how to use the sequence numbers in the rows to match pairs of successive rows
    and compute the differences between each pair of mileage values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The presence of the `seq` column in the `trip_log` table is important for calculating
    successive difference values. It’s needed for establishing which row precedes
    another and matching each row *`n`* with row *`n`*`+1`. The implication is that
    to perform relative-difference calculations using a table of absolute or cumulative
    values, it must include a sequence column that has no gaps. If the table contains
    a sequence column but there are gaps, renumber it (see [Recipe 15.5](ch15.xhtml#nch-sequences-seq-reseq)).
    If the table contains no such column, add one (see [Recipe 15.9](ch15.xhtml#nch-sequences-seq-add-seq)).
  prefs: []
  type: TYPE_NORMAL
- en: A more complex situation occurs when you compute successive differences for
    more than one column and use the results in a calculation. The following table,
    `player_stats`, shows some cumulative numbers for a baseball player at the end
    of each month of his season. `ab` indicates the total at-bats, and `h` the total
    hits the player has had as of a given date. (The first row indicates the starting
    point of the player’s season, which is why the `ab` and `h` values are zero.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The last column of the query result also shows the player’s batting average
    as of each date. This column is not stored in the table but is easily computed
    as the ratio of hits to at-bats. The result provides a general idea of how the
    player’s hitting performance changed over the course of the season, but it provides
    no picture of how the player did during each individual month. To determine that,
    calculate relative differences between pairs of rows. This is easily done with
    a self-join that matches row *`n`* with row *`n`*`+1` to calculate differences
    between pairs of at-bats and hits values. These differences enable computation
    of batting average during each month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: These results show much more clearly than the original table that the player
    started off well but had a slump in the middle of the season, particularly in
    July. They also indicate just how strong his performance was in August.
  prefs: []
  type: TYPE_NORMAL
- en: 17.10 Finding Cumulative Sums and Running Averages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a set of observations measured over time and want to compute the cumulative
    sum of the observations at each measurement point. Or you want to compute a running
    average at each point.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a self-join to produce the sets of successive observations at each measurement
    point, then apply aggregate functions to each set of values to compute its sum
    or average.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Recipe 17.9](#nch-stats-stats-abs-to-rel) illustrates how a self-join can
    produce relative values from absolute values. A self-join can do the opposite
    as well, producing cumulative values at each successive stage of a set of observations.
    The following table shows a set of rainfall measurements taken over a series of
    days. The values in each row show the observation date and precipitation in inches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate cumulative rainfall for a given day, add that day’s precipitation
    value to the values for all the previous days. For example, determine the cumulative
    rainfall as of `2014-06-03` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To get the cumulative figures for all days represented in the table, it’s tedious
    to compute the value separately for each day. A self-join can do this for all
    days with a single statement. Use one instance of the `rainfall` table as a reference,
    and determine for the date in each row the sum of the `precip` values in all rows
    occurring up through that date in another instance of the table. The following
    statement shows the daily and cumulative precipitation for each day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The self-join can be extended to display the number of days elapsed at each
    date, as well as the running averages for amount of precipitation each day:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding statement, the number of days elapsed and the precipitation
    running averages can be computed easily using `COUNT()` and `AVG()` because there
    are no missing days in the table. If missing days are permitted, the calculation
    becomes more complicated because the number of days elapsed for each calculation
    is no longer the same as the number of rows. You can see this by deleting the
    rows for the days that had no precipitation to produce <q>holes</q> in the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting those rows doesn’t change the cumulative sum or running average for
    the dates that remain, but it does change how they must be calculated. If you
    execute the self-join again, it yields incorrect results for the days-elapsed
    and average precipitation columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'To fix the problem, determine the number of days elapsed a different way. Take
    the minimum and maximum date involved in each sum and calculate a days-elapsed
    value from them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'That value must be used for the days-elapsed column and for computing the running
    averages. The resulting statement is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: As this example illustrates, calculation of cumulative values from relative
    values requires only a column that enables rows to be placed into the proper order.
    (For the `rainfall` table, that’s the `date` column.) Values in the column need
    not be sequential, or even numeric. This differs from calculations that produce
    difference values from cumulative values (see [Recipe 17.9](#nch-stats-stats-abs-to-rel)),
    which require a table that has a column containing an unbroken sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The running averages in the rainfall examples are based on dividing cumulative
    precipitation sums by number of days elapsed as of each day. When the table has
    no gaps, the number of days is the same as the number of values summed, making
    it easy to find successive averages. When rows are missing, the calculations become
    more complex. This demonstrates that it’s necessary to consider the nature of
    your data and calculate averages appropriately. The next example is conceptually
    similar to the previous ones in that it calculates cumulative sums and running
    averages, but performs the computations yet another way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows a marathon runner’s performance at each stage of
    a 26-kilometer run. The values in each row show the length of each stage in kilometers
    and how long the runner took to complete the stage. In other words, the values
    pertain to intervals within the marathon and thus are relative to the whole:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'To calculate cumulative distance in kilometers at each stage, use a self-join
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Cumulative distances are easy to compute because they can be summed directly.
    The calculation for accumulating time values is more involved: convert times to
    seconds, total the resulting values, and convert the sum back to a time value.
    To compute the runner’s average speed at the end of each stage, take the ratio
    of cumulative distance over cumulative time. Putting all this together yields
    the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We can see from this that the runner’s average pace increased a little during
    the second stage of the race but then decreased thereafter, presumably as a result
    of fatigue.
  prefs: []
  type: TYPE_NORMAL
- en: 17.11 Assigning Ranks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to assign ranks to a set of values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decide on a ranking method, then put the values in the desired order and apply
    the method to them.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some kinds of statistical tests require assignment of ranks. This section describes
    three ranking methods and shows how each can be implemented by using window functions.
    The examples assume that a table `ranks` contains the following scores, which
    are to be ranked with the values in descending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'One type of ranking simply assigns each value its row number within the ordered
    set of values. To produce such rankings, use window function `ROW_NUMBER()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'That kind of ranking doesn’t take into account the possibility of ties (instances
    of values that are the same). Window function `DENSE_RANK()` does so by advancing
    the rank only when values change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Window function `RANK()` is something of a combination of the other two methods.
    It ranks values by row number, except when ties occur. In that case, the tied
    values each get a rank equal to the row number of the first of the values.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Ranks are easy to assign within a program as well. For example, the following
    Ruby fragment ranks the scores in `ranks` using the third ranking method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The third type of ranking is commonly used for sporting events. The following
    table contains the American League pitchers who won 15 or more games during the
    2001 baseball season:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'These pitchers can be assigned ranks using the third method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about window functions, see [Recipe 15.15](ch15.xhtml#nch-sequences-seq-window-functions).
  prefs: []
  type: TYPE_NORMAL
- en: 17.12 Computing Team Standings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to compute team standings from their win-loss records, including the
    games-behind (GB) values.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Determine which team is in first place, then join that result to the original
    rows.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Standings for sports teams that compete against each other is a ranking problem,
    but ranks are not based on a single measure as in [Recipe 17.11](#nch-stats-stats-ranks).
    Standings are based on two values, wins and losses. Teams are ranked according
    to which has the best win-loss record, and teams not in first place are assigned
    a <q>games-behind</q> value indicating how many games out of first place they
    are. This section shows how to calculate those values. The first example uses
    a table containing a single set of team records to illustrate the logic of the
    calculations. The second example uses a table containing several sets of records
    (that is, the records for all teams in both divisions of a league, for both halves
    of the season). In this case, it’s necessary to use a join to perform the calculations
    independently for each group of teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following table, `standings1`, which contains a single set of
    baseball team records representing the final standings for the Northern League
    in the year 1902:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The rows are sorted by the win-loss differential, which is how to place teams
    in order from first place to last place. But displays of team standings typically
    include each team’s winning percentage and a figure indicating how many games
    behind the leader all the other teams are. So let’s add that information to the
    output. Calculating the percentage is easy. It’s the ratio of wins to total games
    played and can be determined using this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This expression involves division by zero when a team has not played any games
    yet. For simplicity, I’ll assume a nonzero number of games. To handle this condition,
    you’d use a more general expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This expression relies on the fact that no division operation is necessary unless
    the team has won at least one game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining the games-behind value is a little trickier. It’s based on the
    relationship of the win-loss records for two teams, calculated as the average
    of two values:'
  prefs: []
  type: TYPE_NORMAL
- en: How many more wins the first-place team has than the second-place team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many fewer losses the first-place team has than the second-place team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Suppose that two teams A and B have the following win-loss records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, team B has to win three more games, and team A has to lose one more game
    for the teams to be even. The average of three and one is two, thus B is two games
    behind A. Mathematically, the games-behind calculation for the two teams is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'With a little rearrangement of terms, the expression becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The second expression is equivalent to the first, but it has each factor written
    as a single team’s win-loss differential, rather than as a comparison between
    teams. That makes it easier to work with because each factor can be determined
    independently from a single team record. The first factor represents the first-place
    team’s win-loss differential, so if we calculate that value first, the other team
    GB values can be determined in relation to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first-place team is the one with the largest win-loss differential. To
    find that value and save it in a variable, use this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the differential as follows to produce team standings that include
    winning percentage and GB values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a couple minor formatting issues to address at this point. Typically,
    standings listings display percentages to three decimal places, and the GB value
    to one decimal place (except that the GB value for the first-place team is displayed
    as `-`). To display *`n`* decimal places, use `TRUNCATE(`*`expr`*`,`*`n`*`).`
    To display the GB value for the first-place team appropriately, use an `IF()`
    expression that maps 0 to a dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'These statements order the teams by win-loss differential, using winning percentage
    as a tie-breaker in case there are teams with the same differential value. It’s
    simpler to sort by percentage, of course, but then you wouldn’t always get the
    correct ordering. It’s a curious fact that a team with a lower winning percentage
    can actually be higher in the standings than a team with a higher percentage.
    (This generally occurs early in the season, when teams may have played highly
    disparate numbers of games, relatively speaking.) Consider the case in which two
    teams, A and B, have the following rows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Applying the GB and percentage calculations to these team records yields the
    following result, in which the first-place team actually has a lower winning percentage
    than the second-place team:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'The standings calculations shown thus far can be done without a join. They
    involve only a single set of team records, so the first-place team’s win-loss
    differential can be stored in a variable. A more complex situation occurs when
    a dataset includes several sets of team records. For example, the 1997 Northern
    League had two divisions (Eastern and Western). In addition, separate standings
    were maintained for the first and second halves of the season because season-half
    winners in each division played each other for the right to compete in the league
    championship. The following table, `standings2`, shows what these rows look like,
    ordered by season half, division, and win-loss differential:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Generating the standings for these rows requires computing the GB values separately
    for each of the four combinations of season half and division. First, calculate
    the win-loss differential for the first-place team in each group and save the
    values into a separate `firstplace` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Then join the `firstplace` table to the original standings, associating each
    team record with the proper win-loss differential to compute its GB value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'That output is difficult to read, however. To make it easier to understand,
    you might execute the statement from within a program and reformat its results
    to display each set of team records separately. Here’s some Perl code that does
    that by beginning a new output group each time it encounters a new group of standings.
    The code assumes that the join statement has just been executed and that its results
    are available through the statement handle `$sth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The reformatted output looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The code just shown comes from the *calc_standings.pl* script in the *stats*
    directory of the `recipes` distribution. That directory also contains a PHP script,
    *calc_standings.php*, that produces output in the form of HTML tables, which you
    might prefer for generating standings in a web environment.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch17.xhtml#idm45820338373088-marker)) The definition of median given here
    isn’t fully general; it doesn’t address what to do if the middle values in the
    dataset are duplicated.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch17.xhtml#idm45820337870752-marker)) To see where these terms come from,
    consult any standard statistics text.
  prefs: []
  type: TYPE_NORMAL
