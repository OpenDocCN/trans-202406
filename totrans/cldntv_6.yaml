- en: Chapter 6\. Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章。最佳实践
- en: Throughout this book, you have learned about the fundamentals of cloud native
    applications—how to design, develop, and operate them as well as how to deal with
    data. To conclude, this chapter aims to provide a laundry list covering tips,
    proven techniques, and proven best practices to build and manage reactive cloud
    native applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书全程学习了云原生应用程序的基础知识——如何设计、开发和运行它们，以及如何处理数据。总结来说，本章旨在提供一份清单，涵盖了构建和管理反应式云原生应用程序的建议、验证技术和最佳实践。
- en: Moving to Cloud Native
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到云原生
- en: In [Chapter 2](ch02.xhtml#fundamentals), you learned about the process that
    many customers follow when moving traditional applications to the cloud. There
    are many best practices and lessons learned that you should consider when moving
    an existing application into the cloud.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](ch02.xhtml#fundamentals)中，您学习了许多客户在将传统应用程序迁移到云端时遵循的过程。在将现有应用程序迁移到云端时，您应考虑许多最佳实践和经验教训。
- en: Breaking Up the Monolith for the Right Reasons
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为了正确的理由分解单体架构
- en: '“Never change a running system” is a widely used statement in software development,
    and it is also applicable when you consider moving your application to the cloud.
    If your sole requirement is to move your application to the cloud, you can always
    consider moving it on Infrastructure as a Service (IaaS)—in fact, that should
    be your very first step. That said, there are benefits of redesigning your application
    to be cloud native, but you need to weigh the pros and cons. Following are some
    guidelines indicating that a redesign makes sense:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: “永远不要改变正在运行的系统”是软件开发中广泛使用的声明，当您考虑将应用程序迁移到云端时也适用。如果您的唯一需求是将应用程序迁移到云端，您可以考虑首先将其移至基础设施即服务（IaaS）——事实上，这应该是您的第一步。也就是说，重新设计应用程序为云原生也有其好处，但您需要权衡利弊。以下是一些指导方针，表明重新设计是有意义的：
- en: Your codebase has grown to a point that it takes very long to release an updated
    version and thus you cannot react to new market or customer requirements quickly.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的代码库已经增长到更新版本需要很长时间，并且因此无法迅速响应新市场或客户需求。
- en: Components of your applications have different scale requirements. A good example
    is a traditional three-tier application consisting of a frontend, business, and
    data tier. Only the frontend tier might experience heavy load in user requests,
    whereas the business and data tier are still comfortably handling the load. As
    mentioned in [Chapter 2](ch02.xhtml#fundamentals) and [Chapter 3](ch03.xhtml#designing_cloud-native_applications),
    cloud native applications allow you to scale services independently.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的各个组件具有不同的规模要求。一个很好的例子是传统的三层应用程序，包括前端、业务和数据层。只有前端层可能会经历用户请求的大量负载，而业务和数据层仍然可以轻松处理负载。正如在[第二章](ch02.xhtml#fundamentals)和[第三章](ch03.xhtml#designing_cloud-native_applications)中所提到的，云原生应用程序允许您独立扩展服务。
- en: Better technology choices have emerged. There is constant innovation in the
    technology sector, and some new technologies might be better suited for parts
    of your application.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出现了更好的技术选择。技术领域不断创新，一些新技术可能更适合您应用的某些部分。
- en: After you have decided that you want to redesign your application, you need
    to consider many things. In the following sections, we provide a comprehensive
    look at these considerations.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦决定重新设计应用程序，您需要考虑很多事情。在接下来的章节中，我们全面探讨这些考虑事项。
- en: Decouple Simple Services First
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 首先解耦简单服务
- en: Start by breaking off components that provide simpler functionality because
    they usually do not have a lot of dependencies and, thus, are not deeply integrated
    within the monolith.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 从分离提供简单功能的组件开始，因为它们通常没有太多依赖，因此不会深度集成在单体架构中。
- en: Learn to Operate on a Small Scale
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 学会小规模运作
- en: Use the first service as a learning path for how to operate in a cloud native
    world. Starting with a simple service, you can focus on setting up automation
    to provision the infrastructure and the CI/CD pipeline so that you become familiar
    with the process of developing, deploying, and operating a cloud native service.
    Having a simple service and minimal infrastructure will allow you to learn, exercise,
    and improve your new process ahead of time, without substantial impact on the
    monolith and your end users.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第一个服务作为学习路径，了解如何在云原生世界中操作。从一个简单的服务开始，您可以专注于设置自动化以提供基础架构和CI/CD管道，以便熟悉开发、部署和操作云原生服务的过程。拥有一个简单的服务和最小的基础设施将使您能够提前学习、练习和改进新的流程，而不会对单片和最终用户造成重大影响。
- en: Use an Anticorruption Layer Pattern
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用防腐层模式
- en: Nothing is perfect, especially in the software development world, so you will
    eventually end up with a new service that makes calls back to the monolith. In
    this case, you might want to use the *Anticorruption Layer* pattern. This pattern
    is used to implement a facade or adapter between components that don’t share the
    same semantics. The purpose of the anticorruption layer is to translate the request
    from one component to another; for example, implementing protocol or schema translations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么是完美的，特别是在软件开发领域，所以最终您可能会得到一个向单片做出调用的新服务。在这种情况下，您可能需要使用*防腐层*模式。此模式用于在不共享相同语义的组件之间实现外观或适配器。防腐层的目的是将一个组件的请求转换为另一个组件的请求；例如，实现协议或模式的转换。
- en: To implement this, you design and create a new API in the monolith that makes
    calls through the anticorruption layer in the new service, as shown in [Figure 6-1](#anticorruption_layer_pattern).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要实施此操作，您需要在单片应用程序中设计并创建一个新的API，通过新服务中的防腐层进行调用，如[图 6-1](#anticorruption_layer_pattern)所示。
- en: '![clna 0601](Images/clna_0601.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![clna 0601](Images/clna_0601.png)'
- en: Figure 6-1\. *Anticorruption Layer* pattern
  id: totrans-18
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-1\. *防腐层* 模式
- en: There are a couple of considerations when you are using this approach. As [Figure 6-1](#anticorruption_layer_pattern)
    illustrates, the anticorruption layer is a service on its own, so you need to
    think about how to scale and operate the layer. Also, you need to think about
    whether you want to retire the anticorruption layer after the monolithic application
    has been fully moved into a cloud native application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用此方法时，有几个考虑因素。如[图 6-1](#anticorruption_layer_pattern)所示，防腐层本身是一个服务，因此您需要考虑如何扩展和操作该层。此外，您需要考虑在完全将单片应用程序移至云原生应用程序之后是否要废弃防腐层。
- en: Use a Strangler Pattern
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Strangler模式
- en: When you are decomposing your monolith to move to microservices and functions,
    you can use a gateway and a pattern such as a *Strangler* pattern. The idea behind
    the Strangler pattern is to use the gateway as a facade while you gradually move
    the backend monolith to a new architecture—either services, functions, or a combination
    of both. As you’re making progress breaking up the monolith and implementing those
    pieces of functionality as services or functions, you update the gateway to redirect
    requests to the new functionality, instead as shown in [Figure 6-2](#migrating_from_monolith_using_the_strang).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当您将单片拆解以迁移到微服务和函数时，您可以使用网关和*Strangler*模式。Strangler模式的理念是使用网关作为外观，同时逐步将后端单片移至新架构——服务、函数或两者的组合。随着您分解单片并将其功能实现为服务或函数，您更新网关以重定向请求到新功能，如[图 6-2](#migrating_from_monolith_using_the_strang)所示。
- en: '![clna 0602](Images/clna_0602.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![clna 0602](Images/clna_0602.png)'
- en: Figure 6-2\. Migrating from monolith using the *Strangler* pattern
  id: totrans-23
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-2\. 使用*Strangler*模式从单片迁移
- en: Note that the Strangler pattern might not be suitable for the instance in which
    you can’t intercept the requests going to the backing monolith. The pattern also
    might not make sense if you have a smaller system, for which it’s easier and faster
    to replace the entire system, instead of gradually moving it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果您无法拦截发送到支持单片的请求，则Strangler模式可能不适用。如果您有一个较小的系统，更容易和更快地替换整个系统，而不是逐步移动，则此模式可能也没有意义。
- en: The Anticorruption Layer and Strangler patterns have been proven many times
    as good approaches to move a monolithic legacy application to a cloud native application
    because both promote a gradual approach.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 防腐层和Strangler模式在多次证明中被证明是将单片遗留应用程序移动到云原生应用程序的良好方法，因为两者都促进了逐步的方法。
- en: Come Up with a Data Migration Strategy
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 制定数据迁移策略
- en: In a monolith, you are usually working with a centrally shared datastore where
    data is read from and written to by multiple places and services. To truly move
    to the cloud native architecture, you need to decouple data as well. Your data
    migration strategy might consist of multiple phases, especially if you can’t migrate
    everything at the same time. However, in most cases, you will need to do an incremental
    migration while keeping the entire system running. A gradual migration will probably
    involve writing data twice (to the new and old datastore) for a while. After you
    have data in both places and synchronized, you will need to modify where the data
    is being read from and then read everything from the new store. Finally, you should
    be able to stop writing data to the old store completely.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用中，通常会使用一个中心共享的数据存储，多个地方和服务从中读取和写入数据。要真正转向云原生架构，您还需要解耦数据。您的数据迁移策略可能包含多个阶段，特别是如果无法同时迁移所有内容。然而，在大多数情况下，您需要进行增量迁移，同时保持整个系统运行。逐步迁移可能会在一段时间内将数据写入两次（到新旧数据存储）。在两个地方的数据都同步后，您需要修改数据的读取位置，然后从新存储中读取所有数据。最后，您应该能够完全停止向旧存储写入数据。
- en: Rewrite Any Boilerplate Code
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写任何样板代码
- en: Monoliths will usually have large amounts of code that deals with the configuration,
    data caching, datastore access, and so on and is probably using older libraries
    and frameworks. When moving capabilities to a new service, you should rewrite
    this code. The best option is to throw away the old code and rewrite it from scratch
    instead of modifying the existing code and molding it so it fits the new service.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用通常会有大量处理配置、数据缓存、数据存储访问等内容的代码，并且可能使用较旧的库和框架。在将功能移动到新服务时，您应该重写此代码。最好的选择是放弃旧代码，从头开始重写，而不是修改现有代码并将其塑造成适合新服务的样子。
- en: Reconsider Frameworks, Languages, Data Structures, and Datastores
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新考虑框架、语言、数据结构和数据存储
- en: Moving to microservices gives you an option to rethink the existing implementation.
    Are there new frameworks or languages that you could use to rewrite the current
    code that provide better features and functionalities for your scenarios? If it
    makes sense to rewrite the code, do it! Also, reconsider any data structures in
    the current code. Would they still make sense when moved to a service? You should
    also evaluate whether you want to use different datastores. [Chapter 4](ch04.xhtml#working_with_data)
    outlines what datastores are best suited for certain data structures and query
    patterns.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 移向微服务为您提供重新思考现有实现的选项。是否有新的框架或语言可以用来重写当前代码，以提供更好的功能和功能？如果重写代码有意义，那就去做吧！此外，重新考虑当前代码中的任何数据结构。当转移到服务时，它们是否仍然合理？您还应该评估是否要使用不同的数据存储。[第四章](ch04.xhtml#working_with_data)概述了哪些数据存储最适合特定的数据结构和查询模式。
- en: Retire Code
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 淘汰代码
- en: After you’ve created a new service and all the traffic is redirected to that
    service, you need to retire and remove the old code that resides in the monolith.
    Using this approach, you are shrinking the monolith and expanding your services.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新服务并将所有流量重定向到该服务后，您需要淘汰和删除单体中的旧代码。使用这种方法，您正在缩小单体并扩展您的服务。
- en: Ensuring Resiliency
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保弹性
- en: Resiliency is the ability of a system to recover from failures and continue
    to function and serve requests. Resiliency is not about avoiding failures; instead,
    it is all about responding to failures in such a manner that avoids significant
    downtime or data loss.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性是系统从故障中恢复并继续运行和提供请求的能力。弹性不是避免故障，而是响应故障的方式，以避免重大停机时间或数据丢失。
- en: Handle Transient Failures with Retries
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理瞬态故障并进行重试
- en: 'Requests can fail due to multiple reasons such as network latency, dropped
    connections, or timeouts if downstream services are busy. You can avoid most of
    these failures if you retry the request. Retrying can also improve the stability
    of your application. However, before blindly retrying all requests, you need to
    implement a bit of logic that determines whether the request should be retried.
    If the failure is not transient or there is a likelihood that a retry won’t be
    successful, it is better for the component to cancel the request and respond with
    an appropriate error message. For example, retrying a failed login because of
    an incorrect password is futile and retries won’t help. If failure is due to a
    rare network issue, you can retry the request right away given that the same issue
    probably won’t persist. Finally, if the failure happens because the downstream
    service is busy or you are being rate limited, for example, you should retry after
    a delay. Here are some common strategies for delaying between retry operations:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 请求可能因网络延迟、连接中断或超时（如果下游服务繁忙）等多种原因而失败。如果重试请求，您可以避免大部分这些失败。重试还可以提高应用程序的稳定性。然而，在盲目重试所有请求之前，您需要实现一些逻辑来确定是否应该重试请求。如果故障不是暂时的，或者重试可能不会成功，最好是组件取消请求并返回适当的错误消息。例如，因为密码错误而重试失败的登录是徒劳的，重试也不会有所帮助。如果故障是由于罕见的网络问题引起的，可以立即重试请求，因为同样的问题可能不会持续。最后，如果故障是由于下游服务繁忙或者速率限制，例如，应该在延迟后进行重试。以下是一些常见的重试操作之间延迟的策略：
- en: Constant
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 常量
- en: Wait for the same time between each attempt.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在每次尝试之间等待相同的时间。
- en: Linear
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 线性
- en: Incrementally increase the time between each retry. For example, you can start
    with one second, then three seconds, five seconds, and so on.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 按照每次重试之间逐步增加的时间。例如，可以从一秒开始，然后是三秒、五秒等。
- en: Exponential back-off
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 指数退避
- en: Exponentially increase time between each retry. For example, start with 3 seconds,
    12 seconds, 30 seconds, and so on.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 按照每次重试之间指数增加的时间。例如，从3秒开始，然后是12秒、30秒等。
- en: Depending on what type of failure you are dealing with, you can also immediately
    retry the operation once and then use one of the delay strategies mentioned in
    the preceding list. You can handle retries in the component’s source code by using
    the retry and transient failure logic provided by many of the service SDKs, or
    at the infrastructure layer if you are using a service mesh, such as Istio.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您处理的故障类型，您还可以立即重试操作一次，然后使用前面列表中提到的延迟策略之一。您可以通过使用许多服务SDK提供的重试和暂时性故障逻辑来处理组件源代码中的重试，或者如果您正在使用像Istio这样的服务网格，则可以在基础设施层处理重试。
- en: Use a Finite Number of Retries
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用有限次数的重试
- en: Regardless of which retry strategy you’re using, always make sure to use a finite
    number of retries. Having an infinite number of retries will cause an unnecessary
    strain on the system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 无论使用哪种重试策略，请确保使用有限次数的重试。无限次重试将对系统造成不必要的负担。
- en: Use Circuit Breakers for Nontransient Failures
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于非暂时故障的断路器
- en: The purpose of a circuit breaker is to prevent components from doing operations
    that will likely fail and are not transient. Circuit breakers monitor the number
    of faults, and based on that information decide whether the request should continue
    or an error should be returned without even invoking the downstream service. If
    a circuit breaker trips, the number of failures has exceeded a predefined value,
    and the circuit breaker will automatically return errors for a preset time. After
    the preset time elapses, it will reset the failure count and allow requests to
    go through to the downstream service again. A well-known library that implements
    the circuit breaker pattern is Hystrix from Netflix. If you are using a service
    mesh like Istio or Envoy proxies, you can take advantage of the circuit breaker
    implementation in those solutions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 断路器的目的是防止组件执行可能失败且不是暂时的操作。断路器监视故障次数，并根据该信息决定是否继续请求或者是否应该返回错误而不调用下游服务。如果断路器跳闸，则失败次数已超过预定义值，断路器将自动在预设时间内返回错误。在预设时间结束后，它将重置故障计数并允许请求再次通过到下游服务。一个实现断路器模式的知名库是Netflix的Hystrix。如果您正在使用像Istio或Envoy代理这样的服务网格，您可以利用这些解决方案中的断路器实现。
- en: Graceful Degradation
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优雅降级
- en: Services should degrade gracefully, so even if they fail, they still provide
    an acceptable user experience if it makes sense. For example, if you can’t retrieve
    the data, you could display a cached version of the data, and as soon as the data
    source recovers, you show the latest data.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 服务应优雅地降级，因此即使它们失败，如果有意义的话，它们仍然提供可接受的用户体验。例如，如果无法检索数据，可以显示数据的缓存版本，一旦数据源恢复，就显示最新的数据。
- en: Use a Bulkhead Pattern
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分隔模式
- en: The *Bulkhead* pattern refers to isolating different parts of your system into
    groups in such a way that if one fails, the others will continue running unaffected.
    Grouping your services this way allows you isolate failures and continue serving
    requests even when there’s a failure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '*分隔*模式指的是将系统的不同部分分组隔离，以便如果一个部分失败，其他部分仍将继续运行而不受影响。以这种方式对服务进行分组允许你隔离故障，并在发生故障时继续提供请求服务。'
- en: Implement Health Checks and Readiness Checks
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施健康检查和就绪检查
- en: Implement a health check and a readiness check for every service you deploy.
    The platform can use these to determine whether the service is healthy and performing
    correctly as well as when the service is ready to start accepting requests. In
    Kubernetes, health checks are called *probes*. The liveness probe is used to determine
    when a container should be restarted, whereas the readiness probe determines whether
    a pod should start receiving traffic.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你部署的每个服务实施健康检查和就绪检查。平台可以使用这些来确定服务是否健康且正确执行，以及服务何时准备好接受请求。在 Kubernetes 中，健康检查被称为*探针*。存活探针用于确定何时重新启动容器，而就绪探针确定是否应该开始向
    pod 发送流量。
- en: The initial delay defines the number of seconds after the container has started
    before liveness or readiness probes are active, whereas the period defines how
    often the probe is performed. There are also additional settings such as success/failure
    threshold and timeouts that you can use to fine-tune the probes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 初始延迟定义了容器启动后多少秒之后活跃探针或就绪探针开始工作，而周期则定义了探针的执行频率。还有额外的设置，如成功/失败阈值和超时，可以用来微调探针。
- en: Define CPU and Memory Limits for Your Containers
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的容器定义 CPU 和内存限制
- en: You should define CPU and memory limits to isolate resources and prevent certain
    services instances from consuming too many resources. In Kubernetes, you can achieve
    this by defining the memory and CPU limits within the pod definition.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该定义 CPU 和内存限制来隔离资源，防止某些服务实例消耗过多资源。在 Kubernetes 中，你可以通过在 pod 定义中定义内存和 CPU 限制来实现这一点。
- en: Implement Rate Limiting and Throttling
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施速率限制和节流
- en: You use rate limiting and throttling to limit the number of incoming or outgoing
    requests for a service. Implementing those can help you to keep your service responsive
    even in the case of a sudden spike in requests. Throttling, on the other hand,
    is often used for outgoing requests. Think about using it when you want to control
    the number of requests sent to an external service to minimize the costs or to
    make sure that your service does not look like the origin of a Denial-of-Service
    attack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用速率限制和节流来限制服务的入站或出站请求数量。实施这些措施可以帮助你保持服务在请求突然增加的情况下仍然响应。另一方面，节流通常用于出站请求。考虑在希望控制发送到外部服务的请求数量以减少成本或确保你的服务不像是拒绝服务攻击来源时使用它。
- en: Ensuring Security
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保安全性
- en: Security in the cloud native world is based on the shared responsibility model.
    The cloud providers are not solely responsible for the security of their customers’
    solutions; instead, they share that responsibility with the customers. From an
    application perspective you should consider adopting the defense-in-depth concept,
    which is discussed in [Chapter 3](ch03.xhtml#designing_cloud-native_applications).
    The best practices listed in this section will help you to ensure security.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生世界中的安全性基于共享责任模型。云提供商不单独负责其客户解决方案的安全性；相反，他们与客户分享这一责任。从应用程序的角度来看，你应考虑采纳深度防御的概念，该概念在[第
    3 章](ch03.xhtml#designing_cloud-native_applications)中有讨论。本节列出的最佳实践将帮助你确保安全性。
- en: Treat Security Requirements the Same as Any Other Requirements
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将安全要求与其他任何要求视为同等重要
- en: Having fully automated processes is in spirit of the cloud native development.
    To achieve this, all security requirements must be treated as any other requirement
    and be pushed through your development pipeline.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有完全自动化的流程符合云原生开发的精神。为了实现这一点，所有安全要求必须像其他任何要求一样被视为开发流水线中的一部分。
- en: Incorporate Security in Your Designs
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的设计中融入安全性
- en: As you’re planning and designing your cloud native solutions, you need to think
    about security and incorporate the security features in your design. As part of
    your design, you also should call out any additional security concerns that need
    to be addressed during component development.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在规划和设计云原生解决方案时，您需要考虑安全性，并在设计中融入安全功能。作为设计的一部分，您还应该指出在组件开发期间需要解决的任何额外安全问题。
- en: Grant Least-Privileged Access
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授予最小特权访问
- en: If your services or functions need access to any resources, they should be granted
    specific permissions that have the least amount of access set to them. For example,
    if your service is reading only from the database, it does not need to use an
    account that has write permissions.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的服务或函数需要访问任何资源，它们应该被授予具有最少权限的特定权限。例如，如果您的服务只从数据库读取，它不需要使用具有写权限的账户。
- en: Use Separate Accounts/Subscriptions/Tenants
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用单独的账户/订阅/租户
- en: Depending on the terminology of your cloud provider, your cloud native system
    should use separate accounts, subscriptions, and/or tenants. At the very least,
    you will need a separate account for every environment you will be using; that
    way, you can ensure proper isolation between environments.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的云服务提供商的术语，您的云原生系统应该使用单独的账户、订阅和/或租户。至少，您需要为每个将使用的环境设置一个独立的账户；这样，您可以确保各个环境之间得到适当的隔离。
- en: Securely Store All Secrets
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全存储所有机密信息
- en: 'Any secrets within your system, used either by your components or Continuous
    Integration/Continuous Development (CI/CD) pipeline, need to be encrypted and
    securely stored. It might sound like a no-brainer, but never store any secrets
    in plain text: always encrypt them. It’s always best to use existing and proven
    secret management systems that take care of these things for you. The simplest
    option is to use Kubernetes Secrets to store the secrets used by services within
    the cluster. Secrets are stored in etcd, a distributed key/value store. However,
    managed and centralized solutions have multiple advantages over Kubernetes secrets:
    everything is stored in a centralized location, you can define access control
    policies, secrets are encrypted, auditing support is provided, and more. Some
    examples of managed solutions are Microsoft Azure Key Vault, Amazon Secrets Manager,
    and HashiCorp Vault.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 系统内部的任何机密信息，无论是由您的组件还是持续集成/持续开发（CI/CD）流水线使用，都需要被加密并安全地存储。这听起来是理所当然的，但绝不要以明文形式存储任何机密信息：始终加密它们。最好使用现有和经过验证的机密管理系统来处理这些事务。最简单的选择是使用Kubernetes
    Secrets来存储集群内服务使用的机密信息。机密信息存储在etcd中，这是一个分布式键/值存储。然而，受管理和集中化的解决方案在几个方面都比Kubernetes
    Secrets有多个优势：所有内容都存储在一个集中位置，您可以定义访问控制策略，机密信息被加密，提供审计支持等等。一些受管理的解决方案的例子包括Microsoft
    Azure Key Vault，Amazon Secrets Manager和HashiCorp Vault。
- en: Obfuscate Data
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据混淆
- en: Any data your component uses needs to be properly obfuscated. For example, you
    never want to log any data classified as Personally Identifiable Information (PII)
    in plain text; if you need to log or store it, ensure that it’s either obfuscated
    (if logging it) or encrypted (if storing it).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您的组件使用的任何数据都需要适当地混淆。例如，您绝不希望以明文形式记录任何被分类为个人身份信息（PII）的数据；如果需要记录或存储它，确保它要么被混淆（如果记录）或加密（如果存储）。
- en: Encrypt Data in Transit
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加密传输中的数据
- en: Encrypting data in transit protects your data if communications are intercepted
    while the data moves between components. To achieve this protection, you need
    to encrypt the data before transmitting it, authenticate the endpoints, and finally
    decrypt and verify the data after it reaches the endpoint. Transport Layer Security
    (TLS) is used to encrypt data in transit for transport security. If you are using
    a service mesh, TLS might already be implemented between the proxies in the mesh.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在传输中加密数据可以保护您的数据，以防通信过程中被拦截。为了实现这种保护，您需要在传输之前加密数据，验证端点的身份，最后在达到端点后解密并验证数据。传输层安全协议（TLS）用于加密传输中的数据，以实现传输安全。如果您正在使用服务网格，TLS可能已经在网格中的代理之间实现。
- en: Use Federated Identity Management
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用联合身份管理
- en: Using an existing federated identity management service (Auth0, for example)
    to handle how users sign up, sign in, and sign out allows you to redirect users
    to a third-party page for authentication. Your component should delegate authentication
    and authorization whenever possible.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用现有的联合身份管理服务（例如 Auth0）来处理用户的注册、登录和退出，允许您将用户重定向到第三方页面进行身份验证。您的组件应尽可能地委派认证和授权。
- en: Use Role-Based Access Control
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用基于角色的访问控制
- en: Role-Based Access Control (RBAC) has been around for a long time. RBAC is a
    control access mechanism around roles and privileges, and as you have learned,
    it can be a great asset to your defense-in-depth strategy because it allows you
    to provide fine-grained access to users to only the resources they need. Kubernetes
    RBAC, for example, controls permissions to the Kubernetes API. Using RBAC, you
    can allow or deny specific users from creating deployments or listing pods, and
    more. It’s a good practice to scope Kubernetes RBAC permissions by namespaces
    rather than cluster roles.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的访问控制（RBAC）已经存在很长时间了。RBAC 是一种围绕角色和权限的访问控制机制，正如您所学到的，它可以成为防御深度策略的重要组成部分，因为它允许您为用户提供对他们所需资源的精细化访问。例如，Kubernetes
    的 RBAC 控制对 Kubernetes API 的权限。使用 RBAC，您可以允许或拒绝特定用户创建部署或列出 Pod 等操作。在 Kubernetes
    中，通过命名空间来限定 RBAC 权限是一个良好的实践，而不是使用集群角色。
- en: Isolate Kubernetes Pods
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离 Kubernetes Pods
- en: Any pods running in a Kubernetes cluster are not isolated and can accept requests
    from any source. Defining a network policy on pods allows you to isolate pods
    and make them reject any connections that are not allowed by the policy. For example,
    if a component in your system is compromised, a network policy will prevent the
    malicious actor from communicating with services with which you don’t want them
    to communicate. Using a NetworkPolicy resource in Kubernetes, you can define a
    pod selector and detailed ingress and egress policies.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中运行的任何 Pod 都不是隔离的，可以接受来自任何来源的请求。在 Pod 上定义网络策略可以使其隔离，并拒绝任何未经策略允许的连接。例如，如果系统中的某个组件受到了威胁，网络策略将阻止恶意行为者与您不希望其通信的服务进行通信。在
    Kubernetes 中使用 NetworkPolicy 资源，您可以定义 Pod 选择器以及详细的入站和出站策略。
- en: Working with Data
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理数据
- en: 'Most modern applications have some need to store and work with data. A growing
    number of data storage and analytics services are available as cloud provider–managed
    services. Cloud native applications are designed to take full advantage of cloud
    provider–managed data systems and are designed to evolve to take advantage of
    a growing number of features. When working with data in the cloud, many of the
    standard data best practices still apply: have a disaster recovery plan, keep
    business logic out of the database, avoid overfetching or excessively chatty I/O,
    use data access implementations that prevent SQL injections attacks, and so on.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数现代应用程序都需要存储和处理数据。越来越多的数据存储和分析服务作为云提供商管理的服务可用。云原生应用程序设计旨在充分利用云提供商管理的数据系统，并设计成可以逐步利用增多功能。在云中处理数据时，许多标准的数据最佳实践仍然适用：拥有灾难恢复计划、将业务逻辑从数据库中分离、避免过度获取或过度聊天式的
    I/O、使用防止 SQL 注入攻击的数据访问实现等等。
- en: Use Managed Databases and Analytics Services
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用托管数据库和分析服务
- en: Whenever possible use a managed database. Provisioning a database on virtual
    machines (VMs) or in a Kubernetes cluster can often be a quick and easy task.
    Production databases that require backups and replicas can quickly increase the
    time and burden of operating data storage systems. By offloading the operational
    burden of deploying and managing a database, teams are able to focus more on development.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用托管数据库。在虚拟机（VM）上或 Kubernetes 集群中部署数据库通常是一个快速且简单的任务。需要备份和副本的生产数据库可以快速增加操作数据存储系统的时间和负担。通过卸载部署和管理数据库的运营负担，团队能够更多地专注于开发工作。
- en: In some cases, a data storage technology might not be available as a managed
    service or it might be necessary to have access to some configurations that are
    not available in a managed version of the system.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，数据存储技术可能没有作为托管服务提供，或者可能需要访问一些在系统的托管版本中不可用的配置。
- en: Use a Datastore That Best Fits Data Requirements
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用最适合数据需求的数据存储
- en: When designing on-premises applications, architects would often try to avoid
    using multiple databases. Each database technology used would require database
    administrators with the skillset to deploy and manage the database, significantly
    increasing the operational costs of the application. The reduced operational costs
    of cloud-managed databases make it possible to use multiple different types of
    datastores to put data in a system best suited for the data type, read, and write
    requirements. Cloud native applications take full advantage of this, using multiple
    data storage technologies.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计本地应用程序时，架构师通常会尝试避免使用多个数据库。每种数据库技术的使用都需要具有部署和管理数据库技能的数据库管理员，这显著增加了应用程序的运营成本。云托管数据库的降低运营成本使得可以使用多种不同类型的数据存储来放置最适合数据类型、读取和写入要求的系统中的数据。云原生应用程序充分利用这一点，使用多种数据存储技术。
- en: Keep Data in Multiple Regions or Zones
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将数据存储在多个区域或区域中。
- en: Store production data for applications across multiple regions or zones. How
    the data is stored across the zones or regions will depend on the application’s
    availability requirements; for example, the data might be backups or a replicated
    database. If a cloud provider experiences a failure of a zone or region, the data
    can be available to be used for recovery or failover.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 存储应用程序的生产数据跨多个区域或区域。数据如何存储在区域或区域中将取决于应用程序的可用性要求；例如，数据可以是备份或复制数据库。如果云服务提供商经历某个区域或区域的故障，数据可以用于恢复或故障转移。
- en: Use Data Partitioning and Replication for Scale
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用数据分区和复制进行扩展。
- en: Cloud native applications are designed to scale out as opposed to scale up.
    Scaling a database up is achieved by increasing the resources available to a database
    instance; for example, adding more cores or memory. This ultimately encounters
    a hard limit and can be costly. Scaling databases out is achieved through distributing
    the data across multiple instances of a database. The database is partitioned,
    or broken up, and stored in multiple databases.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序的设计是为了扩展而不是扩展。通过增加可用于数据库实例的资源，例如增加更多的核心或内存来实现数据库的扩展。这最终会遇到一个硬性限制并且成本高昂。通过在多个数据库实例之间分布数据来实现数据库的扩展。数据库被分区或分割，并存储在多个数据库中。
- en: Avoid Overfetching and Chatty I/O
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免过多获取和交互式I/O。
- en: Overfetching is when an application requests data from a database but needs
    only a fraction of the data for the operation. For example, an application might
    display a list of orders with a simple summary but request the entire order and
    order details without needing it. A chatty application, on the other hand, makes
    a lot of small calls to complete an operation when a single request can be made
    to the database.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 过多获取是指应用程序从数据库请求数据，但仅需要数据操作的一小部分。例如，应用程序可能会显示订单列表和简单摘要，但请求整个订单和订单详细信息而不需要这些详细信息。另一方面，喋喋不休的应用程序会进行大量的小型调用以完成操作，而单个请求可以向数据库发出。
- en: Don’t Put Business Logic in the Database
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要将业务逻辑放在数据库中。
- en: Too many application scaling issues are the result of putting too much logic
    in the database. Databases made it easy to put business logic inside the database
    by supporting standard development languages, and it became convenient to perform
    these tasks in the database. This often introduces scaling issues because a database
    is commonly an expensive shared resource.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 太多应用程序扩展问题的根源在于将太多逻辑放在数据库中。数据库通过支持标准开发语言，使得在数据库内部执行业务逻辑变得容易，并且执行这些任务在数据库中变得方便。这通常会引入扩展性问题，因为数据库通常是一种昂贵的共享资源。
- en: Test with Production-like Data
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用类似于生产环境的数据进行测试。
- en: Create automation to anonymize production data that can be updated with new
    rules as the data changes. Applications should be tested with production-like
    data. Data is sometimes pulled from production systems, scrubbed, and loaded into
    test systems to provide production-like data. You should automate this process
    so that it is easy to update as the data changes.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自动化流程对生产数据进行匿名化处理，并随着数据变更更新新规则。应用程序应该使用类似于生产环境的数据进行测试。有时会从生产系统中提取数据，进行清洗，并加载到测试系统中，以提供类似于生产环境的数据。您应该自动化此过程，以便随着数据变更而轻松更新。
- en: Handle Transient Failures
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理瞬时故障。
- en: As mentioned in the resiliency section of this chapter, failures will happen.
    Expect failures when making calls to a database and be prepared to handle them.
    Many of the database client libraries support transient fault handling already.
    It’s important to understand whether they do and how it’s supported.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章的弹性部分所述，调用数据库时可能会发生故障。在进行调用时预期故障，并准备处理它们。许多数据库客户端库已经支持暂时性故障处理。重要的是要了解它们是否支持以及如何支持。
- en: Performance and Scalability
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能和可伸缩性
- en: Performance indicates how well a system can execute an operation within a certain
    time frame, whereas scalability refers to how a system can handle load increase
    without impact on the performance. Predicting periods of increased activity to
    a system can be tough, so the components need to be able to scale out as needed
    to meet the increased demand and then scale down, after the demand decreases.
    The subsections that follow present some best practices to help you achieve optimal
    performance and scalability.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 性能（Performance）指示一个系统在特定时间框架内执行操作的能力，而可伸缩性（scalability）则是指系统如何处理负载增加而不影响性能。预测系统活动增加的时期可能会很困难，因此组件需要能够根据需要进行伸缩，以满足增加的需求，然后在需求减少后进行缩减。接下来的子节提供了一些最佳实践，以帮助您实现最佳性能和可伸缩性。
- en: Design Stateless Services That Scale Out
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计能够横向扩展的无状态服务
- en: Services should be designed to scale out. Scaling out is an approach to increasing
    the scale of a service by adding more instances of a service. Scaling up is an
    approach to scaling a service by adding more resources like memory or cores, but
    this method generally has a hard limit. By designing a service to scale out and
    back in, you can scale the service to handle variations in the load without impacting
    the availability of the service.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 应设计服务以进行横向扩展。横向扩展是通过增加服务的更多实例来增加服务的规模的一种方法。纵向扩展是通过增加内存或核心等资源来扩展服务的方法，但这种方法通常有硬性限制。通过设计服务以进行横向扩展和缩回，您可以扩展服务以处理负载变化，而不影响服务的可用性。
- en: Stateful applications are inherently difficult to scale and should be avoided.
    If stateful services are necessary, it’s generally best to separate the functionality
    from the application and use a partitioning strategy and managed services if they
    are available.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有状态应用程序本质上难以扩展，应尽量避免。如果有状态服务是必需的，通常最好将功能与应用程序分开，并使用分区策略和可管理的服务（如果有的话）。
- en: Use Platform Autoscaling Features
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用平台自动缩放功能
- en: When possible, use any autoscaling features that are built into the platform
    before implementing your own. Kubernetes offers Horizontal Pod Autoscaler (HPA).
    HPA scales the pods based on the CPU, memory, or custom metrics. You specify the
    metric (e.g., 85% of CPU or 16 GB of memory) and the minimum and maximum number
    of pod replicas. After the target metric is reached, Kubernetes automatically
    scales the pods. Similarly, cluster autoscaling scales the number of cluster nodes
    if pods can’t be scheduled. Cluster autoscaling uses the requested resources in
    the pod specification to determine whether nodes should be added.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，在实施自己的自动缩放之前，请使用平台内置的任何自动缩放功能。Kubernetes 提供水平 Pod 自动缩放器（HPA）。 HPA 根据
    CPU、内存或自定义指标扩展 Pod。您可以指定指标（例如，CPU 的 85% 或 16 GB 内存）以及 Pod 副本的最小和最大数量。达到目标指标后，Kubernetes
    会自动缩放 Pod。类似地，集群自动缩放会根据 Pod 规范中请求的资源来确定是否应该添加节点，如果无法调度 Pod，则会缩放集群节点数量。
- en: Use Caching
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存
- en: Caching is a technique that can help improve the performance of your component
    by temporarily storing frequently used data in storage that’s close to the component.
    This improves the response time because the component does not need to go to the
    original source. The most basic type of cache is an in-memory store that is being
    used by a single process. If you have multiple instances of your component, each
    instance will have its own independent copy of the in-memory cache. This can cause
    consistency problems if data is not static because the different instances will
    have different versions of cached data. To solve this problem, you can use shared
    caching, which ensures that different component instances use the same cached
    data. In this case, cache is stored separately, usually in front of the database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是一种技术，可以通过在靠近组件的存储中临时存储经常使用的数据来帮助提高组件的性能。这样做可以减少组件访问原始数据源的时间。最基本的缓存类型是单进程使用的内存存储。如果您有多个组件实例，则每个实例将具有自己独立的内存缓存副本。如果数据不是静态的，这可能会导致一致性问题，因为不同的实例将具有不同版本的缓存数据。为了解决这个问题，您可以使用共享缓存，确保不同的组件实例使用相同的缓存数据。在这种情况下，缓存通常是单独存储的，通常位于数据库之前。
- en: Use Partitioning to Scale Beyond Service Limits
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用分区来扩展服务限制之外的规模
- en: Cloud services will often have some defined scale limits. It’s important to
    understand the scalability limits of each of the services used and how much they
    can be scaled up. If a single service is unable to scale to meet the application’s
    requirements, create multiple service instances and partition work across the
    instances. For example, if a managed gateway was capable of handling 80% of the
    application’s intended load, create another gateway and split the services across
    the gateway.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务通常会有一些定义的规模限制。了解每个使用的服务的可伸缩性限制及其可扩展的程度非常重要。如果单个服务无法扩展以满足应用程序的要求，请创建多个服务实例并将工作分区到这些实例中。例如，如果一个托管网关能够处理应用程序预期负载的80%，则创建另一个网关并在网关之间分配服务。
- en: Functions
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: Much of the software development life cycle (SDLC) and general server architecture
    best practices are the same for serverless architectures. Given serverless is
    a different operating model, there are, however, some best practices specific
    to functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然软件开发生命周期（SDLC）和一般服务器架构最佳实践对无服务器架构也适用。然而，由于无服务器是一种不同的操作模型，因此有一些专门针对函数的最佳实践。
- en: Write Single-Purpose Functions
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 撰写单一目的的函数
- en: Follow the single-responsibility principle and only write functions that have
    a single responsibility. This will make your functions easier to reason about,
    test, and, when the time comes, debug.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循单一职责原则，只编写具有单一职责的函数。这将使您的函数更易于理解、测试，并且在需要时更易于调试。
- en: Don’t Chain Functions
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要链式调用函数
- en: In general, functions should push messages/data to a queue or a datastore to
    trigger any other functions if needed. Having one or more functions call other
    functions is often considered an antipattern that additionally increases your
    cost and makes the debugging more difficult. If your application requires the
    daisy-chaining of functions, you should consider using function offerings such
    as Azure Durable Functions or AWS Step Functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，函数应该将消息/数据推送到队列或数据存储中，以触发其他函数的执行。通常认为一个或多个函数调用其他函数是一个反模式，会增加成本并使调试更加困难。如果您的应用程序需要函数串联，您应考虑使用如Azure
    Durable Functions或AWS Step Functions之类的函数提供。
- en: Keep Functions Light and Simple
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持函数轻量和简单
- en: Each function should do just one thing and rely on only a minimal number of
    external libraries. Any extra and unnecessary code in the function makes the function
    bigger in size, and that affects the start time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数应只做一件事，并仅依赖最少数量的外部库。函数中额外和不必要的代码会增加函数的大小，从而影响其启动时间。
- en: Make Functions Stateless
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使函数无状态
- en: Don’t save any data in your functions because new function instances usually
    run in their own isolated environment and don’t share anything with other functions
    or invocations of the same function.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在函数中保存任何数据，因为新的函数实例通常在其自己的隔离环境中运行，不与其他函数或同一函数的调用共享任何内容。
- en: Separate Function Entry Point from the Function Logic
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将函数的入口点与函数逻辑分离开来
- en: Functions will have an entry point invoked by the function framework. Framework-specific
    context is generally passed to the function entry point, along with invocation
    context. For example, if the function is invoked through an HTTP request like
    an API gateway, the context will contain HTTP-specific details. The entry-point
    method should separate these entry-point details from the rest of the code. This
    will improve manageability, testability, and portability of the functions.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 函数将由函数框架调用入口点。通常，框架特定的上下文将传递给函数入口点，以及调用上下文。例如，如果函数通过类似 API 网关的 HTTP 请求调用，则上下文将包含
    HTTP 特定的细节。入口方法应将这些入口点细节与代码的其余部分分开。这将提高函数的可管理性、可测试性和可移植性。
- en: Avoid Long-Running Functions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免长时间运行的函数
- en: Most Function as a Service (FaaS) offerings have an upper limit for execution
    time per function. As a result, long-running functions can cause issues such as
    increased load times and timeouts. Whenever possible, refactor large functions
    into smaller ones that work together.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数函数即服务（FaaS）提供的函数执行时间有上限。因此，长时间运行的函数可能会导致诸如增加的加载时间和超时等问题。在可能的情况下，将大函数重构为更小的函数，这些函数共同工作。
- en: Use Queues for Cross-Function Communication
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用队列进行跨函数通信
- en: Instead of passing information among one another, functions should use a queue
    to which to post the messages. Other functions can be triggered and executed based
    off the events that happen on that queue (item added, removed, updated, etc.).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数之间应该使用队列而不是互相传递信息。其他函数可以基于队列上发生的事件（添加、删除、更新等）来触发和执行。
- en: Operations
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运维
- en: A DevOps practice provides the foundation necessary for organizations to make
    the best use of cloud technologies. Cloud native applications utilize DevOps principles
    and best practices that are detailed in [Chapter 5](ch05.xhtml#devops).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 实践为组织充分利用云技术提供了必要的基础。云原生应用程序利用详细说明的 DevOps 原则和最佳实践，详见 [第 5 章](ch05.xhtml#devops)。
- en: Deployments and Releases Are Separate Activities
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署和发布是分开的活动
- en: It is important to make a distinction between deployment and release. Deployment
    is the act of taking the built component and placing it within an environment—the
    component is fully configured and ready to go; however, there is no traffic being
    sent to it. As part of the component release, we begin to allow traffic to the
    deployed component. This separation allows you to do gradual releases, A/B testing,
    and canary deployments in a controlled manner.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 很重要的是要区分部署和发布。部署是将构建的组件放置在环境中的行为 —— 组件已完全配置且准备就绪；然而，此时尚未向其发送流量。作为组件发布的一部分，我们开始允许流量访问已部署的组件。这种分离允许您以受控的方式进行渐进式发布、A/B
    测试和金丝雀部署。
- en: Keep Deployments Small
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持小型部署
- en: Each component deployment should be a small event that can be performed by a
    single team in a short time. There is no general rule about how small a deployment
    should be and how much time it should take to deploy a component, because this
    is highly dependent on the component, your process, and the change to the component.
    A good approach is to be able to roll out a critical fix within a day.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 每个组件部署应该是一个小事件，可以由一个团队在短时间内完成。关于部署的大小和时间没有通用规则，因为这高度依赖于组件、您的流程和对组件的更改。一个好的方法是能够在一天内推出关键修复。
- en: CI/CD Definition Lives with the Component
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD 定义与组件同在
- en: You need to store and version any CI/CD configuration and dependencies alongside
    the component. Each push to the component’s branch triggers the pipeline and executes
    jobs defined in the CI/CD configuration. To control component deployments to different
    environments (development, staging, production), you can use the Git branch names
    and configure your pipeline to deploy the master branch only to a production environment,
    for example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要存储和版本化与组件一起的任何 CI/CD 配置和依赖关系。每次推送到组件分支都会触发流水线，并执行在 CI/CD 配置中定义的作业。为了控制组件部署到不同环境（开发、演示、生产），您可以使用
    Git 分支名称，并配置流水线仅将主分支部署到生产环境，例如。
- en: Consistent Application Deployment
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致的应用程序部署
- en: With a consistently reliable and repeatable deployment process, you can minimize
    errors. Automate as many processes as possible and ensure that you have a rollback
    plan defined in case deployment fails.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过一个持续可靠且可重复的部署过程，您可以最小化错误。尽可能自动化进程，并确保在部署失败时定义了回滚计划。
- en: Use Zero-Downtime Releases
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用零停机时间发布
- en: To maximize the availability of your system during releases, consider using
    zero-downtime releases such as blue/green or canary. Using one of these approaches
    also allows you to quickly roll back the update in case of failures.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在发布期间最大化系统的可用性，考虑使用蓝/绿或金丝雀等零停机时间发布。使用这些方法之一还允许您在出现故障时快速回滚更新。
- en: Don’t Modify Deployed Infrastructure
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要修改已部署的基础设施
- en: Infrastructure should be immutable. Modifying deployed infrastructure can quickly
    get out of hand, and keeping track of what changed can be complicated. If you
    need to update the infrastructure, redeploy it instead.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施应该是不可变的。修改已部署的基础设施可能会迅速失控，并且跟踪更改内容可能会变得复杂。如果需要更新基础设施，请重新部署它。
- en: Use Containerized Build
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器化构建
- en: To avoid configuring build environments, package your build process into Docker
    containers. Consider using multiple images and containers for builds instead of
    creating a single, monolithic build image.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免配置构建环境，请将您的构建过程打包到 Docker 容器中。考虑使用多个图像和容器进行构建，而不是创建单个的、单块的构建图像。
- en: Describe Infrastructure Using Code
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用代码描述基础设施
- en: Infrastructure should be described using either cloud provider’s declarative
    templates or a programming language or scripts that provision the infrastructure.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 基础设施应该使用云提供商的声明性模板或编程语言或脚本来描述和提供基础设施。
- en: Use Namespaces to Organize Services in Kubernetes
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命名空间组织 Kubernetes 中的服务
- en: Every resource in a Kubernetes cluster belongs to a namespace. By default, newly
    created resources go into a namespace called *default*. For better organization
    of services, it is a good practice to use descriptive names and group services
    into bounded contexts.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中，每个资源都属于一个命名空间。默认情况下，新创建的资源将进入一个名为*default*的命名空间。为了更好地组织服务，使用描述性名称并将服务分组到有界上下文是一个好的实践。
- en: Isolate the Environments
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离环境
- en: Use a dedicated production cluster and physically separate the production cluster
    for your development, staging, or testing environments.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用专用的生产集群，并在您的开发、预备或测试环境中物理分离生产集群。
- en: Separate Function Source Code
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离功能源代码
- en: Each function must be independently versioned and have its own dependencies.
    If that’s not the case, you will end up with a monolith and a tightly coupled
    codebase.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 每个功能必须独立进行版本控制并具有其自己的依赖关系。如果不是这种情况，您将得到一个单体和紧密耦合的代码库。
- en: Correlate Deployments with Commits
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将部署与提交相关联
- en: Pick a branching strategy that allows you to correlate the deployments to specific
    commits in your branch and that also allows you to identify which version of the
    source code is deployed.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 选择一个分支策略，使您能够将部署与分支中的特定提交相关联，并且还允许您确定部署的源代码版本。
- en: Logging, Monitoring, and Alerting
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志记录、监控和警报
- en: Application and infrastructure logging can provide much more value than just
    root-cause analysis. A proper logging solution will provide valuable insights
    into applications and systems, and it’s often necessary for monitoring the health
    of an application and alerting operations of important events. As cloud applications
    become more distributed, logging and instrumentation become increasingly challenging
    and important.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序和基础设施日志记录可以提供比仅仅根本原因分析更多的价值。一个适当的日志记录解决方案将为应用程序和系统提供宝贵的洞察，并且通常对监控应用程序的健康和警报操作的重要事件是必要的。随着云应用程序变得更加分布式，日志记录和仪表化变得越来越具有挑战性和重要性。
- en: Use a Unified Logging System
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用统一的日志系统
- en: Use a unified logging system capable of capturing log messages across all services
    and levels of a system and store them in a centralized store. Whether you move
    all logs to a centralized store for analysis and search, or you leave them on
    the machine with the necessary tools in place to run a distributed query, it’s
    important that an engineer can find and analyze logs without having to go from
    one system to the next.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 使用能够捕获系统中所有服务和层级的日志消息并将其存储在集中存储中的统一日志系统。无论您将所有日志移动到集中存储以进行分析和搜索，还是在机器上留下它们，并配备有必要的工具来运行分布式查询，工程师都能够找到并分析日志而不必从一个系统到另一个系统。
- en: Use Correlation IDs
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用关联 ID
- en: Include a unique correlation ID (CID) that is passed through all services. If
    one of the services fails, the correlation ID is used to trace the request through
    the system and pinpoint where the failure occurred.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 包含一个通过所有服务传递的唯一关联 ID（CID）。如果其中一个服务失败，关联 ID 用于跟踪请求通过系统并准确定位故障发生的位置。
- en: Include Context with Log Entries
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在日志条目中包含上下文
- en: Each log entry should contain additional context that can help when you are
    investigating issues. For example, include all exception handling, retry attempts,
    service name or ID, image version, binary version, and so on.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个日志条目应包含在调查问题时有助的额外上下文。例如，包括所有异常处理、重试尝试、服务名称或ID、图像版本、二进制版本等等。
- en: Common and Structured Logging Format
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见且结构化的日志格式
- en: Decide on a common and structured logging format that all components will use.
    This will allow you to quickly search and parse the logs later on. Also, make
    sure you are using the same time zone information in all your components. In general,
    it is best to adhere to a common time format such as Coordinated Universal Time
    (UTC).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 确定所有组件将使用的常见和结构化日志格式。这将使你能够快速搜索和解析日志。另外，请确保所有组件使用相同的时区信息。一般来说，最好遵循协调世界时（UTC）等常见的时间格式。
- en: Tag Your Metrics Appropriately
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的度量标记适当的标签
- en: In addition to using clear and unique metric names, make sure that you are storing
    any additional information, such as component name, environment, function name,
    region, and so forth, in the metric tags. With tags in place, you can create queries,
    dashboards, and reports using multiple dimensions (e.g., average latency across
    a specific region or across regions for a specific function).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用清晰且唯一的度量标签外，确保存储任何额外信息，例如组件名称、环境、函数名称、区域等等。有了标签，你可以使用多维度（例如，特定区域的平均延迟或特定函数的多个区域的延迟）创建查询、仪表板和报告。
- en: Avoid Alert Fatigue
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 避免警报疲劳
- en: 'The sheer number of metrics makes it difficult to determine how to set up the
    alerting and what to alert on. If you are firing off too many alerts, eventually
    people will stop paying attention to them and no longer take them seriously. Also,
    investigating a bunch of alerts can become overwhelming and it could be the only
    thing your team is doing. It is important to classify alerts by severity: low,
    moderate, and high. The purpose of low-severity alerts is to potentially use them
    later, when doing root-cause analysis of a high-severity alert. You can use them
    to uncover certain patterns, but they do not require any immediate action when
    fired. A moderate-severity alert should either create a notification or open a
    ticket. These are the alerts you want to look at, but are not high priority and
    don’t need immediate action. They could represent a temporary condition (increase
    demand, for example) that eventually goes away. They also give you an early warning
    of a possible high-severity alert. Finally, high-severity alerts are the ones
    that will wake people up in the middle of the night and require immediate action.
    Recently, machine learning–based approaches to automatically triage issues and
    raise alerts are gaining in popularity, and the term AIOps has even been introduced.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的度量标准使得设置警报和何时发出警报变得困难。如果触发了太多警报，最终人们将停止关注它们并不再认真对待。此外，调查一堆警报可能会变得很压倒，甚至可能是你的团队唯一在做的事情。重要的是按严重性对警报进行分类：低、中和高。低严重性警报的目的是在高严重性警报的根本原因分析时可能会用到。你可以用它们来发现某些模式，但在触发时不需要立即采取行动。中等严重性警报应该创建通知或开启工单。这些是你想要查看的警报，但不是高优先级并且不需要立即采取行动。它们可能代表一个临时条件（例如需求增加），最终会消失。它们还可以提前警告可能的高严重性警报。最后，高严重性警报会在半夜唤醒人们并要求立即采取行动。最近，基于机器学习的自动分类问题和发出警报的方法越来越受欢迎，甚至引入了AIOps这个术语。
- en: Define and Alert on Key Performance Indicators
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义并在关键性能指标上发出警报
- en: Cloud native systems will have a plethora of signals that are being emitted
    and monitored. You need to filter down those signals and determine which ones
    are the most important and valuable. These Key Performance Indicators (KPIs) give
    you insight into the health of your system. For example, one KPI is latency, which
    measures the time it takes to service a request. If you begin seeing latency increase
    or deviate from an acceptable range, it is probably time to issue an alert and
    have someone take a look at it. In addition to KPIs, you can use other signals
    and metrics to determine why something is failing.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生系统会发出和监控大量信号。你需要筛选出其中最重要和有价值的信号。这些关键性能指标（KPI）可以让你了解系统的健康状况。例如，一个KPI是延迟，用于衡量处理请求所需的时间。如果看到延迟增加或偏离可接受范围，可能是时候发出警报并请人查看了。除了KPI，你还可以使用其他信号和度量来确定某些事情失败的原因。
- en: Continuous Testing in Production
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生产中的持续测试
- en: 'Using continuous testing you can generate requests that are sent throughout
    the system and simulate real users. You can utilize this traffic to get test coverage
    for the components, discover potential issues, and test your monitoring and alerting.
    Following are some common continuous testing practices:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用持续测试可以生成发送到系统各处并模拟真实用户的请求。您可以利用这些流量对组件进行测试覆盖率、发现潜在问题，并测试您的监控和警报。以下是一些常见的持续测试实践：
- en: Blue/green deployments
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: Canary testing
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 金丝雀测试
- en: A/B testing
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: A/B 测试
- en: These practices are discussed in [Chapter 5](ch05.xhtml#devops).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实践在[第 5 章](ch05.xhtml#devops)中讨论。
- en: Start with Basic Metrics
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从基本指标开始
- en: Ensure that you are always collecting traffic (how much demand is placed on
    the component), latency (the time it takes to service a request), and errors (rate
    of requests that fail) for each component in your system.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 确保始终收集系统中每个组件的流量（组件承受的需求量）、延迟（服务请求所需的时间）和错误（请求失败率）。
- en: Service Communication
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务通信
- en: Service communication is an important part of cloud native applications. Whether
    it’s a client communicating with a backend, a service communicating with a database,
    or the individual services in a distributed architecture communicating with one
    another, these interactions are an important part of cloud native applications.
    Many different forms of communication are used depending on the requirements.
    The following subsections offer some best practices for service communication.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 服务通信是云原生应用程序的重要组成部分。无论是客户端与后端的通信，服务与数据库的通信，还是分布式架构中的各个服务之间的通信，这些交互都是云原生应用程序的重要组成部分。根据需求使用多种不同形式的通信。以下各小节提供了一些服务通信的最佳实践。
- en: Design for Backward and Forward Compatibility
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计向后和向前兼容
- en: With backward compatibility, you ensure that new functionality added to a service
    or component does not break any existing service. For example, in [Figure 6-3](#backward_compatibility-id1),
    Service A v1.0 works with Service B v1.0\. Backward compatibility means that the
    release of Service B v1.1 will not break the functionality of Service A.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向后兼容性，确保添加到服务或组件的新功能不会破坏任何现有服务。例如，在[图 6-3](#backward_compatibility-id1)中，服务
    A v1.0 与服务 B v1.0 兼容。向后兼容性意味着发布的服务 B v1.1 不会破坏服务 A 的功能。
- en: '![clna 0603](Images/clna_0603.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![clna 0603](Images/clna_0603.png)'
- en: Figure 6-3\. Backward compatibility
  id: totrans-183
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 6-3. 向后兼容性
- en: To ensure backward compatibility, any new fields added to the API should be
    optional or have sensible defaults. Any existing fields should never be renamed,
    because that will break the backward compatibility.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保向后兼容性，应向 API 添加的任何新字段都应是可选的或具有合理的默认值。任何现有字段不应更名，因为这将破坏向后兼容性。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '*Parallel change*, also known as the *Expand and Contract* pattern, can be
    used to safely introduce backward-incompatible changes. As an example, say a service
    owner would like to change a property or resource on an interface. The service
    owner will expand the interface with a new property or resource, and then after
    all consumers have had a chance to move the service interface, the previous property
    is removed.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '*并行更改*，也称为*扩展和收缩*模式，可用于安全地引入向后不兼容的更改。例如，假设服务所有者想要在接口上更改属性或资源。服务所有者将通过新的属性或资源扩展接口，然后在所有消费者有机会迁移服务接口之后，删除先前的属性。'
- en: 'If your system or components need to ensure rollback functionality, you will
    need to think about the forward compatibility as you’re making changes to your
    service. Forward compatibility means that your components are compatible with
    future versions. Your service should be able to accept “future” data and messaging
    formats and handle them appropriately. A good example of forward compatibility
    is HTML: when it encounters an unknown tag or attribute, it’s not going to fail;
    it will just skip it.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的系统或组件需要确保回滚功能，那么在修改服务时，需要考虑其向前兼容性。向前兼容性意味着您的组件与未来版本兼容。您的服务应能够接受“未来”数据和消息格式，并适当处理。向前兼容性的一个很好的例子是
    HTML：当它遇到未知标签或属性时，不会导致失败；它只会跳过它们。
- en: Define Service Contracts That Do Not Leak Internal Details
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义不泄漏内部细节的服务契约
- en: A service that exposes an API should define contracts and test against the contracts
    when releasing updates. For example, a REST-based service would generally define
    a contract in the OpenAPI format or as documentation, and consumers of the service
    would build to this contract. Updates to the service can be pushed, and as long
    as it doesn’t introduce any breaking changes to the API contract, these releases
    would not affect the consumer. Leaking internal implementations of a service can
    make it difficult to make changes and introduces coupling. Don’t assume a consumer
    is not using some piece of data exposed through the API.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 暴露 API 的服务应定义契约，并在发布更新时进行契约测试。例如，基于 REST 的服务通常会以 OpenAPI 格式或文档的形式定义契约，而服务的消费者会根据这个契约进行开发。只要更新不会对
    API 契约造成破坏性变更，服务的更新就可以推送，这样就不会影响消费者。泄露服务的内部实现可能会导致难以进行更改并引入耦合。不要假设消费者不会使用通过 API
    公开的某些数据。
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Services that publish messages to a queue or a stream should also define a contract
    in the same way. The service publishing the events will generally own the contract.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 发布消息到队列或流的服务也应以同样的方式定义契约。通常会发布事件的服务会拥有这个契约。
- en: Prefer Asynchronous Communication
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优先使用异步通信
- en: Use asynchronous communication whenever possible. It works well with distributed
    systems and decouples the execution of two or more services. A message bus or
    a stream is often used when implementing this approach, but you could use direct
    calls through something like gRPC as well. Both use a message bus as a channel.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能使用异步通信。它与分布式系统很搭配，并解耦了两个或更多服务的执行。在实现此方法时通常会使用消息总线或流，但也可以通过像 gRPC 这样的直接调用来实现。两者都使用消息总线作为通道。
- en: Use Efficient Serialization Techniques
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用高效的序列化技术
- en: Distributed applications like those built using a microservices architecture
    rely more heavily on communications and messaging between services. The data serialization
    and deserialization can add a lot of overhead in service communication.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 像使用微服务架构构建的分布式应用程序更依赖于服务之间的通信和消息传递。数据序列化和反序列化在服务通信中会增加很多额外开销。
- en: Note
  id: totrans-196
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In one case, serialization and deserialization were found to account for nearly
    40% of the CPU utilization across all the services. Replacing the standard JSON
    serialization library with a custom one reduced this overhead to roughly 15% of
    overall CPU utilization.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在某个案例中，序列化和反序列化被发现占据了所有服务中近 40% 的 CPU 利用率。将标准的 JSON 序列化库替换为自定义库将这一开销减少到大约总 CPU
    利用率的 15%。
- en: Use efficient serialization formats like protocol buffers, commonly used in
    gRPC. Understand the trade-offs with the different serialization formats, because
    tooling and consumer requirements might not make this a feasible option. You can
    also use other techniques to reduce the need for serialization in some services
    by placing some of the data into headers. For example, if a service receives a
    request and operates on only a handful of fields in a large message payload before
    passing it to a downstream service, by putting these fields into headers the service
    does not need to deserialize or reserialize the payload. The service reads and
    writes headers and then simply passes the entire payload through to the downstream
    services.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用诸如协议缓冲区这样的高效序列化格式，它在 gRPC 中被广泛使用。了解不同序列化格式的权衡是很重要的，因为工具和消费者的要求可能不会使这成为可行的选择。您还可以通过将一些数据放入头部来减少某些服务中序列化的需求。例如，如果一个服务接收到请求并在大量消息负载中仅操作少量字段然后将其传递给下游服务，通过将这些字段放入头部，该服务就无需对负载进行反序列化或重新序列化。该服务读取和写入头部，然后简单地将整个负载传递给下游服务。
- en: Use Queues or Streams to Handle Heavy Loads and Traffic Spikes
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用队列或流处理大量负载和流量峰值
- en: A queue or a stream between components acts as a buffer and stores the message
    until it is retrieved. Using a queue allows the components to process the messages
    at their own pace, regardless of the incoming volume or load. Consequently, this
    helps maximize the availability and scalability of your services.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 组件之间的队列或流作为缓冲区，存储消息直到检索。使用队列允许组件以自己的节奏处理消息，无论传入的数量或负载如何。因此，这有助于最大化服务的可用性和可扩展性。
- en: Batch Requests for Efficiency
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 批量请求以提高效率
- en: Queues can be used for batching multiple requests and performing an action only
    once. For example, it is more efficient to write 1,000 batched entries into the
    database instead of one entry at a time 1,000 times.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 队列可以用于批处理多个请求并执行一次操作。例如，将 1,000 个批处理条目写入数据库比每次写入一次 1,000 次更有效率。
- en: Split Up Large Messages
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拆分大消息
- en: Sending, receiving, and manipulating large messages requires more resources
    and can slow down your entire system. The *Claim-Check* pattern talks about splitting
    a large message into two parts. You store the entire message in an external service
    (database, for example) and send only the reference to the message. Any interested
    message receivers can use the reference to obtain the full message from the database.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 发送、接收和操作大消息需要更多资源，并可能减慢整个系统。*Claim-Check* 模式讨论了将大消息拆分为两部分的方法。您可以将整个消息存储在外部服务中（例如数据库），并仅发送消息的引用。任何感兴趣的消息接收者可以使用引用从数据库中获取完整的消息。
- en: Containers
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器
- en: It’s possible to run most applications in a Docker container without very much
    effort. However, there are some potential pitfalls when running containers in
    production and streamlining the build, deployment, and monitoring. A number of
    best practices have been identified to help avoid the pitfalls and improve the
    results.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 可以很容易地在 Docker 容器中运行大多数应用程序。然而，在生产环境中运行容器和优化构建、部署和监控时，可能会遇到一些潜在的问题。已经确定了一些最佳实践，以帮助避免这些问题并改善结果。
- en: Store Images in a Trusted Registry
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将镜像存储在受信任的注册表中
- en: Any images running on the platform should come from the trusted container image
    registry. Kubernetes exposes a webhook (validating admission) that can be used
    to ensure pods can use images only from a trusted registry. If you’re using Google
    Cloud, you can take advantage of the binary authorization security measure that
    ensures only trusted images are deployed on your cluster.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 平台上运行的任何镜像都应来自受信任的容器镜像注册表。Kubernetes 提供了一个 webhook（验证接入），可以用来确保 Pod 只能使用来自受信任注册表的镜像。如果您使用
    Google Cloud，可以利用二进制授权安全措施，确保仅在集群上部署受信任的镜像。
- en: Utilize the Docker Build Cache
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用 Docker 构建缓存
- en: Using the build cache when building Docker images can speed up the build process.
    All images are built up from layers, and each line in the Dockerfile contributes
    a layer to the final image. During the build, Docker will try to reuse a layer
    from a previous build instead of building it again. However, it can reuse only
    the cached layers if all previous build steps used it as well. To get the most
    out of the Docker build cache, put the commands that change more often (e.g.,
    adding the source code to the image, building the source code) at the end of the
    Dockerfile. That way, any preceding steps will be reused.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 使用构建缓存在构建 Docker 镜像时可以加快构建过程。所有镜像都是由层次构成的，每个 Dockerfile 中的命令都为最终镜像贡献了一层。在构建过程中，Docker
    将尝试重用上一次构建的层次而不是再次构建它。然而，只有当所有前面的构建步骤也使用了缓存的层次时，它才能重新使用缓存的层次。为了充分利用 Docker 构建缓存，将更经常变化的命令（例如将源代码添加到镜像中、构建源代码）放在
    Dockerfile 的末尾。这样，任何前面的步骤都将被重用。
- en: Don’t Run Containers in Privileged Mode
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要在特权模式下运行容器
- en: Running containers in privileged mode allows access to everything on the host.
    Use the security policy on the pod to prevent containers from running in privileged
    mode. If a container does for some reason require privileged mode to make changes
    to the host environment, consider separating that functionality from the container
    and into the infrastructure provisioning.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在特权模式下运行容器允许访问主机上的所有内容。使用 Pod 上的安全策略阻止容器在特权模式下运行。如果某个容器确实因某种原因需要特权模式以对主机环境进行更改，则考虑将该功能从容器分离并放入基础设施配置中。
- en: Use Explicit Container Image Tags
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用明确的容器镜像标签
- en: Always tag your container images with specific tags that tightly link the container
    image to the code that is packaged in the image. To tag the images properly, you
    can either use a Git commit hash that uniquely identifies the version of the code
    (e.g., `1f7a7a472`) or use a semantic version (e.g., `1.0.1`). The tag `latest`
    is used as a default value if no tag is provided; however, because it’s not tightly
    linked to the specific version of the code, you should avoid using it. The latest
    tag should never be used in a production environment because it can cause inconsistent
    behavior that can be difficult to troubleshoot.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用与打包在镜像中的代码紧密关联的特定标签标记容器镜像。为了正确标记图像，您可以使用唯一标识代码版本的Git提交哈希（例如，`1f7a7a472`）或使用语义版本（例如，`1.0.1`）。如果未提供标签，则默认使用`latest`标签；然而，由于它与特定代码版本的紧密联系不足，应避免在生产环境中使用。永远不应在生产环境中使用`latest`标签，因为它可能导致不一致的行为，难以排查故障。
- en: Keep Container Images Small
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持容器镜像小巧
- en: 'In addition to taking up less space in a container registry or the host system
    using the image to run a container, smaller images improve image push and pull
    performance. This in turn improves the performance when you start containers as
    part of deploying or scaling a service. The application and its dependencies will
    have some impact on the size of the image, but you can reduce most of the image
    size by using lean base images and ensuring that unnecessary files are not included
    in the image. For example, the alpine 3.9.4 image is only 3 MB, with the Debian
    stretch image at 45 MB, and the CentOS 7.6.1810 at 75 MB. The distributions generally
    offer a slim version that removes more from the base image that might not be needed
    by the application. Generally, there are two things to keep in mind for keeping
    images lean:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 将镜像尽可能地缩小，不论是在容器注册表还是主机系统中使用镜像运行容器，都能减少空间占用。小型镜像提高了镜像的推送和拉取性能。这进一步提升了在部署或扩展服务时启动容器的性能。应用及其依赖关系会影响镜像大小，但通过使用精简基础镜像并确保不包含不必要的文件，可以大幅减少镜像大小。例如，Alpine
    3.9.4镜像仅有3 MB，Debian Stretch镜像为45 MB，CentOS 7.6.1810镜像则为75 MB。这些发行版通常提供了精简版本，从基础镜像中删除可能不需要的内容，这不被应用所需。保持镜像精简需要牢记两点：
- en: Start with a lean base image
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择精简基础镜像开始
- en: Include only the files needed for the operation of the application
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅包含应用程序操作所需的文件
- en: You can use the Container Builder pattern to create lean images by separating
    the images used to build the artifacts from the base image used to run the application.
    Docker’s multistage build is often used to implement this. You can create Docker
    build files that can start from different images used for executing the commands
    to build and test artifacts, and then define another base image as part of creating
    the image to run the application.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用容器构建模式通过将用于构建工件的图像与用于运行应用程序的基础图像分离，创建精简镜像。Docker的多阶段构建通常用于实现此目的。您可以创建Docker构建文件，从不同的图像开始执行构建和测试工件的命令，然后在创建运行应用程序镜像的过程中定义另一个基础图像。
- en: Tip
  id: totrans-220
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Using a *.dockerignore* file can improve build speed by excluding files that
    are not needed in the Docker build.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用*.dockerignore*文件可以通过排除Docker构建中不需要的文件来提高构建速度。
- en: Run One Application per Container
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个容器内运行一个应用程序
- en: Always run a single application within a container. Containers were designed
    to run a single application, with the container having the same life cycle as
    the application running in the container. Running multiple applications within
    the same container makes it difficult to manage, and you might end up with a container
    in which one of the processes has crashed or is unresponsive.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 每个容器内仅运行单一应用程序。容器设计为仅运行单一应用程序，容器与其中运行的应用程序具有相同的生命周期。在同一容器内运行多个应用程序会增加管理难度，并可能导致容器中某些进程崩溃或无响应。
- en: Use Verified Images from Trusted Repositories
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用受信任仓库的验证图像
- en: There’s a large and growing number of publicly available images that are helpful
    when working with containers. Docker repository tags are mutable, so it’s important
    to understand that the images can change. When using images in an external repository
    it’s best to copy or re-create them from the external repository into one managed
    by the organization. The organization’s repository is usually closer to the CI
    services, and this approach removes another service dependency that could impact
    build.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量且不断增长的公开可用镜像，在处理容器时非常有用。Docker 仓库标签是可变的，因此理解镜像可能会变化至关重要。当使用外部仓库中的镜像时，最好将其从外部仓库复制或重新创建到组织管理的仓库中。组织的仓库通常更接近
    CI 服务，这种方法可以消除可能影响构建的其他服务依赖。
- en: Use Vulnerability Scanning Tools on Images
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在镜像上使用漏洞扫描工具
- en: You need to be aware of any vulnerabilities that affect your images because
    this can compromise the security of your system. If a vulnerability is discovered,
    you need to rebuild the image with the patches and fixes included and then redeploy
    it. Some cloud providers offer vulnerability scanning with their image registry
    solutions, so make sure you are taking advantage of those features.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要注意影响你的镜像的任何漏洞，因为这可能会危及系统的安全性。如果发现漏洞，需要重新构建镜像，并包含补丁和修复程序，然后重新部署它。一些云提供商在其镜像注册解决方案中提供漏洞扫描功能，因此确保你充分利用这些功能。
- en: Tip
  id: totrans-228
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Scan an image as often as possible because new cybersecurity vulnerabilities
    and exposures (CVE) are released daily.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 尽可能频繁地扫描镜像，因为每天都会发布新的网络安全漏洞和暴露（CVE）。
- en: Don’t Store Data in Containers
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不要在容器中存储数据
- en: Containers are ephemeral—they can be stopped, destroyed, or replaced without
    any loss of data. If the service running in a container needs to store data, use
    a volume mount to save the data. The contents in a volume exist outside the life
    cycle of a container and a volume does not increase the size of a container. If
    the container requires temporary nonpersistent writes, use a tmpfs mount, which
    will improve performance by avoiding writes to a container’s writable layer.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是临时的 —— 它们可以停止、销毁或替换而不会丢失数据。如果运行在容器中的服务需要存储数据，请使用卷挂载来保存数据。卷中的内容存在于容器的生命周期之外，并且卷不会增加容器的大小。如果容器需要临时非持久性写入，请使用
    tmpfs 挂载，这将通过避免向容器的可写层写入来提高性能。
- en: Never Store Secrets or Configuration Inside an Image
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 永远不要在镜像内部存储机密或配置信息
- en: Hardcoding any type of secrets within an image is something you want to avoid.
    If your container requires any secrets, define them within environment variables
    or as files, mounted to the container through a volume.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在镜像内部硬编码任何类型的机密是应该避免的。如果你的容器需要任何机密信息，请将其定义为环境变量或文件，并通过卷挂载到容器中。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: We could easily fill an entire book covering best practices for cloud native
    applications given the number of technologies involved. However, there are certain
    areas that have been coming up repeatedly in customer conversations, and this
    chapter has covered a collection of best practices, tips, and proven patterns
    for cloud native applications for those areas. You should have a better understanding
    of the factors you may want to consider.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 针对云原生应用程序的最佳实践有很多技术涉及，我们可以轻松撰写一整本书来覆盖这些内容。然而，在客户交流中反复出现的特定领域，本章节已经涵盖了一系列云原生应用程序的最佳实践、技巧和验证的模式。你应该对你可能需要考虑的因素有更深入的理解。
