- en: Chapter 6\. Advanced Chart Features
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。高级图表特性
- en: There is more to charts than metadata about the chart and a collection of templates.
    Charts can have dependencies, values can have schemas, Helm has life cycle hooks,
    you can sign charts, and more. In this chapter you will learn about other elements
    of charts, moving beyond templates.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 图表不仅仅是关于图表的元数据和一组模板。图表可以有依赖关系，值可以有模式，Helm具有生命周期钩子，您可以签名图表，等等。在本章中，您将学习有关图表的其他元素，超越模板。
- en: These features provide powerful solutions to common problems that arise when
    building packages. The chapter starts by covering dependencies. Dependencies are
    a critical part of virtually every package management solution because they let
    you leverage existing packages in your solution and build on the work of others.
    It then goes on to cover schemas and validation, which are useful when you want
    to help chart users avoid issues before covering ways you can hook into processes
    Helm performs to execute custom actions. This chapter covers tests and testing
    as well—tests are vital in development because they ensure your software is running
    as expected. Helm provides security features that aid in mitigating some common
    threat paths, which are covered next. The chapter concludes by looking at how
    charts can be used to extend the Kubernetes API.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能提供了解决构建软件包时常见问题的强大解决方案。本章从覆盖依赖关系开始。依赖关系是几乎每个软件包管理解决方案的关键部分，因为它们让您在解决方案中利用现有的软件包并建立在他人的工作之上。然后它继续覆盖模式和验证，当您希望帮助图表用户在覆盖Helm执行自定义操作的过程中避免问题时，这些都是有用的。本章还涵盖了测试和测试——在开发中测试非常重要，因为它们确保您的软件按预期运行。Helm提供了安全功能，有助于减轻一些常见的威胁路径，接下来将对其进行覆盖。本章最后讨论了如何使用图表来扩展Kubernetes
    API。
- en: Throughout this chapter, you will see charts as examples you can reference at
    [*https://github.com/masterminds/learning-helm/blob/main/chapter6*](https://github.com/masterminds/learning-helm/blob/main/chapter6).
    They showcase different features covered in the chapter along with a Helm repository.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在整个本章中，您将看到图表作为您可以参考的示例，位于[*https://github.com/masterminds/learning-helm/blob/main/chapter6*](https://github.com/masterminds/learning-helm/blob/main/chapter6)。它们展示了本章涵盖的不同特性以及Helm仓库。
- en: Chart Dependencies
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图表依赖项。
- en: Dependencies are a common element of package managers and their packages. Charts
    can have dependencies on other charts. This enables the encapsulation of a service
    in a chart, the reuse of charts, and the use of multiple charts together.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系是包管理器及其软件包的常见元素。图表可以依赖于其他图表。这使得在图表中封装服务、重用图表以及将多个图表一起使用成为可能。
- en: To illustrate dependencies, consider a chart to install WordPress, the popular
    blogging software. WordPress depends on a MySQL-compliant database to store the
    blog content, users, and other configuration. A MySQL-compliant database can be
    used by other applications and can be consumed as a service. One way to handle
    the use of MySQL with WordPress is to put the manifests for it in the WordPress
    chart. Another way to handle it is to have a MySQL chart that stands alone while
    the WordPress chart has a dependency on it. Having a MySQL-compliant database
    as an independent chart enables it to be used by more than one application, and
    the database can be built and tested independently.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明依赖关系，考虑一个安装WordPress的图表，这是一款流行的博客软件。WordPress依赖于一个符合MySQL标准的数据库，用于存储博客内容、用户和其他配置。一个符合MySQL标准的数据库可以被其他应用程序使用，并且可以作为一个服务来消费。处理WordPress中使用MySQL的一种方式是将其清单放在WordPress图表中。另一种处理方式是有一个独立的MySQL图表，而WordPress图表则依赖于它。将符合MySQL标准的数据库作为独立图表使其能够被多个应用程序使用，并且可以独立构建和测试。
- en: 'Dependencies are specified in the *Chart.yaml* file. The following is the `dependencies`
    section in the *Chart.yaml* file for a chart named *rocket*:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系在*Chart.yaml*文件中指定。以下是名为*rocket*的图表的*Chart.yaml*文件中的`dependencies`部分。
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](Images/1.png)](#co_advanced_chart_features_CO1-1)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_chart_features_CO1-1)'
- en: The name of the dependent chart within the repository.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库中依赖图表的名称。
- en: '[![2](Images/2.png)](#co_advanced_chart_features_CO1-2)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_chart_features_CO1-2)'
- en: A version range string for the chart.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图表的版本范围字符串。
- en: '[![3](Images/3.png)](#co_advanced_chart_features_CO1-3)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_chart_features_CO1-3)'
- en: The repository to retrieve the chart from.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 从仓库中检索图表的位置。
- en: Helm charts use semantic versions as their versioning scheme. The `version`
    field used for dependencies accepts a version range, and there are some shorthand
    syntaxes for those ranges. For example, `^1.2.3` is shorthand for `>= 1.2.3, <
    2.0.0`. Helm supports ranges including `=`, `!=`, `<`, `⇐`, `>`, `>=`, `^`, `~`,
    and `-`. Different ranges can be combined together using a space or comma to support
    logical *and* combinations and `|` to support logical *or* combinations. Helm
    also supports using a wildcard character of either `X` or `*`. If you omit a section
    of a version, such as omitting the patch portion, Helm will assume the missing
    part is a wildcard.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Helm图表使用语义版本作为它们的版本方案。用于依赖项的`version`字段接受版本范围，有一些用于这些范围的简写语法。例如，`^1.2.3`是`>=
    1.2.3, < 2.0.0`的简写。Helm支持包括`=`, `!=`, `<`, `⇐`, `>`, `>=`, `^`, `~`和`-`在内的范围。不同的范围可以使用空格或逗号组合在一起，以支持逻辑*and*组合，`|`以支持逻辑*or*组合。Helm还支持使用`X`或`*`作为通配符字符。如果省略版本的一部分，例如省略补丁部分，Helm将假定缺失部分是通配符。
- en: Ranges are the preferred manner to specify the desired version. In a moment
    you’ll learn how to lock to a specific dependency version from the specified range.
    By specifying a range, it is possible to use Helm commands to automatically update
    to the latest release within that range. This is useful if you want to pull in
    bug fixes or security updates to dependencies.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 范围是指定所需版本的首选方法。马上您将学习如何锁定到指定范围内的特定依赖项版本。通过指定范围，可以使用Helm命令自动更新到该范围内的最新版本。如果您想要引入修复bug或安全更新依赖项，则这非常有用。
- en: 'The `repository` field is where you specify the chart repository location to
    pull the dependency from. You can specify this in one of the following two ways:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`repository`字段是您指定的图表存储库位置，用于从中提取依赖项。您可以通过以下两种方式之一指定此字段：'
- en: A URL to the Helm repository.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm存储库的URL。
- en: To the name of a repository you have set up using the `helm repo add` command.
    This name needs to be preceded by an @ and wrapped in quotes (e.g., `"@myrepo"`).
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要使用`helm repo add`命令设置的存储库名称。这个名称需要在@之前加上引号（例如，`"@myrepo"`）。
- en: A full URL is typically used to specify the location. This will ensure the same
    dependency is retrieved in every environment the chart is used in.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用完整URL来指定位置。这将确保在使用图表的每个环境中检索相同的依赖项。
- en: Once you have the dependencies with their requested version ranges specified,
    you need to use Helm to lock those dependencies to specific versions and retrieve
    the dependencies. If you are going to package up your chart as a chart archive
    as covered in [Chapter 4](ch04.xhtml#building_a_chart), you need to lock and fetch
    dependencies before packaging.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您指定了具有所需版本范围的依赖项，您需要使用Helm将这些依赖项锁定到特定版本并检索它们。如果您打算将您的图表打包成图表存档，如[第四章](ch04.xhtml#building_a_chart)中所述，您需要在打包之前锁定并获取依赖项。
- en: 'To resolve the latest version of the dependency within the specified range
    and to retrieve it, you can use the following command:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 解析指定范围内依赖项的最新版本并检索它，您可以使用以下命令：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'After running the command you will see the following output:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 运行该命令后，您将看到以下输出：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running this command caused a few steps to happen.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令会导致执行几个步骤。
- en: First, Helm resolved the latest version of the *booster* chart. It used the
    metadata in the repository to know which versions of the chart were available.
    From the metadata and the specified version range, Helm found the best match.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Helm解析了*booster*图表的最新版本。它使用存储库中的元数据来了解可用的图表版本。从元数据和指定的版本范围中，Helm找到了最佳匹配。
- en: The resolved information is written to the *Chart.lock* file. Instead of a version
    range, the *Chart.lock* file contains the specific version of the dependencies
    to be used. This is important for reproducibility. The *Chart.lock* file is managed
    by Helm. Changes from users will be overwritten the next time `helm dep up` (the
    shorthand syntax) is run. This is similar to lock files for dependency managers
    on other platforms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 将解析后的信息写入*Chart.lock*文件。*Chart.lock*文件中不再是版本范围，而是包含要使用的依赖项的具体版本。这对于可重复性非常重要。*Chart.lock*文件由Helm管理。用户的更改将在下次运行`helm
    dep up`（简写语法）时被覆盖。这类似于其他平台上依赖管理器的锁文件。
- en: Once Helm knows the specific version to use, it downloads the dependent chart
    and puts it into the *charts* subdirectory. It is important for the dependent
    charts to be in the *charts* directory because this is where Helm will get their
    contents from to render the templates. Charts can be in the *charts* directory
    in either their archive or directory form. When Helm downloads them from a repository,
    it stores them in their archive form.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Helm 知道要使用的特定版本，它将下载依赖的图表并将其放入 *charts* 子目录中。依赖的图表放置在 *charts* 目录中非常重要，因为这是
    Helm 获取它们内容以渲染模板的地方。图表可以以其存档或目录形式存在于 *charts* 目录中。当 Helm 从存储库下载它们时，它们以存档形式存储。
- en: If you have a *Chart.lock* file but no contents in the *charts* directory, you
    can rebuild the *charts* directory by running the command `helm dependency build`.
    This will use the lock file to retrieve the dependencies at their already determined
    versions.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有一个 *Chart.lock* 文件但 *charts* 目录中没有内容，则可以通过运行命令 `helm dependency build` 重新构建
    *charts* 目录。这将使用锁定文件以其已确定版本检索依赖项。
- en: Once you have dependencies, Helm will render their resources when you run commands
    like `helm install` or `helm upgrade`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了依赖项，当您运行诸如 `helm install` 或 `helm upgrade` 的命令时，Helm 将渲染它们的资源。
- en: When you specify a dependency, you may also want to pass configuration from
    the parent or main chart to the dependent chart. If we look back at the WordPress
    example, this could be used to set the name of the database to use. Helm provides
    a method to do this within the parent chart’s values.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当您指定依赖项时，您可能还希望将配置从父或主图表传递到依赖图表。如果我们回顾 WordPress 的示例，这可以用于设置要使用的数据库名称。Helm 提供了一种方法，在父图表的值中执行此操作。
- en: In the main chart’s *values.yaml* file, you can create a new section with the
    name of the dependent chart. In this section you can set the values you want passed
    in. You only need to set the ones you want changed because the dependent charts
    included in the *values.yaml* file will serve as the default values.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在主图表的 *values.yaml* 文件中，您可以创建一个以依赖图表名称命名的新部分。在此部分中，您可以设置要传递的值。您只需设置您想要更改的部分，因为包含在
    *values.yaml* 文件中的依赖图表将作为默认值。
- en: 'In the *values.yaml* file for the *rocket* chart there is a section that reads:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *rocket* 图表的 *values.yaml* 文件中，有一个部分如下所示：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Helm knows this section is for the *booster* chart. In this case it sets the
    image tag to a specific value. Any of the values in the dependent chart can be
    set this way. When commands like `helm install` are run, you can use the flags
    to set values (e.g., `--set`) of the dependencies as well as those of the main
    chart.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 知道此部分是用于 *booster* 图表。在这种情况下，它将图像标签设置为特定值。可以以这种方式设置依赖图表中的任何值。当运行诸如 `helm
    install` 的命令时，您可以使用标志设置依赖项的值（例如 `--set`）以及主图表的值。
- en: If you have two dependencies on the same chart you can optionally use the `alias`
    property in the *Chart.yaml* file. This property goes on each dependency you want
    to use an alternative name for next to the `name`, `version`, and other properties.
    With `alias` you can give each dependency a unique name that you can reference
    elsewhere, such as in the *values.yaml* file.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在同一个图表上有两个依赖项，可以选择在 *Chart.yaml* 文件中使用 `alias` 属性。此属性放置在您想要使用替代名称的每个依赖项旁边，例如
    `name`、`version` 和其他属性。通过 `alias`，您可以为每个依赖项提供一个唯一的名称，在其他地方引用它们，例如 *values.yaml*
    文件中。
- en: Conditional Flags for Enabling Dependencies
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 条件标志以启用依赖项
- en: Helm provides the ability for you to enable or disable dependencies through
    configuration. To illustrate this idea, consider the case where you want to provide
    a WordPress blogging solution but give the option to the personnel installing
    WordPress to either use a database as a service or an included database. If the
    person installing the chart chooses to use a database as a service, they would
    provide a URL to that service and not need to have a database installed. This
    can be accomplished through configuration in two different ways.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了通过配置启用或禁用依赖项的功能。为了说明这个想法，考虑这样一个情况：您希望提供一个 WordPress 博客解决方案，但是给安装 WordPress
    的人员选择是否使用作为服务的数据库或包含的数据库的选项。如果安装图表的人选择使用数据库作为服务，则他们将提供该服务的 URL，并且不需要安装数据库。可以通过两种不同的方式在配置中实现这一点。
- en: 'When you want to control if a single feature is enabled or disabled through
    a dependency, you can use the `condition` property on a dependency. To illustrate
    this we will look at the `dependencies` section in the *Chart.yaml* file for the
    conditional chart:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当您希望通过依赖项控制单个功能的启用或禁用时，可以在依赖项上使用`condition`属性。为了说明这一点，我们将查看*Chart.yaml*文件中条件图表的`dependencies`部分：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The dependency has a `condition` key with a value that tells Helm where to
    look in the values to know if it should be enabled or disabled. In the *values.yaml*
    file the corresponding section is:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项具有一个`condition`键，其值告诉Helm在值中查找以确定是否应启用或禁用它。在*values.yaml*文件中，相应的部分如下所示：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The default value, in this case, is to disable the dependency. When someone
    installs the chart they can enable the dependency by passing in a value to enable
    it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，默认值是禁用依赖项。当某人安装图表时，可以通过传递一个值来启用该依赖项。
- en: 'When you have multiple features you want to enable or disable that involve
    dependencies, you can use the `tags` property. Like `condition`, this property
    sits alongside the `name` and `version` when describing a dependency. It contains
    a list of tags for a dependency. To illustrate this we can look at the dependencies
    of another chart named *tag*:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有多个涉及依赖关系的要启用或禁用的功能时，可以使用`tags`属性。像`condition`一样，这个属性在描述依赖关系时与`name`和`version`并列。它包含一个依赖项的标签列表。为了说明这一点，我们可以看一下另一个名为*tag*的图表的依赖项：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here you will see two dependencies with a `tags` section. The tags are a list
    of related tags. In the chart’s *values.yaml* file you use a `tags` property:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您将看到两个带有`tags`部分的依赖项。标签是相关标签的列表。在图表的*values.yaml*文件中，您使用`tags`属性：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`tags` is a property with a special meaning. The values here tell Helm to disable
    dependencies with the tag *faster* by default. They can be enabled when the chart’s
    user passes a true value into the chart as it’s being installed or upgraded.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`tags`是具有特殊含义的属性。这里的值告诉Helm默认情况下禁用具有标签*faster*的依赖项。当图表的用户在安装或升级时传递一个true值时，它们可以被启用。'
- en: Importing Values from Child to Parent Charts
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从子图表导入到父图表的值
- en: There are times where you may want to import or pull values from a child to
    a parent chart. Helm provides two methods to do this. One is for the case where
    a child chart explicitly exported a value to be imported by a parent, and the
    other is for the case in which the child chart did not export a value.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 有时您可能希望将子图表的值导入或拉到父图表中。Helm提供了两种方法来做到这一点。一种是在子图表明确将一个值导出以供父图表导入的情况下，另一种是在子图表未导出值的情况下。
- en: The exports property
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 导出属性
- en: The `exports` property is a special top-level property in a *values.yaml* file.
    When a child chart has declared an `export` property, its contents can be imported
    directly into a parent chart.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '`exports`属性是*values.yaml*文件中的一个特殊顶层属性。当子图表声明了一个`export`属性时，其内容可以直接导入到父图表中。'
- en: 'For example, consider the following from a child chart’s *values.yaml* file:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑来自子图表*values.yaml*文件的以下内容：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When the parent chart declares the child as a dependency, it can import from
    the exports like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当父图表声明子图表为依赖项时，可以从导出中导入值，如下所示：
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Within the parent’s calculated values the types are now accessible at the top
    level. In YAML that would be equivalent to:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在父计算的值中，现在可以在顶层访问这些类型。在YAML中，这相当于：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The child-parent format
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子父格式
- en: When a parent chart wants to import a value from a child but the child chart
    hasn’t exported the value, there is a way to tell Helm to pull the child value
    into the parent chart.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当父图表想从子图表导入一个值，但子图表没有导出该值时，有一种方法告诉Helm将子值拉入到父图表中。
- en: 'To illustrate this, consider a child chart with the following values specified
    in its *values.yaml* file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，请考虑一个子图表，在其*values.yaml*文件中指定了以下值：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These values are not exported, but the parent chart can import them anyway.
    When the dependency is declared in the parent, it can import the values using
    `child` and `parent` files, like the following example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值没有被导出，但父图表仍然可以导入它们。当在父级中声明依赖项时，可以使用`child`和`parent`文件导入这些值，如以下示例：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In both methods of importing it’s the `import-values` property that’s used on
    the dependency. Helm knows how to differentiate between the different formats,
    and you can mix the two.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在导入的两种方法中，使用的是`import-values`属性。Helm知道如何区分不同的格式，您可以混合使用这两种格式。
- en: 'In the child chart the top-level property of `types` will not be available
    in the parent chart under the top-level property of `characters` in its calculated
    values. That would be represented in YAML as:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在子图表中，当 `types` 的顶级属性在其计算的值中不可用于父图表中的 `characters` 的顶级属性时，可以表示为 YAML：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This format does allow for accessing nested values in addition to top-level
    properties using a period as a separator. For example, if the child chart had
    the following format, the `child` property on `import-values` could read `data.types`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 此格式允许访问嵌套值，除了使用点作为分隔符的顶级属性。例如，如果子图表具有以下格式，则 `import-values` 上的 `child` 属性可以读取
    `data.types`：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Library Charts
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库图表
- en: You may run into the situation where you are creating multiple similar charts—charts
    that share a lot of the same templates. For these situations, there are library
    charts.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会遇到创建多个相似图表的情况——这些图表共享许多相同的模板。对于这些情况，有库图表。
- en: Library charts are conceptually similar to software libraries. They provide
    reusable functionality that can be imported and used by other charts but cannot
    be installed themselves.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 库图表在概念上类似于软件库。它们提供可重用的功能，可以被其他图表导入和使用，但本身不能被安装。
- en: 'If you use `helm create` to create a new library chart, the first step is to
    remove the contents of the *templates* directory and the *values.yaml* file because
    neither of these will be used. Then, you need to tell Helm that this is a library
    chart. In the *Chart.yaml* file set the `type` to `library`. To illustrate this,
    here is the *Chart.yaml* file from a chart named *mylib*:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用 `helm create` 创建一个新的库图表，第一步是删除 *templates* 目录和 *values.yaml* 文件的内容，因为这两者都不会被使用。然后，您需要告诉
    Helm 这是一个库图表。在 *Chart.yaml* 文件中将 `type` 设置为 `library`。为了说明这一点，这里是名为 *mylib* 的图表的
    *Chart.yaml* 文件：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The default value for `type`, when not set, is application. You only need to
    set it when your chart is a library.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当未设置时，`type` 的默认值为应用程序。仅当您的图表是库时才需要设置它。
- en: Files in the *templates* directory that start with an underscore (i.e., `` `_`
    ``) are not expected to render manifests to send to Kubernetes. The convention
    is that helper templates and snippets are in _**.tpl* and _**.yaml* files.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *templates* 目录中以下划线（即 `` `_` ``）开头的文件不应该渲染为发送到 Kubernetes 的清单。约定是帮助模板和片段在
    _**.tpl* 和 _**.yaml* 文件中。
- en: 'To illustrate how reusable templates work, the following is the template to
    create a `ConfigMap` in the *mylib* chart file named *_configmap.yaml*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明可重用模板的工作原理，以下是在 *mylib* 图表文件中创建 `ConfigMap` 的模板，命名为 *_configmap.yaml*：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](Images/1.png)](#co_advanced_chart_features_CO2-1)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_chart_features_CO2-1)'
- en: The `fullname` function is the same as the one generated by `helm create`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`fullname` 函数与 `helm create` 生成的函数相同。'
- en: '[![2](Images/2.png)](#co_advanced_chart_features_CO2-2)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_chart_features_CO2-2)'
- en: The `labels` function generates the common labels Helm recommends to use in
    charts.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`labels` 函数生成 Helm 推荐在图表中使用的常见标签。'
- en: '[![3](Images/3.png)](#co_advanced_chart_features_CO2-3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_chart_features_CO2-3)'
- en: A special template is defined that knows how to merge templates together.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个特殊的模板，知道如何合并模板在一起。
- en: 'Most of this definition looks similar to other templates you would put into
    the *templates* directory. `define` is a function used to define a template that
    is used elsewhere. There are two templates defined in this file. *mylib.configmap.tpl*
    contains a template for a resource. This will look similar to other templates.
    It provides a blueprint that is meant to be overridden by the caller in a chart
    that includes this library. *mylib.configmap* is a special template. This is the
    template another chart will use. It takes *mylib.configmap.tpl* along with another
    template, yet to be defined, containing overrides, and merges them into one output.
    *mylib.configmap* uses a utility function that handles the merging and is handy
    to reuse. That function is:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分此定义看起来类似于你会放入 *templates* 目录中的其他模板。 `define` 是一个函数，用于定义在其他地方使用的模板。此文件中定义了两个模板。
    *mylib.configmap.tpl* 包含一个资源的模板。这将看起来类似于其他模板。它提供了一个蓝图，旨在被包含此库的图表中的调用者覆盖。 *mylib.configmap*
    是一个特殊的模板。这是另一个图表将使用的模板。它将 *mylib.configmap.tpl* 与另一个尚未定义的模板（包含覆盖）合并为一个输出。 *mylib.configmap*
    使用一个实用函数来处理合并，并方便重用。该函数是：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function takes a context (think about the `.` data covered in [Chapter 5](ch05.xhtml#developing_templates)),
    a template containing overrides, and the base template function to be overridden.
    The function will become more clear when you see how it is used.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受一个上下文（考虑在[第5章](ch05.xhtml#developing_templates)中涵盖的`.`数据），一个包含覆盖项的模板以及要覆盖的基础模板函数。当您看到它的使用方式时，这个函数将变得更加清晰。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of library charts was developed prior to their official inclusion
    in Helm. The `merge` function was created by Adnan Abdulhussein as part of his
    work developing the idea through a chart named *Common*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方将库图表包含在Helm中之前，已经开发了库图表的概念。`merge`函数由Adnan Abdulhussein开发，作为其通过一个名为*Common*的图表开发这一概念的一部分。
- en: 'To illustrate using this library function, the following template is from another
    chart named *mychart*. Prior to using the resources it defines, it needs to be
    added as a dependency, just like any other. A template is included in *mychart*
    to create a `ConfigMap`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明使用此库函数，以下模板来自另一个名为*mychart*的图表。在使用其定义的资源之前，需要将其作为依赖项添加，就像任何其他依赖项一样。*mychart*中包含一个模板用于创建`ConfigMap`：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_advanced_chart_features_CO3-1)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_chart_features_CO3-1)'
- en: Including and using the function from the library chart for the `ConfigMap`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 包括并使用库图表的功能来生成`ConfigMap`。
- en: '[![2](Images/2.png)](#co_advanced_chart_features_CO3-2)'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_chart_features_CO3-2)'
- en: A new template is defined with just the parts to override the template provided
    by the library.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了一个新模板，其中仅包含要覆盖库提供的模板的部分。
- en: '[![3](Images/3.png)](#co_advanced_chart_features_CO3-3)'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_chart_features_CO3-3)'
- en: The `data` section is provided for use in the `ConfigMap`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 提供`data`部分供`ConfigMap`使用。
- en: This template may appear to be confusing at first because there is a lot going
    on.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板一开始可能看起来令人困惑，因为其中涉及的内容很多。
- en: The first line includes the `ConfigMap` template from the library chart. A new
    list is passed to it with two items. The first is the current data object, and
    the second is the name of another template containing elements to override those
    provided by the library chart.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行包括来自库图表的`ConfigMap`模板。将一个新列表传递给它，其中包含两个条目。第一个是当前的数据对象，第二个是另一个模板的名称，该模板包含要覆盖库图表提供的元素。
- en: The rest of the file is the template containing overrides. In the template provided
    by the library chart no content was provided for the `data` section. It is empty.
    The function `mychart.configmap` provides a `data` section.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 文件的其余部分是包含覆盖项的模板。在库图表提供的模板中，`data`部分未提供任何内容。它是空的。函数`mychart.configmap`提供了一个`data`部分。
- en: 'The Helm rendered output from this template is:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此模板的Helm渲染输出为：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This output is the merged output from the library and the chart consuming the
    library. The same concept can be extended to other resources including those that
    are longer and more complex.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出是来自库和使用库的图表的合并输出。这个概念可以扩展到其他资源，包括那些更长和更复杂的资源。
- en: Schematizing Values Files
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对值文件进行模式化处理
- en: The values defined by a *values.yaml* file are schemaless. There is no set structure
    that all *values.yaml* files need to follow. Different charts have different structures.
    This enables you to structure the values to the application or workload you’re
    deploying with the chart.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由*values.yaml*文件定义的值是无模式的。并不存在所有*values.yaml*文件需要遵循的固定结构。不同的图表具有不同的结构。这使您可以将值结构化到您使用图表部署的应用程序或工作负载中。
- en: Schemas provide numerous useful benefits including the ability to validate content,
    and you can do things such as generate user interfaces from them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 模式提供了许多有用的好处，包括验证内容的能力，您可以执行各种操作，如生成用户界面。
- en: Helm provides the optional ability for each chart to provide its own schema
    for its values using [JSON Schema](https://json-schema.org). JSON Schema provides
    a vocabulary to describe JSON files. YAML is a superset of JSON, and you can transform
    content between the two file formats. This makes it possible to use a JSON Schema
    to validate the content of a YAML file.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Helm提供了每个图表可选的能力，使用[JSON Schema](https://json-schema.org)为其值提供自己的模式。JSON Schema提供了描述JSON文件的词汇。YAML是JSON的超集，您可以在这两种文件格式之间转换内容。这使得可以使用JSON模式验证YAML文件的内容。
- en: When you run the commands `helm install`, `helm upgrade`, `helm lint`, and `helm
    template`, Helm will validate the values against what it finds in the *values.schema.json*
    file. The values Helm validates are the computed values. They include the values
    provided by the chart as well as the values passed in by the person installing
    the chart. The *values.schema.json* file lives next to the *values.yaml* file
    in the root of a chart. The file can describe all or part of the values.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 `helm install`、`helm upgrade`、`helm lint` 和 `helm template` 命令时，Helm 将根据
    *values.schema.json* 文件验证值。Helm 验证的值是计算出的值。它们包括图表提供的值以及安装图表的人提供的值。*values.schema.json*
    文件与图表根目录下的 *values.yaml* 文件相邻。该文件可以描述所有或部分值。
- en: 'Consider the following section from a *values.yaml* file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑来自 *values.yaml* 文件的以下部分：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'A JSON Schema to check this would be:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用以下 JSON Schema 进行检查：
- en: '[PRE21]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[![1](Images/1.png)](#co_advanced_chart_features_CO4-1)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_advanced_chart_features_CO4-1)'
- en: '`image` is an object. If `image` is passed to Helm as something other than
    an object, an error will be thrown.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`image` 是一个对象。如果将 `image` 作为非对象的内容传递给 Helm，将会抛出错误。'
- en: '[![2](Images/2.png)](#co_advanced_chart_features_CO4-2)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_advanced_chart_features_CO4-2)'
- en: '`pullPolicy` is a string. When other types, such as an integer, are passed
    in, an error will be thrown. This can catch subtle problems.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`pullPolicy` 是一个字符串。当传递其他类型，比如整数时，将抛出错误。这可以捕捉到一些微妙的问题。'
- en: '[![3](Images/3.png)](#co_advanced_chart_features_CO4-3)'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_advanced_chart_features_CO4-3)'
- en: The `pullPolicy` must be one of the listed values. When another value, even
    a misspelling, is passed in to Helm, an error will be thrown.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`pullPolicy` 必须是列出的值之一。当传入其他值，甚至拼写错误时，将抛出错误。'
- en: 'To illustrate this, we can use the *booster* chart. If you run the command
    from the root of the chart, you’ll see an error:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一点，我们可以使用 *booster* 图表。如果您在图表根目录下运行该命令，您将看到一个错误：
- en: '[PRE22]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The following error tells you where the values don’t match the schema:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下错误告诉您值与模式不匹配的位置：
- en: '[PRE23]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: JSON Schemas provide several ways to describe properties. The most flexible
    method (a catch-all) is the use of regular expressions for strings. For example,
    instead of an `enum` a `pattern` of `^(Always|IfNotPresent)$` could have been
    used. The pattern would not have been as descriptive. The error would have noted
    the value didn’t fit the pattern. Patterns are great to use when there is no other
    method to describe a property’s value.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: JSON Schema 提供了几种描述属性的方法。最灵活的方法（一个通用的方法）是为字符串使用正则表达式。例如，可以使用 `^(Always|IfNotPresent)$`
    的 `pattern` 来替代 `enum`。这种模式不会像描述性那么强。错误会指出该值不符合模式。在没有其他方法描述属性值时，可以使用模式。
- en: Schemas are a useful addition to charts that can catch and correct subtle issues
    someone may have when installing a chart.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Schema 是图表的有用补充，可以捕捉并修正在安装图表时可能出现的一些微妙问题。
- en: Hooks
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hooks
- en: Helm provides a means to hook into events in the release process and take action.
    This is useful if you want to bundle actions as part of a release—for example,
    building in the ability to back up a database as part of the upgrade process while
    ensuring that the backup occurs prior to upgrading the Kubernetes resources.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了一种方法来钩入发布过程中的事件并采取行动。如果您想要将动作捆绑为发布的一部分，例如，在升级过程中构建数据库备份的能力，并确保备份在升级
    Kubernetes 资源之前发生，这将非常有用。
- en: Hooks are like regular templates and the functionality they encapsulate is provided
    through containers running in Kubernetes clusters alongside the other resources
    for your application. What distinguishes hooks from other resources is when a
    special annotation is set. When Helm sees the `helm.sh/hook` annotation, it uses
    the resource as a hook instead of a resource to be installed as part of the application
    installed by the chart. [Table 6-1](#table_6-1) contains a list of hooks and when
    they are executed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Hooks 类似于常规模板，它们封装的功能通过运行在 Kubernetes 集群中的容器提供给应用程序的其他资源。钩子与其他资源的区别在于设置了特殊的注解时。当
    Helm 看到 `helm.sh/hook` 注解时，它将资源用作钩子，而不是作为图表安装的一部分要安装的资源。[表 6-1](#table_6-1) 包含一些钩子及其执行时机的列表。
- en: Table 6-1\. Helm hooks
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-1\. Helm 钩子
- en: '| Annotation value | Description |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 注解值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| pre-install | Execution happens after resources are rendered but prior to
    those resources being uploaded to Kubernetes. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| pre-install | 在资源被渲染但上传到 Kubernetes 之前执行。|'
- en: '| post-install | Execution happens after resources have been uploaded to Kubernetes.
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| post-install | 执行发生在将资源上传到 Kubernetes 后。 |'
- en: '| pre-delete | Execution happens on a deletion request prior to any resources
    being deleted from Kubernetes. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| pre-delete | 执行发生在删除请求之前，任何资源从 Kubernetes 中被删除。 |'
- en: '| post-delete | Execution happens after all resources have been deleted from
    Kubernetes. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| post-delete | 执行发生在从 Kubernetes 中删除所有资源之后。 |'
- en: '| pre-upgrade | Execution happens after resources are rendered but prior to
    resources being updated in Kubernetes. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| pre-upgrade | 执行发生在渲染资源之后但在更新 Kubernetes 资源之前。 |'
- en: '| post-upgrade | Execution happens after resources have been upgraded in Kubernetes.
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| post-upgrade | 执行发生在 Kubernetes 中的资源升级后。 |'
- en: '| pre-rollback | Execution happens after resources have been rendered but prior
    to any resources in Kubernetes being rolled back. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| pre-rollback | 执行发生在渲染资源之后但在 Kubernetes 中任何资源被回滚之前。 |'
- en: '| post-rollback | Execution happens after resources have been rolled back in
    Kubernetes. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| post-rollback | 执行发生在 Kubernetes 中的资源被回滚后。 |'
- en: '| test | Execution occurs when the `helm test` command is run. Tests are covered
    in the next section. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| test | 执行发生在运行 `helm test` 命令时。测试将在下一节中讨论。 |'
- en: 'A single resource can implement more than one hook by listing them as a comma-separated
    list. For example:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 单个资源可以通过将它们列为逗号分隔列表来实现多个钩子。例如：
- en: '[PRE24]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Hooks can be weighted and specify a deletion policy for the resources after
    they have run. The weight enables more than one hook for the same event to be
    specified while providing an order in which they will run. This gives you the
    ability to ensure a deterministic order. Because Kubernetes resources are used
    for the execution of hooks, the resources are stored in Kubernetes even after
    execution has completed. The deletion policy provides you with some additional
    control on when to delete these resources from Kubernetes.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 钩子可以被加权，并在运行后指定资源的删除策略。权重允许为同一事件指定多个钩子，并指定它们运行的顺序。这使您能够确保确定性顺序。因为 Kubernetes
    资源用于执行钩子，所以即使执行完成后，这些资源也会存储在 Kubernetes 中。删除策略允许您在何时从 Kubernetes 中删除这些资源时具有一些额外控制。
- en: 'The following code provides example annotations specifying all three values:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码提供了指定所有三个值的示例注释：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The weight, specified by the `helm.sh/hook-weight` annotation key, is a number
    represented as a string. It should always be a string. The weight can be a positive
    or negative number and has a default value of `0`. Prior to executing hooks, Helm
    sorts them in ascending order.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `helm.sh/hook-weight` 注释键指定的权重是一个表示为字符串的数字。它应始终为字符串。权重可以是正数或负数，并且默认值为 `0`。在执行钩子之前，Helm
    将它们按升序排序。
- en: The deletion policy, set using the annotation key `helm.sh/hook-delete-policy`,
    is a comma-separated list of policy options. The three possible deletion policies
    are found in [Table 6-2](#table_6-2).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用注释键 `helm.sh/hook-delete-policy` 设置的删除策略是一个逗号分隔的策略选项列表。三种可能的删除策略可以在 [表 6-2](#table_6-2)
    中找到。
- en: Table 6-2\. Helm hook deletion policies
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 表 6-2\. Helm 钩子删除策略
- en: '| Policy value | Description |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 策略值 | 描述 |'
- en: '| --- | --- |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| before-hook-creation | The previous resource is deleted before a new instance
    of this hook is launched. This is the default. |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| before-hook-creation | 在启动新钩子实例之前删除先前的资源。这是默认行为。 |'
- en: '| hook-succeeded | Delete the Kubernetes resource after the hook is successfully
    run. |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| hook-succeeded | 在成功运行钩子之后删除 Kubernetes 资源。 |'
- en: '| hook-failed | Delete the Kubernetes resource if the hook failed while executing.
    |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| hook-failed | 如果在执行钩子时失败，则删除 Kubernetes 资源。 |'
- en: By default, Helm keeps the Kubernetes resources used for hooks until the hook
    is run again. This provides the ability to inspect the logs or look at other information
    about a hook after it is run. A common policy to set is the one used in the previous
    example. This will keep hook resources around unless they complete successfully.
    When hooks fail, the resources and their logs are still available for inspection,
    but otherwise they are deleted.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Helm 会保留用于钩子的 Kubernetes 资源，直到再次运行钩子。这提供了在运行后检查日志或查看钩子其他信息的能力。设置常见策略的一个例子是前面示例中使用的策略。这将保留钩子资源，除非它们成功完成。当钩子失败时，资源及其日志仍然可供检查，否则它们将被删除。
- en: 'The following `Pod` is an example of a hook running post-install:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的 `Pod` 是一个运行 post-install 钩子的示例：
- en: '[PRE26]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you are running a Helm command, such as `helm install`, and want to skip
    running hooks, the `--no-hooks` flag can be used. This flag is available on commands
    that have hooks and will cause Helm to skip executing them. Hooks are an opt-out
    feature.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在运行 `helm install` 等 Helm 命令，并希望跳过运行钩子，可以使用 `--no-hooks` 标志。此标志适用于具有钩子的命令，并将导致
    Helm 跳过执行它们。钩子是一种选择退出的功能。
- en: Adding Tests to Charts
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向图表添加测试
- en: Testing is an integral part of software development, and Helm provides the ability
    to test charts through the use of the *test* hook and Kubernetes resources. That
    means tests run in a Kubernetes cluster right alongside the workloads with access
    to the components installed by the chart. In addition to the chart testing built
    into Helm, the Helm project provides an additional testing tool named Chart Testing.
    Since Chart Testing builds upon the features in the Helm client, we will first
    look at the functionality built into the Helm client.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是软件开发的一个重要部分，Helm 通过 *test* 钩子和 Kubernetes 资源提供了测试图表的能力。这意味着测试在 Kubernetes
    集群中与工作负载并行运行，并且可以访问图表安装的组件。除了 Helm 内置的图表测试功能外，Helm 项目还提供了一个名为 Chart Testing 的额外测试工具。由于
    Chart Testing 建立在 Helm 客户端的功能之上，我们首先看一下 Helm 客户端内置的功能。
- en: Helm Test
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm 测试
- en: Helm has a `helm test` command that executes test hooks on a running instance
    of a chart. The resources implementing those hooks can check database access,
    that database schemas are properly in place, for working connections between workloads,
    and other operational details.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 有一个 `helm test` 命令，用于在图表的运行实例上执行测试钩子。实现这些钩子的资源可以检查数据库访问、数据库架构是否正确放置、工作负载之间的工作连接以及其他操作细节。
- en: If a test fails, Helm will exit with a nonzero exit code and provide you with
    the name of the Kubernetes resource that failed. The nonzero exit code is useful
    when paired with some automation testing systems that detect failures this way.
    When you have the name of the Kubernetes resource, you can look at the logs to
    see what failed.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如果测试失败，Helm 将以非零退出代码退出，并向您提供失败的 Kubernetes 资源的名称。非零退出代码在与某些自动化测试系统配对时非常有用，这些系统通过这种方式检测失败。当您有
    Kubernetes 资源的名称时，可以查看日志以查看失败的原因。
- en: Tests typically live in the *tests* subdirectory of the *templates* directory.
    Putting the tests in this directory provides a useful separation. This is a convention
    and not required for tests to run.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试通常位于 *templates* 目录的 *tests* 子目录中。将测试放置在此目录中提供了有用的分离。这是一种约定，但不是测试运行的必需条件。
- en: 'To illustrate a test, we will look at the [*booster* chart](https://oreil.ly/COJ7w).
    In the *templates/tests* directory, there is a single test in the file *test-connection.yaml*
    that contains the following test hook:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明一个测试，我们将看一下[*booster* 图表](https://oreil.ly/COJ7w)。在 *templates/tests* 目录中，有一个名为
    *test-connection.yaml* 的单个测试，其中包含以下测试钩子：
- en: '[PRE27]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This test is the one created by default for Nginx when `helm create` is run.
    It happens to work to test connectivity to the booster application, as well. This
    simple test illustrates the structure of a test.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试是在运行 `helm create` 时为 Nginx 创建的默认测试。它也恰好适用于测试与 booster 应用程序的连接。这个简单的测试说明了测试的结构。
- en: Note
  id: totrans-167
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If you look at tests in some existing charts you might find the hook they use
    is `test-success` instead of `test`. In Helm version 2 there was a hook named
    `test-success` for running tests. Helm version 3 provides backward compatibility
    and will run this hook name as a test.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看一些现有图表中的测试，可能会发现它们使用的钩子是 `test-success` 而不是 `test`。在 Helm 版本 2 中，有一个名为
    `test-success` 的钩子用于运行测试。Helm 版本 3 提供了向后兼容性，并将此钩子名称作为测试运行。
- en: 'There are two steps to run tests. The first step is to install the chart so
    that an instance of it is running. You can use the `helm install` command to do
    this. The following command installs the *booster* chart and assumes you are running
    it from the root directory of the chart:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试有两个步骤。第一步是安装图表，以便其实例正在运行。您可以使用 `helm install` 命令来执行此操作。以下命令安装 *booster*
    图表，并假设您从图表的根目录运行它：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Once the instance of the chart is running, you run the `helm test` command
    to execute the tests:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当图表的实例正在运行时，您可以运行 `helm test` 命令来执行测试：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Helm will output the status of the test as it executes and then information
    about the test and the release when complete. For the previous test it would return:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 在执行期间会输出测试的状态，完成后会提供关于测试和发布的信息。对于之前的测试，它将返回：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When charts have dependencies that have tests, those will be run, as well. For
    example, if the tests in the *rocket* chart used earlier in the chapter are run,
    the *booster* chart tests and the *rocket* chart tests will be run.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当图表有依赖项且这些依赖项有测试时，这些测试也将被运行。例如，如果在本章中使用的 *rocket* 图表的测试被运行，则将运行 *booster* 图表的测试和
    *rocket* 图表的测试。
- en: Tip
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: If you need to have configuration installed as part of a test, you can put the
    test hook on a Kubernetes `Secret` or ConfigMap to have it installed with other
    test resources.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要在测试的一部分安装配置，则可以将测试挂钩放在 Kubernetes 的 `Secret` 或 ConfigMap 上，以便与其他测试资源一起安装。
- en: Testing charts is a great way to ensure the contents of a chart are able to
    get the workload running in Kubernetes and catch changes that may break that.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 测试图表是确保图表内容能够在 Kubernetes 中运行工作负载并捕捉可能破坏该内容的变化的绝佳方式。
- en: Chart Testing Tool
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Chart Testing 工具
- en: 'The Helm project provides an additional testing tool, built on the foundation
    of `helm test`, that provides more advanced testing capabilities. Some of the
    additional features it includes are:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 项目提供了一个基于 `helm test` 建立的附加测试工具，提供了更高级的测试能力。它包括的一些附加功能有：
- en: The ability to test different—mutually exclusive—configuration options at install
    time for a chart.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够在图表安装时测试不同的、互斥的配置选项。
- en: '*Chart.yaml* schema validation that includes custom schema rules.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Chart.yaml* 模式验证包括自定义模式规则。'
- en: Additional YAML linting that includes configurable rules. For example, you can
    make sure indentation in the YAML files is consistent.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加了可配置规则的 YAML 检查工具。例如，您可以确保 YAML 文件中的缩进保持一致。
- en: When the source is stored in Git, the ability to check if the `version` property
    in a *Chart.yaml* file has been properly incremented.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当源代码存储在 Git 中时，可以检查 *Chart.yaml* 文件中的 `version` 属性是否已正确递增。
- en: The ability to work with collections of charts and only test those that have
    changed.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够处理图表集合，并仅测试已更改的图表。
- en: The Chart Testing tool was designed to use in continuous integration system
    workflows, and some of the features directly target this situation.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Chart Testing 工具设计用于在持续集成系统工作流中使用，并且其中一些功能直接针对此情况。
- en: The ability for Chart Testing to test a chart with different, mutually exclusive,
    configurations requires knowing those configurations. These are bundled in the
    *ci* directory of a chart.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Chart Testing 能够测试具有不同、互斥配置的图表，需要知道这些配置。这些配置捆绑在图表的 *ci* 目录中。
- en: In the *ci* directory you can create a values file for each situation to test.
    You need to use the glob naming pattern **-values.yaml* when you name each file.
    For example, you can use file names like *minimal-values.yaml* and *full-values.yaml*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *ci* 目录中，您可以为每种测试情况创建一个值文件。在命名每个文件时，您需要使用 glob 命名模式 **-values.yaml*。例如，您可以使用类似
    *minimal-values.yaml* 和 *full-values.yaml* 的文件名。
- en: Chart Testing will test each of these configurations separately. For example,
    when the chart is being linted, each case will be linted separately. The custom
    values will be passed to `helm lint` using the `--values` flag. The same idea
    and flag applies when the chart is being runtime tested. The values are passed
    to Helm using the `--values` flag beacuse this is how end users, who install the
    chart, provide their custom configuration.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Chart Testing 将分别测试每个配置。例如，在进行图表的语法检查时，将分别检查每个案例。使用 `--values` 标志将自定义值传递给 `helm
    lint`。当运行时测试图表时，相同的想法和标志适用，因为这是最终用户安装图表时提供其自定义配置的方式。
- en: If you want to test using various configurations but do not want to ship those
    configurations as part of the chart archive, you can put the *ci* directory in
    the *.helmignore* file. When Helm packages the chart, the *ci* directory will
    be ignored.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想使用各种配置进行测试，但不希望将这些配置作为图表存档的一部分发布，您可以将 *ci* 目录放入 *.helmignore* 文件中。当 Helm
    打包图表时，将忽略 *ci* 目录。
- en: Chart Testing can be installed and used in various ways. For example, you can
    use it as a binary application on a development system or in a container within
    a continuous integration system. Learn more about [using and setting it up for
    your situation on the project page](https://oreil.ly/sJXpR).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Chart Testing 可以以各种方式安装和使用。例如，您可以将其作为开发系统上的二进制应用程序使用，或者在持续集成系统中的容器中使用。了解更多关于
    [如何在您的情况下使用和设置它的信息，请查看项目页面](https://oreil.ly/sJXpR)。
- en: Security Considerations
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全考虑
- en: Some of the biggest and most trusted technology organizations have had their
    users be attacked through software updates. Software changes and the mechanisms
    used to update and even install software provide a channel of attack.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最大和最值得信赖的技术组织曾经通过软件更新受到用户的攻击。软件更改和用于更新甚至安装软件的机制提供了一个攻击通道。
- en: Helm provides an opt-in means to check the provenance and integrity of charts.
    *Provenance* provides a means to verify the origin, such as a company or person,
    of a chart while *integrity* provides a way to check that you received what you
    expected without alterations. This functionality enables you and those who use
    your charts to verify who they came from and that the contents have not changed.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 提供了一种选择加入的方式来检查图表的来源和完整性。*来源* 提供了验证图表来自公司或个人等的方式，而 *完整性* 则提供了检查您是否收到了未经更改的预期内容的方法。这种功能使您和使用您图表的人可以验证它们的来源，并且内容没有改变。
- en: 'To accomplish this Helm uses Pretty Good Privacy (PGP), hashes, and a provenance
    file that sits alongside the chart archive file. For example, if you have a chart
    archive named *mylib-1.0.0.tgz*, you can have a provenance file named *mylib-1.0.0.tgz.prov*.
    This file contains a PGP message with the contents of the *Chart.yaml* file along
    with the hash of the chart archive. Helm can generate these files for you. The
    following example is the provenance file for *mylib-1.0.0.tgz*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，Helm 使用了 Pretty Good Privacy (PGP)、哈希和一个坐落在图表归档文件旁边的来源文件。例如，如果您有一个名为
    *mylib-1.0.0.tgz* 的图表归档文件，则可以有一个名为 *mylib-1.0.0.tgz.prov* 的来源文件。该文件包含了一个带有 *Chart.yaml*
    文件内容以及图表归档的哈希的 PGP 消息。Helm 可以为您生成这些文件。以下示例是 *mylib-1.0.0.tgz* 的来源文件：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: A provenance file is a PGP signed message with a particular structure in the
    message. That hash in the message is used by Helm to validate integrity, and the
    PGP signature is used to validate who it came from.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 来源文件是一个具有特定结构的 PGP 签名消息。消息中的哈希由 Helm 用于验证完整性，PGP 签名用于验证来源。
- en: There are two steps to using provenance files. First, you need to generate them.
    In order to do that you need to have a PGP key pair.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 使用来源文件有两个步骤。首先，您需要生成它们。为此，您需要有一个 PGP 密钥对。
- en: 'When creating a package using the `helm package` command, you can tell Helm
    to sign the package:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 `helm package` 命令创建包时，可以告诉 Helm 对包进行签名：
- en: '[PRE32]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The additional flags will tell Helm to create the provenance file. The `--sign`
    flag opts-in to signing, the `--key` flag specifies the name of the private key
    to use, and the `--keyring` flag specifies the location of the keyring to use
    that contains the private key to use for signing. When Helm creates the archive
    of the chart, it will also create the *.prov* file alongside it.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 附加标志将告诉 Helm 创建来源文件。`--sign` 标志选择签名，`--key` 标志指定要使用的私钥名称，`--keyring` 标志指定要使用的包含用于签名的私钥的密钥环的位置。当
    Helm 创建图表的归档时，它还将创建与之并列的 *.prov* 文件。
- en: The provenance file should then be uploaded alongside the chart archive and
    made available for download from a chart repository.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 然后应上传来源文件，与图表归档一起提供下载，放置在图表存储库中。
- en: Verifying happens in reverse and is built into commands such as `helm install`,
    `helm upgrade`, and `helm pull` along with being available in the `helm verify`
    command.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 验证是反向进行的，并内置到命令中，如 `helm install`、`helm upgrade` 和 `helm pull`，以及 `helm verify`
    命令中。
- en: Helm can handle the situation where you have both the archive and provenance
    file locally available and when you have the chart in a remote repository.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 能够处理您本地同时拥有归档和来源文件以及图表位于远程存储库的情况。
- en: 'To illustrate the situation of having both files locally, we can use the `helm
    verify` command:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明同时拥有这两个文件的情况，我们可以使用 `helm verify` 命令：
- en: '[PRE33]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `verify` command will tell Helm to check the hash and signature. The `--keyring`
    flag tells Helm where a PGP keyring exists with the public key that matches the
    private key the chart was signed with. This can be either a keyring or a non-ASCII-Armored
    version of the public key. Helm will look for the *mychart-0.1.0.tgz.prov* file
    and use that to perform the check.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`verify` 命令将告诉 Helm 检查哈希和签名。`--keyring` 标志告诉 Helm 公钥环的位置，该环中包含与图表签名使用的私钥匹配的公钥。这可以是公钥环或非
    ASCII-Armored 版本的公钥。Helm 将查找 *mychart-0.1.0.tgz.prov* 文件，并使用它执行检查。'
- en: 'Running the `verify` command on the *mylib* chart would look like:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *mylib* 图表上运行 `verify` 命令如下所示：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'This would output:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If you have a chart in a Helm repository, Helm will download the provenance
    file when it downloads the chart. For example:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在Helm仓库中有一个图表，Helm在下载图表时会同时下载验证文件。例如：
- en: '[PRE36]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When Helm fetches the chart archive, it will also download the provenance file,
    verify the signature, and verify the hash.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当Helm获取图表存档时，还会下载验证文件、验证签名并验证哈希值。
- en: Tip
  id: totrans-215
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The public key should be shared through a different channel from the chart and
    provenance file.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥应通过不同的渠道与图表和验证文件共享。
- en: If there is a problem during the verification process, Helm will provide an
    error and exit with a nonzero exit code.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在验证过程中出现问题，Helm将提供错误消息并以非零退出代码退出。
- en: Verifying that a chart came from who you expected and that the content hasn’t
    changed is a useful step in securing your software supply chain.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 确保图表来自预期之处并且内容未更改，是确保软件供应链安全的有用步骤。
- en: Custom Resource Definitions
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义资源定义
- en: Kubernetes custom resource definitions (CRDs) provide a means to extend the
    Kubernetes API, and Helm provides methods to install them as part of the chart.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes自定义资源定义（CRD）提供了扩展Kubernetes API的方法，而Helm提供了将它们作为图表的一部分安装的方法。
- en: There are two Helm-based methods to managing the CRDs used by a chart. Choosing
    between the methods to use often depends on the requirements and environment configurations
    of those who need to install your charts.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种基于Helm的方法来管理图表使用的CRD。选择使用的方法通常取决于需要安装您的图表的人员的要求和环境配置。
- en: First, the *crds* directory is a special directory you can add to a chart to
    hold your CRDs. Helm will install CRDs prior to installing other resources. This
    ensures that CRDs are available for any custom resources or controllers that may
    leverage them in the chart.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，*crds*目录是您可以添加到图表中以保存您的CRD的特殊目录。Helm会在安装其他资源之前安装CRD。这确保了CRD在图表中的任何自定义资源或控制器使用之前可用。
- en: CRDs in the *crds* directory are different from other resources installed by
    Helm. These files are not templated. This is useful for the CRD management workflows
    we will cover in a moment. Helm will not upgrade or delete CRDs like it does other
    resources. Upgrading CRDs changes the API surface for all instances of the custom
    resources in the cluster, and deleting CRDs removes all of the custom resources
    for all users. When it comes to handling these cluster-wide changes you will need
    to use a companion tool, like `kubectl`, the command-line tool for Kubernetes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*crds*目录中的CRD与Helm安装的其他资源不同。这些文件没有模板化。这对我们稍后将要涵盖的CRD管理工作流程非常有用。Helm不会像处理其他资源那样升级或删除CRD。升级CRD会更改集群中所有自定义资源实例的API表面，而删除CRD会移除所有用户的所有自定义资源。在处理这些集群范围的更改时，您需要使用伴随工具，如Kubernetes的命令行工具`kubectl`。'
- en: Because CRDs change the Kubernetes API, whoever is installing your chart may
    not have permission to install, upgrade, or delete them. This is the case if you
    are bundling an application for distribution to other companies or the general
    public. Some cluster administrators restrict access to these functions as part
    of their access controls for security.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因为CRD改变了Kubernetes API，安装您的图表的人可能没有权限安装、升级或删除它们。如果将应用程序捆绑用于分发给其他公司或一般公众，则情况是如此。一些集群管理员通过安全访问控制限制对这些功能的访问。
- en: The CRDs in the *crds* directory can be extracted from a chart and used directly
    with tools like `kubectl`. This enables the CRDs to be passed to someone with
    permission to install them, if the person installing the chart doesn’t have permission.
    The extracted CRDs can also be used to upgrade the CRDs within a cluster using
    other tools.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '*crds*目录中的CRD可以从图表中提取，并可以直接与`kubectl`等工具一起使用。这样，如果安装图表的人没有权限，可以将提取的CRD传递给有权限安装它们的人。提取的CRD也可以使用其他工具在集群中升级CRD。'
- en: A second, Helm-based, way to manage CRDs while providing an ordering that installs
    CRDs before using them through custom resources is to use a second chart that
    holds the CRDs. This method provides more nuanced control through Helm.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种基于Helm的管理CRD的方法是使用第二个图表来安装CRD，以确保在使用自定义资源之前安装CRD。这种方法通过Helm提供了更加精细的控制。
- en: 'Using a second chart will let you:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二个图表可以让您：
- en: Use Helm templates and the normal *templates* directory for CRDs.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Helm模板和正常的*模板*目录来管理CRD。
- en: 'Helm will manage the life cycle of the CRDs. That includes uninstalling and
    upgrades. If you want to keep the CRD installed after the chart is uninstalled,
    you can set the annotation `"helm.sh/resource-policy": keep` to tell Helm to skip
    uninstalling the resource.'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 'Helm 将管理 CRD 的生命周期，包括卸载和升级。如果您希望在卸载图表后保留 CRD 安装状态，可以设置注解 `"helm.sh/resource-policy":
    keep`，告诉 Helm 跳过卸载资源的步骤。'
- en: If you have issues with an application and use the uninstall and reinstall method
    to try to fix issues, the CRDs in the separate chart will not be deleted.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在应用程序中遇到问题，并使用卸载和重新安装方法尝试修复问题，则独立图表中的 CRD 将不会被删除。
- en: This second chart can be installed with either a loose coupling, where the directions
    tell people to install it first, or a tight coupling, where it is set as a dependency.
    If the chart holding the CRDs is set as a dependency the use case should be that
    it is only installed once as it is setting cluster-wide resources.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过松耦合或紧耦合安装第二个图表。如果将持有 CRD 的图表设置为依赖项，则使用情况应该是仅安装一次，因为它正在设置集群范围的资源。
- en: When Helm is managing the CRDs, special care needs to be given for handling
    upgrade and delete cases. For example, if two versions of the CRD installing chart
    are installed, as you need to ensure an older version doesn’t overwrite a newer
    version and that a newer version doesn’t break the functionality for someone else
    in the cluster using the older version. This can happen if two people install
    different versions of the chart that installs CRDs. In multitenant clusters different
    users of the cluster may not know about each other, and it’s important to ensure
    that one user of the cluster does not break the workloads of another user of the
    cluster.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Helm 管理 CRD 时，需要特别注意处理升级和删除的情况。例如，如果安装了 CRD 的图表的两个版本，则需要确保旧版本不会覆盖新版本，并且新版本不会破坏集群中其他使用旧版本的用户的功能。如果两个不同版本的安装
    CRD 的图表由两个不同的人安装，则可能会发生这种情况。在多租户集群中，集群的不同用户可能不知道彼此的存在，因此确保一个集群用户不会破坏另一个集群用户的工作负载非常重要。
- en: When installing and working with CRDs, the Helm developers recommend taking
    special care in all of the life cycle steps to make sure that users of charts
    don’t run into situations that accidentally break production workloads.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装和使用 CRD 时，Helm 开发人员建议在整个生命周期的所有步骤中特别小心，以确保图表的用户不会意外地破坏生产工作负载。
- en: Conclusion
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: Helm charts are more than a collection of templates. They handle dependencies,
    can include schemas, provide an event hook mechanism, can include tests, and have
    features for security. These features are part of what make Helm a robust and
    reliable solution to the package management problem.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 图表不仅仅是模板的集合。它们处理依赖关系，可以包含模式，提供事件钩子机制，可以包含测试，并具有安全特性。这些特性使 Helm 成为解决软件包管理问题的强大且可靠的解决方案的一部分。
