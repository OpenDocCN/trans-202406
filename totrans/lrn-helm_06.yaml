- en: Chapter 6\. Advanced Chart Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is more to charts than metadata about the chart and a collection of templates.
    Charts can have dependencies, values can have schemas, Helm has life cycle hooks,
    you can sign charts, and more. In this chapter you will learn about other elements
    of charts, moving beyond templates.
  prefs: []
  type: TYPE_NORMAL
- en: These features provide powerful solutions to common problems that arise when
    building packages. The chapter starts by covering dependencies. Dependencies are
    a critical part of virtually every package management solution because they let
    you leverage existing packages in your solution and build on the work of others.
    It then goes on to cover schemas and validation, which are useful when you want
    to help chart users avoid issues before covering ways you can hook into processes
    Helm performs to execute custom actions. This chapter covers tests and testing
    as well—tests are vital in development because they ensure your software is running
    as expected. Helm provides security features that aid in mitigating some common
    threat paths, which are covered next. The chapter concludes by looking at how
    charts can be used to extend the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you will see charts as examples you can reference at
    [*https://github.com/masterminds/learning-helm/blob/main/chapter6*](https://github.com/masterminds/learning-helm/blob/main/chapter6).
    They showcase different features covered in the chapter along with a Helm repository.
  prefs: []
  type: TYPE_NORMAL
- en: Chart Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependencies are a common element of package managers and their packages. Charts
    can have dependencies on other charts. This enables the encapsulation of a service
    in a chart, the reuse of charts, and the use of multiple charts together.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate dependencies, consider a chart to install WordPress, the popular
    blogging software. WordPress depends on a MySQL-compliant database to store the
    blog content, users, and other configuration. A MySQL-compliant database can be
    used by other applications and can be consumed as a service. One way to handle
    the use of MySQL with WordPress is to put the manifests for it in the WordPress
    chart. Another way to handle it is to have a MySQL chart that stands alone while
    the WordPress chart has a dependency on it. Having a MySQL-compliant database
    as an independent chart enables it to be used by more than one application, and
    the database can be built and tested independently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dependencies are specified in the *Chart.yaml* file. The following is the `dependencies`
    section in the *Chart.yaml* file for a chart named *rocket*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_advanced_chart_features_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the dependent chart within the repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_advanced_chart_features_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A version range string for the chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_advanced_chart_features_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The repository to retrieve the chart from.
  prefs: []
  type: TYPE_NORMAL
- en: Helm charts use semantic versions as their versioning scheme. The `version`
    field used for dependencies accepts a version range, and there are some shorthand
    syntaxes for those ranges. For example, `^1.2.3` is shorthand for `>= 1.2.3, <
    2.0.0`. Helm supports ranges including `=`, `!=`, `<`, `⇐`, `>`, `>=`, `^`, `~`,
    and `-`. Different ranges can be combined together using a space or comma to support
    logical *and* combinations and `|` to support logical *or* combinations. Helm
    also supports using a wildcard character of either `X` or `*`. If you omit a section
    of a version, such as omitting the patch portion, Helm will assume the missing
    part is a wildcard.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges are the preferred manner to specify the desired version. In a moment
    you’ll learn how to lock to a specific dependency version from the specified range.
    By specifying a range, it is possible to use Helm commands to automatically update
    to the latest release within that range. This is useful if you want to pull in
    bug fixes or security updates to dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `repository` field is where you specify the chart repository location to
    pull the dependency from. You can specify this in one of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: A URL to the Helm repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To the name of a repository you have set up using the `helm repo add` command.
    This name needs to be preceded by an @ and wrapped in quotes (e.g., `"@myrepo"`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A full URL is typically used to specify the location. This will ensure the same
    dependency is retrieved in every environment the chart is used in.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the dependencies with their requested version ranges specified,
    you need to use Helm to lock those dependencies to specific versions and retrieve
    the dependencies. If you are going to package up your chart as a chart archive
    as covered in [Chapter 4](ch04.xhtml#building_a_chart), you need to lock and fetch
    dependencies before packaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve the latest version of the dependency within the specified range
    and to retrieve it, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the command you will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Running this command caused a few steps to happen.
  prefs: []
  type: TYPE_NORMAL
- en: First, Helm resolved the latest version of the *booster* chart. It used the
    metadata in the repository to know which versions of the chart were available.
    From the metadata and the specified version range, Helm found the best match.
  prefs: []
  type: TYPE_NORMAL
- en: The resolved information is written to the *Chart.lock* file. Instead of a version
    range, the *Chart.lock* file contains the specific version of the dependencies
    to be used. This is important for reproducibility. The *Chart.lock* file is managed
    by Helm. Changes from users will be overwritten the next time `helm dep up` (the
    shorthand syntax) is run. This is similar to lock files for dependency managers
    on other platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Once Helm knows the specific version to use, it downloads the dependent chart
    and puts it into the *charts* subdirectory. It is important for the dependent
    charts to be in the *charts* directory because this is where Helm will get their
    contents from to render the templates. Charts can be in the *charts* directory
    in either their archive or directory form. When Helm downloads them from a repository,
    it stores them in their archive form.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a *Chart.lock* file but no contents in the *charts* directory, you
    can rebuild the *charts* directory by running the command `helm dependency build`.
    This will use the lock file to retrieve the dependencies at their already determined
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have dependencies, Helm will render their resources when you run commands
    like `helm install` or `helm upgrade`.
  prefs: []
  type: TYPE_NORMAL
- en: When you specify a dependency, you may also want to pass configuration from
    the parent or main chart to the dependent chart. If we look back at the WordPress
    example, this could be used to set the name of the database to use. Helm provides
    a method to do this within the parent chart’s values.
  prefs: []
  type: TYPE_NORMAL
- en: In the main chart’s *values.yaml* file, you can create a new section with the
    name of the dependent chart. In this section you can set the values you want passed
    in. You only need to set the ones you want changed because the dependent charts
    included in the *values.yaml* file will serve as the default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *values.yaml* file for the *rocket* chart there is a section that reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Helm knows this section is for the *booster* chart. In this case it sets the
    image tag to a specific value. Any of the values in the dependent chart can be
    set this way. When commands like `helm install` are run, you can use the flags
    to set values (e.g., `--set`) of the dependencies as well as those of the main
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: If you have two dependencies on the same chart you can optionally use the `alias`
    property in the *Chart.yaml* file. This property goes on each dependency you want
    to use an alternative name for next to the `name`, `version`, and other properties.
    With `alias` you can give each dependency a unique name that you can reference
    elsewhere, such as in the *values.yaml* file.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional Flags for Enabling Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm provides the ability for you to enable or disable dependencies through
    configuration. To illustrate this idea, consider the case where you want to provide
    a WordPress blogging solution but give the option to the personnel installing
    WordPress to either use a database as a service or an included database. If the
    person installing the chart chooses to use a database as a service, they would
    provide a URL to that service and not need to have a database installed. This
    can be accomplished through configuration in two different ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you want to control if a single feature is enabled or disabled through
    a dependency, you can use the `condition` property on a dependency. To illustrate
    this we will look at the `dependencies` section in the *Chart.yaml* file for the
    conditional chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency has a `condition` key with a value that tells Helm where to
    look in the values to know if it should be enabled or disabled. In the *values.yaml*
    file the corresponding section is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The default value, in this case, is to disable the dependency. When someone
    installs the chart they can enable the dependency by passing in a value to enable
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you have multiple features you want to enable or disable that involve
    dependencies, you can use the `tags` property. Like `condition`, this property
    sits alongside the `name` and `version` when describing a dependency. It contains
    a list of tags for a dependency. To illustrate this we can look at the dependencies
    of another chart named *tag*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here you will see two dependencies with a `tags` section. The tags are a list
    of related tags. In the chart’s *values.yaml* file you use a `tags` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`tags` is a property with a special meaning. The values here tell Helm to disable
    dependencies with the tag *faster* by default. They can be enabled when the chart’s
    user passes a true value into the chart as it’s being installed or upgraded.'
  prefs: []
  type: TYPE_NORMAL
- en: Importing Values from Child to Parent Charts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are times where you may want to import or pull values from a child to
    a parent chart. Helm provides two methods to do this. One is for the case where
    a child chart explicitly exported a value to be imported by a parent, and the
    other is for the case in which the child chart did not export a value.
  prefs: []
  type: TYPE_NORMAL
- en: The exports property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `exports` property is a special top-level property in a *values.yaml* file.
    When a child chart has declared an `export` property, its contents can be imported
    directly into a parent chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following from a child chart’s *values.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When the parent chart declares the child as a dependency, it can import from
    the exports like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the parent’s calculated values the types are now accessible at the top
    level. In YAML that would be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The child-parent format
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a parent chart wants to import a value from a child but the child chart
    hasn’t exported the value, there is a way to tell Helm to pull the child value
    into the parent chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, consider a child chart with the following values specified
    in its *values.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'These values are not exported, but the parent chart can import them anyway.
    When the dependency is declared in the parent, it can import the values using
    `child` and `parent` files, like the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In both methods of importing it’s the `import-values` property that’s used on
    the dependency. Helm knows how to differentiate between the different formats,
    and you can mix the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the child chart the top-level property of `types` will not be available
    in the parent chart under the top-level property of `characters` in its calculated
    values. That would be represented in YAML as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This format does allow for accessing nested values in addition to top-level
    properties using a period as a separator. For example, if the child chart had
    the following format, the `child` property on `import-values` could read `data.types`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Library Charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may run into the situation where you are creating multiple similar charts—charts
    that share a lot of the same templates. For these situations, there are library
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: Library charts are conceptually similar to software libraries. They provide
    reusable functionality that can be imported and used by other charts but cannot
    be installed themselves.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use `helm create` to create a new library chart, the first step is to
    remove the contents of the *templates* directory and the *values.yaml* file because
    neither of these will be used. Then, you need to tell Helm that this is a library
    chart. In the *Chart.yaml* file set the `type` to `library`. To illustrate this,
    here is the *Chart.yaml* file from a chart named *mylib*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The default value for `type`, when not set, is application. You only need to
    set it when your chart is a library.
  prefs: []
  type: TYPE_NORMAL
- en: Files in the *templates* directory that start with an underscore (i.e., `` `_`
    ``) are not expected to render manifests to send to Kubernetes. The convention
    is that helper templates and snippets are in _**.tpl* and _**.yaml* files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate how reusable templates work, the following is the template to
    create a `ConfigMap` in the *mylib* chart file named *_configmap.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_advanced_chart_features_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `fullname` function is the same as the one generated by `helm create`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_advanced_chart_features_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `labels` function generates the common labels Helm recommends to use in
    charts.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_advanced_chart_features_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A special template is defined that knows how to merge templates together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of this definition looks similar to other templates you would put into
    the *templates* directory. `define` is a function used to define a template that
    is used elsewhere. There are two templates defined in this file. *mylib.configmap.tpl*
    contains a template for a resource. This will look similar to other templates.
    It provides a blueprint that is meant to be overridden by the caller in a chart
    that includes this library. *mylib.configmap* is a special template. This is the
    template another chart will use. It takes *mylib.configmap.tpl* along with another
    template, yet to be defined, containing overrides, and merges them into one output.
    *mylib.configmap* uses a utility function that handles the merging and is handy
    to reuse. That function is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function takes a context (think about the `.` data covered in [Chapter 5](ch05.xhtml#developing_templates)),
    a template containing overrides, and the base template function to be overridden.
    The function will become more clear when you see how it is used.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The concept of library charts was developed prior to their official inclusion
    in Helm. The `merge` function was created by Adnan Abdulhussein as part of his
    work developing the idea through a chart named *Common*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate using this library function, the following template is from another
    chart named *mychart*. Prior to using the resources it defines, it needs to be
    added as a dependency, just like any other. A template is included in *mychart*
    to create a `ConfigMap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_advanced_chart_features_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Including and using the function from the library chart for the `ConfigMap`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_advanced_chart_features_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A new template is defined with just the parts to override the template provided
    by the library.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_advanced_chart_features_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `data` section is provided for use in the `ConfigMap`.
  prefs: []
  type: TYPE_NORMAL
- en: This template may appear to be confusing at first because there is a lot going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: The first line includes the `ConfigMap` template from the library chart. A new
    list is passed to it with two items. The first is the current data object, and
    the second is the name of another template containing elements to override those
    provided by the library chart.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of the file is the template containing overrides. In the template provided
    by the library chart no content was provided for the `data` section. It is empty.
    The function `mychart.configmap` provides a `data` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Helm rendered output from this template is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This output is the merged output from the library and the chart consuming the
    library. The same concept can be extended to other resources including those that
    are longer and more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Schematizing Values Files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The values defined by a *values.yaml* file are schemaless. There is no set structure
    that all *values.yaml* files need to follow. Different charts have different structures.
    This enables you to structure the values to the application or workload you’re
    deploying with the chart.
  prefs: []
  type: TYPE_NORMAL
- en: Schemas provide numerous useful benefits including the ability to validate content,
    and you can do things such as generate user interfaces from them.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides the optional ability for each chart to provide its own schema
    for its values using [JSON Schema](https://json-schema.org). JSON Schema provides
    a vocabulary to describe JSON files. YAML is a superset of JSON, and you can transform
    content between the two file formats. This makes it possible to use a JSON Schema
    to validate the content of a YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: When you run the commands `helm install`, `helm upgrade`, `helm lint`, and `helm
    template`, Helm will validate the values against what it finds in the *values.schema.json*
    file. The values Helm validates are the computed values. They include the values
    provided by the chart as well as the values passed in by the person installing
    the chart. The *values.schema.json* file lives next to the *values.yaml* file
    in the root of a chart. The file can describe all or part of the values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following section from a *values.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'A JSON Schema to check this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_advanced_chart_features_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`image` is an object. If `image` is passed to Helm as something other than
    an object, an error will be thrown.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_advanced_chart_features_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`pullPolicy` is a string. When other types, such as an integer, are passed
    in, an error will be thrown. This can catch subtle problems.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_advanced_chart_features_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `pullPolicy` must be one of the listed values. When another value, even
    a misspelling, is passed in to Helm, an error will be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, we can use the *booster* chart. If you run the command
    from the root of the chart, you’ll see an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following error tells you where the values don’t match the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: JSON Schemas provide several ways to describe properties. The most flexible
    method (a catch-all) is the use of regular expressions for strings. For example,
    instead of an `enum` a `pattern` of `^(Always|IfNotPresent)$` could have been
    used. The pattern would not have been as descriptive. The error would have noted
    the value didn’t fit the pattern. Patterns are great to use when there is no other
    method to describe a property’s value.
  prefs: []
  type: TYPE_NORMAL
- en: Schemas are a useful addition to charts that can catch and correct subtle issues
    someone may have when installing a chart.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm provides a means to hook into events in the release process and take action.
    This is useful if you want to bundle actions as part of a release—for example,
    building in the ability to back up a database as part of the upgrade process while
    ensuring that the backup occurs prior to upgrading the Kubernetes resources.
  prefs: []
  type: TYPE_NORMAL
- en: Hooks are like regular templates and the functionality they encapsulate is provided
    through containers running in Kubernetes clusters alongside the other resources
    for your application. What distinguishes hooks from other resources is when a
    special annotation is set. When Helm sees the `helm.sh/hook` annotation, it uses
    the resource as a hook instead of a resource to be installed as part of the application
    installed by the chart. [Table 6-1](#table_6-1) contains a list of hooks and when
    they are executed.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Helm hooks
  prefs: []
  type: TYPE_NORMAL
- en: '| Annotation value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| pre-install | Execution happens after resources are rendered but prior to
    those resources being uploaded to Kubernetes. |'
  prefs: []
  type: TYPE_TB
- en: '| post-install | Execution happens after resources have been uploaded to Kubernetes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| pre-delete | Execution happens on a deletion request prior to any resources
    being deleted from Kubernetes. |'
  prefs: []
  type: TYPE_TB
- en: '| post-delete | Execution happens after all resources have been deleted from
    Kubernetes. |'
  prefs: []
  type: TYPE_TB
- en: '| pre-upgrade | Execution happens after resources are rendered but prior to
    resources being updated in Kubernetes. |'
  prefs: []
  type: TYPE_TB
- en: '| post-upgrade | Execution happens after resources have been upgraded in Kubernetes.
    |'
  prefs: []
  type: TYPE_TB
- en: '| pre-rollback | Execution happens after resources have been rendered but prior
    to any resources in Kubernetes being rolled back. |'
  prefs: []
  type: TYPE_TB
- en: '| post-rollback | Execution happens after resources have been rolled back in
    Kubernetes. |'
  prefs: []
  type: TYPE_TB
- en: '| test | Execution occurs when the `helm test` command is run. Tests are covered
    in the next section. |'
  prefs: []
  type: TYPE_TB
- en: 'A single resource can implement more than one hook by listing them as a comma-separated
    list. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Hooks can be weighted and specify a deletion policy for the resources after
    they have run. The weight enables more than one hook for the same event to be
    specified while providing an order in which they will run. This gives you the
    ability to ensure a deterministic order. Because Kubernetes resources are used
    for the execution of hooks, the resources are stored in Kubernetes even after
    execution has completed. The deletion policy provides you with some additional
    control on when to delete these resources from Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code provides example annotations specifying all three values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The weight, specified by the `helm.sh/hook-weight` annotation key, is a number
    represented as a string. It should always be a string. The weight can be a positive
    or negative number and has a default value of `0`. Prior to executing hooks, Helm
    sorts them in ascending order.
  prefs: []
  type: TYPE_NORMAL
- en: The deletion policy, set using the annotation key `helm.sh/hook-delete-policy`,
    is a comma-separated list of policy options. The three possible deletion policies
    are found in [Table 6-2](#table_6-2).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2\. Helm hook deletion policies
  prefs: []
  type: TYPE_NORMAL
- en: '| Policy value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| before-hook-creation | The previous resource is deleted before a new instance
    of this hook is launched. This is the default. |'
  prefs: []
  type: TYPE_TB
- en: '| hook-succeeded | Delete the Kubernetes resource after the hook is successfully
    run. |'
  prefs: []
  type: TYPE_TB
- en: '| hook-failed | Delete the Kubernetes resource if the hook failed while executing.
    |'
  prefs: []
  type: TYPE_TB
- en: By default, Helm keeps the Kubernetes resources used for hooks until the hook
    is run again. This provides the ability to inspect the logs or look at other information
    about a hook after it is run. A common policy to set is the one used in the previous
    example. This will keep hook resources around unless they complete successfully.
    When hooks fail, the resources and their logs are still available for inspection,
    but otherwise they are deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Pod` is an example of a hook running post-install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you are running a Helm command, such as `helm install`, and want to skip
    running hooks, the `--no-hooks` flag can be used. This flag is available on commands
    that have hooks and will cause Helm to skip executing them. Hooks are an opt-out
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Tests to Charts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is an integral part of software development, and Helm provides the ability
    to test charts through the use of the *test* hook and Kubernetes resources. That
    means tests run in a Kubernetes cluster right alongside the workloads with access
    to the components installed by the chart. In addition to the chart testing built
    into Helm, the Helm project provides an additional testing tool named Chart Testing.
    Since Chart Testing builds upon the features in the Helm client, we will first
    look at the functionality built into the Helm client.
  prefs: []
  type: TYPE_NORMAL
- en: Helm Test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm has a `helm test` command that executes test hooks on a running instance
    of a chart. The resources implementing those hooks can check database access,
    that database schemas are properly in place, for working connections between workloads,
    and other operational details.
  prefs: []
  type: TYPE_NORMAL
- en: If a test fails, Helm will exit with a nonzero exit code and provide you with
    the name of the Kubernetes resource that failed. The nonzero exit code is useful
    when paired with some automation testing systems that detect failures this way.
    When you have the name of the Kubernetes resource, you can look at the logs to
    see what failed.
  prefs: []
  type: TYPE_NORMAL
- en: Tests typically live in the *tests* subdirectory of the *templates* directory.
    Putting the tests in this directory provides a useful separation. This is a convention
    and not required for tests to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a test, we will look at the [*booster* chart](https://oreil.ly/COJ7w).
    In the *templates/tests* directory, there is a single test in the file *test-connection.yaml*
    that contains the following test hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This test is the one created by default for Nginx when `helm create` is run.
    It happens to work to test connectivity to the booster application, as well. This
    simple test illustrates the structure of a test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you look at tests in some existing charts you might find the hook they use
    is `test-success` instead of `test`. In Helm version 2 there was a hook named
    `test-success` for running tests. Helm version 3 provides backward compatibility
    and will run this hook name as a test.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two steps to run tests. The first step is to install the chart so
    that an instance of it is running. You can use the `helm install` command to do
    this. The following command installs the *booster* chart and assumes you are running
    it from the root directory of the chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the instance of the chart is running, you run the `helm test` command
    to execute the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Helm will output the status of the test as it executes and then information
    about the test and the release when complete. For the previous test it would return:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: When charts have dependencies that have tests, those will be run, as well. For
    example, if the tests in the *rocket* chart used earlier in the chapter are run,
    the *booster* chart tests and the *rocket* chart tests will be run.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you need to have configuration installed as part of a test, you can put the
    test hook on a Kubernetes `Secret` or ConfigMap to have it installed with other
    test resources.
  prefs: []
  type: TYPE_NORMAL
- en: Testing charts is a great way to ensure the contents of a chart are able to
    get the workload running in Kubernetes and catch changes that may break that.
  prefs: []
  type: TYPE_NORMAL
- en: Chart Testing Tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Helm project provides an additional testing tool, built on the foundation
    of `helm test`, that provides more advanced testing capabilities. Some of the
    additional features it includes are:'
  prefs: []
  type: TYPE_NORMAL
- en: The ability to test different—mutually exclusive—configuration options at install
    time for a chart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chart.yaml* schema validation that includes custom schema rules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional YAML linting that includes configurable rules. For example, you can
    make sure indentation in the YAML files is consistent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the source is stored in Git, the ability to check if the `version` property
    in a *Chart.yaml* file has been properly incremented.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ability to work with collections of charts and only test those that have
    changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Chart Testing tool was designed to use in continuous integration system
    workflows, and some of the features directly target this situation.
  prefs: []
  type: TYPE_NORMAL
- en: The ability for Chart Testing to test a chart with different, mutually exclusive,
    configurations requires knowing those configurations. These are bundled in the
    *ci* directory of a chart.
  prefs: []
  type: TYPE_NORMAL
- en: In the *ci* directory you can create a values file for each situation to test.
    You need to use the glob naming pattern **-values.yaml* when you name each file.
    For example, you can use file names like *minimal-values.yaml* and *full-values.yaml*.
  prefs: []
  type: TYPE_NORMAL
- en: Chart Testing will test each of these configurations separately. For example,
    when the chart is being linted, each case will be linted separately. The custom
    values will be passed to `helm lint` using the `--values` flag. The same idea
    and flag applies when the chart is being runtime tested. The values are passed
    to Helm using the `--values` flag beacuse this is how end users, who install the
    chart, provide their custom configuration.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to test using various configurations but do not want to ship those
    configurations as part of the chart archive, you can put the *ci* directory in
    the *.helmignore* file. When Helm packages the chart, the *ci* directory will
    be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Chart Testing can be installed and used in various ways. For example, you can
    use it as a binary application on a development system or in a container within
    a continuous integration system. Learn more about [using and setting it up for
    your situation on the project page](https://oreil.ly/sJXpR).
  prefs: []
  type: TYPE_NORMAL
- en: Security Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some of the biggest and most trusted technology organizations have had their
    users be attacked through software updates. Software changes and the mechanisms
    used to update and even install software provide a channel of attack.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides an opt-in means to check the provenance and integrity of charts.
    *Provenance* provides a means to verify the origin, such as a company or person,
    of a chart while *integrity* provides a way to check that you received what you
    expected without alterations. This functionality enables you and those who use
    your charts to verify who they came from and that the contents have not changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To accomplish this Helm uses Pretty Good Privacy (PGP), hashes, and a provenance
    file that sits alongside the chart archive file. For example, if you have a chart
    archive named *mylib-1.0.0.tgz*, you can have a provenance file named *mylib-1.0.0.tgz.prov*.
    This file contains a PGP message with the contents of the *Chart.yaml* file along
    with the hash of the chart archive. Helm can generate these files for you. The
    following example is the provenance file for *mylib-1.0.0.tgz*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A provenance file is a PGP signed message with a particular structure in the
    message. That hash in the message is used by Helm to validate integrity, and the
    PGP signature is used to validate who it came from.
  prefs: []
  type: TYPE_NORMAL
- en: There are two steps to using provenance files. First, you need to generate them.
    In order to do that you need to have a PGP key pair.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a package using the `helm package` command, you can tell Helm
    to sign the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The additional flags will tell Helm to create the provenance file. The `--sign`
    flag opts-in to signing, the `--key` flag specifies the name of the private key
    to use, and the `--keyring` flag specifies the location of the keyring to use
    that contains the private key to use for signing. When Helm creates the archive
    of the chart, it will also create the *.prov* file alongside it.
  prefs: []
  type: TYPE_NORMAL
- en: The provenance file should then be uploaded alongside the chart archive and
    made available for download from a chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying happens in reverse and is built into commands such as `helm install`,
    `helm upgrade`, and `helm pull` along with being available in the `helm verify`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Helm can handle the situation where you have both the archive and provenance
    file locally available and when you have the chart in a remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the situation of having both files locally, we can use the `helm
    verify` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `verify` command will tell Helm to check the hash and signature. The `--keyring`
    flag tells Helm where a PGP keyring exists with the public key that matches the
    private key the chart was signed with. This can be either a keyring or a non-ASCII-Armored
    version of the public key. Helm will look for the *mychart-0.1.0.tgz.prov* file
    and use that to perform the check.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `verify` command on the *mylib* chart would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This would output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have a chart in a Helm repository, Helm will download the provenance
    file when it downloads the chart. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When Helm fetches the chart archive, it will also download the provenance file,
    verify the signature, and verify the hash.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The public key should be shared through a different channel from the chart and
    provenance file.
  prefs: []
  type: TYPE_NORMAL
- en: If there is a problem during the verification process, Helm will provide an
    error and exit with a nonzero exit code.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that a chart came from who you expected and that the content hasn’t
    changed is a useful step in securing your software supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Resource Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes custom resource definitions (CRDs) provide a means to extend the
    Kubernetes API, and Helm provides methods to install them as part of the chart.
  prefs: []
  type: TYPE_NORMAL
- en: There are two Helm-based methods to managing the CRDs used by a chart. Choosing
    between the methods to use often depends on the requirements and environment configurations
    of those who need to install your charts.
  prefs: []
  type: TYPE_NORMAL
- en: First, the *crds* directory is a special directory you can add to a chart to
    hold your CRDs. Helm will install CRDs prior to installing other resources. This
    ensures that CRDs are available for any custom resources or controllers that may
    leverage them in the chart.
  prefs: []
  type: TYPE_NORMAL
- en: CRDs in the *crds* directory are different from other resources installed by
    Helm. These files are not templated. This is useful for the CRD management workflows
    we will cover in a moment. Helm will not upgrade or delete CRDs like it does other
    resources. Upgrading CRDs changes the API surface for all instances of the custom
    resources in the cluster, and deleting CRDs removes all of the custom resources
    for all users. When it comes to handling these cluster-wide changes you will need
    to use a companion tool, like `kubectl`, the command-line tool for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Because CRDs change the Kubernetes API, whoever is installing your chart may
    not have permission to install, upgrade, or delete them. This is the case if you
    are bundling an application for distribution to other companies or the general
    public. Some cluster administrators restrict access to these functions as part
    of their access controls for security.
  prefs: []
  type: TYPE_NORMAL
- en: The CRDs in the *crds* directory can be extracted from a chart and used directly
    with tools like `kubectl`. This enables the CRDs to be passed to someone with
    permission to install them, if the person installing the chart doesn’t have permission.
    The extracted CRDs can also be used to upgrade the CRDs within a cluster using
    other tools.
  prefs: []
  type: TYPE_NORMAL
- en: A second, Helm-based, way to manage CRDs while providing an ordering that installs
    CRDs before using them through custom resources is to use a second chart that
    holds the CRDs. This method provides more nuanced control through Helm.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a second chart will let you:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Helm templates and the normal *templates* directory for CRDs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Helm will manage the life cycle of the CRDs. That includes uninstalling and
    upgrades. If you want to keep the CRD installed after the chart is uninstalled,
    you can set the annotation `"helm.sh/resource-policy": keep` to tell Helm to skip
    uninstalling the resource.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have issues with an application and use the uninstall and reinstall method
    to try to fix issues, the CRDs in the separate chart will not be deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This second chart can be installed with either a loose coupling, where the directions
    tell people to install it first, or a tight coupling, where it is set as a dependency.
    If the chart holding the CRDs is set as a dependency the use case should be that
    it is only installed once as it is setting cluster-wide resources.
  prefs: []
  type: TYPE_NORMAL
- en: When Helm is managing the CRDs, special care needs to be given for handling
    upgrade and delete cases. For example, if two versions of the CRD installing chart
    are installed, as you need to ensure an older version doesn’t overwrite a newer
    version and that a newer version doesn’t break the functionality for someone else
    in the cluster using the older version. This can happen if two people install
    different versions of the chart that installs CRDs. In multitenant clusters different
    users of the cluster may not know about each other, and it’s important to ensure
    that one user of the cluster does not break the workloads of another user of the
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: When installing and working with CRDs, the Helm developers recommend taking
    special care in all of the life cycle steps to make sure that users of charts
    don’t run into situations that accidentally break production workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Helm charts are more than a collection of templates. They handle dependencies,
    can include schemas, provide an event hook mechanism, can include tests, and have
    features for security. These features are part of what make Helm a robust and
    reliable solution to the package management problem.
  prefs: []
  type: TYPE_NORMAL
