<html><head></head><body><section data-pdf-bookmark="Chapter 25. Secure Configuration" data-type="chapter" epub:type="chapter"><div class="chapter" id="SecureConfiguration">&#13;
<h1><span class="label">Chapter 25. </span>Secure Configuration</h1>&#13;
&#13;
&#13;
<p>No<a data-primary="Secure Configuration" data-type="indexterm" id="secconfig25"/> real-world application lives in isolation. Instead, each connects to external systems in one way or the other.&#13;
Such external systems could include value-add services provided by the big cloud providers, other microservices that your service connects to, or a database.&#13;
Regardless of which remote services your application connects to, you will likely need to go through authentication, which involves sending over credentials such as username and password or some other security token.&#13;
This confidential information must be stored somewhere close to your application securely and safely.&#13;
This chapter’s <em>Secure Configuration</em> pattern is about the best ways to keep your credentials as secure as possible when running on Kubernetes.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902086875376">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>As<a data-primary="problems" data-secondary="credentials, keeping secure" data-type="indexterm" id="idm45902086873616"/><a data-primary="Secure Configuration" data-secondary="Configuration Resource" data-type="indexterm" id="idm45902086872624"/><a data-primary="Configuration Resource" data-secondary="Secure Configuration" data-type="indexterm" id="idm45902086871648"/><a data-primary="Configuration Resource" data-type="indexterm" id="idm45902086870704"/> you learned in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#ConfigurationResource">Chapter 20, “Configuration Resource”</a>, despite what its name implies, Secret<a data-primary="Secrets" data-secondary="security of" data-type="indexterm" id="idm45902086868672"/> resources are not encrypted but are only Base64 encoded.&#13;
Nevertheless, Kubernetes does its best to restrict access to a Secret’s content with the techniques described in <a data-type="xref" href="ch20.html#config-resource-secrets-secure">“How Secure Are Secrets?”</a>.</p>&#13;
&#13;
<p>However, as soon as Secret resources are stored outside the cluster, they are naked and vulnerable.&#13;
With the advent of GitOps as a prevalent paradigm for deploying and maintaining server-side applications, this security challenge is even more pressing.&#13;
Should Secrets be stored on remote Git repositories?&#13;
If so, then they must not be stored unencrypted.&#13;
However, when those are committed encrypted in a source code management system like Git, where do they get decrypted on their way into a Kubernetes cluster?</p>&#13;
&#13;
<p>Even when credentials are stored encrypted within the cluster, it is not guaranteed that nobody else can access that confidential information. While you can &#13;
<span class="keep-together">granularly</span> regulate access to Kubernetes resources with<a data-primary="RBAC (role-based access control)" data-type="indexterm" id="idm45902086865296"/><a data-primary="role-based access control (RBAC)" data-type="indexterm" id="idm45902086864624"/> RBAC rules,<sup><a data-type="noteref" href="ch25.html#idm45902086863808" id="idm45902086863808-marker">1</a></sup> at least one person has access to all data stored in the cluster: your cluster administrator. You might or might not be able to trust the cluster administrator. It all depends on the context in which your application operates. Are you running a Kubernetes cluster in the cloud operated by somebody else? Or is your application deployed on a big company-wide Kubernetes platform, and you need to know who is running this cluster? Different solutions are required depending on these trust boundaries and confidentiality requirements.</p>&#13;
&#13;
<p>Secrets are the Kubernetes answer for confidential configuration in-cluster storage.&#13;
We talked in depth about Secrets in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#ConfigurationResource">Chapter 20, “Configuration Resource”</a>, so let’s now have a look at how we can improve various security aspects of Secrets with additional techniques.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902086859856">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>The most straightforward solution for secure configuration is decoding encrypted information within the application itself.&#13;
This approach always works, and not just when running on Kubernetes.&#13;
But it takes considerable work to implement this within your code, and it couples your business logic with this aspect of securing your configuration.&#13;
There are better, more transparent ways to do this on Kubernetes.</p>&#13;
&#13;
<p>The support for secure configuration on Kubernetes falls roughly into two categories:</p>&#13;
<dl>&#13;
<dt>Out-of-cluster encryption</dt>&#13;
<dd>&#13;
<p>This stores encrypted configuration information outside of Kubernetes, which nonauthorized persons can also read. The transformation into Kubernetes Secrets happens just before entering the cluster (e.g., when applying a resource via the API server) or inside the cluster by a permanently running operator process.</p>&#13;
</dd>&#13;
<dt>Centralized secret management</dt>&#13;
<dd>&#13;
<p>This uses specialized services that are either already offered by cloud providers (e.g., AWS Secrets Manager or Azure Key Vault) or are part of an in-house vault service (e.g., HashiCorp Vault) for storing confidential configuration data.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>While out-of-cluster encryption techniques always eventually create a Secret within the cluster that your application can use, the support for external<a data-primary="secret management systems (SMSs)" data-type="indexterm" id="idm45902086854256"/><a data-primary="SMSs (secret management systems)" data-type="indexterm" id="idm45902086853488"/> secret management systems (SMSs) provided by Kubernetes add-ons uses various other techniques to bring the confidential information to the deployed workloads.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Out-of-Cluster Encryption" data-type="sect2"><div class="sect2" id="idm45902086852544">&#13;
<h2>Out-of-Cluster Encryption</h2>&#13;
&#13;
<p>The<a data-primary="out-of-cluster encryption" data-type="indexterm" id="idm45902086850928"/><a data-primary="encryption" data-secondary="out-of-cluster" data-type="indexterm" id="idm45902086850128"/> gist of the out-of-cluster technique is simple: pick up secret and confidential data from outside the cluster and transform it into a Kubernetes Secret.&#13;
A lot of projects have been grown that implement this technique. This chapter looks at the three most prominent ones (as of 2023): Sealed Secrets, External Secrets, and sops.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sealed Secrets" data-type="sect3"><div class="sect3" id="idm45902086848928">&#13;
<h3>Sealed Secrets</h3>&#13;
&#13;
<p>One<a data-primary="Secure Configuration" data-secondary="Sealed Secrets" data-type="indexterm" id="SCseal25"/><a data-primary="Sealed Secrets" data-type="indexterm" id="sealsec25"/><a data-primary="Secrets" data-secondary="Sealed Secrets" data-type="indexterm" id="Sseal25"/> of the oldest Kubernetes add-ons for helping with encrypted secrets is <em>Sealed Secrets</em>, introduced by Bitnami in 2017.&#13;
The idea is to store the encrypted data for a Secret in a CustomResourceDefinition (CRD) SealedSecret.&#13;
In the background, an operator monitors such resources and creates one Kubernetes Secret for each SealedSecret with the decrypted content.&#13;
To learn more about CRDs and operators in general, check out <a data-type="xref" data-xrefstyle="chap-num-title" href="ch28.html#Operator">Chapter 28, “Operator”</a>, which explains this pattern in detail.&#13;
While the decryption happens within the cluster, the <em>encryption</em> happens outside by a CLI tool called <code>kubeseal</code>, which takes a Secret and translates it to a SealedSecret that can be stored safely in a source code management system like Git.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-secure-configuration-sealed-secrets">Figure 25-1</a> shows the setup for Sealed Secrets.</p>&#13;
&#13;
<figure class="width-80"><div class="figure" id="img-secure-configuration-sealed-secrets">&#13;
<img alt="Sealed Secrets" src="assets/kup2_2501.png"/>&#13;
<h6><span class="label">Figure 25-1. </span>Sealed Secrets</h6>&#13;
</div></figure>&#13;
&#13;
<p>Secrets are encrypted with<a data-primary="AES-256-GCM encryption" data-type="indexterm" id="idm45902086836848"/><a data-primary="encryption" data-secondary="AES-256-GCM" data-type="indexterm" id="idm45902086836144"/> AES-256-GCM symmetrically as a session key, and the session key is encrypted asymmetrically with<a data-primary="RSA-OAEP encryption" data-type="indexterm" id="idm45902086834960"/><a data-primary="encryption" data-secondary="RSA-OAEP" data-type="indexterm" id="idm45902086834288"/> RSA-OAEP, the same setup TLS uses.</p>&#13;
&#13;
<p>The secret private key is stored within the cluster and is automatically created by the SealedSecret Operator.&#13;
It is up to the administrator to back up this key and rotate it if needed.&#13;
The public key used by <code>kubeseal</code> can be fetched directly from the cluster or accessed directly from a file.&#13;
You also can safely store the public key in Git along with your SealedSecret.</p>&#13;
&#13;
<p>SealedSecrets support three scopes that you can select when creating a SealedSecret from a Secret:</p>&#13;
<dl>&#13;
<dt>Strict</dt>&#13;
<dd>&#13;
<p>This freezes the namespace and name of the SealedSecret. This mode means you can create the SealedSecret only in the same namespace and with the same name as the original Secret in any target cluster. This mode is the default behavior.</p>&#13;
</dd>&#13;
<dt>Namespace-wide</dt>&#13;
<dd>&#13;
<p>This allows you to apply the SealedSecret to a different name than the initial Secret but still pins it to the same namespace.</p>&#13;
</dd>&#13;
<dt>Cluster-wide</dt>&#13;
<dd>&#13;
<p>This allows you to apply the SealedSecret to different namespaces, as it was initially created to do, and the name can be changed too.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>These scopes can be selected when creating the SealedSecret with <code>kubeseal</code>. Still, you can also add the nonstrict scopes with the annotations listed in <a data-type="xref" href="#table-secure-configuration-sealed-secret-annotations">Table 25-1</a> on the original Secret before encryption or on the SealedSecret directly.</p>&#13;
<table id="table-secure-configuration-sealed-secret-annotations">&#13;
<caption><span class="label">Table 25-1. </span>Annotation</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Annotation</th>&#13;
<th>Value</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>sealedsecrets.bitnami.com/namespace-wide</p></td>&#13;
<td><p><code>"true"</code></p></td>&#13;
<td><p>Enable namespace-wide scope when set to <code>true</code>—i.e., different name but same namespace</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>sealedsecrets.bitnami.com/cluster-wide</p></td>&#13;
<td><p><code>"true"</code></p></td>&#13;
<td><p>Enable cluster-wide scope when set to <code>true</code>—i.e., name and namespace can be changed on the SealedSecret after encryption</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p><a data-type="xref" href="#ex-secure-configuration-sealed-secret-resource">Example 25-1</a> shows a SealedSecret created by <code>kubeseal</code> that can be directly stored in Git.</p>&#13;
<div data-type="example" id="ex-secure-configuration-sealed-secret-resource">&#13;
<h5><span class="label">Example 25-1. </span>SealedSecret created with <code>kubeseal</code></h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="c1"># Command to create this sealed secret:</code><code class="w">&#13;
</code><code class="c1"># kubeseal --scope cluster-wide -f mysecret.yaml     </code><a class="co" href="#callout_secure_configuration_CO1-1" id="co_secure_configuration_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bitnami.com/v1alpha1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">SealedSecret</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">annotations</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">sealedsecrets.bitnami.com/cluster-wide</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">true</code><code class="s">"</code><code class="w">   </code><a class="co" href="#callout_secure_configuration_CO1-2" id="co_secure_configuration_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DB-credentials</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">encryptedData</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">password</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">AgCrKIIF2gA7tSR/gqw+FH6cEV..wPWWkHJbo=</code><code class="w"> </code><a class="co" href="#callout_secure_configuration_CO1-3" id="co_secure_configuration_CO1-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">user</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">AgAmvgFQBBNPlt9Gmx..0DNHJpDIMUGgwaQroXT+o=</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_secure_configuration_CO1-1" id="callout_secure_configuration_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Command to create a SealedSecret from the secret stored in <em>mysecret.yaml</em>.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO1-2" id="callout_secure_configuration_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Annotation that indicates that this SealedSecret can have any name and be applied to any namespace.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO1-3" id="callout_secure_configuration_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The secret values are encrypted individually (and shortened here for the sake of demonstration).</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>A Sealed Secret is a tool that allows you to store encrypted secrets in a publicly available location, such as a GitHub repository.&#13;
It is important to properly back up the secret key, as without it, it will not be possible to decrypt the secrets if the operator is uninstalled.&#13;
One potential drawback of Sealed Secrets is that they require a server-side operator to be continuously running in the cluster in order to perform the decryption.<a data-primary="" data-startref="SCseal25" data-type="indexterm" id="idm45902086750640"/><a data-primary="" data-startref="sealsec25" data-type="indexterm" id="idm45902086749696"/><a data-primary="" data-startref="Sseal25" data-type="indexterm" id="idm45902086709792"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="External Secrets" data-type="sect3"><div class="sect3" id="idm45902086848336">&#13;
<h3>External Secrets</h3>&#13;
&#13;
<p>The<a data-primary="External Secrets Operator" data-type="indexterm" id="idm45902086707248"/> <a href="https://oreil.ly/4kC1b">External Secrets Operator</a> is a Kubernetes operator that integrates a growing list of external SMSs.&#13;
The main difference between External Secrets and Sealed Secrets is that you do not manage the encrypted data storage yourself but rely on an external SMS to do the hard work, including encryption, decryption, and secure persistence.&#13;
That way, you benefit from all the features of your cloud’s SMS, like key rotation and a dedicated user interface.&#13;
SMS also provides an excellent way of separating concerns so that different roles can manage the application deployments and the secrets separately.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-secure-configuration-external-secrets">Figure 25-2</a> shows the External Secrets architecture.</p>&#13;
&#13;
<figure><div class="figure" id="img-secure-configuration-external-secrets">&#13;
<img alt="External Secrets" src="assets/kup2_2502.png"/>&#13;
<h6><span class="label">Figure 25-2. </span>External Secrets</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">A central operator reconciles two custom resources:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>SecretStore is the resource that holds the type and configuration of the external SMS to access. <a data-type="xref" href="#ex-secure-configuration-external-secrets-store">Example 25-2</a> gives an example of a store that connects to AWS Secret Manager.</p>&#13;
</li>&#13;
<li>&#13;
<p>ExternalSecret references a SecretStore, and the operator will create a corresponding Kubernetes Secret filled with the data fetched from the external SMS. For example, <a data-type="xref" href="#ex-secure-configuration-external-secrets-secret">Example 25-3</a> references a secret in the AWS Secret Manager and exposes the value within the specified target Secret.</p>&#13;
</li>&#13;
</ul>&#13;
<div class="less_space" data-type="example" id="ex-secure-configuration-external-secrets-store">&#13;
<h5><span class="label">Example 25-2. </span>SecretStore for connecting to AWS Secret Manager</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external-secrets.io/v1beta1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">SecretStore</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secret-store-aws</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">provider</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">aws</code><code class="p">:</code><code class="w">                        </code><a class="co" href="#callout_secure_configuration_CO2-1" id="co_secure_configuration_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">service</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">SecretsManager</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">region</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">us-east-1</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">auth</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">secretRef</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">accessKeyIDSecretRef</code><code class="p">:</code><code class="w"> </code><a class="co" href="#callout_secure_configuration_CO2-2" id="co_secure_configuration_CO2-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">awssm-secret</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">access-key</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">secretAccessKeySecretRef</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">awssm-secret</code><code class="w">&#13;
</code><code class="w">            </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secret-access-key</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_secure_configuration_CO2-1" id="callout_secure_configuration_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Provider <code>aws</code> configures the usage of the AWS Secret Manager.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO2-2" id="callout_secure_configuration_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Reference to a Secret that holds the access keys for talking with the AWS Secret Manager. A Secret with the name <code>awssm-secret</code> contains the keys <code>access-key</code> and <code>secret-access-key</code> used to authenticate against the AWS Secret Manager.</p></dd>&#13;
</dl></div>&#13;
<div data-type="example" id="ex-secure-configuration-external-secrets-secret">&#13;
<h5><span class="label">Example 25-3. </span>ExternalSecret that will be transformed into a Secret</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">external-secrets.io/v1beta1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ExternalSecret</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-credentials</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">refreshInterval</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1h</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">secretStoreRef</code><code class="p">:</code><code class="w">                </code><a class="co" href="#callout_secure_configuration_CO3-1" id="co_secure_configuration_CO3-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secret-store-aws</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">SecretStore</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">target</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-credentials-secrets</code><code class="w"> </code><a class="co" href="#callout_secure_configuration_CO3-2" id="co_secure_configuration_CO3-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">creationPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Owner</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">data</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cluster/db-username</code><code class="w">   </code><a class="co" href="#callout_secure_configuration_CO3-3" id="co_secure_configuration_CO3-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">username</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">cluster/db-password</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">password</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_secure_configuration_CO3-1" id="callout_secure_configuration_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Reference to the SecretStore object that holds the connection parameters for AWS Secret Manager.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO3-2" id="callout_secure_configuration_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Name of the Secret to create.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO3-3" id="callout_secure_configuration_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The username that will be looked up under <code>cluster/DB-username</code> in AWS Secret Manager and put under the key <code>username</code> in the resulting Secret.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>You have a lot of flexibility in defining the mapping of the external secret data to the content of the mirrored Secret—for example, using a template to create a configuration with a particular structure.&#13;
See the <a href="https://oreil.ly/Oj4Qq">External Secrets documentation</a> for more information.&#13;
One significant advantage of this solution over a client-side solution is that only the server-side operator knows the credentials to authenticate against the external SMS.</p>&#13;
&#13;
<p>The External Secrets Operator project merges several other Secret-syncing projects.&#13;
In 2023, it is already the dominant solution for this specific use case of mapping and syncing an externally defined secret to a Kubernetes Secret.&#13;
However, it has the same cost as a server-side component that runs all the time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sops" data-type="sect3"><div class="sect3" id="idm45902086481120">&#13;
<h3>Sops</h3>&#13;
&#13;
<p>Do<a data-primary="sops (Secret OPerationS)" data-type="indexterm" id="idm45902086430816"/><a data-primary="Secret OPerationS (sops)" data-type="indexterm" id="idm45902086430016"/> we need a server-side component to work with Secrets in a GitOps world where all resources are stored in a Git repository?&#13;
Luckily, solutions exist that work entirely outside of a Kubernetes cluster.&#13;
A pure client-side solution is <a href="https://oreil.ly/HH9GE">sops</a> (“Secret OPerationS”) by Mozilla.&#13;
Sops is not specific to Kubernetes but allows you to encrypt and decrypt any YAML or JSON file to safely store those in a source code repository.&#13;
It does this by encrypting all values of such a document but leaving the keys untouched.</p>&#13;
&#13;
<p>We can use various methods for encryption with sops:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Asymmetric local encryption via <a href="https://oreil.ly/DH4RE"><code>age</code></a> with the keys stored locally.</p>&#13;
</li>&#13;
<li>&#13;
<p>Storing the secret encryption key in a centralized key management system (KMS). Supported platforms are AWS KMS, Google KMS, and Azure Key Vault as external cloud providers and HashiCorp Vault as an SMS you can host on your own. The identity management of those platforms allows for fine-granular access control to the encryption key.</p>&#13;
</li>&#13;
</ul>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902086424960">&#13;
<h1>SMS Versus KMS</h1>&#13;
<p>In<a data-primary="SMSs (secret management systems)" data-type="indexterm" id="idm45902086423632"/><a data-primary="secret management systems (SMSs)" data-type="indexterm" id="idm45902086422832"/><a data-primary="key management systems (KMSs)" data-type="indexterm" id="idm45902086422144"/> the previous sections, we talked about <em>secret management systems</em> (SMSs), cloud services that do secret management for you. They provide an API for storing and accessing the secrets with granular and configurable access control. Those secrets are encrypted transparently for the user, and you don’t have to worry about this. <em>Key management systems</em> (KMSs) are cloud services you can access with an API. However, in contrast to SMSs, KMSs are not databases for secure data but care about the discovery and storage of encryption keys, which you can use to encrypt data outside of a KMS. The GnuPG keyservers are good examples of a KMS.&#13;
Each leading cloud provider offers both SMSs and KMSs. If you are sold to one of the big clouds, you also get good integration with its identity management for defining and assigning the access rules to SMS- and KMS-managed data.</p>&#13;
</div></aside>&#13;
&#13;
<p>Sops is a CLI tool you can run locally on your machine or within a cluster (e.g., as part of a CI pipeline).&#13;
Especially for the latter use case and if you are running in one of the big clouds, leveraging one of their KMSs provides a smooth integration.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-secure-configuration-sops">Figure 25-3</a> illustrates how sops handles encryption and decryption on the client side.</p>&#13;
&#13;
<figure class="width-70"><div class="figure" id="img-secure-configuration-sops">&#13;
<img alt="Sops" src="assets/kup2_2503.png"/>&#13;
<h6><span class="label">Figure 25-3. </span>Sops for decrypting and encrypting resource files</h6>&#13;
</div></figure>&#13;
&#13;
<p><a data-type="xref" href="#ex-secure-configuration-sops-encrypt">Example 25-4</a> shows how to use sops to create an encrypted version of a ConfigMap.<sup><a data-type="noteref" href="ch25.html#idm45902086415408" id="idm45902086415408-marker">2</a></sup>&#13;
This example uses <code>age</code> and a freshly generated keypair for the encryption, which should be stored safely.</p>&#13;
<div data-type="example" id="ex-secure-configuration-sops-encrypt">&#13;
<h5><span class="label">Example 25-4. </span>Sops for creating encrypted secrets</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="l-Scalar-Plain">$</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">age-keygen</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">-o</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">keys.txt</code><code class="w">       </code><a class="co" href="#callout_secure_configuration_CO4-1" id="co_secure_configuration_CO4-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="l-Scalar-Plain">Public</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">key</code><code class="p-Indicator">:</code><code class="w"> </code><code class="l-Scalar-Plain">age1j49ugcg2rzyye07ksyvj5688m6hmv</code><code class="w">&#13;
&#13;
</code><code class="l-Scalar-Plain">$</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">cat</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">configmap.yaml</code><code class="w">           </code><a class="co" href="#callout_secure_configuration_CO4-2" id="co_secure_configuration_CO4-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name_unencrypted</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-auth</code><code class="w">    </code><a class="co" href="#callout_secure_configuration_CO4-3" id="co_secure_configuration_CO4-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="nt">data</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="c1"># User and Password</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">USER</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">batman</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">PASSWORD</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">r0b1n</code><code class="s">"</code><code class="w">&#13;
&#13;
</code><code class="l-Scalar-Plain">$</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">sops</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">--encrypt</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">\</code><code class="w">             </code><a class="co" href="#callout_secure_configuration_CO4-4" id="co_secure_configuration_CO4-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="l-Scalar-Plain">--age</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">age1j49ugcg2rzyye07ksyvj5688m6hmv</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">\</code><code class="w">&#13;
</code><code class="w">    </code><code class="l-Scalar-Plain">configmap.yaml</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">&gt;</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">configmap_encrypted.yaml</code><code class="w">&#13;
&#13;
</code><code class="l-Scalar-Plain">$</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">cat</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">configmap_encrypted.yaml</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ENC[AES256_GCM,data:...,iv:...,tag:...,type:str]</code><code class="w"> </code><a class="co" href="#callout_secure_configuration_CO4-5" id="co_secure_configuration_CO4-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ENC[AES256_GCM,data:...,iv:...,tag:...,type:str]</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name_unencrypted</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-auth</code><code class="w">  </code><a class="co" href="#callout_secure_configuration_CO4-6" id="co_secure_configuration_CO4-6"><img alt="6" src="assets/6.png"/></a><code class="w">&#13;
</code><code class="nt">data</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="c1">#ENC[AES256_GCM,data:...,iv:...,tag:...,type:comment]</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">USER</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ENC[AES256_GCM,data:...,iv:...,tag:...=,type:str]</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">PASSWORD</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ENC[AES256_GCM,data:...,iv:...,tag:...,type:str]</code><code class="w">&#13;
</code><code class="nt">sops</code><code class="p">:</code><code class="w">                          </code><a class="co" href="#callout_secure_configuration_CO4-7" id="co_secure_configuration_CO4-7"><img alt="7" src="assets/7.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">age</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">recipient</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">age1j49ugcg2rzyye07ksyvj5688m6hmv</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">enc</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w">               </code><a class="co" href="#callout_secure_configuration_CO4-8" id="co_secure_configuration_CO4-8"><img alt="8" src="assets/8.png"/></a><code class="w">&#13;
</code><code class="w">            </code><code class="no">-----BEGIN AGE ENCRYPTED FILE-----</code><code class="w">&#13;
</code><code class="w">            </code><code class="no">YWdlLWVuY3J5cHRpb24ub3JnL3YxCi0+IFgyNTUxOSBqems3QkU4aXRyQWxaNER1</code><code class="w">&#13;
</code><code class="w">            </code><code class="no">TTdqcUZTeXFXNWhSY0E1T05XMUhVUzFjR1FnCmdMZmhlSlZCRHlqTzlNM0E1Z280</code><code class="w">&#13;
</code><code class="w">            </code><code class="no">Y0tqQ2VKYXdxdDZIZHpDbmxTYzhQSTgKLS0tIHlBYmloL2laZlA4Q05DTmRwQ0ls</code><code class="w">&#13;
</code><code class="w">            </code><code class="no">bURoU2xITHNzSXp5US9mUUV0Z0RackkKFtH+uNNe3A13pzSvHjT6n3q9av0pN7Nb</code><code class="w">&#13;
</code><code class="w">            </code><code class="no">i3AULtKvAGs6oAnH8qYbnwoj3qt/LFfnbqfeFk1zC2uqNONWkKxa2Q==</code><code class="w">&#13;
</code><code class="w">            </code><code class="no">-----END AGE ENCRYPTED FILE-----</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">last modified</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">2022-09-20T09:56:49Z</code><code class="s">"</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">mac</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ENC[AES256_GCM,data:...,iv:...,tag:...,type:str]</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">unencrypted_suffix</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">_unencrypted</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_secure_configuration_CO4-1" id="callout_secure_configuration_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create a secret key with <code>age</code> and store it in <em>keys.txt</em>.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO4-2" id="callout_secure_configuration_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The ConfigMap to encrypt.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO4-3" id="callout_secure_configuration_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The <code>name</code> field is changed to <code>name_unencrypted</code> to prevent it from getting encrypted.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO4-4" id="callout_secure_configuration_CO4-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Call sops with the public part of the <code>age</code> key, and store the result in <em>configmap_encrypted.yml</em>.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO4-5" id="callout_secure_configuration_CO4-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Each value is replaced with an encrypted version in <code>ENC[...]</code> (output shortened for readability).</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO4-6" id="callout_secure_configuration_CO4-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>The <code>name</code> of the ConfigMap is left untouched.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO4-7" id="callout_secure_configuration_CO4-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>An extra section, <code>sops</code> is appended to contain metadata that is needed for decryption.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO4-8" id="callout_secure_configuration_CO4-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Encrypted session key that is used for symmetrical decryption. This key itself is encrypted asymmetrically by <code>age</code>.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>As you can see, every value of the ConfigMap resource gets encrypted, even those that are not confidential, like resource types or the name of the resource.&#13;
You can skip the encryption for specific values by appending an <code>_unencrypted</code> suffix to the key (which gets stripped off later when doing the decryption).</p>&#13;
&#13;
<p>The generated <em>configmap_encrypted.yml</em> can safely be stored in Git or any other source control management.&#13;
As shown in <a data-type="xref" href="#ex-secure-configuration-sops-decrypt">Example 25-5</a>, you need the private key to decrypt the ciphered ConfigMap to apply it to the cluster.</p>&#13;
<div data-type="example" id="ex-secure-configuration-sops-decrypt">&#13;
<h5><span class="label">Example 25-5. </span>Decrypt sops-encoded resource and apply it to Kubernetes</h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code>$</code><code class="w"> </code><code class="nb">export</code><code class="w"> </code><code class="nv">SOPS_AGE_KEY_FILE</code><code class="o">=</code><code>keys.txt</code><code class="w">  </code><a class="co" href="#callout_secure_configuration_CO5-1" id="co_secure_configuration_CO5-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code>$</code><code class="w"> </code><code>sops</code><code class="w"> </code><code>--decrypt</code><code class="w"> </code><code>configmap_encrypted.yaml</code><code class="w"> </code><code class="p">|</code><code class="w"> </code><code>kubectl</code><code class="w"> </code><code>apply</code><code class="w"> </code><code>-f</code><code class="w"> </code><code>-</code><code class="w"> </code><a class="co" href="#callout_secure_configuration_CO5-2" id="co_secure_configuration_CO5-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code>configmap/db-auth</code><code class="w"> </code><code>created</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_secure_configuration_CO5-1" id="callout_secure_configuration_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Point sops to the private key to decrypt the session key.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO5-2" id="callout_secure_configuration_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Decrypt and apply to Kubernetes. Note that every <code>_unencrypted</code> suffix on the resource keys is removed during sops decryption.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Sops is an excellent solution for easy GitOps-style integration of Secrets without worrying about installing and maintaining Kubernetes add-ons.&#13;
However, while your configuration can now be stored securely in Git, it is essential to understand that as soon as those configurations have been handed over to the cluster, anybody with elevated access rights can read that data directly via the Kubernetes API.</p>&#13;
&#13;
<p>If this is not something you can tolerate, we need to dig deeper into the toolbox and look again at centralized SMSs.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Centralized Secret Management" data-type="sect2"><div class="sect2" id="idm45902086431856">&#13;
<h2>Centralized Secret Management</h2>&#13;
&#13;
<p>As<a data-primary="Secrets" data-secondary="centralized Secret management" data-type="indexterm" id="Scentral25"/> explained in <a data-type="xref" href="ch20.html#config-resource-secrets-secure">“How Secure Are Secrets?”</a>, Secrets are as secure as possible. Still, any administrator with cluster-wide read access can read every Secret stored unencrypted.&#13;
Depending on your trust relationship with your cluster operators and security requirements, this might or might not be a problem.</p>&#13;
&#13;
<p>Besides baking individual secret handling into your application code, an alternative is to keep the secure information outside the cluster in the external SMS and request the confidential information on demand over secure channels.</p>&#13;
&#13;
<p>There is a growing number of such SMSs out there, and every cloud provider offers its variant.&#13;
We won’t go into many details here for those individual offerings but focus on the mechanism of how such systems integrate into Kubernetes.&#13;
You will find a list of relevant products as of 2023 in <a data-type="xref" href="#sect-secure-configuration-more-information">“More Information”</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Secrets Store CSI Driver" data-type="sect3"><div class="sect3" id="idm45902086058432">&#13;
<h3>Secrets Store CSI Driver</h3>&#13;
&#13;
<p>The<a data-primary="Container Storage Interface (CSI)" data-type="indexterm" id="idm45902086056800"/><a data-primary="CSI (Container Storage Interface)" data-type="indexterm" id="idm45902086056000"/> Container Storage Interface (CSI) is a Kubernetes API for exposing storage systems to containerized applications.&#13;
CSI shows the path for third-party storage providers to plug in new types of storage that can be mounted as volumes in Kubernetes.&#13;
Of particular interest in the context of this pattern is the <a href="https://oreil.ly/vm0F3">Secrets Store CSI Driver</a>.&#13;
This driver, developed and maintained by the Kubernetes community, allows access to various centralized SMSs and mounts them as regular Kubernetes volumes.&#13;
The difference from a mounted Secret volume as described in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch20.html#ConfigurationResource">Chapter 20, “Configuration Resource”</a>, is that nothing is stored in the Kubernetes etcd database but securely outside the cluster.</p>&#13;
&#13;
<p>The Secrets Store CSI Driver supports the SMS from major cloud vendors (AWS, Azure, and GCP) and HashiCorp Vault.</p>&#13;
&#13;
<p>The Kubernetes setup for connecting a secret manager via the CSI driver involves performing these two administrative tasks:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Installing the Secrets Store CSI Driver and configuration for accessing a specific SMS. Cluster-admin permissions<a data-primary="cluster-admin" data-secondary="centralized Secret management" data-type="indexterm" id="idm45902086051072"/> are required for the installation process.</p>&#13;
</li>&#13;
<li>&#13;
<p>Configuring access rules and policies. Several provider-specific steps need to be completed, but the result is that a Kubernetes service account is mapped to a secret manager-specific role that allows access to the secrets.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><a data-type="xref" href="#img-secure-configuration-secrets-store-csi">Figure 25-4</a> shows the overall setup needed for enabling the Secrets Store CSI Driver with a HashiCorp Vault backend.</p>&#13;
&#13;
<figure class="width-80"><div class="figure" id="img-secure-configuration-secrets-store-csi">&#13;
<img alt="Secrets Store CSI Provider" src="assets/kup2_2504.png"/>&#13;
<h6><span class="label">Figure 25-4. </span>Secrets Store CSI Driver</h6>&#13;
</div></figure>&#13;
&#13;
<p>After the setup is done, the usage of secret volumes is straightforward.&#13;
First, you must define a SecretProviderClass, as demonstrated in <a data-type="xref" href="#ex-secure-configuration-csi-provider">Example 25-6</a>.&#13;
In this resource, you select the backend provider for the secret manager.&#13;
For our example, we selected HashiCorp’s Vault.&#13;
In the <code>parameters</code> section, the provider-specific configuration is added, which contains the connection parameter to the vault, the role to impersonate, and a pointer to the secret information that Kubernetes will mount into a Pod.</p>&#13;
<div data-type="example" id="ex-secure-configuration-csi-provider">&#13;
<h5><span class="label">Example 25-6. </span>Configuration of how to access a secret manager</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secrets-store.csi.x-k8s.io/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">SecretProviderClass</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">vault-database</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">provider</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">vault</code><code class="w">                                </code><a class="co" href="#callout_secure_configuration_CO6-1" id="co_secure_configuration_CO6-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">parameters</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">vaultAddress</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">http://vault.default:8200</code><code class="s">"</code><code class="w">    </code><a class="co" href="#callout_secure_configuration_CO6-2" id="co_secure_configuration_CO6-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">roleName</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">database</code><code class="s">"</code><code class="w">                         </code><a class="co" href="#callout_secure_configuration_CO6-3" id="co_secure_configuration_CO6-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="nt">objects</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w">&#13;
</code><code class="w">      </code><code class="no">- objectName: "database-password"          </code><a class="co" href="#callout_secure_configuration_CO6-4" id="co_secure_configuration_CO6-4"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="no">secretPath: "secret/data/database-creds" </code><a class="co" href="#callout_secure_configuration_CO6-5" id="co_secure_configuration_CO6-5"><img alt="5" src="assets/5.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="no">secretKey: "password"                    </code><a class="co" href="#callout_secure_configuration_CO6-6" id="co_secure_configuration_CO6-6"><img alt="6" src="assets/6.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_secure_configuration_CO6-1" id="callout_secure_configuration_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Type of provider to use (<code>azure</code>, <code>gcp</code>, <code>aws</code>, or <code>vault</code> as of 2023).</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO6-2" id="callout_secure_configuration_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Connection URL to the Vault service instance.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO6-3" id="callout_secure_configuration_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Vault-specific authentication role contains the Kubernetes service account allowed to connect.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO6-4" id="callout_secure_configuration_CO6-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Name of the file that should be mapped into the mounted volume.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO6-5" id="callout_secure_configuration_CO6-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Path to the stored secret in the vault.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO6-6" id="callout_secure_configuration_CO6-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Key to pick from the Vault secret.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This secret manager configuration can then be referenced by its name when used as a Pod volume.&#13;
<a data-type="xref" href="#ex-secure-configuration-csi-pod">Example 25-7</a> shows a Pod that mounts the secrets configured in <a data-type="xref" href="#ex-secure-configuration-csi-provider">Example 25-6</a>.&#13;
One key aspect is the service account <code>vault-access-sa</code> with which this Pod runs. This service account must be configured on the Vault side to be part of the role <code>database</code> referenced in the SecretProviderClass.</p>&#13;
&#13;
<p>You can find this Vault configuration in our complete working and self-contained <a href="https://oreil.ly/7w89_">example</a>,  along with setup instructions.</p>&#13;
<div data-type="example" id="ex-secure-configuration-csi-pod">&#13;
<h5><span class="label">Example 25-7. </span>Pod mounting a CSI volume from Vault</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shell-pod</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">vault-access-sa</code><code class="w">  </code><a class="co" href="#callout_secure_configuration_CO7-1" id="co_secure_configuration_CO7-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secrets-store</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">/secrets-store</code><code class="s">"</code><code class="w">      </code><a class="co" href="#callout_secure_configuration_CO7-2" id="co_secure_configuration_CO7-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secrets-store</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">csi</code><code class="p">:</code><code class="w">                             </code><a class="co" href="#callout_secure_configuration_CO7-3" id="co_secure_configuration_CO7-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">driver</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">secrets-store.csi.k8s.io</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">readOnly</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">volumeAttributes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">secretProviderClass</code><code class="p">:</code><code class="w"> </code><code class="s">"</code><code class="s">vault-database</code><code class="s">"</code><code class="w"> </code><a class="co" href="#callout_secure_configuration_CO7-4" id="co_secure_configuration_CO7-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_secure_configuration_CO7-1" id="callout_secure_configuration_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Service account that is used to authenticate against Vault.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO7-2" id="callout_secure_configuration_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Directory in which to mount the secrets.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO7-3" id="callout_secure_configuration_CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Declaration of a CSI Driver, which points to the Secret Store CSI driver.</p></dd>&#13;
<dt><a class="co" href="#co_secure_configuration_CO7-4" id="callout_secure_configuration_CO7-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Reference to the SecretProviderClass that provides the connection to the Vault service.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>While the setup for a CSI Secret Storage drive is quite complex, the usage is straightforward, and you can avoid storing confidential data within Kubernetes.&#13;
However, there are more moving parts than with Secrets alone, so more things can go wrong, and it’s harder to troubleshoot.</p>&#13;
&#13;
<p>Let’s look at a final alternative for offering secrets to applications via well-known Kubernetes abstractions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Pod injection" data-type="sect3"><div class="sect3" id="idm45902086057808">&#13;
<h3>Pod injection</h3>&#13;
&#13;
<p>As<a data-primary="Pods" data-secondary="Pod injection" data-type="indexterm" id="idm45902085753488"/> mentioned, an application can always access external SMSs via proprietary client libraries.&#13;
This approach’s disadvantage is that you still have to store the credentials to access the SMS along your application and add a hard dependency within your code to a particular SMS.&#13;
The CSI abstraction for projecting secret information into volumes visible as files for the deployed application is much more decoupled.</p>&#13;
&#13;
<p>Alternative solutions leverage other well-known patterns described in this book:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An<a data-primary="Secure Configuration" data-secondary="Init Container" data-type="indexterm" id="idm45902085750720"/><a data-primary="Secure Configuration" data-secondary="Sidecar" data-type="indexterm" id="idm45902085749744"/><a data-primary="Init Container" data-secondary="Secure Configuration" data-type="indexterm" id="idm45902085748768"/><a data-primary="Sidecar" data-secondary="Secure Configuration" data-type="indexterm" id="idm45902085747824"/><a data-primary="Init Container" data-type="indexterm" id="idm45902085746880"/><a data-primary="Sidecar" data-type="indexterm" id="idm45902085746208"/> <em>Init Container</em> (see <a data-type="xref" href="ch15.html#InitContainer">Chapter 15</a>) fetches the confidential data from an SMS and then copies it to a shared local volume that is mounted by the application container. The secret data is fetched only once before the main container starts.</p>&#13;
</li>&#13;
<li>&#13;
<p>A <em>Sidecar</em> (see <a data-type="xref" href="ch16.html#Sidecar">Chapter 16</a>) syncs the secret data from the SMS to a local ephemeral volume that is also accessed by the application. The benefit of the sidecar approach is that it can update the secrets locally in case the SMS starts to rotate the secrets.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>You can leverage these patterns on your own for your applications, but this is tedious.&#13;
It is much better to let an external controller inject the init container or sidecar into your application.</p>&#13;
&#13;
<p>An excellent example of such an injector is the HashiCorp <a href="https://oreil.ly/T1y41">Vault Sidecar Agent Injector</a>.&#13;
This injector is implemented as a so-called<a data-primary="mutating webhooks" data-type="indexterm" id="idm45902085740112"/><a data-primary="HashiCorp Vault Sidecar Agent Injector" data-type="indexterm" id="idm45902085739440"/> <em>mutating webhook</em>, a variant of a controller (see <a data-type="xref" data-xrefstyle="chap-num-title" href="ch27.html#Controller">Chapter 27, “Controller”</a>), that allows modification of any resource when it is created.&#13;
When a Pod specification contains a particular, vault-specific annotation, the vault controller will modify this specification to add a container for syncing with Vault and to mount a volume for the secret data.</p>&#13;
&#13;
<p><a data-type="xref" href="#img-secure-configuration-pod-injector">Figure 25-5</a> visualizes this technique, which is entirely transparent to the user.</p>&#13;
&#13;
<p>While you still need to install the Vault Injector controller, it has fewer moving parts than hooking up a CSI secret storage volume with the provider deployment for a particular SMS product.&#13;
Still, you can access all the secrets by just reading a file without using a proprietary client library.<a data-primary="" data-startref="Scentral25" data-type="indexterm" id="idm45902085735504"/></p>&#13;
&#13;
<figure><div class="figure" id="img-secure-configuration-pod-injector">&#13;
<img alt="Vault Injector" src="assets/kup2_2505.png"/>&#13;
<h6><span class="label">Figure 25-5. </span>Vault Injector</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902085732448">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>Now that we have seen the many ways you can make access to your confidential information more secure, the question is, which one is the best?</p>&#13;
&#13;
<p>As usual, it depends:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If your main goal is a simple way to encrypt Secrets stored in public-readable places like a remote Git repository, the pure <em>client-side</em> encryption that <em>Sops</em> offers is perfect.</p>&#13;
</li>&#13;
<li>&#13;
<p>The secret synchronization that the <em>External Secrets Operator</em> implements is a good choice when separating the concerns of retrieving credentials in a remote SMS and using them is essential.</p>&#13;
</li>&#13;
<li>&#13;
<p>The ephemeral volume projection of secret information provided by <em>Secret Storage CSI Providers</em> is the right choice for you when you want to ensure that no confidential information is stored permanently in the cluster except the access tokens for accessing external vaults.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sidebar injections like the <em>Vault Sidecar Agent Injector</em>  have the benefit of shielding from a direct access to an SMS. They are easily approachable at the cost of blurring the boundary between developers and administrator because of security annotations leaking into application deployment.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Note that the listed projects are the most prominent as of this writing in 2023.&#13;
The landscape is constantly evolving, so by the time you read this book, there might be new contenders (or some existing projects might have stopped).&#13;
However, the techniques used (client-side encryption, Secret synchronization, volume projections, and sidecar injections) are universal and will be part of future solutions.</p>&#13;
&#13;
<p>But a clear warning at the end: regardless of how securely and safely you can access your secret configuration, if somebody with evil intentions has full root access to your cluster and containers, a means to get to that data will always exist.&#13;
This pattern makes these kinds of exploits as difficult as possible by adding an extra layer on the Kubernetes Secret abstraction.<a data-primary="" data-startref="secconfig25" data-type="indexterm" id="idm45902085723616"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="sect-secure-configuration-more-information">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/-ROVS">Secure Configuration Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Alex Soto Bueno and Andrew Block’s <em>Kubernetes Secrets Management</em> (Manning, 2022)</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/sLSSI">Kubernetes: Sealed Secrets</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/XRkqy">Sealed Secrets</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/2VdMM">External Secrets Operator</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/VLVi8">Kubernetes External Secrets</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/HH9GE">Sops</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/2_27G">Kubernetes Secrets Store CSI Driver</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/NFU1g">Retrieve HashiCorp Vault Secrets with Kubernetes CSI</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/JUjiP">HashiCorp Vault</a></p>&#13;
</li>&#13;
<li>&#13;
<p>Secret Management Systems:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/LWLvX">Azure Key Vault</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/eJ-dk">AWS Secrets Manager</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/nYaCF">AWS Systems Manager Parameter Store</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/caLls">GCP Secret Manager</a></p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45902086863808"><sup><a href="ch25.html#idm45902086863808-marker">1</a></sup> RBAC rules are explained in detail in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch26.html#AccessControl">Chapter 26, “Access Control”</a>.</p><p data-type="footnote" id="idm45902086415408"><sup><a href="ch25.html#idm45902086415408-marker">2</a></sup> In the real world, you should use a Secret for this kind of confidential information, but here we use a ConfigMap to demonstrate that you can use <em>any</em> resource file with sops.</p></div></div></section></body></html>