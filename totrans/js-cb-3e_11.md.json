["```\ntry {\n  // This is guaranteed to fail with a URIError\n  const uri = decodeURI('http%test');\n\n  // We never get here\n  console.log('Success!');\n}\ncatch (error) {\n  console.log(error);\n}\n```", "```\nURIError: URI malformed\n    at decodeURI (<anonymous>)\n    at runTest (<anonymous>):14:15\n    at <anonymous>:20:1\n```", "```\ntry {\n  const uri = decodeURI('http%test');\n\n  // We never get here\n  console.log('Success!');\n}\ncatch (error) {\n  console.log(error);\n}\nfinally {\n  console.log('The operation (and any error handling) is complete');\n}\n```", "```\ntry {\n  // Some code that will raise an error\n}\ncatch (error) {\n  if (error instanceof RangeError) {\n    // Do something about the value being out of range\n  }\n  else if (error instanceof TypeError) {\n    // Do something about the value being the wrong type\n  }\n  else {\n    // Rethrow the error\n    throw error;\n  }\n}\n```", "```\nconst request = new XMLHttpRequest();\n\nrequest.onerror = function errorHander(error) {\n  console.log(error);\n}\n\nrequest.open('GET', 'http://noserver');\nrequest.send();\n```", "```\nfetch('http://noserver')\n.then((response) => {\n  console.log('We did it, fam.');\n})\n.catch((error) => {\n  console.log(error);\n});\n```", "```\nasync function doWork() {\n  try {\n    const response = await fetch('http://noserver');\n  }\n  catch (error) {\n    console.log(error);\n  }\n}\n\ndoWork().then(() => {\n  console.log('All done');\n});\n```", "```\n// Attach the event handler\nwindow.onerror = (message, url, lineNo, columnNo, error) => {\n  console.log(`An unhandled error occurred in ${url}`);\n}\n\n// Cause an unhandled error\nconsole.log(null.length);\n```", "```\n// Attach the event handler\nwindow.onunhandledrejection = (e) => {\n  console.log(e.reason);\n}\n\n// Create a promise that will cause an unhandled asynchronous error\nconst faultyPromise = new Promise(() => {\n  throw new Error('Disaster strikes!');\n});\n\n// Create a promise that rejects (also triggers window.onunhandledrejection)\nconst rejectedPromise = new Promise((resolve, reject) => {\n  reject(new Error('Another disaster strikes!'));\n});\n```", "```\nwindow.onunhandledrejection = (e) => {\n  console.log('An error occurred, but we won\\'t tell you what it was');\n\n  // Cancel the default error handling\n  e.preventDefault();\n}\n```", "```\nfunction strictDivision(number, divisor) {\n  if (divisor == 0) {\n    throw new Error('Dividing by zero is not allowed');\n  }\n  else {\n    return number/divisor;\n  }\n}\n\n// Catch the error\ntry {\n  const result = strictDivision(42, 0);\n}\ncatch (error) {\n  // Shows the custom error message\n  console.log(`Error: ${error.message}`);\n}\n```", "```\n// Standard error-throwing\nthrow new Error(`Dividing by zero is not allowed`);\n\n// An equivalent approach\nthrow Error(`Dividing by zero is not allowed`);\n```", "```\nfunction setAge(age) {\n  const upper = 125;\n  const lower = 18;\n  if (age > 125 || age < 18) {\n    throw new RangeError(\n     `Age [${age}] is out of the acceptable range of ${lower} to ${upper}.`);\n  }\n}\n```", "```\nfunction calculateValue(num) {\n  if (typeof num !== 'number') {\n    throw new TypeError(`Value [${num}] is not a number.`);\n  }\n}\n```", "```\nclass CustomError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'CustomError';\n\n    // Optional improvement: clean up the stack trace, if supported\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CustomError);\n    }\n  }\n}\n\n// Try raising this error\nthrow new CustomError('An application-specific problem occurred');\n```", "```\nclass ProductNotFound extends Error {\n  constructor(missingProductID) {\n    super(`Product ${missingProductID} does not exist in the catalog`);\n\n    this.name = 'ProductNotFound';\n    this.productID = missingProductID;\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ProductNotFound);\n    }\n  }\n}\n\ntry {\n  throw new ProductNotFound(420);\n}\ncatch (error) {\n  console.log(`An error occured with the message: ${error.message}`);\n\n  if (error instanceof ProductNotFound) {\n    console.log(`Missing: ${error.productID}`);\n  }\n}\n```", "```\n$ npm init -y\n```", "```\n$ npm install --save-dev jest\n```", "```\nfunction factorialize(number) {\n  if (number < 0) {\n    throw new RangeError('Factorials are only defined for positive numbers');\n  }\n  else if (number != Math.trunc(number)) {\n    throw new RangeError('Factorials are only defined for integers');\n  }\n  else {\n    if (number == 0 || number == 1) {\n      return 1;\n    }\n    else {\n      let result = number;\n      while (number > 1) {\n        number--;\n        result *= number;\n      }\n      return result;\n    }\n  }\n}\n```", "```\nexport {factorialize}\n```", "```\nimport {factorialize} from './factorialize.js';\n```", "```\ntest('10! is 3628800', () => {\n  expect(factorialize(10)).toBe(3628800);\n});\n```", "```\n$ npx jest factorialize.test.js\n```", "```\nPASS  ./factorialize.test.js\n √ 10! is 3628800 (4 ms)\n\nTest Suites: 1 passed, 1 total\nTests:       1 passed, 1 total\nSnapshots:   0 total\nTime:        2.725 s, estimated 3 s\n\nRan all test suites matching /factorialize.test.js\n```", "```\n{\n  \"scripts\": {\n    \"test\": \"jest\"\n  }\n}\n```", "```\ntest('Some test name', () => {\n  // Test assertions go here\n});\n```", "```\ntest('10! is 3628800', () => {\n  `expect`(factorialize(10)).`toBe`(3628800);\n});\n\n```", "```\ndescribe('factorialize() function tests', () => {\n  test('0! is 1', () => {\n    expect(factorialize(0)).toBe(1);\n  });\n  test('1! is 1', () => {\n    expect(factorialize(1)).toBe(1);\n  });\n  test('10! is 3628800', () => {\n    expect(factorialize(10)).toBe(3628800);\n  });\n  test('\"5\"! is 120', () => {\n    expect(factorialize('5')).toBe(120);\n  });\n  test('NaN is 0', () => {\n    expect(factorialize(NaN)).toBe(0);\n  });\n});\n```", "```\n FAIL  ./factorialize.test.js\n  factorialize() function tests\n    √ 0! is 1 (3 ms)\n    √ 1! is 1\n    √ 10! is 3628800\n    √ \"5\"! is 120\n    × NaN is 0 (3 ms)\n\n  ● factorialize() function tests › NaN is 0\n\n    RangeError: Factorials are only defined for integers\n\n      4 |   }\n      5 |   if (number != Math.trunc(number)) {\n    > 6 |     throw new RangeError('Factorials are only defined for integers');\n        |           ^\n      7 |   }\n      8 |   else {\n      9 |     if (number == 0 || number == 1) {\n\n      at factorialize (factorialize.js:6:11)\n      at Object.<anonymous> (factorialize.test.js:17:12)\n\nTest Suites: 1 failed, 1 total\nTests:       1 failed, 4 passed, 5 total\nSnapshots:   0 total\nTime:        2.833 s\nRan all test suites.\n```", "```\ntest('NaN causes error', () => {\n  expect(() => {\n    factorialize(NaN);\n  }).toThrow();\n});\n```", "```\n$ npx jest --collect-coverage\n```", "```\n-----------------|---------|----------|---------|---------|-------------------\nFile             | % Stmts | % Branch | % Funcs | % Lines | Uncovered Line #s\n-----------------|---------|----------|---------|---------|-------------------\nAll files        |   82.61 |    66.67 |     100 |   82.61 |\n factorialize.js |   82.61 |    66.67 |     100 |   82.61 | 3-4,6-7\n-----------------|---------|----------|---------|---------|-------------------\nTest Suites: 1 passed, 1 total\nTests:       4 passed, 4 total\nSnapshots:   0 total\nTime:        2.741 s\n```"]