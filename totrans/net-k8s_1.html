<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. Networking Introduction"><div class="chapter" id="networking_introduction">
<h1><span class="label">Chapter 1. </span>Networking Introduction</h1>


<p>“Guilty until proven innocent.” That’s the mantra of networks and the engineers who supervise them. In this opening chapter, we will wade through the development of networking technologies and standards, give a brief overview of the dominant theory of networking, and introduce our Golang web server that will be the basis of the networking examples in Kubernetes and the cloud throughout the book.</p>

<p>Let’s begin…at the beginning.</p>






<section data-type="sect1" data-pdf-bookmark="Networking History"><div class="sect1" id="idm46219958410296">
<h1>Networking History</h1>

<p>The internet <a data-type="indexterm" data-primary="networking" data-secondary="history of" id="ch1_term1"/>we know today is vast, with cables spanning oceans and mountains and connecting cities with lower latency than ever before. <a data-type="indexterm" data-primary="Lyon, Barrett" id="idm46219958407016"/>Barrett Lyon’s “Mapping the Internet,” shown in <a data-type="xref" href="#img-internet-map">Figure 1-1</a>, shows just how vast it truly is. That image illustrates all the connections between the networks of networks that make up the internet. The purpose of a network is to exchange information from one system to another system. That is an enormous ask of a distributed global system, but the internet was not always global; it started as a conceptual model and slowly was built up over time, to the behemoth in Lyon’s visually stunning artwork. There are many factors to consider when learning about networking, such as the last mile, the connectivity between a customer’s home and their internet service provider’s network—all the way to scaling up to the geopolitical landscape of the internet. The internet is integrated into the fabric of our society. In this book, we will discuss how networks operate and how Kubernetes abstracts them for us.</p>

<figure><div id="img-internet-map" class="figure">
<img src="Images/neku_0101.png" alt="Internet Art" width="652" height="337"/>
<h6><span class="label">Figure 1-1. </span>Barrett Lyon, “Mapping the Internet,” 2003</h6>
</div></figure>

<p><a data-type="xref" href="#a_brief_history_of_networking">Table 1-1</a> briefly outlines the history of networking before we dive into a few of the important <a data-type="indexterm" data-primary="Advanced Research Projects Agency Network (ARPANET)" id="idm46219958286600"/><a data-type="indexterm" data-primary="ARPANET (Advanced Research Projects Agency Network)" id="idm46219958285960"/>details.</p>
<table id="a_brief_history_of_networking">
<caption><span class="label">Table 1-1. </span>A brief history of networking</caption>
<thead>
<tr>
<th>Year</th>
<th>Event</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>1969</p></td>
<td><p>ARPANET’s first connection test</p></td>
</tr>
<tr>
<td><p>1969</p></td>
<td><p>Telnet 1969 Request for Comments (RFC) 15 drafted</p></td>
</tr>
<tr>
<td><p>1971</p></td>
<td><p>FTP RFC 114 drafted</p></td>
</tr>
<tr>
<td><p>1973</p></td>
<td><p>FTP RFC 354 drafted</p></td>
</tr>
<tr>
<td><p>1974</p></td>
<td><p>TCP RFC 675 by Vint Cerf, Yogen Dalal, and Carl Sunshine drafted</p></td>
</tr>
<tr>
<td><p>1980</p></td>
<td><p>Development of Open Systems Interconnection model begins</p></td>
</tr>
<tr>
<td><p>1981</p></td>
<td><p>IP RFC 760 drafted</p></td>
</tr>
<tr>
<td><p>1982</p></td>
<td><p>NORSAR and University College London left the ARPANET and began using TCP/IP over SATNET</p></td>
</tr>
<tr>
<td><p>1984</p></td>
<td><p>ISO 7498 Open Systems Interconnection (OSI) model published</p></td>
</tr>
<tr>
<td><p>1991</p></td>
<td><p>National Information Infrastructure (NII) Bill passed with Al Gore’s help</p></td>
</tr>
<tr>
<td><p>1991</p></td>
<td><p>First version of Linux released</p></td>
</tr>
<tr>
<td><p>2015</p></td>
<td><p>First version of Kubernetes released</p></td>
</tr>
</tbody>
</table>

<p class="pagebreak-before">In its earliest forms, networking was government run or sponsored; in the United States, the Department of Defense (DOD) sponsored the Advanced Research Projects Agency Network (ARPANET), well before Al Gore’s time in politics, which will be relevant in a moment. In 1969, ARPANET was deployed at the University of California–Los Angeles, the Augmentation Research Center at Stanford Research Institute, the University of California–Santa Barbara, and the University of Utah School of Computing. Communication between these nodes was not completed until 1970, when they <a data-type="indexterm" data-primary="NCP (Network Control Protocol)" id="idm46219952071976"/><a data-type="indexterm" data-primary="Network Control Protocol (NCP)" id="idm46219952071208"/>began using the Network Control Protocol (NCP).
NCP led to the development and use of the first computer-to-computer protocols like Telnet and File Transfer
Protocol (FTP).</p>

<p>The success of ARPANET and NCP, the first protocol to power ARPANET, led to NCP’s downfall. It could not keep up with the demands of the network and the variety of networks connected. In 1974, Vint Cerf, Yogen Dalal, and Carl Sunshine began <a data-type="indexterm" data-primary="RFC 675" id="idm46219952069560"/><a data-type="indexterm" data-primary="TCP (Transmission Control Protocol)" data-secondary="origins of" id="idm46219952068856"/>drafting RFC 675 for Transmission Control Protocol (TCP). (You’ll learn more about RFCs in a few paragraphs.) TCP would go on to become the standard for network connectivity. TCP allowed for exchanging packets across different types of networks. In 1981, <a data-type="indexterm" data-primary="IP (Internet Protocol), origins of" id="idm46219952067496"/><a data-type="indexterm" data-primary="RFC 791" id="idm46219952066808"/>the
Internet Protocol (IP), defined in RFC 791, helped break out the responsibilities of TCP into a separate protocol, increasing the modularity of the network. In the following years, many organizations, including the DOD, adopted TCP as the standard. By January 1983, <a data-type="indexterm" data-primary="TCP/IP" data-secondary="and ARPANET" data-secondary-sortas="ARPANET" id="idm46219952065720"/>TCP/IP had become the only approved protocol on ARPANET, replacing the earlier NCP
because of its versatility and modularity.</p>

<p>A competing standards organization, the <a data-type="indexterm" data-primary="ISO 7498, OSI model" id="idm46219952063848"/><a data-type="indexterm" data-primary="OSI (Open Systems Interconnection) model" data-secondary="ISO 7498 standards for" id="idm46219952063144"/>International Organization for Standardization (ISO), developed and published ISO 7498, “Open Systems Interconnection Reference Model,” which detailed the OSI model. With its publication also came the protocols to support it. Unfortunately, the OSI model protocols never gained traction and lost out to the popularity of TCP/IP. The OSI model is still an excellent learning tool for understanding the layered approach to networking, however.</p>

<p>In 1991, <a data-type="indexterm" data-primary="Gore, Al" id="idm46219952061256"/>Al Gore invented the internet (well, really he helped pass the National Information Infrastructure [NII] Bill), which helped lead to the creation of the <a data-type="indexterm" data-primary="IETF (Internet Engineering Task Force)" id="idm46219952060216"/><a data-type="indexterm" data-primary="Internet Engineering Task Force (IETF)" id="idm46219952059528"/><a data-type="indexterm" data-primary="Internet standards (IETF RFCs)" id="idm46219952058840"/><a data-type="indexterm" data-primary="proposed standards (IETF RFCs)" id="idm46219952058152"/>Internet Engineering Task Force (IETF). Nowadays <a data-type="indexterm" data-primary="RFC standards" id="idm46219958151480"/>standards for the internet are under the management of the IETF, an open consortium of leading experts and companies in the field of networking, like Cisco and Juniper. RFCs are published by the Internet Society and the Internet Engineering Task Force. RFCs are prominently authored by individuals or groups of engineers and computer scientists, and they detail their processes, operations, and applications for the internet’s functioning.</p>

<p class="pagebreak-before">An IETF RFC has two states:</p>
<dl>
<dt>Proposed Standard</dt>
<dd>
<p>A protocol specification has reached enough community support to be considered a standard. The designs are stable and well understood. A proposed standard can be deployed, implemented, and tested. It may be withdrawn from further consideration, however.</p>
</dd>
<dt>Internet Standard</dt>
<dd>
<p>Per RFC 2026: “In general, an internet standard is a stable specification and well understood,
technically competent, has multiple, independent, and interoperable implementations with substantial operational
experience, enjoys significant public support, and is recognizably useful in some parts of the internet.”</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Draft standard is a third classification that was discontinued in 2011.</p>
</div>

<p>There are thousands of internet standards defining how to implement protocols for all facets of networking, including wireless, encryption, and data formats, among others. Each one is implemented by contributors of open source projects and privately by large organizations like Cisco.</p>

<p>A lot has happened in the nearly 50 years since those first connectivity tests. Networks have grown in complexity and <a data-type="indexterm" data-startref="ch1_term1" id="idm46219958143480"/>abstractions, so let’s start with the OSI model.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="OSI Model"><div class="sect1" id="idm46219958409672">
<h1>OSI Model</h1>

<p>The OSI <a data-type="indexterm" data-primary="OSI (Open Systems Interconnection) model" data-secondary="ISO 7498 standards for" id="idm46219958140952"/><a data-type="indexterm" data-primary="OSI (Open Systems Interconnection) model" data-secondary="layers of" id="ch1_term2"/><a data-type="indexterm" data-primary="layering" data-secondary="of OSI model" data-secondary-sortas="OSI model" id="ch1_term3"/><a data-type="indexterm" data-primary="networking" data-secondary="OSI model and" id="ch1_term4"/>model is a conceptual framework for describing how two systems communicate over a network. The OSI model breaks down the responsibility of sending data across networks into layers. This works well for educational purposes to describe the relationships between each layer’s responsibility and how data gets sent over networks. Interestingly enough, it was meant to be a protocol suite to power networks but
lost to TCP/IP.</p>

<p>Here are the ISO standards that outline the OSI model and protocols:</p>

<ul>
<li>
<p>ISO/IEC 7498-1, “The Basic Model”</p>
</li>
<li>
<p>ISO/IEC 7498-2, “Security Architecture”</p>
</li>
<li>
<p>ISO/IEC 7498-3, “Naming and Addressing”</p>
</li>
<li>
<p>ISO/IEC 7498-4, “Management Framework”</p>
</li>
</ul>

<p>The ISO/IEC 7498-1 describes what the OSI model attempts to convey:</p>
<blockquote>
<p>5.2.2.1 The basic structuring technique in the Reference Model of Open Systems Interconnection is layering. According to this technique, each open system is viewed as logically composed of an ordered set of (N)-subsystems…Adjacent (N)-subsystems communicate through their common boundary. (N)-subsystems of the same rank (N) collectively form the (N)-layer of the Reference Model of Open Systems Interconnection. There is one and only one (N)-subsystem in an open system for layer N. An
(N)-subsystem consists of one or several (N)-entities. Entities exist in each (N)-layer. Entities in the same (N)-layer are termed peer-(N)-entities. Note that the highest layer does not have an (N+l)-layer above it, and the lowest layer does not have an (N-1)-layer below it.</p></blockquote>

<p>The OSI model description is a complex and exact way of saying networks have layers like cakes or onions. The OSI model breaks the responsibilities of the network into seven distinct layers, each with different functions to aid in transmitting information from one system to another, as shown in <a data-type="xref" href="#osi-model">Figure 1-2</a>. The layers encapsulate
information from the layer below it; these layers are Application, Presentation, Session, Transport, Network, Data Link, and Physical. Over the next few pages, we will go over each layer’s functionality and how it sends data between two systems.</p>

<figure><div id="osi-model" class="figure">
<img src="Images/neku_0102.png" alt="OSI Model" width="265" height="830"/>
<h6><span class="label">Figure 1-2. </span>OSI model layers</h6>
</div></figure>

<p>Each layer takes data from the previous layer and encapsulates it to <a data-type="indexterm" data-primary="PDU (Protocol Data Unit)" id="idm46219958124552"/><a data-type="indexterm" data-primary="Protocol Data Unit (PDU)" id="idm46219958237032"/>make its Protocol Data Unit (PDU). The PDU is used to describe the data at each layer. PDUs are also part of TCP/IP. The applications of the Session layer are considered “data” for the PDU, preparing the application information
for communication. Transport uses ports to distinguish what process on the local system is responsible for the data. <a data-type="indexterm" data-primary="packets" data-secondary="defined" id="idm46219958235848"/><a data-type="indexterm" data-primary="packets" data-secondary="in OSI model" data-secondary-sortas="OSI model" id="idm46219958234904"/><a data-type="indexterm" data-primary="Network (Internet) layer of OSI model" id="idm46219958233688"/><a data-type="indexterm" data-primary="routing" data-secondary="in Network layer" data-secondary-sortas="Network layer" id="idm46219958233000"/>The

<span class="keep-together">Network</span> layer PDU is the packet. Packets are distinct pieces of data routed between networks. The Data Link layer is the
frame or segment. Each packet is broken up into frames, checked for errors, and sent out on the local network. The Physical layer transmits the frame in bits over the medium. Next we will outline each layer in detail:</p>
<dl>
<dt>Application</dt>
<dd>

<p>The Application <a data-type="indexterm" data-primary="Application layer (L7)" data-secondary="examples of" id="idm46219958228856"/><a data-type="indexterm" data-primary="Application layer (L7)" data-secondary="of OSI model" data-secondary-sortas="OSI model" id="idm46219958227848"/>layer is the top layer of the OSI model and is the one the end user interacts with every day. This layer is not where actual applications live, but it provides the interface for applications that use it like a web browser or Office 365. The single biggest interface is <a data-type="indexterm" data-primary="HTTP" data-secondary="in Application layer" data-secondary-sortas="Application layer" id="idm46219958226216"/>HTTP; you are probably reading this book on a web page hosted by an O’Reilly web server. Other examples of the Application layer that we use daily are DNS, SSH, and SMTP. Those applications are responsible for displaying and arranging data requested and sent over the network.</p>
</dd>
<dt>Presentation</dt>
<dd>

<p>This layer <a data-type="indexterm" data-primary="Presentation layer, OSI model" id="idm46219958223304"/>provides independence from data representation by translating between application and network formats. It
can be referred to as the <em>syntax layer</em>. This layer allows two systems to use different encodings for data and
still pass data between them. Encryption is also done at this layer, but that is a more complicated story we’ll save for <a data-type="xref" href="#tlssection">“TLS”</a>.</p>
</dd>
<dt>Session</dt>
<dd>

<p>The Session <a data-type="indexterm" data-primary="Session layer, OSI model" id="idm46219958219592"/>layer is responsible for the duplex of the connection, in other words, whether sending and receiving data at the same
time. It also establishes procedures for performing checkpointing, suspending, restarting, and terminating a session.
It builds, manages, and terminates the connections between the local and remote applications.</p>
</dd>
<dt>Transport</dt>
<dd>

<p>The Transport <a data-type="indexterm" data-primary="Transport layer, OSI model" id="idm46219958217128"/><a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="overview of" id="idm46219958216376"/>layer transfers data between applications, providing reliable data transfer services to the
upper layers. The Transport layer controls a given connection’s reliability through flow control, segmentation and
desegmentation, and error control. Some protocols are state- and connection-oriented. This layer tracks the
segments and retransmits those that fail. It also provides the acknowledgment of successful data
transmission and sends the next data if no errors <a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="UDP alternative for" id="idm46219958214808"/><a data-type="indexterm" data-primary="UDP (User Datagram textProtocol)" data-secondary="in Transport layer of TCP/IP" data-secondary-sortas="Transport layer of TCP/IP" id="idm46219958213848"/>occurred. TCP/IP has two protocols at this layer: TCP and User Datagram 
<span class="keep-together">Protocol</span> (UDP).</p>
</dd>
<dt>Network</dt>
<dd>

<p>The Network <a data-type="indexterm" data-primary="Network (Internet) layer of OSI model" id="idm46219958210456"/><a data-type="indexterm" data-primary="routing" data-secondary="in Network layer" data-secondary-sortas="Network layer" id="idm46219958209704"/>layer implements a means of transferring variable-length data flows from a  host on one network to a host on another network while sustaining 
<span class="keep-together">service quality.</span> The Network layer performs routing functions and might also perform fragmentation and reassembly while reporting delivery errors. Routers operate at this layer, sending data throughout the neighboring networks. Several management  protocols  belong  to  the  Network  layer,  including  routing  protocols,  multicast  group  management,  network-layer information, error handling, and network-layer address assignment, which we will discuss further in 
<span class="keep-together"><a data-type="xref" href="#tcp_ip">“TCP/IP”</a>.</span></p>
</dd>
<dt>Data Link</dt>
<dd>

<p>This layer is <a data-type="indexterm" data-primary="data" data-secondary="host-to-host transfer of" id="idm46219958204504"/><a data-type="indexterm" data-primary="host-to-host data transfers" id="idm46219958203480"/><a data-type="indexterm" data-primary="Link layer (L2)" data-secondary="of OSI model" data-secondary-sortas="OSI model" id="idm46219958202792"/>responsible for the host-to-host transfers on the same network. It defines the protocols to create and
terminate the connections between two devices.  The Data Link layer transfers data between network hosts and
provides the means to detect and possibly correct errors from the Physical layer. Data Link frames, the PDU for layer
2, do not cross the boundaries of a local network.</p>
</dd>
<dt>Physical</dt>
<dd>

<p>The Physical <a data-type="indexterm" data-primary="Physical layer" data-secondary="of OSI model" data-secondary-sortas="OSI model" id="idm46219958199768"/>layer is represented visually by an Ethernet cord plugged into a switch. This layer converts data in the form
of digital bits into electrical, radio, or optical signals. Think of this layer as the physical devices, like cables, switches, and
wireless access points. The wire signaling protocols are also defined at this layer.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are many mnemonics to remember the layers of the OSI model; our favorite is All People Seem To Need Data Processing.</p>
</div>

<p><a data-type="xref" href="#osi_layers_details">Table 1-2</a> summarizes the OSI layers.</p>
<table id="osi_layers_details">
<caption><span class="label">Table 1-2. </span>OSI layer details</caption>
<thead>
<tr>
<th>Layer number</th>
<th>Layer name</th>
<th>Protocol data unit</th>
<th>Function overview</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>7</p></td>
<td><p>Application</p></td>
<td><p>Data</p></td>
<td><p>High-level APIs and application protocols like HTTP, DNS, and SSH.</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>Presentation</p></td>
<td><p>Data</p></td>
<td><p>Character encoding, data compression, and encryption/decryption.</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>Session</p></td>
<td><p>Data</p></td>
<td><p>Continuous data exchanges between nodes are managed here: how much data to
send, when to send more.</p></td>
</tr>
<tr>
<td><p>4</p></td>
<td><p>Transport</p></td>
<td><p>Segment, datagram</p></td>
<td><p>Transmission of data segments between endpoints on a network, including
segmentation, acknowledgment, and multiplexing.</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>Network</p></td>
<td><p>Packet</p></td>
<td><p>Structuring and managing addressing, routing, and traffic control for all endpoints on the network.</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>Data Link</p></td>
<td><p>Frame</p></td>
<td><p>Transmission of data frames between two nodes connected by a Physical layer.</p></td>
</tr>
<tr>
<td><p>1</p></td>
<td><p>Physical</p></td>
<td><p>Bit</p></td>
<td><p>Sending and receiving of bitstreams over the medium.</p></td>
</tr>
</tbody>
</table>

<p class="pagebreak-before">The OSI model breaks down all the necessary functions to send a data packet over a network between two hosts. In the
late 1980s and early 1990s, it lost out to TCP/IP as the standard adopted by the DOD and all other major players in networking. The standard <a data-type="indexterm" data-primary="OSI (Open Systems Interconnection) model" data-secondary="ISO 7498 standards for" id="idm46219958491304"/><a data-type="indexterm" data-primary="ISO 7498, OSI model" id="idm46219958490232"/>defined in ISO 7498 gives a brief glimpse into the implementation details that were considered by most at the time to be complicated, inefficient, and to an extent unimplementable. The OSI model at a high level still allows those learning networking to comprehend the basic concepts and challenges in networking. In addition, these terms and functions are used in the TCP/IP model covered in the next section and ultimately in Kubernetes
abstractions. Kubernetes services break out each function <a data-type="indexterm" data-startref="ch1_term2" id="idm46219958488920"/><a data-type="indexterm" data-startref="ch1_term3" id="idm46219958488248"/><a data-type="indexterm" data-startref="ch1_term4" id="idm46219958487576"/>depending on the layer it is operating at, for example, a layer 3 IP address or a layer 4 port; you will learn more about that in <a data-type="xref" href="ch04.xhtml#kubernetes_networking_introduction">Chapter 4</a>. Next, we will do a deep dive into the TCP/IP suite with an example walk-through.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="TCP/IP"><div class="sect1" id="tcp_ip">
<h1>TCP/IP</h1>

<p>TCP/IP creates a <a data-type="indexterm" data-primary="TCP/IP" id="ch1_term5"/>heterogeneous network with open protocols that are independent of the operating system and architectural
differences. Whether the hosts are running Windows, Linux, or another OS, TCP/IP allows them to communicate; TCP/IP does
not care if you are running Apache or Nginx for your web server at the Application layer. The separation of responsibilities
similar to the OSI model makes that possible. In <a data-type="xref" href="#img-osi-tcp">Figure 1-3</a>, we compare the <a data-type="indexterm" data-primary="Network (Internet) layer of OSI model" id="idm46219958481352"/><a data-type="indexterm" data-primary="OSI (Open Systems Interconnection) model" data-secondary="versus TCP/IP" data-secondary-sortas="TCP/IP" id="idm46219958480680"/><a data-type="indexterm" data-primary="TCP/IP" data-secondary="versus OSI model" data-secondary-sortas="OSI model" id="idm46219958479496"/><a data-type="indexterm" data-primary="Presentation layer, OSI model" id="idm46219958478280"/><a data-type="indexterm" data-primary="Session layer, OSI model" id="idm46219958477640"/>OSI model to TCP/IP.</p>

<figure><div id="img-osi-tcp" class="figure">
<img src="Images/neku_0103.png" alt="OSI Model" width="633" height="921"/>
<h6><span class="label">Figure 1-3. </span>OSI model compared to TCP/IP</h6>
</div></figure>

<p>Here we expand on the differences between the OSI model and the TCP/IP:</p>
<dl>
<dt>Application</dt>
<dd>

<p>In TCP/IP, the <a data-type="indexterm" data-primary="Application layer (L7)" data-secondary="examples of" id="idm46219958472456"/><a data-type="indexterm" data-primary="Application layer (L7)" data-secondary="of OSI model" data-secondary-sortas="OSI model" id="idm46219958471448"/><a data-type="indexterm" data-primary="Application layer (L7)" data-secondary="of TCP/IP" data-secondary-sortas="TCP/IP" id="idm46219957981192"/><a data-type="indexterm" data-primary="communication" data-secondary="Application layer for" id="idm46219957979976"/><a data-type="indexterm" data-primary="TCP/IP" data-secondary="Application layer of" id="idm46219957979032"/>Application layer comprises the communications protocols used in process-to-process communications
across an IP network. The Application layer standardizes communication and depends upon the underlying Transport layer protocols to <a data-type="indexterm" data-primary="data" data-secondary="host-to-host transfer of" id="idm46219957977720"/><a data-type="indexterm" data-primary="host-to-host data transfers" id="idm46219957976808"/>establish the host-to-host data transfer. The lower Transport layer also manages the data exchange in
network communications. Applications at this layer are defined in RFCs; in this book, we will <a data-type="indexterm" data-primary="HTTP" data-secondary="in Application layer" data-secondary-sortas="Application layer" id="idm46219957975832"/>continue to use HTTP, RFC 7231 as our example for the Application layer.</p>
</dd>
<dt>Transport</dt>
<dd>

<p>TCP and UDP <a data-type="indexterm" data-primary="Transport layer, OSI model" id="idm46219957973112"/><a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="overview of" id="idm46219957972408"/><a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="UDP alternative for" id="idm46219957971496"/><a data-type="indexterm" data-primary="UDP (User Datagram textProtocol)" data-secondary="in Transport layer of TCP/IP" data-secondary-sortas="Transport layer of TCP/IP" id="idm46219957970536"/>are the primary protocols of the Transport layer that provide host-to-host communication services for
applications. Transport protocols are responsible for connection-oriented communication, reliability, flow control,
and multiplexing. In TCP, the window size manages flow control, while UDP does not manage the congestion flow and is
considered unreliable; you’ll learn more about that in <a data-type="xref" href="#udpsection">“UDP”</a>. Each port identifies the host process responsible for processing the information from the network communication. <a data-type="indexterm" data-primary="HTTP" data-secondary="ports used by" id="idm46219957967800"/><a data-type="indexterm" data-primary="port 80" id="idm46219957966856"/><a data-type="indexterm" data-primary="ports" data-secondary="HTTP 80 and 443" id="idm46219957966184"/><a data-type="indexterm" data-primary="ports" data-secondary="identification of" id="idm46219957965240"/>HTTP uses the well-known port 80 for nonsecure communication and 443 for secure communication. Each port on the server identifies its traffic, and the sender generates a random port locally to identify itself. The <a data-type="indexterm" data-primary="IANA (Internet Assigned Number Authority)" id="idm46219957963944"/><a data-type="indexterm" data-primary="Internet Assigned Number Authority (IANA)" id="idm46219957963240"/>governing body that manages port number assignments is the Internet Assigned Number Authority (IANA); there are 65,535 ports.</p>
</dd>
<dt>Internet</dt>
<dd>

<p>The Internet, or Network <a data-type="indexterm" data-primary="Network (Internet) layer, TCP/IP (L3)" data-secondary="overview of" id="idm46219957961112"/>layer, is responsible for transmitting data between networks. For an outgoing packet, it selects the
next-hop host and transmits it to that host by passing it to the appropriate link-layer. Once the packet is
received by the destination, the Internet layer will pass the packet payload up to the appropriate Transport layer
protocol.</p>

<p>IP  provides the fragmentation or defragmentation of packets <a data-type="indexterm" data-primary="packets" data-secondary="MTUs of" id="idm46219957959256"/><a data-type="indexterm" data-primary="maximum transmission unit (MTU)" id="idm46219957958280"/><a data-type="indexterm" data-primary="MTU (maximum transmission unit)" id="idm46219957957592"/>based on the maximum transmission unit (MTU); this is the maximum size of the IP packet.  IP makes no guarantees about packets’ proper arrival. Since packet
delivery across diverse networks is inherently unreliable and failure-prone, that burden is with the endpoints of a
communication path, rather than on the network.  The function of providing service reliability is in the Transport
layer. A <a data-type="indexterm" data-primary="checksum" id="idm46219957956360"/>checksum ensures that the information in a received packet is accurate, but this layer does not validate
data integrity.  The IP address identifies packets on the network.</p>
</dd>
<dt>Link</dt>
<dd>

<p>The Link <a data-type="indexterm" data-primary="Link layer (L2)" data-secondary="of TCP/IP" data-secondary-sortas="TCP/IP" id="idm46219957954088"/><a data-type="indexterm" data-primary="TCP/IP" data-secondary="Data Link layer of" id="idm46219957952808"/>layer in the TCP/IP model comprises networking protocols that operate only on the local network that a
host connects to. Packets are not routed to nonlocal networks; that is the Internet layer’s role. <a data-type="indexterm" data-primary="Ethernet" data-secondary="in Link layer" data-secondary-sortas="Link layer" id="idm46219957951512"/>Ethernet is
the dominant protocol at this layer, and hosts are identified by the link-layer address or commonly their Media
Access Control addresses on their network interface cards. Once <a data-type="indexterm" data-primary="Address Resolution Protocol (ARP)" id="idm46219957949960"/><a data-type="indexterm" data-primary="ARP (Address Resolution Protocol)" id="idm46219957949272"/>determined by the host using Address Resolution
Protocol 9 (ARP), data sent off the local network is processed by the Internet layer. This layer also includes
protocols for moving packets between two Internet layer hosts.</p>
</dd>
<dt>Physical layer</dt>
<dd>

<p>The Physical <a data-type="indexterm" data-primary="Physical layer" data-secondary="of TCP/IP" data-secondary-sortas="TCP/IP" id="idm46219957946936"/><a data-type="indexterm" data-primary="TCP/IP" data-secondary="Physical layer of" id="idm46219957945656"/>layer defines the components of the hardware to use for the network. For example, the Physical network layer stipulates the physical characteristics of the communications media. The Physical layer of TCP/IP details hardware standards <a data-type="indexterm" data-primary="IEEE 802 standards" id="idm46219957944328"/>such as IEEE 802.3, the specification for Ethernet network media. Several interpretations of RFC 1122 for the Physical layer are included with the other layers; we have added this for completeness.</p>
</dd>
</dl>

<p>Throughout this book, we will use the minimal Golang web server (also called Go) from <a data-type="xref" href="#minmal_web_server_in_go">Example 1-1</a> to show various levels of networking components from <code>tcpdump</code>, a Linux syscall, to show how Kubernetes abstracts the syscalls. This section will use it to demonstrate what is happening at the Application, Transport, Network, and Data Link layers.</p>








<section data-type="sect2" data-pdf-bookmark="Application"><div class="sect2" id="idm46219957941368">
<h2>Application</h2>

<p>As mentioned, <a data-type="indexterm" data-primary="Application layer (L7)" data-secondary="of TCP/IP" data-secondary-sortas="TCP/IP" id="ch1_term6"/><a data-type="indexterm" data-primary="TCP/IP" data-secondary="Application layer of" id="ch1_term7"/>Application is the highest layer in the TCP/IP stack; it is where the user interacts with data before
it gets sent over the network. In our example walk-through, we are going to use Hypertext Transfer Protocol (HTTP) and a simple HTTP transaction to demonstrate what happens at each layer in the TCP/IP stack.</p>










<section data-type="sect3" data-pdf-bookmark="HTTP"><div class="sect3" id="idm46219957936696">
<h3>HTTP</h3>

<p>HTTP is <a data-type="indexterm" data-primary="HTML (Hypertext Markup Language) web page" id="idm46219957935000"/><a data-type="indexterm" data-primary="Hypertext Markup Language (HTML) web page" id="idm46219957934232"/>responsible for sending and receiving Hypertext Markup Language (HTML) documents—you know, a web page. A <a data-type="indexterm" data-primary="Golang (Go) web server" data-secondary="HTTP request to" id="ch1_term8"/><a data-type="indexterm" data-primary="HTTP" data-secondary="examples of requests with" id="ch1_term9"/><a data-type="indexterm" data-primary="client requests" data-secondary="with HTTP" data-secondary-sortas="HTTP" id="ch1_term19"/>vast majority of what we see and do on the internet is over HTTP: Amazon purchases, Reddit posts, and tweets all use HTTP. A client will make an HTTP request to our minimal Golang web server from <a data-type="xref" href="#minmal_web_server_in_go">Example 1-1</a>, and it will send an HTTP response with “Hello” text. The web server runs locally in an Ubuntu virtual machine to test the full TCP/IP stack.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>See the example code <a href="https://oreil.ly/Jan5M">repository</a> for full instructions.</p>
</div>
<div id="minmal_web_server_in_go" data-type="example">
<h5><span class="label">Example 1-1. </span>Minimal web server in Go</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>

<code class="kn">import</code> <code class="p">(</code>
	<code class="s">"fmt"</code>
	<code class="s">"net/http"</code>
<code class="p">)</code>

<code class="kd">func</code> <code class="nx">hello</code><code class="p">(</code><code class="nx">w</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code> <code class="nx">_</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">{</code>
	<code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprintf</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code> <code class="s">"Hello"</code><code class="p">)</code>
<code class="p">}</code>

<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>
	<code class="nx">http</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code> <code class="nx">hello</code><code class="p">)</code>
	<code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">"0.0.0.0:8080"</code><code class="p">,</code> <code class="kc">nil</code><code class="p">)</code>
<code class="p">}</code></pre></div>

<p>In our Ubuntu virtual machine we need to start our minimal web server, or if you have Golang installed locally, you can just run this:</p>

<pre data-type="programlisting" data-code-language="bash">go run web-server.go</pre>

<p>Let’s break down the request for each layer of the TPC/IP stack.</p>

<p>cURL is the <a data-type="indexterm" data-primary="cURL/curl tool" data-secondary="client requests with" id="idm46219955272104"/>requesting client for our HTTP request example. Generally, for a web page, the client would be a web browser,
but we’re using cURL to simplify and show the command line.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a href="https://curl.haxx.se">cURL</a> is meant for uploading and downloading data specified with a URL. It is a client-side program (the <em>c</em>) to
request data from a URL and return the response.</p>
</div>

<p>In <a data-type="xref" href="#client_request">Example 1-2</a>, we can see each <a data-type="indexterm" data-primary="Accept header, HTTP request" id="ch1_term10"/><a data-type="indexterm" data-primary="Content-Length header, HTTP request" id="ch1_term11"/><a data-type="indexterm" data-primary="Content-Type header, HTTP request" id="ch1_term12"/><a data-type="indexterm" data-primary="Date header, HTTP request" id="ch1_term13"/><a data-type="indexterm" data-primary="Get HTTP command" id="ch1_term14"/><a data-type="indexterm" data-primary="Host, HTTP header of" id="ch1_term16"/><a data-type="indexterm" data-primary="HTTP GET command" id="ch1_term17"/><a data-type="indexterm" data-primary="User-Agent, HTTP request" id="ch1_term18"/>part of the HTTP request that the cURL client is making and the response. Let’s review
what all those options and outputs are.</p>
<div id="client_request" data-type="example">
<h5><span class="label">Example 1-2. </span>Client request</h5>

<pre data-type="programlisting" data-code-language="bash"><code>○</code><code> </code><code>→</code><code> </code><code>curl</code><code> </code><code>localhost:8080</code><code> </code><code>-vvv</code><code> </code><a class="co" id="co_networking_introduction_CO1-1" href="#callout_networking_introduction_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>
</code><code>*</code><code>   </code><code>Trying</code><code> </code><code>::1...</code><code>
</code><code>*</code><code> </code><code>TCP_NODELAY</code><code> </code><code class="nb">set</code><code>
</code><code>*</code><code> </code><code>Connected</code><code> </code><code>to</code><code> </code><code>localhost</code><code> </code><code class="o">(</code><code>::1</code><code class="o">)</code><code> </code><code>port</code><code> </code><code class="m">8080</code><code> </code><a class="co" id="co_networking_introduction_CO1-2" href="#callout_networking_introduction_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>
</code><code>&gt;</code><code> </code><code>GET</code><code> </code><code>/</code><code> </code><code>HTTP/1.1</code><code> </code><a class="co" id="co_networking_introduction_CO1-3" href="#callout_networking_introduction_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>
</code><code>&gt;</code><code> </code><code>Host:</code><code> </code><code>localhost:8080</code><code> </code><a class="co" id="co_networking_introduction_CO1-4" href="#callout_networking_introduction_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>
</code><code>&gt;</code><code> </code><code>User-Agent:</code><code> </code><code>curl/7.64.1</code><code> </code><a class="co" id="co_networking_introduction_CO1-5" href="#callout_networking_introduction_CO1-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>
</code><code>&gt;</code><code> </code><code>Accept:</code><code> </code><code>*/*</code><code> </code><a class="co" id="co_networking_introduction_CO1-6" href="#callout_networking_introduction_CO1-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a><code>
</code><code>&gt;</code><code>
</code><code>&lt;</code><code> </code><code>HTTP/1.1</code><code> </code><code class="m">200</code><code> </code><code>OK</code><code> </code><a class="co" id="co_networking_introduction_CO1-7" href="#callout_networking_introduction_CO1-7"><img src="Images/7.png" alt="7" width="12" height="12"/></a><code>
</code><code>&lt;</code><code> </code><code>Date:</code><code> </code><code>Sat,</code><code> </code><code class="m">25</code><code> </code><code>Jul</code><code> </code><code class="m">2020</code><code> </code><code>14:57:46</code><code> </code><code>GMT</code><code> </code><a class="co" id="co_networking_introduction_CO1-8" href="#callout_networking_introduction_CO1-8"><img src="Images/8.png" alt="8" width="12" height="12"/></a><code>
</code><code>&lt;</code><code> </code><code>Content-Length:</code><code> </code><code class="m">5</code><code> </code><a class="co" id="co_networking_introduction_CO1-9" href="#callout_networking_introduction_CO1-9"><img src="Images/9.png" alt="9" width="12" height="12"/></a><code>
</code><code>&lt;</code><code> </code><code>Content-Type:</code><code> </code><code>text/plain</code><code class="p">;</code><code> </code><code class="nv">charset</code><code class="o">=</code><code>utf-8</code><code> </code><a class="co" id="co_networking_introduction_CO1-10" href="#callout_networking_introduction_CO1-10"><img src="Images/10.png" alt="10" width="12" height="12"/></a><code>
</code><code>&lt;</code><code>
</code><code>*</code><code> </code><code>Connection</code><code> </code><code class="c">#0 to host localhost left intact
</code><code>Hello*</code><code> </code><code>Closing</code><code> </code><code>connection</code><code> </code><code class="m">0</code><code> </code><a class="co" id="co_networking_introduction_CO1-11" href="#callout_networking_introduction_CO1-11"><img src="Images/11.png" alt="11" width="12" height="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_networking_introduction_CO1-1" href="#co_networking_introduction_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p><code>curl</code> <code>localhost:8080</code> <code>-vvv</code>: This is <a data-type="indexterm" data-primary="cURL/curl tool" data-secondary="localhost command with" id="idm46219954647000"/>the <code>curl</code> command that opens a connection to the locally running web server, <code>localhost</code> on TCP port 8080. <code>-vvv</code> sets the verbosity of the output so we can see everything happening with the request. Also, <code>TCP_NODELAY</code> instructs the TCP connection to send the data without delay, one of many options available to the client to set.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-2" href="#co_networking_introduction_CO1-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p><code>Connected</code> <code>to</code> <code>localhost</code> <code>(::1)</code> <code>port</code> <code>8080</code>: It worked! cURL connected to the web server on localhost and over port 8080.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-3" href="#co_networking_introduction_CO1-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p><code>Get</code> <code>/</code> <code>HTTP/1.1</code>: HTTP has several methods for retrieving or updating information. In our request, we are
performing an HTTP GET to retrieve our “Hello” response. The forward slash is the next part, a Uniform Resource
Locator (URL), which indicates where we are sending the client request to the server. The last section of this header
is the version of HTTP the server is using, 1.1.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-4" href="#co_networking_introduction_CO1-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p><code>Host:</code> <code>localhost:8080</code>: HTTP has several options for sending information about the request. In our request, the cURL
process has <a data-type="indexterm" data-primary="HTTP" data-secondary="header contents" id="idm46219954589288"/>set the HTTP Host header. The client and server can transmit information with an HTTP
request or response. An HTTP header contains its name followed by a colon (:) and then its value.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-5" href="#co_networking_introduction_CO1-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p><code>User-Agent: cURL/7.64.1</code>: The user agent is a string that indicates the computer program making the HTTP request
on behalf of the end user; it is cURL in our context. This string often identifies the browser, its version number,
and its host operating system.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-6" href="#co_networking_introduction_CO1-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p><code>Accept:</code> <code>*/*</code>:  This header instructs the web server what content types the client understands. <a data-type="xref" href="#common_content_types_for_http_data">Table 1-3</a> shows
examples of common content types that can be sent.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-7" href="#co_networking_introduction_CO1-7"><img src="Images/7.png" alt="7" width="12" height="12"/></a></dt>
<dd><p><code>HTTP/1.1</code> <code>200</code> <code>OK</code>: This is the <a data-type="indexterm" data-primary="server responses" data-secondary="to HTTP requests" data-secondary-sortas="HTTP requests" id="idm46219954577592"/><a data-type="indexterm" data-primary="server responses" data-secondary="status codes" id="idm46219954576312"/>server response to our request. The server responds with the HTTP version and the
response status code. There are several possible responses from the server. A status code of 200 indicates the
response was successful. 1XX means informational, 2XX means successful, 3XX means redirects, 4XX responses indicate there are issues with
the requests, and 5XX generally refers to issues from the server.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-8" href="#co_networking_introduction_CO1-8"><img src="Images/8.png" alt="8" width="12" height="12"/></a></dt>
<dd><p><code>Date: Sat, July 25, 2020, 14:57:46 GMT</code>:  The <code>Date</code> header field represents the date and time at which the message
originated.  The sender generates the value as the approximate date and time of message generation.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-9" href="#co_networking_introduction_CO1-9"><img src="Images/9.png" alt="9" width="12" height="12"/></a></dt>
<dd><p><code>Content-Length: 5</code>: The <code>Content-Length</code> header indicates the size of the message body, in bytes, sent to the
recipient; in our case, the message is 5 bytes.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-10" href="#co_networking_introduction_CO1-10"><img src="Images/10.png" alt="10" width="12" height="12"/></a></dt>
<dd><p><code>Content-Type: text/plain; charset=utf-8</code>: The <code>Content-Type</code> entity header is used to indicate the resource’s media
type. Our response is indicating that it is returning a plain-text file that is UTF-8 encoded.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO1-11" href="#co_networking_introduction_CO1-11"><img src="Images/11.png" alt="11" width="12" height="12"/></a></dt>
<dd><p><code>Hello* Closing connection 0</code>: This prints out the response from our web server and closes out the HTTP <a data-type="indexterm" data-startref="ch1_term10" id="idm46219954561736"/><a data-type="indexterm" data-startref="ch1_term11" id="idm46219954561032"/><a data-type="indexterm" data-startref="ch1_term12" id="idm46219954560360"/><a data-type="indexterm" data-startref="ch1_term13" id="idm46219954559688"/><a data-type="indexterm" data-startref="ch1_term14" id="idm46219954559016"/><a data-type="indexterm" data-startref="ch1_term16" id="idm46219954558344"/><a data-type="indexterm" data-startref="ch1_term17" id="idm46219954557672"/><a data-type="indexterm" data-startref="ch1_term18" id="idm46219954557000"/>connection.</p></dd>
</dl>
<table id="common_content_types_for_http_data">
<caption><span class="label">Table 1-3. </span>Common content types for HTTP data</caption>
<thead>
<tr>
<th>Type</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>application</p></td>
<td><p>Any kind of binary data that doesn’t fall explicitly into one of the other types. Common examples
include application/json, application/pdf, application/pkcs8, and application/zip.</p></td>
</tr>
<tr>
<td><p>audio</p></td>
<td><p>Audio or music data. Examples include audio/mpeg and audio/vorbis.</p></td>
</tr>
<tr>
<td><p>font</p></td>
<td><p>Font/typeface data. Common examples include font/woff, font/ttf, and font/otf.</p></td>
</tr>
<tr>
<td><p>image</p></td>
<td><p>Image or graphical data including both bitmap and vector such as animated GIF or APNG. Common examples are
image/jpg, image/png, and image/svg+xml.</p></td>
</tr>
<tr>
<td><p>model</p></td>
<td><p>Model data for a 3D object or scene. Examples include model/3mf and model/vrml.</p></td>
</tr>
<tr>
<td><p>text</p></td>
<td><p>Text-only data including human-readable content, source code, or text data. Examples include text/plain, text/csv,
and text/html.</p></td>
</tr>
<tr>
<td><p>video</p></td>
<td><p>Video data or files, such as video/mp4.</p></td>
</tr>
</tbody>
</table>

<p>This is a <a data-type="indexterm" data-primary="HTTP" data-secondary="data content types of" id="idm46219954541560"/><a data-type="indexterm" data-primary="data" data-secondary="HTTP content types of" id="idm46219954540552"/>simplistic view that happens with every HTTP request. Today, a single web page makes an exorbitant number of requests with one load of a page, and in just a matter of seconds! This is a brief example for cluster administrators of how HTTP (and for that matter, the other seven  layers’ applications) operate. We will continue to build our
knowledge of how this request is completed at each layer of the TCP/IP stack and then how Kubernetes completes those
same requests. All this data is formatted and options are set at layer 7, but the real <a data-type="indexterm" data-startref="ch1_term6" id="idm46219954538920"/><a data-type="indexterm" data-startref="ch1_term7" id="idm46219954538248"/><a data-type="indexterm" data-startref="ch1_term8" id="idm46219954537576"/><a data-type="indexterm" data-startref="ch1_term9" id="idm46219954536904"/><a data-type="indexterm" data-startref="ch1_term19" id="idm46219954536232"/>heavy lifting is done at the
lower layers of the TCP/IP stack, which we will go over in the next sections.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Transport"><div class="sect2" id="idm46219954535176">
<h2>Transport</h2>

<p>The Transport <a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" id="ch1_term22"/>layer protocols are responsible for connection-oriented communication, reliability, flow control,
and multiplexing; this is mostly true of TCP. We’ll describe the differences in the following sections. Our Golang
web server is a layer 7 application using HTTP; the Transport layer that HTTP relies on is TCP.</p>










<section data-type="sect3" data-pdf-bookmark="TCP"><div class="sect3" id="idm46219954532040">
<h3>TCP</h3>

<p>As already mentioned, TCP is a connection-oriented, reliable protocol, and it provides flow control and multiplexing.
TCP is considered connection-oriented because it manages the connection state through the life cycle of the connection. In TCP, the window size manages flow control, unlike UDP, which does not manage the congestion flow. In addition, UDP is unreliable, and data may arrive out of sequence. Each <a data-type="indexterm" data-primary="TCP (Transmission Control Protocol)" data-secondary="segment headers of" id="ch1_term20"/><a data-type="indexterm" data-primary="headers" data-secondary="for TCP" data-secondary-sortas="TCP" id="ch1_term70"/><a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="TCP segment header for" id="ch1_term21"/><a data-type="indexterm" data-primary="segment headers, TCP" id="ch1_term23"/>port identifies the host process responsible for processing the information from the network communication. TCP is <a data-type="indexterm" data-primary="data" data-secondary="host-to-host transfer of" id="idm46219954524552"/><a data-type="indexterm" data-primary="host-to-host data transfers" id="idm46219954523592"/>known as a host-to-host layer protocol. To identify the process on the host responsible for the connection, TCP identifies the segments with a 16-bit port
number. HTTP <a data-type="indexterm" data-primary="ports" data-secondary="HTTP 80 and 443" id="idm46219954522584"/><a data-type="indexterm" data-primary="port 80" id="idm46219954521640"/><a data-type="indexterm" data-primary="security" data-secondary="TLS for" id="idm46219954520968"/><a data-type="indexterm" data-primary="TLS (Transport Layer Security)" id="idm46219954520024"/>servers use the well-known port of 80 for nonsecure communication and 443 for secure communication using Transport Layer Security (TLS). Clients requesting a new <a data-type="indexterm" data-primary="source port identification" id="idm46219954519032"/>connection create a source port local in the range of 0–65534.</p>

<p>To understand how <a data-type="indexterm" data-primary="HTML (Hypertext Markup Language) web page" id="ch1_term24"/><a data-type="indexterm" data-primary="Hypertext Markup Language (HTML) web page" id="ch1_term25"/><a data-type="indexterm" data-primary="TCP (Transmission Control Protocol)" data-secondary="multiplexing of" id="ch1_term26"/>TCP performs multiplexing, let’s review a simple HTML page retrieval:</p>
<ol>
<li>
<p>In a web browser, type in a web page address.</p>
</li>
<li>
<p>The browser opens a connection to transfer the page.</p>
</li>
<li>
<p>The browser opens connections for each image on the page.</p>
</li>
<li>
<p>The browser opens another connection for the external CSS.</p>
</li>
<li>
<p>Each of these connections uses a different set of virtual ports.</p>
</li>
<li>
<p>All the page’s assets download simultaneously.</p>
</li>
<li>
<p>The browser reconstructs the page.</p>
</li>

</ol>

<p>Let’s walk through how TCP manages multiplexing with the information provided in the TCP segment headers:</p>
<dl>
<dt><code>Source port</code> (16 bits)</dt>
<dd>
<p>This identifies the sending port.</p>
</dd>
<dt><code>Destination port</code> (16 bits)</dt>
<dd>
<p>This identifies <a data-type="indexterm" data-primary="destination port identification" id="idm46219954504040"/>the receiving port.</p>
</dd>
<dt><code>Sequence number</code> (32 bits)</dt>
<dd>
<p>If the SYN flag is <a data-type="indexterm" data-primary="sequence number, TCP" id="idm46219954501512"/>set, this is the initial sequence number. The sequence number of the
first data byte and the acknowledged number in the corresponding ACK is this sequence number plus 1. It is
also used to reassemble data if it arrives out of order.</p>
</dd>
</dl>
<dl class="less_space pagebreak-before">
<dt><code>Acknowledgment number</code> (32 bits)</dt>
<dd>
<p>If the ACK <a data-type="indexterm" data-primary="acknowledgment number, TCP" id="idm46219954497832"/>flag is set, then this field’s value is the next sequence number
of the ACK the sender is expecting. This acknowledges receipt of all preceding bytes (if any). Each end’s first ACK
acknowledges the other end’s initial sequence number itself, but no data has been sent.</p>
</dd>
<dt><code>Data offset</code> (4 bits)</dt>
<dd>
<p>This specifies <a data-type="indexterm" data-primary="data offset, TCP" id="idm46219954495096"/>the size of the TCP header in 32-bit words.</p>
</dd>
<dt><code>Reserved</code> (3 bits)</dt>
<dd>
<p>This is for <a data-type="indexterm" data-primary="reserved setting, TCP" id="idm46219954492664"/>future use and should be set to zero.</p>
</dd>
<dt><code>Flags</code> (9 bits)</dt>
<dd>
<div class="openblock">
<p>There are <a data-type="indexterm" data-primary="flags" data-secondary="in TCP header" data-secondary-sortas="TCP header" id="idm46219954489640"/>nine 1-bit fields defined for the TCP header:</p>

<ul>
<li>
<p>NS–ECN-nonce: Concealment protection.</p>
</li>
<li>
<p>CWR: Congestion Window Reduced; the sender reduced its sending rate.</p>
</li>
<li>
<p>ECE: ECN Echo; the sender received an earlier congestion notification.</p>
</li>
<li>
<p>URG: Urgent; the Urgent Pointer field is valid, but this is rarely used.</p>
</li>
<li>
<p>ACK: Acknowledgment; the <a data-type="indexterm" data-primary="ACK flag, TCP" id="idm46219954483480"/>Acknowledgment Number field is valid and is always on after a connection is established.</p>
</li>
<li>
<p>PSH: Push; the receiver should pass this data to the application as soon as possible.</p>
</li>
<li>
<p>RST: Reset the connection or connection abort, usually because of an error.</p>
</li>
<li>
<p>SYN: Synchronize sequence numbers to initiate a connection.</p>
</li>
<li>
<p>FIN: The sender of the segment is finished sending data to its peer.</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The NS bit field is <a data-type="indexterm" data-primary="ECN (Robust Explicit Congestion Notification) Signaling with Nonces" id="idm46219954477976"/><a data-type="indexterm" data-primary="Robust Explicit Congestion Notification (ECN) Signaling with Nonces" id="idm46219954477272"/>further explained in RFC 3540, “Robust Explicit Congestion Notification (ECN)
Signaling with Nonces.” This specification describes an optional addition to ECN
improving robustness against malicious or accidental concealment of marked packets.</p>
</div>
</div>

</dd>
<dt><code>Window size</code> (16 bits)</dt>
<dd>
<p>This is the <a data-type="indexterm" data-primary="window size, TCP" id="idm46219954474424"/>size of the receive window.</p>
</dd>
<dt><code>Checksum</code> (16 bits)</dt>
<dd>
<p>The checksum <a data-type="indexterm" data-primary="checksum" id="idm46219954471992"/>field is used for error checking of the TCP header.</p>
</dd>
</dl>
<dl class="less_space pagebreak-before">
<dt><code>Urgent pointer</code> (16 bits)</dt>
<dd>
<p>This is an <a data-type="indexterm" data-primary="urgent pointer, TCP" id="idm46219954469016"/>offset from the sequence number indicating the last urgent data byte.</p>
</dd>
<dt><code>Options</code></dt>
<dd>
<p>Variable 0–320 bits, <a data-type="indexterm" data-primary="options" data-secondary="TCP header field" id="idm46219954466744"/>in units of 32 bits.</p>
</dd>
<dt><code>Padding</code></dt>
<dd>
<p>The TCP header <a data-type="indexterm" data-primary="padding, TCP" id="idm46219954464168"/>padding is used to ensure that the TCP header ends, and data begins on a 32-bit boundary.</p>
</dd>
<dt><code>Data</code></dt>
<dd>
<p>This is the <a data-type="indexterm" data-primary="data" data-secondary="TCP header field" id="idm46219954461784"/><a data-type="indexterm" data-primary="data flow of TCP/IP" id="idm46219954460776"/>piece of application data being sent in this segment.</p>
</dd>
</dl>

<p>In <a data-type="xref" href="#img-tcp-data">Figure 1-4</a>, we can see all the TCP segment headers that provide metadata about the TCP streams.</p>

<figure><div id="img-tcp-data" class="figure">
<img src="Images/neku_0104.png" alt="TCP Segment Header" width="866" height="827"/>
<h6><span class="label">Figure 1-4. </span>TCP segment header</h6>
</div></figure>

<p>These fields help manage the flow of <a data-type="indexterm" data-primary="TCP/IP" data-secondary="overview of network topology of" id="idm46219954456216"/>data between two systems. <a data-type="xref" href="#img-osi-model">Figure 1-5</a> shows how each step of the
TCP/IP stack sends data from one application on one host, through a network communicating at layers 1 and 2, to get data
to the destination host.</p>

<figure><div id="img-osi-model" class="figure">
<img src="Images/neku_0105.png" alt="neku 0105" width="1008" height="1150"/>
<h6><span class="label">Figure 1-5. </span>tcp/ip data flow</h6>
</div></figure>

<p>In the next <a data-type="indexterm" data-startref="ch1_term20" id="idm46219954451672"/><a data-type="indexterm" data-startref="ch1_term21" id="idm46219954450936"/><a data-type="indexterm" data-startref="ch1_term23" id="idm46219954450264"/><a data-type="indexterm" data-startref="ch1_term24" id="idm46219954449592"/><a data-type="indexterm" data-startref="ch1_term25" id="idm46219954448920"/><a data-type="indexterm" data-startref="ch1_term26" id="idm46219954448248"/><a data-type="indexterm" data-startref="ch1_term70" id="idm46219954447576"/>section, we will show how TCP uses these fields to initiate a connection through the three-way handshake.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="TCP handshake"><div class="sect3" id="idm46219954531512">
<h3>TCP handshake</h3>

<p>TCP uses a <a data-type="indexterm" data-primary="client requests" data-secondary="with TCP handshake" data-secondary-sortas="TCP handshake" id="ch1_term27"/><a data-type="indexterm" data-primary="server responses" data-secondary="with TCP handshake" data-secondary-sortas="TCP handshake" id="ch1_term28"/><a data-type="indexterm" data-primary="TCP (Transmission Control Protocol)" data-secondary="handshakes" id="ch1_term29"/><a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="TCP handshake of" id="ch1_term30"/>three-way handshake, pictured in <a data-type="xref" href="#three-way-tcp">Figure 1-6</a>, to create a connection by exchanging information
along the way with various options and flags:</p>
<ol>
<li>
<p>The requesting node sends a connection request via a SYN packet to get the transmission started.</p>
</li>
<li>
<p>If the receiving node is listening on the port the sender requests, the receiving node replies with a SYN-ACK,
acknowledging that it has heard the requesting node.</p>
</li>
<li>
<p>The requesting node <a data-type="indexterm" data-primary="ACK flag, TCP" id="idm46219954435448"/>returns an ACK packet, exchanging information and letting them know the nodes are good to send each
other information.</p>
</li>

</ol>

<figure><div id="three-way-tcp" class="figure">
<img src="Images/neku_0106.png" alt="OSI Model" width="634" height="257"/>
<h6><span class="label">Figure 1-6. </span>TCP three-way handshake</h6>
</div></figure>

<p>Now the connection is established. Data can be transmitted over the physical medium, routed between networks, to find its
way to the local destination—but how does the endpoint know how to handle the information? On the <a data-type="indexterm" data-primary="sockets" data-secondary="defined" id="idm46219954431576"/>local and remote
hosts, a socket gets created to track this connection. A socket is just a logical endpoint for communication.  In
<a data-type="xref" href="ch02.xhtml#linux_networking">Chapter 2</a>, we will discuss how a Linux client and server handle sockets.</p>

<p>TCP is a stateful protocol, <a data-type="indexterm" data-primary="TCP (Transmission Control Protocol)" data-secondary="connection states of" id="ch1_term31"/>tracking the connection’s state throughout its life cycle. The state of the
connection depends on both the sender and the receiver agreeing where they are in the connection flow. The connection
state is concerned about who is sending and receiving data in the TCP stream. TCP has a complex state
transition for explaining when and where the connection is, using the 9-bit TCP flags in the TCP segment header, as
you can see in <a data-type="xref" href="#tcp-state">Figure 1-7</a>.</p>

<p>The TCP connection states are:</p>
<dl>
<dt><code>LISTEN</code> (server)</dt>
<dd>
<p>Represents waiting for a connection request from any remote TCP and port</p>
</dd>
<dt><code>SYN-SENT</code> (client)</dt>
<dd>
<p>Represents waiting for a matching connection request after sending a connection request</p>
</dd>
<dt><code>SYN-RECEIVED</code> (server)</dt>
<dd>
<p>Represents waiting for a confirming connection request acknowledgment after having both
received and sent a connection request</p>
</dd>
<dt><code>ESTABLISHED</code> (both server and client)</dt>
<dd>
<p>Represents an open connection; data received can be delivered to the user—the
intermediate state for the data transfer phase of the connection</p>
</dd>
<dt><code>FIN-WAIT-1</code> (both server and client)</dt>
<dd>
<p>Represents waiting for a connection termination request from the remote host</p>
</dd>
<dt><code>FIN-WAIT-2</code> (both server and client)</dt>
<dd>
<p>Represents waiting for a connection termination request from the remote TCP</p>
</dd>
<dt><code>CLOSE-WAIT</code> (both server and client)</dt>
<dd>
<p>Represents waiting for a local user’s connection termination request</p>
</dd>
<dt><code>CLOSING</code> (both server and client)</dt>
<dd>
<p>Represents waiting for a connection termination request acknowledgment from the
remote TCP</p>
</dd>
<dt><code>LAST-ACK</code> (both server and client)</dt>
<dd>
<p>Represents waiting for an acknowledgment of the connection termination request
previously sent to the remote host</p>
</dd>
<dt><code>TIME-WAIT</code> (either server or client)</dt>
<dd>
<p>Represents waiting for enough time to pass to ensure the remote host received
the acknowledgment of its connection termination request</p>
</dd>
<dt><code>CLOSED</code> (both server and client)</dt>
<dd>
<p>Represents no <a data-type="indexterm" data-primary="CLOSED connection state, TCP" id="idm46219954406728"/>connection state at all</p>
</dd>
</dl>

<figure><div id="tcp-state" class="figure">
<img src="Images/neku_0107.png" alt="TCP State Diagram" width="1194" height="1162"/>
<h6><span class="label">Figure 1-7. </span>TCP state transition diagram</h6>
</div></figure>

<p><a data-type="xref" href="#tcp_connection_states">Example 1-3</a> is a sample of a Mac’s TCP connections, their state, and the addresses for both ends of the connection.</p>
<div id="tcp_connection_states" data-type="example">
<h5><span class="label">Example 1-3. </span>TCP connection states</h5>

<pre data-type="programlisting" data-code-language="bash">○ → netstat -ap TCP
Active internet connections <code class="o">(</code>including servers<code class="o">)</code>
Proto Recv-Q Send-Q  Local Address          Foreign Address        <code class="o">(</code>state<code class="o">)</code>
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.53606 g2600-1407-2800-.https ESTABLISHED
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.53603 g2600-1408-5c00-.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53602     ec2-3-22-64-157..https ESTABLISHED
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.53600 g2600-1408-5c00-.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53598     164.196.102.34.b.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53597     server-99-84-217.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53596     151.101.194.137.https  ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53587     ec2-52-27-83-248.https ESTABLISHED
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.53586 iad23s61-in-x04..https ESTABLISHED
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.53542 iad23s61-in-x04..https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53536     ec2-52-10-162-14.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53530     server-99-84-178.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53525     ec2-52-70-63-25..https ESTABLISHED
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.53480 upload-lb.eqiad..https ESTABLISHED
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.53477 text-lb.eqiad.wi.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53466     151.101.1.132.https    ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53420     ec2-52-0-84-183..https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53410     192.168.0.18.8060      CLOSE_WAIT
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.53408 2600:1901:1:c36:.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53067     ec2-52-40-198-7..https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53066     ec2-52-40-198-7..https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.53055     ec2-54-186-46-24.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  localhost.16587        localhost.53029        ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  localhost.53029        localhost.16587        ESTABLISHED
tcp46      <code class="m">0</code>      <code class="m">0</code>  *.16587                *.*                    LISTEN
tcp6      <code class="m">56</code>      <code class="m">0</code>  2607:fcc8:a205:c.56210 ord38s08-in-x0a..https CLOSE_WAIT
tcp6       <code class="m">0</code>      <code class="m">0</code>  2607:fcc8:a205:c.51699 2606:4700::6810:.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.64407     <code class="k">do</code>-77.lastpass.c.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.64396     ec2-54-70-97-159.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.60612     ac88393aca5853df.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.58193     47.224.186.35.bc.https ESTABLISHED
tcp4       <code class="m">0</code>      <code class="m">0</code>  localhost.63342        *.*                    LISTEN
tcp4       <code class="m">0</code>      <code class="m">0</code>  localhost.6942         *.*                    LISTEN
tcp4       <code class="m">0</code>      <code class="m">0</code>  192.168.0.17.55273     ec2-50-16-251-20.https ESTABLISHED</pre></div>

<p>Now that we know more about how TCP constructs and tracks <a data-type="indexterm" data-startref="ch1_term27" id="idm46219954383432"/><a data-type="indexterm" data-startref="ch1_term28" id="idm46219954382824"/><a data-type="indexterm" data-startref="ch1_term29" id="idm46219954331624"/><a data-type="indexterm" data-startref="ch1_term30" id="idm46219954330984"/><a data-type="indexterm" data-startref="ch1_term31" id="idm46219954330312"/>connections, let’s review the HTTP request for our
web server at the Transport layer using TCP. To accomplish this, we use a command-line tool called <code>tcpdump</code>.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="tcpdump"><div class="sect3" id="idm46219954446056">
<h3>tcpdump</h3>
<blockquote>
<p><code>tcpdump</code> prints out a description of the contents of packets on a network interface that matches the boolean expression.</p>
<p data-type="attribution">tcpdump man page</p>
</blockquote>

<p><code>tcpdump</code> allows administrators and users to display all the <a data-type="indexterm" data-primary="packets" data-secondary="tcpdump capture of" id="ch1_term32"/><a data-type="indexterm" data-primary="tcpdump tool" data-secondary="overview of packet capture with" id="ch1_term33"/><a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="tcpdump tool for" id="ch1_term34"/>packets processed on the system and filter them out
based on many TCP segment header details. In the request, we filter all packets with the destination port
8080 on the network interface labeled lo0; this is the local loopback interface on the Mac. Our web server is
running on 0.0.0.0:8080. <a data-type="xref" href="#img-curl">Figure 1-8</a> shows <a data-type="indexterm" data-primary="network interface card (NIC)" id="idm46219954320008"/><a data-type="indexterm" data-primary="NIC (network interface card)" data-secondary="and tcpdump packet capture" data-secondary-sortas="tcpdump packet capture" id="idm46219954319288"/>where <code>tcpdump</code> is collecting data in reference to the full TCP/IP stack,
between the network interface card (NIC) driver and layer 2.</p>

<figure><div id="img-curl" class="figure">
<img src="Images/neku_0108.png" alt="neku 0108" width="1443" height="516"/>
<h6><span class="label">Figure 1-8. </span><code>tcpdump</code> packet capture</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>A loopback <a data-type="indexterm" data-primary="loopback interface (lo)" id="idm46219954314200"/>interface is a logical, virtual interface on a device. A loopback interface is not a physical interface
like Ethernet interface. Loopback interfaces are always up and running and always available, even if other
interfaces are down on the host.</p>
</div>

<p>The general format of a <code>tcpdump</code> output will contain the following fields: <code>tos</code>,<code>TTL</code>, <code>id</code>, <code>offset</code>, <code>flags</code>, <code>proto</code>, <code>length</code>, and <code>options</code>. Let’s review these:</p>
<dl>
<dt><code>tos</code></dt>
<dd>
<p>The type <a data-type="indexterm" data-primary="tos field, tcpdump" id="idm46219954306392"/>of service field.</p>
</dd>
<dt><code>TTL</code></dt>
<dd>
<p>The time <a data-type="indexterm" data-primary="TTL field, tcpdump" id="idm46219954304088"/>to live; it is not reported if it is zero.</p>
</dd>
<dt><code>id</code></dt>
<dd>
<p>The IP <a data-type="indexterm" data-primary="id field, tcpdump" id="idm46219954301752"/>identification field.</p>
</dd>
<dt><code>offset</code></dt>
<dd>
<p>The fragment <a data-type="indexterm" data-primary="offset field, tcpdump" id="idm46219954299448"/>offset field; it is printed whether this is part of a fragmented datagram or not.</p>
</dd>
<dt><code>flags</code></dt>
<dd>
<p>The DF, <a data-type="indexterm" data-primary="flags" data-secondary="in tcpdump output" data-secondary-sortas="tcpdump output" id="idm46219954297176"/>Don’t Fragment, flag, which indicates that the packet cannot be fragmented for transmission. When unset, it indicates that the packet can be fragmented. The MF, More Fragments, flag indicates there are packets that contain more fragments and when unset, it indicates that no more fragments remain.</p>
</dd>
<dt><code>proto</code></dt>
<dd>
<p>The protocol <a data-type="indexterm" data-primary="proto field, tcpdump" id="idm46219954294040"/>ID field.</p>
</dd>
<dt><code>length</code></dt>
<dd>
<p>The total <a data-type="indexterm" data-primary="length field identifier" id="idm46219954291736"/>length field.</p>
</dd>
<dt><code>options</code></dt>
<dd>
<p>The IP <a data-type="indexterm" data-primary="options" data-secondary="tcpdump output" id="idm46219954289432"/>options.</p>
</dd>
</dl>

<p>Systems that <a data-type="indexterm" data-primary="checksum" id="idm46219954287688"/>support checksum offloading and IP, TCP, and UDP checksums are <a data-type="indexterm" data-primary="network interface card (NIC)" id="idm46219954286824"/><a data-type="indexterm" data-primary="NIC (network interface card)" data-secondary="and tcpdump packet capture" data-secondary-sortas="tcpdump packet capture" id="idm46219954286184"/>calculated on the NIC before being
transmitted on the wire. Since we are running a <code>tcpdump</code> packet capture before the NIC, errors like <code>cksum
0xfe34 (incorrect -&gt; 0xb4c1)</code> appear in the output of <a data-type="xref" href="#tcp_dump">Example 1-4</a>.</p>

<p>To produce the output for <a data-type="xref" href="#tcp_dump">Example 1-4</a>, open another terminal and start a <code>tcpdump</code> trace on the loopback for only TCP
and port 8080; otherwise, you will see a lot of other packets not relevant to our example. You’ll need to <a data-type="indexterm" data-primary="sudo packet" id="idm46219954281384"/>use
escalated privileges to trace packets, so that means using <code>sudo</code> in this case.</p>
<div id="tcp_dump" data-type="example">
<h5><span class="label">Example 1-4. </span><code>tcpdump</code></h5>

<pre data-type="programlisting" data-code-language="bash"><code>○</code><code> </code><code>→</code><code> </code><code>sudo</code><code> </code><code>tcpdump</code><code> </code><code>-i</code><code> </code><code>lo0</code><code> </code><code>tcp</code><code> </code><code>port</code><code> </code><code class="m">8080</code><code> </code><code>-vvv</code><code>  </code><a class="co" id="co_networking_introduction_CO2-1" href="#callout_networking_introduction_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a><code>

</code><code>tcpdump:</code><code> </code><code>listening</code><code> </code><code>on</code><code> </code><code>lo0,</code><code> </code><code>link-type</code><code> </code><code>NULL</code><code> </code><code class="o">(</code><code>BSD</code><code> </code><code>loopback</code><code class="o">)</code><code>,</code><code>
</code><code>capture</code><code> </code><code>size</code><code> </code><code class="m">262144</code><code> </code><code>bytes</code><code>  </code><a class="co" id="co_networking_introduction_CO2-2" href="#callout_networking_introduction_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a><code>

</code><code>08:13:55.009899</code><code> </code><code>localhost.50399</code><code> </code><code>&gt;</code><code> </code><code>localhost.http-alt:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>S</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0034</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1bd9</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>2784345138,</code><code>
</code><code>win</code><code> </code><code>65535,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>mss</code><code> </code><code>16324,nop,wscale</code><code> </code><code>6,nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>0,</code><code>
</code><code>sackOK,eol</code><code class="o">]</code><code>,</code><code> </code><code>length</code><code> </code><code class="m">0</code><code> </code><a class="co" id="co_networking_introduction_CO2-3" href="#callout_networking_introduction_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a><code>

</code><code>08:13:55.009997</code><code> </code><code>localhost.http-alt</code><code> </code><code>&gt;</code><code> </code><code>localhost.50399:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>S.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0034</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0xbe5a</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>195606347,</code><code>
</code><code>ack</code><code> </code><code>2784345139,</code><code> </code><code>win</code><code> </code><code>65535,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>mss</code><code> </code><code>16324,nop,wscale</code><code> </code><code>6,nop,nop,</code><code>
</code><code>TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215,sackOK,eol</code><code class="o">]</code><code>,</code><code> </code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-4" href="#callout_networking_introduction_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a><code>

</code><code>08:13:55.010012</code><code> </code><code>localhost.50399</code><code> </code><code>&gt;</code><code> </code><code>localhost.http-alt:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0028</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1f58</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>1,</code><code> </code><code>ack</code><code> </code><code>1,</code><code>
</code><code>win</code><code> </code><code>6371,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-5" href="#callout_networking_introduction_CO2-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a><code>

</code><code>v</code><code> </code><code>08:13:55.010021</code><code> </code><code>localhost.http-alt</code><code> </code><code>&gt;</code><code> </code><code>localhost.50399:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0028</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1f58</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>1,</code><code> </code><code>ack</code><code>
</code><code>1,</code><code> </code><code>win</code><code> </code><code>6371,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-6" href="#callout_networking_introduction_CO2-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a><code>

</code><code>08:13:55.010079</code><code> </code><code>localhost.50399</code><code> </code><code>&gt;</code><code> </code><code>localhost.http-alt:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>P.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0076</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x78b2</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>1:79,</code><code>
</code><code>ack</code><code> </code><code>1,</code><code> </code><code>win</code><code> </code><code>6371,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code>78:</code><code> </code><code>HTTP,</code><code> </code><code>length:</code><code> </code><code class="m">78</code><code>  </code><a class="co" id="co_networking_introduction_CO2-7" href="#callout_networking_introduction_CO2-7"><img src="Images/7.png" alt="7" width="12" height="12"/></a><code>
</code><code>GET</code><code> </code><code>/</code><code> </code><code>HTTP/1.1</code><code>
</code><code>Host:</code><code> </code><code>localhost:8080</code><code>
</code><code>User-Agent:</code><code> </code><code>curl/7.64.1</code><code>
</code><code>Accept:</code><code> </code><code>*/*</code><code>
</code><code>08:13:55.010102</code><code> </code><code>localhost.http-alt</code><code> </code><code>&gt;</code><code> </code><code>localhost.50399:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0028</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1f0b</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>1,</code><code>
</code><code>ack</code><code> </code><code>79,</code><code> </code><code>win</code><code> </code><code>6370,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-8" href="#callout_networking_introduction_CO2-8"><img src="Images/8.png" alt="8" width="12" height="12"/></a><code>

</code><code>08:13:55.010198</code><code> </code><code>localhost.http-alt</code><code> </code><code>&gt;</code><code> </code><code>localhost.50399:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>P.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x00a1</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x05d7</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>1:122,</code><code>
</code><code>ack</code><code> </code><code>79,</code><code> </code><code>win</code><code> </code><code>6370,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code>121:</code><code> </code><code>HTTP,</code><code> </code><code>length:</code><code> </code><code class="m">121</code><code>  </code><a class="co" id="co_networking_introduction_CO2-9" href="#callout_networking_introduction_CO2-9"><img src="Images/9.png" alt="9" width="12" height="12"/></a><code>
</code><code>HTTP/1.1</code><code> </code><code class="m">200</code><code> </code><code>OK</code><code>
</code><code>Date:</code><code> </code><code>Wed,</code><code> </code><code class="m">19</code><code> </code><code>Aug</code><code> </code><code class="m">2020</code><code> </code><code>12:13:55</code><code> </code><code>GMT</code><code>
</code><code>Content-Length:</code><code> </code><code>5</code><code>
</code><code>Content-Type:</code><code> </code><code>text/plain</code><code class="p">;</code><code> </code><code class="nv">charset</code><code class="o">=</code><code>utf-8</code><code>
</code><code>Hello</code><code class="o">[</code><code>!http</code><code class="o">]</code><code>

</code><code>08:13:55.010219</code><code> </code><code>localhost.50399</code><code> </code><code>&gt;</code><code> </code><code>localhost.http-alt:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>.</code><code class="o">]</code><code>,</code><code> </code><code>cksum</code><code> </code><code>0x0028</code><code>
</code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1e93</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>79,</code><code>
</code><code>ack</code><code> </code><code>122,</code><code> </code><code>win</code><code> </code><code>6369,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code> </code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-10" href="#callout_networking_introduction_CO2-10"><img src="Images/10.png" alt="10" width="12" height="12"/></a><code>

</code><code>08:13:55.010324</code><code> </code><code>localhost.50399</code><code> </code><code>&gt;</code><code> </code><code>localhost.http-alt:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>F.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0028</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1e92</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>79,</code><code>
</code><code>ack</code><code> </code><code>122,</code><code> </code><code>win</code><code> </code><code>6369,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-11" href="#callout_networking_introduction_CO2-11"><img src="Images/11.png" alt="11" width="12" height="12"/></a><code>

</code><code>08:13:55.010343</code><code> </code><code>localhost.http-alt</code><code> </code><code>&gt;</code><code> </code><code>localhost.50399:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0028</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1e91</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>122,</code><code>
</code><code class="se">\a</code><code>ck</code><code> </code><code>80,</code><code> </code><code>win</code><code> </code><code>6370,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-12" href="#callout_networking_introduction_CO2-12"><img src="Images/12.png" alt="12" width="12" height="12"/></a><code>

</code><code>08:13:55.010379</code><code> </code><code>localhost.http-alt</code><code> </code><code>&gt;</code><code> </code><code>localhost.50399:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>F.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0028</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1e90</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>122,</code><code>
</code><code>ack</code><code> </code><code>80,</code><code> </code><code>win</code><code> </code><code>6370,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-13" href="#callout_networking_introduction_CO2-13"><img src="Images/13.png" alt="13" width="12" height="12"/></a><code>

</code><code>08:13:55.010403</code><code> </code><code>localhost.50399</code><code> </code><code>&gt;</code><code> </code><code>localhost.http-alt:</code><code> </code><code>Flags</code><code> </code><code class="o">[</code><code>.</code><code class="o">]</code><code>,</code><code>
</code><code>cksum</code><code> </code><code>0x0028</code><code> </code><code class="o">(</code><code>incorrect</code><code> </code><code>-&gt;</code><code> </code><code>0x1e91</code><code class="o">)</code><code>,</code><code> </code><code>seq</code><code> </code><code>80,</code><code> </code><code>ack</code><code>
</code><code>123,</code><code> </code><code>win</code><code> </code><code>6369,</code><code> </code><code>options</code><code> </code><code class="o">[</code><code>nop,nop,TS</code><code> </code><code>val</code><code> </code><code class="m">587364215</code><code> </code><code>ecr</code><code> </code><code>587364215</code><code class="o">]</code><code>,</code><code>
</code><code>length</code><code> </code><code class="m">0</code><code>  </code><a class="co" id="co_networking_introduction_CO2-14" href="#callout_networking_introduction_CO2-14"><img src="Images/14.png" alt="14" width="12" height="12"/></a><code>

 </code><code class="m">12</code><code> </code><code>packets</code><code> </code><code>captured,</code><code> </code><code class="m">12062</code><code> </code><code>packets</code><code> </code><code>received</code><code> </code><code>by</code><code> </code><code>filter</code><code>
 </code><code class="m">0</code><code> </code><code>packets</code><code> </code><code>dropped</code><code> </code><code>by</code><code> </code><code>kernel.</code><code>  </code><a class="co" id="co_networking_introduction_CO2-15" href="#callout_networking_introduction_CO2-15"><img src="Images/15.png" alt="15" width="12" height="12"/></a></pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_networking_introduction_CO2-1" href="#co_networking_introduction_CO2-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>This is the start of the <code>tcpdump</code> collection with its command and all of its options. The <code>sudo</code> <a data-type="indexterm" data-primary="sudo packet" id="idm46219953649160"/>packet captures the required
escalated privileges. <code>tcpdump</code> is the <code>tcpdump</code> binary. <code>-i lo0</code> is the interface from which we want to capture
packets. <code>dst port 8080</code> is the matching expression that the man page discussed; here we are matching on
all packets destined for TCP port 8080, which is the port the web service is listening to for requests. <code>-v</code> is the verbose
option, which allows us to see more details from the <code>tcpdump</code> capture.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-2" href="#co_networking_introduction_CO2-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>Feedback from <code>tcpdump</code> letting us know about the <code>tcpdump</code> filter running.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-3" href="#co_networking_introduction_CO2-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>This is the first packet in the TCP handshake. We can tell it’s the SYN because the flags bit is set
with <code>[S]</code>, and the <a data-type="indexterm" data-primary="sequence number, TCP" id="idm46219953671496"/>sequence number is set to <code>2784345138</code> by cURL, with the localhost process number being <code>50399</code>.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-4" href="#co_networking_introduction_CO2-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>The SYN-ACK packet is the the one filtered by <code>tcpdump</code> from the <code>localhost.http-alt</code> process, the Golang web
server. The flag is to <code>[S.]</code>, so it is a SYN-ACK. The packet sends <code>195606347</code> as the next sequence number, and ACK <code>2784345139</code> is
set to acknowledge the previous packet.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-5" href="#co_networking_introduction_CO2-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>The acknowledgment <a data-type="indexterm" data-primary="ACK flag, TCP" id="idm46219954142728"/>packet from cURL is now sent back to the server with the ACK flag set, <code>[.]</code>, with the ACK and SYN
numbers set to 1, indicating it is ready to send data.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-6" href="#co_networking_introduction_CO2-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>The acknowledgment <a data-type="indexterm" data-primary="acknowledgment number, TCP" id="idm46219953687080"/>number is set to 1 to indicate the client’s SYN flag’s receipt in the opening data push.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-7" href="#co_networking_introduction_CO2-7"><img src="Images/7.png" alt="7" width="12" height="12"/></a></dt>
<dd><p>The TCP connection is established; both the <a data-type="indexterm" data-primary="data" data-secondary="tcpdump transmissions of" id="idm46219953683640"/>client and server are ready for data transmission. The next packets are our
data transmissions of the HTTP request with the flag set to a data push and ACK, <code>[P.]</code>. The previous packets had a length
of zero, but the HTTP request is 78 bytes long, with a sequence number of 1:79.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-8" href="#co_networking_introduction_CO2-8"><img src="Images/8.png" alt="8" width="12" height="12"/></a></dt>
<dd><p>The server acknowledges the receipt of the data transmission, with the ACK flag set, <code>[.]</code>, by sending the
acknowledgment number of 79.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-9" href="#co_networking_introduction_CO2-9"><img src="Images/9.png" alt="9" width="12" height="12"/></a></dt>
<dd><p>This packet <a data-type="indexterm" data-primary="cURL/curl tool" data-secondary="client requests with" id="idm46219953637880"/>is the HTTP server’s response to the cURL request. The data push flag is set, <code>[P.]</code>, and it acknowledges the
previous packet with an ACK number of 79. A new sequence number is set with the data transmission, 122, and the data
length is 121 bytes.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-10" href="#co_networking_introduction_CO2-10"><img src="Images/10.png" alt="10" width="12" height="12"/></a></dt>
<dd><p>The cURL client acknowledges the receipt of the packet with the ACK flag set, sets the acknowledgment number to 122,
and sets the sequence number to 79.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-11" href="#co_networking_introduction_CO2-11"><img src="Images/11.png" alt="11" width="12" height="12"/></a></dt>
<dd><p>The start of closing the TCP connection, with the client sending the FIN-ACK packet, the <code>[F.]</code>,
acknowledging the receipt of the previous packet, number 122, and a new sequence number to 80.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-12" href="#co_networking_introduction_CO2-12"><img src="Images/12.png" alt="12" width="12" height="12"/></a></dt>
<dd><p>The server increments the acknowledgment number to 80 and sets the ACK flag.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-13" href="#co_networking_introduction_CO2-13"><img src="Images/13.png" alt="13" width="12" height="12"/></a></dt>
<dd><p>TCP requires that both the sender and the receiver set the FIN packet for closing the connection. This is the
packet where the FIN and ACK flags are set.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-14" href="#co_networking_introduction_CO2-14"><img src="Images/14.png" alt="14" width="12" height="12"/></a></dt>
<dd><p>This is the final ACK from the client, with acknowledgment number 123. The connection is closed now.</p></dd>
<dt><a class="co" id="callout_networking_introduction_CO2-15" href="#co_networking_introduction_CO2-15"><img src="Images/15.png" alt="15" width="12" height="12"/></a></dt>
<dd><p><code>tcpdump</code> on exit lets us know the number of packets in this capture, the total number of the packets captured
during the <code>tcpdump</code>, and how many packets were dropped by the operating system.</p></dd>
</dl>

<p><code>tcpdump</code> is an <a data-type="indexterm" data-primary="cluster administrators" data-secondary="tcpdump and" id="idm46219954027928"/><a data-type="indexterm" data-primary="network engineers" id="idm46219954026952"/><a data-type="indexterm" data-primary="troubleshooting" id="idm46219954026280"/><a data-type="indexterm" data-primary="debugging" id="idm46219953962392"/>excellent troubleshooting application for network engineers as well as cluster administrators.
Being able to verify connectivity at many levels in the cluster and the network are valuable skills to have. You will
see in <a data-type="xref" href="ch06.xhtml#kubernetes_and_cloud_networking">Chapter 6</a> how useful <code>tcpdump</code> can be.</p>

<p>Our example was a simple HTTP application using TCP. All of this data was sent over the network in plain text. While
this example was a simple Hello World, other requests like our bank logins need to have some security.
The Transport layer does not offer any security protection for data transiting the <a data-type="indexterm" data-startref="ch1_term32" id="idm46219953959480"/><a data-type="indexterm" data-startref="ch1_term33" id="idm46219953958776"/><a data-type="indexterm" data-startref="ch1_term34" id="idm46219953958104"/>network. TLS adds additional security on top of TCP. Let’s dive into that in our next section.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="TLS"><div class="sect3" id="tlssection">
<h3>TLS</h3>

<p>TLS adds <a data-type="indexterm" data-primary="certificates and keys" data-secondary="in TLS" data-secondary-sortas="TLS" id="ch1_term35"/><a data-type="indexterm" data-primary="client requests" data-secondary="with TCL encryption" data-secondary-sortas="TCL encryption" id="ch1_term36"/><a data-type="indexterm" data-primary="encryption with TCL" id="ch1_term37"/><a data-type="indexterm" data-primary="keys for encryption" id="ch1_term38"/><a data-type="indexterm" data-primary="security" data-secondary="TLS for" id="ch1_term39"/><a data-type="indexterm" data-primary="server responses" data-secondary="with TCL encryption" data-secondary-sortas="TCL encryption" id="ch1_term40"/><a data-type="indexterm" data-primary="TLS (Transport Layer Security)" id="ch1_term41"/><a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="TLS add-on for" id="ch1_term42"/>encryption to TCP. TLS is an add-on to the TCP/IP suite and is not considered to be part of the base operation for TCP. HTTP transactions can be completed without TLS but are not
secure from eavesdroppers on the wire. TLS is a combination of protocols used to ensure traffic is seen between
the sender and the intended recipient. TLS, much like TCP, uses a handshake to establish encryption capabilities and
exchange keys for encryption. The following steps detail the TLS handshake between the client and the server, which can also be seen in <a data-type="xref" href="#img-tls-handshake">Figure 1-9</a>:</p>
<ol class="less_space pagebreak-before">
<li>
<p>ClientHello: This contains the cipher suites supported by the client and a random number.</p>
</li>
<li>
<p>ServerHello: This message contains the cipher it supports and
a random number.</p>
</li>
<li>
<p>ServerCertificate: This contains the server’s certificate and its server public key.</p>
</li>
<li>
<p>ServerHelloDone: This is the end of the ServerHello. If the client receives a request for its certificate, it
sends a ClientCertificate message.</p>
</li>
<li>
<p>ClientKeyExchange: Based on the server’s random number, our client generates a random premaster secret, encrypts
it with the server’s public key certificate, and sends it to the server.</p>
</li>
<li>
<p>Key Generation: The client and server generate a master secret from the premaster secret and exchange random
values.</p>
</li>
<li>
<p>ChangeCipherSpec: Now the client and server swap their ChangeCipherSpec to begin using the new keys for encryption.</p>
</li>
<li>
<p>Finished Client: The client sends the finished message to confirm that the key exchange and authentication were
successful.</p>
</li>
<li>
<p>Finished Server: Now, the server sends the finished message to the client to end the handshake.</p>
</li>

</ol>

<p>Kubernetes applications and components will manage TLS for developers, so a basic introduction is required; <a data-type="xref" href="ch05.xhtml#kubernetes_networking_abstractions">Chapter 5</a> reviews more about TLS and Kubernetes.</p>

<p>As demonstrated with our web server, cURL, and <code>tcpdump</code>, TCP is a stateful and reliable protocol for sending data between hosts. Its use of flags, combined with the sequence and acknowledgment number dance it performs, delivers thousands of messages over unreliable networks across the globe. That reliability comes at
a cost, however. Of the 12 packets we set, only two were real data transfers. For applications that do not need reliability such as voice, the overhead that comes with UDP offers an alternative. Now that we understand how TCP works as a reliable connection-oriented <a data-type="indexterm" data-startref="ch1_term22" id="idm46219953469048"/><a data-type="indexterm" data-startref="ch1_term35" id="idm46219953468344"/><a data-type="indexterm" data-startref="ch1_term36" id="idm46219953467672"/><a data-type="indexterm" data-startref="ch1_term37" id="idm46219953467000"/><a data-type="indexterm" data-startref="ch1_term38" id="idm46219953466328"/><a data-type="indexterm" data-startref="ch1_term39" id="idm46219953465656"/><a data-type="indexterm" data-startref="ch1_term40" id="idm46219953464984"/><a data-type="indexterm" data-startref="ch1_term41" id="idm46219953464312"/><a data-type="indexterm" data-startref="ch1_term42" id="idm46219953463640"/>protocol, let’s review how UDP differs from TCP.</p>

<figure><div id="img-tls-handshake" class="figure">
<img src="Images/neku_0109.png" alt="TLS Handshake" width="1440" height="1522"/>
<h6><span class="label">Figure 1-9. </span>TLS handshake</h6>
</div></figure>
</div></section>













<section data-type="sect3" class="less_space pagebreak-before" data-pdf-bookmark="UDP"><div class="sect3" id="udpsection">
<h3>UDP</h3>

<p>UDP offers an <a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="UDP alternative for" id="idm46219953458744"/><a data-type="indexterm" data-primary="UDP (User Datagram textProtocol)" data-secondary="in Transport layer of TCP/IP" data-secondary-sortas="Transport layer of TCP/IP" id="idm46219953457720"/>alternative to applications that do not need the reliability that TCP provides. UDP is an excellent
choice for applications that can withstand packet loss such as voice and DNS. UDP offers little overhead from a
network perspective, only having four fields and no data acknowledgment, unlike its verbose brother TCP.</p>

<p>It is transaction-oriented, suitable for simple query and response protocols like the Domain Name System (DNS) and
Simple Network Management Protocol (SNMP). UDP slices a request into datagrams, making it capable for use with other
protocols for tunneling like a virtual private network (VPN). It is lightweight and straightforward, making it great for bootstrapping
application data in the case of DHCP. The stateless nature of data transfer makes UDP perfect for applications, such
as voice, that can withstand packet loss—did you hear that? UDP’s lack of retransmit also makes it an apt choice for
streaming video.</p>

<p>Let’s look<a data-type="indexterm" data-primary="UDP (User Datagram textProtocol)" data-secondary="header for" id="idm46219953454552"/><a data-type="indexterm" data-primary="headers" data-secondary="for UDP" data-secondary-sortas="UDP" id="idm46219953453528"/> at the small number of headers required in a UDP datagram (see <a data-type="xref" href="#udp-header">Figure 1-10</a>):</p>
<dl>
<dt><code>Source port number</code> (2 bytes)</dt>
<dd>
<p>Identifies the <a data-type="indexterm" data-primary="ports" data-secondary="identification of" id="idm46219953449368"/><a data-type="indexterm" data-primary="source port identification" id="idm46219953448360"/>sender’s port. The source host is the client; the port number is ephemeral. UDP ports have well-known numbers like DNS on 53 or DHCP 67/68.</p>
</dd>
<dt><code>Destination port number</code> (2 bytes)</dt>
<dd>
<p>Identifies <a data-type="indexterm" data-primary="destination port identification" id="idm46219953445864"/>the receiver’s port and is required.</p>
</dd>
<dt><code>Length</code> (2 bytes)</dt>
<dd>
<p>Specifies the <a data-type="indexterm" data-primary="length field identifier" id="idm46219953443416"/>length in bytes of the UDP header and UDP data. The minimum length is 8 bytes, the length of the header.</p>
</dd>
<dt><code>Checksum</code> (2 bytes)</dt>
<dd>
<p>Used for <a data-type="indexterm" data-primary="checksum" id="idm46219953440856"/>error checking of the header and data. It is optional in IPv4, but mandatory in IPv6, and is all zeros if unused.</p>
</dd>
</dl>

<p>UDP and <a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="overview of" id="idm46219953439352"/>TCP are general transport protocols that help ship and receive data between hosts. <a data-type="indexterm" data-primary="Kubernetes" data-secondary="transport protocols for" id="idm46219953438200"/>Kubernetes supports both
protocols on the network, and services allow users to load balance many pods using services. Also important to note is that in each service, developers must define the transport protocol; if they do not TCP is the <a data-type="indexterm" data-startref="ch1_term43" id="idm46219953436872"/><a data-type="indexterm" data-startref="ch1_term44" id="idm46219953436200"/>default used.</p>

<figure><div id="udp-header" class="figure">
<img src="Images/neku_0110.png" alt="udp header" width="806" height="515"/>
<h6><span class="label">Figure 1-10. </span>UDP header</h6>
</div></figure>

<p>The next layer in the TCP/IP stack is the Internetworking layer—these are packets that can get sent across the globe on
the vast networks that make up the internet. Let’s review how that gets completed.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Network"><div class="sect2" id="idm46219953432632">
<h2>Network</h2>

<p>All TCP and <a data-type="indexterm" data-primary="Network (Internet) layer, TCP/IP (L3)" data-secondary="IP header and" id="ch1_term45"/><a data-type="indexterm" data-primary="Network (Internet) layer, TCP/IP (L3)" id="ch1_term46"/>UDP data gets transmitted as IP packets in TCP/IP in the Network layer. The Internet or Network layer is
responsible for transferring data between networks. Outgoing packets select the next-hop host and send the data to that
host by passing it the appropriate Link layer details; packets are received by a host, de-encapsulated, and
sent up to the proper Transport layer protocol. In IPv4, both transmit and receive, IP provides fragmentation or
defragmentation of packets <a data-type="indexterm" data-primary="maximum transmission unit (MTU)" id="idm46219953428584"/><a data-type="indexterm" data-primary="MTU (maximum transmission unit)" id="idm46219953427896"/><a data-type="indexterm" data-primary="packets" data-secondary="MTUs of" id="idm46219953427208"/>based on the MTU; this is the maximum size of the IP packet.</p>

<p>IP makes <a data-type="indexterm" data-primary="packets" data-secondary="IP (Internet Protocol) and" id="idm46219953425752"/>no guarantees about packets’ proper arrival; since packet delivery across diverse networks is inherently
unreliable and failure-prone, that burden is with the endpoints of a communication path, rather than on the network.
As discussed in the previous section, providing service reliability is a function of the Transport layer. Each packet
has a checksum to ensure that the received packet’s information is accurate, but this layer does not validate data
integrity. Source and destination IP addresses identify packets on the network, which we’ll address next.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Internet Protocol"><div class="sect2" id="idm46219953423768">
<h2>Internet Protocol</h2>

<p>This almighty packet is <a data-type="indexterm" data-primary="RFC 791" id="idm46219953421752"/>defined in RFC 791 and is used for sending data across networks. <a data-type="xref" href="#img-ipv4-header">Figure 1-11</a> shows the IPv4 header format.</p>

<figure><div id="img-ipv4-header" class="figure">
<img src="Images/neku_0111.png" alt="neku 0111" width="751" height="843"/>
<h6><span class="label">Figure 1-11. </span>IPv4 header format</h6>
</div></figure>

<p>Let’s look at the header fields in more detail:<a data-type="indexterm" data-primary="headers" data-secondary="for IPv4" data-secondary-sortas="IPv4" id="ch1_term47"/><a data-type="indexterm" data-primary="IPv4" data-secondary="header format for" id="ch1_term48"/></p>
<dl>
<dt><code>Version</code></dt>
<dd>
<p>The first <a data-type="indexterm" data-primary="version, IP header" id="idm46219953412648"/>header field in the IP packet is the four-bit version field. For IPv4, this is always equal to
four.</p>
</dd>
<dt><code>Internet Header Length</code> (IHL)</dt>
<dd>
<p>The IPv4 <a data-type="indexterm" data-primary="internet header length, IP header" id="idm46219953410104"/>header has a variable size due to the optional 14th field option.</p>
</dd>
<dt><code>Type of Service</code></dt>
<dd>
<p> Originally defined as the <a data-type="indexterm" data-primary="type of service (ToS), IP header" id="idm46219953407816"/>type of service (ToS), now <a data-type="indexterm" data-primary="Differentiated Services Code Point (DSCP)" id="idm46219953406920"/><a data-type="indexterm" data-primary="DSCP (Differentiated Services Code Point)" id="idm46219953406280"/>Differentiated Services Code Point (DSCP), this field specifies differentiated services. DSC Pallows for routers and networks to make decisions on packet priority during times of congestion. Technologies such as
Voice over IP use DSCP to ensure calls take precedence over other traffic.</p>
</dd>
<dt><code>Total Length</code></dt>
<dd>
<p>This is the <a data-type="indexterm" data-primary="total length, IP header" id="idm46219953403800"/>entire packet size in bytes.</p>
</dd>
<dt><code>Identification</code></dt>
<dd>
<p>This is the <a data-type="indexterm" data-primary="identification field, IP header" id="idm46219953401480"/>identification field and is used for uniquely identifying the group of fragments of a single IP
datagram.</p>
</dd>
<dt><code>Flags</code></dt>
<dd>
<p>This is <a data-type="indexterm" data-primary="flags" data-secondary="in IP header" data-secondary-sortas="IP header" id="idm46219953399016"/>used to control or identify fragments. In order from most significant to least:</p>

<ul>
<li>
<p>bit 0: Reserved, set to zero</p>
</li>
<li>
<p>bit 1: Do not Fragment</p>
</li>
<li>
<p>bit 2: More Fragments</p>
</li>
</ul>
</dd>
<dt><code>Fragment Offset</code></dt>
<dd>
<p>This specifies <a data-type="indexterm" data-primary="fragment offset, IP header" id="idm46219953393096"/>the offset of a distinct fragment relative to the first unfragmented IP packet. The
first fragment always has an offset of zero.</p>
</dd>
<dt><code>Time To Live (TTL)</code></dt>
<dd>
<p>An 8-bit <a data-type="indexterm" data-primary="time to live (TTL) value" id="idm46219953390616"/><a data-type="indexterm" data-primary="TTL (time to live), IP header" id="idm46219953389864"/>time to live field helps prevent datagrams from going in circles on a network.</p>
</dd>
<dt><code>Protocol</code></dt>
<dd>
<div class="openblock">
<p>This is <a data-type="indexterm" data-primary="protocol numbers, IP header" id="idm46219953386824"/>used in the data section of the IP packet. <a data-type="indexterm" data-primary="IANA (Internet Assigned Number Authority)" id="idm46219953385992"/><a data-type="indexterm" data-primary="Internet Assigned Number Authority (IANA)" id="idm46219953385352"/>IANA has a list of IP protocol numbers in RFC 790;
some well-known <a data-type="indexterm" data-primary="ICMP (Internet Control Message Protocol)" data-secondary="protocol number for" id="idm46219953384584"/><a data-type="indexterm" data-primary="TCP (Transmission Control Protocol)" data-secondary="protocol number of" id="idm46219953383672"/><a data-type="indexterm" data-primary="UDP (User Datagram textProtocol)" data-secondary="protocol number for" id="idm46219953382712"/>protocols are also detailed in <a data-type="xref" href="#ip_protocol_numbers">Table 1-4</a>.</p>
<table id="ip_protocol_numbers">
<caption><span class="label">Table 1-4. </span>IP protocol numbers</caption>
<thead>
<tr>
<th>Protocol number</th>
<th>Protocol name</th>
<th>Abbreviation</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>1</p></td>
<td><p>Internet Control Message Protocol</p></td>
<td><p>ICMP</p></td>
</tr>
<tr>
<td><p>2</p></td>
<td><p>Internet Group Management Protocol</p></td>
<td><p>IGMP</p></td>
</tr>
<tr>
<td><p>6</p></td>
<td><p>Transmission Control Protocol</p></td>
<td><p>TCP</p></td>
</tr>
<tr>
<td><p>17</p></td>
<td><p>User Datagram Protocol</p></td>
<td><p>UDP</p></td>
</tr>
<tr>
<td><p>41</p></td>
<td><p>IPv6 Encapsulation</p></td>
<td><p>ENCAP</p></td>
</tr>
<tr>
<td><p>89</p></td>
<td><p>Open Shortest Path First</p></td>
<td><p>OSPF</p></td>
</tr>
<tr>
<td><p>132</p></td>
<td><p>Stream Control Transmission Protocol</p></td>
<td><p>SCTP</p></td>
</tr>
</tbody>
</table>
</div>

</dd>
<dt><code>Header Checksum</code> (16-bit)</dt>
<dd>
<div class="openblock">
<p>The IPv4 header <a data-type="indexterm" data-primary="header checksum, IP header" id="idm46219953359464"/><a data-type="indexterm" data-primary="checksum" id="idm46219953358712"/>checksum field is used for error checking. When a packet arrives, a router
computes the header’s checksum; the router drops the packet if the two values do not match. The encapsulated protocol
must handle errors in the data field. Both UDP and TCP have checksum fields.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When the <a data-type="indexterm" data-primary="routing" data-secondary="in Network layer" data-secondary-sortas="Network layer" id="idm46219953356648"/>router receives a packet, it lowers the TTL field by one. As a consequence, the router must compute a new 
<span class="keep-together">checksum.</span></p>
</div>
</div>

</dd>
<dt><code>Source address</code></dt>
<dd>
<div class="openblock">
<p>This is the <a data-type="indexterm" data-primary="source address, IP header" id="idm46219953352296"/>IPv4 address of the sender of the packet.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The source address may be changed in transit by a network address translation device; NAT will be discussed later in
this chapter and extensively in <a data-type="xref" href="ch03.xhtml#container_networking_basics">Chapter 3</a>.</p>
</div>
</div>

</dd>
<dt><code>Destination address</code></dt>
<dd>
<p>This is the <a data-type="indexterm" data-primary="destination address, IP header" id="idm46219953347736"/>IPv4 address of the receiver of the packet. As with the source address, a NAT device can change
the destination IP address.</p>
</dd>
<dt><code>Options</code></dt>
<dd>
<p>The possible <a data-type="indexterm" data-primary="options" data-secondary="IP header" id="idm46219953345304"/>options in the header are Copied, Option Class, Option Number, Option Length, and Option Data.</p>
</dd>
</dl>

<p>The crucial <a data-type="indexterm" data-primary="IP (Internet Protocol) addresses" data-secondary="for IPv4 and IPv6" data-secondary-sortas="IPv4 and IPv6" id="ch1_term49"/><a data-type="indexterm" data-primary="IPv4" data-secondary="addresses" id="ch1_term50"/><a data-type="indexterm" data-primary="Network (Internet) layer, TCP/IP (L3)" data-secondary="IP addresses and" id="ch1_term51"/>component here is the address; it’s how networks are identified. They simultaneously identify the
host on the network and the whole network <a data-type="indexterm" data-startref="ch1_term45" id="idm46219953339592"/><a data-type="indexterm" data-startref="ch1_term47" id="idm46219953338920"/><a data-type="indexterm" data-startref="ch1_term48" id="idm46219953338248"/>itself (more on that in <a data-type="xref" href="#getround">“Getting round the network”</a>). Understanding how to identify
an IP address is critical for an engineer. First, we will review IPv4 and then understand the drastic changes in IPv6.</p>

<p>IPv4 addresses are in the dotted-decimal notation for us humans; computers read them out as binary strings. <a data-type="xref" href="#ipv-four-address">Figure 1-12</a>
details the dotted-decimal notation and binary. Each section is 8 bits in length, with four sections, making the complete
length 32 bits. IPv4 addresses have two sections: the first part is the network, and the second is the host’s unique
identifier on the network.</p>

<figure><div id="ipv-four-address" class="figure">
<img src="Images/neku_0112.png" alt="IPv4 Address" width="649" height="389"/>
<h6><span class="label">Figure 1-12. </span>IPv4 address</h6>
</div></figure>

<p>In <a data-type="xref" href="#ip_address">Example 1-5</a>, we have the output of a computer’s IP address for its network interface
card and we can see its IPv4 address is <code>192.168.1.2</code>. The IP address also has a <a data-type="indexterm" data-primary="netmask (subnet mask)" id="idm46219953331000"/><a data-type="indexterm" data-primary="subnet mask (netmask)" id="idm46219953330296"/>subnet mask or netmask
associated with it to make out what network it is assigned. The example’s subnet is <code>netmask 0xffffff00</code> in
dotted-decimal, which is <code>255.255.255.0</code>.</p>
<div id="ip_address" data-type="example">
<h5><span class="label">Example 1-5. </span>IP address</h5>

<pre data-type="programlisting" data-code-language="bash">○ → ifconfig en0
en0: <code class="nv">flags</code><code class="o">=</code>8863&lt;UP,BROADCAST,SMART,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
	<code class="nv">options</code><code class="o">=</code>400&lt;CHANNEL_IO&gt;
	ether 38:f9:d3:bc:8a:51
	inet6 fe80::8f4:bb53:e500:9557%en0 prefixlen <code class="m">64</code> secured scopeid 0x6
	inet 192.168.1.2 netmask 0xffffff00 broadcast 192.168.1.255
	nd6 <code class="nv">options</code><code class="o">=</code>201&lt;PERFORMNUD,DAD&gt;
	media: autoselect
	status: active</pre></div>

<p>The subnet brings up the <a data-type="indexterm" data-primary="classful IP addressing" id="idm46219953321960"/>idea of classful addressing. Initially, when an IP address range was assigned, a range was considered to be the combination of an 8-, 16-, or 24-bit network prefix along with a 24-, 16-, or 8-bit host identifier, respectively. Class A had 8 bits for the host, Class B 16, and Class C 24. Following that, Class A had 2 to the power of 16 hosts available, 16,777,216; Class B had 65,536; and Class C had 256. Each class had a host address, the first one in its boundary, and the last one was designated as the broadcast address. <a data-type="xref" href="#ipv-four-class-address">Figure 1-13</a> demonstrates this for us.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>There are two other classes, but they are not generally used in IP addressing. Class D addresses are used for IP
multicasting, and Class E addresses are reserved for experimental use.</p>
</div>

<figure><div id="ipv-four-class-address" class="figure">
<img src="Images/neku_0113.png" alt="IPv4 Class Address" width="1227" height="578"/>
<h6><span class="label">Figure 1-13. </span>IP class</h6>
</div></figure>

<p>Classful addressing was not <a data-type="indexterm" data-primary="scaling" id="idm46219953314712"/>scalable on the internet, so to help alleviate that scale issue, we began <a data-type="indexterm" data-primary="CIDR (Classless Inter-Domain Routing) ranges" data-secondary="overview of" id="ch1_term52"/>breaking up the
class boundaries using Classless Inter-Domain Routing (CIDR) ranges. Instead of having the full 16 million-plus addresses
in a class address range, an internet entity gives only a subsection of that range. This effectively allows network
engineers to move the subnet boundary to anywhere inside the class range, giving them more flexibility with CIDR ranges,
and helping to scale IP address ranges.</p>

<p>In <a data-type="xref" href="#cidr-example">Figure 1-14</a>, we can see the breakdown of the <code>208.130.29.33</code> IPv4 address and the hierarchy that it creates. The <code>208.128.0.0/11</code> CIDR range is assigned to ARIN from IANA. ARIN further <a data-type="indexterm" data-primary="subnets" data-secondary="as CIDR" data-secondary-sortas="CIDR" id="idm46219953303784"/>breaks down the subnet to smaller and smaller subnets for its purposes, leading to the single host on the network <code>208.130.29.33/32</code>.</p>

<figure><div id="cidr-example" class="figure">
<img src="Images/neku_0114.png" alt="CIDR example" width="865" height="584"/>
<h6><span class="label">Figure 1-14. </span>CIDR example</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The global <a data-type="indexterm" data-primary="IANA (Internet Assigned Number Authority)" id="idm46219953298984"/><a data-type="indexterm" data-primary="Internet Assigned Number Authority (IANA)" id="idm46219953298280"/>coordination of the DNS root, IP addressing, and other internet protocol resources is performed by IANA.</p>
</div>

<p>Eventually, though, even this <a data-type="indexterm" data-primary="IPv4 versus IPv6" id="idm46219953296824"/><a data-type="indexterm" data-primary="IPv6" data-secondary="addresses" id="idm46219953296120"/>practice of using CIDR to extend the range of an IPv4 address led to an exhaustion of
address spaces that could be doled out, leading network engineers and IETF to develop <a data-type="indexterm" data-startref="ch1_term52" id="idm46219953294856"/>the IPv6 standard.</p>

<p>In <a data-type="xref" href="#ipv-six-address">Figure 1-15</a>, we can see that IPv6, unlike IPv4, uses hexadecimal to shorten addresses for writing purposes. It has similar characteristics to IPv4
in that it has a host and network prefix.</p>

<p>The most significant difference between IPv4 and IPv6 is the size of the address space. IPv4 has 32 bits, while IPv6 has
128 bits to produce its addresses. To put that size differential in perspective, here are those numbers:</p>

<p>IPv4 has 4,294,967,296.</p>

<p>IPv6 has 340,282,366,920,938,463,463,374,607,431,768,211,456.</p>

<figure><div id="ipv-six-address" class="figure">
<img src="Images/neku_0115.png" alt="IPv4 Address" width="1376" height="451"/>
<h6><span class="label">Figure 1-15. </span>IPv6 address</h6>
</div></figure>

<p>Now that we understand how an individual host on the network is identified and what network it belongs to, <a data-type="indexterm" data-startref="ch1_term49" id="idm46219953288552"/><a data-type="indexterm" data-startref="ch1_term50" id="idm46219953287848"/><a data-type="indexterm" data-startref="ch1_term51" id="idm46219953271016"/>we will
explore how those <a data-type="indexterm" data-primary="Network (Internet) layer, TCP/IP (L3)" data-secondary="routing protocols in" id="ch1_term58"/><a data-type="indexterm" data-primary="routing" data-secondary="in Network layer" data-secondary-sortas="Network layer" id="ch1_term59"/>networks exchange information between themselves using routing protocols.</p>










<section data-type="sect3" data-pdf-bookmark="Getting round the network"><div class="sect3" id="getround">
<h3>Getting round the network</h3>

<p>Packets are addressed, and data is ready to be sent, but how do our packets get from our host on our network to the
intended hosted on another network halfway around the world? That is the job of routing. There are several
routing protocols, but the <a data-type="indexterm" data-primary="internet, BGP routing protocol for" id="ch1_term53"/><a data-type="indexterm" data-primary="Border Gateway Protocol (BGP)" id="ch1_term54"/><a data-type="indexterm" data-primary="routing" data-secondary="BGP protocol for" id="ch1_term55"/>internet relies on Border Gateway Protocol (BGP), a dynamic routing protocol used to manage how packets get routed between edge routers on the internet. It is relevant for us because some <a data-type="indexterm" data-primary="Kubernetes" data-secondary="network protocols for" id="idm46219953261384"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="routing tools of" id="idm46219953260440"/>Kubernetes network implementations use BGP to route cluster network traffic between nodes. Between each node on separate networks is a series of routers.</p>

<p>If we refer to the map of the internet in <a data-type="xref" href="#img-internet-map">Figure 1-1</a>, each network on the internet is <a data-type="indexterm" data-primary="ASNs (autonomous system numbers)" id="ch1_term56"/><a data-type="indexterm" data-primary="autonomous system numbers (ASNs)" id="ch1_term57"/>assigned a BGP autonomous system number (ASN) to designate a single administrative entity or corporation that represents a common and clearly defined routing policy on the internet. <a data-type="indexterm" data-primary="network administrators" id="idm46219953255512"/>BGP and ASNs allows network administrators to maintain control of their internal network routing while announcing and summarizing their routes on the internet. <a data-type="xref" href="#complete_table_of_asn_available">Table 1-5</a> lists the available ASNs managed by <a data-type="indexterm" data-primary="IANA (Internet Assigned Number Authority)" id="idm46219953253720"/><a data-type="indexterm" data-primary="Internet Assigned Number Authority (IANA)" id="idm46219953253080"/>IANA and other regional entities.<sup><a data-type="noteref" id="idm46219953252264-marker" href="ch01.xhtml#idm46219953252264">1</a></sup></p>
<table id="complete_table_of_asn_available" class="less_space pagebreak-before">
<caption><span class="label">Table 1-5. </span>ASNs available</caption>
<thead>
<tr>
<th>Number</th>
<th>Bits</th>
<th>Description</th>
<th>Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>16</p></td>
<td><p>Reserved</p></td>
<td><p>RFC 1930, RFC 7607</p></td>
</tr>
<tr>
<td><p>1–23455</p></td>
<td><p>16</p></td>
<td><p>Public ASNs</p></td>
<td/>
</tr>
<tr>
<td><p>23456</p></td>
<td><p>16</p></td>
<td><p>Reserved for AS Pool Transition</p></td>
<td><p>RFC 6793</p></td>
</tr>
<tr>
<td><p>23457–64495</p></td>
<td><p>16</p></td>
<td><p>Public ASNs</p></td>
<td/>
</tr>
<tr>
<td><p>64496–64511</p></td>
<td><p>16</p></td>
<td><p>Reserved for use in documentation/sample code</p></td>
<td><p>RFC 5398</p></td>
</tr>
<tr>
<td><p>64512–65534</p></td>
<td><p>16</p></td>
<td><p>Reserved for private use</p></td>
<td><p>RFC 1930, RFC 6996</p></td>
</tr>
<tr>
<td><p>65535</p></td>
<td><p>16</p></td>
<td><p>Reserved</p></td>
<td><p>RFC 7300</p></td>
</tr>
<tr>
<td><p>65536–65551</p></td>
<td><p>32</p></td>
<td><p>Reserved for use in documentation and sample code</p></td>
<td><p>RFC 4893, RFC 5398</p></td>
</tr>
<tr>
<td><p>65552–131071</p></td>
<td><p>32</p></td>
<td><p>Reserved</p></td>
<td/>
</tr>
<tr>
<td><p>131072–4199999999</p></td>
<td><p>32</p></td>
<td><p>Public 32-bit ASNs</p></td>
<td/>
</tr>
<tr>
<td><p>4200000000–4294967294</p></td>
<td><p>32</p></td>
<td><p>Reserved for private use</p></td>
<td><p>RFC 6996</p></td>
</tr>
<tr>
<td><p>4294967295</p></td>
<td><p>32</p></td>
<td><p>Reserved</p></td>
<td><p>RFC 7300</p></td>
</tr>
</tbody>
</table>

<p>In <a data-type="xref" href="#bgp-routing">Figure 1-16</a> ,we have five ASNs, 100–500. A host on <code>130.10.1.200</code> wants to reach a host destined on <code>150.10.2.300</code>. Once the local router or default gateway for the host <code>130.10.1.200</code> receives the packet, it will look for the interface and path for <code>150.10.2.300</code> that BGP has determined for that route.</p>

<figure><div id="bgp-routing" class="figure">
<img src="Images/neku_0116.png" alt="BGP Routing" width="1080" height="938"/>
<h6><span class="label">Figure 1-16. </span>BGP routing example</h6>
</div></figure>

<p>Based on the routing table in <a data-type="xref" href="#route-table">Figure 1-17</a>,  the router for AS 100 determined the packet belongs to AS 300, and the preferred path is out interface <code>140.10.1.1</code>. Rinse and repeat on AS 200 until the local router for <code>150.10.2.300</code> on AS 300 receives that packet. The flow here is described in <a data-type="xref" href="#three-way-tcp">Figure 1-6</a>, which shows the TCP/IP data flow between networks. A basic understanding of BGP is needed because some container networking projects, like Calico, use it for routing between <a data-type="indexterm" data-startref="ch1_term56" id="idm46219945117096"/><a data-type="indexterm" data-startref="ch1_term57" id="idm46219945116488"/>nodes; you’ll learn more about this in <a data-type="xref" href="ch03.xhtml#container_networking_basics">Chapter 3</a>.</p>

<figure><div id="route-table" class="figure">
<img src="Images/neku_0117.png" alt="Route Table" width="1249" height="741"/>
<h6><span class="label">Figure 1-17. </span>Local routing table</h6>
</div></figure>

<p><a data-type="xref" href="#route-table">Figure 1-17</a> displays a <a data-type="indexterm" data-primary="local routing table" id="idm46219945112184"/><a data-type="indexterm" data-primary="routing" data-secondary="local table for" id="idm46219945111576"/>local route table. In the route table, we can see the interface that a packet will be sent out is based on the destination IP address. For example, a packet destined for <code>192.168.1.153</code> will be sent out the <code>link#11</code> gateway, which is local to the network, and no routing is needed. <code>192.168.1.254</code> is the router on the network attached to our internet connection. If the destination network is unknown, it is sent out the default route.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Like all Linux and BSD OSs, you can find more <a data-type="indexterm" data-primary="man netstat" id="idm46219945108120"/><a data-type="indexterm" data-primary="netstat" id="idm46219945107512"/>information on <code>netstat</code>’s man page (<code>man netstat</code>). Apple’s <code>netstat</code> is derived from the BSD version. More information can be found in the <a href="https://oreil.ly/YM0eQ">FreeBSD Handbook</a>.</p>
</div>

<p>Routers continuously communicate on the internet, exchanging route information and informing each other of changes on
their respective networks. BGP takes care of a lot of that data <a data-type="indexterm" data-startref="ch1_term53" id="idm46219945104424"/><a data-type="indexterm" data-startref="ch1_term54" id="idm46219945103816"/><a data-type="indexterm" data-startref="ch1_term55" id="idm46219945103208"/>exchange, but network engineers and system
administrators can use the ICMP protocol and <code>ping</code> command line tools to test connectivity between hosts and routers.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="ICMP"><div class="sect3" id="idm46219953266552">
<h3>ICMP</h3>

<p><code>ping</code> is a network <a data-type="indexterm" data-primary="ICMP (Internet Control Message Protocol)" data-secondary="echo requests and replies" id="idm46219945099928"/><a data-type="indexterm" data-primary="ping network utility" data-secondary="ICMP echo requests with" id="idm46219945099080"/><a data-type="indexterm" data-primary="echo requests, ICMP" id="idm46219945098232"/><a data-type="indexterm" data-primary="Network (Internet) layer, TCP/IP (L3)" data-secondary="testing connectivity in" id="ch1_term60"/><a data-type="indexterm" data-primary="routing" data-secondary="ICMP protocol for" id="ch1_term61"/><a data-type="indexterm" data-primary="testing for network connections" id="ch1_term62"/>utility that uses ICMP for testing connectivity between hosts on the network. In <a data-type="xref" href="#icmp_echo_request">Example 1-6</a>, we
see a successful <code>ping</code> test to <code>192.168.1.2</code>, with five packets all returning an ICMP echo reply.</p>
<div id="icmp_echo_request" data-type="example">
<h5><span class="label">Example 1-6. </span>ICMP echo request</h5>

<pre data-type="programlisting" data-code-language="bash">○ → ping 192.168.1.2 -c 5
PING 192.168.1.2 <code class="o">(</code>192.168.1.2<code class="o">)</code>: <code class="m">56</code> data bytes
<code class="m">64</code> bytes from 192.168.1.2: <code class="nv">icmp_seq</code><code class="o">=</code><code class="m">0</code> <code class="nv">ttl</code><code class="o">=</code><code class="m">64</code> <code class="nb">time</code><code class="o">=</code>0.052 ms
<code class="m">64</code> bytes from 192.168.1.2: <code class="nv">icmp_seq</code><code class="o">=</code><code class="m">1</code> <code class="nv">ttl</code><code class="o">=</code><code class="m">64</code> <code class="nb">time</code><code class="o">=</code>0.089 ms
<code class="m">64</code> bytes from 192.168.1.2: <code class="nv">icmp_seq</code><code class="o">=</code><code class="m">2</code> <code class="nv">ttl</code><code class="o">=</code><code class="m">64</code> <code class="nb">time</code><code class="o">=</code>0.142 ms
<code class="m">64</code> bytes from 192.168.1.2: <code class="nv">icmp_seq</code><code class="o">=</code><code class="m">3</code> <code class="nv">ttl</code><code class="o">=</code><code class="m">64</code> <code class="nb">time</code><code class="o">=</code>0.050 ms
<code class="m">64</code> bytes from 192.168.1.2: <code class="nv">icmp_seq</code><code class="o">=</code><code class="m">4</code> <code class="nv">ttl</code><code class="o">=</code><code class="m">64</code> <code class="nb">time</code><code class="o">=</code>0.050 ms
--- 192.168.1.2 ping statistics ---
<code class="m">5</code> packets transmitted, <code class="m">5</code> packets received, 0.0% packet loss
round-trip min/avg/max/stddev <code class="o">=</code> 0.050/0.077/0.142/0.036 ms</pre></div>

<p><a data-type="xref" href="#icmp_echo_request_failed">Example 1-7</a> shows a failed ping attempt that times out trying to reach host <code>1.2.3.4</code>. Routers and administrators will
use <code>ping</code> for testing connections, and it is useful in testing container connectivity as well. You’ll learn more about this in
Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.xhtml#linux_networking">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.xhtml#container_networking_basics">3</a> as we deploy our minimal Golang web server into a container and a pod.</p>
<div id="icmp_echo_request_failed" data-type="example">
<h5><span class="label">Example 1-7. </span>ICMP echo request failed</h5>

<pre data-type="programlisting" data-code-language="bash">○ → ping 1.2.3.4 -c 4
PING 1.2.3.4 <code class="o">(</code>1.2.3.4<code class="o">)</code>: <code class="m">56</code> data bytes
Request timeout <code class="k">for</code> icmp_seq 0
Request timeout <code class="k">for</code> icmp_seq 1
Request timeout <code class="k">for</code> icmp_seq 2
--- 1.2.3.4 ping statistics ---
<code class="m">4</code> packets transmitted, <code class="m">0</code> packets received, 100.0% packet loss</pre></div>

<p>As with TCP and UDP, there are <a data-type="indexterm" data-primary="ICMP (Internet Control Message Protocol)" data-secondary="header for" id="idm46219945024888"/><a data-type="indexterm" data-primary="headers" data-secondary="for ICMP" data-secondary-sortas="ICMP" id="idm46219944985560"/>headers, data, and options in ICMP packets; they are reviewed here and shown in
<a data-type="xref" href="#ICMP-header">Figure 1-18</a>:</p>
<dl>
<dt><code>Type</code></dt>
<dd>
<p>ICMP type.</p>
</dd>
<dt><code>Code</code></dt>
<dd>
<p>ICMP subtype.</p>
</dd>
<dt><code>Checksum</code></dt>
<dd>
<p>Internet <a data-type="indexterm" data-primary="checksum" id="idm46219945020344"/>checksum for error checking, calculated from the ICMP header and data with value 0
substitutes for this field.</p>
</dd>
<dt><code>Rest of Header</code> (4-byte field)</dt>
<dd>
<p>Contents vary based on the ICMP type and code.</p>
</dd>
<dt><code>Data</code></dt>
<dd>
<p>ICMP error <a data-type="indexterm" data-primary="IPv4" data-secondary="in ICMP error messages" data-secondary-sortas="ICMP error messages" id="idm46219945011688"/>messages contain a data section that includes a copy of the entire IPv4 header.</p>
</dd>
</dl>

<figure><div id="ICMP-header" class="figure">
<img src="Images/neku_0118.png" alt="icmp header" width="623" height="368"/>
<h6><span class="label">Figure 1-18. </span>ICMP header</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some consider <a data-type="indexterm" data-primary="ICMP (Internet Control Message Protocol)" data-secondary="in Network versus Transport layer" data-secondary-sortas="Network versus Transport layer" id="idm46219945007416"/><a data-type="indexterm" data-primary="Transport layer, TCP/IP (L4)" data-secondary="ICMP as" id="idm46219945006056"/>ICMP a Transport layer protocol since it does not use TCP or UDP. Per RFC 792, it defines ICMP, which
provides routing, diagnostic, and error functionality for IP. Although ICMP messages are encapsulated within IP
datagrams, ICMP processing is considered and is typically implemented as part of the IP layer. <a data-type="indexterm" data-primary="ICMP (Internet Control Message Protocol)" data-secondary="protocol number for" id="idm46219945004648"/><a data-type="indexterm" data-primary="TCP (Transmission Control Protocol)" data-secondary="protocol number of" id="idm46219945003672"/><a data-type="indexterm" data-primary="UDP (User Datagram textProtocol)" data-secondary="protocol number for" id="idm46219945002712"/>ICMP is IP protocol 1,
while TCP is 6, and UDP is 17.</p>
</div>

<p>The value <a data-type="indexterm" data-primary="ICMP (Internet Control Message Protocol)" data-secondary="type numbers in" id="idm46219945001112"/>identifies control messages in the <code>Type</code> field. The <code>code</code> field gives additional context information
for the message. You can find some standard ICMP type numbers in <a data-type="xref" href="#common_icmp_type_numbers">Table 1-6</a>.</p>
<table id="common_icmp_type_numbers">
<caption><span class="label">Table 1-6. </span>Common ICMP type numbers</caption>
<thead>
<tr>
<th>Number</th>
<th>Name</th>
<th>Reference</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0</p></td>
<td><p>Echo reply</p></td>
<td><p>RFC 792</p></td>
</tr>
<tr>
<td><p>3</p></td>
<td><p>Destination unreachable</p></td>
<td><p>RFC 792</p></td>
</tr>
<tr>
<td><p>5</p></td>
<td><p>Redirect</p></td>
<td><p>RFC 792</p></td>
</tr>
<tr>
<td><p>8</p></td>
<td><p>Echo</p></td>
<td><p>RFC 792</p></td>
</tr>
</tbody>
</table>

<p>Now that our packets know which networks they are being sourced and destined to, it is <a data-type="indexterm" data-startref="ch1_term46" id="idm46219944938072"/><a data-type="indexterm" data-startref="ch1_term58" id="idm46219944937464"/><a data-type="indexterm" data-startref="ch1_term59" id="idm46219944936856"/><a data-type="indexterm" data-startref="ch1_term60" id="idm46219944936248"/><a data-type="indexterm" data-startref="ch1_term61" id="idm46219944935640"/><a data-type="indexterm" data-startref="ch1_term62" id="idm46219944935032"/>time to start physically
sending this data request across the network; this is the responsibility of the Link layer.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Link Layer"><div class="sect2" id="idm46219953422984">
<h2>Link Layer</h2>

<p>The HTTP request has been broken up into segments, addressed for routing across the internet, and <a data-type="indexterm" data-primary="Link layer (L2)" data-secondary="of TCP/IP" data-secondary-sortas="TCP/IP" id="ch1_term64"/><a data-type="indexterm" data-primary="TCP/IP" data-secondary="Data Link layer of" id="ch1_term65"/>now all that is left is to send the data across the wire. The Link layer of the TCP/IP stack comprises two sublayers: the <a data-type="indexterm" data-primary="MAC (Media Access Control) sublayer" data-secondary="of Link layer" data-secondary-sortas="Link layer" id="ch1_term63"/>Media Access Control (MAC) sublayer and the <a data-type="indexterm" data-primary="LLC (Logical Link Control) sublayer" id="idm46219944928296"/><a data-type="indexterm" data-primary="Logical Link Control (LLC) sublayer" id="idm46219944927688"/>Logical Link Control (LLC) sublayer. Together, they perform OSI layers 1 and 2, Data Link and Physical. The Link layer is responsible for connectivity to the local network. The first sublayer, MAC, is responsible for access to the physical medium. The <a data-type="indexterm" data-primary="Ethernet" data-secondary="demultiplexing example of" id="idm46219944926680"/><a data-type="indexterm" data-primary="IEEE 802 standards" id="idm46219944925832"/><a data-type="indexterm" data-primary="Ethernet" data-secondary="in Link layer" data-secondary-sortas="Link layer" id="ch1_term66"/>LLC layer has the privilege of managing flow control and multiplexing protocols over the MAC layer to transmit and demultiplexing when receiving, as shown in <a data-type="xref" href="#net-demux">Figure 1-19</a>. IEEE standard 802.3, Ethernet, defines the protocols for sending and receiving frames to encapsulate IP packets. IEEE 802 is the overarching standard for LLC (802.2), wireless (802.11), and Ethernet/MAC (802.3).</p>

<figure><div id="net-demux" class="figure">
<img src="Images/neku_0119.png" alt="ethernet-demux" width="1439" height="895"/>
<h6><span class="label">Figure 1-19. </span>Ethernet demultiplexing example</h6>
</div></figure>

<p>As with the other PDUs, <a data-type="indexterm" data-primary="Ethernet" data-secondary="header and footers of" id="idm46219944920632"/><a data-type="indexterm" data-primary="footers, Ethernet" id="idm46219944919784"/><a data-type="indexterm" data-primary="headers" data-secondary="for Ethernet" data-secondary-sortas="Ethernet" id="idm46219944919176"/>Ethernet has a header and footers, as shown in <a data-type="xref" href="#ethernet-header">Figure 1-20</a>.</p>

<figure><div id="ethernet-header" class="figure">
<img src="Images/neku_0120.png" alt="ethernet header" width="1448" height="537"/>
<h6><span class="label">Figure 1-20. </span>Ethernet header and footer</h6>
</div></figure>

<p>Let’s review these in detail:</p>
<dl>
<dt><code>Preamble</code> (8 bytes)</dt>
<dd>
<p>Alternating string of ones and zeros indicate to the receiving host that a frame is incoming.</p>
</dd>
<dt><code>Destination MAC Address</code> (6 bytes)</dt>
<dd>
<p>MAC destination address; the Ethernet frame recipient.</p>
</dd>
<dt><code>Source MAC Address</code> (6 bytes)</dt>
<dd>
<p>MAC source address; the Ethernet frame source.</p>
</dd>
<dt><code>VLAN tag</code> (4 bytes)</dt>
<dd>
<p>Optional 802.1Q tag to <a data-type="indexterm" data-primary="VLAN (virtual local area network)" id="idm46219944908808"/><a data-type="indexterm" data-primary="local area network, virtual (VLAN)" id="idm46219944908200"/>differentiate traffic on the network segments.</p>
</dd>
<dt><code>Ether-type</code> (2 bytes)</dt>
<dd>
<p>Indicates which protocol is encapsulated in the payload of the frame.</p>
</dd>
<dt><code>Payload</code> (variable length)</dt>
<dd>
<p>The encapsulated IP packet.</p>
</dd>
<dt><code>Frame Check Sequence (FCS)</code> or <code>Cycle Redundancy Check (CRC)</code> (4 bytes)</dt>
<dd>
<p>The frame check sequence (FCS) is a four-octet
cyclic redundancy check (CRC) that allows the detection of corrupted data within the entire frame as received on the
receiver side. The CRC is part of the Ethernet frame footer.</p>
</dd>
</dl>

<p><a data-type="xref" href="#mac-address">Figure 1-21</a> shows that <a data-type="indexterm" data-primary="MAC (Media Access Control) sublayer" data-secondary="addresses of" id="idm46219944901624"/><a data-type="indexterm" data-primary="network interface card (NIC)" id="idm46219944900776"/><a data-type="indexterm" data-primary="NIC (network interface card)" data-secondary="and MAC addresses" data-secondary-sortas="MAC addresses" id="idm46219944900168"/><a data-type="indexterm" data-primary="organization unit identifier (OUI)" id="idm46219944899080"/><a data-type="indexterm" data-primary="OUI (organization unit identifier)" id="idm46219944898472"/>MAC addresses get assigned to network interface hardware at the time of manufacture. MAC
addresses have two parts: the organization unit identifier (OUI) and the NIC-specific parts.</p>

<figure><div id="mac-address" class="figure">
<img src="Images/neku_0121.png" alt="Mac Address" width="1072" height="890"/>
<h6><span class="label">Figure 1-21. </span>MAC address</h6>
</div></figure>

<p>The frame indicates to the recipient of the Network layer <a data-type="indexterm" data-primary="Ethernet" data-secondary="protocols" id="ch1_term69"/>packet type. <a data-type="xref" href="#common_ethertype_protocols">Table 1-7</a> details the <a data-type="indexterm" data-primary="IEEE 802 standards" id="idm46219944893240"/><a data-type="indexterm" data-primary="IPv4" data-secondary="Ethertype of" id="idm46219944892632"/><a data-type="indexterm" data-primary="IPv6" data-secondary="Ethertype of" id="idm46219944891784"/><a data-type="indexterm" data-primary="MAC (Media Access Control) sublayer" data-secondary="Ethertype of" id="idm46219944890936"/><a data-type="indexterm" data-primary="VLAN (virtual local area network)" id="idm46219944890088"/><a data-type="indexterm" data-primary="local area network, virtual (VLAN)" id="idm46219944889480"/>common protocols
handled. In <a data-type="indexterm" data-primary="Kubernetes" data-secondary="packet protocols for" id="idm46219944888744"/><a data-type="indexterm" data-primary="Address Resolution Protocol (ARP)" id="ch1_term67"/><a data-type="indexterm" data-primary="ARP (Address Resolution Protocol)" id="ch1_term68"/>Kubernetes, we are mostly interested in IPv4 and ARP packets. IPv6 has recently been introduced to
Kubernetes in the 1.19 release.</p>
<table id="common_ethertype_protocols">
<caption><span class="label">Table 1-7. </span>Common EtherType protocols</caption>
<thead>
<tr>
<th>EtherType</th>
<th>Protocol</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>0x0800</p></td>
<td><p>Internet Protocol version 4 (IPv4)</p></td>
</tr>
<tr>
<td><p>0x0806</p></td>
<td><p>Address Resolution Protocol (ARP)</p></td>
</tr>
<tr>
<td><p>0x8035</p></td>
<td><p>Reverse Address Resolution Protocol (RARP)</p></td>
</tr>
<tr>
<td><p>0x86DD</p></td>
<td><p>Internet Protocol version 6 (IPv6)</p></td>
</tr>
<tr>
<td><p>0x88E5</p></td>
<td><p>MAC security (IEEE 802.1AE)</p></td>
</tr>
<tr>
<td><p>0x9100</p></td>
<td><p>VLAN-tagged (IEEE 802.1Q) frame with double tagging</p></td>
</tr>
</tbody>
</table>

<p>When an IP packet reaches its destination network, the destination IP address is resolved with the Address Resolution
Protocol for IPv4 (Neighbor Discovery Protocol in the case of IPv6) into the destination host’s MAC address. The
Address Resolution Protocol must manage address translation from internet addresses to Link layer addresses on
Ethernet networks. The ARP table is for fast lookups for those known hosts, so it does not have to send an ARP
request for every frame the host wants to send out. <a data-type="xref" href="#arp_table">Example 1-8</a> shows the output of a local ARP table. All devices on
the network keep a cache of ARP addresses for this purpose.</p>
<div id="arp_table" data-type="example">
<h5><span class="label">Example 1-8. </span>ARP table</h5>

<pre data-type="programlisting" data-code-language="bash">○ → arp -a
? <code class="o">(</code>192.168.0.1<code class="o">)</code> at bc:a5:11:f1:5d:be on en0 ifscope <code class="o">[</code>ethernet<code class="o">]</code>
? <code class="o">(</code>192.168.0.17<code class="o">)</code> at 38:f9:d3:bc:8a:51 on en0 ifscope permanent <code class="o">[</code>ethernet<code class="o">]</code>
? <code class="o">(</code>192.168.0.255<code class="o">)</code> at ff:ff:ff:ff:ff:ff on en0 ifscope <code class="o">[</code>ethernet<code class="o">]</code>
? <code class="o">(</code>224.0.0.251<code class="o">)</code> at 1:0:5e:0:0:fb on en0 ifscope permanent <code class="o">[</code>ethernet<code class="o">]</code>
? <code class="o">(</code>239.255.255.250<code class="o">)</code> at 1:0:5e:7f:ff:fa on en0 ifscope permanent <code class="o">[</code>ethernet<code class="o">]</code></pre></div>

<p><a data-type="xref" href="#arp-request">Figure 1-22</a> shows the exchange between hosts on the local network. The browser makes an HTTP request for a website
hosted by the target server. Through DNS, it determines that the server has the IP address <code>10.0.0.1</code>. To continue
to send the HTTP request, it also requires the server’s MAC address. First, the requesting computer consults a cached ARP
table to look up <code>10.0.0.1</code> for any existing records of the server’s MAC address. If the MAC address is found, it sends an
Ethernet frame with the destination address of the server’s MAC address, containing the IP packet addressed to <code>10.0.0.1</code> onto
the link. If the cache did not produce a hit for <code>10.0.0.2</code>, the requesting computer must send a broadcast ARP request
message with a destination MAC address of <code>FF:FF:FF:FF:FF:FF</code>, which is accepted by all hosts on the local network,
requesting an answer for <code>10.0.0.1</code>. The server responds with an ARP response message containing its MAC and IP address. As part of answering the request, the server may insert an entry for requesting the computer’s MAC address into its ARP table
for future use. The requesting computer receives and caches the response information in its ARP table and can now send
the HTTP packets.</p>

<p>This also brings up a <a data-type="indexterm" data-primary="broadcast domains" id="idm46219944844952"/>crucial concept on the local networks, broadcast domains. All packets on the broadcast domain receive
all the ARP messages from hosts. In addition, all frames are sent all nodes on the broadcast, and the host compares the
destination MAC address to its own. It will discard frames not destined for itself. As hosts on the network grow, so
too does the broadcast traffic.<a data-type="indexterm" data-primary="tcpdump tool" data-secondary="with ARP requests" data-secondary-sortas="ARP requests" id="idm46219944843704"/></p>

<figure><div id="arp-request" class="figure">
<img src="Images/neku_0122.png" alt="ARP Request" width="1233" height="1163"/>
<h6><span class="label">Figure 1-22. </span>ARP request</h6>
</div></figure>

<p>We can use <code>tcpdump</code> to view all the ARP requests happening on the local network as in
<a data-type="xref" href="#arp_tcpdump">Example 1-9</a>. The packet capture details the ARP packets; the Ethernet type used, <code>Ethernet (len 6)</code>; and the
higher-level protocol, <code>IPv4</code>. It also includes who is requesting the MAC address of the IP <a data-type="indexterm" data-startref="ch1_term63" id="idm46219944837800"/>address, <code>Request who-has 192.168.0.1 tell 192.168.0.12</code>.</p>
<div id="arp_tcpdump" data-type="example">
<h5><span class="label">Example 1-9. </span>ARP <code>tcpdump</code></h5>

<pre data-type="programlisting" data-code-language="bash">○ → sudo tcpdump -i en0 arp -vvv
tcpdump: listening on en0, link-type EN10MB <code class="o">(</code>Ethernet<code class="o">)</code>, capture size <code class="m">262144</code> bytes
17:26:25.906401 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:27.954867 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:29.797714 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:31.845838 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:33.897299 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:35.942221 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:37.785585 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:39.628958 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.13, length 28
17:26:39.833697 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:41.881322 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:43.929320 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:45.977691 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
17:26:47.820597 ARP, Ethernet <code class="o">(</code>len 6<code class="o">)</code>, IPv4 <code class="o">(</code>len 4<code class="o">)</code>,
Request who-has 192.168.0.1 tell 192.168.0.12, length 46
^C
<code class="m">13</code> packets captured
<code class="m">233</code> packets received by filter
<code class="m">0</code> packets dropped by kernel</pre></div>

<p>To further <a data-type="indexterm" data-startref="ch1_term67" id="idm46219944789448"/><a data-type="indexterm" data-startref="ch1_term68" id="idm46219944788840"/>segment the layer 2 network, network engineers can use <a data-type="indexterm" data-primary="VLAN (virtual local area network)" id="idm46219944734648"/><a data-type="indexterm" data-primary="local area network, virtual (VLAN)" id="idm46219944734008"/>virtual local area network (VLAN) tagging.
Inside the Ethernet frame header is an optional VLAN tag that differentiates traffic on the LAN. It is useful to use
VLANs to break up LANs and manage networks on the same switch or different ones across the network campus. Routers
between VLANs filter broadcast traffic, enable network security, and alleviate network congestion. They are <a data-type="indexterm" data-primary="network administrators" id="idm46219944732792"/>useful to the
network administrator for those purposes, but Kubernetes network administrators <a data-type="indexterm" data-primary="VXLAN (virtual extensible LAN)" id="idm46219944731880"/>can use the extended version of the VLAN
technology known as a <em>virtual extensible LAN</em> (VXLAN).</p>

<p><a data-type="xref" href="#vxlan">Figure 1-23</a> shows how a VXLAN is an extension of a VLAN that allows network engineers to encapsulate layer 2 frames into layer 4 UDP packets. A VXLAN increases <a data-type="indexterm" data-primary="scaling" id="idm46219944729496"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="scaling with" id="idm46219944728824"/>scalability up to 16 million logical networks and allows for layer 2 adjacency across IP networks. This technology is used in Kubernetes networks to produce overlay networks, which you’ll learn more about in later chapters.</p>

<figure><div id="vxlan" class="figure">
<img src="Images/neku_0123.png" alt="VXLAN" width="667" height="398"/>
<h6><span class="label">Figure 1-23. </span>VXLAN packet</h6>
</div></figure>

<p>Ethernet also <a data-type="indexterm" data-primary="media for transmission" id="idm46219944725128"/>details the specifications for the medium to transmit frames on, such as twisted pair, coaxial
cable, optical fiber, wireless, or other transmission media yet to be invented, such as the gamma-ray network that powers the
Philotic Parallax Instantaneous Communicator.<sup><a data-type="noteref" id="idm46219944723976-marker" href="ch01.xhtml#idm46219944723976">2</a></sup> Ethernet even defines the encoding and signaling protocols used on the wire; this is out of scope for our proposes.</p>

<p>The Link layer has multiple other protocols involved from a network perspective. Like the layers discussed previously, we
have only touched the surface of the Link layer. We constrained this book to those details needed for a base
understanding of the Link layer for the Kubernetes <a data-type="indexterm" data-startref="ch1_term5" id="idm46219944721880"/><a data-type="indexterm" data-startref="ch1_term64" id="idm46219944721176"/><a data-type="indexterm" data-startref="ch1_term65" id="idm46219944720504"/><a data-type="indexterm" data-startref="ch1_term66" id="idm46219944719832"/><a data-type="indexterm" data-startref="ch1_term69" id="idm46219944719160"/>networking model.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Revisiting Our Web Server"><div class="sect2" id="idm46219944933256">
<h2>Revisiting Our Web Server</h2>

<p>Our journey through all the layers of TCP/IP is complete. <a data-type="xref" href="#all-headers">Figure 1-24</a> outlines <a data-type="indexterm" data-primary="PDU (Protocol Data Unit)" id="idm46219944716376"/><a data-type="indexterm" data-primary="Protocol Data Unit (PDU)" id="idm46219944715656"/><a data-type="indexterm" data-primary="TCP/IP" data-secondary="summary view of all layers in" id="ch1_term76"/><a data-type="indexterm" data-primary="layering" data-secondary="summary of TCP/IP" id="ch1_term77"/>all the headers and footers each
layer of the TCP/IP model produces to send data across the internet.</p>

<figure><div id="all-headers" class="figure">
<img src="Images/neku_0124.png" alt="Full view" width="1223" height="655"/>
<h6><span class="label">Figure 1-24. </span>TCP/IP PDU full view</h6>
</div></figure>

<p>Let’s review the <a data-type="indexterm" data-primary="client requests" data-secondary="with HTTP" data-secondary-sortas="HTTP" id="ch1_term71"/><a data-type="indexterm" data-primary="Golang (Go) web server" data-secondary="overview of TCP/IP layers with" id="ch1_term72"/><a data-type="indexterm" data-primary="HTTP" data-secondary="examples of requests with" id="ch1_term73"/><a data-type="indexterm" data-primary="networking" data-secondary="overview of basics" id="ch1_term74"/><a data-type="indexterm" data-primary="server responses" data-secondary="to HTTP requests" data-secondary-sortas="HTTP requests" id="ch1_term75"/>journey and remind ourselves again what is going on now that we understand each layer in detail.
<a data-type="xref" href="#EX1">Example 1-10</a> shows our web server again, and <a data-type="xref" href="#EX0111">Example 1-11</a> shows the cURL request for it from earlier in the chapter.</p>
<div id="EX1" data-type="example" class="less_space pagebreak-before">
<h5><span class="label">Example 1-10. </span>Minimal web server in Go</h5>

<pre data-type="programlisting" data-code-language="go"><code class="kn">package</code> <code class="nx">main</code>

<code class="kn">import</code> <code class="p">(</code>
	<code class="s">"fmt"</code>
	<code class="s">"net/http"</code>
<code class="p">)</code>

<code class="kd">func</code> <code class="nx">hello</code><code class="p">(</code><code class="nx">w</code> <code class="nx">http</code><code class="p">.</code><code class="nx">ResponseWriter</code><code class="p">,</code> <code class="nx">_</code> <code class="o">*</code><code class="nx">http</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="p">{</code>
	<code class="nx">fmt</code><code class="p">.</code><code class="nx">Fprintf</code><code class="p">(</code><code class="nx">w</code><code class="p">,</code> <code class="s">"Hello"</code><code class="p">)</code>
<code class="p">}</code>

<code class="kd">func</code> <code class="nx">main</code><code class="p">()</code> <code class="p">{</code>
	<code class="nx">http</code><code class="p">.</code><code class="nx">HandleFunc</code><code class="p">(</code><code class="s">"/"</code><code class="p">,</code> <code class="nx">hello</code><code class="p">)</code>
	<code class="nx">http</code><code class="p">.</code><code class="nx">ListenAndServe</code><code class="p">(</code><code class="s">"0.0.0.0:8080"</code><code class="p">,</code> <code class="kc">nil</code><code class="p">)</code>
<code class="p">}</code></pre></div>
<div id="EX0111" data-type="example">
<h5><span class="label">Example 1-11. </span>Client request</h5>

<pre data-type="programlisting" data-code-language="bash">○ → curl localhost:8080 -vvv
*   Trying ::1...
* TCP_NODELAY <code class="nb">set</code>
* Connected to localhost <code class="o">(</code>::1<code class="o">)</code> port 8080
&gt; GET / HTTP/1.1
&gt; Host: localhost:8080
&gt; User-Agent: curl/7.64.1
&gt; Accept: */*
&gt;
&lt; HTTP/1.1 <code class="m">200</code> OK
&lt; Date: Sat, <code class="m">25</code> Jul <code class="m">2020</code> 14:57:46 GMT
&lt; Content-Length: 5
&lt; Content-Type: text/plain<code class="p">;</code> <code class="nv">charset</code><code class="o">=</code>utf-8
&lt;
* Connection <code class="c">#0 to host localhost left intact</code>
Hello* Closing connection 0</pre></div>

<p>We begin with the <a data-type="indexterm" data-primary="packets" data-secondary="overview of client request with" id="idm46219944593880"/>web server waiting for a connection in <a data-type="xref" href="#EX1">Example 1-10</a>. cURL requests <a data-type="indexterm" data-primary="cURL/curl tool" data-secondary="client requests with" id="idm46219944592168"/>the HTTP server at <code>0.0.0.0</code> on port
8080. cURL determines the IP address and port number from the URL and proceeds to establish a TCP connection to the
server. Once the connection is set up, via a TCP handshake, cURL sends the HTTP request. When the web server
starts up, a <a data-type="indexterm" data-primary="sockets" data-secondary="in client request process" data-secondary-sortas="client request process" id="idm46219944585128"/>socket of 8080 is created on the HTTP server, which matches TCP port 8080; the same is done
on the cURL client side with a random port number. Next, this information is sent to the <a data-type="indexterm" data-primary="Network (Internet) layer, TCP/IP (L3)" data-secondary="overview of" id="idm46219944583592"/>Network layer, where
the source and destination IP addresses are attached to the packet’s IP header. At the <a data-type="indexterm" data-primary="Link layer (L2)" data-secondary="of TCP/IP" data-secondary-sortas="TCP/IP" id="idm46219944582376"/><a data-type="indexterm" data-primary="MAC (Media Access Control) sublayer" data-secondary="of Link layer" data-secondary-sortas="Link layer" id="idm46219944581160"/><a data-type="indexterm" data-primary="network interface card (NIC)" id="idm46219944579928"/><a data-type="indexterm" data-primary="NIC (network interface card)" data-secondary="and MAC addresses" data-secondary-sortas="MAC addresses" id="idm46219944579240"/>client’s Data Link layer, the source
MAC address of the NIC is added to the Ethernet frame. If the destination MAC address is unknown, an ARP request is
made to find it. Next, the NIC is used to transmit the Ethernet frames to the web server.</p>

<p>When the web server receives the request, it creates packets of data that contain the HTTP response. The packets are
sent back to the cURL process by routing them through the internet using the source IP address
on the request packet. Once received by the cURL process, the packet is sent from the device to the drivers. At
the Data Link layer, the MAC address is removed. At the <a data-type="indexterm" data-primary="Network (Internet) layer, TCP/IP (L3)" data-secondary="IP addresses and" id="idm46219944576968"/>Network Protocol layer, the IP address is verified and
then removed from the packet. For this reason, if an application requires access to the client IP, it needs to be
stored at the Application layer; the best example here is in HTTP requests and the X-Forwarded-For header. Now the socket
is determined from the TCP data and removed. The packet is then forwarded to the client application that creates that
socket. The client reads it and processes the response data. In this case, the socket ID was random, corresponding to
the cURL process. All packets are sent to cURL and pieced together into one HTTP response. If we were to use the <code>-O</code>
output option, it would have been saved to a file; otherwise, cURL outputs the response to the terminal’s standard out.</p>

<p>Whew, that is a mouthful, 50 pages and 50 years of networking condensed into two paragraphs! The basics of networking we have reviewed <a data-type="indexterm" data-startref="ch1_term71" id="idm46219944574152"/><a data-type="indexterm" data-startref="ch1_term72" id="idm46219944573448"/><a data-type="indexterm" data-startref="ch1_term73" id="idm46219944572776"/><a data-type="indexterm" data-startref="ch1_term74" id="idm46219944572104"/><a data-type="indexterm" data-startref="ch1_term75" id="idm46219944571432"/><a data-type="indexterm" data-startref="ch1_term76" id="idm46219944570760"/><a data-type="indexterm" data-startref="ch1_term77" id="idm46219944570088"/>are just the beginning but are required knowledge if you want to run
Kubernetes clusters and networks at scale.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46219958485304">
<h1>Conclusion</h1>

<p>The HTTP transactions modeled in this chapter happen every millisecond, globally, all day on the internet and
data center network. This is the type of scale that the Kubernetes networks’ APIs help developers abstract away into
simple YAML. Understanding the scale of the problem is our first in step in mastering the management of a Kubernetes
network. By taking our simple example of the Golang web server and learning the first principles of networking, you can
begin to wrangle the packets flowing into and out of your clusters.</p>

<p>So far, we have covered the following:</p>

<ul>
<li>
<p>History of networking</p>
</li>
<li>
<p>OSI model</p>
</li>
<li>
<p>TCP/IP</p>
</li>
</ul>

<p>Throughout this chapter, we discussed many things related to <a data-type="indexterm" data-primary="networking" data-seealso="TCP/IP" id="idm46219944563112"/>networks but only those needed to learn about using the
Kubernetes abstractions. There are <a data-type="indexterm" data-primary="Hunt, Craig" id="idm46219944561896"/><a data-type="indexterm" data-primary="TCP/IP Network Administration (Hunt)" id="idm46219944561224"/>several O’Reilly books about TCP/IP; <a href="https://oreil.ly/UIP62"><em>TCP/IP Network Administration</em></a> by Craig Hunt (O’Reilly) is a great in-depth read on
all aspects of TCP.</p>

<p>We discussed how networking evolved, walked through the OSI model, translated it to the TCP/IP stack, and with
that stack completed an example HTTP request. In the next chapter, we will walk through how this is implemented for the
client and server with Linux networking.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46219953252264"><sup><a href="ch01.xhtml#idm46219953252264-marker">1</a></sup> <a href="https://oreil.ly/Jgi2c">“Autonomous System (AS) Numbers”.</a> IANA.org. 2018-12-07. Retrieved 2018-12-31.</p><p data-type="footnote" id="idm46219944723976"><sup><a href="ch01.xhtml#idm46219944723976-marker">2</a></sup> In the movie <em>Ender’s Game</em>, they use the Ansible network to communicate across the galaxy instantly. Philotic Parallax Instantaneous Communicator is the official name of the Ansible network.</p></div></div></section></div></body></html>