- en: Chapter 2\. Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various methods a process can use to communicate with other processes.
    As an example of this, consider communication by reading and writing to the filesystem
    or by using Inter-Process Communication (IPC). But with these approaches, it’s
    only possible for a process to communicate with other processes on the same machine.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, processes are typically built to communicate directly with the network.
    This still allows for communication between processes on the same machine, but
    more importantly, it allows processes to communicate across a network. There are
    limited resources available to any given machine and far more resources available
    across multiple machines.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Jeff Bezos mandated in the early 2000s that Amazon services must expose APIs
    over the network. This is credited as transforming Amazon from a simple bookstore
    to the cloud behemoth that is AWS. This pattern is now embraced by tech companies
    everywhere, allowing teams to access data and innovate at an unprecedented rate.
  prefs: []
  type: TYPE_NORMAL
- en: A *protocol* is a standardized format for communicating between two parties.
    When communication happens without protocols involved, it’s inevitable that messages
    either won’t be interpreted correctly or won’t be understood at all. It’s almost
    always better to adhere to an industry standard than to create a protocol from
    scratch. It’s also better to embrace a smaller number of inter-service protocols
    within an organization to reduce the amount of implementation effort and API documentation.
  prefs: []
  type: TYPE_NORMAL
- en: The *Open Systems Interconnection* (OSI) model is a concept for describing the
    relationship between different layers of network protocols. Officially there are
    seven layers, though as you’ll see in this chapter, it’s often the case that more
    layers are needed to describe modern applications. By first examining this model
    in [Table 2-1](#table_osi_layers), you will better understand some of the concepts
    covered later. This book mostly discusses Layer 4, Layer 7, and the hypothetical
    Layer 8.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. The OSI layers
  prefs: []
  type: TYPE_NORMAL
- en: '| Layer | Name | Example |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *8* | *User* | *JSON, gRPC* |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | Application | HTTP, WebSocket |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | Presentation | MIME, ASCII, TLS |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Session | Sockets |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Transport | TCP, UDP |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Network | IP, ICMP |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | Data Link | MAC, LLC |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Physical | Ethernet, IEEE 802.11 |'
  prefs: []
  type: TYPE_TB
- en: This chapter looks at a few protocols that are often used for inter-service
    communication. The ubiquitous HTTP protocol is the first one discussed, as well
    as JSON, which it is frequently paired with. Various permutations of this protocol
    are also examined, such as securing it with TLS and enabling compression. Next,
    the GraphQL protocol is covered, which comes with a schema syntax and the ability
    to shape the JSON responses. Finally, the *Remote Procedure Call* (RPC) pattern
    is also looked at by using an implementation called gRPC.
  prefs: []
  type: TYPE_NORMAL
- en: The forms of communication covered in this chapter are examples of *synchronous
    communication*. With this approach, one service sends a request to another service
    and waits for the other service to reply. An alternative approach, *asynchronous
    communication*, is when a service doesn’t wait for a response to a message, like
    pushing a message into a queue.
  prefs: []
  type: TYPE_NORMAL
- en: Request and Response with HTTP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, HTTP (Layer 7) is a text-based protocol that sits atop TCP (Layer
    4), the go-to protocol chosen when delivery guarantees are required. The protocol
    is based on requests, generated by a client to initiate an HTTP conversation,
    as well as responses, which are returned from a server to the client. It was designed
    for browsers to consume content from websites. Over the years it has received
    many enhancements. It comes with semantics for dealing with compression, caching,
    errors, and even retries. Although it wasn’t exactly designed for API use, it’s
    certainly the most popular go-to protocol for communicating between networked
    services and one of the most popular protocols on which to build other protocols.
  prefs: []
  type: TYPE_NORMAL
- en: That last point comes up a few times in this chapter. HTTP is a protocol for
    transferring *hypermedia*, content such as images and HTML documents. This includes
    content discovered and navigated by a person, not necessarily application code.
    This “shortcoming” is considered throughout the next few sections.
  prefs: []
  type: TYPE_NORMAL
- en: There are many reasons why HTTP is the default protocol used for public-facing
    APIs. Most companies already have a website, so the HTTP-speaking infrastructure
    already exists. Browsers often need to consume such APIs, and there are only a
    few protocols that browsers can use. Testing an API endpoint can sometimes be
    done by visiting a URL with a browser—a tool that every developer already has
    installed.
  prefs: []
  type: TYPE_NORMAL
- en: The following section mostly examines the HTTP 1.1 protocol, which is arguably
    the most popular version used today.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Payloads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP, being a text-based protocol, allows communication using any platform or
    language that can communicate over TCP. This also allows me to embed the raw content
    of HTTP messages within the pages of this book. To generate a request, you might
    write code that looks like [Example 2-1](#ex_node_request).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-1\. Node.js request code
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Writing HTTP requests manually can be a bit of a chore. Luckily, most libraries
    handle serializing and deserializing the tough parts—namely, parsing headers and
    the request/status lines. [Example 2-2](#ex_http_request) shows the correlating
    HTTP request that was generated by the previous node application.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-2\. HTTP request
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first line is the request line.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Header/value pairs, separated by colons.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_protocols_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Two new lines then the (optional) request body.
  prefs: []
  type: TYPE_NORMAL
- en: This is the raw version of an HTTP request. It’s much simpler than a typical
    request you’ll see in a browser, lacking items such as cookies and the myriad
    default headers inserted by modern browsers. Each newline is represented as a
    combination carriage return character and line feed character (`\r\n`). Responses
    look fairly similar to requests. [Example 2-3](#ex_http_response) shows a response
    that could correlate to the previous request.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-3\. HTTP response
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The first line is the response line.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Header/value pairs, separated by colons.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_protocols_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Two new lines, then the response body (also optional).
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Semantics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTTP has several important semantics built in. It is these semantics that, given
    enough time, any hand-rolled protocol ultimately ends up rebuilding. Ultimately
    it is because of these semantics and their universal understanding that many other
    protocols end up being built on top of HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP methods
  prefs: []
  type: TYPE_NORMAL
- en: This value is the first word in the request line. In [Example 2-2](#ex_http_request),
    the method is `POST`. There are several HTTP methods, and the other popular ones
    include `GET`, `PATCH`, and `DELETE`. These methods map to the basic CRUD operations
    (Create, Read, Update, and Delete), generic concepts that can be applied to almost
    all stateful data stores. By having applications adhere to the intentions of the
    HTTP methods, it’s possible for an outside observer to infer what the intent of
    a particular request is.
  prefs: []
  type: TYPE_NORMAL
- en: Idempotency
  prefs: []
  type: TYPE_NORMAL
- en: This is a fancy word meaning that an operation can be executed multiple times
    without risk of side effects. The HTTP methods `GET`, `PATCH`, and `DELETE` are
    each considered idempotent operations. If the result of an operation using one
    of those methods is unknown, for example, a network failure prevents the response
    from being received, then it is considered safe for a client to retry the same
    request.
  prefs: []
  type: TYPE_NORMAL
- en: Status codes
  prefs: []
  type: TYPE_NORMAL
- en: Another important concept is that of status codes, and in particular, status
    code ranges. A status code is the three digit number present in the response line.
    In [Example 2-3](#ex_http_response), the status code is 403\. An overview of these
    status code ranges is available in [Table 2-2](#table_status_codes).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. HTTP status code ranges
  prefs: []
  type: TYPE_NORMAL
- en: '| Range | Type | Examples |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 100–199 | Information | 101 Switching Protocols |'
  prefs: []
  type: TYPE_TB
- en: '| 200–299 | Success | 200 OK, 201 Created |'
  prefs: []
  type: TYPE_TB
- en: '| 300–399 | Redirect | 301 Moved Permanently |'
  prefs: []
  type: TYPE_TB
- en: '| 400–499 | Client error | 401 Unauthorized, 404 Not Found |'
  prefs: []
  type: TYPE_TB
- en: '| 500–599 | Server error | 500 Internal Server Error, 502 Bad Gateway |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The text that follows a status code is called the Reason Phrase. Any popular
    Node.js HTTP framework will infer which text to use based on the numeric status
    code your application specifies. The value is unused by modern software, and HTTP/2,
    the successor to HTTP 1.1, doesn’t provide such a value.
  prefs: []
  type: TYPE_NORMAL
- en: Client versus server errors
  prefs: []
  type: TYPE_NORMAL
- en: The status code provides some very useful information. For example, the status
    range 400–499 dictates that the client made a mistake, while the status range
    500–599 blames the server. This informs the client that if an operation is attempted,
    and the server decides the client made a mistake, that the client shouldn’t attempt
    to send the request again. This can happen if the client were to violate the protocol
    in some manner. However, when a server error happens, the client should feel free
    to try idempotent requests again. This could be due to a temporary error with
    the server, such as it being overwhelmed with requests or losing a database connection.
    In [“Idempotency and Messaging Resilience”](ch08.html#ch_resilience_sec_messaging)
    you will implement custom logic for retrying HTTP requests based on these status
    codes.
  prefs: []
  type: TYPE_NORMAL
- en: Response caching
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP also hints at how responses can be cached. Typically, the only responses
    that get cached, especially by intermediary services, are those associated with
    a `GET` request. If there’s an error code associated with a response, then it
    probably shouldn’t be cached. HTTP goes even further and conveys how long a response
    should be cached. The `Expires` header tells the client a particular date and
    time by which to discard the cached value. This system isn’t entirely perfect,
    though. Additional semantics could be applied to caching. For example, if user
    #123 requests a document with information specific to their bank account, it can
    be difficult to know that the cached result shouldn’t also be supplied to user
    #456.'
  prefs: []
  type: TYPE_NORMAL
- en: Statelessness
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is inherently a stateless protocol. This means that by sending one message,
    the meaning of a future message won’t change. It’s not like, say, a terminal session
    where you might list the files in the current directory with `ls`, change directory
    with `cd`, and then issue the same exact `ls` command but get different output.
    Instead, every request contains all the information it needs to set the desired
    state.
  prefs: []
  type: TYPE_NORMAL
- en: There *are* conventions for simulating state over HTTP. For example, by making
    use of a header like `Cookie` and setting a unique session identifier, state about
    the connection can be maintained in a database. Other than basic authentication
    information, it’s usually not appropriate to require clients that provide such
    stateful session tokens when using an API.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Compression
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is possible to compress the HTTP response body in order to reduce the amount
    of data sent over the network. This is another built-in feature of HTTP. When
    a client supports compression, it can choose to supply the `Accept-Encoding` header.
    The server, upon encountering the header, can then choose to compress the response
    body using whichever compression algorithm was supplied in the request. The gzip
    compression algorithm is the ubiquitous form of HTTP compression, though other
    algorithms such as brotli may offer higher compression values. The response contains
    a header specifying which algorithm the server used, such as `Content-Encoding:
    br` for brotli.'
  prefs: []
  type: TYPE_NORMAL
- en: Compression is a trade-off between network payload size and CPU usage. Typically,
    it’s in your best interest to support HTTP compression at some point between the
    Node.js server and whatever client is consuming the data, especially if this is
    traffic being consumed by a third party over the internet. However, Node.js is
    not the most efficient tool for performing compression. This is a CPU-heavy operation
    and should be handled outside of the Node.js process whenever possible. [“Reverse
    Proxies with HAProxy”](ch03.html#ch_scaling_sec_rp) looks at using a tool called
    a *reverse proxy* to automatically handle HTTP compression. [“SLA and Load Testing”](ch03.html#ch_scaling_sec_bm)
    looks at some benchmarks to prove this performance claim.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-4](#ex_node_gzip)^([1](ch02.html#idm46291204847576)) provides a
    demonstration of how to create such a server that performs gzip compression in-process.
    It only uses built-in Node.js modules and doesn’t require a package install. Any
    popular HTTP framework has its own idiomatic approach for implementing compression,
    usually just a `require` and a function call away, but under the hood they’re
    all essentially doing the same thing.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-4\. *server-gzip.js*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you’re ready to test this server. First create an *index.html* file to
    serve and then start the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, run the following commands in a separate terminal window to view the
    output from the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: These `curl` commands act as a client communicating with the service over the
    network. The service prints whether or not a request used compression to help
    explain what’s happening. In this particular example, the compressed version of
    the file is actually larger than the uncompressed version! You can see this happening
    by running the two commands in [Example 2-5](#ex_request_wc).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-5\. Comparing compressed versus uncompressed requests
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the uncompressed version of the document is 40 bytes, and the
    compressed version is 53 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: With larger documents, this won’t be an issue. To prove this, run the previous
    `echo` command three more times to increase the *index.html* file size. Then,
    run the same commands in [Example 2-5](#ex_request_wc) again. This time the uncompressed
    version is 160 bytes and the compressed version is 56 bytes. This is because gzip
    operates by removing redundancies in the response bodies, and the example contains
    the same text repeated four times. This redundancy removal is particularly useful
    if a response body contains redundant text, like a JSON document with repeating
    attribute names. Most gzip compression tools can be configured to be bypassed
    if a document is smaller than a certain size.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP compression only compresses the body of the request. It does not affect
    the HTTP headers (short of changing the value in the `Content-Length` header).
    In the world of service-to-service APIs with a finite set of intentional HTTP
    headers, this isn’t that big of a deal. However, when it comes to web browsers,
    it isn’t uncommon to end up with HTTP requests containing several kilobytes of
    headers (just think of all those tracking cookies). HTTP/2 was invented to address
    situations like that and uses HPACK to compress headers.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS / TLS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another form of encoding is encryption. Transport Layer Security (TLS) is the
    protocol used for encrypting HTTP traffic. It’s what puts the *S* (secure) in
    *HTTPS*. Unlike gzip compression, TLS does encapsulate the HTTP headers as well.
    Much like gzip, TLS is a CPU-intensive operation and should also be performed
    by an external process such as a Reverse Proxy. TLS supplants the obsolete Secure
    Sockets Layer (SSL) protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'TLS works by using certificates. There are two types of certificates: one containing
    a public key, which can safely be given to anyone in the world, and one containing
    a private key, which should remain a secret. These two keys are inherently paired.
    Anyone can take a message and encrypt it using the public key, but only someone
    with the private key can then decrypt the message. With HTTP, this means a server
    will provide its public key, and a client will encrypt requests using the public
    key. When the client first communicates with the server, it also generates a large
    random number, essentially a password for the session, which is encrypted with
    the public key and sent to the server. This temporary password is used to encrypt
    the TLS session.'
  prefs: []
  type: TYPE_NORMAL
- en: Generating certificates and enabling them with a server can take some effort
    to implement. Traditionally, it was even an expensive feature that had to be paid
    for. Nowadays there is a service called [Let’s Encrypt](https://oreil.ly/OXEmD)
    that not only automates the process but also makes it free. A caveat of this service
    is that the tool requires a server to be publicly exposed to the internet to verify
    DNS ownership of the domain. This makes it difficult to encrypt internal services,
    even though it is the clear winner for public services.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to do some hands-on work with TLS. The easiest way to get an HTTPS
    server running locally is to generate a self-signed certificate, have your server
    read that certificate, and have a client make a request to the server without
    performing certificate validation. To generate your own certificate, run the command
    in [Example 2-6](#ex_generate_cert). Feel free to use any values you like, but
    use `localhost` when prompted for a *common name*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-6\. Generating a self-signed certificate
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command creates two files, namely *basic-private-key.key* (the private
    key) and *basic-certificate.cert* (the public key).
  prefs: []
  type: TYPE_NORMAL
- en: Next, copy the *recipe-api/producer-http-basic.js* service that you made in
    [Example 1-6](ch01.html#ex_producer) to a new file named *recipe-api/producer-https-basic.js*
    to resemble [Example 2-7](#ex_node_server_https). This is an HTTPS server built
    entirely with Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-7\. *recipe-api/producer-https-basic.js*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The web server is now configured to enable HTTPS and read the certificate files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve created the server file, run the server and then make a request
    to it. You can do this by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: That `--insecure` flag probably caught your attention. In fact, if you were
    to open the URL directly in a web browser, you would get a warning that there
    is a problem with the certificate. This is what happens when a certificate is
    self-signed.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to make a request to this service using a Node.js application,
    the request would also fail. The inner Node.js `http` and `https` modules accept
    an options argument, and most higher-level HTTP libraries in npm accept those
    same options in some manner. One such way to avoid these errors is to provide
    the `rejectUnauthorized: false` flag. Unfortunately, this isn’t much more secure
    than using plain HTTP and should be avoided.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason all this matters is that it’s not necessarily safe to trust just
    any old certificate encountered on the internet. Instead, it’s important to know
    that a certificate is valid. This is usually done by having one certificate “sign”
    another certificate. This is a way of saying that one certificate is vouching
    for the other. As an example of this, the certificate for *thomashunter.name*
    has been signed for by another certificate called *Let’s Encrypt Authority X3*.
    That certificate has been signed by another one called *IdenTrust DST Root CA
    X3*. The three certificates form a *chain of trust* (see [Figure 2-1](#fig_certificate_chain)
    for a visualization of this).
  prefs: []
  type: TYPE_NORMAL
- en: '![Visualization of the certificate chain of trust](assets/dsnj_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. The certificate chain of trust
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The highest point in the chain is called the root certificate. This certificate
    is trusted by much of the world; in fact, its public key is included in modern
    browsers and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach to working with self-signed certificates is to actually give
    the client a copy of the trusted self-signed certificate, in this case the *basic-certificate.cert*
    file generated previously. This certificate can then be passed along by using
    the `ca: certContent` options flag. An example of this can be seen in [Example 2-8](#ex_node_client_https).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-8\. *web-api/consumer-https-basic.js*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The client is now trusting the exact public key used by the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the *web-api* service and make an HTTP request to it by running the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `curl` command talks to *web-api* using HTTP, and *web-api* then talks to
    *recipe-api* using HTTPS.
  prefs: []
  type: TYPE_NORMAL
- en: Recall from [Example 2-7](#ex_node_server_https) that each HTTPS server needs
    access to both the public and private key in order to receive requests. Also recall
    that a private key should never fall into the hands of an adversary. So, having
    a single pair of public and private keys for all services within a company is
    dangerous. If just one of the projects leaks its private key, then all projects
    are affected!
  prefs: []
  type: TYPE_NORMAL
- en: 'One approach is to generate a new key for every single running service. Unfortunately,
    a copy of every server’s public key would need to be distributed to every client
    that might want to communicate with it, like in [Example 2-8](#ex_node_client_https).
    This would be quite a maintenance nightmare! Instead, the approach used by non-self-signed
    certificates can be emulated: generate a single internal root certificate, keep
    the private key for that secure, but use it to sign each service’s set of keys.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the commands in [Example 2-9](#ex_private_ca) to do exactly this. These
    commands represent a condensed version of what you might do within an organization.
    The steps noted with *CSR* would be run on a very private machine, one that is
    just used for certificate generation purposes. The steps noted with *APP* would
    be performed on behalf of the new application.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-9\. How to be your own Certificate Authority
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '*CSR*: Generate a private key *ca-private-key.key* for the Certificate Authority.
    You’ll be prompted for a password.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '*CSR*: Generate a root cert *shared/tls/ca-certificate.cert* (this will be
    provided to clients). You’ll get asked a lot of questions, but they don’t matter
    for this example.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_protocols_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: '*APP*: Generate a private key *producer-private-key.key* for a particular service.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_protocols_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: '*APP*: Create a CSR *producer.csr* for that same service. Be sure to answer
    `localhost` for the *Common Name* question, but other questions don’t matter as
    much.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_protocols_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: '*CSR*: Generate a service certificate *producer-certificate.cert* signed by
    the CA.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now modify the code in *web-api/consumer-https-basic.js* to load the *ca-certificate.cert*
    file. Also modify *recipe-api/producer-https-basic.js* to load both the *producer-private-key.key*
    and *producer-certificate.cert* files. Restart both servers and run the following
    command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You should get a successful response, even though *web-api* wasn’t aware of
    the *recipe-api* service’s exact certificate; it gains its trust from the root
    *ca-certificate.cert* certificate instead.
  prefs: []
  type: TYPE_NORMAL
- en: JSON over HTTP
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Up to this point, the body of HTTP requests and responses hasn’t really been
    examined. This is because the HTTP standard doesn’t dictate quite as much what
    goes in the body of an HTTP message. As I mentioned earlier, HTTP is a protocol
    that many other protocols end up being built on top of. This is where the mystical
    Layer 8 of the OSI model comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular APIs written today are *JSON over HTTP*, a pattern that is
    often—usually mistakenly—referred to as *REST* (Representational State Transfer).
    The small JSON payloads you’ve been sending back and forth in the example applications
    are an example of JSON over HTTP.
  prefs: []
  type: TYPE_NORMAL
- en: Simply communicating by JSON over HTTP leaves a lot to be desired. For example,
    how are errors represented? Certainly the HTTP error status codes should be leveraged
    and general semantics should be followed, but what payload should actually be
    used for the body? What is the correct way to represent a particular internal
    object in JSON? What about meta information that doesn’t map cleanly to HTTP headers,
    such as pagination data? The problem with JSON over HTTP, as well as many APIs
    touting the REST label, is that the entirety of the contract between producer
    and consumer exists in documentation. A human must read the docs and manually
    write code to interact with these payloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another issue is that every JSON over HTTP service is going to implement things
    differently. Short of having a `Content-Type: application/json` header, anything
    can happen between that first and last curly brace. This usually requires that
    each new service consumed by a particular client must have new code written.'
  prefs: []
  type: TYPE_NORMAL
- en: For a more concrete example, consider pagination. The loose concept of “JSON
    over HTTP” doesn’t have a built-in way to handle this. The Stripe API uses the
    query parameters `?limit=10&starting_after=20`. Meta information is provided in
    the response body, such as the `has_more` boolean property that lets the client
    know that there is more data to paginate. The GitHub API, on the other hand, uses
    the query parameters `?per_page=10&page=3`. Meta information about pagination
    is provided in the `Link` response header.
  prefs: []
  type: TYPE_NORMAL
- en: It’s because of these reasons that different standards for representing request
    and response bodies in HTTP have been invented. [JSON:API](https://jsonapi.org/format/),
    [JSON Schema](http://json-schema.org/specification.html), and [OpenAPI (Swagger)](https://swagger.io/specification/)
    are specifications that fully embrace JSON over HTTP and attempt to bring order
    to chaos. They deal with concepts like describing request and response bodies
    and, to a varying extent, how to interact with an HTTP API server. The next two
    sections deal with GraphQL and gRPC, which are more extreme protocol changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[“JSON over HTTP benchmarks”](ch03.html#ch_scaling_sec_bm_subsec_protocol_json)
    contains benchmarks on communicating between two servers using JSON over HTTP.'
  prefs: []
  type: TYPE_NORMAL
- en: The Dangers of Serializing POJOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript makes it dangerously easy to serialize an in-memory representation
    of a domain object. By simply calling `JSON.stringify(obj)`—which is what most
    HTTP frameworks automatically do for you—any refactoring of your project’s internal
    properties can leak out and result in API breaking changes. It can also result
    in leaking secrets.
  prefs: []
  type: TYPE_NORMAL
- en: A much better approach is to add a safety net to objects for manually controlling
    how they’re to be represented in JSON—a pattern called *marshalling*. This can
    be achieved by representing serializable data as a class with a `toJSON()` method,
    instead of storing data as a POJO (Plain Ol’ JavaScript Object).
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of this, here are two ways to represent a `User` object within
    your codebase. The first one is a POJO, and the second is a class with a `toJSON()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In both of these situations, when the response is sent, a consumer of the service
    will receive a JSON string representing an object with the same properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Perhaps at some point the application is modified to start tracking the user’s
    password as well. This might be done by adding a new `password` attribute to instances
    of the user object, perhaps by modifying the code where a user instance is created,
    setting the password at creation time. Or perhaps some dark corner of the codebase
    is setting the password by calling `user.password = value`. Such a change can
    be represented like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When this happens, the POJO is now leaking private information to consumers.
    The class with explicit marshalling logic is not leaking such details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Even if there are tests that check the HTTP response messages for the presence
    of values like `username` and `email`, they probably won’t fail when a new attribute
    like `password` has been added.
  prefs: []
  type: TYPE_NORMAL
- en: API Facade with GraphQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GraphQL is a protocol for querying APIs, designed by Facebook. It’s very useful
    for building *facade services*—which is one service that sits in front of multiple
    other services and data sources. GraphQL attempts to solve several issues present
    with traditional ad hoc implementations of JSON over HTTP APIs. GraphQL is particularly
    good at returning the smallest amount of data needed by a client. It’s also good
    at hydrating a response payload with data from multiple sources so that a client
    can get everything it needs while making a single request.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL doesn’t dictate that a particular underlying protocol be used. Most
    implementations, and the implementation used in this section, do use GraphQL over
    HTTP, but it’s just as happy being consumed over another protocol like TCP. An
    entire GraphQL query is described using a single string, much like with an SQL
    query. When implementations are built on top of HTTP they often use a single endpoint,
    with clients sending queries via the `POST` method.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL responses are usually provided using JSON, but again, a different response
    type could be used as long as it’s able to represent a hierarchy of data. These
    examples use JSON as well.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of today, it’s more common to expose JSON over HTTP APIs to the public. GraphQL
    APIs are more likely to be consumed by clients maintained by the same organization—such
    as internal usage or mobile first-party apps. This is beginning to change, however,
    and more companies are beginning to expose public GraphQL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Schema
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A GraphQL schema is a string that describes all the interactions a particular
    GraphQL server is able to make. It also describes all the objects a server can
    represent, as well as the types of those objects (such as `String` and `Int`).
    There are essentially two classifications of these types; a type is either a primitive
    or it is a named object. Every named object will need an entry in the schema;
    no objects can be used that aren’t named and described. Create a new file name
    *schema.gql* and enter the contents of [Example 2-10](#ex_graphql_schema) into
    this file.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-10\. *shared/graphql-schema.gql*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Top-level query representation.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Recipe` type.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_protocols_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: A `Recipe` has `Ingredient` children in an array called `ingredients`.
  prefs: []
  type: TYPE_NORMAL
- en: The first entry, `Query`, represents the root of the query provided by the consumer.
    In this case the consumer can essentially ask for two different sets of information.
    The `pid` entry returns an integer. The other entry, `recipe`, returns a `Recipe`
    type, which was defined in the schema document. This call accepts an argument
    when it is being queried. In this case the schema is stating that by calling the
    `recipe` method with an argument named `id`, an object following the `Recipe`
    schema is returned. [Table 2-3](#table_graphql_scalars) contains a list of scalar
    types used by GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-3\. GraphQL scalars
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Examples | JSON equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Int` | 10, 0, -1 | Number |'
  prefs: []
  type: TYPE_TB
- en: '| `Float` | 1, -1.0 | Number |'
  prefs: []
  type: TYPE_TB
- en: '| `String` | “Hello, friend!\n” | String |'
  prefs: []
  type: TYPE_TB
- en: '| `Boolean` | true, false | Boolean |'
  prefs: []
  type: TYPE_TB
- en: '| `ID` | “42”, “975dbe93” | String |'
  prefs: []
  type: TYPE_TB
- en: The `Recipe` object is then described in further detail in the next block. This
    block contains an `id` property, which is an `ID`. By default the fields are nullable—if
    the client asks for the value and the server doesn’t provide the value, then it
    will be coerced to null. The `!` character states that the server must provide
    the field. `Recipe` also has `name` and `steps` properties that are strings (`String`).
    Finally, it has a property named `ingredients`, which contains an array of `Ingredient`
    entries. The next block describes the `Ingredient` object and contains its own
    properties. This schema resembles the response used so far in the example applications.
  prefs: []
  type: TYPE_NORMAL
- en: Queries and Responses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, you’ll look at what a query for interacting with this data might look
    like, as well as the response payloads. Queries in GraphQL have a very useful
    feature in that the consumer gets to specify exactly what properties it is looking
    for. Another convenient feature is that there is never any surprise in the format
    of the response data; the nested query hierarchy ends up being in the same shape
    as the resulting data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, consider a very basic example where only the `pid` value should be retrieved
    from the server. The query to do so looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'An example response payload that matches the previous query would then resemble
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The outermost “envelope” object, the one that contains `data`, is there to help
    disambiguate meta information about the response from the response itself. Remember
    that GraphQL isn’t tied to HTTP, which provides concepts such as errors, so the
    response payloads must be able to differentiate a successful response from an
    error (if this query had an error, there would be no `data` property in the root,
    but there would be an `errors` array).
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that the recipe data isn’t displayed at all, even though it was
    defined in the root `Query` type in the GraphQL schema. Again, this is because
    queries specify exactly which fields should be returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Up next is a more complicated query. This query will get a specific recipe
    based on its ID. It will also get information about the ingredients that belong
    to that recipe. The query would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This query states that it wants an instance of the recipe having an `id` of
    42\. It also wants the `name` of that recipe, but not the `id` or the `steps`
    properties, and wants access to the ingredients, specifically their `name` and
    `quantity` values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The response payload for this query would then look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Again, notice how the nested request query follows the same shape as the nested
    JSON response. Assuming the developer who is writing the query is aware of the
    schema, that developer can safely write any query and know if it will be valid
    or not, know the shape of the response, and even know the types of every property
    in the response.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the `graphql` npm package provides a web REPL specifically for writing
    and testing queries. The name of this interface is *GraphiQL*, a play on “GraphQL”
    and “graphical.”
  prefs: []
  type: TYPE_NORMAL
- en: The `graphql` package is the official package for building GraphQL services
    in Node.js. It’s also the official reference implementation for GraphQL as a whole,
    as GraphQL isn’t tied to a specific language or platform. The following code samples
    make use of the `fastify-gql` package. This package lets GraphQL work with Fastify
    in a convenient manner, but it is essentially a wrapper around the official `graphql`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Producer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve seen some sample queries and their responses, you’re ready to
    write some code. First, create a new *recipe-api* service file based on the content
    in [Example 2-11](#ex_graphql_producer).
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-11\. *recipe-api/producer-graphql.js*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The schema file is provided to the `graphql` package.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `resolvers` object tells `graphql` how to build responses.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_protocols_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Query` entry represents the top-level query.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_protocols_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `Recipe` resolver is run when a `Recipe` is retrieved.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_protocols_CO7-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Fastify uses `server.register()` with the `fastify-gql` package; other frameworks
    have their own conventions.
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL code gets registered with the Fastify server on the `server.register`
    line. This ends up creating a route that listens at `/graphql` for incoming requests.
    It is this endpoint that the consumer will later send queries to. The following
    object configures GraphQL with the content of the *shared/graphql-schemal.gql*
    file, a reference to the `resolvers` object (covered shortly), and a final `graphiql`
    flag. This flag, if true, enables the GraphiQL console mentioned earlier. With
    the service running, that console can be visited at *http://localhost:4000/graphiql*.
    Ideally, you’d never set that value to true for a service running in production.
  prefs: []
  type: TYPE_NORMAL
- en: Now it’s time to consider the `resolvers` object. This object has properties
    at the root that correlate to the different types described in the GraphQL schema.
    The `Query` property describes the top-level queries, whereas the `Recipe` describes
    the Recipe objects. Each property of those two objects is an asynchronous method
    (methods that are awaited somewhere else in the code). That means these methods
    can return a promise, they can be an `async` function, or they can just return
    a simple value. There’s no databases involved in this example, so each method
    runs synchronously and returns a simple value.
  prefs: []
  type: TYPE_NORMAL
- en: When these methods are called, GraphQL provides arguments about the context
    in which they’re being called. Consider the `resolvers.Query.recipe` method, for
    example. The first argument in this case is an empty object since it’s called
    at the root of the query. However, the second argument is an object representing
    the arguments being made to this function. In the schema file, a `recipe()` is
    defined as accepting an argument named `id` that accepts an ID and as returning
    a `Recipe` type. So, within this method, the `id` is provided as an argument.
    It’s also expected to return an object adhering to the `Recipe` shape.
  prefs: []
  type: TYPE_NORMAL
- en: In the schema, you’ve defined the `Recipe` as having `id`, `name`, `steps`,
    and `ingredients` properties. So, in the object you’re returning, each of the
    scalar values have been specified. However, the `ingredients` property hasn’t
    been defined. That will be picked up by `resolvers.Recipe` automatically when
    the GraphQL code runs.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL enforces that the JSON response from the request matches the incoming
    query shape. If the response object in the `recipe()` method were modified to
    have an additional property called `serves`, GraphQL would automatically strip
    out that unknown value before the response is sent to the client. Additionally,
    if the client didn’t request either of the known `id` or `name` values, they would
    also be stripped from the response.
  prefs: []
  type: TYPE_NORMAL
- en: Once the GraphQL code has run the `resolvers` and has recieved the top-level
    recipe it expects from the `recipe()` method call, and assuming the client has
    requested the `ingredients`, it’s now ready to call the code to hydrate those
    ingredient values. This is performed by calling the `resolvers.Recipe.ingredients`
    method. In this case, the first argument now contains information about the parent
    object, here the top-level `Recipe` instance. The object provided contains all
    of the information that was returned from the `recipe()` method call (in this
    example, the `id`, `name`, and `steps` values). The `id` is typically the most
    useful value. If this application were backed by a database, then the `id` could
    be used to make a database query and get the related `Ingredient` entries. However,
    this simple example just uses hard-coded values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each of the methods described within the `resolvers` object can be called asynchronously.
    GraphQL is smart enough to call them all essentially in parallel, allowing your
    application to make multiple outbound asynchronous calls to get data from other
    sources. Once the slowest request is finished, then the overall query can complete
    and a response can be sent to the consumer.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL Consumer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’re familiar with building a producer that provides a GraphQL interface,
    it’s time to look at what it takes to build a consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Building a consumer is a bit simpler. There are npm packages to help with the
    query generation, but interacting with a GraphQL service is simple enough that
    you can simply rebuild it using basic tools.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 2-12](#ex_graphql_consumer) creates a new *web-api* consumer. The
    most important part of this example is the query that will be sent. It’s also
    going to make use of *query variables*, which are a GraphQL equivalent to *query
    parameters* in SQL. Variables are useful because, much like SQL, it’s dangerous
    to manually concatenate strings together to combine dynamic data, like user-supplied
    values, with static data, such as query code.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-12\. *web-api/consumer-graphql.js*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s a more complex query that accepts arguments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The request body is JSON encapsulating the GraphQL query.
  prefs: []
  type: TYPE_NORMAL
- en: This example makes a `POST` request and sends a JSON payload to the server.
    This payload contains both the query and the variables. The `query` property is
    the GraphQL query string, and the `variables` property contains a mapping of variable
    names with their values.
  prefs: []
  type: TYPE_NORMAL
- en: The `complex_query` being sent is asking for almost every piece of data the
    server supports. It’s also using a more complex syntax for specifying which variables
    will be used in the query. In this case it names the query `kitchenSink`, which
    can be useful for debugging. The arguments for the query are defined after the
    name, in this case it’s declared that there’s a variable named `$id` that is of
    type ID. That variable is then passed into the `recipe()` method. The `variables`
    property of the request body contains a single variable. In this section the variable
    doesn’t need to be prefixed with a `$`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve modified the two files, run both of the services and then make
    a request to the consumer service by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll then receive a reply that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: GraphQL offers many more features than those listed in this section. For example,
    it includes a feature called *mutations*, which allows a client to modify documents.
    It also has a feature called *subscription*, which allows a client to subscribe
    to and receive a stream of messages.
  prefs: []
  type: TYPE_NORMAL
- en: '[“GraphQL benchmarks”](ch03.html#ch_scaling_sec_bm_subsec_protocol_graphql)
    contains benchmarks on communicating between two servers using GraphQL.'
  prefs: []
  type: TYPE_NORMAL
- en: RPC with gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Patterns like REST—and to an extent GraphQL—attempt to abstract away the underlying
    functionality provided by a producer and essentially expose an API driven by data
    and CRUD operations. Despite all the complexity within the service, the consumer
    is left with an interface with a lot of nouns and very few verbs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an API with a RESTful interface might allow a consumer to create
    an invoice. Such an operation might be performed by using the `POST` method in
    combination with a route named `/invoice`. But how does the producer allow the
    consumer to send an email to the user when the invoice is created? Should there
    be a separate endpoint for invoice emails? Should there be a property on an invoice
    record called `email` that, when set to true during create time, triggers the
    email? There often isn’t a perfect way to represent application functionality
    using the methods provided by HTTP. This is when it might make sense to reach
    for a new pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '*Remote Procedure Call (RPC)* is such a pattern. Unlike HTTP, which offers
    a very finite list of verbs, RPC is essentially free to support whatever verb
    the developer desires. If you think about the heart of the application, the aforementioned
    `POST /invoice` route ends up calling some code deeper within the application.
    There very well could be a correlating method called `create_invoice()` within
    the code. With RPC, instead of going through the work to create a different interface,
    you can expose that method, almost in its raw form, to the network.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, RPC works by choosing which functions in the application to expose,
    and creating a mapping between these functions to some sort of network interface.
    Of course, it’s not as straightforward as simply exposing the functions to the
    network. Such methods need to be very rigorous about what type of data they accept
    and who they accept it from (just like an HTTP endpoint should).
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular standards for providing networked RPC endpoints between
    services is Google’s [gRPC](https://grpc.io). gRPC is typically served over HTTP/2\.
    Unlike GraphQL, which uses a single HTTP endpoint, gRPC uses the endpoint to determine
    what method to call.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol Buffers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike JSON over HTTP and GraphQL, gRPC typically doesn’t deliver messages over
    plain text. Instead, it transfers the data using Protocol Buffers (aka Protobufs),
    a binary format for representing serialized objects. Such a representation leads
    to smaller message payloads and increased network performance. Not only does it
    create more compact messages, but it also reduces the amount of redundant information
    sent with each message. Regarding the OSI model, Protobufs can be thought of as
    running on Layer 8, while HTTP/2 runs on Layer 7.
  prefs: []
  type: TYPE_NORMAL
- en: Protobufs have their own language for describing the messages that can be represented
    in a gRPC server. These files end in `.proto` and are reminiscent of a GraphQL
    schema. [Example 2-13](#ex_grpc_proto) demonstrates how a similar operation can
    be defined for a gRPC service.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-13\. *shared/grpc-recipe.proto*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A definition for a service named `RecipeService`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A message of type `Meta`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_protocols_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A field named `id` that can be a 32-bit integer.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_protocols_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: An array of `Recipe` messages in a field named `ingredients`, the fourth entry
    for this message.
  prefs: []
  type: TYPE_NORMAL
- en: This *recipe.proto* file is shared by both clients and servers. This allows
    both ends to communicate with each other and be able to decode and encode the
    messages being sent. gRPC defines RPC methods, which can accept a message of a
    particular type and return a message of another type, as well as services, which
    are ways to group related method calls.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the granularity of the message types. GraphQL, which was built with JSON
    and HTTP in mind, specifies numeric types using the value `Int`, simply an integer.
    gRPC, with lower-level roots in C, describes an integer more specifically using
    its size, in this case an `int32`. There usually isn’t a reason to limit an integer’s
    size if it’s going to be used in JSON. [Table 2-4](#table_grpc_scalars) has a
    more detailed list of common gRPC data types.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-4\. Common gRPC scalars
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Examples | Node/JS equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | 1.1 | `Number` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | 1.1 | `Number` |'
  prefs: []
  type: TYPE_TB
- en: '| `int32` | -2_147_483_648 | `Number` |'
  prefs: []
  type: TYPE_TB
- en: '| `int64` | 9_223_372_036_854_775_808 | `Number` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | true, false | `Boolean` |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | “Hello, friend!\n” | `String` |'
  prefs: []
  type: TYPE_TB
- en: '| `bytes` | *binary data* | `Buffer` |'
  prefs: []
  type: TYPE_TB
- en: The `repeated` keyword means that a field can contain multiple values. In those
    situations the values can be represented as an array of that value’s type.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are some other number formats that can be represented in gRPC as well.
    These include `uint32` and `uint64`, `sint32` and `sint64`, `fixed32` and `fixed64`,
    and finally, `sfixed32` and `sfixed64`. Each has different restrictions on the
    range of the number represented, accuracy, and how the number is represented in
    transit. The `@grpc/proto-loader` package can be configured to represent different
    values using a `String` in cases where a `Number` is insufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting part about these message types is the numeric value associated
    with each field. These values represent the order in which the field follows within
    the messages. The `Ingredient` message, for example, has `id` as the first property
    and `quantity` as the third property. It seems weird to list these numbers at
    first, but the order is very important. Unlike JSON, which doesn’t technically
    have an order to properties, the order of properties in a Protocol Buffer message
    is very important for two reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first reason is that the field names aren’t transmitted with the messages
    themselves. Since schemas are shared between client and server, the names of the
    fields would be redundant. As a quick visualization of this, imagine how two integers
    transmitted using JSON and again using binary might look. The two messages might
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If two numbers are always sent, and it’s common knowledge that the first is
    called `id` and the second is called `code`, then representing the message like
    in the second row removes unnecessary redundancies. This is similar to how CSV
    works: having column names in the first row and data in subsequent rows.'
  prefs: []
  type: TYPE_NORMAL
- en: The second reason that field order matters is that messages represented using
    Protobufs, and gRPC itself, are designed to be backwards compatible. As an example,
    if v1 of the Protobufs `Ingredient` message contains an `id`, a `name`, and a
    `quantity` field, and one day a new v2 is created with a fourth `substitute` field,
    then any nodes on the network still using v1 can safely ignore the additional
    fields and still communicate with the other nodes. This is beneficial in situations
    where a new version of the application is slowly released as the old version is
    phased out.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC supports four styles of messaging, though these examples only look at the
    most basic style. Message requests and responses can either be streaming or a
    single message. The basic style used in these examples involves a nonstreaming
    request and response. However, one can use *server-side streaming RPC*, where
    the server streams a response; *client-side streaming RPC*, where the client streams
    a request; or *bidirectional streaming RPC*, where the client and the server stream
    a request and a response. When working with a stream, an instance of an `EventEmitter`
    is provided, but when working with singular messages, code will instead deal with
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC Producer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you’ve looked at some Protobuf message and service definitions, it’s
    time to implement a gRPC server using Node.js. Again, you’ll begin by creating
    a new *recipe-api/* service. Create a file to resemble [Example 2-14](#ex_grpc_producer),
    and be sure to install the necessary dependencies. Dependencies beginning with
    an `@` symbol represent scoped packages within the npm registry.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-14\. *recipe-api/producer-grpc.js*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The producer needs access to the *.proto* file. In this case it’s loaded and
    processed when started, incurring a small startup cost.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: When a service is defined, an object is provided with properties reflecting
    the methods defined in the *.proto* file.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_protocols_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This method correlates with the `GetMetaData(Empty)` method in the *.proto*
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_protocols_CO10-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `getRecipe()` method makes use of an object passed in during the request.
    This object is provided as `call.request`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_protocols_CO10-5)'
  prefs: []
  type: TYPE_NORMAL
- en: gRPC can use TLS and authentication, but for this example it’s disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'This server listens for incoming HTTP/2 requests sent to localhost via port
    4000\. The HTTP routes associated with the two methods are based on the name of
    the service and the name of the methods. This means the `getMetaData()` method
    technically lives at the following URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The gRPC package abstracts the underlying HTTP/2 layer, so you typically don’t
    need to think of a gRPC service as being over HTTP/2, nor do you have to think
    about the paths.
  prefs: []
  type: TYPE_NORMAL
- en: gRPC Consumer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it’s time to implement the consumer. [Example 2-15](#ex_grpc_consumer) is
    a reworked version of the *web-api* service. At the time of writing, the official
    `@grpc/grpc-js` npm package works by exposing methods that use callbacks. This
    code example uses `util.promisify()` so that you can call the methods using async
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2-15\. *web-api/consumer-grpc.js*
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_protocols_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Just like with the producer service, this one loads the *.proto* definitions
    at startup.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_protocols_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The gRPC client is aware that it is connecting to a `recipe.RecipeService` service.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_protocols_CO11-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Also like the producer, security has been disabled.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_protocols_CO11-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The `GetMetaData()` call makes use of an `Empty` message, which contains no
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_protocols_CO11-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The `GetRecipe()` call, however, expects a `RecipeRequest` message. Here, an
    object adhering to the same shape is passed in.
  prefs: []
  type: TYPE_NORMAL
- en: This example sends two requests between the *web-api* and *recipe-api* services,
    whereas the previous GraphQL and JSON over HTTP examples made a single request.
    All the required information could have been retrieved in a single request, but
    I feel this example helps convey the heart of the RPC pattern where individual
    methods are called on a remote server.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `@grpc/grpc-js` package was able to look at your `.proto` file
    and give you an object with methods on it correlating to methods in the service.
    In this case the client has a method called `getMetaData()`. This drives the feeling
    that RPC intends to convey, that code on one service is remotely calling methods
    on another service, as if the methods existed locally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve got the two services defined, go ahead and run both of them
    and make a request by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The response to this request should resemble the following JSON payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The consumer service has combined the result of the two gRPC methods together,
    but they’re still visible in the resulting document. The `recipe` property correlates
    to the `Recipe` message definition in the *.proto* file. Notice how it contains
    a property called `ingredients`, which is an array of `Recipe` instances.
  prefs: []
  type: TYPE_NORMAL
- en: '[“gRPC benchmarks”](ch03.html#ch_scaling_sec_bm_subsec_protocol_grpc) contains
    benchmarks on communicating between two servers using gRPC.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#idm46291204847576-marker)) These code examples take many shortcuts
    to remain terse. For example, always favor `path.join()` over manual string concatenation
    when generating paths.
  prefs: []
  type: TYPE_NORMAL
