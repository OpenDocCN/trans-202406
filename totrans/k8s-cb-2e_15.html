<html><head></head><body><section data-pdf-bookmark="Chapter 15. Extending Kubernetes" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_dev_k8s">&#13;
<h1><span class="label">Chapter 15. </span>Extending Kubernetes</h1>&#13;
&#13;
&#13;
<p>Now that you’ve seen how to install, interact with, and use Kubernetes to deploy and manage applications, we focus in this chapter on adapting Kubernetes to your needs.<a data-primary="extending Kubernetes" data-type="indexterm" id="ix_extnd"/> For the recipes in this chapter, you will need <a href="https://go.dev">Go</a> installed and access to the Kubernetes source code hosted on <a href="https://github.com/kubernetes/kubernetes">GitHub</a>. We show how to compile Kubernetes as a whole, and how to compile specific components like the client <code>kubectl</code>. We also demonstrate how to use Python to talk to the Kubernetes API server and show how to extend Kubernetes with a custom resource definition.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="15.1 Compiling from Source" data-type="sect1"><div class="sect1" id="compiling_source">&#13;
<h1>15.1 Compiling from Source</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id138">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to build your own Kubernetes binaries from source instead of downloading the official release binaries (see <a data-type="xref" href="ch02.html#get_binaries">Recipe 2.9</a>) or third-party artifacts.<a data-primary="extending Kubernetes" data-secondary="compiling from source" data-type="indexterm" id="id1338"/><a data-primary="compiling from source" data-type="indexterm" id="id1339"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id139">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Clone the Kubernetes Git repository and build from source.<a data-primary="Git Kubernetes repository, cloning" data-type="indexterm" id="id1340"/></p>&#13;
&#13;
<p>If your development machine has Docker Engine installed, you <a data-primary="Makefiles" data-secondary="quick-release target of root Makefile" data-type="indexterm" id="id1341"/><a data-primary="Docker Engine" data-type="indexterm" id="id1342"/><a data-primary="quick-release target of root Makefile" data-type="indexterm" id="id1343"/>can use the <code>quick-release</code> target of the root <em>Makefile</em>, as shown here:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>git clone https://github.com/kubernetes/kubernetes.git</strong>&#13;
$ <strong>cd kubernetes</strong>&#13;
$ <strong>make quick-release</strong>&#13;
</pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>This Docker-based build requires at least 8 GB of RAM to complete. Ensure that your Docker daemon has access to that much memory. On macOS, access the Docker for Mac preferences and increase the allocated RAM.</p>&#13;
</div>&#13;
&#13;
<p>The binaries will be located in the <em>_output/release-stage</em> directory, and a complete bundle will be in the <em>_output/release-tars</em> directory.</p>&#13;
&#13;
<p>Alternatively, if <a data-primary="Golang environment property" data-type="indexterm" id="id1344"/>you have a <a href="https://go.dev/doc/install">Golang</a> environment properly set up, use the <code>release</code> target of the root <em>Makefile</em>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>git clone https://github.com/kubernetes/kubernetes.git</strong>&#13;
$ <strong>cd kubernetes</strong>&#13;
$ <strong>make</strong>&#13;
</pre>&#13;
&#13;
<p>The binaries will be located in the <em>_output/bin</em> directory.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1345">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The Kubernetes <a href="https://oreil.ly/6CSWo">developer guides</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="15.2 Compiling a Specific Component" data-type="sect1"><div class="sect1" id="compiling_components">&#13;
<h1>15.2 Compiling a Specific Component</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id282">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You want to build one specific component of Kubernetes from source. <a data-primary="compiling from source" data-secondary="building a specific Kubernetes component" data-type="indexterm" id="id1346"/><a data-primary="kubectl" data-secondary="building from source" data-type="indexterm" id="id1347"/>For example, you only want to build the client <code>kubectl</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id283">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Instead of using <code>make quick-release</code> or simply <code>make</code>, as shown in <a data-type="xref" href="#compiling_source">Recipe 15.1</a>, use <code>make kubectl</code>.</p>&#13;
&#13;
<p>There are targets in the root <em>Makefile</em> to build individual components.<a data-primary="Makefiles" data-secondary="targets in root Makefile to build individual Kubernetes components" data-type="indexterm" id="id1348"/> For example, to compile <code>kubectl</code>, <code>kubeadm</code>, and <code>kubelet</code>, do this:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>make kubectl kubeadm kubelet</strong>&#13;
</pre>&#13;
&#13;
<p>The binaries will be located in the <em>_output/bin</em> directory.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>To get the complete list of <em>Makefile</em> build targets, run <code>make help</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="15.3 Using a Python Client to Interact with the Kubernetes API" data-type="sect1"><div class="sect1" id="python_client">&#13;
<h1>15.3 Using a Python Client to Interact with the Kubernetes API</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id140">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>As a developer, you want to use Python to write scripts that use the Kubernetes API.<a data-primary="extending Kubernetes" data-secondary="using Python client to interact with Kubernetes API" data-type="indexterm" id="id1349"/><a data-primary="Python client, using to interact with Kubernetes API" data-type="indexterm" id="id1350"/><a data-primary="clients" data-secondary="Python client interacting with Kubernetes API" data-type="indexterm" id="id1351"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id141">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Install the Python <code>kubernetes</code> module. This <a href="https://oreil.ly/OolLt">module</a> is the official Python client library for Kubernetes.<a data-primary="Python Package Index (PyPi) site" data-type="indexterm" id="id1352"/> You can install the module from source or from the <a href="https://pypi.org">Python Package Index (PyPi) site</a>:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>pip install kubernetes</strong>&#13;
</pre>&#13;
&#13;
<p>With a Kubernetes cluster reachable using your default <code>kubectl</code> context, you are now ready to use this Python module to talk to the Kubernetes API.<a data-primary="kubectl" data-secondary="default kubectl context" data-type="indexterm" id="id1353"/> For example, the following Python script lists all the pods and prints their names:</p>&#13;
&#13;
<pre data-code-language="python" data-type="programlisting"><code class="kn">from</code> <code class="nn">kubernetes</code> <code class="kn">import</code> <code class="n">client</code><code class="p">,</code> <code class="n">config</code>&#13;
&#13;
<code class="n">config</code><code class="o">.</code><code class="n">load_kube_config</code><code class="p">()</code>&#13;
&#13;
<code class="n">v1</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">CoreV1Api</code><code class="p">()</code>&#13;
<code class="n">res</code> <code class="o">=</code> <code class="n">v1</code><code class="o">.</code><code class="n">list_pod_for_all_namespaces</code><code class="p">(</code><code class="n">watch</code><code class="o">=</code><code class="kc">False</code><code class="p">)</code>&#13;
<code class="k">for</code> <code class="n">pod</code> <code class="ow">in</code> <code class="n">res</code><code class="o">.</code><code class="n">items</code><code class="p">:</code>&#13;
    <code class="nb">print</code><code class="p">(</code><code class="n">pod</code><code class="o">.</code><code class="n">metadata</code><code class="o">.</code><code class="n">name</code><code class="p">)</code></pre>&#13;
&#13;
<p>The <code>config.load_kube_config()</code> call in this script will load your Kubernetes credentials and endpoint from your <code>kubectl</code> config file. By default, it will load the cluster endpoint and credentials for your current context.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id142">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The Python client is built using the OpenAPI specification of the Kubernetes API. It is up to date and autogenerated. All APIs are available through this client.<a data-primary="OpenAPI specification" data-type="indexterm" id="id1354"/><a data-primary="APIs" data-secondary="Python client interacting with Kubernetes API" data-type="indexterm" id="id1355"/></p>&#13;
&#13;
<p>Each API group corresponds to a specific class, so <a data-primary="API groups" data-type="indexterm" id="id1356"/>to call a method on an API object that is part of the <code>/api/v1</code> API group, you need to instantiate the <code>CoreV1Api</code> class. To use deployments, you will need to instantiate the <code>extensionsV1beta1Api</code> class. All methods and corresponding API group instances can be found in the autogenerated <a href="https://oreil.ly/ITREP"><em>README</em></a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1357">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/6rw3l">Examples in the project’s repository</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="15.4 Extending the API Using Custom &#10;Resource Definitions" data-type="sect1"><div class="sect1" id="writing_crd">&#13;
<h1>15.4 Extending the API Using Custom &#13;
<span class="keep-together">Resource Definitions</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id284">&#13;
<h2>Problem</h2>&#13;
&#13;
<p>You have a custom workload and none of the existing resources, such as <code>Deployment</code>, <code>Job</code>, or <code>StatefulSet</code>, is a good fit.<a data-primary="APIs" data-secondary="extending Kubernetes API using custom resource definitions" data-type="indexterm" id="ix_APIextKube"/><a data-primary="custom resource definitions" data-secondary="using to extend Kubernetes API" data-type="indexterm" id="ix_CRDextKube"/><a data-primary="extending Kubernetes" data-secondary="using custom resource definitions to extend Kubernetes API" data-type="indexterm" id="ix_extndCRD"/> So, you want to extend the Kubernetes API with a new resource that represents your workload while continuing to use <code>kubectl</code> in the usual way.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id143">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use a <a href="https://oreil.ly/d2MmH">custom resource definition (CRD)</a>.</p>&#13;
&#13;
<p>Let’s say you want to define a custom resource of kind <code>Function</code>. <a data-primary="Function custom resource" data-type="indexterm" id="id1358"/>This represents a short-running <code>Job</code>-like kind of resource, akin to what AWS Lambda offers, that is a function as a service (FaaS, or sometimes misleadingly called a “serverless function”).<a data-primary="CRDs" data-see="custom resource definitions" data-type="indexterm" id="id1359"/><a data-primary="function as a service (FaaS)" data-type="indexterm" id="ix_fnctser"/><a data-primary="FaaS (function as a service)" data-type="indexterm" id="ix_FaaS"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For a production-ready FaaS solution running on Kubernetes, see <a data-type="xref" href="ch14.html#ch_serverless">Chapter 14</a>.</p>&#13;
</div>&#13;
&#13;
<p>First, define the CRD in a manifest <a data-primary="manifests" data-secondary="defining Function custom resource" data-type="indexterm" id="id1360"/>file called <em>functions-crd.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apiextensions.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">CustomResourceDefinition</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">functions.example.com</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">example.com</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">versions</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">served</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">schema</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">openAPIV3Schema</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">object</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">properties</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">object</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">properties</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">code</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">string</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">ram</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">string</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">scope</code><code class="p">:</code><code class="w">              </code><code class="l-Scalar-Plain">Namespaced</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">names</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">plural</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">functions</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">singular</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">function</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Function</code><code class="w"/></pre>&#13;
&#13;
<p>Then let the API server know about your new CRD (it can take several minutes to register):</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f functions-crd.yaml</strong>&#13;
customresourcedefinition.apiextensions.k8s.io/functions.example.com created&#13;
</pre>&#13;
&#13;
<p>Now that you have the custom resource <code>Function</code> defined and the API server knows about it, you can instantiate it using a manifest<a data-primary="Function custom resource" data-secondary="instantiating" data-type="indexterm" id="id1361"/> called <em>myfaas.yaml</em> with the following contents:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">example.com/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Function</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myfaas</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">code</code><code class="p">:</code><code class="w"> </code><code class="s">"http://src.example.com/myfaas.js"</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">ram</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">100Mi</code><code class="w"/></pre>&#13;
&#13;
<p>And create the <code>myfaas</code> resource of kind <code>Function</code> as per usual:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl apply -f myfaas.yaml</strong>&#13;
function.example.com/myfaas created&#13;
&#13;
$ <strong>kubectl get crd functions.example.com -o yaml</strong>&#13;
apiVersion: apiextensions.k8s.io/v1&#13;
kind: CustomResourceDefinition&#13;
metadata:&#13;
  creationTimestamp: "2023-05-02T12:12:03Z"&#13;
  generation: 1&#13;
  name: functions.example.com&#13;
  resourceVersion: "2494492251"&#13;
  uid: 5e0128b3-95d9-412b-b84d-b3fac030be75&#13;
spec:&#13;
  conversion:&#13;
    strategy: None&#13;
  group: example.com&#13;
  names:&#13;
    kind: Function&#13;
    listKind: FunctionList&#13;
    plural: functions&#13;
    shortNames:&#13;
    - fn&#13;
    singular: function&#13;
  scope: Namespaced&#13;
  versions:&#13;
  - name: v1&#13;
    schema:&#13;
      openAPIV3Schema:&#13;
        properties:&#13;
          spec:&#13;
            properties:&#13;
              code:&#13;
                type: string&#13;
              ram:&#13;
                type: string&#13;
            type: object&#13;
        type: object&#13;
    served: true&#13;
    storage: true&#13;
status:&#13;
  acceptedNames:&#13;
    kind: Function&#13;
    listKind: FunctionList&#13;
    plural: functions&#13;
    shortNames:&#13;
    - fn&#13;
    singular: function&#13;
  conditions:&#13;
  - lastTransitionTime: "2023-05-02T12:12:03Z"&#13;
    message: no conflicts found&#13;
    reason: NoConflicts&#13;
    status: "True"&#13;
    type: NamesAccepted&#13;
  - lastTransitionTime: "2023-05-02T12:12:03Z"&#13;
    message: the initial names have been accepted&#13;
    reason: InitialNamesAccepted&#13;
    status: "True"&#13;
    type: Established&#13;
  storedVersions:&#13;
  - v1&#13;
&#13;
$ <strong>kubectl describe functions.example.com/myfaas</strong>&#13;
Name:         myfaas&#13;
Namespace:    triggermesh&#13;
Labels:       &lt;none&gt;&#13;
Annotations:  &lt;none&gt;&#13;
API Version:  example.com/v1&#13;
Kind:         Function&#13;
Metadata:&#13;
  Creation Timestamp:  2023-05-02T12:13:07Z&#13;
  Generation:          1&#13;
  Resource Version:    2494494012&#13;
  UID:                 bed83736-6c40-4039-97fb-2730c7a4447a&#13;
Spec:&#13;
  Code:  http://src.example.com/myfaas.js&#13;
  Ram:   100Mi&#13;
Events:  &lt;none&gt;&#13;
</pre>&#13;
&#13;
<p>To discover CRDs, simply access the API server. For example, using <code>kubectl proxy</code>, you can access the API server locally and query the key space (<code>example.com/v1</code> in our case):</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>curl 127.0.0.1:8001/apis/example.com/v1/ | jq .</strong>&#13;
{&#13;
  "kind": "APIResourceList",&#13;
  "apiVersion": "v1",&#13;
  "groupVersion": "example.com/v1",&#13;
  "resources": [&#13;
    {&#13;
      "name": "functions",&#13;
      "singularName": "function",&#13;
      "namespaced": true,&#13;
      "kind": "Function",&#13;
      "verbs": [&#13;
        "delete",&#13;
        "deletecollection",&#13;
        "get",&#13;
        "list",&#13;
        "patch",&#13;
        "create",&#13;
        "update",&#13;
        "watch"&#13;
      ],&#13;
      "shortNames": [&#13;
        "fn"&#13;
      ],&#13;
      "storageVersionHash": "FLWxvcx1j74="&#13;
    }&#13;
  ]&#13;
}&#13;
</pre>&#13;
&#13;
<p>Here you can see the resource along with the allowed verbs.</p>&#13;
&#13;
<p>When you want to get rid of your custom resource instance, simply delete it:</p>&#13;
<pre data-type="programlisting">&#13;
$ <strong>kubectl delete functions.example.com/myfaas</strong>&#13;
function.example.com "myfaas" deleted&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id144">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>As you’ve seen, it is straightforward to create a CRD. From an end user’s point of view, CRDs present a consistent API and are more or less indistinguishable from native resources such as pods or jobs. All the usual commands, such as <code>kubectl get</code> and <code>kubectl delete</code>, work as expected.</p>&#13;
&#13;
<p>Creating a CRD is, however, really less than half of the work necessary to fully extend the Kubernetes API. On their own, CRDs only let you store and retrieve custom data via the API server in etcd. You need to also write a <a href="https://oreil.ly/kYmqw">custom controller</a> that interprets the custom data expressing the user’s intent, establishes a control loop comparing the current state with the declared state, and tries to  &#13;
<span class="keep-together">reconcile both</span>.<a data-primary="FaaS (function as a service)" data-startref="ix_FaaS" data-type="indexterm" id="id1362"/><a data-primary="function as a service (FaaS)" data-startref="ix_fnctser" data-type="indexterm" id="id1363"/><a data-primary="extending Kubernetes" data-secondary="using custom resource definitions to extend Kubernetes API" data-startref="ix_extndCRD" data-type="indexterm" id="id1364"/><a data-primary="custom resource definitions" data-secondary="using to extend Kubernetes API" data-startref="ix_CRDextKube" data-type="indexterm" id="id1365"/><a data-primary="APIs" data-secondary="extending Kubernetes API using custom resource definitions" data-startref="ix_APIextKube" data-type="indexterm" id="id1366"/><a data-primary="extending Kubernetes" data-startref="ix_extnd" data-type="indexterm" id="id1367"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="id1368">&#13;
<h2>See Also</h2>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/mz2bH">“Extend the Kubernetes API with <code>CustomResourceDefinitions</code>"</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/gp0xn">“Custom Resources”</a> in the Kubernetes documentation</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>