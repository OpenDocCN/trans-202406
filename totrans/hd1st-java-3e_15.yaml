- en: 'Chapter 13\. Risky Behavior: Exception Handling'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0421-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Stuff happens. The file isn’t there. The server is down.** No matter how
    good a programmer you are, you can’t control everything. Things can go wrong.
    *Very* wrong. When you write a risky method, you need code to handle the bad things
    that might happen. But how do you *know* when a method is risky? And where do
    you put the code to *handle* the ***exceptional*** situation? So far in this book,
    we haven’t *really* taken any risks. We’ve certainly had things go wrong at runtime,
    but the problems were mostly flaws in our own code. Bugs. And those we should
    fix at development time. No, the problem-handling code we’re talking about here
    is for code that you *can’t* guarantee will work at runtime. Code that expects
    the file to be in the right directory, the server to be running, or the Thread
    to stay asleep. And we have to do this *now*. Because in *this* chapter, we’re
    going to build something that uses the risky JavaSound API. We’re going to build
    a MIDI Music Player.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make a Music Machine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the next three chapters, we’ll build a few different sound applications,
    including a BeatBox Drum Machine. In fact, before the book is done, we’ll have
    a multiplayer version so you can send your drum loops to another player, kind
    of like sharing over social media. You’re going to write the whole thing, although
    you can choose to use Ready-Bake Code for the GUI parts. OK, so not every IT department
    is looking for a new BeatBox server, but we’re doing this to learn more about
    Java. Building a BeatBox is just a way to have fun *while* we’re learning Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'The finished BeatBox looks something like this:'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0422-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Notice the check marks in the boxes for each of the 16 “beats.” For example,
    on beat 1 (of 16) the Bass drum and the Maracas will play, on beat 2 nothing,
    and on beat 3 the Maracas and Closed Hi-Hat...you get the idea. When you hit Start,
    it plays your pattern in a loop until you hit Stop. At any time, you can “capture”
    one of your own patterns by sending it to the BeatBox server (which means any
    other players can listen to it). You can also load any of the incoming patterns
    by clicking on the message that goes with it.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously we’ve got a few things to learn before the whole program is finished,
    including how to build a GUI, how to *connect* to another machine via networking,
    and a little I/O so we can *send* something to the other machine.
  prefs: []
  type: TYPE_NORMAL
- en: Oh yeah, and the JavaSound API. *That’s* where we’ll start in this chapter.
    For now, you can forget the GUI, forget the networking and the I/O, and focus
    only on getting some MIDI-generated sound to come out of your computer. And don’t
    worry if you don’t know a thing about MIDI or a thing about reading or making
    music. Everything you need to learn is covered here. You can almost smell the
    record deal.
  prefs: []
  type: TYPE_NORMAL
- en: The JavaSound API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaSound is a collection of classes and interfaces added to Java way back
    in version 1.3\. These aren’t special add-ons; they’re part of the standard Java
    SE class library. JavaSound is split into two parts: MIDI and Sampled. We use
    only MIDI in this book. MIDI stands for Musical Instrument Digital Interface,
    and is a standard protocol for getting different kinds of electronic sound equipment
    to communicate. But for our BeatBox app, you can think of MIDI as *a kind of sheet
    music* that you feed into some device like a high-tech “player piano.” In other
    words, MIDI data doesn’t actually include any *sound*, but it does include the
    *instructions* that a MIDI-reading instrument can play back. Or for another analogy,
    you can think of a MIDI file like an HTML document, and the instrument that renders
    the MIDI file (i.e., *plays* it) is like the web browser.'
  prefs: []
  type: TYPE_NORMAL
- en: MIDI data says *what* to do (play middle C, and here’s how hard to hit it, and
    here’s how long to hold it, etc.), but it doesn’t say anything at all about the
    actual *sound* you hear. MIDI doesn’t know how to make a flute, piano, or Jimi
    Hendrix guitar sound. For the actual sound, we need an instrument (a MIDI device)
    that can read and play a MIDI file. But the device is usually more like an *entire
    band or orchestra* of instruments. And that instrument might be a physical device,
    like a keyboard, or it could even be an instrument built entirely in software,
    living in your computer.
  prefs: []
  type: TYPE_NORMAL
- en: For our BeatBox, we use only the built-in, software-only instrument that you
    get with Java. It’s called a *synthesizer* (some folks refer to it as a *software
    synth*) because it *creates* sound. Sound that you *hear*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0423-01.png)'
  prefs: []
  type: TYPE_IMG
- en: First we need a Sequencer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we can get any sound to play, we need a Sequencer object. The sequencer
    is the object that takes all the MIDI data and sends it to the right instruments.
    It’s the thing that *plays* the music. A sequencer can do a lot of different things,
    but in this book, we’re using it strictly as a playback device. It’s like a device
    that streams music, but with a few added features. The Sequencer class is in the
    javax.sound.midi package. So let’s start by making sure we can make (or get) a
    Sequencer object.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0424-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Something’s wrong!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0424-02.png)'
  prefs: []
  type: TYPE_IMG
- en: What happens when a method you want to call (probably in a class you didn’t
    write) is risky?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Let’s say you want to call a method in a class that
    you didn’t write.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0425-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) **That method does something risky, something that
    might not work at runtime.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0425-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) **You need to *know* that the method you’re calling
    is risky.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0425-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4.png) **You then write code that can handle the failure if
    it *does* happen. You need to be prepared, just in case.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0425-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Methods in Java use *exceptions* to tell the calling code, “Something Bad Happened.
    I failed.”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Java’s exception-handling mechanism is a clean, well-lighted way to handle “exceptional
    situations” that pop up at runtime; it lets you put all your error-handling code
    in one easy-to-read place. It’s based on the method you’re calling *telling you*
    it’s risky (i.e., that the method *might* generate an exception), so that you
    can write code to deal with that possibility. If you *know* you might get an exception
    when you call a particular method, you can be *prepared* for—possibly even *recover*
    from—the problem that caused the exception.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does a method tell you it might throw an exception? You find a `**throws**`
    clause in the risky method’s declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '**The** `**getSequencer ()**` **method takes a risk. It can fail at runtime.
    So it must “declare” the risk *you* take when you call it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0426-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Risky methods that could fail at runtime declare the exceptions that might
    happen using “throws SomeKindOfException” on their method declaration.**'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler needs to know that YOU know you’re calling a risky method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0427-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If you wrap the risky code in something called a **try/catch**, the compiler
    will relax.
  prefs: []
  type: TYPE_NORMAL
- en: A try/catch block tells the compiler that you *know* an exceptional thing could
    happen in the method you’re calling, and that you’re prepared to handle it. That
    compiler doesn’t care *how* you handle it; it cares only that you say you’re taking
    care of it.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0428-01.png)'
  prefs: []
  type: TYPE_IMG
- en: An exception is an object... of type Exception
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is fortunate, because it would be much harder to remember if exceptions
    were of type Broccoli.
  prefs: []
  type: TYPE_NORMAL
- en: Remember from the polymorphism ([Chapter 7](ch07.xhtml#better_living_in_objectville_inheritance)
    and [Chapter 8](ch08.xhtml#serious_polymorphism_interfaces_and_abst)) that an
    object of type Exception *can* be an instance of any *subclass* of Exception.
  prefs: []
  type: TYPE_NORMAL
- en: Because an *Exception* is an object, what you *catch* is an object. In the following
    code, the **`catch`** argument is declared as type Exception, and the parameter
    reference variable is *ex*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0428-03.png)![image](Images/f0428-02.png)'
  prefs: []
  type: TYPE_IMG
- en: What you write in a catch block depends on the exception that was thrown. For
    example, if a server is down, you might use the catch block to try another server.
    If the file isn’t there, you might ask the user for help finding it.
  prefs: []
  type: TYPE_NORMAL
- en: If it’s your code that catches the exception, then whose code throws it?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0429-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ll spend much more of your Java coding time *handling* exceptions than you’ll
    spend *creating* and *throwing* them yourself. For now, just know that when your
    code *calls* a risky method—a method that declares an exception—it’s the risky
    method that *throws* the exception back to *you*, the caller.
  prefs: []
  type: TYPE_NORMAL
- en: In reality, it might be you who wrote both classes. It really doesn’t matter
    who writes the code...what matters is knowing which method *throws* the exception
    and which method *catches* it.
  prefs: []
  type: TYPE_NORMAL
- en: When somebody writes code that could throw an exception, they must *declare*
    the exception.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Risky, exception-throwing code:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0429-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) **Your code that *calls* the risky method:**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0429-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The compiler checks for everything except RuntimeExceptions.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0430-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**The compiler guarantees:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) If you *throw* an exception in your code, you *must*
    declare it using the *throws* keyword in your method declaration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) If you *call* a method that throws an exception (in
    other words, a method that *declares* it throws an exception), you must *acknowledge*
    that you’re aware of the exception possibility. One way to satisfy the compiler
    is to wrap the call in a try/catch. (There’s a second way we’ll look at a little
    later in this chapter.)'
  prefs:
  - PREF_UL
  type: TYPE_IMG
- en: '![image](Images/arr.png) **Yours to solve.**'
  prefs: []
  type: TYPE_NORMAL
- en: Flow control in try/catch blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you call a risky method, one of two things can happen. The risky method
    either succeeds, and the try block completes, or the risky method throws an exception
    back to your calling method.
  prefs: []
  type: TYPE_NORMAL
- en: '**If the try succeeds**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(doRiskyThing() does *not* throw an exception)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0432-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**If the try fails**'
  prefs: []
  type: TYPE_NORMAL
- en: '**(because doRiskyThing() *does* throw an exception)**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0432-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally: for the things you want to do no matter what'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0433-01.png)'
  prefs: []
  type: TYPE_IMG
- en: If you try to cook something, you start by turning on the oven.
  prefs: []
  type: TYPE_NORMAL
- en: If the thing you try is a complete **failure, *you have to turn off the oven.***
  prefs: []
  type: TYPE_NORMAL
- en: If the thing you try **succeeds, *you have to turn off the oven.***
  prefs: []
  type: TYPE_NORMAL
- en: '***You have to turn off the oven no matter what!***'
  prefs: []
  type: TYPE_NORMAL
- en: '**A finally block is where you put code that must run *regardless* of an exception.**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Without finally, you have to put the turnOvenOff() in *both* the try and the
    catch because ***you have to turn off the oven no matter what.*** A finally block
    lets you put all your important cleanup code­ in *one* place instead of duplicating
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '**If the try block fails (an exception),** flow control immediately moves to
    the catch block. When the catch block completes, the finally block runs. When
    the finally block completes, the rest of the method continues on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**If the try block succeeds (*no* exception),** flow control skips over the
    catch block and moves to the finally block. When the finally block completes,
    the rest of the method continues on.'
  prefs: []
  type: TYPE_NORMAL
- en: '**If the try or catch block has a return statement, finally will still run!**
    Flow jumps to the finally, then back to the return.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/pencil.png)'
  prefs: []
  type: TYPE_IMG
- en: Flow Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/arr.png) **Yours to solve.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Look at the code to the left. What do you think the output of this program
    would be? What do you think it would be if the third line of the program were
    changed to** `String test = "yes";`**? Assume ScaryException extends Exception.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0434-01.png)![image](Images/f0434-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When test = “no”: start try - start risky - end risky - end try - finally -
    end of main'
  prefs: []
  type: TYPE_NORMAL
- en: 'When test = “yes”: start try - start risky - scary exception - finally - end
    of main'
  prefs: []
  type: TYPE_NORMAL
- en: Did we mention that a method can throw more than one exception?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A method can throw multiple exceptions if it darn well needs to. But a method’s
    declaration must declare *all* the checked exceptions it can throw (although if
    two or more exceptions have a common superclass, the method can declare just the
    superclass).
  prefs: []
  type: TYPE_NORMAL
- en: Catching multiple exceptions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler will make sure that you’ve handled *all* the checked exceptions
    thrown by the method you’re calling. Stack the *catch* blocks under the *try*,
    one after the other. Sometimes the order in which you stack the catch blocks matters,
    but we’ll get to that a little later.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0435-01.png)![image](Images/f0435-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Exceptions are polymorphic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exceptions are objects, remember. There’s nothing all that special about one,
    except that it is *a thing that can be **thrown***. So like all good objects,
    Exceptions can be referred to polymorphically. A LingerieException *object*, for
    example, could be assigned to a ClothingException *reference*. A PantsException
    could be assigned to an Exception reference. You get the idea. The benefit for
    exceptions is that a method doesn’t have to explicitly declare every possible
    exception it might throw; it can declare a superclass of the exceptions. Same
    thing with catch blocks—you don’t have to write a catch for each possible exception
    as long as the catch (or catches) you have can handle any exception thrown.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0436-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1.png) **You can DECLARE exceptions using a superclass of
    the exceptions you throw.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0436-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) **You can CATCH exceptions using a superclass of the
    exception thrown.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0436-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Just because you CAN catch everything with one big super polymorphic catch,
    doesn’t always mean you SHOULD.**'
  prefs: []
  type: TYPE_NORMAL
- en: You *could* write your exception-handling code so that you specify only *one*
    catch block, using the superclass Exception in the catch clause, so that you’ll
    be able to catch *any* exception that might be thrown.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0437-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Write a different catch block for each exception that you need to handle
    uniquely.**'
  prefs: []
  type: TYPE_NORMAL
- en: For example, if your code deals with (or recovers from) a TeeShirtException
    differently than it handles a LingerieException, write a catch block for each.
    But if you treat all other types of ClothingException in the same way, then add
    a ClothingException catch to handle the rest.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0437-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Multiple catch blocks must be ordered from smallest to biggest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0438-01.png)![image](Images/f0438-02.png)![image](Images/f0438-03.png)![image](Images/f0438-04.png)'
  prefs: []
  type: TYPE_IMG
- en: The higher up the inheritance tree, the bigger the catch “basket.” As you move
    down the inheritance tree, toward more and more specialized Exception classes,
    the catch “basket” is smaller. It’s just plain old polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'A ShirtException catch is big enough to take a TeeShirtException or a DressShirtException
    (and any future subclass of anything that extends ShirtException). A ClothingException
    is even bigger (i.e., there are more things that can be referenced using a ClothingException
    type). It can take an exception of type ClothingException (duh) and any ClothingException
    subclasses: PantsException, UniformException, LingerieException, and ShirtException.
    The mother of all catch arguments is type **Exception**; it will catch *any* exception,
    including runtime (unchecked) exceptions, so you probably won’t use it outside
    of testing.'
  prefs: []
  type: TYPE_NORMAL
- en: You can’t put bigger baskets above smaller baskets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0439-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Well, you *can,* but it won’t compile. Catch blocks are not like overloaded
    methods where the best match is picked. With catch blocks, the JVM simply starts
    at the first one and works its way down until it finds a catch that’s broad enough
    (in other words, high enough on the inheritance tree) to handle the exception.
    If your first catch block is `**catch(Exception ex)**`, the compiler knows there’s
    no point in adding any others—they’ll never be reached.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0439-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Siblings (exceptions at the same level of the hierarchy tree, like PantsException
    and LingerieException) can be in any order, because they can’t catch one another’s
    exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: You could put ShirtException above LingerieException, and nobody would mind.
    Because even though ShirtException is a bigger (broader) type because it can catch
    other classes (its own subclasses), ShirtException can’t catch a LingerieException,
    so there’s no problem.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/arr.png) **Both answers in [“Sharpen your pencil”](#sharpen_your_pencil-id00035).**'
  prefs: []
  type: TYPE_NORMAL
- en: When you don’t want to handle an exception...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0441-02.png)![image](Images/f0441-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**If you don’t want to handle an exception, you can** **duck** **it by** **declaring**
    **it.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call a risky method, the compiler needs you to acknowledge it. Most
    of the time, that means wrapping the risky call in a try/catch. But you have another
    alternative: simply duck it and let the method that called you catch the exception.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s easy—all you have to do is *declare* that *you* throw the exceptions. Even
    though, technically, *you* aren’t the one doing the throwing, it doesn’t matter.
    You’re still the one letting the exception whiz right on by.
  prefs: []
  type: TYPE_NORMAL
- en: But if you duck an exception, then you don’t have a try/catch, so what happens
    when the risky method (doLaundry()) *does* throw the exception?
  prefs: []
  type: TYPE_NORMAL
- en: When a method throws an exception, that method is popped off the stack immediately,
    and the exception is thrown to the next method down the stack—the *caller*. But
    if the *caller* is a *ducker*, then there’s no catch for it, so the *caller* pops
    off the stack immediately, and the exception is thrown to the next method and
    so on...where does it end? You’ll see a little later.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0441-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Ducking (by declaring) only delays the inevitable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sooner or later, *somebody* has to deal with it. But what if main() ducks
    the exception?**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0442-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1circle.png) doLaundry() throws a ClothingException'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0442-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/2circle.png) foo() ducks the exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0442-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3circle.png) main() ducks the exception'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0442-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/4circle.png) The JVM shuts down'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Images](Images/f0442-05.png) We’re using the T-shirt to represent a Clothing
    Exception. We know, we know...you would have preferred the blue jeans.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Handle or Declare. It’s the law.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**So now we’ve seen both ways to satisfy the compiler when you call a risky
    (exception-throwing) method.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **HANDLE**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0443-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) **DECLARE (duck it)**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare that YOUR method throws the same exceptions as the risky method you’re
    calling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0443-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: But now this means that whoever calls the foo() method has to follow the Handle
    or Declare law. If foo() ducks the exception (by declaring it) and main() calls
    foo(), then main() has to deal with the exception.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0443-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Getting back to our music code...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve completely forgotten, we started this chapter with a first look
    at some JavaSound code. We created a Sequencer object, but it wouldn’t compile
    because the method Midi.getSequencer() declares a checked exception (MidiUnavailableException).
    But we can fix that now by wrapping the call in a try/catch.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0444-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Exception Rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **You cannot have a catch or finally without a try.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0444-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) **You cannot put code between the try and the catch.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0444-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) **A try MUST be followed by either a catch or a finally.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0444-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4.png) **A try with only a finally (no catch) must still declare
    the exception.**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0444-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Code Kitchen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0445-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You don’t have to do it yourself, but it’s a lot more fun if you do.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**The rest of this chapter is optional; you can use Ready-Bake Code for all
    the music apps.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**But if you want to learn more about JavaSound, turn the page.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Making actual sound
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember near the beginning of the chapter, we looked at how MIDI data holds
    the instructions for *what* should be played (and *how* it should be played) and
    we also said that MIDI data doesn’t actually *create any sound that you hear.*
    For sound to come out of the speakers, the MIDI data has to be sent through some
    kind of MIDI device that takes the MIDI instructions and renders them in sound,
    by triggering either a hardware instrument or a “virtual” instrument (software
    synthesizer). In this book, we’re using only software devices, so here’s how it
    works in JavaSound:'
  prefs: []
  type: TYPE_NORMAL
- en: '**You need FOUR things:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0446-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**And you need FIVE steps:**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Get a `**Sequencer**` and open it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/2.png) Make a new `**Sequence**`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/3.png) Get a new `**Track**` from the Sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Images](Images/4.png) Fill the Track with `**MidiEvents**` and give the Sequence
    to the Sequencer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![image](Images/f0447-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Version 1: Your very first sound player app'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Type it in and run it. You’ll hear the sound of someone playing a single note
    on a piano! (OK, maybe not some*one*, but some*thing*.)
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0448-01.png)![image](Images/f0448-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Making a MidiEvent (song data)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A MidiEvent is an instruction for part of a song. A series of MidiEvents is
    kind of like sheet music, or a player piano roll. Most of the MidiEvents we care
    about describe ***a thing to do*** and the ***moment in time to do it***. The
    moment in time part matters, since timing is everything in music. This note follows
    this note and so on. And because MidiEvents are so detailed, you have to say at
    what moment to *start* playing the note (a NOTE ON event) and at what moment to
    *stop* playing the notes (NOTE OFF event). So you can imagine that firing the
    “stop playing note G” (NOTE OFF message) *before* the “start playing Note G” (NOTE
    ON) message wouldn’t work.
  prefs: []
  type: TYPE_NORMAL
- en: The MIDI instruction actually goes into a Message object; the MidiEvent is a
    combination of the Message plus the moment in time when that message should “fire.”
    In other words, the Message might say, “Start playing Middle C,” while the MidiEvent
    would say, “Trigger this message at beat 4.”
  prefs: []
  type: TYPE_NORMAL
- en: So we always need a Message and a MidiEvent.
  prefs: []
  type: TYPE_NORMAL
- en: The Message says *what* to do, and the MidiEvent says *when* to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**A MidiEvent says what to do and when to do it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Every instruction must include the timing for that instruction.**'
  prefs: []
  type: TYPE_NORMAL
- en: '**In other words, at which beat that thing should happen.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) Make a **Message**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ShortMessage msg = new ShortMessage();`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/2.png) Put the **Instruction** in the Message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0449-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) Make a new **MidiEvent** using the Message'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0449-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4.png) Add the MidiEvent to the **Track**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0449-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'MIDI message: the heart of a MidiEvent'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A MIDI message holds the part of the event that says *what* to do. It’s the
    actual instruction you want the sequencer to execute. The first argument of an
    instruction is always the type of the message. The values you pass to the other
    three arguments depend on the type of message. For example, a message of type
    144 means “NOTE ON.” But in order to carry out a NOTE ON, the sequencer needs
    to know a few things. Imagine the sequencer saying, “OK, I’ll play a note, but
    *which channel*? In other words, do you want me to play a Drum note or a Piano
    note? And *which note*? Middle-C? D Sharp? And while we’re at it, at *which velocity*
    should I play the note?
  prefs: []
  type: TYPE_NORMAL
- en: To make a MIDI message, make a ShortMessage instance and invoke setMessage(),
    passing in the four arguments for the message. But remember, the message says
    only *what* to do, so you still need to stuff the message into an event that adds
    *when* that message should “fire.”
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *first* argument to setMessage() always represents the message “type,” while
    the *other t*hree arguments represent different things depending on the message
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**The Message says what to do; the MidiEvent says when to do it.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0450-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/1.png) **Message type**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![image](Images/f0450-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) **Channel**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Think of a channel like a musician in a band. Channel 1 is musician 1 (the keyboard
    player), channel 9 is the drummer, etc.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Images](Images/3.png) **Note to play**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A number from 0 to 127, going from low to high notes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0450-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/4.png) **Velocity**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How fast and hard did you press the key? 0 is so soft you probably won’t hear
    anything, but 100 is a good default.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0450-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Change a message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know what’s in a MIDI message, you can start experimenting. You
    can change the note that’s played, how long the note is held, add more notes,
    and even change the instrument.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/1.png) **Change the note**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Try a number between 0 and 127 in the note on and note off messages.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![image](Images/f0451-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/2.png) **Change the duration of the note**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the note off event (not the *message*) so that it happens at an earlier
    or later beat.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![image](Images/f0451-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/3.png) **Change the instrument**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new message, BEFORE the note-playing message, that sets the instrument
    in channel 1 to something other than the default piano. The change-instrument
    message is “192,” and the third argument represents the actual instrument (try
    a number between 0 and 127).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0451-03.png)![image](Images/f0451-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Version 2: Using command-line args to experiment with sounds'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This version still plays just a single note, but you get to use command-line
    arguments to change the instrument and note. Experiment by passing in two int
    values from 0 to 127\. The first int sets the instrument; the second int sets
    the note to play.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0452-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Where we’re headed with the rest of the CodeKitchens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '| **[Chapter 17](ch17.xhtml#make_a_connection_networking_and_threads): the
    goal** When we’re done, we’ll have a working BeatBox that’s also a Drum Chat Client.
    We’ll need to learn about GUIs (including event handling), I/O, networking, and
    threads. The next three ([Chapter 14](ch14.xhtml#a_very_graphic_story_getting_gui),
    [Chapter 15](ch15.xhtml#work_on_your_swing_using_swing), and [Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr))
    will get us there. | ![image](Images/f0453-01.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **[Chapter 14](ch14.xhtml#a_very_graphic_story_getting_gui): MIDI events**
    This CodeKitchen lets us build a little “music video” (bit of a stretch to call
    it that...) that draws random rectangles to the beat of the MIDI music. We’ll
    learn how to construct and play a lot of MIDI events (instead of just a couple,
    as we do in the current chapter). | ![image](Images/f0453-02.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **[Chapter 15](ch15.xhtml#work_on_your_swing_using_swing): Standalone BeatBox**
    Now we’ll actually build the real BeatBox, GUI and all. But it’s limited—as soon
    as you change a pattern, the previous one is lost. There’s no Save and Restore
    feature, and it doesn’t communicate with the network. (But you can still use it
    to work on your drum pattern skills.) | ![image](Images/f0453-03.png) |'
  prefs: []
  type: TYPE_TB
- en: '| **[Chapter 16](ch16.xhtml#saving_objects_left_parenthesisand_textr): Save
    and Restore** You’ve made the perfect pattern, and now you can save it to a file
    and reload it when you want to play it again. This gets us ready for the final
    version ([Chapter 15](ch15.xhtml#work_on_your_swing_using_swing)), where instead
    of writing the pattern to a file, we send it over a network to the chat server.
    | ![image](Images/f0453-04.png) |'
  prefs: []
  type: TYPE_TB
- en: Exercise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: This chapter explored the wonderful world of exceptions. Your job is to decide
    whether each of the following exception-related statements is true or false.
  prefs: []
  type: TYPE_NORMAL
- en: True or False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/hand.png)![image](Images/hand1.png)'
  prefs: []
  type: TYPE_IMG
- en: A try block must be followed by a catch and a finally block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you write a method that might cause a compiler-checked exception, you must
    wrap that risky code in a try/catch block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catch blocks can be polymorphic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only “compiler checked” exceptions can be caught.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you define a try/catch block, a matching finally block is optional.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you define a try block, you can pair it with a matching catch or finally
    block, or both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you write a method that declares that it can throw a compiler-checked exception,
    you must also wrap the exception throwing code in a try/catch block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The main( ) method in your program must handle all unhandled exceptions thrown
    to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A single try block can have many different catch blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method can throw only one kind of exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A finally block will run regardless of whether an exception is thrown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A finally block can exist without a try block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A try block can exist by itself, without a catch block or a finally block.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Handling an exception is sometimes referred to as “ducking.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The order of catch blocks never matters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A method with a try block and a finally block can optionally declare a checked
    exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Runtime exceptions must be handled or declared.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/arr.png) **Answers in [“True or False”](#true_or_false_left_parenthesisfrom_page).**'
  prefs: []
  type: TYPE_NORMAL
- en: Code Magnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/f0455-02.png)'
  prefs: []
  type: TYPE_IMG
- en: A working Java program is scrambled up on the fridge. Can you reconstruct all
    the code snippets to make a working Java program that produces the output listed
    below? Some of the curly braces fell on the floor and they were too small to pick
    up, so feel free to add as many of those as you need!
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0455-05.png)'
  prefs: []
  type: TYPE_IMG
- en: '![image](Images/arr.png) **Answers in [“Code Magnets”](ch02.xhtml#code_magnets_left_parenthesisfrom_page_4).**'
  prefs: []
  type: TYPE_NORMAL
- en: JavaCross
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '![image](Images/arr.png) **Answers in [“JavaCross”](#javacross_left_parenthesisfrom_page_456r).**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0456-01.png)![image](Images/f0456-02.png)'
  prefs: []
  type: TYPE_IMG
- en: You know what to do!
  prefs: []
  type: TYPE_NORMAL
- en: '**Across**'
  prefs: []
  type: TYPE_NORMAL
- en: 1\. To give value
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Flew off the top
  prefs: []
  type: TYPE_NORMAL
- en: 6\. All this and more!
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Start
  prefs: []
  type: TYPE_NORMAL
- en: 10\. The family tree
  prefs: []
  type: TYPE_NORMAL
- en: 13\. No ducking
  prefs: []
  type: TYPE_NORMAL
- en: 15\. Problem objects
  prefs: []
  type: TYPE_NORMAL
- en: 18\. One of Java’s ‘49’
  prefs: []
  type: TYPE_NORMAL
- en: 20\. Class hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 21\. Too hot to handle
  prefs: []
  type: TYPE_NORMAL
- en: 24\. Common primitive
  prefs: []
  type: TYPE_NORMAL
- en: 25\. Code recipe
  prefs: []
  type: TYPE_NORMAL
- en: 27\. Unruly method action
  prefs: []
  type: TYPE_NORMAL
- en: 28\. No Picasso here
  prefs: []
  type: TYPE_NORMAL
- en: 29\. Start a chain of events
  prefs: []
  type: TYPE_NORMAL
- en: '**Down**'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Currently usable
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Template’s creation
  prefs: []
  type: TYPE_NORMAL
- en: 4\. Don’t show the kids
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Mostly static API class
  prefs: []
  type: TYPE_NORMAL
- en: 7\. Not about behavior
  prefs: []
  type: TYPE_NORMAL
- en: 9\. The template
  prefs: []
  type: TYPE_NORMAL
- en: 11\. Roll another one off the line
  prefs: []
  type: TYPE_NORMAL
- en: 12\. Javac saw it coming
  prefs: []
  type: TYPE_NORMAL
- en: 14\. Attempt risk
  prefs: []
  type: TYPE_NORMAL
- en: 16\. Automatic acquisition
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Changing method
  prefs: []
  type: TYPE_NORMAL
- en: 19\. Announce a duck
  prefs: []
  type: TYPE_NORMAL
- en: 22\. Deal with it
  prefs: []
  type: TYPE_NORMAL
- en: 23\. Create bad news
  prefs: []
  type: TYPE_NORMAL
- en: 26\. One of my roles
  prefs: []
  type: TYPE_NORMAL
- en: '**More Hints:**'
  prefs: []
  type: TYPE_NORMAL
- en: '**Across**'
  prefs: []
  type: TYPE_NORMAL
- en: 6\. A Java child
  prefs: []
  type: TYPE_NORMAL
- en: 8\. Start a method
  prefs: []
  type: TYPE_NORMAL
- en: 13\. Instead of declare
  prefs: []
  type: TYPE_NORMAL
- en: 20\. Also a type of collection
  prefs: []
  type: TYPE_NORMAL
- en: 21\. Quack
  prefs: []
  type: TYPE_NORMAL
- en: 27\. Starts a problem
  prefs: []
  type: TYPE_NORMAL
- en: 28\. Not Abstract
  prefs: []
  type: TYPE_NORMAL
- en: '**Down**'
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Or a mouthwash
  prefs: []
  type: TYPE_NORMAL
- en: 3\. For ______ (not example)
  prefs: []
  type: TYPE_NORMAL
- en: 5\. Numbers . . .
  prefs: []
  type: TYPE_NORMAL
- en: 9\. Only public or default
  prefs: []
  type: TYPE_NORMAL
- en: 16\. _____ the family fortune
  prefs: []
  type: TYPE_NORMAL
- en: 17\. Not a ‘getter’
  prefs: []
  type: TYPE_NORMAL
- en: Sharpen your pencil
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Sharpen your pencil”](#sharpen_your_pencil-id00034))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/pencil.png)![image](Images/f0457-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Exercise Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/exercise.png)'
  prefs: []
  type: TYPE_IMG
- en: True or False
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“True or False”](#true_or_false-id000040))
  prefs: []
  type: TYPE_NORMAL
- en: False, either or both.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False, you can declare the exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False, runtime exception can be caught.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True, both are acceptable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False, the declaration is sufficient.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False, but if it doesn’t, the JVM may shut down.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True. It’s often used to clean up partially completed tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False, ducking is synonymous with declaring.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False, broadest exceptions must be caught by the last catch blocks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False, if you don’t have a catch block, you must declare.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: False.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Code Magnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“Code Magnets”](#code_magnets-id000005))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0458-02.png)'
  prefs: []
  type: TYPE_IMG
- en: JavaCross
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: (from [“JavaCross”](#javacross-id00003))
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0456-01.png)![image](Images/f0459-01.png)'
  prefs: []
  type: TYPE_IMG
