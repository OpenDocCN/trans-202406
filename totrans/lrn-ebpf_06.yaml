- en: Chapter 6\. The eBPF Verifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’ve mentioned the verification step a few times, so you already know that when
    you load an eBPF program into the kernel, this verification process ensures that
    the program is safe. In this chapter we’ll dive into how the verifier works to
    achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: Verification involves checking every possible execution path through the program
    and ensuring that every instruction is safe. The verifier also makes some updates
    to the bytecode to ready it for execution. In this chapter I’ll show some examples
    of verification failures, by starting from an example that works and making modifications
    that render that code invalid to the verifier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The example code for this chapter is in the *chapter6* directory of the repository
    at [*github.com/lizrice/learning-ebpf*](https://github.com/lizrice/learning-ebpf).
  prefs: []
  type: TYPE_NORMAL
- en: This chapter doesn’t attempt to cover every possible check the verifier makes.
    It’s intended to be an overview, with illustrative examples that will help you
    deal with verification errors that you might run into when writing your own eBPF
    code.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to bear in mind is that the verifier works on eBPF bytecode, not directly
    on the source. That bytecode depends on the output from the compiler. Because
    of things like compiler optimization, a change in the source code might not always
    result in exactly what you expect in the bytecode, so correspondingly it might
    not give you the result you expect in the verifier’s verdict. For example, the
    verifier will reject unreachable instructions, but the compiler might optimize
    them away before the verifier sees them.
  prefs: []
  type: TYPE_NORMAL
- en: The Verification Process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The verifier analyzes the program to assess all possible execution paths. It
    steps through the instructions in order, evaluating them rather than actually
    executing them. As it goes along it keeps track of the state of each register
    in a structure called `bpf_reg_state`. (The registers I’m referring to here are
    the registers from the eBPF virtual machine that you met in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program).)
    This structure includes a field called `bpf_reg_type`, which describes what type
    of value is held in that register. There are several possible types, including
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NOT_INIT`, indicating that the register has not yet been set to a value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SCALAR_VALUE`, indicating that the register has been set to a value that doesn’t
    represent a pointer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Several `PTR_TO_*` types, indicating that the register holds a pointer to something.
    That something could be, for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PTR_TO_CTX`: The register holds a pointer to the context passed as the argument
    to a BPF program.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PTR_TO_PACKET`: The register points to a network packet (held in the kernel
    as `skb->data`).'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PTR_TO_MAP_KEY` or `PTR_TO_MAP_VALUE`: I’m sure you can guess what these mean.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several other `PTR_TO_*` types, and you can find the full set enumerated
    in the [*linux/bpf.h* header file](https://oreil.ly/aWb50).
  prefs: []
  type: TYPE_NORMAL
- en: The `bpf_reg_state` structure also keeps track of the range of possible values
    the register might hold. This information is used by the verifier to determine
    when invalid actions are being attempted.
  prefs: []
  type: TYPE_NORMAL
- en: Each time the verifier comes to a branch, where a decision has to be made on
    whether to carry on in sequence or jump to a different instruction, the verifier
    pushes a copy of the current state of all the registers onto a stack and explores
    one of the possible paths. It continues evaluating the instructions until it reaches
    the return at the end of the program (or reaches the limit on the number of instructions
    it will process, which is currently one million instructions^([1](ch06.html#ch06fn1))),
    at which point it pops a branch off the stack to evaluate next. If it finds an
    instruction that could result in an invalid operation, it fails verification.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying every single possibility could get computationally expensive, so in
    practice there are optimizations called *state pruning* that avoid reevaluating
    paths through the program that are essentially equivalent. As it works through
    the program, the verifier records the state of all the registers at certain instructions
    within the program. If it later arrives at the same instruction with registers
    in a matching state, there is no need to continue to verify the rest of that path,
    as it’s already known to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: '[Lots of work has gone into optimizing the verifier](https://oreil.ly/pQDES)
    and its pruning process. The verifier used to store pruning state before and after
    each jump instruction, but analysis showed that this results in storing state
    on average every four instructions or so, and the vast majority of these pruning
    states would never get matched. It turned out that it’s more efficient to store
    pruning state every 10 instructions, regardless of branching.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can read more details on how verification works in the [kernel documentation](https://oreil.ly/atNda).
  prefs: []
  type: TYPE_NORMAL
- en: The Verifier Log
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the verification of a program fails, the verifier generates a log showing
    how it reached the conclusion that the program is invalid. If you’re using `bpftool
    prog load`, the verifier log gets output to stderr. When you’re writing a program
    with *libbpf*, you can use the function `libbpf_set_print()` to set a handler
    that will display (or do something else useful with) any errors. (You’ll see an
    example of this in the *hello-verifier.c* source code for this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you really want to dig into what the verifier is doing, you can get it to
    generate the log on success as well as on failure. There is a basic example of
    this in the *hello-verifier.c* file too. It involves passing a buffer that will
    hold verifier log contents into the *libbpf* call that loads the program into
    the kernel and then writing the contents of that log to screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verifier log includes a summary of how much work the verifier did, which
    looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the verifier processed 61 instructions, including potentially
    processing the same instruction multiple times by arriving at it through different
    paths. Note that the complexity limit of one million is an upper bound on the
    number of instructions in a program; in practice, if there are branches in the
    code, the verifier will process some instructions more than once.
  prefs: []
  type: TYPE_NORMAL
- en: The total number of states stored was four, which for this simple program matches
    the peak number of stored states. If some of the states had been pruned, the peak
    number might be lower than the total.
  prefs: []
  type: TYPE_NORMAL
- en: 'The log output includes the BPF instructions the verifier has analyzed, along
    with the corresponding C source code lines (if the object file was built with
    the `-g` flag to include debug information) and summaries of verifier state information.
    Here is an example extract of the verifier log relating to the first few lines
    of the program in *hello-verifier.bpf.c*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_6_1)'
  prefs: []
  type: TYPE_NORMAL
- en: The log includes source code lines to make it easier to understand how the output
    relates to the source. This source code is available because the `-g` flag was
    used to build in debug information during the compilation step.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_6_2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s an example of some register state information being output in the log.
    It tells us that at this stage Register 1 contains a map value, Register 6 holds
    the context, and Register 10 is the frame (or stack) pointer where local variables
    are held.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_6_3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is another example of register state information. Here you can see not
    only the types of values that are held in each (initialized) register, but also
    the range of possible values for Register 2 and Register 3.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dig further into the details of this. I said that Register 6 holds the
    context, and the verifier log indicates this with `R6_w=ctx(id=0,off=0,imm=0)`.
    This was set up in the very first line of the bytecode, where Register 1 was copied
    to Register 6\. When an eBPF program is called, Register 1 always holds the context
    argument passed to the program. Why copy it to Register 6? Well, when a BPF helper
    function is called, the arguments to that call are passed in Registers 1 through
    5\. Helper functions don’t modify the contents of Registers 6 through 9, so saving
    the context off into Register 6 means the code can call a helper function without
    losing access to the context.
  prefs: []
  type: TYPE_NORMAL
- en: Register 0 is used for the return value from a helper function and also for
    the return value from an eBPF program. Register 10 always holds a pointer to the
    eBPF stack frame (and the eBPF program can’t modify it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the register state information for Registers 2 and 3 after instruction
    6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Register 2 doesn’t have a minimum value, and the `umax_value` shown here in
    decimal corresponds to 0xFFFFFFFF, which is the largest value that can be held
    in an 8-byte register. In other words, at this point the register could hold any
    of its possible values.
  prefs: []
  type: TYPE_NORMAL
- en: In instruction 4, the contents of Register 2 are copied into Register 3, and
    then instruction 5 adds one to that value. Therefore, Register 3 could have any
    value that’s 1 or greater. You can see this in the state information for Register
    3, which has `umin_value` set to `1`, and a `umax_value` of `0xFFFFFFFF`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verifier uses the information about not just the states of each register,
    but also the range of values each can contain, to determine the possible paths
    through the program. This is also used for the state pruning that I mentioned
    before: if the verifier has been in the same position in the code, with the same
    types and possible ranges of values for each register, there’s no need to evaluate
    this path further. What’s more, if the current state is a subset of a state that
    was seen earlier, it can also be pruned.'
  prefs: []
  type: TYPE_NORMAL
- en: Visualizing Control Flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The verifier explores all the possible paths through the eBPF program, and
    if you’re trying to debug an issue, it can be helpful to see those paths for yourself.
    The `bpftool` utility can help with this by producing a control flow graph of
    the program in [DOT format](https://oreil.ly/V-1WN), which you can then convert
    into an image format, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This produces a visual representation of the control flow like that shown in
    [Figure 6-1](#extract_from_control_flow_graph_left_pa).
  prefs: []
  type: TYPE_NORMAL
- en: '![Extract from control flow graph (the full image can be found as chapter6/kprobe_exec.png
    in the GitHub repo for this book)](assets/lebp_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Extract from control flow graph (the full image can be found as
    chapter6/kprobe_exec.png in the [GitHub repo](http://github.com/lizrice/learning-ebpf)
    for this book)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Validating Helper Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’re not allowed to call directly from eBPF programs to any kernel function
    (unless it has been registered as a kfunc, which you’ll meet in the next chapter),
    but eBPF provides a number of helper functions that enable programs to access
    information from the kernel. There’s a [bpf-helpers manpage](https://oreil.ly/pdLGW)
    that attempts to document them all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Different helper functions are valid for different BPF program types. For example,
    the helper function `bpf_get_current_pid_tgid()` retrieves the current user space
    process ID and thread ID, but it doesn’t make sense to call this from an XDP program
    that is triggered by the receipt of a packet at a network interface, because there
    is no user space process involved. You can see an example of this by changing
    the `SEC()` definition for the *hello* eBPF program in *hello-verifier.bpf.c*
    from `kprobe` to `xdp`. On attempting to load this program the verifier output
    gives the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `unknown func` doesn’t mean the function is completely unknown, just that
    it is unknown *for this BPF program type*. (BPF program types are a topic for
    the next chapter; for now you can just think of them as being programs that are
    suitable for attaching to different types of event.)
  prefs: []
  type: TYPE_NORMAL
- en: Helper Function Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you look, for example, in [*kernel/bpf/helpers.c*](https://oreil.ly/tjjVR),^([2](ch06.html#ch06fn2))
    you’ll find that each helper function has a `bpf_func_proto` structure similar
    to this example for the helper function `bpf_map_lookup_elem()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This structure defines the constraints for arguments to and return values from
    the helper function. Because the verifier is keeping track of the type of value
    held in each register, it can spot if you try to pass the wrong kind of argument
    to a helper function. For example, try changing the argument to the call to `bpf_map_lookup_elem()`
    in the *hello* program, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of passing `&my_config`, which is a pointer to a map, this now passes
    `&data`, which is a pointer to a local variable structure. This is valid from
    the compiler’s point of view, so you can build the BPF object file *hello-verifier.bpf.o*,
    but when you try to load the program into the kernel, you’ll see an error like
    this in the verifier log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, `fp` stands for *frame pointer*, and it’s the area of memory on the stack
    where local variables are stored. Register 1 was loaded with the address of the
    local variable called `data`, but the function expects a pointer to a map (as
    indicated by the `arg1_type` field in the `bpf_func_proto` structure shown earlier).
    By tracking the types of value stored in each register, the verifier was able
    to spot this discrepancy.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the License
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The verifier also checks that if you are using a BPF helper function that’s
    licensed under GPL, your program also has a GPL-compatible license. The last line
    in the [Chapter 6](#the_ebpf_verifier) example code *hello-verifier.bpf.c* defines
    a “license” section that holds the string `Dual BSD/GPL`. If you remove this line,
    the output from the verifier will end like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That’s because the `gpl_only` field is set to `true` for the `bpf_probe_read_kernel()`
    helper function. There are other helper functions called earlier in this eBPF
    program, but they are not GPL licensed, so the verifier doesn’t object to their
    use.
  prefs: []
  type: TYPE_NORMAL
- en: The BCC project maintains a [list of helper functions](https://oreil.ly/mCpvB),
    indicating whether they are GPL licensed or not. If you’re interested in more
    details on how helper functions are implemented, there’s a section on this in
    the [BPF and XDP reference guide](https://oreil.ly/kVd6j).
  prefs: []
  type: TYPE_NORMAL
- en: Checking Memory Access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The verifier performs a number of checks to make sure BPF programs only access
    memory they are supposed to have access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when processing a network packet, an XDP program is only permitted
    to access the memory locations that make up that network packet. Most XDP programs
    start with something very similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `xdp_md` structure passed as the context to the program describes the network
    packet that has been received. The `ctx->data` field within that structure is
    the location in memory where the packet starts, and `ctx->data_end` is the last
    location in the packet. The verifier will ensure that the program doesn’t exceed
    these bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following program in *hello_verifier.bpf.c* is valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The variables `data` and `data_end` are very similar, but the verifier is smart
    enough to recognize that `data_end` relates to the end of a packet. Your program
    is required to check that any values read from the packet aren’t from beyond that
    location, and it won’t let you “cheat” by modifying the `data_end` value. Try
    adding the following line just before the `bpf_printk()` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The verifier will complain, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In another example, when accessing an array you need to make sure there’s no
    possibility of accessing an index that is beyond the bounds of that array. In
    the example code there is a section that reads a character out of the `message`
    array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is fine because of the explicit check to ensure that the counter variable
    `c` is no bigger than the size of the message array. Making a simple “off by one”
    error like the following renders it invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The verifier will fail this with an error message similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s fairly clear from this message that there is an invalid access to a map
    value because Register 2 might hold a value that’s too large for indexing the
    map. If you were debugging this error, you’d want to dig into the log to see what
    line in the source code was responsible. The log ends like this just before emitting
    the error message (I have removed some of the state information for clarity):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_6_6)'
  prefs: []
  type: TYPE_NORMAL
- en: Working backward from the error, the last register state information shows that
    Register 2 could have a maximum value of `12`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_6_5)'
  prefs: []
  type: TYPE_NORMAL
- en: At instruction 31, Register 2 is set to an address in memory and then is incremented
    by the value of Register 1\. The output shows that this corresponds to the line
    of code accessing `message[c]`, so it stands to reason that Register 2 is set
    to point to the message array and then to be incremented by the value of `c`,
    which is held in the Register 1 register.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#code_id_6_4)'
  prefs: []
  type: TYPE_NORMAL
- en: Working further back to find the value of Register 1, the log shows that it
    has a maximum value of `12` (which is hex 0x0c). However, `message` is defined
    as a 12-byte character array, so only indexes 0 through 11 are within its bounds.
    From this, you can see that the error springs from the source code testing for
    `c <= sizeof(message)`.
  prefs: []
  type: TYPE_NORMAL
- en: At step 2, I have inferred the relationship between some registers and the source
    code variables they represent, from the lines of source code the verifier has
    helpfully included in the log. You could work back through the verifier log to
    check that this is true, and indeed you might have to if the code was compiled
    without debug information. Given the debug information is present, it makes sense
    to use it.
  prefs: []
  type: TYPE_NORMAL
- en: The `message` array is declared as a global variable, and you might recall from
    [Chapter 3](ch03.html#anatomy_of_an_ebpf_program) that global variables are implemented
    using maps. This explains why the error message talks about “invalid access to
    a map value.”
  prefs: []
  type: TYPE_NORMAL
- en: Checking Pointers Before Dereferencing Them
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One easy way to make a C program crash is to dereference a pointer when the
    pointer has a zero value (also known as *null*). Pointers indicate where in memory
    a value is being held, and zero is not a valid memory location. The eBPF verifier
    requires all pointers to be checked before they are dereferenced so that this
    type of crash can’t happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example code in *hello-verifier.bpf.c* looks for a custom message that
    might exist in the `my_config` hash table map for a user, with the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If there’s no entry in this map corresponding to `uid`, this will set `p` (which
    is a pointer to the message structure `msg_t`) to zero. Here’s a little bit of
    additional code that attempts to dereference this potentially null pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This compiles fine, but the verifier rejects it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#code_id_6_7)'
  prefs: []
  type: TYPE_NORMAL
- en: The return value from a helper function call gets stored in Register 0\. Here,
    that value is being stored in Register 7\. This means Register 7 now holds the
    value of the local variable `p`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#code_id_6_8)'
  prefs: []
  type: TYPE_NORMAL
- en: This instruction attempts to dereference the pointer value `p`. The verifier
    has been keeping track of the state of Register 7 and knows that it may hold a
    pointer to a map value, or it might be null.
  prefs: []
  type: TYPE_NORMAL
- en: 'The verifier rejects this attempt to dereference a null pointer, but the program
    will pass if there is an explicit check, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Some helper functions incorporate the pointer check for you. For example, if
    you look at the manpage for bpf-helpers, you’ll find the function signature for
    `bpf_probe_read_kernel()` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The third argument to this function is called `unsafe_ptr`. This is an example
    of a BPF helper function that helps programmers write safe code by handling checks
    for you. You’re allowed to pass a potentially null pointer—but only as the third
    argument called `unsafe_ptr`—and the helper function will check that it’s not
    null before attempting to deference it.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every eBPF program is passed some context information as an argument, but depending
    on the program and attachment type, it may be allowed to access only some of that
    context information. For example, [tracepoint programs](https://oreil.ly/6RFFI)
    receive a pointer to some tracepoint data. The format of that data depends on
    the particular tracepoint, but they all start with some common fields—yet those
    common fields are not accessible to eBPF programs. Only the tracepoint-specific
    fields that follow can be accessed. Attempting to read or write the wrong fields
    leads to an `invalid bpf_context access` error. There is an example of this in
    the exercises at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Running to Completion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The verifier ensures that the eBPF program will run to completion; otherwise,
    there is a risk that it might consume resources indefinitely. It does this by
    having a limit on the total number of instructions that it will process, which,
    as I mentioned earlier, is set at one million instructions at the time of this
    writing. That limit is [hard-coded into the kernel](https://oreil.ly/IucYm); it’s
    not a configurable option. If the verifier hasn’t reached the end of the BPF program
    before it has processed this many instructions, it rejects the program.
  prefs: []
  type: TYPE_NORMAL
- en: One easy way to create a program that never completes is to write a loop that
    never ends. Let’s see how loops can be created in eBPF programs.
  prefs: []
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To guarantee completion, until kernel version 5.3 there was a restriction on
    loops.^([3](ch06.html#ch06fn3)) Looping through the same instructions requires
    a jump backward to earlier instructions, and it used to be the case that the verifier
    would not permit this. eBPF programmers worked around this by using the `#pragma
    unroll` compiler directive to tell the compiler to write out a set of identical
    (or very similar) bytecode instructions for each time around the loop. This saved
    the programmer typing in the same lines many times, but you would see repeated
    instructions in the emitted bytecode.
  prefs: []
  type: TYPE_NORMAL
- en: From version 5.3 onward the verifier follows branches backward as well as forward
    as part of its process of checking all the possible execution paths. This means
    it can accept some loops, provided the execution path remains within the limit
    of one million instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an example of a loop in the example *xdp_hello* program. A version
    of the loop that passes verification looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The (successful) verifier log will show that it has followed the execution path
    around this loop 10 times. In doing so, it doesn’t hit the complexity limit of
    one million instructions. In the exercises for this chapter, there’s another version
    of this loop that will hit that limit and will fail verification.
  prefs: []
  type: TYPE_NORMAL
- en: In version 5.17 a new helper function, `bpf_loop()`, was introduced that makes
    it much easier for the verifier not only to accept loops but also to do it in
    a much more efficient way. This helper takes the maximum number of iterations
    as its first argument, and it is also passed a function that is called for each
    iteration. The verifier only has to validate the BPF instructions in that function
    once, however many times it might be called. That function can return a nonzero
    value to indicate that there is no need to call it again, which is used to terminate
    a loop early once the desired result is achieved.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a helper function [`bpf_for_each_map_elem()`](https://oreil.ly/Yg_oQ)
    that calls a provided callback function for each item in a map.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the Return Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The return code from an eBPF program is stored in Register 0 (`R0`). If the
    program leaves `R0` uninitialized, the verifier will fail, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can try this by commenting out all the code in a function; for example,
    modify the `xdp_hello` example to be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will fail the verifier. However, if you put the line with the helper function
    `bpf_printf()` back in, the verifier won’t complain, even though there’s no explicit
    return value set by the source code!
  prefs: []
  type: TYPE_NORMAL
- en: This is because Register 0 is also used to hold the return code from a helper
    function. After returning from a helper function in an eBPF program, Register
    0 is no longer uninitialized.
  prefs: []
  type: TYPE_NORMAL
- en: Invalid Instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you know from the discussion of the eBPF (virtual) machine in [Chapter 3](ch03.html#anatomy_of_an_ebpf_program),
    eBPF programs consist of a set of bytecode instructions. The verifier checks that
    the instructions in a program are valid bytecode instructions—for example, using
    only known opcodes.
  prefs: []
  type: TYPE_NORMAL
- en: It would be considered a bug in the compiler if it emitted invalid bytecode,
    so you’re not likely to see this kind of verifier error unless you choose (for
    some reason best known to yourself) to write eBPF bytecode by hand. However, there
    have been some instructions added more recently, such as the atomic operations.
    If your compiled bytecode uses these instructions, they would fail verification
    on an older kernel.
  prefs: []
  type: TYPE_NORMAL
- en: Unreachable Instructions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The verifier also rejects programs that have unreachable instructions. Oftentimes,
    these will get optimized out by the compiler anyway.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When I first got interested in eBPF, getting code through the verifier seemed
    like a dark art, where seemingly valid code would get rejected, throwing up what
    seemed to be arbitrary errors. Over time there have been *lots* of improvements
    to the verifier, and in this chapter you’ve seen several examples where the verifier
    log gives hints to help you figure out what the problem is.
  prefs: []
  type: TYPE_NORMAL
- en: These hints are more helpful when you have a mental model of how the eBPF (virtual)
    machine works, using a set of registers for temporary value storage as it steps
    through an eBPF program. The verifier keeps track of the types and possible range
    of values for each register to ensure that eBPF programs are safe to run.
  prefs: []
  type: TYPE_NORMAL
- en: If you try writing some eBPF code of your own, you might find yourself needing
    assistance to resolve verifier errors. The [eBPF community Slack channel](http://ebpf.io/slack)
    is a good place to ask for help, and lots of people have also found advice on
    [StackOverflow](https://oreil.ly/nu_0v).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some more ways to cause a verifier error. See if you can correlate
    the verifier log output to the errors you get:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In [“Checking Memory Access”](#checking_memory_access), you saw the verifier
    rejecting access beyond the end of the global `message` array. In the example
    code there’s a section that accesses the local variable `data.message` in a similar
    way:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Try adjusting the code to make the same out-by-one mistake by replacing the
    `<` with `<=`, and you’ll see an error message about `invalid variable-offset
    read from stack R2`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Find the commented-out loops in *xdp_hello* in the example code. Try adding
    in the first loop that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see in the verifier log a repeated series of lines that look something
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the log, work out which register is tracking the loop variable `i`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now try adding in a loop that will fail, which looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should see that the verifier tries to explore this loop to its conclusion,
    but it reaches the instruction complexity limit before it completes (because there
    is no upper bound on the global variable `c`).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write a program that attaches to a tracepoint. (You may have done this already
    for the exercises in [Chapter 4](ch04.html#the_bpfleft_parenthesisright_parenthesi).)
    Looking ahead to [“Tracepoints”](ch07.html#tracepoints), you can see a structure
    definition for the context argument that starts with these fields:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create your own version of a structure that starts like this, and make the context
    argument in your program a pointer to this structure. In the program, try accessing
    any of these fields and see that the verifier fails with `invalid bpf_context
    access`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ^([1](ch06.html#ch06fn1-marker)) For a long time the limit was 4,096 instructions,
    which imposed significant restrictions on the complexity of eBPF programs. This
    limit still applies to unprivileged users running BPF programs.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch06.html#ch06fn2-marker)) Helper functions are also defined in some other
    places in the source code, for example, [*kernel/trace/bpf_trace.c*](https://oreil.ly/cY8y9)
    and [*net/core/filter.c*](https://oreil.ly/qww-b).
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch06.html#ch06fn3-marker)) This release brought a number of significant
    optimizations and improvements to the BPF verifier, which are summarized nicely
    in the LWN article [“Bounded loops in BPF for the 5.3 kernel”](https://oreil.ly/50BoD).
  prefs: []
  type: TYPE_NORMAL
