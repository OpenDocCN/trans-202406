["```\nimport {Subscriber} from './Subscriber'\nimport {Subscription} from './Subscription'\nimport {PartialObserver, Subscribable, TeardownLogic} from './types'\n\nexport class Observable<T> implements Subscribable<T> {\n  public _isScalar: boolean = false\n  constructor(\n    subscribe?: (\n      this: Observable<T>,\n      subscriber: Subscriber<T>\n    ) => TeardownLogic\n  ) {\n    if (subscribe) {\n      this._subscribe = subscribe\n    }\n  }\n  static create<T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) {\n    return new Observable<T>(subscribe)\n  }\n  subscribe(observer?: PartialObserver<T>): Subscription\n  subscribe(\n    next?: (value: T) => void,\n    error?: (error: any) => void,\n    complete?: () => void\n  ): Subscription\n  subscribe(\n    observerOrNext?: PartialObserver<T> | ((value: T) => void),\n    error?: (error: any) => void,\n    complete?: () => void\n  ): Subscription {\n    // ...\n  }\n}\n```", "```\nimport {Subscriber} from './Subscriber'\nimport {Subscription} from './Subscription'\nimport {PartialObserver, Subscribable, TeardownLogic} from './types'\n\nexport declare class Observable<T> implements Subscribable<T> { ![1](assets/1.png)\n  _isScalar: boolean\n  constructor(\n    subscribe?: (\n      this: Observable<T>,\n      subscriber: Subscriber<T>\n    ) => TeardownLogic\n  );\n  static create<T>(\n    subscribe?: (subscriber: Subscriber<T>) => TeardownLogic\n  ): Observable<T>\n  subscribe(observer?: PartialObserver<T>): Subscription\n  subscribe(\n    next?: (value: T) => void,\n    error?: (error: any) => void,\n    complete?: () => void\n  ): Subscription ![2](assets/2.png)\n}\n```", "```\nUncaught ReferenceError: process is not defined.\n```", "```\nprocess = {\n  env: {\n    NODE_ENV: 'production'\n  }\n}\n```", "```\nError TS2304: Cannot find name 'process'.\n```", "```\n`declare` `let` `process``:` `{`\n  `env``:` `{`\n    `NODE_ENV``:` `'development'` `|` `'production'`\n  `}`\n`}`\n\nprocess = {\n  env: {\n    NODE_ENV: 'production'\n  }\n}\n\n```", "```\ntype ToArray<T> = T extends unknown[] ? T : T[]\n```", "```\nfunction toArray<T>(a: T): ToArray<T> {\n  // ...\n}\n```", "```\ntype UserID = string & {readonly brand: unique symbol}\n```", "```\ndeclare module 'module-name' {\n  export type MyType = number\n  export type MyDefaultType = {a: string}\n  export let myExport: MyType\n  let myDefaultExport: MyDefaultType\n  export default myDefaultExport\n}\n```", "```\nimport ModuleName from 'module-name'\nModuleName.a  // string\n```", "```\ndeclare module '@most/core' {\n  // Type declaration\n}\n```", "```\n// Declare a module that can be imported, where each of its imports are any\ndeclare module 'unsafe-module-name'\n```", "```\nimport {x} from 'unsafe-module-name'\nx  // any\n```", "```\n// Type JSON files imported with Webpack's json-loader\ndeclare module 'json!*' {\n  let value: object\n  export default value\n}\n\n// Type CSS files imported with Webpack's style-loader\ndeclare module '*.css' {\n  let css: CSSRuleList\n  export default css\n}\n```", "```\nimport a from 'json!myFile'\na  // object\n\nimport b from './widget.css'\nb  // CSSRuleList\n```", "```\n{\n  \"compilerOptions\": {\n  \"allowJs\": true\n}\n```", "```\n{\n  \"compilerOptions\": {\n  \"allowJs\": true,\n  \"checkJs\": true\n}\n\n```", "```\n{\n  \"compilerOptions\": {\n  \"allowJs\": true,\n  \"checkJs\": true,\n  \"noImplicitAny\": false\n}\n\n```", "```\n class A {\n   x = 0 // number | string | string[], inferred from usage\n   method() {\n     this.x = 'foo'\n   }\n   otherMethod() {\n     this.x = ['array', 'of', 'strings']\n   }\n }\n```", "```\nexport function toPascalCase(word) {\n  return word.replace(\n    /\\w+/g,\n    ([a, ...b]) => a.toUpperCase() + b.join('').toLowerCase()\n  )\n}\n```", "```\n*`/**  * @param word {string} An input string to convert  * @returns {string} The string in PascalCase  */`*\nexport function toPascalCase(word) {\n  return word.replace(\n    /\\w+/g,\n    ([a, ...b]) => a.toUpperCase() + b.join('').toLowerCase()\n  )\n}\n\n```", "```\n// globals.ts\ntype TODO_FROM_JS_TO_TS_MIGRATION = any\n\n// MyMigratedUtil.ts\nexport function mergeWidgets(\n  widget1: TODO_FROM_JS_TO_TS_MIGRATION,\n  widget2: TODO_FROM_JS_TO_TS_MIGRATION\n): number {\n  // ...\n}\n```", "```\n{\n  \"compilerOptions\": {\n  \"allowJs\": false,\n  \"checkJs\": false\n}\n\n```", "```\n    my-app/\n    ├──src/\n    │ ├──index.ts\n    │ └──legacy/\n    │   ├──old-file.js\n    │   └──old-file.d.ts\n    ```", "```\n    // index.ts\n    import './legacy/old-file'\n    ```", "```\n    my-app/\n    ├──node_modules/\n    │ └──foo/\n    ├──src/\n    │ ├──index.ts\n    │ └──types.d.ts\n    ```", "```\n    // types.d.ts\n    declare module 'foo' {\n      let bar: {}\n      export default bar\n    }\n    ```", "```\n    // index.ts\n    import bar from 'foo'\n    ```", "```\n    npm install react --save\n    npm install @types/react --save-dev\n    ```", "```\n    my-app/\n    ├──node_modules/\n    │ ├──@types/\n    │ │ └──react/\n    │ └──react/\n    ├──src/\n    │ └──index.ts\n    ```", "```\n    // index.ts\n    import * as React from 'react'\n    ```", "```\n{\n  \"compilerOptions\": {\n    \"typeRoots\" : [\"./typings\", \"./node modules/@types\"]\n  }\n}\n```", "```\n{\n  \"compilerOptions\": {\n    \"types\" : [\"react\"]\n  }\n}\n```", "```\nnpm install rxjs\nnpm install ava\nnpm install @angular/cli\n```", "```\nnpm install lodash --save            # Install Lodash\nnpm install @types/lodash --save-dev # Install type declarations for Lodash\n```", "```\n    // @ts-ignore\n    import Unsafe from 'untyped-module'\n\n    Unsafe  // any\n    ```", "```\n    // types.d.ts\n    declare module 'nearby-ferret-alerter'\n    ```", "```\n    // types.d.ts\n    declare module 'nearby-ferret-alerter' {\n      export default function alert(loudness: 'soft' | 'loud'): Promise<void>\n      export function getFerretCount(): Promise<number>\n    }\n    ```"]