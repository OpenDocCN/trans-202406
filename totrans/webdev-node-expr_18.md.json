["```\nopenssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout meadowlark.pem\n\t-out meadowlark.crt\n```", "```\napp.listen(app.get('port'), () => {\n  console.log(`Express started in ${app.get('env')} mode ` +\n    `on port + ${app.get('port')}.`)\n})\n```", "```\nconst https = require('https')\nconst fs = require('fs')           // usually at top of file\n\n// ...the rest of your application configuration\n\nconst options = {\n  key: fs.readFileSync(__dirname + '/ssl/meadowlark.pem'),\n  cert: fs.readFileSync(__dirname + '/ssl/meadowlark.crt'),\n}\n\nconst port = process.env.PORT || 3000\nhttps.createServer(options, app).listen(port, () => {\n  console.log(`Express started in ${app.get('env')} mode ` +\n    `on port + ${port}.`)\n})\n```", "```\nproxy_set_header X-Forwarded-Proto $scheme;\n```", "```\napp.get('/', (req, res) => {\n  // the following is essentially\n  // equivalent to: if(req.secure)\n  if(req.headers['x-forwarded-proto'] === 'https') {\n    res.send('line is secure')\n  } else {\n    res.send('you are insecure!')\n  }\n})\n```", "```\n// this must come after we link in body-parser,\n// cookie-parser, and express-session\nconst csrf = require('csurf')\n\napp.use(csrf({ cookie: true }))\napp.use((req, res, next) => {\n  res.locals._csrfToken = req.csrfToken()\n  next()\n})\n```", "```\n<form action=\"/newsletter\" method=\"POST\">\n  <input type=\"hidden\" name=\"_csrf\" value=\"{{_csrfToken}}\">\n  Name: <input type=\"text\" name=\"name\"><br>\n  Email: <input type=\"email\" name=\"email\"><br>\n  <button type=\"submit\">Submit</button>\n</form>\n```", "```\nconst mongoose = require('mongoose')\n\nconst userSchema = mongoose.Schema({\n  authId: String,\n  name: String,\n  email: String,\n  role: String,\n  created: Date,\n})\n\nconst User = mongoose.model('User', userSchema)\nmodule.exports = User\n```", "```\nconst User = require('./models/user')\n\nmodule.exports = {\n  //...\n  getUserById: async id => User.findById(id),\n  getUserByAuthId: async authId => User.findOne({ authId }),\n  addUser: async data => new User(data).save(),\n}\n```", "```\nnpm install passport passport-facebook\n```", "```\nconst passport = require('passport')\nconst FacebookStrategy = require('passport-facebook').Strategy\n\nconst db = require('../db')\n\npassport.serializeUser((user, done) => done(null, user._id))\n\npassport.deserializeUser((id, done) => {\n  db.getUserById(id)\n    .then(user => done(null, user))\n    .catch(err => done(err, null))\n})\n```", "```\nmodule.exports = (app, options) => {\n  // if success and failure redirects aren't specified,\n  // set some reasonable defaults\n  if(!options.successRedirect) options.successRedirect = '/account'\n  if(!options.failureRedirect) options.failureRedirect = '/login'\n  return {\n    init: function() { /* TODO */ },\n    registerRoutes: function() { /* TODO */ },\n  }\n}\n```", "```\nconst createAuth = require('./lib/auth')\n\n// ...other app configuration\n\nconst auth = createAuth(app, {\n  // baseUrl is optional; it will default to localhost if you omit it;\n  // it can be helpful to set this if you're not working on\n  // your local machine.  For example, if you were using a staging server,\n  // you might set the BASE_URL environment variable to\n  // https://staging.meadowlark.com\n  baseUrl: process.env.BASE_URL,\n  providers: credentials.authProviders,\n  successRedirect: '/account',\n  failureRedirect: '/unauthorized',\n})\n\n// auth.init() links in Passport middleware:\nauth.init()\n\n// now we can specify our auth routes:\nauth.registerRoutes()\n```", "```\n\"authProviders\": {\n  \"facebook\": {\n    \"appId\": \"your_app_id\",\n    \"appSecret\": \"your_app_secret\"\n  }\n}\n```", "```\ninit: function() {\n  var config = options.providers\n\n  // configure Facebook strategy\n  passport.use(new FacebookStrategy({\n    clientID: config.facebook.appId,\n    clientSecret: config.facebook.appSecret,\n    callbackURL: (options.baseUrl || '') + '/auth/facebook/callback',\n  }, (accessToken, refreshToken, profile, done) => {\n    const authId = 'facebook:' + profile.id\n    db.getUserByAuthId(authId)\n      .then(user => {\n        if(user) return done(null, user)\n        db.addUser({\n          authId: authId,\n          name: profile.displayName,\n          created: new Date(),\n          role: 'customer',\n        })\n          .then(user => done(null, user))\n          .catch(err => done(err, null))\n      })\n      .catch(err => {\n        if(err) return done(err, null);\n      })\n  }))\n\n  app.use(passport.initialize())\n  app.use(passport.sessionp))\n},\n```", "```\n  registerRoutes: () => {\n    app.get('/auth/facebook', (req, res, next) => {\n      if(req.query.redirect) req.session.authRedirect = req.query.redirect\n      passport.authenticate('facebook')(req, res, next)\n    })\n    app.get('/auth/facebook/callback', passport.authenticate('facebook',\n      { failureRedirect: options.failureRedirect }),\n      (req, res) => {\n        // we only get here on successful authentication\n        const redirect = req.session.authRedirect\n        if(redirect) delete req.session.authRedirect\n        res.redirect(303, redirect || options.successRedirect)\n      }\n    )\n  },\n```", "```\napp.get('/account', (req, res) => {\n  if(!req.user)\n    return res.redirect(303, '/unauthorized')\n  res.render('account', { username: req.user.name })\n})\n// we also need an 'unauthorized' page\napp.get('/unauthorized', (req, res) => {\n  res.status(403).render('unauthorized')\n})\n// and a way to logout\napp.get('/logout', (req, res) => {\n  req.logout()\n  res.redirect('/')\n})\n```", "```\nconst customerOnly = (req, res, next) => {\n  if(req.user && req.user.role === 'customer') return next()\n  // we want customer-only pages to know they need to logon\n  res.redirect(303, '/unauthorized')\n}\n```", "```\nconst employeeOnly = (req, res, next) => {\n  if(req.user && req.user.role === 'employee') return next()\n  // we want employee-only authorization failures to be \"hidden\", to\n  // prevent potential hackers from even knowing that such a page exists\n  next('route')\n}\n```", "```\n// customer routes\n\napp.get('/account', customerOnly, (req, res) => {\n  res.render('account', { username: req.user.name })\n})\napp.get('/account/order-history', customerOnly, (req, res) => {\n  res.render('account/order-history')\n})\napp.get('/account/email-prefs', customerOnly, (req, res) => {\n  res.render('account/email-prefs')\n})\n\n// employer routes\n\napp.get('/sales', employeeOnly, (req, res) => {\n\tres.render('sales')\n})\n```", "```\nconst allow = roles => (req, res, next) => {\n  if(req.user && roles.split(',').includes(req.user.role)) return next()\n  res.redirect(303, '/unauthorized')\n}\n```", "```\n// configure Google strategy\npassport.use(new GoogleStrategy({\n  clientID: config.google.clientID,\n  clientSecret: config.google.clientSecret,\n  callbackURL: (options.baseUrl || '') + '/auth/google/callback',\n}, (token, tokenSecret, profile, done) => {\n  const authId = 'google:' + profile.id\n  db.getUserByAuthId(authId)\n    .then(user => {\n      if(user) return done(null, user)\n      db.addUser({\n        authId: authId,\n        name: profile.displayName,\n        created: new Date(),\n        role: 'customer',\n      })\n        .then(user => done(null, user))\n        .catch(err => done(err, null))\n    })\n    .catch(err => {\n      console.log('whoops, there was an error: ', err.message)\n      if(err) return done(err, null);\n    })\n}))\n```", "```\napp.get('/auth/google', (req, res, next) => {\n  if(req.query.redirect) req.session.authRedirect = req.query.redirect\n  passport.authenticate('google', { scope: ['profile'] })(req, res, next)\n})\napp.get('/auth/google/callback', passport.authenticate('google',\n  { failureRedirect: options.failureRedirect }),\n  (req, res) => {\n    // we only get here on successful authentication\n    const redirect = req.session.authRedirect\n    if(redirect) delete req.session.authRedirect\n    res.redirect(303, req.query.redirect || options.successRedirect)\n  }\n)\n```"]