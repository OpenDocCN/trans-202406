- en: Chapter 1\. Project Setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You want to get started with TypeScript, fantastic! The big question is: how
    do you start? You can integrate TypeScript into your projects in many ways, and
    all are slightly different depending on your project’s needs. Just as JavaScript
    runs on many runtimes, there are plenty of ways to configure TypeScript so it
    meets your target’s needs.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers all the possibilities of introducing TypeScript to your
    project, as an extension next to JavaScript that gives you basic autocompletion
    and error indication, up to full-fledged setups for full-stack applications on
    Node.js and the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Since JavaScript tooling is a field with endless possibilities—​some say that
    a new JavaScript build chain is released every week, almost as much as new frameworks—​this
    chapter focuses more on what you can do with the TypeScript compiler alone, without
    any extra tool.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript offers everything you need for your transpilation needs, except the
    ability to create minified and optimized bundles for web distribution. Bundlers
    like [ESBuild](https://esbuild.github.io) or [Webpack](https://webpack.js.org)
    take care of this task. Also, there are setups that include other transpilers
    like [Babel.js](https://babeljs.io) that can play nicely with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Bundlers and other transpilers are not within the scope of this chapter. Refer
    to their documentation for the inclusion of TypeScript and use the knowledge in
    this chapter to get the right configuration setup.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript being a project with more than a decade of history, it carries some
    remains from older times that, for the sake of compatibility, TypeScript can’t
    just get rid of. Therefore, this chapter will spotlight modern JavaScript syntax
    and recent developments in web standards.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still need to target Internet Explorer 8 or Node.js 10, first: I’m sorry,
    these platforms are really hard to develop for. However, second: you will be able
    to put together the pieces for older platforms with the knowledge from this chapter
    and the [official TypeScript documentation](https://typescriptlang.org).'
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Type-Checking JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get basic type-checking for JavaScript with the least amount of
    effort possible.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a single-line comment with `@ts-check` at the beginning of every JavaScript
    file you want to type-check. With the right editors, you already get red squiggly
    lines whenever TypeScript encounters things that don’t quite add up.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript has been designed as a superset of JavaScript, and every valid JavaScript
    is also valid TypeScript. This means TypeScript is also really good at figuring
    out potential errors in regular JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: We can use this if we don’t want a full-blown TypeScript setup but want some
    basic hints and type-checks to ease our development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: A good prerequisite if you only want to type-check JavaScript is a good editor
    or IDE. An editor that goes really well with TypeScript is [Visual Studio Code](https://code.visualstudio.com).
    Visual Studio Code—or VSCode for short—was the first major project to utilize
    TypeScript, even before TypeScript’s release.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of people recommend VSCode if you want to write JavaScript or TypeScript.
    But really, every editor is great as long as it features TypeScript support. And
    nowadays most of them do.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Visual Studio Code we get one very important thing for type-checking JavaScript:
    red squiggly lines when something doesn’t quite add up, as you can see in [Figure 1-1](#img-vscode-error).
    This is the lowest barrier to entry. TypeScript’s type system has different levels
    of strictness when working with a codebase.'
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0101](assets/tscb_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1-1\. Red squiggly lines in code editors: first-level feedback if something
    in your code doesn’t add up'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'First, the type system will try to *infer* types from JavaScript code through
    usage. If you have a line like this in your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript will correctly infer `number` as the type of `a_number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'One difficulty with JavaScript is that types are dynamic. Bindings via `let`,
    `var`, or `const` can change type based on usage.^([1](ch01.html#id393)) Take
    a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We assign a number to `a_number` and change the binding to a `string` if the
    condition in the next line evaluates to true. This wouldn’t be much of a problem
    if we didn’t try to multiply `a_number` on the last line. In approximately 50%
    of all cases, this example will produce unwanted behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript can help here. With the addition of a single-line comment with `@ts-check`
    at the very top of our JavaScript file, TypeScript activates the next strictness
    level: type-checking JavaScript files based on the type information available
    in the JavaScript file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, TypeScript will figure out that we tried to assign a string
    to a binding that TypeScript has inferred to be a number. We will get an error
    in our editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now we can start to fix our code, and TypeScript will guide us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type inference for JavaScript goes a long way. In the following example, TypeScript
    infers types by looking at operations like multiplication and addition as well
    as default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The function `addVat` takes two arguments. The second argument is optional,
    as it has been set to a default value of `0.2`. TypeScript will alert you if you
    try to pass a value that doesn’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, since we use multiplication and addition operations within the function
    body, TypeScript understands that we will return a number from this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In some situations you need more than type inference. In JavaScript files,
    you can annotate function arguments and bindings through JSDoc type annotations.
    [JSDoc](https://jsdoc.app) is a comment convention that allows you to describe
    your variables and function interfaces in a way that’s not only readable for humans
    but also interpretable by machines. TypeScript will pick up your annotations and
    use them as types for the type system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'JSDoc also allows you to define new, complex types for objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The syntax might feel a bit clunky, though; we will find better ways to annotate
    objects in [Recipe 1.3](#ch01_item_types_on_the_side).
  prefs: []
  type: TYPE_NORMAL
- en: Given that you have a JavaScript codebase that is well documented via JSDoc,
    adding a single line on top of your files will give you a really good understanding
    if something goes wrong in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Installing TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Red squigglies in the editor are not enough: you want command-line feedback,
    status codes, configuration, and options to type-check JavaScript and compile
    TypeScript.'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Install TypeScript via Node’s primary package registry: [NPM](https://npmjs.com).'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript is written in TypeScript, compiled to JavaScript, and uses the [Node.js
    JavaScript runtime](https://nodejs.org) as its primary execution environment.^([2](ch01.html#id406))
    Even if you’re not writing a Node.js app, the tooling for your JavaScript applications
    will run on Node. So, make sure you get Node.js from [the official website](https://nodejs.org)
    and get familiar with its command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a new project, make sure you initialize your project’s folder with a fresh
    *package.json*. This file contains all the information for Node and its package
    manager NPM to figure out your project’s contents. Generate a new *package.json*
    file with default contents in your project’s folder with the NPM command-line
    tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Throughout this book, you will see commands that should be executed in your
    terminal. For convenience, we show these commands as they would appear on BASH
    or similar shells available for Linux, macOS, or the Windows subsystem for Linux.
    The leading `$` sign is a convention to indicate a command, but it is not meant
    to be written by you. Note that all commands also work on the regular Windows
    command-line interface as well as PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: 'NPM is Node’s package manager. It comes with a CLI, a registry, and other tools
    that allow you to install dependencies. Once you initialize your *package.json*,
    install TypeScript from NPM. We install it as a development dependency, meaning
    that TypeScript won’t be included if you intend to publish your project as a library
    to NPM itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can globally install TypeScript so you have the TypeScript compiler available
    everywhere, but I strongly suggest installing TypeScript separately per project.
    Depending on how frequently you visit your projects, you will end up with different
    TypeScript versions that are in sync with your project’s code. Installing (and
    updating) TypeScript globally might break projects you haven’t touched in a while.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you install frontend dependencies via NPM, you will need an additional tool
    to make sure that your code also runs in your browser: a bundler. TypeScript doesn’t
    include a bundler that works with the supported module systems, so you need to
    set up the proper tooling. Tools like [Webpack](https://webpack.js.org) are common,
    and so is [ESBuild](https://esbuild.github.io). All tools are designed to execute
    TypeScript as well. Or you can go full native, as described in [Recipe 1.8](#ch01_item_es_modules).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that TypeScript is installed, initialize a new TypeScript project. Use
    NPX for that: it allows you to execute a command-line utility that you installed
    relative to your project.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: you can run your project’s local version of the TypeScript compiler and pass
    the `init` flag to create a new *tsconfig.json*.
  prefs: []
  type: TYPE_NORMAL
- en: The *tsconfig.json* is the main configuration file for your TypeScript project.
    It contains all the configuration needed so that TypeScript understands how to
    interpret your code, how to make types available for dependencies, and if you
    need to turn certain features on or off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Per default, TypeScript sets these options for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: '`target` is `es2016`, which means that if you run the TypeScript compiler,
    it will compile your TypeScript files to an ECMAScript 2016 compatible syntax.
    Depending on your supported browsers or environments, you can set that either
    to something more recent (ECMAScript versions are named after the year of release)
    or to something older such as `es5` for people who have to support very old Internet
    Explorer versions. Of course, I hope you don’t have to.'
  prefs: []
  type: TYPE_NORMAL
- en: '`module` is `commonjs`. This allows you to write ECMAScript module syntax,
    but instead of carrying this syntax over to the output, TypeScript will compile
    it to the CommonJS format. This means that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: once you compile. CommonJS was the module system for Node.js and has become
    very common because of Node’s popularity. Node.js has since adopted ECMAScript
    modules as well, something we’ll tackle in [Recipe 1.9](#ch01_item_modules).
  prefs: []
  type: TYPE_NORMAL
- en: '`esModuleInterop` ensures modules that aren’t ECMAScript modules are aligned
    to the standard once imported. `forceConsistentCasingInFileNames` helps people
    using case-sensitive file systems cooperate with folks who use case-insensitive
    file systems. And `skipLibCheck` assumes that your installed type definition files
    (more on that later) have no errors. So your compiler won’t check them and will
    become a little faster.'
  prefs: []
  type: TYPE_NORMAL
- en: One of the most interesting features is TypeScript’s strict mode. If set to
    `true`, TypeScript will behave differently in certain areas. It’s a way for the
    TypeScript team to define their view on how the type system should behave.
  prefs: []
  type: TYPE_NORMAL
- en: If TypeScript introduces a breaking change because the view on the type system
    changes, it will get incorporated in strict mode. This ultimately means that your
    code might break if you update TypeScript and always run in strict mode.
  prefs: []
  type: TYPE_NORMAL
- en: To give you time to adapt to changes, TypeScript also allows you to turn certain
    strict mode features on or off, feature by feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the default settings, I strongly recommend two more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This tells TypeScript to pick up source files from a *src* folder and put the
    compiled files into a *dist* folder. This setup allows you to separate your built
    files from the ones you author. You will have to create the *src* folder, of course;
    the *dist* folder will be created after you compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oh, compilation. Once you have your project set up, create an *index.ts* file
    in `src`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The *.ts* extension indicates it’s a TypeScript file. Now run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: in your command line and see the compiler at work.
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Keeping Types on the Side
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write regular JavaScript with no extra build step but still get
    some editor support and proper type information for your functions. However, you
    don’t want to define your complex object types with JSDoc as shown in [Recipe
    1.1](#ch01_item_type-checking-javascript).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Keep type definition files “on the side” and run the TypeScript compiler in
    the “check JavaScript” mode.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Gradual adoption has always been a dedicated goal for TypeScript. With this
    technique, which I dubbed “types on the side,” you can write TypeScript syntax
    for object types and advanced features like generics and conditional types (see
    [Chapter 5](ch05.html#ch05)) instead of clunky JSDoc comments, but you still write
    JavaScript for your actual app.
  prefs: []
  type: TYPE_NORMAL
- en: Somewhere in your project, maybe in a *@types* folder, create a type definition
    file. Its ending is *.d.ts*, and as opposed to regular *.ts* files, its purpose
    is to hold declarations but no actual code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where you can write your interfaces, type aliases, and complex types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that you export the interfaces from the declaration files. This is so
    you can import them in your JavaScript files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The comment on the first line tells TypeScript to import the `Person` type from
    *@types/person* and make it available under the name `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use this identifier to annotate function parameters or objects
    just like you would with primitive types like `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To make sure that you get editor feedback, you still need to set `@ts-check`
    at the beginning of your JavaScript files as described in [Recipe 1.1](#ch01_item_type-checking-javascript).
    Or, you can configure your project to always check JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Open *tsconfig.json* and set the `checkJs` flag to `true`. This will pick up
    all the JavaScript files from your *src* folder and give you constant feedback
    on type errors in your editor. You also can run `npx tsc` to see if you have errors
    in your command line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want TypeScript to transpile your JavaScript files to older versions
    of JavaScript, make sure you set `noEmit` to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With that, TypeScript will look at your source files and will give you all the
    type information you need, but it won’t touch your code.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is also known to scale. Prominent JavaScript libraries like [Preact](https://preactjs.org)
    work like this and provide fantastic tooling for their users as well as their
    contributors.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Migrating a Project to TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to get the full benefits of TypeScript for your project, but you need
    to migrate an entire codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rename your modules file by file from *.js* to *.ts*. Use several compiler options
    and features that help you iron out errors.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The benefit of having TypeScript files instead of JavaScript files with types
    is that your types and implementations are in one file, which gives you better
    editor support and access to more TypeScript features, and increases compatibility
    with other tools.
  prefs: []
  type: TYPE_NORMAL
- en: However, just renaming all files from *.js* to *.ts* most likely will result
    in tons of errors. This is why you should go file by file and gradually increase
    type safety as you go along.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest problem when migrating is that you’re suddenly dealing with a TypeScript
    project, not with JavaScript. Still, lots of your modules will be JavaScript and,
    with no type information, they will fail the type-checking step.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make it easier for yourself and for TypeScript by turning off type-checking
    for JavaScript, but allow TypeScript modules to load and refer to JavaScript files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Should you run `npx tsc` now, you will see that TypeScript picks up all JavaScript
    and TypeScript files in your source folder and creates respective JavaScript files
    in your destination folder. TypeScript will also transpile your code to be compatible
    with the specified target version.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are working with dependencies, you will see that some of them don’t
    come with type information. This will also produce TypeScript errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Install third-party type definitions to get rid of this error. See [Recipe 1.5](#ch01_item_definitely_typed).
  prefs: []
  type: TYPE_NORMAL
- en: Once you migrate file by file, you might realize that you won’t be able to get
    all typings for one file in one go. There are dependencies, and you will quickly
    go down the rabbit hole of having too many files to adjust before you can tackle
    the one that you actually need.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can always decide just to live with the error. By default, TypeScript sets
    the compiler option `noEmitOnError` to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This means that no matter how many errors you have in your project, TypeScript
    will generate result files, trying not to block you. This might be a setting you
    want to turn on after you finish migrating.
  prefs: []
  type: TYPE_NORMAL
- en: 'In strict mode, TypeScript’s feature flag `noImplicitAny` is set to `true`.
    This flag will make sure that you don’t forget to assign a type to a variable,
    constant, or function parameter. Even if it’s just `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`any` is the catchall type in TypeScript. Every value is compatible with `any`,
    and `any` allows you to access every property or call every method. `any` effectively
    turns off type-checking, giving you some room to breathe during your migration
    process.'
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, you can annotate your parameters with `unknown`. This also allows
    you to pass everything to a function but won’t allow you to do anything with it
    until you know more about the type.
  prefs: []
  type: TYPE_NORMAL
- en: You can also decide to ignore errors by adding a `@ts-ignore` comment before
    the line you want to exclude from type-checking. A `@ts-nocheck` comment at the
    beginning of your file turns off type-checking entirely for this particular module.
  prefs: []
  type: TYPE_NORMAL
- en: A comment directive that is fantastic for migration is `@ts-expect-error`. It
    works like `@ts-ignore` as it will swallow errors from the type-checking progress
    but will produce red squiggly lines if no type error is found.
  prefs: []
  type: TYPE_NORMAL
- en: 'When migrating, this helps you find the spots that you successfully moved to
    TypeScript. When there are no `@ts-expect-error` directives left, you’re done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The great thing about this technique is that you flip responsibilities. Usually,
    you have to make sure that you pass in the right values to a function; now you
    can make sure that the function is able to handle the right input.
  prefs: []
  type: TYPE_NORMAL
- en: 'All possibilities for getting rid of errors throughout your migration process
    have one thing in common: they’re explicit. You need to explicitly set `@ts-expect-error`
    comments, annotate function parameters as `any`, or ignore files entirely from
    type-checking. With that, you can always search for those escape hatches during
    the migration process and make sure that, over time, you got rid of them all.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.5 Loading Types from Definitely Typed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You rely on a dependency that hasn’t been written in TypeScript and therefore
    lacks typings.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: From [Definitely Typed](https://oreil.ly/nZ4xZ), install community-maintained
    type definitions.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Definitely Typed is one of the biggest and most active repositories on GitHub
    and collects high-quality TypeScript type definitions developed and maintained
    by the community.
  prefs: []
  type: TYPE_NORMAL
- en: The number of maintained type definitions is close to 10,000, and there is rarely
    a JavaScript library not available.
  prefs: []
  type: TYPE_NORMAL
- en: All type definitions are linted, checked, and deployed to the Node.js package
    registry NPM under the `@types` namespace. NPM has an indicator on each package’s
    information site that shows if Definitely Typed type definitions are available,
    as you can see in [Figure 1-2](#img-npm-react).
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0102](assets/tscb_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. The NPM site for React shows a DT logo next to the package name;
    this indicates available type definitions from Definitely Typed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Clicking on this logo leads you to the actual site for type definitions. If
    a package has first-party type definitions already available, it shows a small
    TS logo next to the package name, as shown in [Figure 1-3](#img-npm-types-react).
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0103](assets/tscb_0103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-3\. Type definitions for React from Definitely Typed
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To install, for example, typings for the popular JavaScript framework React,
    you install the `@types/react` package to your local dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example we install types to development dependencies, since we consume
    them while developing the application, and the compiled result has no use of the
    types anyway.
  prefs: []
  type: TYPE_NORMAL
- en: By default, TypeScript will pick up type definitions it can find that are in
    visible *@types* folders relative to your project’s root folder. It will also
    pick up all type definitions from *node_modules/@types*; note that this is where
    NPM installs, for example, `@types/react`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this because the `typeRoots` compiler option in *tsconfig.json* is set
    to `@types` and `./node_modules/@types`. Should you need to override this setting,
    make sure to include the original folders if you want to pick up type definitions
    from Definitely Typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note that just by installing type definitions into *node_modules/@types*, TypeScript
    will load them during compilation. This means that if some types declare globals,
    TypeScript will pick them up.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might want to explicitly state which packages should be allowed to contribute
    to the global scope by specifying them in the `types` setting in your compiler
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this setting will only affect the contributions to the global scope.
    If you load node modules via import statements, TypeScript still will pick up
    the correct types from *@types*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We will revisit this setting in [Recipe 1.7](#ch01_item_testing).
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 Setting Up a Full-Stack Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write a full-stack application targeting Node.js and the browser,
    with shared dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create two *tsconfig* files for each frontend and backend, and load shared dependencies
    as composites.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js and the browser both run JavaScript, but they have a very different
    understanding of what developers should do with the environment. Node.js is meant
    for servers, command-line tools, and everything that runs without a UI—*headless*.
    It has its own set of APIs and standard library. This little script starts an
    HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'While it’s without a doubt JavaScript, some things are unique to Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_project_setup_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`"http"` is a built-in Node.js module for everything related to HTTP. It is
    loaded via `require`, which is an indicator for Node’s module system called *CommonJS*.
    There are other ways to load modules in Node.js as we see in [Recipe 1.9](#ch01_item_modules),
    but recently CommonJS has been the most common.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_project_setup_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The `process` object is a global object containing information on environment
    variables and the current Node.js process in general. This is also unique to Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_project_setup_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `console` and its functions are available in almost every JavaScript runtime,
    but what it does in Node is different from what it does in the browser. In Node,
    it prints on STDOUT; in the browser, it will print a line to the development tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are of course many more unique APIs for Node.js. But the same goes for
    JavaScript in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_project_setup_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: After years without a way to load modules, ECMAScript modules have found their
    way into JavaScript and the browsers. This line loads an object from another JavaScript
    module. This runs in the browser natively and is a second module system for Node.js
    (see [Recipe 1.9](#ch01_item_modules)).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_project_setup_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript in the browser is meant to interact with UI events. The `document`
    object and the idea of a `querySelector` that points to elements in the *Document
    Object Model (DOM)* are unique to the browser. So is adding an event listener
    and listening on “click” events. You don’t have this in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_project_setup_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: And again, `console`. It has the same API as in Node.js, but the result is a
    bit different.
  prefs: []
  type: TYPE_NORMAL
- en: The differences are so big, it’s hard to create one TypeScript project that
    handles both. If you are writing a full-stack application, you need to create
    two TypeScript configuration files that deal with each part of your stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s work on the backend first. Let’s assume you want to write an Express.js
    server in Node.js (Express is a popular server framework for Node). First, you
    create a new NPM project as shown in [Recipe 1.1](#ch01_item_type-checking-javascript).
    Then, install Express as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And install type definitions for Node.js and Express from Definitely Typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new folder called *server*. This is where your Node.js code goes.
    Instead of creating a new *tsconfig.json* via `tsc`, create a new *tsconfig.json*
    in your project’s *server* folder. Here are the contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should already know a lot of this, but a few things stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: The `module` property is set to `commonjs`, the original Node.js module system.
    All `import` and `export` statements will be transpiled to their CommonJS counterpart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `types` property is set to `["node"]`. This property includes all the libraries
    you want to have globally available. If `"node"` is in the global scope, you will
    get type information for `require`, `process`, and other Node.js specifics that
    are in the global space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To compile your server-side code, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Now for the client:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some similarities, but again, a few things stand out:'
  prefs: []
  type: TYPE_NORMAL
- en: You add `DOM` to the `lib` property. This gives you type definitions for everything
    related to the browser. Where you needed to install Node.js typings via Definitely
    Typed, TypeScript ships the most recent type definitions for the browser with
    the compiler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `types` array is empty. This will *remove* `"node"` from our global typings.
    Since you only can install type definitions per *package.json*, the `"node"` type
    definitions we installed earlier would be available in the entire code base. For
    the `client` part, however, you want to get rid of them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To compile your frontend code, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Please note that you configured two distinct *tsconfig.json* files. Editors
    like Visual Studio Code pick up configuration information only for *tsconfig.json*
    files per folder. You could as well name them *tsconfig.server.json* and *tsconfig.client.json*
    and have them in your project’s root folder (and adjust all directory properties).
    `tsc` will use the correct configurations and throw errors if it finds any, but
    the editor will mostly stay silent or work with a default configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Things get a bit hairier if you want to have shared dependencies. One way to
    achieve shared dependencies is to use project references and composite projects.
    This means that you extract your shared code in its own folder, but tell TypeScript
    that this is meant to be a dependency project of another one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a *shared* folder on the same level as *client* and *server*. Create
    a *tsconfig.json* in *shared* with these contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Two things stand out again:'
  prefs: []
  type: TYPE_NORMAL
- en: The flag `composite` is set to `true`. This allows other projects to reference
    this one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `declaration` flag is also set to `true`. This will generate *d.ts* files
    from your code so other projects can consume type information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To include them in your client and server code, add this line to *client/tsconfig.json*
    and *server/tsconfig.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: And you are all set. You can write shared dependencies and include them in your
    client and server code.
  prefs: []
  type: TYPE_NORMAL
- en: There is a caveat, however. This works great if you share, for example, only
    models and type information, but the moment you share actual functionality, you
    will see that the two different module systems (CommonJS in Node, ECMAScript modules
    in the browser) can’t be unified in one compiled file. You either create an ESNext
    module and can’t import it in CommonJS code or create CommonJS code and can’t
    import it in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two things you can do:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile to CommonJS and let a bundler take care of the module resolution work
    for the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile to ECMAScript modules and write modern Node.js applications based on
    ECMAScript modules. See [Recipe 1.9](#ch01_item_modules) for more information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since you are starting out new, I strongly recommend the second option.
  prefs: []
  type: TYPE_NORMAL
- en: 1.7 Setting Up Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to write tests, but the globals for testing frameworks interfere with
    your production code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a separate *tsconfig* for development and build, and exclude all test
    files in the latter one.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the JavaScript and Node.js ecosystem, there are a lot of unit testing frameworks
    and test runners. They vary in detail, have different opinions, or are tailored
    for certain needs. Some of them might just be prettier than others.
  prefs: []
  type: TYPE_NORMAL
- en: 'While test runners like [Ava](https://oreil.ly/R6xFr) rely on importing modules
    to get the framework into scope, others provide a set of globals. Take [Mocha](https://mochajs.org),
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`assert` comes from the Node.js built-in assertion library, but `describe`,
    `it`, and many more are globals provided by Mocha. They also only exist when the
    Mocha CLI is running.'
  prefs: []
  type: TYPE_NORMAL
- en: This provides a bit of a challenge for your type setup, as those functions are
    necessary to write tests but aren’t available when you execute your actual application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to create two different configuration files: a regular *tsconfig.json*
    for development that your editor can pick up (remember [Recipe 1.6](#ch01_item_fullstack))
    and a separate *tsconfig.build.json* that you use when you want to compile your
    application.'
  prefs: []
  type: TYPE_NORMAL
- en: The first one includes all the globals you need, including types for Mocha;
    the latter makes sure no test file is included within your compilation.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through this step by step. We look at Mocha as an example, but other
    test runners that provide globals like [Jest](https://jestjs.io) work just the
    same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install Mocha and its types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new *tsconfig.base.json*. Since the only differences between development
    and build are the set of files to be included and the libraries activated, you
    want to have all the other compiler settings located in one file you can reuse
    for both. An example file for a Node.js application would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The source files should be located in *src*; test files should be located in
    an adjacent folder *test*. The setup you create in this recipe will also allow
    you to create files ending with *.test.ts* anywhere in your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new *tsconfig.json* with your base development configuration. This
    one is used for editor feedback and for running tests with Mocha. You extend the
    basic settings from *tsconfig.base.json* and inform TypeScript which folders to
    pick up for compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Note that you add `types` for Node and Mocha. The `types` property defines which
    globals are available and, in the development setting, you have both.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, you might find that compiling your tests before executing them
    is cumbersome. There are shortcuts to help you. For example, `ts-node` runs your
    local installation of Node.js and does an in-memory TypeScript compilation first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'With the development environment set up, it’s time for the build environment.
    Create a *tsconfig.build.json*. It looks similar to *tsconfig.json*, but you will
    spot the difference right away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: In addition to changing `types` and `rootDirs`, you define which files to exclude
    from type-checking and compilation. You use wild-card patterns that exclude all
    files ending with *.test.ts* that are located in test folders. Depending on your
    taste, you can also add *.spec.ts* or *spec* folders to this array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compile your project by referring to the right JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see that in the result files (located in `dist`), you won’t see any
    test file. Also, while you still can access `describe` and `it` when editing your
    source files, you will get an error if you try to compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t like polluting your globals during development mode, you can choose
    a similar setup as in [Recipe 1.6](#ch01_item_fullstack), but it won’t allow you
    to write tests adjacent to your source files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can always opt for a test runner that prefers the module system.
  prefs: []
  type: TYPE_NORMAL
- en: 1.8 Typing ECMAScript Modules from URLs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to work without bundlers and use the browser’s module-loading capabilities
    for your app, yet you still want to have all the type information.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set `target` and `module` in your *tsconfig*’s compiler options to `esnext`
    and point to your modules with a *.js* extension. In addition, install types to
    dependencies via NPM, and use the `path` property in your *tsconfig* to tell TypeScript
    where to look for types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern browsers support module loading out of the box. Instead of bundling your
    app into a smaller set of files, you can use the raw JavaScript files directly.
  prefs: []
  type: TYPE_NORMAL
- en: Content Delivery Networks (CDNs) like [esm.sh](https://esm.sh), [unpkg](https://unpkg.com),
    and others are designed to distribute node modules and JavaScript dependencies
    as URLs, consumable by native ECMAScript module loading.
  prefs: []
  type: TYPE_NORMAL
- en: With proper caching and state-of-the-art HTTP, ECMAScript modules become a real
    alternative for apps.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript does not include a modern bundler, so you would need to install an
    extra tool anyway. But if you decide to go module first, there are a few things
    to consider when working with TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you want to achieve is to write `import` and `export` statements in TypeScript
    but preserve the module-loading syntax and let the browser handle module resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To achieve this, tell TypeScript to:'
  prefs: []
  type: TYPE_NORMAL
- en: Compile to an ECMAScript version that understands modules
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the ECMAScript module syntax for module code generation
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update two properties in your *tsconfig.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`module` tells TypeScript how to transform import and export statements. The
    default converts module loading to CommonJS, as seen in [Recipe 1.2](#ch01_item_installing).
    Setting `module` to `esnext` will use ECMAScript module loading and thus preserve
    the syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: '`target` tells TypeScript the ECMAScript version you want to transpile your
    code to. Once a year, there’s a new ECMAScript release with new features. Setting
    `target` to `esnext` will always target the latest ECMAScript version.'
  prefs: []
  type: TYPE_NORMAL
- en: Depending on your compatibility goals, you might want to set this property to
    the ECMAScript version compatible with the browsers you want to support. This
    is usually a version with a year (e.g. `es2015`, `es2016`, `es2017`, etc). ECMAScript
    modules work with every version from `es2015` on. If you go for an older version,
    you won’t be able to load ECMAScript modules natively in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing these compiler options already does one important thing: it leaves
    the syntax intact. A problem occurs once you want to run your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Usually, import statements in TypeScript point to files without an extension.
    You write `import { obj } from "./module"`, leaving out *.ts*. Once you compile,
    this extension is still missing. But the browser needs an extension to actually
    point to the respective JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution: Add a *.js* extension, even though you are pointing to a *.ts*
    file when you develop. TypeScript is smart enough to pick that up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: For your project’s modules, that’s all you need!
  prefs: []
  type: TYPE_NORMAL
- en: 'It gets a lot more interesting when you want to use dependencies. If you go
    native, you might want to load modules from a CDN, like [esm.sh](https://esm.sh):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript will error with the following message: “Cannot find module *…​*
    or its corresponding type declarations. (2307)”'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s module resolution works when files are on your disk, not on a server
    via HTTP. To get the info we need, we have to provide TypeScript with a resolution
    of our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though we are loading dependencies from URLs, the type information for
    these dependencies lives with NPM. For `lodash`, you can install type information
    from Definitely Typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'For dependencies that come with their own types, you can install the dependencies
    directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the types are installed, use the `path` property in your compiler options
    to tell TypeScript how to resolve your URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Be sure to point to the right file!
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s also an escape hatch if you don’t want to use typings, or if you just
    can’t find typings. Within TypeScript, we can use `any` to intentionally disable
    type-checking. For modules, we can do something very similar—ignore the TypeScript
    error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`ts-ignore` removes the *next* line from type-checking and can be used everywhere
    you want to ignore type errors (see [Recipe 1.4](#ch01_item_migrating)). This
    effectively means that you won’t get any type information for your dependencies
    and you might run into errors, but it might be the ultimate solution for unmaintained,
    old dependencies that you just need but won’t find any types for.'
  prefs: []
  type: TYPE_NORMAL
- en: 1.9 Loading Different Module Types in Node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use ECMAScript modules in Node.js and the CommonJS interoperability
    feature for libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Set TypeScript’s module resolution to `"nodeNext"` and name your files *.mts*
    or *.cts*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the advent of Node.js, the CommonJS module system has become one of the
    most popular module systems in the JavaScript ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is simple and effective: define exports in one module and require
    them in another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This system has been a huge influence on ECMAScript modules and also has been
    the default for TypeScript’s module resolution and transpiler. If you look at
    the ECMAScript modules syntax in [Example 1-1](#listing_cts), you can see that
    the keywords allow for different transpilations. This means that with the `commonjs`
    module setting, your `import` and `export` statements are transpiled to `require`
    and `exports`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1-1\. Using the ECMAScript module system
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: With ECMAScript modules stabilizing, Node.js has also started to adopt them.
    Even though the basics of both module systems seem to be very similar, there are
    some differences in the details, such as handling default exports or loading ECMAScript
    modules asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: As there is no way to treat both module systems the same but with different
    syntax, the Node.js maintainers decided to give both systems room and assigned
    different file endings to indicate the preferred module type. [Table 1-1](#table_mjs_cjs_js)
    shows the different endings, how they’re named in TypeScript, what TypeScript
    compiles them to, and what they can import. Thanks to the CommonJS interoperability,
    it’s fine to import CommonJS modules from ECMAScript modules, but not the other
    way around.
  prefs: []
  type: TYPE_NORMAL
- en: Table 1-1\. Module endings and what they import
  prefs: []
  type: TYPE_NORMAL
- en: '| Ending | TypeScript | Compiles to | Can import |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *.js* | *.ts* | CommonJS | *.js*, *.cjs* |'
  prefs: []
  type: TYPE_TB
- en: '| *.cjs* | *.cts* | CommonJS | *.js*, *.cjs* |'
  prefs: []
  type: TYPE_TB
- en: '| *.mjs* | *.mts* | ES Modules | *.js*, *.cjs*, *.mjs* |'
  prefs: []
  type: TYPE_TB
- en: 'Library developers who publish on NPM get extra information in their *package.json*
    file to indicate the main type of a package (`module` or `commonjs`), and to point
    to a list of main files or fallbacks so module loaders can pick up the right file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript, you write mainly ECMAScript module syntax and let the compiler
    decide which module format to create in the end. Now there are possibly two: CommonJS
    and ECMAScript modules.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow for both, you can set module resolution in your *tsconfig.json* to
    `NodeNext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: With that flag, TypeScript will pick up the right modules as described in your
    dependencies *package.json*, will recognize *.mts* and *.cts* endings, and will
    follow [Table 1-1](#table_mjs_cjs_js) for module imports.
  prefs: []
  type: TYPE_NORMAL
- en: For you as a developer, there are differences in importing files. Since CommonJS
    didn’t require endings when importing, TypeScript still supports imports without
    endings. The example in [Example 1-1](#listing_cts) still works, if all you use
    is CommonJS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Importing with file endings, just like in [Recipe 1.8](#ch01_item_es_modules),
    allows modules to be imported in both ECMAScript modules and CommonJS modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Should CommonJS interoperability not work, you can always fall back on a `require`
    statement. Add `"node"` as global types to your compiler options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, import with this TypeScript-specific syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In a CommonJS module, this will be just another `require` call; in ECMAScript
    modules, this will include Node.js helper functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Note that this will reduce compatibility with non-Node.js environments like
    the browser, but it might eventually fix interoperability issues.
  prefs: []
  type: TYPE_NORMAL
- en: 1.10 Working with Deno and Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use TypeScript with Deno, a modern JavaScript runtime for applications
    outside the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That’s easy; TypeScript is built in.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Deno is a modern JavaScript runtime created by the same people who developed
    Node.js. Deno is similar to Node.js in many ways, but with significant differences:'
  prefs: []
  type: TYPE_NORMAL
- en: Deno adopts web platform standards for their main APIs, meaning that you will
    find it easier to port code from the browser to the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows file system or network access only if you explicitly activate it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t handle dependencies via a centralized registry, but—again adopting
    browser features—via URLs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oh, and it comes with built-in development tooling and TypeScript!
  prefs: []
  type: TYPE_NORMAL
- en: 'Deno is the tool with the lowest barrier if you want to try TypeScript. No
    need to download any other tool (the `tsc` compiler is already built in), no need
    for TypeScript configurations. You write *.ts* files, and Deno handles the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Deno’s TypeScript can do everything `tsc` can do, and it is updated with every
    Deno update. However, there are some differences when you want to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: First, the default configuration has differences in its default settings as
    opposed to the default configuration issued by `tsc --init`. Strict mode feature
    flags are set differently, and it includes support for React (on the server side!).
  prefs: []
  type: TYPE_NORMAL
- en: 'To make changes to the configuration, you should create a *deno.json* file
    in your root folder. Deno will automatically pick this up, unless you tell it
    not to. *deno.json* includes several configurations for the Deno runtime, including
    TypeScript compiler options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: You can see more possibilities on the [Deno website](https://oreil.ly/zGA--).
  prefs: []
  type: TYPE_NORMAL
- en: The default libraries are different as well. Even though Deno supports web platform
    standards and has browser-compatible APIs, it needs to make some cuts because
    there is no graphical user interface. That’s why some types—for example, the DOM
    library—clash with what Deno provides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some libraries of interest are:'
  prefs: []
  type: TYPE_NORMAL
- en: '*deno.ns*, the default Deno namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*deno.window*, the global object for Deno'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*deno.worker*, the equivalent for Web Workers in the Deno runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DOM and subsets are included in Deno, but they are not switched on by default.
    If your application targets both the browser and Deno, configure Deno to include
    all browser and Deno libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[Aleph.js](https://alephjs.org) is an example of a framework that targets both
    Deno and the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: Also different with Deno is how type information for dependencies is distributed.
    External dependencies in Deno are loaded via URLs from a CDN. Deno itself hosts
    its standard library at [*https://deno.land/std*](https://deno.land/std).
  prefs: []
  type: TYPE_NORMAL
- en: But you can also use CDNs like [esm.sh](https://esm.sh) or [unpkg](https://unpkg.com),
    like in [Recipe 1.8](#ch01_item_es_modules). These CDNs distribute types by sending
    an `X-TypeScript-Types` header with the HTTP request, showing Deno was to load
    type declarations. This also goes for dependencies that don’t have first-party
    type declarations but rely on Definitely Typed.
  prefs: []
  type: TYPE_NORMAL
- en: So the moment you install your dependency, Deno will fetch not only the source
    files but also all the type information.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t load a dependency from a CDN but rather have it locally, you can
    point to a type declaration file the moment you import the dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'or include a reference to the typings in the library itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This reference is also called a *triple-slash directive* and is a TypeScript
    feature, not a Deno feature. There are various triple-slash directives, mostly
    used for pre-ECMAScript module dependency systems. The [documentation](https://oreil.ly/EvUWm)
    gives a really good overview. If you stick with ECMAScript modules, you most likely
    won’t use triple-slash directives, though.
  prefs: []
  type: TYPE_NORMAL
- en: 1.11 Using Predefined Configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use TypeScript for a certain framework or platform but don’t know
    where to start with your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a predefined configuration from [*tsconfig/bases*](https://oreil.ly/ljsVT)
    and extend from there.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like Definitely Typed hosts community-maintained type definitions for popular
    libraries, *tsconfig/bases* hosts a set of community-maintained recommendations
    for TypeScript configurations you can use as a starting point for your own project.
    This includes frameworks like Ember.js, Svelte, or Next.js as well as JavaScript
    runtimes like Node.js and Deno.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration files are reduced to a minimum, dealing mostly with recommended
    libraries, modules, and target settings, and a bunch of strict mode flags that
    make sense for the respective environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this is the recommended configuration for Node.js 18, with a recommended
    strict mode setting and with ECMAScript modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this configuration, install it via NPM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'and wire it up in your own TypeScript configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: This will pick up all the settings from the predefined configuration. You can
    now start setting your own properties, for example, root and out directories.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch01.html#id393-marker)) Objects assigned to a `const` binding can still
    change values and properties, and thus change their types.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch01.html#id406-marker)) TypeScript also works in other JavaScript runtimes,
    such as Deno and the browser, but they are not intended as main targets.
  prefs: []
  type: TYPE_NORMAL
