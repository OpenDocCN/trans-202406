<html><head></head><body><section data-pdf-bookmark="Chapter 7. Shipping Controllers and Operators" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_shipping">&#13;
<h1><span class="label">Chapter 7. </span>Shipping Controllers and Operators</h1>&#13;
&#13;
&#13;
<p>Now that you’re familiar with the development of custom controllers, let’s move on to the topic of how to make your custom controllers and operators production-ready. In this chapter we’ll discuss the operational aspects of controllers and operators, showing you how to package them, walking you through best practices for running controllers in production, and making sure that your extension points don’t break your Kubernetes cluster, security, or performance-wise.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lifecycle Management and Packaging" data-type="sect1"><div class="sect1" id="packaging">&#13;
<h1>Lifecycle Management and Packaging</h1>&#13;
&#13;
<p>In<a data-primary="deployment (controllers and operators)" data-secondary="overview of" data-type="indexterm" id="idm46336854804504"/><a data-primary="controllers and operators" data-secondary="packaging" data-type="indexterm" id="CAOlife07"/> this section we consider the lifecycle management of operators. That is, we will discuss how to package and ship your controller or operator, as well as how to handle upgrades. When you’re ready to ship your operator to users, you’ll need a way for them to install it. For this, you need to package the respective artifacts, such as YAML manifests that define the controller binary (typically as a Kubernetes deployment), along with the CRDs and security-related resources, such as service accounts and the necessary RBAC permissions. Once your targeted users have a certain version of the operator running, you will also want to have a mechanism in place for upgrading the controller, considering versioning and potentially zero-downtime upgrades.</p>&#13;
&#13;
<p>Let’s start with the low-hanging fruit: packaging and delivering your controllers so that a user can install it in a straightforward manner.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Packaging: The Challenge" data-type="sect2"><div class="sect2" id="packaging_challenge">&#13;
<h2>Packaging: The Challenge</h2>&#13;
&#13;
<p>While Kubernetes<a data-primary="deployment (controllers and operators)" data-secondary="packaging challenges" data-type="indexterm" id="idm46336854798824"/><a data-primary="packaging" data-secondary="challenges of" data-type="indexterm" id="idm46336854797752"/> defines resources with manifests, typically written in YAML, a low-level interface to declare the state of resources, these manifest files have shortcomings. Most importantly in the context of packaging containerized apps, the YAML manifests are static; that is, all values in a YAML manifest are fixed. This means that if you want to change the container image in a <a href="http://bit.ly/2WZ1uRD">deployment manifest</a>, for example, you have to create a new manifest.</p>&#13;
&#13;
<p>Let’s look at a concrete example. Assume you have the following Kubernetes deployment encoded in a YAML manifest called <em>mycontroller.yaml</em>, representing the custom controller you’d like users to install:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">mycustomcontroller</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
  <code class="nt">template</code><code class="p">:</code>&#13;
    <code class="nt">metadata</code><code class="p">:</code>&#13;
      <code class="nt">labels</code><code class="p">:</code>&#13;
        <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">customcontroller</code>&#13;
    <code class="nt">spec</code><code class="p">:</code>&#13;
      <code class="nt">containers</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">thecontroller</code>&#13;
        <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">example/controller:0.1.0</code>&#13;
        <code class="nt">ports</code><code class="p">:</code>&#13;
        <code class="p-Indicator">-</code> <code class="nt">containerPort</code><code class="p">:</code> <code class="l-Scalar-Plain">9999</code>&#13;
        <code class="nt">env</code><code class="p">:</code>&#13;
        <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">REGION</code>&#13;
          <code class="nt">value</code><code class="p">:</code> <code class="l-Scalar-Plain">eu-west-1</code></pre>&#13;
&#13;
<p>Imagine the environment variable <code>REGION</code> defines certain runtime properties of your controller, such as the availability of other services like a managed service mesh. In other words, while the default value of <code>eu-west-1</code> might be a sensible one, users can and likely will overwrite it, based on their own preferences or policies.</p>&#13;
&#13;
<p>Now, given that the YAML manifest <em>mycontroller.yaml</em> itself is a static file with all values defined at the time of writing—and clients such as <code>kubectl</code> don’t inherently support variable parts in the manifest—how do you enable users to supply variable values or overwrite existing values at runtime? That is, how in the preceding example can a user set <code>REGION</code> to, say, <code>us-east-2</code> when they’re installing it, using<a data-primary="kubectl apply" data-type="indexterm" id="idm46336854735144"/> (for example) <code>kubectl apply</code>?</p>&#13;
&#13;
<p>To overcome these limitations of build-time, static<a data-primary="YAML manifests" data-type="indexterm" id="idm46336854733576"/> YAML manifests in Kubernetes, there are a few options to templatize the manifests (Helm, for example) or otherwise enable variable input (Kustomize), depending on user-provided values or runtime properties.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Helm" data-type="sect2"><div class="sect2" id="helm">&#13;
<h2>Helm</h2>&#13;
&#13;
<p><a href="https://helm.sh">Helm</a>, which<a data-primary="deployment (controllers and operators)" data-secondary="packaging with Helm" data-type="indexterm" id="idm46336854729640"/><a data-primary="packaging" data-secondary="with Helm" data-type="indexterm" id="idm46336854728664"/><a data-primary="Helm" data-type="indexterm" id="idm46336854727720"/><a data-primary="package management" data-type="indexterm" id="idm46336854727048"/> touts itself as <em>the</em> package manager for Kubernetes, was originally developed by Deis and is now a Cloud Native Computing Foundation (<a href="https://www.cncf.io">CNCF</a>) project with major contributors from Microsoft, Google, and Bitnami (now part of VMware).</p>&#13;
&#13;
<p>Helm<a data-primary="charts" data-type="indexterm" id="idm46336854724616"/> helps you to install and upgrade Kubernetes applications by defining and applying so-called charts, effectively parameterized YAML manifests. Here is an excerpt of an <a href="http://bit.ly/2XmLk3R">example chart template</a>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">include "flagger.fullname" .</code> <code class="p-Indicator">}}</code>&#13;
<code class="nn">...</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
  <code class="nt">strategy</code><code class="p">:</code>&#13;
    <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Recreate</code>&#13;
  <code class="nt">selector</code><code class="p">:</code>&#13;
    <code class="nt">matchLabels</code><code class="p">:</code>&#13;
      <code class="nt">app.kubernetes.io/name</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">template "flagger.name" .</code> <code class="p-Indicator">}}</code>&#13;
      <code class="nt">app.kubernetes.io/instance</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">.Release.Name</code> <code class="p-Indicator">}}</code>&#13;
  <code class="nt">template</code><code class="p">:</code>&#13;
    <code class="nt">metadata</code><code class="p">:</code>&#13;
      <code class="nt">labels</code><code class="p">:</code>&#13;
        <code class="nt">app.kubernetes.io/name</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">template "flagger.name" .</code> <code class="p-Indicator">}}</code>&#13;
        <code class="nt">app.kubernetes.io/instance</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">.Release.Name</code> <code class="p-Indicator">}}</code>&#13;
    <code class="nt">spec</code><code class="p">:</code>&#13;
      <code class="nt">serviceAccountName</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">template "flagger.serviceAccountName" .</code> <code class="p-Indicator">}}</code>&#13;
      <code class="nt">containers</code><code class="p">:</code>&#13;
        <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">flagger</code>&#13;
          <code class="nt">securityContext</code><code class="p">:</code>&#13;
            <code class="nt">readOnlyRootFilesystem</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
            <code class="nt">runAsUser</code><code class="p">:</code> <code class="l-Scalar-Plain">10001</code>&#13;
          <code class="nt">image</code><code class="p">:</code> <code class="s">"{{</code><code class="nv"> </code><code class="s">.Values.image.repository</code><code class="nv"> </code><code class="s">}}:{{</code><code class="nv"> </code><code class="s">.Values.image.tag</code><code class="nv"> </code><code class="s">}}"</code></pre>&#13;
&#13;
<p>As you can see, variables are encoded in <code>{{ ._Some.value.here_ }}</code> format, which happens to be <a href="http://bit.ly/2N2Q3DW">Go templates</a>.</p>&#13;
&#13;
<p>To install a chart, you can run the <code>helm install</code> command. While Helm has several ways to find and install charts, the easiest is to use one of the official stable charts:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="c"># get the latest list of charts:</code>&#13;
<code class="nv">$ </code>helm repo update&#13;
&#13;
<code class="c"># install MySQL:</code>&#13;
<code class="nv">$ </code>helm install stable/mysql&#13;
Released smiling-penguin&#13;
&#13;
<code class="c"># list running apps:</code>&#13;
<code class="nv">$ </code>helm ls&#13;
NAME             VERSION   UPDATED                   STATUS    CHART&#13;
smiling-penguin  <code class="m">1</code>         Wed Sep <code class="m">28</code> 12:59:46 <code class="m">2016</code>  DEPLOYED  mysql-0.1.0&#13;
&#13;
<code class="c"># remove it:</code>&#13;
<code class="nv">$ </code>helm delete smiling-penguin&#13;
Removed smiling-penguin</pre>&#13;
&#13;
<p>In order to package your controller, you will need to create a Helm chart for it and publish it somewhere, by default to a public repository indexed and accessible through the <a href="https://hub.helm.sh">Helm Hub</a>, as depicted in <a data-type="xref" href="#helm-hub">Figure 7-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="helm-hub">&#13;
<img alt="Helm Hub screen shot, showing publicly available Helm charts" src="assets/prku_0701.png"/>&#13;
<h6><span class="label">Figure 7-1. </span>Helm Hub screenshot showing publicly available Helm charts</h6>&#13;
</div></figure>&#13;
&#13;
<p>For further guidance on how to create Helm charts, peruse the following resources at your leisure:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Bitnami’s excellent article <a href="http://bit.ly/2ZIlODJ">“How to Create Your First Helm Chart”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="http://bit.ly/2KzwLDY">“Using S3 as a Helm Repository”</a>, if you want to keep the charts in your own organization.</p>&#13;
</li>&#13;
<li>&#13;
<p>The official Helm docs: <a href="http://bit.ly/31GbayW">“The Chart Best Practices Guide”</a>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Helm is popular, partly because of its ease of use for end users. However, some argue that the current Helm architecture introduces <a href="http://bit.ly/2WXM5vZ">security risks</a>. The good news is that the community is actively working on addressing those.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kustomize" data-type="sect2"><div class="sect2" id="kustomize">&#13;
<h2>Kustomize</h2>&#13;
&#13;
<p><a href="https://kustomize.io">Kustomize</a> provides<a data-primary="deployment (controllers and operators)" data-secondary="packaging with Kustomize" data-type="indexterm" id="idm46336854223672"/><a data-primary="packaging" data-secondary="with Kustomize" data-type="indexterm" id="idm46336854222680"/><a data-primary="Kustomize" data-type="indexterm" id="idm46336854221736"/><a data-primary="manifest files" data-type="indexterm" id="idm46336854221064"/> a declarative approach to configuration customization of Kubernetes manifest files, adhering to the familiar Kubernetes API. It was <a href="http://bit.ly/2L5Ec5f">introduced in mid-2018</a> and is now a Kubernetes SIG CLI project.</p>&#13;
&#13;
<p>You can <a href="http://bit.ly/2Y3JeCV">install</a> Kustomize on your machine, as a standalone, or, if you have a more recent <code>kubectl</code> version (newer than 1.14), it is <a href="http://bit.ly/2IEYqRG">shipped</a> with <code>kubectl</code> and activated with the <code>-k</code> command-line flag.</p>&#13;
&#13;
<p>So, Kustomize lets you customize the raw YAML manifest files, without touching the original manifest. But how does this work in practice? Let’s assume you want to package our <code>cnat</code> custom controller; you’d define a file called <em>kustomize.yaml</em> that looks something like:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">imageTags</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">quay.io/programming-kubernetes/cnat-operator</code>&#13;
    <code class="nt">newTag</code><code class="p">:</code> <code class="l-Scalar-Plain">0.1.0</code>&#13;
<code class="nt">resources</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="l-Scalar-Plain">cnat-controller.yaml</code></pre>&#13;
&#13;
<p>Now you can apply this to the <em>cnat-controller.yaml</em> file, say, with the following <span class="keep-together">content</span>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cnat-controller</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
  <code class="nt">template</code><code class="p">:</code>&#13;
    <code class="nt">metadata</code><code class="p">:</code>&#13;
      <code class="nt">labels</code><code class="p">:</code>&#13;
        <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">cnat</code>&#13;
    <code class="nt">spec</code><code class="p">:</code>&#13;
      <code class="nt">containers</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">custom-controller</code>&#13;
        <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">quay.io/programming-kubernetes/cnat-operator</code></pre>&#13;
&#13;
<p>Use <code>kustomize build</code> and—leaving the <em>cnat-controller.yaml</em> file unchanged!—the output is then:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">cnat-controller</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
  <code class="nt">template</code><code class="p">:</code>&#13;
    <code class="nt">metadata</code><code class="p">:</code>&#13;
      <code class="nt">labels</code><code class="p">:</code>&#13;
        <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">cnat</code>&#13;
    <code class="nt">spec</code><code class="p">:</code>&#13;
      <code class="nt">containers</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">custom-controller</code>&#13;
        <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">quay.io/programming-kubernetes/cnat-operator:0.1.0</code></pre>&#13;
&#13;
<p>The<a data-primary="kubectl apply" data-type="indexterm" id="idm46336854086504"/> output of <code>kustomize build</code> can then, for example, be used in a <code>kubectl apply</code> command, with all the <a href="http://bit.ly/2LbCDTr">customizations</a> applied for you, automatically.</p>&#13;
&#13;
<p>For a more detailed walk-through of Kustomize and how to use it, check out the following resources:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Sébastien Goasguen’s blog post <a href="http://bit.ly/2JbgJOR">“Configuring Kubernetes Applications with <span class="keep-together">kustomize</span>"</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Kevin Davin’s post <a href="http://bit.ly/2JpJgPm">“Kustomize—The right way to do templating in Kubernetes”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The video <a href="http://bit.ly/2XoHm6C">“TGI Kubernetes 072: Kustomize and friends”</a>, where you can watch Joe Beda apply it.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Given the native support of Kustomize in <code>kubectl</code>, it’s likely that an increasing number of users will adopt it. Note that while it solves some problems (customization), there are other areas of the lifecycle management, such as validations and upgrades, that may require you to use Kustomize together with languages such as Google’s <a href="http://bit.ly/32heAZl">CUE</a>.</p>&#13;
&#13;
<p>To wrap up this packaging topic, let’s review some other solutions practitioners use.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Other Packaging Options" data-type="sect2"><div class="sect2" id="other_packaging">&#13;
<h2>Other Packaging Options</h2>&#13;
&#13;
<p>Some<a data-primary="packaging" data-secondary="other options for" data-type="indexterm" id="idm46336854037464"/><a data-primary="deployment (controllers and operators)" data-secondary="packaging with other tools" data-type="indexterm" id="idm46336854036456"/> notable alternatives to the aforementioned packaging options—and the many others <a href="http://bit.ly/2X553FE">in the wild</a>—are:</p>&#13;
<dl>&#13;
<dt>UNIX tooling</dt>&#13;
<dd>&#13;
<p>In<a data-primary="UNIX tooling, for packaging" data-type="indexterm" id="idm46336854032600"/> order to customize values of raw Kubernetes manifests, you can use a range of CLI tools such as <code>sed</code>, <code>awk</code>, or <code>jq</code> in shell scripts. This is a popular solution and, at least until the arrival of Helm, likely the most widely used option—not least because it minimizes dependencies and is rather portable across *nix <span class="keep-together">environments</span>.</p>&#13;
</dd>&#13;
<dt>Traditional configuration management systems</dt>&#13;
<dd>&#13;
<p>You<a data-primary="configuration management systems" data-type="indexterm" id="idm46336854028280"/><a data-primary="Ansible" data-type="indexterm" id="idm46336854027528"/><a data-primary="Salt" data-type="indexterm" id="idm46336854026856"/><a data-primary="Chef" data-type="indexterm" id="idm46336854026184"/><a data-primary="Puppet" data-type="indexterm" id="idm46336854025512"/> can use any of the traditional configuration management systems, such as Ansible, Puppet, Chef, or Salt, to package and deliver your operator.</p>&#13;
</dd>&#13;
<dt>Cloud-native languages</dt>&#13;
<dd>&#13;
<p>A<a data-primary="cloud-native languages" data-type="indexterm" id="idm46336854023272"/><a data-primary="Plumi" data-type="indexterm" id="idm46336854022536"/><a data-primary="Ballerina" data-type="indexterm" id="idm46336854021864"/> new generation of so-called <a href="http://bit.ly/2Rwh5lu">cloud-native programming languages</a>, such as Pulumi and Ballerina, allows for, among other things, packaging and lifecycle management of Kubernetes-native apps.</p>&#13;
</dd>&#13;
<dt><a href="https://get-ytt.io">ytt</a></dt>&#13;
<dd>&#13;
<p>With <code>ytt</code> you<a data-primary="ytt" data-type="indexterm" id="idm46336854018088"/> have another option for a YAML templating tool using a language that is itself a modified version of Google’s configuration language <a href="http://bit.ly/2NaqoJh">Starlark</a>. It operates semantically on the YAML structures and focuses on reusability.</p>&#13;
</dd>&#13;
<dt><a href="https://ksonnet.io">Ksonnet</a></dt>&#13;
<dd>&#13;
<p>A<a data-primary="ksonnet" data-type="indexterm" id="idm46336854014696"/> configuration management tool for Kubernetes manifests, originally developed by Heptio (now VMware), Ksonnet has been deprecated and is not actively worked on anymore, so use it at your own risk.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Read more about the options discussed here in Jesse Suen’s post <a href="http://bit.ly/2N9BkXM">“The State of Kubernetes Configuration Management: An Unsolved Problem”</a>.</p>&#13;
&#13;
<p>Now that we’ve discussed the packaging options in general, let’s look at best practices for packaging and shipping controllers and operators.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Packaging Best Practices" data-type="sect2"><div class="sect2" id="packaging_gp">&#13;
<h2>Packaging Best Practices</h2>&#13;
&#13;
<p>When<a data-primary="deployment (controllers and operators)" data-secondary="packaging best practices" data-type="indexterm" id="idm46336854010280"/><a data-primary="packaging" data-secondary="best practices" data-type="indexterm" id="idm46336854009192"/> packaging and publishing your operator, make sure you are aware of the following best practices. These apply regardless of which mechanism you choose (Helm, Kustomize, shell scripts, etc.):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Provide<a data-primary="access control" data-secondary="best practices" data-type="indexterm" id="idm46336853986120"/> a proper access control setup: this means defining a dedicated service account for the controller along with the RBAC permissions on a least-privileges basis; see <a data-type="xref" href="#crds-rbac">“Getting the Permissions Right”</a> for further details.</p>&#13;
</li>&#13;
<li>&#13;
<p>Consider<a data-primary="controllers and operators" data-secondary="custom controller scope" data-type="indexterm" id="idm46336853983144"/> the scope of your custom controller: will it look after CRs in one namespace or more than one namespace? Check out <a href="http://bit.ly/2ZHd5S7">Alex Ellis’s Twitter conversation</a> about the pros and cons of the different approaches.</p>&#13;
</li>&#13;
<li>&#13;
<p>Test<a data-primary="controllers and operators" data-secondary="footprint and scalability of" data-type="indexterm" id="idm46336853980456"/> and profile your controller so that you have an idea of its footprint and scalability. For example, Red Hat has put together a detailed set of requirements with instructions in the OperatorHub <a href="http://bit.ly/2IEplx4">contribution</a> guide.</p>&#13;
</li>&#13;
<li>&#13;
<p>Make<a data-primary="custom resource definitions (CRDs)" data-secondary="best practices" data-type="indexterm" id="idm46336853977496"/><a data-primary="controllers and operators" data-secondary="documenting with inline docs" data-type="indexterm" id="idm46336853976520"/> sure the CRDs and controller are well documented, ideally with the inline docs available on <a href="https://godoc.org">godoc.org</a> and a set of usage examples; see Banzai Cloud’s <a href="http://bit.ly/2XtfPVB">bank-vaults</a> operator for inspiration.<a data-primary="" data-startref="CAOlife07" data-type="indexterm" id="idm46336853973944"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Lifecycle Management" data-type="sect2"><div class="sect2" id="operator_lm">&#13;
<h2>Lifecycle Management</h2>&#13;
&#13;
<p>A<a data-primary="controllers and operators" data-secondary="lifecycle management" data-type="indexterm" id="idm46336853970488"/><a data-primary="deployment (controllers and operators)" data-secondary="lifecycle management" data-type="indexterm" id="idm46336853969448"/><a data-primary="packaging" data-secondary="lifecycle management" data-type="indexterm" id="idm46336853968504"/><a data-primary="lifecycle management" data-type="indexterm" id="idm46336853967560"/> broader and more holistic approach, compared to package/ship, is that of lifecycle management. The basic idea is to consider the entire supply chain, from development to shipping to upgrades, and automate as much as possible. In this area, CoreOS (and later Red Hat) was again a trailblazer: applying the same logic that led to operators to their lifecycle management. In other words: in order to install and later upgrade the custom controller of an operator, you’d have a dedicated operator that knows how to, well, handle operators. And<a data-primary="OLM (Operator Lifecycle Management)" data-type="indexterm" id="idm46336853966200"/> indeed, part of the Operator Framework—which also provides the Operator SDK, as discussed in <a data-type="xref" href="ch06.html#operator-sdk">“The Operator SDK”</a>—is the so-called <a href="http://bit.ly/2HIfDcR">Operator Lifecycle Manager</a> (OLM).</p>&#13;
&#13;
<p>Jimmy Zelinskie, one of the main people behind OLM, <a href="http://bit.ly/2KEfoSu">phrased</a> it as follows:</p>&#13;
<blockquote>&#13;
<p>OLM does a lot for Operator authors, but it also solves an important problem that not many people have thought about yet: how do you effectively manage first-class extensions to Kubernetes over time?</p></blockquote>&#13;
&#13;
<p>In a nutshell, OLM provides a declarative way to install and upgrade operators and their dependencies, complementary packaging solutions such as Helm. It’s up to you if you want to buy into the full-blown OLM solution or create an ad hoc solution for the versioning and upgrading challenge; however, you should have some strategy in place here. For certain areas—for example, the <a href="http://bit.ly/2KBlymy">certification process</a> for the Operator Hub by Red Hat—it’s not only recommended but mandatory for any nontrivial deployment scenario, even if you don’t aim at the Hub.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Production-Ready Deployments" data-type="sect1"><div class="sect1" id="crd-prod">&#13;
<h1>Production-Ready Deployments</h1>&#13;
&#13;
<p>In<a data-primary="deployment (controllers and operators)" data-secondary="production-ready overview" data-type="indexterm" id="idm46336853958472"/><a data-primary="controllers and operators" data-secondary="production-ready deployments" data-type="indexterm" id="CAOprod07"/> this section we review and discuss how to make your custom controllers and operators production-ready. The following is a high-level checklist:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use Kubernetes <a href="http://bit.ly/2q7vR7Y">deployments</a> or DaemonSets to supervise your custom controller so that they are restarted automatically when they fail—and fail they will.</p>&#13;
</li>&#13;
<li>&#13;
<p>Implement<a data-primary="health checks" data-type="indexterm" id="idm46336853952872"/> health checks through dedicated endpoints for liveness and readiness probes. This, together with the previous step, makes your operations more <span class="keep-together">resilient</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Consider<a data-primary="leader-follower/standby model" data-type="indexterm" id="idm46336853950296"/> a leader-follower/standby model to make sure that even when your controller pod crashes, someone else can take over. Note, however, that synchronizing state is a nontrivial task.</p>&#13;
</li>&#13;
<li>&#13;
<p>Provide<a data-primary="access control" data-secondary="for production-ready deployment" data-type="indexterm" id="idm46336853948440"/> access control resources, such as service account and roles, applying the least-privileges principle; see <a data-type="xref" href="#crds-rbac">“Getting the Permissions Right”</a> for details.</p>&#13;
</li>&#13;
<li>&#13;
<p>Consider<a data-primary="automated builds" data-type="indexterm" id="idm46336853945496"/> automated builds, including testing. Some more tips are available in <a data-type="xref" href="#crds-perf">“Automated Builds and Testing”</a>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Proactively<a data-primary="monitoring and logging" data-type="indexterm" id="idm46336853942888"/><a data-primary="logging" data-type="indexterm" id="idm46336853942152"/> tackle monitoring and logging; see <a data-type="xref" href="#o11y">“Custom Controllers and Observability”</a> for the what and how.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We also suggest that you peruse the aforementioned article <a href="http://bit.ly/31P7rPC">“Kubernetes Operator Development Guidelines for Improved Usability”</a> to learn more.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting the Permissions Right" data-type="sect2"><div class="sect2" id="crds-rbac">&#13;
<h2>Getting the Permissions Right</h2>&#13;
&#13;
<p>Your<a data-primary="access control" data-secondary="role-based access control (RBAC)" data-type="indexterm" id="idm46336853937128"/><a data-primary="role-based access control (RBAC)" data-type="indexterm" id="idm46336853936056"/><a data-primary="deployment (controllers and operators)" data-secondary="access control" data-type="indexterm" id="idm46336853935368"/> custom controller is part of the Kubernetes control plane. It needs to read the state of resources, create resources inside as well as (potentially) outside Kubernetes, and communicate the state of its own resources. For all of this, the custom controller needs the right set of permissions, expressed through a set of role-based access control (RBAC)–related settings. Getting this right is the topic of this section.</p>&#13;
&#13;
<p>First things first: <em>always</em> create a <a href="http://bit.ly/2RwoSQp">dedicated service account</a> to run your controller. In other words: <em>never</em> use the <code>default</code> service account in a namespace.<sup><a data-type="noteref" href="ch07.html#idm46336853931352" id="idm46336853931352-marker">1</a></sup></p>&#13;
&#13;
<p>To make your life easier, you can define a <code>ClusterRole</code> with the necessary RBAC rules along with a <code>RoleBinding</code> to bind it to a specific namespace, effectively reusing the role across namespaces, as explained in the <a href="http://bit.ly/2LdVFsj">Using RBAC Authorization</a> entry.</p>&#13;
&#13;
<p>Following<a data-primary="least-privileges principle" data-type="indexterm" id="idm46336853927336"/> the least-privileges principle, assign only the permissions necessary for the controller to carry out its work. For example, if a controller only manages pods, there is no need to provide it with the permissions to list or create deployments or services. Also, make sure that the controller does not install the CRDs and/or the admission webhooks. In other words, the controller <em>should not</em> have permissions to manage CRDs and webhooks.</p>&#13;
&#13;
<p>Common tooling for creating custom controllers, as discussed in <a data-type="xref" href="ch06.html#ch_operator-solutions">Chapter 6</a>, typically provides functionality for generating RBAC rules out-of-the-box. For example, Kubebuilder generates the <a href="http://bit.ly/2RRCyFO">following</a> RBAC assets, along with an operator:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>ls -al rbac/&#13;
total 40&#13;
drwx------  <code class="m">7</code> mhausenblas  staff   <code class="m">224</code> <code class="m">12</code> Apr 09:52 .&#13;
drwx------  <code class="m">7</code> mhausenblas  staff   <code class="m">224</code> <code class="m">12</code> Apr 09:55 ..&#13;
-rw-------  <code class="m">1</code> mhausenblas  staff   <code class="m">280</code> <code class="m">12</code> Apr 09:49 auth_proxy_role.yaml&#13;
-rw-------  <code class="m">1</code> mhausenblas  staff   <code class="m">257</code> <code class="m">12</code> Apr 09:49 auth_proxy_role_binding.yaml&#13;
-rw-------  <code class="m">1</code> mhausenblas  staff   <code class="m">449</code> <code class="m">12</code> Apr 09:49 auth_proxy_service.yaml&#13;
-rw-r--r--  <code class="m">1</code> mhausenblas  staff  <code class="m">1044</code> <code class="m">12</code> Apr 10:50 rbac_role.yaml&#13;
-rw-r--r--  <code class="m">1</code> mhausenblas  staff   <code class="m">287</code> <code class="m">12</code> Apr 10:50 rbac_role_binding.yaml</pre>&#13;
&#13;
<p>Looking at the autogenerated RBAC roles and bindings reveals a fine-grained setup. In <em>rbac_role.yaml</em> you can find:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">creationTimestamp</code><code class="p">:</code> <code class="l-Scalar-Plain">null</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">manager-role</code>&#13;
<code class="nt">rules</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">apps</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">deployments</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"list"</code><code class="p-Indicator">,</code> <code class="s">"watch"</code><code class="p-Indicator">,</code> <code class="s">"create"</code><code class="p-Indicator">,</code> <code class="s">"update"</code><code class="p-Indicator">,</code> <code class="s">"patch"</code><code class="p-Indicator">,</code> <code class="s">"delete"</code><code class="p-Indicator">]</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">apps</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">deployments/status</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"update"</code><code class="p-Indicator">,</code> <code class="s">"patch"</code><code class="p-Indicator">]</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">cnat.programming-kubernetes.info</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">ats</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"list"</code><code class="p-Indicator">,</code> <code class="s">"watch"</code><code class="p-Indicator">,</code> <code class="s">"create"</code><code class="p-Indicator">,</code> <code class="s">"update"</code><code class="p-Indicator">,</code> <code class="s">"patch"</code><code class="p-Indicator">,</code> <code class="s">"delete"</code><code class="p-Indicator">]</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">cnat.programming-kubernetes.info</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">ats/status</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"update"</code><code class="p-Indicator">,</code> <code class="s">"patch"</code><code class="p-Indicator">]</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">admissionregistration.k8s.io</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">mutatingwebhookconfigurations</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">validatingwebhookconfigurations</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"list"</code><code class="p-Indicator">,</code> <code class="s">"watch"</code><code class="p-Indicator">,</code> <code class="s">"create"</code><code class="p-Indicator">,</code> <code class="s">"update"</code><code class="p-Indicator">,</code> <code class="s">"patch"</code><code class="p-Indicator">,</code> <code class="s">"delete"</code><code class="p-Indicator">]</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="s">""</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">secrets</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"list"</code><code class="p-Indicator">,</code> <code class="s">"watch"</code><code class="p-Indicator">,</code> <code class="s">"create"</code><code class="p-Indicator">,</code> <code class="s">"update"</code><code class="p-Indicator">,</code> <code class="s">"patch"</code><code class="p-Indicator">,</code> <code class="s">"delete"</code><code class="p-Indicator">]</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="s">""</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">services</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code> <code class="s">"list"</code><code class="p-Indicator">,</code> <code class="s">"watch"</code><code class="p-Indicator">,</code> <code class="s">"create"</code><code class="p-Indicator">,</code> <code class="s">"update"</code><code class="p-Indicator">,</code> <code class="s">"patch"</code><code class="p-Indicator">,</code> <code class="s">"delete"</code><code class="p-Indicator">]</code></pre>&#13;
&#13;
<p>Looking at these permissions that Kubebuilder generates in <code>v1</code>, you’ll likely be a little taken aback.<sup><a data-type="noteref" href="ch07.html#idm46336853898344" id="idm46336853898344-marker">2</a></sup> We certainly were: best practice tells us that a controller, if it does not have very good reasons for doing so, should not be able to:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Write resources that are only read in the code, generally. For example, if you only watch services and deployments, do remove the <code>create</code>, <code>update</code>, <code>patch</code>, and <code>delete</code> verbs in the role.</p>&#13;
</li>&#13;
<li>&#13;
<p>Access all secrets; that is, always restrict this to the most minimal set of secrets necessary.</p>&#13;
</li>&#13;
<li>&#13;
<p>Write <code>MutatingWebhookConfigurations</code> or <code>ValidatingWebhookConfigurations</code>. This is equivalent to getting access to any resource in the cluster.</p>&#13;
</li>&#13;
<li>&#13;
<p>Write <code>CustomResourceDefinition</code>s. Note that this is not allowed in the cluster role just shown, but it’s important to mention here, nevertheless: CRD creation should be done by a separate process, not by the controller itself.</p>&#13;
</li>&#13;
<li>&#13;
<p>Write the <em>/status</em> subresource (see <a data-type="xref" href="ch04.html#crd-subresources">“Subresources”</a>) of foreign resources that it is not managing. For example, deployments here are not managed by the <code>cnat</code> controller and should not be in scope.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Kubebuilder, of course, is not really able to understand what your controller code is actually doing. So it’s not surprising that the generated RBAC rules are far too relaxed. We recommend double-checking the permissions and reducing them to the absolute minimum, following the preceding checklist.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Having read access<a data-primary="access control" data-secondary="read access" data-type="indexterm" id="idm46336853611416"/><a data-primary="read access" data-type="indexterm" id="idm46336853610408"/><a data-primary="write access" data-type="indexterm" id="idm46336853609736"/><a data-primary="access control" data-secondary="write access" data-type="indexterm" id="idm46336853609064"/> to all secrets in the system gives a controller access to all service account tokens. This is equivalent to having access to all passwords in the cluster. Having write access to <code>MutatingWebhookConfigurations</code> or <code>ValidatingWebhookConfigurations</code> allows you to intercept and manipulate&#13;
every API request in the system. This opens the door to rootkits in a Kubernetes cluster. Both are obviously highly dangerous and considered antipatterns, so it’s best to avoid them.</p>&#13;
&#13;
<p>To avoid having too much power—that is, to restrict access rights to those that are absolutely necessary—consider using <a href="http://bit.ly/2IDW1qm">audit2rbac</a>. This tool uses audit logs to generate an appropriate set of permissions, leading to more secure setups and fewer headaches down the road.</p>&#13;
</div>&#13;
&#13;
<p>From <em>rbac_role_binding.yaml</em> you can learn:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRoleBinding</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">creationTimestamp</code><code class="p">:</code> <code class="l-Scalar-Plain">null</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">manager-rolebinding</code>&#13;
<code class="nt">roleRef</code><code class="p">:</code>&#13;
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterRole</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">manager-role</code>&#13;
<code class="nt">subjects</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">system</code></pre>&#13;
&#13;
<p>For more best practices on RBAC and tooling around it, check out <a href="https://rbac.dev"><em>RBAC.dev</em></a>, a website dedicated to RBAC in Kubernetes. Let’s move on now to testing and performance considerations for custom controllers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Automated Builds and Testing" data-type="sect2"><div class="sect2" id="crds-perf">&#13;
<h2>Automated Builds and Testing</h2>&#13;
&#13;
<p>As<a data-primary="deployment (controllers and operators)" data-secondary="automated builds and testing" data-type="indexterm" id="idm46336853472776"/><a data-primary="testing" data-type="indexterm" id="idm46336853471832"/><a data-primary="continuous integration (CI)" data-type="indexterm" id="idm46336853471160"/><a data-primary="automated builds" data-type="indexterm" id="idm46336853470520"/> a best practice in cloud-native land, consider an automated build of your custom controller. This is usually called <em>continuous build</em> or <em>continuous integration</em> (CI) and comprises unit tests, integration tests, building the container image, and potentially even sanity or <a href="http://bit.ly/1Z9jXp5">smoke</a> tests. The Cloud Native Computing Foundation (CNCF) maintains an interactive <a href="http://bit.ly/2J2vy4L">listing</a> of the many open source CI tools available.</p>&#13;
&#13;
<p>When building your controller, keep in mind that it should consume as few compute resources as possible, while at the same time serving as many clients as possible. Each CR, based on the CRD(s) you define, is a proxy for a client. But how do you know how much it consumes, if and where it leaks memory, and how well it scales?</p>&#13;
&#13;
<p>You can and indeed should carry out a number of tests, once the development of your custom controller stabilizes. These can include the following, but may not be limited to them:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Performance-related tests, as found in <a href="http://bit.ly/2X556g8">Kubernetes itself</a> as well as the <a href="http://bit.ly/2Fuy4zU">kboom</a> tool, can provide you with data around scaling and resource footprints.</p>&#13;
</li>&#13;
<li>&#13;
<p>Soak tests—for example, the ones used <a href="http://bit.ly/2KBZmZc">in Kubernetes</a>—aim at long-term usage, from several hours to days, with the goal of unveiling any leaking of resources, like files or main memory.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As a best practice, these tests should be part of your CI pipeline. In other words, automate the building of the custom controller, testing, and packaging from day one. For a concrete example setup we encourage you to check out Marko Mudrinić’s excellent post <a href="http://bit.ly/2FwN1RU">“Spawning Kubernetes Clusters in CI for Integration and E2E tests”</a>.</p>&#13;
&#13;
<p>Next, we’ll look at best practices that provide the basis for effective troubleshooting: built-in support for observability.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Custom Controllers and Observability" data-type="sect2"><div class="sect2" id="o11y">&#13;
<h2>Custom Controllers and Observability</h2>&#13;
&#13;
<p>In<a data-primary="deployment (controllers and operators)" data-secondary="custom controller observability" data-type="indexterm" id="idm46336853457800"/><a data-primary="monitoring and logging" data-type="indexterm" id="idm46336853456760"/> this section we look at <em>observability</em> aspects of your custom controllers, specifically logging and monitoring.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logging" data-type="sect3"><div class="sect3" id="idm46336853455448">&#13;
<h3>Logging</h3>&#13;
&#13;
<p>Make<a data-primary="logging" data-type="indexterm" id="idm46336853576216"/> sure you provide enough logging information to aid <a href="http://bit.ly/2WXD85D">troubleshooting</a> (in production). As usual in a containerized setup, log information<a data-primary="kubectl logs" data-type="indexterm" id="idm46336853574696"/> is sent to <code>stdout</code>, where it can be consumed either on a per-pod basis with the <code>kubectl logs</code> command or in an aggregated form. Aggregates can be provided using cloud-provider-specific solutions, such as Stackdriver in Google Cloud or CloudWatch in AWS, or bespoke solutions like the Elasticsearch-Logstash-Kibana/Elasticsearch-Fluentd-Kibana stack. See also <a href="http://bit.ly/2FTgJzk"><em>Kubernetes Cookbook</em></a> by Sébastien Goasguen and Michael Hausenblas (O’Reilly) for recipes on this topic.</p>&#13;
&#13;
<p>Let’s look at an example excerpt of our <code>cnat</code> custom controller log:</p>&#13;
&#13;
<pre class="small" data-code-language="bash" data-type="programlisting"><code class="o">{</code> <code class="s2">"level"</code>:<code class="s2">"info"</code>,&#13;
  <code class="s2">"ts"</code>:1555063927.492718,&#13;
  <code class="s2">"logger"</code>:<code class="s2">"controller"</code>,&#13;
  <code class="s2">"msg"</code>:<code class="s2">"=== Reconciling At"</code> <code class="o">}</code>&#13;
<code class="o">{</code> <code class="s2">"level"</code>:<code class="s2">"info"</code>,&#13;
  <code class="s2">"ts"</code>:1555063927.49283,&#13;
  <code class="s2">"logger"</code>:<code class="s2">"controller"</code>,&#13;
  <code class="s2">"msg"</code>:<code class="s2">"Phase: PENDING"</code> <code class="o">}</code>&#13;
<code class="o">{</code> <code class="s2">"level"</code>:<code class="s2">"info"</code>,&#13;
  <code class="s2">"ts"</code>:1555063927.492857,&#13;
  <code class="s2">"logger"</code>:<code class="s2">"controller"</code>,&#13;
  <code class="s2">"msg"</code>:<code class="s2">"Checking schedule"</code> <code class="o">}</code>&#13;
<code class="o">{</code> <code class="s2">"level"</code>:<code class="s2">"info"</code>,&#13;
  <code class="s2">"ts"</code>:1555063927.492915,&#13;
  <code class="s2">"logger"</code>:<code class="s2">"controller"</code>,&#13;
  <code class="s2">"msg"</code>:<code class="s2">"Schedule parsing done"</code> <code class="o">}</code></pre>&#13;
&#13;
<p>The <em>how</em> of logging: in general, we prefer <a href="http://bit.ly/31TPRu3">structured logging</a> and adjustable log levels, at least <code>debug</code> and <code>info</code>. There are two methods widely used across the Kubernetes code base, and unless you have good reasons not to, you should consider using those:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The <code>logger</code> interface—for example, as found in <a href="http://bit.ly/2WWV54w"><em>httplog.go</em></a>, along with a concrete type (<code>respLogger</code>)—captures things like the status and errors.</p>&#13;
</li>&#13;
<li>&#13;
<p><a href="http://bit.ly/31OJxUu"><code>klog</code></a>, a fork<a data-primary="klog" data-type="indexterm" id="idm46336853432488"/> of Google’s <code>glog</code>, is a structured logger used throughout Kubernetes, and while it has its idiosyncrasies, it’s worth knowing.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The <em>what</em> of logging: make sure to have detailed log information for the normal case of your business logic operation. For example, from our Operator SDK implementation of the <code>cnat</code> controller, in <a href="http://bit.ly/2Fpo5Mi"><em>at_controller.go</em></a>, set up the logger like so:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">reqLogger</code> <code class="o">:=</code> <code class="nx">log</code><code class="p">.</code><code class="nx">WithValues</code><code class="p">(</code><code class="s">"namespace"</code><code class="p">,</code> <code class="nx">request</code><code class="p">.</code><code class="nx">Namespace</code><code class="p">,</code> <code class="s">"at"</code><code class="p">,</code> <code class="nx">request</code><code class="p">.</code><code class="nx">Name</code><code class="p">)</code></pre>&#13;
&#13;
<p>And then in the business logic, in the <code>Reconcile(request reconcile.Request)</code> function:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="k">case</code> <code class="nx">cnatv1alpha1</code><code class="p">.</code><code class="nx">PhasePending</code><code class="p">:</code>&#13;
  <code class="nx">reqLogger</code><code class="p">.</code><code class="nx">Info</code><code class="p">(</code><code class="s">"Phase: PENDING"</code><code class="p">)</code>&#13;
  <code class="c1">// As long as we haven't executed the command yet, we need to check if it's</code>&#13;
  <code class="c1">// already time to act:</code>&#13;
  <code class="nx">reqLogger</code><code class="p">.</code><code class="nx">Info</code><code class="p">(</code><code class="s">"Checking schedule"</code><code class="p">,</code> <code class="s">"Target"</code><code class="p">,</code> <code class="nx">instance</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Schedule</code><code class="p">)</code>&#13;
  <code class="c1">// Check if it's already time to execute the command with a tolerance of</code>&#13;
  <code class="c1">// 2 seconds:</code>&#13;
  <code class="nx">d</code><code class="p">,</code> <code class="nx">err</code> <code class="o">:=</code> <code class="nx">timeUntilSchedule</code><code class="p">(</code><code class="nx">instance</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Schedule</code><code class="p">)</code>&#13;
  <code class="k">if</code> <code class="nx">err</code> <code class="o">!=</code> <code class="kc">nil</code> <code class="p">{</code>&#13;
    <code class="nx">reqLogger</code><code class="p">.</code><code class="nx">Error</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="s">"Schedule parsing failure"</code><code class="p">)</code>&#13;
    <code class="c1">// Error reading the schedule. Wait until it is fixed.</code>&#13;
    <code class="k">return</code> <code class="nx">reconcile</code><code class="p">.</code><code class="nx">Result</code><code class="p">{},</code> <code class="nx">err</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">reqLogger</code><code class="p">.</code><code class="nx">Info</code><code class="p">(</code><code class="s">"Schedule parsing done"</code><code class="p">,</code> <code class="s">"Result"</code><code class="p">,</code> <code class="s">"diff"</code><code class="p">,</code> <code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"%v"</code><code class="p">,</code> <code class="nx">d</code><code class="p">))</code>&#13;
  <code class="k">if</code> <code class="nx">d</code> <code class="p">&gt;</code> <code class="mi">0</code> <code class="p">{</code>&#13;
    <code class="c1">// Not yet time to execute the command, wait until the scheduled time</code>&#13;
    <code class="k">return</code> <code class="nx">reconcile</code><code class="p">.</code><code class="nx">Result</code><code class="p">{</code><code class="nx">RequeueAfter</code><code class="p">:</code> <code class="nx">d</code><code class="p">},</code> <code class="kc">nil</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">reqLogger</code><code class="p">.</code><code class="nx">Info</code><code class="p">(</code><code class="s">"It's time!"</code><code class="p">,</code> <code class="s">"Ready to execute"</code><code class="p">,</code> <code class="nx">instance</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Command</code><code class="p">)</code>&#13;
  <code class="nx">instance</code><code class="p">.</code><code class="nx">Status</code><code class="p">.</code><code class="nx">Phase</code> <code class="p">=</code> <code class="nx">cnatv1alpha1</code><code class="p">.</code><code class="nx">PhaseRunning</code></pre>&#13;
&#13;
<p>This Go snippet gives you a good idea of what to log, and especially when to use <code>reqLogger.Info</code> and <code>reqLogger.Error</code>.</p>&#13;
&#13;
<p>With Logging 101 out of the way, let’s move on to a related topic: metrics!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Monitoring, instrumentation, and auditing" data-type="sect3"><div class="sect3" id="idm46336853454824">&#13;
<h3>Monitoring, instrumentation, and auditing</h3>&#13;
&#13;
<p>A<a data-primary="Prometheus" data-type="indexterm" id="idm46336853205352"/> great open source, container-ready monitoring solution you can use across environments (on-premises and in the cloud) is <a href="https://prometheus.io">Prometheus</a>. Alerting on each event is not practical, so you might want to think about who needs to be informed about what kind of event. For example, you could have a policy that node-related or namespace-related events are handled by infrastructure admins, and namespace admins or developers are paged for pod-level events. In this context, in order to visualize the metrics you’ve gathered, the most popular solution is certainly <a href="https://grafana.com">Grafana</a>; see <a data-type="xref" href="#grafana_prometheus">Figure 7-2</a> for an example of Prometheus metrics visualized in Grafana, taken from the <a href="http://bit.ly/2Oi4YcA">Prometheus documentation</a>.</p>&#13;
&#13;
<p>If you are using a service mesh—for example, based on the <a href="https://envoy.com">Envoy proxy</a> (like Istio or App Mesh), or Linkerd—then instrumentation typically comes for free or is achievable with minimal (configuration) effort. Otherwise, you will have to use the respective libraries, such as those provided by <a href="http://bit.ly/2xb2qmv">Prometheus</a>, to expose the relevant metrics in your code yourself. In this context, you might also want to check out the fledgling Service Mesh Interface (<a href="https://smi-spec.io">SMI</a>) project, introduced in early 2019, which aims to <span class="keep-together">provide</span> a standardized interface for service meshes, based on CRs and controllers.</p>&#13;
&#13;
<figure><div class="figure" id="grafana_prometheus">&#13;
<img alt="Prometheus metrics visualized in Grafana" src="assets/prku_0702.png"/>&#13;
<h6><span class="label">Figure 7-2. </span>Prometheus metrics visualized in Grafana</h6>&#13;
</div></figure>&#13;
&#13;
<p>Another<a data-primary="auditing" data-type="indexterm" id="idm46336853194952"/> useful feature Kubernetes offers via the API server is <a href="http://bit.ly/2O4WBkL">auditing</a>, which allows you to record a sequence of activities affecting the cluster. Different strategies are available in the auditing policy, from no logging to logging event metadata, request bodies, and response bodies. You can choose between a simple log backend and using a webhook for integrating with third-party systems.<a data-primary="" data-startref="CAOprod07" data-type="indexterm" id="idm46336853193096"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46336853191992">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter focused on how to make your operators production-ready by discussing operational aspects of controllers and operators, including packaging, security, and performance.</p>&#13;
&#13;
<p>With this we’ve covered the basics of writing and using custom Kubernetes controllers and operators, so now we move on to another way to extend Kubernetes: developing a custom API server.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46336853931352"><sup><a href="ch07.html#idm46336853931352-marker">1</a></sup> See also Luc Juggery’s post <a href="http://bit.ly/2X0fjKK">“Kubernetes Tips: Using a ServiceAccount”</a> for a detailed discussion of service account usage.</p><p data-type="footnote" id="idm46336853898344"><sup><a href="ch07.html#idm46336853898344-marker">2</a></sup> We did, however, raise <a href="http://bit.ly/2J7Qys4">Issue 748</a> against the Kubebuilder project.</p></div></div></section></body></html>