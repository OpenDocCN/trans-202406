["```\n// ensure that we're not trying to create objects in terminating Namespaces if a.GetOperation() == admission.Create {\n  if namespace.Status.Phase != v1.NamespaceTerminating {\n    return nil ![1](assets/1.png)\n  }\n\n  err := admission.NewForbidden(a, fmt.Errorf(\"unable to create new content in\n  namespace %s because it is being terminated\", a.GetNamespace()))\n  if apierr, ok := err.(*errors.StatusError); ok {\n    apierr.ErrStatus.Details.Causes = append(apierr.ErrStatus.Details.Causes,\n    metav1.StatusCause{\n      Type:    v1.NamespaceTerminatingCause,\n      Message: fmt.Sprintf(\"namespace %s is being terminated\", a.GetNamespace()),\n      Field:   \"metadata.namespace\",\n    })\n  }\n  return err ![2](assets/2.png)\n}\n```", "```\napiVersion: admissionregistration.k8s.io/v1\nkind: MutatingWebhookConfiguration\nmetadata:\n  name: \"test-mutating-hook\"\nwebhooks:\n- name: \"test-mutating-hook\"\n  rules: ![1](assets/1.png)\n  - apiGroups:   [\"\"]\n    apiVersions: [\"v1\"]\n    operations:  [\"CREATE\"] ![2](assets/2.png)\n    resources:   [\"pods\"] ![3](assets/3.png)\n    scope:       \"Namespaced\" ![4](assets/4.png)\n  clientConfig: ![5](assets/5.png)\n    service:\n      namespace: test-ns\n      name: test-service\n      path: /test-path\n      port: 8443\n    caBundle: \"Ci0tLS0tQk...tLS0K\" ![6](assets/6.png)\n  admissionReviewVersions: [\"v1\", \"v1beta1\"] ![7](assets/7.png)\n  sideEffects: \"None\" ![8](assets/8.png)\n  timeoutSeconds: \"5\" ![9](assets/9.png)\n  reinvocationPolicy: \"IfNeeded\" ![10](assets/10.png)\n  failurePolicy: \"Fail\" ![11](assets/11.png)\n```", "```\n# <...snip...>\nrules: ![1](assets/1.png)\n- apiGroups:   [\"\"]\n  apiVersions: [\"v1\"]\n  operations:  [\"CREATE\"] ![2](assets/2.png)\n  resources:   [\"secrets\"] ![3](assets/3.png)\n  scope:       \"Namespaced\" ![4](assets/4.png)\n# <...snip...>\n```", "```\n# <...snip...>\nnamespaceSelector:\n  matchExpressions:\n  - key: webhook\n    operator: In\n    values: [\"enabled\"]\n# <...snip...>\n```", "```\n// <...snip...> type patchOperation struct { ![1](assets/1.png)\n  Op    string      `json:\"op\"`\n  Path  string      `json:\"path\"`\n  Value interface{} `json:\"value,omitempty\"`\n}\n\nvolume := corev1.Volume{ ![2](assets/2.png)\n  Name: m.volName,\n  VolumeSource: corev1.VolumeSource{\n    Projected: &corev1.ProjectedVolumeSource{\n      Sources: []corev1.VolumeProjection{\n        {\n          ServiceAccountToken: &corev1.ServiceAccountTokenProjection{\n            Audience:          audience,\n            ExpirationSeconds: &m.Expiration,\n            Path:              m.tokenName,\n          },\n        },\n      },\n    },\n  },\n}\n\npatch := []patchOperation{ ![3](assets/3.png)\n  {\n    Op:    \"add\",\n    Path:  \"/spec/volumes/0\",\n    Value: volume,\n  },\n}\n\nif pod.Spec.Volumes == nil { ![4](assets/4.png)\n  patch = []patchOperation{\n    {\n      Op:   \"add\",\n      Path: \"/spec/volumes\",\n      Value: []corev1.Volume{\n        volume,\n      },\n    },\n  }\n}\n\npatchBytes, err := json.Marshal(patch) ![5](assets/5.png)\n// <...snip...>\n```", "```\nreturn &v1beta1.AdmissionResponse{\n  Allowed: true,\n  Patch:   patchBytes,\n  PatchType: func() *v1beta1.PatchType {\n    pt := v1beta1.PatchTypeJSONPatch\n    return &pt\n  }(),\n}\n```", "```\nfunc (w *Webhook) Handle(\n  ctx context.Context,\n  req admission.Request) admission.Response\n```", "```\nvm := &v1alpha3.VSphereMachine{} ![1](assets/1.png)\nerr := w.decoder.DecodeRaw(req.Object, vm) ![2](assets/2.png)\nif err != nil {\n  return admission.Errored(http.StatusBadRequest, err) ![3](assets/3.png)\n}\n```", "```\nif _, ok := vm.Annotations[\"infoblox\"]; !ok {\n  return admission.Allowed(\"Nothing to do\")\n}\n```", "```\nvm.Spec.VirtualMachineCloneSpec.Network.Devices[0].IPAddrs[0] = ipFromInfoblox ![1](assets/1.png)\nmarshaledVM, err := json.Marshal(vm) ![2](assets/2.png)\nif err != nil { ![3](assets/3.png)\n  return admission.Errored(http.StatusInternalServerError, err)\n}\nreturn admission.PatchResponseFromRaw(req.Object.Raw, marshaledVM) ![4](assets/4.png)\n```", "```\napiVersion: config.gatekeeper.sh/v1alpha1\nkind: Config\nmetadata:\n  name: config\n  namespace: \"gatekeeper-system\"\nspec:\n  sync: ![1](assets/1.png)\n    syncOnly:\n      - group: \"extensions\"\n        version: \"v1beta1\"\n        kind: \"Ingress\"\n      - group: \"networking.k8s.io\"\n        version: \"v1beta1\"\n        kind: \"Ingress\"\n      - group: \"\"\n        version: \"v1\"\n        kind: \"Namespace\"\n```", "```\napiVersion: templates.gatekeeper.sh/v1beta1\nkind: ConstraintTemplate\nmetadata:\n  name: limitnamespaceingress\nspec:\n  crd:\n    spec:\n      names:\n        kind: LimitNamespaceIngress\n        listKind: LimitNamespaceIngressList\n        plural: limitnamespaceingresss\n        singular: limitnamespaceingress\n      validation:\n        # Schema for the `parameters` field in the constraint\n        openAPIV3Schema:\n          properties: ![1](assets/1.png)\n            annotation:\n              type: string\n  targets: ![2](assets/2.png)\n    - target: admission.k8s.gatekeeper.sh\n      rego: |\n        package limitnamespaceingress\n\n        violation[{\"msg\": msg}] {\n          cluster := data.inventory.cluster.v1\n          namespace := cluster.Namespace[input.review.object.metadata.namespace]\n          regex := namespace.metadata.annotations[input.parameters.annotation]\n          hosts := input.review.object.spec.rules[_].host\n          not re_match(regex, hosts)\n          msg := sprintf(\"Only ingresses matching %v in namespace %v allowed\",\n             [regex ,input.review.object.metadata.namespace])\n        }\n```", "```\napiVersion: constraints.gatekeeper.sh/v1beta1\nkind: LimitNamespaceIngress\nmetadata:\n  name: limit-namespace-ingress\nspec:\n  match:\n    kinds:\n      - apiGroups: [\"extensions\", \"networking.k8s.io\"]\n        kinds: [\"Ingress\"]\n  parameters:\n    annotation: allowed-ingress-pattern\n```", "```\napiVersion: v1\nkind: Namespace\nmetadata:\n  annotations:\n    # Note regex special character escaping\n    allowed-ingress-pattern: \\w\\.my-namespace\\.com\n  name: ingress-test\n```", "```\n# FAILS because the host doesn't match the pattern above\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-1\n  namespace: ingress-test\nspec:\n  rules:\n  - host: foo.other-namespace.com\n    http:\n      paths:\n      - backend:\n          serviceName: service1\n          servicePort: 80\n---\n# SUCCEEDS as the pattern matches\napiVersion: networking.k8s.io/v1beta1\nkind: Ingress\nmetadata:\n  name: test-2\n  namespace: ingress-test\nspec:\n  rules:\n  - host: foo.my-namespace.com\n    http:\n      paths:\n      - backend:\n          serviceName: service2\n          servicePort: 80\n```", "```\nError from server ([denied by limit-namespace-ingress] Only ingresses with\nhost matching \\w\\.my-namespace\\.com are allowed in namespace ingress-test):\nerror when creating \"ingress.yaml\": admission webhook \"validation.gatekeeper.sh\"\ndenied the request: [denied by limit-namespace-ingress] Only ingresses with host\nmatching \\w\\.my-namespace\\.com are allowed in namespace ingress-test\n```"]