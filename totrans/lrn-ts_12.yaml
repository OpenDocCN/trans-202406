- en: Chapter 10\. Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables you
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: declare in the type system?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A whole new (typed) world!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: All the type syntaxes you’ve learned about so far are meant to be used with
    types that are completely known when they’re being written. Sometimes, however,
    a piece of code may be intended to work with various different types depending
    on how it’s called.
  prefs: []
  type: TYPE_NORMAL
- en: Take this `identity` function in JavaScript meant to receive an input of any
    possible type and return that same input as output. How would you describe its
    parameter type and return type?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We could declare `input` as `any`, but then the return type of the function
    would also be `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Given that `input` is allowed to be any input, we need a way to say that there
    is a relationship between the `input` type and the type the function returns.
    TypeScript captures relationships between types using *generics*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, constructs such as functions may declare any number of generic
    *type parameters*: types that are determined for each usage of the generic construct.
    These type parameters are used as types in the construct to represent some type
    that can be different in each instance of the construct. Type parameters may be
    provided with different types, referred to as *type arguments*, for each instance
    of the construct but will remain consistent within that instance.'
  prefs: []
  type: TYPE_NORMAL
- en: Type parameters typically have single-letter names like `T` and `U` or PascalCase
    names like `Key` and `Value`. In all of the constructs covered in this chapter,
    generics may be declared using `<` and `>` brackets, like `someFunction<T>` or
    `SomeInterface<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A function may be made generic by placing an alias for a type parameter, wrapped
    in angle brackets, immediately before the parameters parentheses. That type parameter
    will then be available for usage in parameter type annotations, return type annotations,
    and type annotations inside the function’s body.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following version of `identity` declares a type parameter `T` for its `input`
    parameter, which allows TypeScript to infer that the return type of the function
    is `T`. TypeScript can then infer a different type for `T` every time `identity`
    is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Arrow functions can be generic too. Their generic declarations are also placed
    immediately before the `(` before their list of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following arrow function is functionally the same as the previous declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The syntax for generic arrow functions has some restrictions in *.tsx* files,
    as it conflicts with JSX syntax. See [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options)
    for workarounds as well as configuring JSX and React support.
  prefs: []
  type: TYPE_NORMAL
- en: Adding type parameters to functions in this way allows them to be reused with
    different inputs while still maintaining type safety and avoiding `any` types.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Generic Call Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the time when calling generic functions, TypeScript will be able to
    infer type arguments based on how the function is being called. For example, in
    the previous examples’ `identity` functions, TypeScript’s type checker used an
    argument provided to `identity` to infer the corresponding function parameter’s
    type argument.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, as with class members and variable types, sometimes there isn’t
    enough information from a function’s call to inform TypeScript what its type argument
    should resolve to. This will commonly happen if a generic construct is provided
    another generic construct whose type arguments aren’t known.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript will default to assuming the `unknown` type for any type argument
    it cannot infer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following `logWrapper` function takes in a callback with a
    parameter type set to `logWrapper`’s type parameter `Input`. TypeScript can infer
    the type argument if `logWrapper` is called with a callback that explicitly declares
    its parameter type. If the parameter type is implicit, however, TypeScript has
    no way of knowing what `Input` should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To avoid defaulting to `unknown`, functions may be called with an explicit generic
    type argument that explicitly tells TypeScript what that type argument should
    be instead. TypeScript will perform type checking on the generic call to make
    sure the parameter being requested matches up to what’s provided as a type argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `logWrapper` seen previously is provided with an explicit `string`
    for its `Input` generic. TypeScript can then infer that the callback’s `input`
    parameter of generic type `Input` resolves to type `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Much like explicit type annotations on variables, explicit type arguments may
    always be specified on a generic function but often aren’t necessary. Many TypeScript
    developers generally only specify them when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `logWrapper` usage explicitly specifies `string` both as a type
    argument and as a function parameter type. Either could be removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Name<Type>` syntax for specifying a type argument will be the same for
    other generic constructs throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Function Type Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functions may define any number of type parameters, separated by commas. Each
    call of the generic function may resolve its own set of values for each of the
    type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, `makeTuple` declares two type parameters and returns a value
    typed as a read-only tuple with one, then the other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that if a function declares multiple type parameters, calls to that function
    must explicitly declare either none of the generic types or all of them. TypeScript
    does not yet support inferring only some of the types of a generic call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `makePair` also takes in two type parameters, so either neither of them
    or both of them must be explicitly specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Try not to use more than one or two type parameters in any generic construct.
    As with runtime function parameters, the more you use, the harder it is to read
    and understand the code.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Interfaces may be declared as generic as well. They follow similar generic
    rules to functions: they may have any number of type parameters declared between
    a `<` and `>` after their name. That generic type may later be used elsewhere
    in their declaration, such as on member types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `Box` declaration has a `T` type parameter for a property. Creating
    an object declared to be a `Box` with a type argument enforces that the `inside:
    T` property matches that type argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Fun fact: the built-in `Array` methods are defined in TypeScript as a generic
    interface! `Array` uses a type parameter `T` to represent the type of data stored
    within an array. Its `pop` and `push` methods look roughly like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Inferred Generic Interface Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with generic functions, generic interface type arguments may be inferred
    from usage. TypeScript will do its best to infer type arguments from the types
    of values provided to a location declared as taking in a generic type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `getLast` function declares a type parameter `Value` that is then used
    for its `node` parameter. TypeScript can then infer `Value` based on the type
    of whatever value is passed in as an argument. It can even report a type error
    when an inferred type argument doesn’t match the type of a value. Providing `getLast`
    with an object that doesn’t include `next`, or whose inferred `Value` type argument
    is the same type, is allowed. Mismatching the provided object’s `value` and `next.value`,
    though, is a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that if an interface declares type parameters, any type annotations referring
    to that interface must provide corresponding type arguments. Here, the usage of
    `CrateLike` is incorrect for not including a type argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Later in this chapter, I’ll show how to provide default values for type parameters
    to get around this requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Classes, like interfaces, can also declare any number of type parameters to
    be later used on members. Each instance of the class may have a different set
    of type arguments for its type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Secret` class declares `Key` and `Value` type parameters, then uses them
    for member properties, constructor parameter types, and a method’s parameter and
    return types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As with generic interfaces, type annotations using a class must indicate to
    TypeScript what any generic types on that class are. Later in this chapter, I’ll
    show how to provide default values for type parameters to get around this requirement
    for classes too.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Generic Class Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instantiating generic classes goes by the same type arguments inference rules
    as calling generic functions. If the type argument can be inferred from the type
    of a parameter to the class constructor, such as the `new Secret(12345, "luggage")`
    earlier, TypeScript will use the inferred type. Otherwise, if a class type argument
    can’t be inferred from the arguments passed to its constructor, the type argument
    will default to `unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `CurriedCallback` class declares a constructor that takes in a generic
    function. If the generic function has a known type—such as from an explicit type
    argument type annotation—then the class instance’s `Input` type argument can be
    informed by it. Otherwise, the class instance’s `Input` type argument will default
    to `unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Class instances may also avoid defaulting to `unknown` by providing explicit
    type argument(s) the same way other generic function calls do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `CurriedCallback` from before is now being provided with an explicit
    `string` for its `Input` type argument, so TypeScript can infer that the callback’s
    `Input` type parameter resolves to `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Extending Generic Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generic classes can be used as the base class following an `extends` keyword.
    TypeScript will not attempt to infer type arguments for the base class from usage.
    Any type arguments without defaults will need to be specified using an explicit
    type annotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `SpokenQuote` class provides `string` as the `T` type argument
    for its base class `Quote<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic derived classes can alternately pass their own type argument through
    to their base class. The type names don’t have to match; just for fun, this `AttributedQuote`
    passes a differently named `Value` type argument to the base class `Quote<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Implementing Generic Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Generic classes may also implement generic interfaces by providing them any
    necessary type parameters. This works similarly to extending a generic base class:
    any type parameters on the base interface must be declared by the class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `MoviePart` class specifies the `ActingCredit` interface’s `Role`
    type argument as `string`. The `IncorrectExtension` class causes a type complaint
    because its `role` is type `boolean` despite it providing `string[]` as a type
    argument to `ActingCredit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Method Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Class methods may declare their own generic types separate from their class
    instance. Each call to a generic class method may have a different type argument
    for each of its type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'This generic `CreatePairFactory` class declares a `Key` type and includes a
    `createPair` method that also declares a separate `Value` generic type. The return
    type for `createPair` is then inferred to be `{ key: Key, value: Value }`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Static Class Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static members of a class are separate from instance members and aren’t associated
    with any particular instance of the class. They don’t have access to any class
    instances or type information specific to any class instances. As a result, while
    static class methods can declare their own type parameters, they can’t access
    any type parameters declared on a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a `BothLogger` class declares an `OnInstance` type parameter for its
    `instanceLog` method and a separate `OnStatic` type parameter for its static `staticLog`
    method. The static method is not able to access the instance `OnInstance` because
    `OnInstance` is declared for class instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Generic Type Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One last construct in TypeScript that can be made generic with type arguments
    is type aliases. Each type alias may be given any number of type parameters, such
    as this `Nullish` type receiving a `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Generic type aliases are commonly used with functions to describe the type
    of a generic function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Generic Discriminated Unions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I mentioned back in [Chapter 4, “Objects”](ch04.xhtml#objects) that discriminated
    unions are my favorite feature in all of TypeScript because they beautifully combine
    a common elegant JavaScript pattern with TypeScript’s type narrowing. My favorite
    use for discriminated unions is to add a type argument to create a generic “result”
    type that represents either a successful result with data or a failure with an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Result` generic type features a `succeeded` discriminant that must be
    used to narrow a result to whether it’s a success or failure. This means any operation
    that returns a `Result` can indicate an error or data result, and be assured that
    consumers will need to check whether the result succeeded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Put together, generic types and discriminated types provide a wonderful way
    to model reusable types like `Result`.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript includes syntax that allows you to modify the behavior of generic
    type parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have stated so far that if a generic type is used in a type annotation or
    as the base of a class `extends` or `implements`, it must provide a type argument
    for each type parameter. You can get around explicitly providing type arguments
    by placing an `=` sign followed by a default type after the type parameter’s declaration.
    The default will be used in any subsequent type where the type argument isn’t
    explicitly declared and can’t be inferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `Quote` interface takes in a `T` type parameter that defaults to
    `string` if not provided. The `explicit` variable explicitly sets `T` to `number`
    while `implicit` and `mismatch` both resolve to `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Type parameters can default to earlier type parameters in the same declaration
    too. Since each type parameter introduces a new type for the declaration, they
    are available as defaults for later type parameters in that declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `KeyValuePair` type can have different types for its `Key` and `Value`
    generics but defaults to keeping them the same—though because `Key` doesn’t have
    a default, it does still need to be inferrable or provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Keep in mind that all default type parameters must come last in their declaration
    list, similar to default function parameters. Generic types without a default
    may not follow generic types with a default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `inTheEnd` is allowed because all generic types without defaults come
    before generic types with defaults. `inTheMiddle` is a problem because a generic
    type without a default follows types with defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Constrained Generic Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generic types by default can be given any type in the world: classes, interfaces,
    primitives, unions, you name it. However, some functions are only meant to work
    with a limited set of types.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript allows for a type parameter to declare itself as needing to *extend*
    a type: meaning it’s only allowed to alias types that are assignable to that type.
    The syntax to constrain a type parameter is to place the `extends` keyword after
    the type parameter’s name, followed by a type to constrain it to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, by creating a `WithLength` interface to describe anything that
    has a `length: number`, we can then allow our generic function to take in any
    type that has a `length` for its `T` generic. Strings, arrays, and now even objects
    that just so happen to have a `length: number` are allowed, while type shapes
    such as `Date` missing that numeric `length` result in a type error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: I’ll cover more type operations you can perform with generics in [Chapter 15,
    “Type Operations”](ch15.xhtml#type_operations).
  prefs: []
  type: TYPE_NORMAL
- en: keyof and Constrained Type Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `keyof` operator introduced in [Chapter 9, “Type Modifiers”](ch09.xhtml#type_modifiers_chapter)
    also works well with constrained type parameters. Using `extends` and `keyof`
    together allows a type parameter to be constrained to the keys of a previous type
    parameter. It is also the only way to specify the key of a generic type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take this simplified version of the `get` method from the popular library Lodash.
    It takes in a container value, typed as `T`, and a `key` name of one of the keys
    of `T` to retrieve from `container`. Because the `Key` type parameter is constrained
    to be a `keyof T`, TypeScript knows this function is allowed to return `T[Key]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Without `keyof`, there would have been no way to correctly type the generic
    `key` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the importance of the `Key` type parameter in the previous example. If
    only `T` is provided as a type parameter, and the `key` parameter is allowed to
    be any `keyof T`, then the return type will be the union type of all property
    values in `Container`. This less-specific function declaration doesn’t indicate
    to TypeScript that each call can have a specific `key` via a type argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Be sure when writing generic functions to know when a parameter’s type depends
    on a previous parameter’s type. You’ll often need to use constrained type parameters
    for correct parameter types in those cases.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you’ve seen how generics work, it’s finally time to talk about a core
    feature of modern JavaScript that relies on their concepts: Promises! To recap,
    a Promise in JavaScript represents something that might still be pending, such
    as a network request. Each Promise provides methods to register callbacks in case
    the pending action “resolves” (completes successfully) or “rejects” (throws an
    error).'
  prefs: []
  type: TYPE_NORMAL
- en: A Promise’s ability to represent similar actions on any arbitrary value types
    is a natural fit for TypeScript’s generics. Promises are represented in the TypeScript
    type system as a `Promise` class with a single type parameter representing the
    eventual resolved value.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Promise` constructor is typed in TypeScript as taking in a single parameter.
    That parameter’s type relies on a type parameter declared on the generic `Promise`
    class. A reduced form would look roughly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating a Promise intended to eventually resolve with a value generally necessitates
    explicitly declaring the type argument of the Promise. TypeScript would default
    to assuming the parameter type is `unknown` without that explicit generic type
    argument. Explicitly providing a type argument to the `Promise` constructor would
    allow TypeScript to understand the resultant Promise instance’s resolved type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: A Promise’s generic `.then` method introduces a new type parameter representing
    the resolved value of the Promise it returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code creates a `textEventually` Promise that resolves
    with a `string` value after a second, as well as a `lengthEventually` that waits
    an additional second to resolve with a `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Async Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any function declared in JavaScript with the `async` keyword returns a `Promise`.
    If a value returned by an `async` function in JavaScript isn’t a Thenable (an
    object with a `.then()` method; in practice almost always a Promise), it will
    be wrapped in a `Promise` as if `Promise.resolve` was called on it. TypeScript
    recognizes this and will infer the return type of an `async` function to always
    be a `Promise` for whatever value is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `lengthAfterSecond` returns a `Promise<number>` directly, while `lengthImmediately`
    is inferred to return a `Promise<number>` because it is `async` and directly returns
    a `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Any manually declared return type on an `async` function therefore must always
    be a `Promise` type, even if the function doesn’t explicitly mention Promises
    in its implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Using Generics Right
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the `Promise<Value>` implementations earlier in this chapter, although
    generics can give us a lot of flexibility in describing types in code, they can
    become rather complex quite quickly. Programmers new to TypeScript often go through
    a phase of overusing generics to the point of making code confusing to read and
    overly complex to work with. TypeScript best practice is generally to use generics
    only when necessary, and to be clear about what they’re used for when they are.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Most code you write in TypeScript should not heavily use generics to the point
    of confusion. However, types for utility libraries, particularly general-use modules,
    may sometimes need to heavily use them. Understanding generics is particularly
    useful to be able to work effectively with those utility types.
  prefs: []
  type: TYPE_NORMAL
- en: The Golden Rule of Generics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One quick test that can help show whether a type parameter is necessary for
    a function is it should be used at least twice. Generics describe relationships
    between types, so if a generic type parameter only appears in one place, it can’t
    possibly be defining a relationship between multiple types.
  prefs: []
  type: TYPE_NORMAL
- en: Each function type parameter should be used for a parameter and then also for
    at least one other parameter and/or the return type of the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this `logInput` function uses its `Input` type parameter exactly
    once, to declare its `input` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the `identify` functions earlier in the chapter, `logInput` doesn’t
    do anything with its type parameter such as returning or declaring more parameters.
    There is therefore not much use to declaring that `Input` type parameter. We can
    rewrite `logInput` without it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '*Effective TypeScript* by Dan Vanderkam (O’Reilly, 2019) contains several excellent
    tips for how to work with generics, including a section titled “The Golden Rule
    of Generics.” I highly recommend reading *Effective TypeScript* and that section
    especially if you’re finding yourself spending a lot of time wrestling with generics
    in your code.'
  prefs: []
  type: TYPE_NORMAL
- en: Generic Naming Conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The standard naming convention for type parameters in many languages, TypeScript
    included, is to default to calling a first type argument “T” (for “type” or “template”)
    and if subsequent type parameters exist, calling them “U,” “V,” and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If some contextual information is known about how the type argument is supposed
    to be used, the convention sometimes extends to using the first letter of the
    term for that usage: for example, state management libraries might refer to a
    generic state as “S.” “K” and “V” often refer to keys and values in data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, naming a type argument with one letter can be just as confusing
    as naming a function or variable with just one character:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'When the intent of a generic isn’t clear from a single-letter `T`, it’s best
    to use descriptive generic type names that indicate what the type is used for:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Whenever a construct has multiple type parameters, or the purpose of a single
    type argument isn’t immediately clear, consider using fully written names for
    readability instead of single-letter abbreviations.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you made classes, functions, interfaces, and type aliases
    “generic” by allowing them to work with type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: Using type parameters to represent types different between uses of a construct
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Providing explicit or implicit type arguments when calling generic functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using generic interfaces to represent generic object types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding type parameters to classes, and how that impacts their types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding type parameters to type aliases, in particular with discriminated type
    unions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying generic type parameters with defaults (`=`) and constraints (`extends`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Promises and `async` functions use generics to represent asynchronous data
    flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices with generics, including their Golden Rule and naming conventions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus concludes the *Features* section of this book. Congratulations: you now
    know all the most important syntax and type-checking features in the TypeScript
    type system for most projects!'
  prefs: []
  type: TYPE_NORMAL
- en: The next section, *Usage*, covers how to configure TypeScript to run on your
    project, interact with external dependencies, and tweak its type checking and
    emitted JavaScript. Those are important features for using TypeScript on your
    own projects.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other miscellaneous type operations available in TypeScript syntax.
    You don’t need to fully understand them to work in most TypeScript projects—but
    they are interesting and useful to know. I’ve thrown them in [Part IV, “Extra
    Credit”](part04.xhtml#extra_credit) after [Part III, “Usage”](part03.xhtml#usage)
    as a fun little treat if you have the time.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/generics*](https://learningtypescript.com/generics).
  prefs: []
  type: TYPE_NORMAL
- en: Why do generics anger developers?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: They’re always typing arguments.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
