<html><head></head><body><section data-pdf-bookmark="Chapter 9. eBPF for Security" data-type="chapter" epub:type="chapter"><div class="chapter" id="ebpf_for_security">&#13;
<h1><span class="label">Chapter 9. </span>eBPF for Security</h1>&#13;
<p><a contenteditable="false" data-primary="security" data-type="indexterm" id="ch09.html0"/>You’ve seen how eBPF can be used to observe events across a system and report information about those events to user space tools. In this chapter you’ll consider how to build on the concept of event detection to create eBPF-based security tools that can detect, or even prevent, malicious activity. I’ll start by helping you understand what makes security different from other types of observability.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Example code for this chapter is in the <a href="http://github.com/lizrice/learning-ebpf">GitHub repo</a> in the <em>chapter9</em> directory.</p>&#13;
</div>&#13;
<section data-pdf-bookmark="Security Observability Requires Policy and Context" data-type="sect1"><div class="sect1" id="security_observability_requires_policy_">&#13;
<h1>Security Observability Requires Policy and Context</h1>&#13;
<p><a contenteditable="false" data-primary="observability tools, security tools versus" data-type="indexterm" id="ch09.html1"/><a contenteditable="false" data-primary="security" data-secondary="observability tools versus security tools" data-type="indexterm" id="ch09.html2"/>The difference between a security tool and an observability tool that reports on events is that a security tool needs to be able to distinguish between events that are expected under normal circumstances and events that suggest malicious activity might be taking place. For example, suppose you have an application that writes data to a local file as part of its normal processing. Let’s say the app is expected to write to <em>/home/&lt;username&gt;/&lt;filename&gt;</em>, so this activity isn’t something you’re interested in from a security perspective. However, you would want to be notified if the app writes to one of the many sensitive file locations in Linux. For example, it is unlikely that it needs to modify the password information stored in <em>/etc/passwd</em>.</p>&#13;
<p><a contenteditable="false" data-primary="policies, security observability and" data-type="indexterm" id="idm46123192052928"/>Policies have to take into account not just normal behavior when systems are fully functional, but also the expected error path behavior. For example, if a physical disk gets full, the application might start sending network messages to alert about this situation. These network messages shouldn’t be seen as security events—even though they are unusual, they’re not suspicious. Taking error paths into account can make it challenging to create effective policies, and we’ll come back to that challenge later in this chapter.</p>&#13;
<p>Defining what is and isn’t expected behavior is the job of a policy. A security tool compares activity to a policy and takes some action when the activity is outside the policy, making it suspicious. That action would typically involve generating a security event log, which would usually get sent to a Security Information Event Management (SIEM) platform. It might also result in an alert to a human who will be called on to investigate what happened.</p>&#13;
<p>The more contextual information that’s available to the investigator, the more likely they will be able to find out the root cause of the event and determine whether it was an attack, which components were affected, how and when the attack took place, and who was responsible. As illustrated in <a data-type="xref" href="#contextual_information_is_required_alon">Figure 9-1</a>, being able to answer questions like this takes a tool from mere logging to deserving the nomenclature “security <span class="keep-together">observability</span>.”</p>&#13;
<figure><div class="figure" id="contextual_information_is_required_alon">&#13;
<img alt="Contextual information is required alongside out-of-policy event detection for security observability" src="assets/lebp_0901.png"/>&#13;
<h6><span class="label">Figure 9-1. </span>Contextual information is required alongside out-of-policy event detection for security observability</h6>&#13;
</div></figure>&#13;
<p>Let’s explore some of the ways eBPF programs are being used to detect and enforce security events. As you know, eBPF programs can be attached to a variety of events, and one set of events that have been commonly used for security for many years are syscalls. We’ll start our discussion with syscalls, but as you’ll see, syscalls might not be the most effective way to implement security tooling with eBPF. We’ll see some newer and more sophisticated approaches later in this chapter.<a contenteditable="false" data-primary="" data-startref="ch09.html2" data-type="indexterm" id="idm46123192046400"/><a contenteditable="false" data-primary="" data-startref="ch09.html1" data-type="indexterm" id="idm46123192045024"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Using System Calls for Security Events" data-type="sect1"><div class="sect1" id="using_system_calls_for_security_events">&#13;
<h1>Using System Calls for Security Events</h1>&#13;
<p><a contenteditable="false" data-primary="security" data-secondary="using syscalls for security events" data-type="indexterm" id="ch09.html3"/><a contenteditable="false" data-primary="system calls" data-secondary="using for security events" data-type="indexterm" id="ch09.html4"/>System calls (or syscalls) are the interface between user space applications and the kernel. If you can restrict the set of syscalls an app can make, that will limit what it is able to do. For example, if you stop an app from making syscalls in the <code>open*()</code> family, it won’t be able to open files. If you have an application that you never expect to open files, you might want to create this limitation so that even if the app gets compromised, it won’t be able to open files maliciously. If you’ve been using Docker or Kubernetes over the past few years, there is a very good chance you have already come across a security tool that uses BPF to limit syscalls: seccomp<em>.</em></p>&#13;
<section data-pdf-bookmark="Seccomp" data-type="sect2"><div class="sect2" id="seccomp">&#13;
<h2>Seccomp</h2>&#13;
<p><a contenteditable="false" data-primary="seccomp" data-secondary="basics" data-type="indexterm" id="idm46123192035360"/><a contenteditable="false" data-primary="security" data-secondary="seccomp" data-type="indexterm" id="idm46123192033760"/><a contenteditable="false" data-primary="system calls" data-secondary="seccomp and" data-type="indexterm" id="idm46123192032384"/>The name <em>seccomp</em> is a contraction of “SECure COMPuting.” In its original, or “strict,” form, seccomp is used to limit the set of syscalls a process can use to a very small subset: <code>read()</code>, <code>write()</code>, <code>_exit()</code>, and <code>sigreturn()</code>. The intention of this strict mode was to allow users to run untrusted code (perhaps a program downloaded from the internet) without any possibility of that code doing malicious things.</p>&#13;
<p>Strict mode is very restrictive, and many applications need to use a much larger set of syscalls—but that doesn’t mean they need all 400 and more of them. It makes sense to allow a more flexible method for restricting the set that any given application can use. This is the reasoning behind the flavor of seccomp that most of us from the container world have encountered, which is more properly known as seccomp-bpf. Instead of having a fixed subset of syscalls that it permits, this mode of seccomp uses BPF code to filter the syscalls that are and aren’t allowed.</p>&#13;
<p>In seccomp-bpf, a set of BPF instructions are loaded that act as a filter. Each time a syscall is called, the filter is triggered. The filter code has access to the arguments that are passed to the syscall so that it can make decisions based on both the syscall itself and the arguments that have been passed to it. The outcome is one of a set of possible actions that include:</p>&#13;
<ul>&#13;
<li><p>Allowing the syscall to go ahead</p></li>&#13;
<li><p>Returning an error code to the user space application</p></li>&#13;
<li><p>Killing the thread</p></li>&#13;
<li><p>Notifying a user space application (seccomp-unotify<em>)</em> (as of kernel version 5.0)</p></li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you want to explore writing your own BPF filter code, Michael Kerrisk has some good examples at <a href="https://oreil.ly/cJ6HL"><em class="hyperlink">https://oreil.ly/cJ6HL</em></a>.</p>&#13;
</div>&#13;
<p>Some of the arguments passed to syscalls are pointers, and the BPF code in seccomp-bpf is not able to dereference these pointers. This limits the flexibility of a seccomp profile, as it can only use value arguments in its decision-making process. Also, it has to be applied to the process when it starts—you can’t modify the profile that is being applied to a given application process.</p>&#13;
<p>You may well have used seccomp-bpf without writing BPF code, as the code is often derived from a human-readable seccomp profile. <a href="https://oreil.ly/IT_Bf">Docker’s default profile</a> is a good example. This is a general-purpose profile intended to be usable with pretty much any normal, containerized application. That inevitably means it allows most syscalls and disallows only a few that are unlikely to be appropriate in any application, <code>reboot()</code> being a great example.</p>&#13;
<p><a href="https://oreil.ly/1xWmn">According to Aqua Security</a>, most containerized apps use somewhere in the range of 40 to 70 syscalls. For better security, it would be preferable to use a more constrained profile that is targeted at each specific application and only allows the syscalls it actually uses.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Generating Seccomp Profiles" data-type="sect2"><div class="sect2" id="generating_seccomp_profiles">&#13;
<h2>Generating Seccomp Profiles</h2>&#13;
<p><a contenteditable="false" data-primary="seccomp" data-secondary="generating seccomp profiles" data-type="indexterm" id="ch09.html5"/><a contenteditable="false" data-primary="security" data-secondary="generating seccomp profiles" data-type="indexterm" id="ch09.html6"/><a contenteditable="false" data-primary="system calls" data-secondary="generating seccomp profiles" data-type="indexterm" id="ch09.html7"/>If you ask the average app developer to tell you what syscalls one of their programs makes, you’re likely to get a blank look. That’s not intended to be insulting. It’s just that most developers write in programming languages that give them higher-level abstractions far removed from the details of syscalls. For example, they might know what files their application opens, but it’s less likely that they could tell you whether they are opened using <code>open()</code> or <code>openat()</code><em>.</em> This makes it unlikely that you’ll get a positive response if you ask the developer to handcraft an appropriate seccomp profile along with their application code.</p>&#13;
<p>Automation is the way forward: the idea is to use a tool to record the set of syscalls an application makes. In the early days, seccomp profiles were generally compiled using <code>strace</code> to gather the set of syscalls an application calls.<sup><a data-type="noteref" href="ch09.html#ch09fn2" id="ch09fn2-marker">1</a></sup> This isn’t a wonderful solution in the cloud native age, as there’s no easy way to point <code>strace</code> at a specific container or Kubernetes pod. It would also be more helpful to generate the profile not just as a list of syscalls, but in the JSON format that Kubernetes and OCI-compatible container runtimes can take as input. There are a couple of tools that do this, using eBPF to gather information about all the syscalls being called:</p>&#13;
<ul>&#13;
<li><p><a href="https://www.inspektor-gadget.io">Inspektor Gadget</a> includes a seccomp profiler that allows you to generate a custom seccomp profile for the containers in a Kubernetes pod.<sup><a data-type="noteref" href="ch09.html#ch09fn3" id="ch09fn3-marker">2</a></sup></p></li>&#13;
<li><p>Red Hat created a seccomp profiler in the form of an <a href="https://oreil.ly/nC8vM">OCI runtime hook</a>.</p></li>&#13;
</ul>&#13;
<p>With these profilers, you need to run the application for some arbitrary amount of time to generate a profile that includes the full list of the syscalls it might legitimately call. As discussed earlier in this chapter, this list needs to include error paths. If your application can’t behave correctly under error conditions because the syscalls it needs to call are blocked, this might cause a bigger problem. And since seccomp profiles deal with a lower abstraction level than most developers are familiar with, it’s hard to review them manually to see if they cover all the right cases.</p>&#13;
<p>Taking the OCI runtime hook as an example, an eBPF program is <a href="https://oreil.ly/sbWSc">attached to the <code>syscall_enter</code> raw tracepoint</a> and maintains an eBPF map that keeps track of <a href="https://oreil.ly/czUM7">which syscalls have been seen</a>. The user space parts of this tool are written in Go and use the <a href="https://oreil.ly/sYCT3"><em>iovisor/gobpf</em> library</a>. (I’ll discuss this and other Golang libraries for eBPF in <a data-type="xref" href="ch10.html#ebpf_programming">Chapter 10</a>.)</p>&#13;
<p>The following are the <a href="https://oreil.ly/DOShA">lines of code</a> from the OCI runtime hook that load the eBPF program into the kernel and attach it to the tracepoint (a few lines have been omitted for brevity):</p>&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">src</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">strings</code><code class="p">.</code><code class="nx">Replace</code><code class="p">(</code><code class="nx">source</code><code class="p">,</code><code class="w"> </code><code class="s">"$PARENT_PID"</code><code class="p">,</code><code class="w"> </code><code class="nx">strconv</code><code class="p">.</code><code class="nx">Itoa</code><code class="p">(</code><code class="nx">pid</code><code class="p">)</code><code class="p">,</code><code class="w"> </code><code class="o">-</code><code class="mi">1</code><code class="p">)</code><code class="w">           </code><a class="co" href="#list_id_9_1" id="code_id_9_1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="nx">m</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">bcc</code><code class="p">.</code><code class="nx">NewModule</code><code class="p">(</code><code class="nx">src</code><code class="p">,</code><code class="w"> </code><code class="p">[</code><code class="p">]</code><code class="kt">string</code><code class="p">{</code><code class="p">}</code><code class="p">)</code><code class="w">&#13;
</code><code class="k">defer</code><code class="w"> </code><code class="nx">m</code><code class="p">.</code><code class="nx">Close</code><code class="p">(</code><code class="p">)</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="o">...</code><code class="w">&#13;
</code><code class="nx">enterTrace</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">m</code><code class="p">.</code><code class="nx">LoadTracepoint</code><code class="p">(</code><code class="s">"enter_trace"</code><code class="p">)</code><code class="w">                             </code><a class="co" href="#list_id_9_2" id="code_id_9_2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="o">...</code><code class="w">&#13;
</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">m</code><code class="p">.</code><code class="nx">AttachTracepoint</code><code class="p">(</code><code class="s">"raw_syscalls:sys_enter"</code><code class="p">,</code><code class="w"> </code><code class="nx">enterTrace</code><code class="p">)</code><code class="p">;</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><a class="co" href="#list_id_9_3" id="code_id_9_3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
    </code><code class="p">{</code><code class="w">                                                                       &#13;
    </code><code class="k">return</code><code class="w"> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"error attaching to tracepoint: %v"</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="p">)</code><code class="w">&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#code_id_9_1" id="list_id_9_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>This line does something quite interesting: it replaces a variable named <code>$PARENT_PID</code> in the eBPF source code with a numeric process ID. This is a common pattern, and it indicates that this tool will load individual eBPF programs for each process being instrumented.</dd>&#13;
<dt><a class="co" href="#code_id_9_2" id="list_id_9_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>Here, an eBPF program called <code>enter_trace</code> gets loaded into the kernel.</dd>&#13;
<dt><a class="co" href="#code_id_9_3" id="list_id_9_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>The <code>enter_trace</code> program gets attached to the tracepoint <code>raw_syscalls:sys_enter</code>. This is the tracepoint at the point of entry to any syscall, which you’ve encountered in earlier examples. Whenever any user space code makes a syscall, this tracepoint will be hit.</dd>&#13;
</dl>&#13;
<p>These profilers use eBPF code attached to <code>sys_enter</code> to keep track of the set of syscalls that have been used, and they generate a seccomp profile to be used with seccomp, which does the actual job of enforcing the profile. The next class of eBPF tools we’ll consider also attach to <code>sys_enter</code>, but they use syscalls to track the behavior of an application and compare it against security policies.<a contenteditable="false" data-primary="" data-startref="ch09.html7" data-type="indexterm" id="idm46123191866624"/><a contenteditable="false" data-primary="" data-startref="ch09.html6" data-type="indexterm" id="idm46123191812096"/><a contenteditable="false" data-primary="" data-startref="ch09.html5" data-type="indexterm" id="idm46123191810720"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Syscall-Tracking Security Tools" data-type="sect2"><div class="sect2" id="syscall_tracking_security_tools">&#13;
<h2>Syscall-Tracking Security Tools</h2>&#13;
<p><a contenteditable="false" data-primary="system calls" data-secondary="syscall-tracking security tools" data-type="indexterm" id="ch09.html9"/>The <a contenteditable="false" data-primary="Falco" data-type="indexterm" id="idm46123191805728"/>best-known tool that falls into this category of syscall-tracking security tools is the CNCF project <a href="https://falco.org">Falco</a>, which provides security alerts. By default, Falco is installed as a kernel module, but there is also an eBPF version. Users can define <a href="https://oreil.ly/enufu">rules</a> to determine what events are security relevant, and Falco can generate alerts in a variety of formats when events happen that don’t match the policies defined in these rules.</p>&#13;
<p>Both the kernel module driver and the eBPF-based driver attach to system calls. If you examine the <a href="https://oreil.ly/Q_cBD">Falco eBPF programs on GitHub</a> you’ll see lines like the following that attach probes to raw syscall entry and exit points (plus a few other events, such as page faults):</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">BPF_PROBE</code><code class="p">(</code><code class="s">"raw_syscalls/"</code><code class="p">,</code><code class="w"> </code><code class="n">sys_enter</code><code class="p">,</code><code class="w"> </code><code class="n">sys_enter_args</code><code class="p">)</code><code class="w"/>&#13;
&#13;
<code class="n">BPF_PROBE</code><code class="p">(</code><code class="s">"raw_syscalls/"</code><code class="p">,</code><code class="w"> </code><code class="n">sys_exit</code><code class="p">,</code><code class="w"> </code><code class="n">sys_exit_args</code><code class="p">)</code><code class="w"/></pre>&#13;
<p>Since eBPF programs can be loaded dynamically and can detect events triggered by preexisting processes, tools like Falco can apply policies to application workloads that are already running. Users can modify the set of rules being applied without having to modify the applications or their configuration. This is in contrast to seccomp profiles, which have to be applied to the application process when it is launched.</p>&#13;
<p><a contenteditable="false" data-primary="Time Of Check to Time Of Use (TOCTOU)" data-type="indexterm" id="ch09.html10"/>Unfortunately there is a problem with this approach of using syscall entry points for security tooling: there is a Time Of Check to Time Of Use (TOCTOU) issue.</p>&#13;
<p>When an eBPF program is triggered at the entry point to a system call, it can access the arguments that user space has passed to that system call. If those arguments are pointers, the kernel will need to copy the pointed-to data into its own data structures before acting on that data. As illustrated in <a data-type="xref" href="#an_attacker_can_change_syscall_argument">Figure 9-2</a>, there is a window of opportunity for an attacker to modify this data, after it has been inspected by the eBPF <span class="keep-together">program</span> but before the kernel copies it. Thus, the data being acted on might not be the same as what was captured by the eBPF program.<sup><a data-type="noteref" href="ch09.html#ch09fn4" id="ch09fn4-marker">3</a></sup></p>&#13;
<figure><div class="figure" id="an_attacker_can_change_syscall_argument">&#13;
<img alt="An attacker can change syscall arguments before they are accessed by the kernel" src="assets/lebp_0902.png"/>&#13;
<h6><span class="label">Figure 9-2. </span>An attacker can change syscall arguments before they are accessed by the <span class="keep-together">kernel</span></h6>&#13;
</div></figure>&#13;
<p>The same window would apply for seccomp-bpf, were it not for the fact that in seccomp-bpf the program is not allowed to dereference the user space pointer, so it’s not possible to examine the data at all.</p>&#13;
<p>The TOCTOU issue does apply for seccomp_unotify, a recently added mode of seccomp where a violation can be reported to user space. The <a href="https://oreil.ly/cwpki">manpage for seccomp_unotify</a> explicitly notes that “It should thus be absolutely clear that the seccomp user-space notification mechanism <em>cannot</em> be used to implement a security policy!”</p>&#13;
<p>The syscall entry point might be very convenient for observability purposes, but for a serious security tool it’s really not sufficient.</p>&#13;
<p>The <a href="https://oreil.ly/pbtF3">Sysmon for Linux tool</a> addresses the TOCTOU window by attaching to both the entry and exit points for syscalls. Once the call has completed, it looks at the kernel’s data structures to get an accurate view. For example, if the syscall returns a file descriptor, the eBPF program attached to the exit can retrieve correct information about the object that the file descriptor represents by looking into the related process’s file descriptor table. While this approach can result in an accurate record of <span class="keep-together">security-related</span> activity, it can’t prevent an action from taking place, since the syscall has already completed by the time a check is made.<a contenteditable="false" data-primary="" data-startref="ch09.html10" data-type="indexterm" id="idm46123191761760"/></p>&#13;
<p>To be certain that it is inspecting the same information the kernel will act on, the eBPF program should be attached to an event that occurs after the parameters have been copied into kernel memory. Unfortunately, there is no single common place in the kernel to do this, as the data is handled differently in syscall-specific code. However, there is a well-defined interface where eBPF programs can be safely attached: the Linux Security Module (LSM) API.<a contenteditable="false" data-primary="" data-startref="ch09.html9" data-type="indexterm" id="idm46123191759968"/> This requires a relatively new eBPF feature: BPF LSM.<a contenteditable="false" data-primary="" data-startref="ch09.html4" data-type="indexterm" id="idm46123191758464"/><a contenteditable="false" data-primary="" data-startref="ch09.html3" data-type="indexterm" id="idm46123191757088"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="BPF LSM" data-type="sect1"><div class="sect1" id="bpf_lsm">&#13;
<h1>BPF LSM</h1>&#13;
<p><a contenteditable="false" data-primary="LSM (Linux Security Module)" data-secondary="LSM BPF" data-type="indexterm" id="ch09.html11"/><a contenteditable="false" data-primary="security" data-secondary="LSM BPF" data-type="indexterm" id="ch09.html12"/>The LSM interface provides a set of hooks that each occur just before the kernel is about to act on a kernel data structure. The function called by a hook can make a decision about whether to allow the action to go ahead. This interface was originally provided to allow security tools to be implemented in the form of <a href="https://oreil.ly/mF_OD">kernel modules</a>; <a href="https://oreil.ly/KzaMT">BPF LSM</a> extends this so that eBPF programs can be attached to the same hook points, as shown in <a data-type="xref" href="#with_lsm_bpfcomma_ebpf_programs_can_be_">Figure 9-3</a>.</p>&#13;
<figure><div class="figure" id="with_lsm_bpfcomma_ebpf_programs_can_be_">&#13;
<img alt="With LSM BPF, eBPF programs can be triggered by LSM hook events" src="assets/lebp_0903.png"/>&#13;
<h6><span class="label">Figure 9-3. </span>With LSM BPF, eBPF programs can be triggered by LSM hook events</h6>&#13;
</div></figure>&#13;
<p>There are hundreds of LSM hooks, and they’re pretty nicely <a href="https://oreil.ly/dO8jT">documented in the kernel source code</a>. To be clear, there isn’t a one-to-one mapping between syscalls and LSM hooks, but if a syscall has the potential to do something interesting from a security perspective, processing that syscall will trigger one or more of the hooks.</p>&#13;
<p>Here’s a trivial example of an eBPF program attached to an LSM hook. This example is called during the processing of a <code>chmod</code> command (“chmod” stands for “change modes” and is mostly used to change the access permissions on a file):</p>&#13;
<pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"lsm/path_chmod"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">BPF_PROG</code><code class="p">(</code><code class="n">path_chmod</code><code class="p">,</code><code class="w"> </code><code class="k">const</code><code class="w"> </code><code class="k">struct</code><code class="w"> </code><code class="nc">path</code><code class="w"> </code><code class="o">*</code><code class="n">path</code><code class="p">,</code><code class="w"> </code><code class="n">umode_t</code><code class="w"> </code><code class="n">mode</code><code class="p">)</code><code class="w"/>&#13;
<code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"Change mode of file name %s</code><code class="se">\n</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">path</code><code class="o">-&gt;</code><code class="n">dentry</code><code class="o">-&gt;</code><code class="n">d_iname</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
<p>This example simply traces out the name of the file and always returns <code>0</code>, but you can imagine a real implementation that would make use of the arguments to decide whether to allow this change of mode. Returning a nonzero value would deny permission to make this change, so the kernel wouldn’t go ahead with it. It’s worth noting that making policy checks entirely within the kernel like this is highly performant.</p>&#13;
<p>The <code>path</code> argument to <code>BPF_PROG()</code> is the kernel data structure representing the file, and the <code>mode</code> argument is the desired new mode value. You can see the name of the file being accessed from the field <code>path-&gt;dentry-&gt;d_iname</code>.</p>&#13;
<p>LSM BPF was added in kernel version 5.7, which means that (at least at the time of this writing) it’s not yet available on many supported Linux distributions, but I expect that over the next couple of years many vendors will develop security tooling that makes use of this interface. Before LSM BPF is made widely available, there is another possible approach, as used by the developers of Cilium Tetragon.<a contenteditable="false" data-primary="" data-startref="ch09.html12" data-type="indexterm" id="idm46123191689312"/><a contenteditable="false" data-primary="" data-startref="ch09.html11" data-type="indexterm" id="idm46123191687936"/></p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Cilium Tetragon" data-type="sect1"><div class="sect1" id="cilium_tetragon">&#13;
<h1>Cilium Tetragon</h1>&#13;
<p><a contenteditable="false" data-primary="Cilium Tetragon" data-type="indexterm" id="ch09.html13"/><a contenteditable="false" data-primary="security" data-secondary="Cilium Tetragon" data-type="indexterm" id="ch09.html14"/><a href="https://oreil.ly/p-bdc">Tetragon</a> is part of the Cilium project (also part of the CNCF). Rather than attaching to LSM API hooks, Tetragon’s approach is to build a framework for attaching eBPF programs to arbitrary functions in the Linux kernel.</p>&#13;
<p>Tetragon is designed for use in a Kubernetes environment, and the project defines a custom Kubernetes resource type called a <em>TracingPolicy</em>. This is used to define a set of events to which eBPF programs should be attached, conditions that need to be checked by eBPF code, and actions to take if the conditions are met. The following is an extract from a sample TracingPolicy:</p>&#13;
<pre data-type="programlisting">spec:&#13;
 kprobes:&#13;
 - call: "fd_install"&#13;
...&#13;
     matchArgs:&#13;
     - index: 1&#13;
       operator: "Prefix"&#13;
       values:&#13;
       - "/etc/"&#13;
...</pre>&#13;
<p>This policy defines a set of kprobes to attach programs to, the first of which is the kernel function <code>fd_install</code>. This is an internal function in the kernel. Let’s explore why you might choose to attach to a function like that.</p>&#13;
<section data-pdf-bookmark="Attaching to Internal Kernel Functions" data-type="sect2"><div class="sect2" id="attaching_to_internal_kernel_functions">&#13;
<h2>Attaching to Internal Kernel Functions</h2>&#13;
<p><a contenteditable="false" data-primary="Cilium Tetragon" data-secondary="attaching to internal kernel functions" data-type="indexterm" id="idm46123191617744"/>The system call interface and the LSM interface are defined as stable interfaces in the Linux kernel; that is to say, they won’t change in a backward-incompatible way. If you write code today that uses the functions in those interfaces, they will continue to work in future versions of the kernel. These interfaces represent just a tiny fraction of the 30 million lines of code that make up the Linux kernel. Parts of that codebase are de facto stable, even if they are not officially declared as such; they haven’t changed for a long time and are unlikely to do so in the future.</p>&#13;
<p>It’s perfectly reasonable to write eBPF programs that attach to kernel functions that aren’t officially stable, with the expectation that they are likely to work for some considerable time to come. Also, given that it typically takes several years for a new kernel version to be widely deployed, it’s a safe bet that there will be plenty of time to address any incompatibility issues that might arise.</p>&#13;
<p>The Tetragon contributors include a number of kernel developers who have used their knowledge of kernel internals to identify some good, safe places where eBPF programs can be attached for useful security purposes. There are several <a href="https://oreil.ly/51yRN">example TracingPolicy definitions</a> that make use of this knowledge. <a contenteditable="false" data-primary="privileges" data-secondary="escalation" data-type="indexterm" id="idm46123191614752"/>These examples monitor security events covering file operations, network activity, program executions, and changes to privileges—all the kinds of things a malicious actor would do as part of an attack.</p>&#13;
<p>Let’s come back to that example policy definition that attaches to <code>fd_install</code>. The “fd” stands for “file descriptor,” and the <a href="https://oreil.ly/Tm6MN">comment in the source code for this function</a> tells us this function “Install[s] a file pointer in the fd array.” This happens when a file is opened, and it’s called after the file’s data structure has been populated in the kernel. It’s a safe place to check the name of the file—and in the earlier TracingPolicy example, it’s only of interest if the filename starts with “/etc/”.</p>&#13;
<p>Just as in LSM BPF programs, Tetragon eBPF programs have access to contextual information to allow them to make security decisions entirely within the kernel. Rather than reporting all events of a given type to user space, security-relevant events can be filtered within the kernel so that only the out-of-policy events get reported to user space.</p>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Preventative Security" data-type="sect2"><div class="sect2" id="preventative_security">&#13;
<h2>Preventative Security</h2>&#13;
<p><a contenteditable="false" data-primary="Cilium Tetragon" data-secondary="preventative security" data-type="indexterm" id="idm46123191609600"/><a contenteditable="false" data-primary="preventative security" data-type="indexterm" id="idm46123191608224"/>Most eBPF-based security tools have used eBPF programs to detect malicious events, which notify a user space application that can then take action. As you can see in <a data-type="xref" href="#an_asynchronous_notification_from_kerne">Figure 9-4</a>, any action the user space app takes happens asynchronously, by which time it might be too late—perhaps data could have been exfiltrated, or the attacker could have persisted malicious code onto disk.</p>&#13;
<figure><div class="figure" id="an_asynchronous_notification_from_kerne">&#13;
<img alt="An asynchronous notification from kernel to user space allows some time for an attack to continue" src="assets/lebp_0904.png"/>&#13;
<h6><span class="label">Figure 9-4. </span>An asynchronous notification from kernel to user space allows some time for an attack to continue</h6>&#13;
</div></figure>&#13;
<p>In kernel versions 5.3 and up, there is a BPF helper function called <code>b⁠p⁠f⁠_⁠s⁠e⁠n⁠d⁠_​s⁠i⁠g⁠n⁠a⁠l⁠(⁠)</code>. Tetragon uses this function to implement preventative security. If a policy defines a Sigkill action, any matching events will cause Tetragon eBPF code to generate a SIGKILL signal that terminates the process that was attempting the out-of-policy action. As shown in <a data-type="xref" href="#tetragon_kills_malicious_processes_sync">Figure 9-5</a>, this happens synchronously; that is, the activity the kernel was performing that the eBPF code determined to be out of policy is prevented from completing.</p>&#13;
<figure><div class="figure" id="tetragon_kills_malicious_processes_sync">&#13;
<img alt="Tetragon kills malicious processes synchronously by sending a SIGKILL signal from the kernel" src="assets/lebp_0905.png"/>&#13;
<h6><span class="label">Figure 9-5. </span>Tetragon kills malicious processes synchronously by sending a SIGKILL signal from the kernel</h6>&#13;
</div></figure>&#13;
<p>Sigkill policies need to be used with care, because an incorrectly configured policy could result in terminating applications unnecessarily, but it’s an incredibly powerful use of eBPF for security purposes. You can start by running in an “audit” mode that generates security events but doesn’t apply the SIGKILL enforcement, until you’re confident that the policy won’t break anything.</p>&#13;
<p>If you’re interested in learning more about using Cilium Tetragon for detecting security events, there is a report titled “<a class="orm:hideurl" href="https://www.oreilly.com/library/view/security-observability-with/9781492096719/">Security Observability with eBPF</a>” by Natália Réka Ivánkó and Jed Salazar that digs into much more detail.<a contenteditable="false" data-primary="" data-startref="ch09.html14" data-type="indexterm" id="idm46123191598400"/><a contenteditable="false" data-primary="" data-startref="ch09.html13" data-type="indexterm" id="idm46123191597184"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
<section data-pdf-bookmark="Network Security" data-type="sect1"><div class="sect1" id="network_security">&#13;
<h1>Network Security</h1>&#13;
<p><a contenteditable="false" data-primary="network security" data-type="indexterm" id="idm46123191593776"/><a contenteditable="false" data-primary="networking" data-secondary="security" data-type="indexterm" id="idm46123191592672"/><a contenteditable="false" data-primary="security" data-secondary="network security" data-type="indexterm" id="idm46123191591296"/><a data-type="xref" href="ch08.html#ebpf_for_networking">Chapter 8</a> discussed how eBPF can be used very effectively to implement network security mechanisms. To summarize:</p>&#13;
<ul>&#13;
<li><p>Firewalling and DDoS protection are a natural fit for eBPF programs attached early in the ingress path for network packets. And with the possibility of XDP programs offloaded to hardware, malicious packets may never even reach the CPU!</p></li>&#13;
<li><p>For implementing more sophisticated network policies, such as Kubernetes policies determining which services are allowed to communicate with one another, eBPF programs that attach to points in the network stack can drop packets if they are determined to be out of policy.</p></li>&#13;
</ul>&#13;
<p>Network security tools are very often used in a preventative mode, dropping packets rather than just auditing malicious activity. This is because it’s so easy for bad actors to mount network-related attacks; if you give a device a public IP address exposed to the internet, it won’t be long before you start seeing suspicious traffic, so organizations are forced to use preventative measures.</p>&#13;
<p>In contrast, lots of organizations use intrusion detection tools in an audit mode, and they rely on forensics to determine whether a suspicious event was really malicious and what remedial action needs to be taken. If a given security tool is too blunt an instrument and is prone to detecting false-positives, it’s not surprising that it needs to be run in audit mode rather than preventative mode. It’s my belief that eBPF is enabling more sophisticated security tools with finer-grained, accurate controls. Just as we consider firewalls today to be sufficiently accurate to use in preventative mode, we’ll see increased use of preventative tooling that acts on other, non-networking events. This could even include eBPF-based controls being packaged as part of an application product so that it can provide its own runtime security.</p>&#13;
</div></section>&#13;
<section class="pagebreak-before" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000018">&#13;
<h1 class="less_space">Summary</h1>&#13;
<p>In this chapter you saw how eBPF’s use in security has evolved from low-level checks on system calls to much more sophisticated use of eBPF programs for security policy checks, in-kernel event filtering, and runtime enforcement.</p>&#13;
<p>There’s still much active development in the area of using eBPF for security purposes. I believe we will see tools in this area evolving and becoming widely adopted over the coming years.<a contenteditable="false" data-primary="" data-startref="ch09.html0" data-type="indexterm" id="idm46123191583680"/></p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch09fn2"><sup><a href="ch09.html#ch09fn2-marker">1</a></sup> See, for example, this post from Jess Frazelle, who developed the default seccomp profile for Docker: <a href="https://oreil.ly/EcpnM">“How to Use the New Docker Seccomp Profiles”</a>.</p><p data-type="footnote" id="ch09fn3"><sup><a href="ch09.html#ch09fn3-marker">2</a></sup> The documentation for Inspektor Gadget’s seccomp profiler is quite dry, but <a href="https://oreil.ly/0bYaa">this video overview from Jose Blanquicet</a> is more accessible.</p><p data-type="footnote" id="ch09fn4"><sup><a href="ch09.html#ch09fn4-marker">3</a></sup> Exploiting this window was discussed in a DEFCON 29 talk titled “<a href="https://oreil.ly/WguKq">Phantom Attack: Evading System Call Monitoring</a>” by Rex Guo and Junyuan Zeng, and its impact on Falco was covered in more detail in the talk “<a href="https://oreil.ly/17c-3">LSM BPF Change Everything</a>” by Leo Di Donato and KP Singh.</p></div></div></section></body></html>