- en: Chapter 7\. Shipping Controllers and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’re familiar with the development of custom controllers, let’s move
    on to the topic of how to make your custom controllers and operators production-ready.
    In this chapter we’ll discuss the operational aspects of controllers and operators,
    showing you how to package them, walking you through best practices for running
    controllers in production, and making sure that your extension points don’t break
    your Kubernetes cluster, security, or performance-wise.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle Management and Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we consider the lifecycle management of operators. That is,
    we will discuss how to package and ship your controller or operator, as well as
    how to handle upgrades. When you’re ready to ship your operator to users, you’ll
    need a way for them to install it. For this, you need to package the respective
    artifacts, such as YAML manifests that define the controller binary (typically
    as a Kubernetes deployment), along with the CRDs and security-related resources,
    such as service accounts and the necessary RBAC permissions. Once your targeted
    users have a certain version of the operator running, you will also want to have
    a mechanism in place for upgrading the controller, considering versioning and
    potentially zero-downtime upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the low-hanging fruit: packaging and delivering your controllers
    so that a user can install it in a straightforward manner.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Packaging: The Challenge'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Kubernetes defines resources with manifests, typically written in YAML,
    a low-level interface to declare the state of resources, these manifest files
    have shortcomings. Most importantly in the context of packaging containerized
    apps, the YAML manifests are static; that is, all values in a YAML manifest are
    fixed. This means that if you want to change the container image in a [deployment
    manifest](http://bit.ly/2WZ1uRD), for example, you have to create a new manifest.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at a concrete example. Assume you have the following Kubernetes
    deployment encoded in a YAML manifest called *mycontroller.yaml*, representing
    the custom controller you’d like users to install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Imagine the environment variable `REGION` defines certain runtime properties
    of your controller, such as the availability of other services like a managed
    service mesh. In other words, while the default value of `eu-west-1` might be
    a sensible one, users can and likely will overwrite it, based on their own preferences
    or policies.
  prefs: []
  type: TYPE_NORMAL
- en: Now, given that the YAML manifest *mycontroller.yaml* itself is a static file
    with all values defined at the time of writing—and clients such as `kubectl` don’t
    inherently support variable parts in the manifest—how do you enable users to supply
    variable values or overwrite existing values at runtime? That is, how in the preceding
    example can a user set `REGION` to, say, `us-east-2` when they’re installing it,
    using (for example) `kubectl apply`?
  prefs: []
  type: TYPE_NORMAL
- en: To overcome these limitations of build-time, static YAML manifests in Kubernetes,
    there are a few options to templatize the manifests (Helm, for example) or otherwise
    enable variable input (Kustomize), depending on user-provided values or runtime
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Helm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Helm](https://helm.sh), which touts itself as *the* package manager for Kubernetes,
    was originally developed by Deis and is now a Cloud Native Computing Foundation
    ([CNCF](https://www.cncf.io)) project with major contributors from Microsoft,
    Google, and Bitnami (now part of VMware).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm helps you to install and upgrade Kubernetes applications by defining and
    applying so-called charts, effectively parameterized YAML manifests. Here is an
    excerpt of an [example chart template](http://bit.ly/2XmLk3R):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, variables are encoded in `{{ ._Some.value.here_ }}` format,
    which happens to be [Go templates](http://bit.ly/2N2Q3DW).
  prefs: []
  type: TYPE_NORMAL
- en: 'To install a chart, you can run the `helm install` command. While Helm has
    several ways to find and install charts, the easiest is to use one of the official
    stable charts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In order to package your controller, you will need to create a Helm chart for
    it and publish it somewhere, by default to a public repository indexed and accessible
    through the [Helm Hub](https://hub.helm.sh), as depicted in [Figure 7-1](#helm-hub).
  prefs: []
  type: TYPE_NORMAL
- en: '![Helm Hub screen shot, showing publicly available Helm charts](assets/prku_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. Helm Hub screenshot showing publicly available Helm charts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For further guidance on how to create Helm charts, peruse the following resources
    at your leisure:'
  prefs: []
  type: TYPE_NORMAL
- en: Bitnami’s excellent article [“How to Create Your First Helm Chart”](http://bit.ly/2ZIlODJ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[“Using S3 as a Helm Repository”](http://bit.ly/2KzwLDY), if you want to keep
    the charts in your own organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official Helm docs: [“The Chart Best Practices Guide”](http://bit.ly/31GbayW).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helm is popular, partly because of its ease of use for end users. However, some
    argue that the current Helm architecture introduces [security risks](http://bit.ly/2WXM5vZ).
    The good news is that the community is actively working on addressing those.
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kustomize](https://kustomize.io) provides a declarative approach to configuration
    customization of Kubernetes manifest files, adhering to the familiar Kubernetes
    API. It was [introduced in mid-2018](http://bit.ly/2L5Ec5f) and is now a Kubernetes
    SIG CLI project.'
  prefs: []
  type: TYPE_NORMAL
- en: You can [install](http://bit.ly/2Y3JeCV) Kustomize on your machine, as a standalone,
    or, if you have a more recent `kubectl` version (newer than 1.14), it is [shipped](http://bit.ly/2IEYqRG)
    with `kubectl` and activated with the `-k` command-line flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, Kustomize lets you customize the raw YAML manifest files, without touching
    the original manifest. But how does this work in practice? Let’s assume you want
    to package our `cnat` custom controller; you’d define a file called *kustomize.yaml*
    that looks something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can apply this to the *cnat-controller.yaml* file, say, with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Use `kustomize build` and—leaving the *cnat-controller.yaml* file unchanged!—the
    output is then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The output of `kustomize build` can then, for example, be used in a `kubectl
    apply` command, with all the [customizations](http://bit.ly/2LbCDTr) applied for
    you, automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a more detailed walk-through of Kustomize and how to use it, check out
    the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Sébastien Goasguen’s blog post [“Configuring Kubernetes Applications with kustomize"](http://bit.ly/2JbgJOR).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kevin Davin’s post [“Kustomize—The right way to do templating in Kubernetes”](http://bit.ly/2JpJgPm).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The video [“TGI Kubernetes 072: Kustomize and friends”](http://bit.ly/2XoHm6C),
    where you can watch Joe Beda apply it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given the native support of Kustomize in `kubectl`, it’s likely that an increasing
    number of users will adopt it. Note that while it solves some problems (customization),
    there are other areas of the lifecycle management, such as validations and upgrades,
    that may require you to use Kustomize together with languages such as Google’s
    [CUE](http://bit.ly/32heAZl).
  prefs: []
  type: TYPE_NORMAL
- en: To wrap up this packaging topic, let’s review some other solutions practitioners
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Other Packaging Options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some notable alternatives to the aforementioned packaging options—and the many
    others [in the wild](http://bit.ly/2X553FE)—are:'
  prefs: []
  type: TYPE_NORMAL
- en: UNIX tooling
  prefs: []
  type: TYPE_NORMAL
- en: In order to customize values of raw Kubernetes manifests, you can use a range
    of CLI tools such as `sed`, `awk`, or `jq` in shell scripts. This is a popular
    solution and, at least until the arrival of Helm, likely the most widely used
    option—not least because it minimizes dependencies and is rather portable across
    *nix environments.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional configuration management systems
  prefs: []
  type: TYPE_NORMAL
- en: You can use any of the traditional configuration management systems, such as
    Ansible, Puppet, Chef, or Salt, to package and deliver your operator.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native languages
  prefs: []
  type: TYPE_NORMAL
- en: A new generation of so-called [cloud-native programming languages](http://bit.ly/2Rwh5lu),
    such as Pulumi and Ballerina, allows for, among other things, packaging and lifecycle
    management of Kubernetes-native apps.
  prefs: []
  type: TYPE_NORMAL
- en: '[ytt](https://get-ytt.io)'
  prefs: []
  type: TYPE_NORMAL
- en: With `ytt` you have another option for a YAML templating tool using a language
    that is itself a modified version of Google’s configuration language [Starlark](http://bit.ly/2NaqoJh).
    It operates semantically on the YAML structures and focuses on reusability.
  prefs: []
  type: TYPE_NORMAL
- en: '[Ksonnet](https://ksonnet.io)'
  prefs: []
  type: TYPE_NORMAL
- en: A configuration management tool for Kubernetes manifests, originally developed
    by Heptio (now VMware), Ksonnet has been deprecated and is not actively worked
    on anymore, so use it at your own risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Read more about the options discussed here in Jesse Suen’s post [“The State
    of Kubernetes Configuration Management: An Unsolved Problem”](http://bit.ly/2N9BkXM).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve discussed the packaging options in general, let’s look at best
    practices for packaging and shipping controllers and operators.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When packaging and publishing your operator, make sure you are aware of the
    following best practices. These apply regardless of which mechanism you choose
    (Helm, Kustomize, shell scripts, etc.):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Provide a proper access control setup: this means defining a dedicated service
    account for the controller along with the RBAC permissions on a least-privileges
    basis; see [“Getting the Permissions Right”](#crds-rbac) for further details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider the scope of your custom controller: will it look after CRs in one
    namespace or more than one namespace? Check out [Alex Ellis’s Twitter conversation](http://bit.ly/2ZHd5S7)
    about the pros and cons of the different approaches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test and profile your controller so that you have an idea of its footprint and
    scalability. For example, Red Hat has put together a detailed set of requirements
    with instructions in the OperatorHub [contribution](http://bit.ly/2IEplx4) guide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make sure the CRDs and controller are well documented, ideally with the inline
    docs available on [godoc.org](https://godoc.org) and a set of usage examples;
    see Banzai Cloud’s [bank-vaults](http://bit.ly/2XtfPVB) operator for inspiration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifecycle Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A broader and more holistic approach, compared to package/ship, is that of
    lifecycle management. The basic idea is to consider the entire supply chain, from
    development to shipping to upgrades, and automate as much as possible. In this
    area, CoreOS (and later Red Hat) was again a trailblazer: applying the same logic
    that led to operators to their lifecycle management. In other words: in order
    to install and later upgrade the custom controller of an operator, you’d have
    a dedicated operator that knows how to, well, handle operators. And indeed, part
    of the Operator Framework—which also provides the Operator SDK, as discussed in
    [“The Operator SDK”](ch06.html#operator-sdk)—is the so-called [Operator Lifecycle
    Manager](http://bit.ly/2HIfDcR) (OLM).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jimmy Zelinskie, one of the main people behind OLM, [phrased](http://bit.ly/2KEfoSu)
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OLM does a lot for Operator authors, but it also solves an important problem
    that not many people have thought about yet: how do you effectively manage first-class
    extensions to Kubernetes over time?'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: In a nutshell, OLM provides a declarative way to install and upgrade operators
    and their dependencies, complementary packaging solutions such as Helm. It’s up
    to you if you want to buy into the full-blown OLM solution or create an ad hoc
    solution for the versioning and upgrading challenge; however, you should have
    some strategy in place here. For certain areas—for example, the [certification
    process](http://bit.ly/2KBlymy) for the Operator Hub by Red Hat—it’s not only
    recommended but mandatory for any nontrivial deployment scenario, even if you
    don’t aim at the Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Production-Ready Deployments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section we review and discuss how to make your custom controllers and
    operators production-ready. The following is a high-level checklist:'
  prefs: []
  type: TYPE_NORMAL
- en: Use Kubernetes [deployments](http://bit.ly/2q7vR7Y) or DaemonSets to supervise
    your custom controller so that they are restarted automatically when they fail—and
    fail they will.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement health checks through dedicated endpoints for liveness and readiness
    probes. This, together with the previous step, makes your operations more resilient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider a leader-follower/standby model to make sure that even when your controller
    pod crashes, someone else can take over. Note, however, that synchronizing state
    is a nontrivial task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide access control resources, such as service account and roles, applying
    the least-privileges principle; see [“Getting the Permissions Right”](#crds-rbac)
    for details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider automated builds, including testing. Some more tips are available in
    [“Automated Builds and Testing”](#crds-perf).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proactively tackle monitoring and logging; see [“Custom Controllers and Observability”](#o11y)
    for the what and how.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also suggest that you peruse the aforementioned article [“Kubernetes Operator
    Development Guidelines for Improved Usability”](http://bit.ly/31P7rPC) to learn
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Permissions Right
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your custom controller is part of the Kubernetes control plane. It needs to
    read the state of resources, create resources inside as well as (potentially)
    outside Kubernetes, and communicate the state of its own resources. For all of
    this, the custom controller needs the right set of permissions, expressed through
    a set of role-based access control (RBAC)–related settings. Getting this right
    is the topic of this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first: *always* create a [dedicated service account](http://bit.ly/2RwoSQp)
    to run your controller. In other words: *never* use the `default` service account
    in a namespace.^([1](ch07.html#idm46336853931352))'
  prefs: []
  type: TYPE_NORMAL
- en: To make your life easier, you can define a `ClusterRole` with the necessary
    RBAC rules along with a `RoleBinding` to bind it to a specific namespace, effectively
    reusing the role across namespaces, as explained in the [Using RBAC Authorization](http://bit.ly/2LdVFsj)
    entry.
  prefs: []
  type: TYPE_NORMAL
- en: Following the least-privileges principle, assign only the permissions necessary
    for the controller to carry out its work. For example, if a controller only manages
    pods, there is no need to provide it with the permissions to list or create deployments
    or services. Also, make sure that the controller does not install the CRDs and/or
    the admission webhooks. In other words, the controller *should not* have permissions
    to manage CRDs and webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common tooling for creating custom controllers, as discussed in [Chapter 6](ch06.html#ch_operator-solutions),
    typically provides functionality for generating RBAC rules out-of-the-box. For
    example, Kubebuilder generates the [following](http://bit.ly/2RRCyFO) RBAC assets,
    along with an operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the autogenerated RBAC roles and bindings reveals a fine-grained
    setup. In *rbac_role.yaml* you can find:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at these permissions that Kubebuilder generates in `v1`, you’ll likely
    be a little taken aback.^([2](ch07.html#idm46336853898344)) We certainly were:
    best practice tells us that a controller, if it does not have very good reasons
    for doing so, should not be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: Write resources that are only read in the code, generally. For example, if you
    only watch services and deployments, do remove the `create`, `update`, `patch`,
    and `delete` verbs in the role.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Access all secrets; that is, always restrict this to the most minimal set of
    secrets necessary.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write `MutatingWebhookConfigurations` or `ValidatingWebhookConfigurations`.
    This is equivalent to getting access to any resource in the cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write `CustomResourceDefinition`s. Note that this is not allowed in the cluster
    role just shown, but it’s important to mention here, nevertheless: CRD creation
    should be done by a separate process, not by the controller itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write the */status* subresource (see [“Subresources”](ch04.html#crd-subresources))
    of foreign resources that it is not managing. For example, deployments here are
    not managed by the `cnat` controller and should not be in scope.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubebuilder, of course, is not really able to understand what your controller
    code is actually doing. So it’s not surprising that the generated RBAC rules are
    far too relaxed. We recommend double-checking the permissions and reducing them
    to the absolute minimum, following the preceding checklist.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Having read access to all secrets in the system gives a controller access to
    all service account tokens. This is equivalent to having access to all passwords
    in the cluster. Having write access to `MutatingWebhookConfigurations` or `ValidatingWebhookConfigurations`
    allows you to intercept and manipulate every API request in the system. This opens
    the door to rootkits in a Kubernetes cluster. Both are obviously highly dangerous
    and considered antipatterns, so it’s best to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: To avoid having too much power—that is, to restrict access rights to those that
    are absolutely necessary—consider using [audit2rbac](http://bit.ly/2IDW1qm). This
    tool uses audit logs to generate an appropriate set of permissions, leading to
    more secure setups and fewer headaches down the road.
  prefs: []
  type: TYPE_NORMAL
- en: 'From *rbac_role_binding.yaml* you can learn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For more best practices on RBAC and tooling around it, check out [*RBAC.dev*](https://rbac.dev),
    a website dedicated to RBAC in Kubernetes. Let’s move on now to testing and performance
    considerations for custom controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Automated Builds and Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a best practice in cloud-native land, consider an automated build of your
    custom controller. This is usually called *continuous build* or *continuous integration*
    (CI) and comprises unit tests, integration tests, building the container image,
    and potentially even sanity or [smoke](http://bit.ly/1Z9jXp5) tests. The Cloud
    Native Computing Foundation (CNCF) maintains an interactive [listing](http://bit.ly/2J2vy4L)
    of the many open source CI tools available.
  prefs: []
  type: TYPE_NORMAL
- en: When building your controller, keep in mind that it should consume as few compute
    resources as possible, while at the same time serving as many clients as possible.
    Each CR, based on the CRD(s) you define, is a proxy for a client. But how do you
    know how much it consumes, if and where it leaks memory, and how well it scales?
  prefs: []
  type: TYPE_NORMAL
- en: 'You can and indeed should carry out a number of tests, once the development
    of your custom controller stabilizes. These can include the following, but may
    not be limited to them:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance-related tests, as found in [Kubernetes itself](http://bit.ly/2X556g8)
    as well as the [kboom](http://bit.ly/2Fuy4zU) tool, can provide you with data
    around scaling and resource footprints.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soak tests—for example, the ones used [in Kubernetes](http://bit.ly/2KBZmZc)—aim
    at long-term usage, from several hours to days, with the goal of unveiling any
    leaking of resources, like files or main memory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a best practice, these tests should be part of your CI pipeline. In other
    words, automate the building of the custom controller, testing, and packaging
    from day one. For a concrete example setup we encourage you to check out Marko
    Mudrinić’s excellent post [“Spawning Kubernetes Clusters in CI for Integration
    and E2E tests”](http://bit.ly/2FwN1RU).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll look at best practices that provide the basis for effective troubleshooting:
    built-in support for observability.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom Controllers and Observability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section we look at *observability* aspects of your custom controllers,
    specifically logging and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure you provide enough logging information to aid [troubleshooting](http://bit.ly/2WXD85D)
    (in production). As usual in a containerized setup, log information is sent to
    `stdout`, where it can be consumed either on a per-pod basis with the `kubectl
    logs` command or in an aggregated form. Aggregates can be provided using cloud-provider-specific
    solutions, such as Stackdriver in Google Cloud or CloudWatch in AWS, or bespoke
    solutions like the Elasticsearch-Logstash-Kibana/Elasticsearch-Fluentd-Kibana
    stack. See also [*Kubernetes Cookbook*](http://bit.ly/2FTgJzk) by Sébastien Goasguen
    and Michael Hausenblas (O’Reilly) for recipes on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example excerpt of our `cnat` custom controller log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The *how* of logging: in general, we prefer [structured logging](http://bit.ly/31TPRu3)
    and adjustable log levels, at least `debug` and `info`. There are two methods
    widely used across the Kubernetes code base, and unless you have good reasons
    not to, you should consider using those:'
  prefs: []
  type: TYPE_NORMAL
- en: The `logger` interface—for example, as found in [*httplog.go*](http://bit.ly/2WWV54w),
    along with a concrete type (`respLogger`)—captures things like the status and
    errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[`klog`](http://bit.ly/31OJxUu), a fork of Google’s `glog`, is a structured
    logger used throughout Kubernetes, and while it has its idiosyncrasies, it’s worth
    knowing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The *what* of logging: make sure to have detailed log information for the normal
    case of your business logic operation. For example, from our Operator SDK implementation
    of the `cnat` controller, in [*at_controller.go*](http://bit.ly/2Fpo5Mi), set
    up the logger like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And then in the business logic, in the `Reconcile(request reconcile.Request)`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This Go snippet gives you a good idea of what to log, and especially when to
    use `reqLogger.Info` and `reqLogger.Error`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Logging 101 out of the way, let’s move on to a related topic: metrics!'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring, instrumentation, and auditing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A great open source, container-ready monitoring solution you can use across
    environments (on-premises and in the cloud) is [Prometheus](https://prometheus.io).
    Alerting on each event is not practical, so you might want to think about who
    needs to be informed about what kind of event. For example, you could have a policy
    that node-related or namespace-related events are handled by infrastructure admins,
    and namespace admins or developers are paged for pod-level events. In this context,
    in order to visualize the metrics you’ve gathered, the most popular solution is
    certainly [Grafana](https://grafana.com); see [Figure 7-2](#grafana_prometheus)
    for an example of Prometheus metrics visualized in Grafana, taken from the [Prometheus
    documentation](http://bit.ly/2Oi4YcA).
  prefs: []
  type: TYPE_NORMAL
- en: If you are using a service mesh—for example, based on the [Envoy proxy](https://envoy.com)
    (like Istio or App Mesh), or Linkerd—then instrumentation typically comes for
    free or is achievable with minimal (configuration) effort. Otherwise, you will
    have to use the respective libraries, such as those provided by [Prometheus](http://bit.ly/2xb2qmv),
    to expose the relevant metrics in your code yourself. In this context, you might
    also want to check out the fledgling Service Mesh Interface ([SMI](https://smi-spec.io))
    project, introduced in early 2019, which aims to provide a standardized interface
    for service meshes, based on CRs and controllers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Prometheus metrics visualized in Grafana](assets/prku_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Prometheus metrics visualized in Grafana
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Another useful feature Kubernetes offers via the API server is [auditing](http://bit.ly/2O4WBkL),
    which allows you to record a sequence of activities affecting the cluster. Different
    strategies are available in the auditing policy, from no logging to logging event
    metadata, request bodies, and response bodies. You can choose between a simple
    log backend and using a webhook for integrating with third-party systems.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter focused on how to make your operators production-ready by discussing
    operational aspects of controllers and operators, including packaging, security,
    and performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this we’ve covered the basics of writing and using custom Kubernetes controllers
    and operators, so now we move on to another way to extend Kubernetes: developing
    a custom API server.'
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch07.html#idm46336853931352-marker)) See also Luc Juggery’s post [“Kubernetes
    Tips: Using a ServiceAccount”](http://bit.ly/2X0fjKK) for a detailed discussion
    of service account usage.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch07.html#idm46336853898344-marker)) We did, however, raise [Issue 748](http://bit.ly/2J7Qys4)
    against the Kubebuilder project.
  prefs: []
  type: TYPE_NORMAL
