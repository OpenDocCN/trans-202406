- en: Chapter 6\. Labels and Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes was made to grow with you as your application scales in both size
    and complexity. Labels and annotations are fundamental concepts in Kubernetes
    that let you work in sets of things that map to how *you* think about your application.
    You can organize, mark, and cross-index all of your resources to represent the
    groups that make the most sense for your application.
  prefs: []
  type: TYPE_NORMAL
- en: '*Labels* are key/value pairs that can be attached to Kubernetes objects such
    as Pods and ReplicaSets. They can be arbitrary and are useful for attaching identifying
    information to Kubernetes objects. Labels provide the foundation for grouping
    objects.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Annotations*, on the other hand, provide a storage mechanism that resembles
    labels: key/value pairs designed to hold nonidentifying information that tools
    and libraries can leverage. Unlike labels, annotations are not meant for querying,
    filtering, or otherwise differentiating Pods from each other.'
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Labels provide identifying metadata for objects. These are fundamental qualities
    of the object that will be used for grouping, viewing, and operating. The motivations
    for labels grew out of Google’s experience in running large and complex applications.
    A couple of lessons emerged from this experience:'
  prefs: []
  type: TYPE_NORMAL
- en: Production abhors a singleton. When deploying software, users often start with
    a single instance. However, as the application matures, these singletons often
    multiply and become sets of objects. With this in mind, Kubernetes uses labels
    to deal with sets of objects instead of single instances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any hierarchy imposed by the system will fall short for many users. In addition,
    user groupings and hierarchies change over time. For instance, a user may start
    out with the idea that all apps are made up of many services. However, over time,
    a service may be shared across multiple apps. Kubernetes labels are flexible enough
    to adapt to these situations and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See the great site reliability book [*Site Reliability Engineering*](http://shop.oreilly.com/product/0636920041528.do)
    by Betsy Beyer et al. (O’Reilly) for deeper background on how Google approaches
    production systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Labels have simple syntax. They are key/value pairs, where both the key and
    value are represented by strings. Label keys can be broken down into two parts:
    an optional prefix and a name, separated by a slash. The prefix, if specified,
    must be a DNS subdomain with a 253-character limit. The key name is required and
    have a maximum length of 63 characters. Names must also start and end with an
    alphanumeric character and permit the use of dashes (`-`), underscores (`_`),
    and dots (`.`) between characters.'
  prefs: []
  type: TYPE_NORMAL
- en: Label values are strings with a maximum length of 63 characters. The contents
    of the label values follow the same rules as label keys. [Table 6-1](#label_examples_table)
    shows some valid label keys and values.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Label examples
  prefs: []
  type: TYPE_NORMAL
- en: '| Key | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `acme.com/app-version` | `1.0.0` |'
  prefs: []
  type: TYPE_TB
- en: '| `appVersion` | `1.0.0` |'
  prefs: []
  type: TYPE_TB
- en: '| `app.version` | `1.0.0` |'
  prefs: []
  type: TYPE_TB
- en: '| `kubernetes.io/cluster-service` | `true` |'
  prefs: []
  type: TYPE_TB
- en: When domain names are used in labels and annotations, they are expected to be
    aligned to that particular entity in some way. For example, a project might define
    a canonical set of labels used to identify the various stages of application deployment
    such as staging, canary, and production. Or a cloud provider might define provider-specific
    annotations that extend Kubernetes objects to activate features specific to their
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we create a few deployments (a way to create an array of Pods) with some
    interesting labels. We’ll take two apps (called `alpaca` and `bandicoot`) and
    have two environments and two versions for each.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create the `alpaca-prod` deployment and set the `ver`, `app`, and `env`
    labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create the `alpaca-test` deployment and set the `ver`, `app`, and `env`
    labels with the appropriate values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, create two deployments for `bandicoot`. Here we name the environments
    `prod` and `staging`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you should have four deployments—`alpaca-prod`, `alpaca-test`,
    `bandicoot-prod`, and `bandicoot-staging`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We can visualize this as a Venn diagram based on the labels ([Figure 6-1](#fig0601)).
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/kur3_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Visualization of labels applied to our deployments
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Modifying Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also apply or update labels on objects after you create them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There is a caveat here. In this example, the `kubectl label` command will only
    change the label on the deployment itself; it won’t affect any objects that the
    deployment creates, such as ReplicaSets and Pods. To change those, you’ll need
    to change the template embedded in the deployment (see [Chapter 10](ch10.xhtml#deployments_chapter)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `-L` option to `kubectl get` to show a label value as
    a column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can remove a label by applying a dash-suffix:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Label Selectors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Label selectors are used to filter Kubernetes objects based on a set of labels.
    Selectors use a simple syntax for Boolean expressions. They are used both by end
    users (via tools like `kubectl`) and by different types of objects (such as how
    a ReplicaSet relates to its Pods).
  prefs: []
  type: TYPE_NORMAL
- en: Each deployment (via a ReplicaSet) creates a set of Pods using the labels specified
    in the template embedded in the deployment. This is configured by the `kubectl
    run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `kubectl get pods` command should return all the Pods currently
    running in the cluster. We should have a total of six `kuard` Pods across our
    three environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You may see a new label that you haven’t seen before: `pod-template-hash`.
    This label is applied by the deployment so it can keep track of which Pods were
    generated from which template versions. This allows the deployment to manage updates
    cleanly, as will be covered in depth in [Chapter 10](ch10.xhtml#deployments_chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to list only Pods that have the `ver` label set to `2`, we could
    use the `--selector` flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we specify two selectors separated by a comma, only the objects that satisfy
    both will be returned. This is a logical AND operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also ask if a label is one of a set of values. Here we ask for all Pods
    where the `app` label is set to `alpaca` or `bandicoot` (which will be all six
    Pods):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can ask if a label is set at all. Here we are asking for all of
    the deployments with the `canary` label set to anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: There are also “negative” versions of each of these, as shown in [Table 6-2](#selector-operators-table).
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2\. Selector operators
  prefs: []
  type: TYPE_NORMAL
- en: '| Operator | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `key=value` | `key` is set to `value` |'
  prefs: []
  type: TYPE_TB
- en: '| `key!=value` | `key` is not set to `value` |'
  prefs: []
  type: TYPE_TB
- en: '| `key in (value1, value2)` | `key` is one of `value1` or `value2` |'
  prefs: []
  type: TYPE_TB
- en: '| `key notin (value1, value2)` | `key` is not one of `value1` or `value2` |'
  prefs: []
  type: TYPE_TB
- en: '| `key` | `key` is set |'
  prefs: []
  type: TYPE_TB
- en: '| `!key` | `key` is not set |'
  prefs: []
  type: TYPE_TB
- en: 'For example, asking if a key, in this case `canary`, is not set can look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine positive and negative selectors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Label Selectors in API Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Kubernetes object uses a label selector to refer to a set of other Kubernetes
    objects. Instead of a simple string as described in the previous section, we use
    a parsed structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'For historical reasons (Kubernetes doesn’t break API compatibility!), there
    are two forms. Most objects support a newer, more powerful set of selector operators.
    A selector of `app=alpaca,ver in (1, 2)` would be converted to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This example uses compact YAML syntax. This is an item in a list (`matchExpressions`)
    that is a map with three entries. The last entry (`values`) has a value that is
    a list with two items. All of the terms are evaluated as a logical AND. The only
    way to represent the `!=` operator is to convert it to a `NotIn` expression with
    a single value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The older form of specifying selectors (used in `ReplicationController`s and
    services) only supports the `=` operator. The `=` operator selects target objects
    where its set of key/value pairs all match the object. The selector `app=alpaca,ver=1`
    would be represented like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Labels in the Kubernetes Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to enabling users to organize their infrastructure, labels play
    a critical role in linking various related Kubernetes objects. Kubernetes is a
    purposefully decoupled system. There is no hierarchy and all components operate
    independently. However, in many cases, objects need to relate to one another,
    and these relationships are defined by labels and label selectors.
  prefs: []
  type: TYPE_NORMAL
- en: For example, ReplicaSets, which create and maintain multiple replicas of a Pod,
    find the Pods that they are managing via a selector. Likewise, a service load
    balancer finds the Pods to which it should bring traffic via a selector query.
    When a Pod is created, it can use a node selector to identify a particular set
    of nodes onto which it can be scheduled. When people want to restrict network
    traffic in their cluster, they use Network Policy in conjunction with specific
    labels to identify Pods that should or should not be allowed to communicate with
    each other.
  prefs: []
  type: TYPE_NORMAL
- en: Labels are a powerful and ubiquitous glue that holds a Kubernetes application
    together. Though your application will likely start out with a simple set of labels
    and queries, you should expect it to grow in size and sophistication with time.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Annotations provide a place to store additional metadata for Kubernetes objects
    where the sole purpose of the metadata is assisting tools and libraries. They
    are a way for other programs driving Kubernetes via an API to store some opaque
    data with an object. Annotations can be used for the tool itself or to pass configuration
    information between external systems.
  prefs: []
  type: TYPE_NORMAL
- en: While labels are used to identify and group objects, annotations are used to
    provide extra information about where an object came from, how to use it, or policy
    around that object. There is overlap, and it is a matter of taste as to when to
    use an annotation or a label. When in doubt, add information to an object as an
    annotation and promote it to a label if you find yourself wanting to use it in
    a selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotations are used to:'
  prefs: []
  type: TYPE_NORMAL
- en: Keep track of a “reason” for the latest update to an object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate a specialized scheduling policy to a specialized scheduler.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend data about the last tool to update the resource and how it was updated
    (used for detecting changes by other tools and doing a smart merge).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach build, release, or image information that isn’t appropriate for labels
    (may include a Git hash, timestamp, pull request number, etc.).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable the Deployment object (see [Chapter 10](ch10.xhtml#deployments_chapter))
    to keep track of ReplicaSets that it is managing for rollouts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide extra data to enhance the visual quality or usability of a UI. For example,
    objects could include a link to an icon (or a base64-encoded version of an icon).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prototype alpha functionality in Kubernetes (instead of creating a first-class
    API field, the parameters for that functionality are encoded in an annotation).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annotations are used in various places in Kubernetes, with the primary use case
    being rolling deployments. During rolling deployments, annotations are used to
    track rollout status and provide the necessary information required to roll back
    a deployment to a previous state.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using the Kubernetes API server as a general-purpose database. Annotations
    are good for small bits of data that are highly associated with a specific resource.
    If you want to store data in Kubernetes but you don’t have an obvious object to
    associate it with, consider storing that data in some other, more appropriate
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Annotation keys use the same format as label keys. However, because they are
    often used to communicate information between tools, the “namespace” part of the
    key is more important. Example keys include `deployment.kubernetes.io/revision`
    or `kubernetes.io/change-cause`.
  prefs: []
  type: TYPE_NORMAL
- en: The value component of an annotation is a free-form string field. While this
    allows maximum flexibility as users can store arbitrary data, because this is
    arbitrary text, there is no validation of any format. For example, it is not uncommon
    for a JSON document to be encoded as a string and stored in an annotation. It
    is important to note that the Kubernetes server has no knowledge of the required
    format of annotation values. If annotations are used to pass or store data, there
    is no guarantee the data is valid. This can make tracking down errors more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'Annotations are defined in the common `metadata` section in every Kubernetes
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Annotations are very convenient and provide powerful loose coupling, but use
    them judiciously to avoid an untyped mess of data.
  prefs: []
  type: TYPE_NORMAL
- en: Cleanup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is easy to clean up all of the deployments that we started in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you want to be more selective, you can use the `--selector` flag to choose
    which deployments to delete.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Labels are used to identify and optionally group objects in a Kubernetes cluster.
    They are also used in selector queries to provide flexible runtime grouping of
    objects, such as Pods.
  prefs: []
  type: TYPE_NORMAL
- en: Annotations provide object-scoped key/value metadata storage used by automation
    tooling and client libraries. They can also be used to hold configuration data
    for external tools such as third-party schedulers and monitoring tools.
  prefs: []
  type: TYPE_NORMAL
- en: Labels and annotations are vital to understanding how key components in a Kubernetes
    cluster work together to ensure the desired cluster state. Using them properly
    unlocks the true power of Kubernetes’s flexibility and provides a starting point
    for building automation tools and deployment workflows.
  prefs: []
  type: TYPE_NORMAL
