- en: Chapter 5\. Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces MongoDB indexes. Indexes enable you to perform queries
    efficiently. They’re an important part of application development and are even
    required for certain types of queries. In this chapter we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: What indexes are and why you’d want to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to choose which fields to index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to enforce and evaluate index usage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administrative details on creating and removing indexes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you’ll see, choosing the right indexes for your collections is critical to
    performance.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A database index is similar to a book’s index. Instead of looking through the
    whole book, the database takes a shortcut and just looks at an ordered list with
    references to the content. This allows MongoDB to query orders of magnitude faster.
  prefs: []
  type: TYPE_NORMAL
- en: 'A query that does not use an index is called a *collection scan*, which means
    that the server has to “look through the whole book” to find a query’s results.
    This process is basically what you’d do if you were looking for information in
    a book without an index: you’d start at page 1 and read through the whole thing.
    In general, you want to avoid making the server do collection scans because the
    process is very slow for large collections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. To get started, we’ll create a collection with 1
    million documents in it (or 10 million or 100 million, if you have the patience):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Then we’ll look at the differences in performance for queries on this collection,
    first without an index and then with an index.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we do a query on this collection, we can use the `explain` command to see
    what MongoDB is doing when it executes the query. The preferred way to use the
    `explain` command is through the cursor helper method that wraps this command.
    The `explain` cursor method provides information on the execution of a variety
    of CRUD operations. This method may be run in several verbosity modes. We’ll look
    at `executionStats` mode since this helps us understand the effect of using an
    index to satisfy queries. Try querying on a specific username to see an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[“explain Output”](#sect1_d1e5527) will explain the output fields; for now
    you can ignore almost all of them. For this example, we want to look at the nested
    document that is the value of the `"executionStats"` field. In this document,
    `"totalDocsExamined"` is the number of documents MongoDB looked at while trying
    to satisfy the query, which, as you can see, is every document in the collection.
    That is, MongoDB had to look through every field in every document. This took
    nearly half a second to accomplish on my laptop (the `"executionTimeMillis"` field
    shows the number of milliseconds it took to execute the query).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `"nReturned"` field of the `"executionStats"` document shows the number
    of results returned: `1`, which makes sense because there is only one user with
    the username `"user101"`. Note that MongoDB had to look through every document
    in the collection for matches because it did not know that usernames are unique.'
  prefs: []
  type: TYPE_NORMAL
- en: To enable MongoDB to respond to queries efficiently, all query patterns in your
    application should be supported by an index. By query patterns, we simply mean
    the different types of questions your application asks of the database. In this
    example, we queried the *users* collection by username. That is an example of
    a specific query pattern. In many applications, a single index will support several
    query patterns. We will discuss tailoring indexes to query patterns in a later
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s try creating an index on the `"username"` field. To create an index,
    we’ll use the `createIndex` collection method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating the index should take no longer than a few seconds, unless you made
    your collection especially large. If the `createIndex` call does not return after
    a few seconds, run `db.currentOp()` (in a different shell) or check your *mongod*’s
    log to see the index build’s progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the index build is complete, try repeating the original query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This `explain` output is more complex, but for now you can continue to ignore
    all the fields other than `"nReturned"`, `"totalDocsExamined"`, and `"executionTimeMillis"`
    in the `"executionStats"` nested document. As you can see, the query is now almost
    instantaneous and, even better, has a similar runtime when querying, for example,
    for any username:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An index can make a dramatic difference in query times. However, indexes have
    their price: write operations (inserts, updates, and deletes) that modify an indexed
    field will take longer. This is because in addition to updating the document,
    MongoDB has to update indexes when your data changes. Typically, the tradeoff
    is worth it. The tricky part becomes figuring out which fields to index.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: MongoDB’s indexes work almost identically to typical relational database indexes,
    so if you are familiar with those, you can just skim this section for syntax specifics.
  prefs: []
  type: TYPE_NORMAL
- en: To choose which fields to create indexes for, look through your frequent queries
    and queries that need to be fast and try to find a common set of keys from those.
    For instance, in the preceding example, we were querying on `"username"`. If that
    were a particularly common query or were becoming a bottleneck, indexing `"username"`
    would be a good choice. However, if this were an unusual query or one that’s only
    done by administrators who don’t care how long it takes, it would not be a good
    choice for indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Compound Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of an index is to make your queries as efficient as possible. For
    many query patterns it is necessary to build indexes based on two or more keys.
    For example, an index keeps all of its values in a sorted order, so it makes sorting
    documents by the indexed key much faster. However, an index can only help with
    sorting if it is a prefix of the sort. For example, the index on `"username"`
    wouldn’t help much for this sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This sorts by `"age"` and then `"username"`, so a strict sorting by `"username"`
    isn’t terribly helpful. To optimize this sort, you could make an index on `"age"`
    *and* `"username"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is called a *compound index* and is useful if your query has multiple sort
    directions or multiple keys in the criteria. A compound index is an index on more
    than one field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a *users* collection that looks something like this, if we
    run a query with no sorting (called natural order):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we index this collection by `{"age" : 1, "username" : 1}`, the index will
    have a form we can represent as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each index entry contains an age and a username and points to a record identifier.
    A record identifier is used internally by the storage engine to locate the data
    for a document. Note that `"age"` fields are ordered to be strictly ascending
    and, within each age, usernames are also in ascending order. In this example dataset,
    each age has approximately 8,000 usernames associated with it. Here we’ve included
    only those necessary to convey the general idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way MongoDB uses this index depends on the type of query you’re doing.
    These are the three most common ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.users.find({"age" : 21}).sort({"username" : -1})`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an equality query, which searches for a single value. There may be
    multiple documents with that value. Due to the second field in the index, the
    results are already in the correct order for the sort: MongoDB can start with
    the last match for `{"age" : 21}` and traverse the index in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This type of query is very efficient: MongoDB can jump directly to the correct
    age and doesn’t need to sort the results because traversing the index returns
    the data in the correct order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that sort direction doesn’t matter: MongoDB can traverse the index in
    either direction.'
  prefs: []
  type: TYPE_NORMAL
- en: '`db.users.find({"age" : {"$gte" : 21, "$lte" : 30}})`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a range query, which looks for documents matching multiple values (in
    this case, all ages between 21 and 30). MongoDB will use the first key in the
    index, `"age"`, to return the matching documents, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In general, if MongoDB uses an index for a query it will return the resulting
    documents in index order.
  prefs: []
  type: TYPE_NORMAL
- en: '`db.users.find({"age" : {"$gte" : 21, "$lte" : 30}}).sort({"username" : 1})`'
  prefs: []
  type: TYPE_NORMAL
- en: This is a multivalue query, like the previous one, but this time it has a sort.
    As before, MongoDB will use the index to match the criteria. However, the index
    doesn’t return the usernames in sorted order and the query requested that the
    results be sorted by username. This means MongoDB will need to sort the results
    in memory before returning them, rather than simply traversing an index in which
    the documents are already sorted in the desired order. This type of query is usually
    less efficient as a consequence.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the speed depends on how many results match your criteria: if your
    result set is only a couple of documents MongoDB won’t have much work to do to
    sort them, but if there are more results it will be slower or may not work at
    all. If you have more than 32 MB of results MongoDB will just error out, refusing
    to sort that much data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you need to avoid this error, then you must create an index supporting the
    sort operation ([*https://docs.mongodb.com/manual/reference/method/cursor.sort/index.html#sort-index-use*](https://docs.mongodb.com/manual/reference/method/cursor.sort/index.html#sort-index-use))
    or use `sort` in conjunction with `limit` to reduce the results to below 32 MB.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other index you can use in the last example is the same keys in reverse
    order: `{"username" : 1, "age" : 1}`. MongoDB will then traverse all the index
    entries, but in the order you want them back in. It will pick out the matching
    documents using the `"age"` part of the index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is good in that it does not require any giant in-memory sorts. However,
    it does have to scan the entire index to find all the matches. Putting the sort
    key first is generally a good strategy when designing compound indexes. As we’ll
    see shortly, this is one of several best practices when considering how to construct
    compound indexes with consideration for equality queries, multivalue queries,
    and sorting.
  prefs: []
  type: TYPE_NORMAL
- en: How MongoDB Selects an Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let’s take a look at how MongoDB chooses an index to satisfy a query. Let’s
    imagine we have five indexes. When a query comes in, MongoDB looks at the query’s
    *shape*. The shape has to do with what fields are being searched on and additional
    information, such as whether or not there is a sort. Based on that information,
    the system identifies a set of candidate indexes that it might be able to use
    in satisfying the query.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume we have a query come in, and three of our five indexes are identified
    as candidates for this query. MongoDB will then create three query plans, one
    for each of these indexes, and run the query in three parallel threads, each using
    a different index. The objective here is to see which one is able to return results
    the fastest.
  prefs: []
  type: TYPE_NORMAL
- en: Visually, we can think of this as a race, as pictured in [Figure 5-1](#fig0501).
    The idea here is that the first query plan to reach a goal state is the winner.
    But more importantly, going forward it will be selected as the index to use for
    queries that have that same query shape. The plans are raced against each other
    for a period (referred to as the trial period), after which the results of each
    race are used to calculate the overall winning plan.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/mdb3_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. How the MongoDB Query Planner selects an index, visualized as a
    race
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To win the race, a query thread must be the first to either return all the query
    results or return a trial number of results in sort order. The sort order portion
    of this is important given how expensive it is to perform in-memory sorts.
  prefs: []
  type: TYPE_NORMAL
- en: The real value of racing several query plans against one another is that for
    subsequent queries that have the same query shape, the MongoDB server will know
    which index to select. The server maintains a cache of query plans. A winning
    plan is stored in the cache for future use for queries of that shape. Over time,
    as a collection changes and as the indexes change, eventually a query plan might
    be evicted from the cache and MongoDB will, again, experiment with possible query
    plans to find the one that works best for the current collection and set of indexes.
    Other events that will lead to plans being evicted from the cache are if we rebuild
    a given index, add or drop an index, or explicitly clear the plan cache. Finally,
    the query plan cache does not survive a restart of a *mongod* process.
  prefs: []
  type: TYPE_NORMAL
- en: Using Compound Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous sections, we’ve been using compound indexes, which are indexes
    with more than one key in them. Compound indexes are a little more complicated
    to think about than single-key indexes, but they are very powerful. This section
    covers them in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will walk through an example that gives you an idea of the type of
    thinking you need to do when you are designing compound indexes. The goal is for
    our read and write operations to be as efficient as possible—but as with so many
    things, this requires some upfront thinking and some experimentation.
  prefs: []
  type: TYPE_NORMAL
- en: To be sure we get the right indexes in place, it is necessary to test our indexes
    under some real-world workloads and make adjustments from there. However, there
    are some best practices we can apply as we design our indexes.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to consider the selectivity of the index. We are interested in
    the degree to which, for a given query pattern, the index is going to minimize
    the number of records scanned. We need to consider selectivity in light of all
    operations necessary to satisfy a query, and sometimes make tradeoffs. We will
    need to consider, for example, how sorts are handled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at an example. For this, we will use a student dataset containing
    approximately one million records. Documents in this dataset resemble the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will begin with two indexes and look at how MongoDB uses these indexes (or
    doesn’t) in order to satisfy queries. These two indexes are created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In working with this dataset, we will consider the following query, because
    it illustrates several of the issues that we have to think about in designing
    our indexes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this query we are requesting all records with an ID greater than
    500,000, so about half of the records. We are also constraining the search to
    records for the class with ID `54`. There are about 500 classes represented in
    this dataset. Finally, we are sorting in ascending order based on `"student_id"`.
    Note that this is the same field on which we are doing a multivalue query. Throughout
    this example we will look at the execution stats that the `explain` method provides
    to illustrate how MongoDB will handle this query.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we run the query, the output of the `explain` method tells us how MongoDB
    used indexes to satisfy it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As with most data output from MongoDB, the `explain` output is JSON. Let’s look
    first at the bottom half of this output, which is almost entirely the execution
    stats. The `"executionStats"` field contains statistics that describe the completed
    query execution for the winning query plan. We will look at query plans and the
    query plan output from `explain` a little later.
  prefs: []
  type: TYPE_NORMAL
- en: Within `"executionStats"`, first we will look at `"totalKeysExamined"`. This
    is how many keys within the index MongoDB walked through in order to generate
    the result set. We can compare `"totalKeysExamined"` to `"nReturned"` to get a
    sense for how much of the index MongoDB had to traverse in order to find just
    the documents matching the query. In this case, 850,477 index keys were examined
    in order to locate the 9,903 matching documents.
  prefs: []
  type: TYPE_NORMAL
- en: This means that the index used in order to satisfy this query was not very selective.
    This is further emphasized by the fact that this query took more than 4.3 seconds
    to run, as indicated by the `"executionTimeMillis"` field. Selectivity is one
    of our key objectives when we are designing an index, so let’s figure out where
    we went wrong with the existing indexes for this query.
  prefs: []
  type: TYPE_NORMAL
- en: Near the top of the `explain` output is the winning query plan (see the field
    `"winningPlan"`). A query plan describes the steps MongoDB used to satisfy a query.
    This is, in JSON form, the specific outcome of racing a couple of different query
    plans against one another. In particular, we are interested in what indexes were
    used and whether MongoDB had to do an in-memory sort. Below the winning plan are
    the rejected plans. We’ll look at both.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the winning plan used a compound index based on `"student_id"`
    and `"class_id"`. This is evident in the following portion of the `explain` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `explain` output presents the query plan as a tree of stages. A stage can
    have one or more input stages, depending on how many child stages it has. An input
    stage provides the documents or index keys to its parent. In this case, there
    was one input stage, an index scan, and that scan provided the record IDs for
    documents matching the query to its parent, the `"FETCH"` stage. The `"FETCH"`
    stage, then, will retrieve the documents themselves and return them in batches
    as the client requests them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The losing query plan—there is only one—would have used an index based on `"class_id"`
    but then it would have had to do an in-memory sort. That is what the following
    portion of this particular query plan means. When you see a `"SORT"` stage in
    a query plan, it means that MongoDB would have been unable to sort the result
    set in the database using an index and instead would have had to do an in-memory
    sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For this query, the index that won is one that was able to return sorted output.
    To win it only had to reach a trial number of sorted result documents. For the
    other plan to win, that query thread would have had to return the entire result
    set (nearly 10,000 documents) first, since those would then need to be sorted
    in memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'The issue here is one of selectivity. The multivalue query we are running specifies
    a broad range of `"student_id"` values, because it’s requesting records for which
    the `"student_id"` is greater than 500,000\. That’s about half the records in
    our collection. Here again, for convenience, is the query we are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, I’m sure you can see where we are headed here. This query contains both
    a multivalue portion and an equality portion. The equality portion is that we
    are asking for all records in which `"class_id"` is equal to `54`. There are only
    about 500 classes in this dataset, and while there are a large number of students
    with grades in those classes, `"class_id"` would serve as a much more selective
    basis on which to execute this query. It is this value that constrains our result
    set to just under 10,000 records rather than the approximately 850,000 that were
    identified by the multivalue portion of this query.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, it would be better, given the indexes we have, if we were to
    use the index based on just `"class_id"`—the one in the losing query plan. MongoDB
    provides two ways of forcing the database to use a particular index. However,
    I cannot stress strongly enough that you should use these ways of overriding what
    would be the outcome of the query planner with caution. These are not techniques
    you should use in a production deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The cursor `hint` method enables us to specify a particular index to use, either
    by specifying its shape or its name. An index filter uses a query shape, which
    is a combination of a query, sort, and projection specification. The `planCacheSetFilter`
    function can be used with an index filter to limit the query optimizer to only
    considering indexes specified in the index filter. If an index filter exists for
    a query shape, MongoDB will ignore `hint`. Index filters only persist for the
    duration of the *mongod* server process; they do not persist after shutdown.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we change our query slightly to use `hint`, as in the following example,
    the `explain` output will be quite different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output shows that we are now down from having scanned roughly
    850,000 index keys to just about 20,000 in order to get to our result set of just
    under 10,000\. In addition, the execution time is only 272 milliseconds rather
    than the 4.3 seconds we saw with the query plan using the other index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: However, what we really want to see is `"nReturned"` very close to `"totalKeysExamined"`.
    In addition, we would like avoid having to use `hint` in order to more efficiently
    execute this query. The way to address both of these concerns is to design a better
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better index for the query pattern in question is one based on `"class_id"`
    and `"student_id"`, in that order. With `"class_id"` as the prefix, we are using
    the equality filter in our query to restrict the keys considered within the index.
    This is the most selective component of our query, and therefore effectively constrains
    the number of keys MongoDB needs to consider to satisfy this query. We can build
    this index as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: While not true for absolutely every dataset, in general you should design compound
    indexes such that fields on which you will be using equality filters come before
    those on which your application will use multivalue filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'With our new index in place, if we rerun our query, this time no hinting is
    required and we can see from the `"executionStats"` field in the `explain` output
    that we have a fast query (37 milliseconds) for which the number of results returned
    (`"nReturned"`) is equal to the number of keys scanned in the index (`"totalKeysExamined"`).
    We can also see that this is due to the fact that the `"executionStages"`, which
    reflect the winning query plan, contain an index scan that makes use of the new
    index we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Considering what we know about how indexes are built, you can probably see
    why this works. The `[class_id, student_id]` index is composed of key pairs such
    as the following. Since the student IDs are ordered within these key pairs, in
    order to satisfy our sort MongoDB simply needs to walk all the key pairs beginning
    with the first one for `class_id` `54`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In considering the design of a compound index, we need to know how to address
    equality filters, multivalue filters, and sort components of common query patterns
    that will make use of the index. It is necessary to consider these three factors
    for all compound indexes, and if you design your index to balance these concerns
    correctly, you will get the best performance out of MongoDB for your queries.
    While we’ve addressed all three factors for our example query with the `[class_id,
    student_id]` index, the query as written represents a special case of the compound
    index problem because we’re sorting on one of the fields we are also filtering
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the special-case nature of this example, let’s sort on final grade
    instead, changing our query to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this query and look at the `explain` output, we see that we’re now
    doing an in-memory sort. While the query is still fast at only 136 milliseconds,
    it is an order of magnitude slower than when sorting on `"student_id"`, because
    we are now doing an in-memory sort. We can see that we are doing an in-memory
    sort because the winning query plan now contains a `"SORT"` stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If we can avoid an in-memory sort with a better index design, we should. This
    will allow us to scale more easily with respect to dataset size and system load.
  prefs: []
  type: TYPE_NORMAL
- en: But to do that, we are going to have to make a tradeoff. This is commonly the
    case when designing compound indexes.
  prefs: []
  type: TYPE_NORMAL
- en: As is so often necessary for compound indexes, in order to avoid an in-memory
    sort we need to examine more keys than the number of documents we return. To use
    the index to sort, MongoDB needs to be able to walk the index keys in order. This
    means that we need to include the sort field among the compound index keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'The keys in our new compound index should be ordered as follows: `[class_id,
    final_grade, student_id]`. Note that we include the sort component immediately
    after the equality filter, but before the multivalue filter. This index will very
    selectively narrow the set of keys considered for this query. Then, by walking
    the key triplets matching the equality filter in this index, MongoDB can identify
    the records that match the multivalue filter and those records will be ordered
    properly by final grade in ascending order.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This compound index forces MongoDB to examine keys for more documents than
    will end up being in our result set. However, by using the index to ensure we
    have sorted documents, we save execution time. We can construct the new index
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we once again issue our query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'we get the following `"executionStats"` in the output from `explain`. This
    will vary depending on your hardware and what else is going on in the system,
    but you can see that the winning plan no longer includes an in-memory sort. It
    is instead using the index we just created to satisfy the query, including the
    sort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This section has provided a concrete example of some best practices for designing
    compound indexes. While these guidelines do not hold for every situation, they
    do for most and should be the first ideas you consider when constructing a compound
    index.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap, when designing a compound index:'
  prefs: []
  type: TYPE_NORMAL
- en: Keys for equality filters should appear first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys used for sorting should appear before multivalue fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keys for multivalue filters should appear last.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design your compound index using these guidelines and then test it under real-world
    workloads for the range of query patterns your index is designed to support.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing key directions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, all of our index entries have been sorted in ascending, or least-to-greatest,
    order. However, if you need to sort on two (or more) criteria, you may need to
    have index keys go in different directions. For example, going back to our earlier
    example with the *users* collection, suppose we wanted to sort the collection
    by age from youngest to oldest and by name from Z−A. Our previous indexes would
    not be very efficient for this problem: within each age group users were sorted
    by username in ascending order (A−Z, not Z−A). The compound indexes we’ve been
    using so far do not hold the values in any useful order for getting `"age"` ascending
    and `"username"` descending.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To optimize compound sorts in different directions, we need to use an index
    with matching directions. In this example, we could use `{"age" : 1, "username"
    : -1}`, which would organize the data as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The ages are arranged from youngest to oldest, and within each age, the usernames
    are sorted from Z to A (or rather 9 to 0, given our usernames).
  prefs: []
  type: TYPE_NORMAL
- en: 'If our application also needed to optimize sorting by `{"age" : 1, "username"
    : 1}`, we would have to create a second index with those directions. To figure
    out which directions to use for an index, simply match the directions your sort
    is using. Note that inverse indexes (multiplying each direction by −1) are equivalent:
    `{"age" : 1, "username" : -1}` suits the same queries that `{"age" : -1, "username"
    : 1}` does.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Index direction only really matters when you’re sorting based on multiple criteria.
    If you’re only sorting by a single key, MongoDB can just as easily read the index
    in the opposite order. For example, if you had a sort on `{"age" : -1}` and an
    index on `{"age" : 1}`, MongoDB could optimize it just as well as if you had an
    index on `{"age" : -1}` (so don’t create both!). The direction only matters for
    multikey sorts.'
  prefs: []
  type: TYPE_NORMAL
- en: Using covered queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the preceding examples, the index was always used to find the correct document
    and then follow a pointer back to fetch the actual document. However, if your
    query is only looking for the fields that are included in the index, it does not
    need to fetch the document. When an index contains all the values requested by
    a query, the query is considered to be *covered*. Whenever practical, use covered
    queries in preference to going back to documents. You can make your working set
    much smaller that way.
  prefs: []
  type: TYPE_NORMAL
- en: To make sure a query can use the index only, you should use projections (which
    limit the fields returned to only those specified in your query; see [“Specifying
    Which Keys to Return”](ch04.xhtml#sect2_d1e3675)) to avoid returning the `"_id"`
    field (unless it is part of the index). You may also have to index fields that
    you aren’t querying on, so you should balance your need for faster queries with
    the overhead this will add on writes.
  prefs: []
  type: TYPE_NORMAL
- en: If you run `explain` on a covered query, the result has an `"IXSCAN"` stage
    that is *not* a descendant of a `"FETCH"` stage, and in the `"executionStats"`,
    the value of `"totalDocsExamined"` is `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compound indexes can do “double duty” and act like different indexes for different
    queries. If we have an index on `{"age" : 1, "username" : 1}`, the `"age"` field
    is sorted identically to the way it would be if we had an index on just `{"age"
    : 1}`. Thus, the compound index can be used the way an index on `{"age" : 1}`
    by itself would be.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be generalized to as many keys as necessary: if an index has *N* keys,
    you get a “free” index on any prefix of those keys. For example, if we have an
    index that looks like `{"a": 1, "b": 1, "c": 1, ..., "z": 1}`, we effectively
    have indexes on `{"a": 1}`, `{"a": 1, "b" : 1}`, `{"a": 1, "b": 1, "c": 1}`, and
    so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that this doesn’t hold for *any* subset of keys: queries that would use
    the index `{"b": 1}` or `{"a": 1, "c": 1}` (for example) will not be optimized.
    Only queries that can use a prefix of the index can take advantage of it.'
  prefs: []
  type: TYPE_NORMAL
- en: How $ Operators Use Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some queries can use indexes more efficiently than others; some queries cannot
    use indexes at all. This section covers how various query operators are handled
    by MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Inefficient operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In general, negation is inefficient. `"$ne"` queries can use an index, but
    not very well. They must look at all the index entries other than the one specified
    by `"$ne"`, so they basically have to scan the entire index. For example, for
    a collection with an index on the field named `"i"`, here are the index ranges
    traversed for such a query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This query looks at all index entries less than `3` and all index entries greater
    than `3`. This can be efficient if a large swath of your collection is `3`, but
    otherwise it must check almost everything.
  prefs: []
  type: TYPE_NORMAL
- en: '`"$not"` can sometimes use an index but often does not know how. It can reverse
    basic ranges (``{"*`key`*" : {"$lt" : 7}}`` becomes ``{"*`key`*" : {"$gte" : 7}}``)
    and regular expressions. However, most other queries with `"$not"` will fall back
    to doing a table scan. `"$nin"` always uses a table scan.'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to perform one of these types of queries quickly, figure out if
    there’s another clause that you could add to the query that could use an index
    to filter the result set down to a small number of documents before MongoDB attempts
    to do nonindexed matching.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Compound indexes can help MongoDB efficiently execute queries with multiple
    clauses. When designing an index with multiple fields, put fields that will be
    used in exact matches first (e.g., `"x" : 1`) and ranges last (e.g., `"y": {"$gt"
    : 3, "$lt" : 5}`). This allows the query to find an exact value for the first
    index key and then search within that for a second index range. For example, suppose
    we were querying for a specific age and a range of usernames using an `{"age"
    : 1, "username" : 1}` index. We would get fairly exact index bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The query goes directly to `"age" : 47` and then searches within that for usernames
    between `"user5"` and `"user8"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, suppose we use an index on `{"username" : 1, "age" : 1}`. This
    changes the query plan, as the query must look at all users between `"user5"`
    and `"user8"` and pick out the ones with `"age" : 47`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This forces MongoDB to scan 100 times the number of index entries as using the
    previous index would. Using two ranges in a query basically always forces this
    less-efficient query plan.
  prefs: []
  type: TYPE_NORMAL
- en: OR queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As of this writing, MongoDB can only use one index per query. That is, if you
    create one index on `{"x" : 1}` and another index on `{"y" : 1}` and then do a
    query on `{"x" : 123, "y" : 456}`, MongoDB will use one of the indexes you created,
    not both. The only exception to this rule is `"$or"`. `"$or"` can use one index
    per `"$or"` clause, as `"$or"` performs two queries and then merges the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this `explain` required two separate queries on the two indexes
    (as indicated by the two `"IXSCAN"` stages). In general, doing two queries and
    merging the results is much less efficient than doing a single query; thus, whenever
    possible, prefer `"$in"` to `"$or"`.
  prefs: []
  type: TYPE_NORMAL
- en: If you must use an `"$or"`, keep in mind that MongoDB needs to look through
    the results of both queries and remove any duplicates (documents that matched
    more than one `"$or"` clause).
  prefs: []
  type: TYPE_NORMAL
- en: 'When running `"$in"` queries there is no way, other than sorting, to control
    the order of documents returned. For example, `{"x" : {"$in" : [1, 2, 3]}}` will
    return documents in the same order as `{"x" : {"$in" : [3, 2, 1]}}`.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing Objects and Arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MongoDB allows you to reach into your documents and create indexes on nested
    fields and arrays. Embedded object and array fields can be combined with top-level
    fields in compound indexes, and although they are special in some ways, they mostly
    behave the way “normal” index fields behave.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing embedded docs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Indexes can be created on keys in embedded documents in the same way that they
    are created on normal keys. If we had a collection where each document represented
    a user, we might have an embedded document that described each user’s location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We could put an index on one of the subfields of `"loc"`, say `"loc.city"`,
    to speed up queries using that field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'You can go as deep as you’d like with these: you could index `"x.y.z.w.a.b.c"`
    (and so on) if you wanted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that indexing the embedded document itself (`"loc"`) has very different
    behavior than indexing a field of that embedded document (`"loc.city"`). Indexing
    the entire subdocument will only help queries that are querying for the entire
    subdocument. The query optimizer could only use an index on `"loc"` for queries
    that described the whole subdocument with fields in the correct order (e.g., `db.users.find({"loc"
    : {"ip" : "123.456.789.000", "city" : "Shelbyville", "state" : "NY"}}})`). It
    could not use the index for queries that looked like `db.users.find({"loc.city"
    : "Shelbyville"})`.'
  prefs: []
  type: TYPE_NORMAL
- en: Indexing arrays
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also index arrays, which allows you to use the index to search for specific
    array elements efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a collection of blog posts where each document is a post. Each
    post has a `"comments"` field, which is an array of `"comment"` subdocuments.
    If we wanted to be able to find the most recently commented-on blog posts, we
    could create an index on the `"date"` key in the array of embedded `"comments"`
    documents of our blog post collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Indexing an array creates an index entry for each element of the array, so
    if a post had 20 comments, it would have 20 index entries. This makes array indexes
    more expensive than single-value ones: for a single insert, update, or remove,
    every array entry might have to be updated (potentially thousands of index entries).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike the `"loc"` example in the previous section, you cannot index an entire
    array as a single entity: indexing an array field indexes each element of the
    array, not the array itself.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Indexes on array elements do not keep any notion of position: you cannot use
    an index for a query that is looking for a specific array element, such as `"comments.4"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can, incidentally, index a specific array entry, as in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: However, this index would only be useful for queries for exactly the 11th array
    element (arrays start at index 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'Only one field in an index entry can be from an array. This is to avoid the
    explosive number of index entries you’d get from multiple multikey indexes: every
    possible pair of elements would have to be indexed, causing indexes to be *n*m*
    entries per document. For example, suppose we had an index on `{"x" : 1, "y" :
    1}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Were MongoDB to index the final example, it would have to create index entries
    for `{"x" : 1, "y" : 4}`, `{"x" : 1, "y" : 5}`, `{"x" : 1, "y" : 6}`, `{"x" :
    2, "y" : 4}`, `{"x" : 2, "y" : 5}`, `{"x" : 2, "y" : 6}`, `{"x" : 3, "y" : 4}`,
    `{"x" : 3, "y" : 5}`, and `{"x" : 3, "y" : 6}` (and these arrays are only three
    elements long).'
  prefs: []
  type: TYPE_NORMAL
- en: Multikey index implications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If any document has an array field for the indexed key, the index immediately
    is flagged as a multikey index. You can see whether an index is multikey from
    `explain`’s output: if a multikey index was used, the `"isMultikey"` field will
    be `true`. Once an index has been flagged as multikey, it can never be un-multikeyed,
    even if all of the documents containing arrays in that field are removed. The
    only way to un-multikey it is to drop and recreate it.'
  prefs: []
  type: TYPE_NORMAL
- en: Multikey indexes may be a bit slower than non-multikey indexes. Many index entries
    can point at a single document, so MongoDB may need to do some deduplication before
    returning results.
  prefs: []
  type: TYPE_NORMAL
- en: Index Cardinality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Cardinality* refers to how many distinct values there are for a field in a
    collection. Some fields, such as `"gender"` or `"newsletter opt-out"`, might only
    have two possible values, which is considered a very low cardinality. Others,
    such as `"username"` or `"email"`, might have a unique value for every document
    in the collection, which is high cardinality. Still others fall somewhere in between,
    such as `"age"` or `"zip code"`.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, the greater the cardinality of a field, the more helpful an index
    on that field can be. This is because the index can quickly narrow the search
    space to a much smaller result set. For a low-cardinality field, an index generally
    cannot eliminate as many possible matches.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we had an index on `"gender"` and were looking for women
    named Susan. We could only narrow down the result space by approximately 50% before
    referring to individual documents to look up `"name"`. Conversely, if we indexed
    by `"name"`, we could immediately narrow down our result set to the tiny fraction
    of users named Susan, and then we could refer to those documents to check the
    gender.
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, try to create indexes on high-cardinality keys or at least
    put high-cardinality keys first in compound indexes (before low-cardinality keys).
  prefs: []
  type: TYPE_NORMAL
- en: explain Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve seen, `explain` gives you lots of information about your queries.
    It’s one of the most important diagnostic tools there is for slow queries. You
    can find out which indexes are being used and how by looking at a query’s `"explain"`
    output. For any query, you can add a call to `explain` at the end (the way you
    would add a `sort` or `limit`, but `explain` must be the last call).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of `explain` output that you’ll see most commonly: for
    indexed and nonindexed queries. Special index types may create slightly different
    query plans, but most fields should be similar. Also, sharding returns a conglomerate
    of `explain`s (as covered in [Chapter 14](ch14.xhtml#chapter_d1e10482)), as it
    runs the query on multiple servers.'
  prefs: []
  type: TYPE_NORMAL
- en: The most basic type of `explain` is on a query that doesn’t use an index. You
    can tell that a query doesn’t use an index because it uses a `"COLLSCAN"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of an `explain` on a query that uses an index varies, but in the
    simplest case it looks something like this if we add an index on `imdb.rating`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This output first tells you what index was used: `imdb.rating`. Next is how
    many documents were actually returned as a result: `"nReturned"`. Note that this
    doesn’t necessarily reflect how much work MongoDB did to answer the query (i.e.,
    how many indexes and documents it had to search). `"totalKeysExamined"` reports
    the number of index entries scanned while `"totalDocsExamined"` indicates how
    many documents were scanned. The number of documents scanned is reflected in `"nscannedObjects"`.'
  prefs: []
  type: TYPE_NORMAL
- en: The output also shows that there were no `rejectedPlans` and that it used a
    bounded search on the index within the value 42.0.
  prefs: []
  type: TYPE_NORMAL
- en: '`"executionTimeMillis"` reports how fast the query was executed, from the server
    receiving the request to when it sent a response. However, it may not always be
    the number you are looking for. If MongoDB tried multiple query plans, `"executionTimeMillis"`
    will reflect how long it took all of them to run, not the one chosen as the best.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know the basics, here is a breakdown of some of the more important
    fields in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"isMultiKey" : false`'
  prefs: []
  type: TYPE_NORMAL
- en: If this query used a multikey index (see [“Indexing Objects and Arrays”](#sect2_d1e5358)).
  prefs: []
  type: TYPE_NORMAL
- en: '`"nReturned" : 8449`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of documents returned by the query.
  prefs: []
  type: TYPE_NORMAL
- en: '`"totalDocsExamined" : 8449`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of times MongoDB had to follow an index pointer to the actual document
    on disk. If the query contains criteria that are not part of the index or requests
    fields that aren’t contained in the index, MongoDB must look up the document each
    index entry points to.
  prefs: []
  type: TYPE_NORMAL
- en: '`"totalKeysExamined" : 8449`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of index entries looked at, if an index was used. If this was a table
    scan, it is the number of documents examined.
  prefs: []
  type: TYPE_NORMAL
- en: '`"stage" : "IXSCAN"`'
  prefs: []
  type: TYPE_NORMAL
- en: If MongoDB was able to fulfill this query using an index; if not `"COLSCAN"`
    would indicate it had to perform a collection scan to fulfill the query.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, MongoDB found all matching documents using the index, which
    we know because `"totalKeysExamined"` is the same as `"totalDocsExamined"`. However,
    the query was told to return every field in the matching documents and the index
    only contained the `"age"` and `"username"` fields.
  prefs: []
  type: TYPE_NORMAL
- en: '`"needYield" : 0`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of times this query yielded (paused) to allow a write request to
    proceed. If there are writes waiting to go, queries will periodically release
    their lock and allow them to continue. On this system, there were no writes waiting
    so the query never yielded.
  prefs: []
  type: TYPE_NORMAL
- en: '`"executionTimeMillis" : 15`'
  prefs: []
  type: TYPE_NORMAL
- en: The number of milliseconds it took the database to execute the query. The lower
    this number is, the better.
  prefs: []
  type: TYPE_NORMAL
- en: '`"indexBounds" : {...}`'
  prefs: []
  type: TYPE_NORMAL
- en: 'A description of how the index was used, giving ranges of the index traversed.
    In this example, as the first clause in the query was an exact match, the index
    only needed to look at that value: `42`. The second index key was a free variable,
    because the query didn’t specify any restrictions to it. Thus, the database looked
    for values between negative infinity (`` `"$minElement" : 1` ``) and infinity
    (`` `"$maxElement" : 1` ``) for usernames within `"age" : 42`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at a slightly more complicated example. Suppose you have
    an index on `{"username" : 1, "age" : 1}` and an index on `{"age" : 1, "username"
    : 1}`. What happens if you query for `"username"` and `"age"`? Well, it depends
    on the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We are querying for an exact match on `"username"` and a range of values for
    `"age"`, so the database chooses to use the `{"username" : 1, "age" : 1}` index,
    reversing the terms of the query. If, on the other hand, we query for an exact
    age and a range of names, MongoDB will use the other index:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'If you find that Mongo is using different indexes than you want it to for a
    query, you can force it to use a certain index by using `hint`. For instance,
    if you want to make sure MongoDB uses the `{"username" : 1, "age" : 1}` index
    on the previous query, you could say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a query is not using the index that you want it to and you use a hint to
    change it, run an `explain` on the hinted query before deploying. If you force
    MongoDB to use an index on a query that it does not know how to use an index for,
    you could end up making the query less efficient than it was without the index.
  prefs: []
  type: TYPE_NORMAL
- en: When Not to Index
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Indexes are most effective at retrieving small subsets of data, and some types
    of queries are faster without indexes. Indexes become less and less efficient
    as you need to get larger percentages of a collection because using an index requires
    two lookups: one to look at the index entry and one following the index’s pointer
    to the document. A collection scan only requires one: looking at the document.
    In the worst case (returning all of the documents in a collection) using an index
    would take twice as many lookups and would generally be significantly slower than
    a collection scan.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, there isn’t a hard-and-fast rule about when an index helps and
    when it hinders as it really depends on the size of your data, indexes, documents,
    and average result set ([Table 5-1](#table5-1)). As a rule of thumb, an index
    often speeds things up if the query is returning 30% or more of the collection.
    However, this number can vary from 2% to 60%. [Table 5-1](#table5-1) summarizes
    the conditions in which indexes or collection scans tend to work better.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Properties that affect the effectiveness of indexes
  prefs: []
  type: TYPE_NORMAL
- en: '| Indexes often work well for | Collection scans often work well for |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Large collections | Small collections |'
  prefs: []
  type: TYPE_TB
- en: '| Large documents | Small documents |'
  prefs: []
  type: TYPE_TB
- en: '| Selective queries | Nonselective queries |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s say we have an analytics system that collects statistics. Our application
    queries the system for all documents for a given account to generate a nice graph
    of all data from an hour ago to the beginning of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We index "`created_at`" to speed up this query.
  prefs: []
  type: TYPE_NORMAL
- en: When we first launch, the result set is tiny and the query returns instantly.
    But after a couple of weeks, it starts being a lot of data, and after a month
    this query is already taking too long to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most applications, this is probably the “wrong” query: do you really want
    a query that’s returning most of your dataset? Most applications, particularly
    those with large datasets, do not. However, there are some legitimate cases where
    you may want most or all of your data. For example, you might be exporting this
    data to a reporting system or using it for a batch job. In these cases, you would
    like to return this large proportion of the dataset as fast as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Types of Indexes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few index options you can specify when building an index that change
    the way the index behaves. The most common variations are described in the following
    sections, and more advanced or special-case options are described in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Unique Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unique indexes guarantee that each value will appear at most once in the index.
    For example, if you want to make sure no two documents can have the same value
    in the `"username"` key, you can create a unique index with a `partialFilterExpression`
    for only documents with a `firstname` field (more on this option later in the
    chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, suppose you tried to insert the following documents in the *users*
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you check the collection, you’ll see that only the first `"bob"` was stored.
    Throwing duplicate key exceptions is not very efficient, so use the unique constraint
    for the occasional duplicate, not to filter out zillions of duplicates a second.
  prefs: []
  type: TYPE_NORMAL
- en: A unique index that you are probably already familiar with is the index on `"_id"`,
    which is automatically created whenever you create a collection. This is a normal
    unique index (aside from the fact that it cannot be dropped, as other unique indexes
    can be).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a key does not exist, the index stores its value as `null` for that document.
    This means that if you create a unique index and try to insert more than one document
    that is missing the indexed field, the inserts will fail because you already have
    a document with a value of `null`. See [“Partial Indexes”](#sparse-indexes) for
    advice on handling this.
  prefs: []
  type: TYPE_NORMAL
- en: 'In some cases a value won’t be indexed. Index buckets are of limited size and
    if an index entry exceeds it, it just won’t be included in the index. This can
    cause confusion as it makes a document “invisible” to queries that use the index.
    Prior to MongoDB 4.2, a field was required to be smaller than 1,024 bytes to be
    included in an index. In MongoDB 4.2 and later, this constraint was removed. MongoDB
    does not return any sort of error or warning if a document’s fields cannot be
    indexed due to size. This means that keys longer than 8 KB will not be subject
    to the unique index constraints: you can insert identical 8 KB strings, for example.'
  prefs: []
  type: TYPE_NORMAL
- en: Compound unique indexes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also create a compound unique index. If you do this, individual keys
    can have the same values, but the combination of values across all keys in an
    index entry can appear in the index at most once.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we had a unique index on `{"username" : 1, "age" : 1}`, the
    following inserts would be legal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: However, attempting to insert a second copy of any of these documents would
    cause a duplicate key exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'GridFS, the standard method for storing large files in MongoDB (see [“Storing
    Files with GridFS”](ch06.xhtml#sect1_d1e7744)), uses a compound unique index.
    The collection that holds the file content has a unique index on `{"files_id"
    : 1, "n" : 1}`, which allows documents that look like (in part) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Note that all of the values for `"files_id"` are the same, but `"n"` is different.
  prefs: []
  type: TYPE_NORMAL
- en: Dropping duplicates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you attempt to build a unique index on an existing collection, it will fail
    to build if there are any duplicate values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Generally, you’ll need to process your data (the aggregation framework can help)
    and figure out where the duplicates are and what to do with them.
  prefs: []
  type: TYPE_NORMAL
- en: Partial Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the previous section, unique indexes count `null` as a value,
    so you cannot have a unique index with more than one document missing the key.
    However, there are lots of cases where you may want the unique index to be enforced
    only if the key exists. If you have a field that may or may not exist but must
    be unique when it does, you can combine the `"unique"` option with the `"partial"`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Partial indexes in MongoDB are only created on a subset of the data. This is
    unlike sparse indexes on relational databases, which create fewer index entries
    pointing to a block of data—however, all blocks of data will have an associated
    sparse index entry in RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a partial index, include the `"partialFilterExpression"` option.
    Partial indexes represent a superset of the functionality offered by sparse indexes,
    with a document representing the filter expression you wish to create it on. For
    example, if providing an email address was optional but, if provided, should be
    unique, we could do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Partial indexes do not necessarily have to be unique. To make a nonunique partial
    index, simply do not include the `"unique"` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to be aware of is that the same query can return different results
    depending on whether or not it uses the partial index. For example, suppose we
    have a collection where most of the documents have `"x"` fields, but one does
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do a query on `"x"`, it will return all matching documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create a partial index on `"x"`, the `"_id" : 0` document won’t be included
    in the index. So now if we query on `"x"`, MongoDB will use the index and not
    return the `{"_id" : 0}` document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: You can use `hint` to force it to do a table scan if you need documents with
    missing fields.
  prefs: []
  type: TYPE_NORMAL
- en: Index Administration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in the previous section, you can create new indexes using the `createIndex`
    function. An index only needs to be created once per collection. If you try to
    create the same index again, nothing will happen.
  prefs: []
  type: TYPE_NORMAL
- en: All of the information about a database’s indexes is stored in the *system.indexes*
    collection. This is a reserved collection, so you cannot modify its documents
    or remove documents from it. You can manipulate it only through the `createIndex`,
    `createIndexes`, and `dropIndexes` database commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create an index, you can see its metainformation in *system.indexes*.
    You can also run ``db.*`collectionName`*.getIndexes()`` to see information about
    all the indexes on a given collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'The important fields are `"key"` and `"name"`. The key can be used for hinting
    and other places where an index must be specified. This is a place where field
    order matters: an index on `{"class_id" : 1, "student_id" : 1}` is not the same
    as an index on `{"student_id" : 1, "class_id" : 1}`. The index name is used as
    an identifier for a lot of administrative index operations, such as `dropIndexes`.
    Whether or not the index is multikey is not specified in its spec.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `"v"` field is used internally for index versioning. If you have any indexes
    that do not have at least a `` `"v"` : 1 `` field, they are being stored in an
    older, less efficient format. You can upgrade them by ensuring that you’re running
    at least MongoDB version 2.0 and dropping and rebuilding the indexes.'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each index in a collection has a name that uniquely identifies that index and
    is used by the server to delete or manipulate it. Index names are, by default,
    ``*`keyname1`*_*`dir1`*_*`keyname2`*_*`dir2`*_..._*`keynameN`*_*`dirN`*``, where
    ``*`keynameX`*`` is the index’s key and ``*`dirX`*`` is the index’s direction
    (`1` or `-1`). This can get unwieldy if indexes contain more than a couple of
    keys, so you can specify your own name as one of the options to `createIndex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There is a limit to the number of characters in an index name, so complex indexes
    may need custom names to be created. A call to `getLastError` will show if the
    index creation succeeded or why it didn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Changing Indexes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As your application grows and changes, you may find that your data or queries
    have changed and that indexes that used to work well no longer do. You can remove
    unneeded indexes using the `dropIndex` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Use the `"name"` field from the index description to specify which index to
    drop.
  prefs: []
  type: TYPE_NORMAL
- en: Building new indexes is time-consuming and resource-intensive. Prior to version
    4.2, MongoDB will build an index as fast as possible, blocking all reads and writes
    on a database until the index build has finished. If you would like your database
    to remain somewhat responsive to reads and writes, use the `"background"` option
    when building an index. This forces the index build to occasionally yield to other
    operations, but may still have a severe impact on your application (see [“Building
    Indexes”](ch13.xhtml#repl-building-indexes) for more information). Background
    indexing is also much slower than foreground indexing. MongoDB version 4.2 introduced
    a new approach, the hybrid index build. It only holds the exclusive lock at the
    beginning and end of the index build. The rest of the build process yields to
    interleaving read and write operations. This replaces both the foreground and
    the background index build type in MongoDB 4.2.
  prefs: []
  type: TYPE_NORMAL
- en: If you have the choice, creating indexes on existing documents is slightly faster
    than creating the index first and then inserting all documents.
  prefs: []
  type: TYPE_NORMAL
- en: There is more on the operational aspects of building indexes in [Chapter 19](ch19.xhtml#chapter-data-admin).
  prefs: []
  type: TYPE_NORMAL
