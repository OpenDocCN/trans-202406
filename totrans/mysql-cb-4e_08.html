<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Working with Dates and Times"><div class="chapter" id="nch-dates"><h1><span class="label">Chapter 8. </span>Working with Dates and Times</h1><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820372068096"><h5>A note for Early Release readers</h5><p>With Early Release ebooks, you get books in their earliest form—the author’s raw and unedited content as they write—so you can take advantage of these technologies long before the official release of these titles.</p></div></aside><section data-type="sect1" data-pdf-bookmark="8.0 Introduction"><div class="sect1" id="nch-dates-dates-intro"><h1>8.0 Introduction</h1><p>MySQL has several data types for representing dates and times, and many functions
    for operating on them. MySQL stores dates and times in specific formats,
    and it’s important to understand them to avoid surprises in results from
    manipulating temporal data. This chapter covers the following aspects of
    working with date and time values in MySQL:</p><dl><dt>Choosing a temporal data type</dt><dd><p>MySQL provides several temporal data types to choose from when
          you create tables. Knowing their properties enables you to choose
          them appropriately.</p></dd><dt>Displaying dates and times</dt><dd><p>MySQL displays temporal values using specific formats by
          default. You can produce other formats by using the appropriate
          functions.</p></dd><dt>Changing the client time zone</dt><dd><p>The server interprets <code>TIMESTAMP</code> and <code>DATETIME</code>values in the client’s current time zone, not its own. Clients
          in different time zones should set their zone so that the server can
          properly interpret <code>TIMESTAMP</code>
          values for them.</p></dd><dt>Determining the current date and time</dt><dd><p>MySQL provides functions that return the date and time. These
          are useful for applications that must know these values or need to
          calculate other temporal values in relation to them.</p></dd><dt>Tracking row modification times</dt><dd><p>The <code>TIMESTAMP</code> and <code>DATETIME</code> data types have special properties that enable you to record
          row-creation and last-modification times automatically.</p></dd><dt>Breaking dates and times into component values, creating dates
        and times from component values</dt><dd><p>You can split date and time values when you need only a
          component, such as the month part of a date or the hour part of a
          time. Conversely, you can combine component values to synthesize
          dates and times.</p></dd><dt>Converting between dates or times and basic units</dt><dd><p>Some temporal calculations such as date arithmetic operations
          are more easily performed using the number of days or seconds
          represented by a date or time value than by using the value itself.
          MySQL can perform conversions between date and time values and more
          basic units such as days or seconds.</p></dd><dt>Date and time arithmetic</dt><dd><p>You can add or subtract temporal values to produce other
          temporal values or calculate intervals between values. Applications
          include age determination, relative date computation, and date
          shifting.</p></dd><dt>Selecting data based on temporal constraints</dt><dd><p>The calculations discussed in the preceding sections to
          produce output values can also be used in <code>WHERE</code> clauses to specify how to select
          rows using temporal conditions.</p></dd></dl><p>This chapter covers several MySQL functions for operating on date
    and time values, but there are many others. To familiarize yourself with
    the full set, consult the <a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html">MySQL Reference Manual</a>.
    The variety of functions available to you means that it’s often possible to
    perform a given temporal calculation more than one way. We sometimes
    illustrate alternative methods for achieving a given result, and many of
    the problems addressed in this chapter can be solved in ways other than
    shown here. We invite you to experiment to find other solutions. You may
    find a method that’s more efficient or that you find more
    intuitive.</p><p>Scripts that implement recipes discussed in this chapter are located
    in the <em class="filename">dates</em> directory of the
    <code>recipes</code> source distribution. Scripts
    that create tables used here are located in the <em class="filename">tables</em>
    directory.</p></div></section><section data-type="sect1" data-pdf-bookmark="8.1 Choosing a Temporal Data Type"><div class="sect1" id="nch-dates-dates-types"><h1>8.1 Choosing a Temporal Data Type</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820372050992"><h2>Problem</h2><p>You need to store temporal data but aren’t sure which is the most
      appropriate data type.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820372049904"><h2>Solution</h2><p>Choose the data type according to the characteristics of the
      information to be stored and how you need to use it.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820372048832"><h2>Discussion</h2><p>To choose a temporal data type, consider questions such as
      these:</p><ul><li><p>Do you need times only, dates only, or combined date and time
          values?</p></li><li><p>What range of values do you require?</p></li><li><p>Do you want automatic initialization of the column to the
          current date and time?</p></li></ul><p>MySQL provides <code>DATE</code> and
      <code>TIME</code> data types for representing date and time values separately, and
      <code>DATETIME</code> and <code>TIMESTAMP</code> types for combined date-and-time
      values. These values have the following characteristics:</p><ul><li><p><code>DATE</code> values have <em><code>YYYY-MM-DD</code></em> format,
          where <em><code>YY</code></em>,
          <em><code>MM</code></em>, and <em><code>DD</code></em>
          represent the year, month, and day parts of
          the date. The supported range for <code>DATE</code> values is <code>1000-01-01</code> to <code>9999-12-31</code>.</p></li><li><p><code>TIME</code> values have <em><code>hh:mm:ss</code></em> format, where
          <em><code>hh</code></em>, <em><code>mm</code></em>, and
          <em><code>ss</code></em> are the hours, minutes, and seconds
          parts of the time. <code>TIME</code> values
          often can be thought of as time-of-day values, but MySQL actually
          treats them as elapsed time. Thus, they may be greater than <code>23:59:59</code> or even negative. (The actual
          range of a <code>TIME</code> column is
          <code>-838:59:59</code> to <code>838:59:59</code>.)</p></li><li><p><code>DATETIME</code> and <code>TIMESTAMP</code> are combined date-and-time values in
          <em><code>YYYY-MM-DD</code></em>
          <em><code>hh:mm:ss</code></em> format.</p><p>The <code>DATETIME</code> and <code>TIMESTAMP</code> data types are similar in many
          respects, but watch out for these differences:</p><ul><li><p><code>DATETIME</code> has a
              supported range of <code>1000-01-01
              00:00:00</code> to <code>9999-12-31
              23:59:59</code>, whereas <code>TIMESTAMP</code> values are valid only from
              the year 1970 partially through 2038.</p></li><li><p><code>TIMESTAMP</code> and <code>DATETIME</code> have special
              auto-initialization and auto-update properties (see <a data-type="xref" href="#nch-dates-dates-automatic">Recipe 8.8</a>), but for <code>DATETIME</code> they are not available before
              MySQL 5.6.5.</p></li><li><p>When a client inserts a <code>TIMESTAMP</code> value, the server converts
              it from the time zone associated with the client session to UTC
              and stores the UTC value. When the client retrieves a <code>TIMESTAMP</code> value, the server performs
              the reverse operation to convert the UTC value back to the
              client session time zone. A client in a time zone different from
              the server can configure its session so that this conversion is
              appropriate for its own time zone (see <a data-type="xref" href="#nch-dates-dates-client-time-zone">Recipe 8.4</a>).</p></li></ul></li><li><p>Types that include a time part can have a fractional seconds
          part for subsecond resolution (see <a data-type="xref" href="#nch-dates-fractional-seconds">Recipe 8.2</a>).</p></li></ul><p>Many of the examples in this chapter draw on the following tables,
      which contain columns representing time, date, and date-and-time values.
      (The <code>time_val</code> table has two columns
      for use in time interval calculation examples.)</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1, t2 FROM time_val;</code></strong>
+----------+----------+
| t1       | t2       |
+----------+----------+
| 15:00:00 | 15:00:00 |
| 05:01:30 | 02:30:20 |
| 12:30:20 | 17:30:45 |
+----------+----------+
mysql&gt; <strong><code>SELECT d FROM date_val;</code></strong>
+------------+
| d          |
+------------+
| 1864-02-28 |
| 1900-01-15 |
| 1999-12-31 |
| 2000-06-04 |
| 2017-03-16 |
+------------+
mysql&gt; <strong><code>SELECT dt FROM datetime_val;</code></strong>
+---------------------+
| dt                  |
+---------------------+
| 1970-01-01 00:00:00 |
| 1999-12-31 09:00:00 |
| 2000-06-04 15:45:30 |
| 2017-03-16 12:30:15 |
+---------------------+</pre><p>It is a good idea to create the <code>time_val</code>, <code>date_val</code>, and <code>datetime_val</code> tables right now before reading
      further. (Use the appropriate scripts in the <em class="filename">tables</em>
      directory of the <code>recipes</code>
      distribution.)</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.2 Using Fractional Seconds Support"><div class="sect1" id="nch-dates-fractional-seconds"><h1>8.2 Using Fractional Seconds Support</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820372013664"><h2>Problem</h2><p>Your application requires subsecond resolution of time values.
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820372012688"><h2>Solution</h2><p>Specify fractional seconds.
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820372011616"><h2>Discussion</h2><p>As of MySQL 5.6.4, fractional seconds are supported for temporal types that include a time
    part: <code>DATETIME</code>, <code>TIME</code>, and <code>TIMESTAMP</code>. For applications that require
    subsecond resolution of time values, this enables you to specify
    fractional seconds precision down to the microsecond level.</p><p>The default is to have no fractional seconds part, so to include it
    for temporal types that support this capability, specify it explicitly in
    the column declaration: include <code>(</code><em><code>fsp</code></em><code>)</code> after the data type name in a column
    definition. <em><code>fsp</code></em> can be from 0 to 6 to indicate
    the number of fractional digits. 0 means <q>none</q> (resolution
    to seconds), 6 means resolution to microseconds. For example, to create a
    <code>TIME</code> column with two fractional digits
    (resolution to hundredths of a second), use this syntax:</p><pre data-type="programlisting">mycol TIME(2)</pre><p>A precision timing is crucial for specific events such as races. 
    One of the most popular and time-sensitive event is Formula 1 races worldwide. 
    Time tracking for the fastest motorsport requires detailed timekeeping and technology.  
    In short, the necessary time to be tracked is within ten thousand of a 
    second by using multiple transponders. 
</p><table id="nch-dates-fractional-seconds-formula1"><caption><span class="label">Table 8-1. </span>FORMULA 1 ROLEX TURKISH GRAND PRIX 2021 - RACE RESULT</caption><thead><tr><th>Driver</th><th>Car</th><th>Time</th></tr></thead><tbody><tr><td>Max Verstappen</td><td>RED BULL RACING HONDA</td><td><code>1:17.301 </code></td></tr><tr><td>Valtteri Bottas</td><td>MERCEDES</td><td><code>1:17.725 </code></td></tr><tr><td>Lewis Hamilton</td><td>MERCEDES</td><td><code>1:17.810 </code></td></tr></tbody></table><p>Temporal functions that return current time or date-and-time values
    also support fractional seconds. The default without an argument is no
    fractional part. Otherwise, the argument specifies the desired resolution.
    Permitted values are 0 to 6, the same as when declaring temporal
    columns:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CURTIME(), CURTIME(2), CURTIME(6);</code></strong>
+-----------+-------------+-----------------+
| CURTIME() | CURTIME(2)  | CURTIME(6)      |
+-----------+-------------+-----------------+
| 18:07:03  | 18:07:03.24 | 18:07:03.244950 |
+-----------+-------------+-----------------+</pre><p> 
     In order to better demonstrate we will take example of having Formula 1 race standings from one of the latest races
     held in Turkey (<a data-type="xref" href="#nch-dates-fractional-seconds-formula1">Table 8-1</a>). </p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="o">`</code><code class="n">formula1</code><code class="o">`</code> <code class="p">(</code>
    <code class="n">id</code> <code class="nb">INT</code> <code class="n">AUTO_INCREMENT</code> <code class="k">PRIMARY</code> <code class="k">KEY</code><code class="p">,</code>
    <code class="k">position</code> <code class="nb">INT</code> <code class="n">UNSIGNED</code><code class="p">,</code>
    <code class="k">no</code>       <code class="nb">INT</code> <code class="n">UNSIGNED</code><code class="p">,</code>
    <code class="n">driver</code>   <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">25</code><code class="p">),</code>
    <code class="n">car</code>      <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">25</code><code class="p">),</code>
    <code class="n">laps</code>     <code class="nb">SMALLINT</code><code class="p">,</code>
    <code class="n">time</code>     <code class="k">TIMESTAMP</code><code class="p">(</code><code class="mi">3</code><code class="p">),</code>
    <code class="n">points</code>   <code class="nb">SMALLINT</code>
<code class="p">);</code></pre><pre data-type="programlisting" data-code-language="sql"><code class="k">INSERT</code> <code class="k">INTO</code> <code class="n">formula1</code> <code class="k">VALUES</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">77</code><code class="p">,</code><code class="ss">"Valtteri Bottas"</code><code class="p">,</code><code class="ss">"MERCEDES"</code><code class="p">,</code><code class="mi">58</code><code class="p">,</code><code class="ss">"2021-10-08 </code>
<code class="ss">\ 1:31:04.103"</code><code class="p">,</code><code class="mi">26</code><code class="p">);</code>
<code class="k">INSERT</code> <code class="k">INTO</code> <code class="n">formula1</code> <code class="k">VALUES</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">33</code><code class="p">,</code><code class="ss">"Max Verstappen"</code><code class="p">,</code><code class="ss">"RED BULL RACING HONDA"</code><code class="p">,</code><code class="mi">58</code><code class="p">,</code>
<code class="err">\</code><code class="ss">"2021-10-08 1:45:58.243"</code><code class="p">,</code><code class="mi">18</code><code class="p">);</code>
<code class="k">INSERT</code> <code class="k">INTO</code> <code class="n">formula1</code> <code class="k">VALUES</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">11</code><code class="p">,</code><code class="ss">"Sergio Perez"</code><code class="p">,</code><code class="ss">"RED BULL RACING HONDA"</code><code class="p">,</code><code class="mi">58</code><code class="p">,</code>
<code class="err">\</code><code class="ss">"2021-10-08 1:46:10.342"</code><code class="p">,</code><code class="mi">15</code><code class="p">);</code></pre><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="k">POSITION</code> <code class="k">as</code> <code class="n">pos</code><code class="p">,</code>
        <code class="k">no</code><code class="p">,</code>
        <code class="n">driver</code><code class="p">,</code>
        <code class="n">car</code><code class="p">,</code>
        <code class="n">laps</code><code class="p">,</code>
        <code class="n">date_format</code><code class="p">(</code><code class="n">time</code><code class="p">,</code><code class="s1">'%H:%i:%s:%f'</code><code class="p">)</code> <code class="k">as</code> <code class="n">time</code><code class="p">,</code>
        <code class="n">points</code> <code class="k">as</code> <code class="n">pts</code>
   <code class="k">FROM</code> <code class="n">formula1</code> <code class="k">ORDER</code> <code class="k">BY</code> <code class="n">time</code><code class="p">;</code>
<code class="o">+</code><code class="c1">------+------+-----------------+-----------------------+------+-----------------+------+</code>
<code class="o">|</code> <code class="n">pos</code>  <code class="o">|</code> <code class="k">no</code>   <code class="o">|</code> <code class="n">driver</code>          <code class="o">|</code> <code class="n">car</code>                   <code class="o">|</code> <code class="n">laps</code> <code class="o">|</code> <code class="n">time</code>            <code class="o">|</code> <code class="n">pts</code>  <code class="o">|</code>
<code class="o">+</code><code class="c1">------+------+-----------------+-----------------------+------+-----------------+------+</code>
<code class="o">|</code>    <code class="mi">1</code> <code class="o">|</code>   <code class="mi">77</code> <code class="o">|</code> <code class="n">Valtteri</code> <code class="n">Bottas</code> <code class="o">|</code> <code class="n">MERCEDES</code>              <code class="o">|</code>   <code class="mi">58</code> <code class="o">|</code> <code class="mi">01</code><code class="p">:</code><code class="mi">31</code><code class="p">:</code><code class="mi">04</code><code class="p">:</code><code class="mi">103000</code> <code class="o">|</code>   <code class="mi">26</code> <code class="o">|</code>
<code class="o">|</code>    <code class="mi">2</code> <code class="o">|</code>   <code class="mi">33</code> <code class="o">|</code> <code class="k">Max</code> <code class="n">Verstappen</code>  <code class="o">|</code> <code class="n">RED</code> <code class="n">BULL</code> <code class="n">RACING</code> <code class="n">HONDA</code> <code class="o">|</code>   <code class="mi">58</code> <code class="o">|</code> <code class="mi">01</code><code class="p">:</code><code class="mi">45</code><code class="p">:</code><code class="mi">58</code><code class="p">:</code><code class="mi">243000</code> <code class="o">|</code>   <code class="mi">18</code> <code class="o">|</code>
<code class="o">|</code>    <code class="mi">3</code> <code class="o">|</code>   <code class="mi">11</code> <code class="o">|</code> <code class="n">Sergio</code> <code class="n">Perez</code>    <code class="o">|</code> <code class="n">RED</code> <code class="n">BULL</code> <code class="n">RACING</code> <code class="n">HONDA</code> <code class="o">|</code>   <code class="mi">58</code> <code class="o">|</code> <code class="mi">01</code><code class="p">:</code><code class="mi">46</code><code class="p">:</code><code class="mi">10</code><code class="p">:</code><code class="mi">342000</code> <code class="o">|</code>   <code class="mi">15</code> <code class="o">|</code>
<code class="o">+</code><code class="c1">------+------+-----------------+-----------------------+------+-----------------+------+</code></pre><p>In order to get proper listing of this time gaps between the driver performance we will use a CTE.
	We will be discussing CTEs (Common Table Expressions) in 
	 <a data-type="xref" href="ch10.xhtml#nch-sum-sum-with">Recipe 10.18</a>. Here is the solution.</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="k">MIN</code><code class="p">(</code><code class="n">time</code><code class="p">)</code> <code class="k">from</code> <code class="n">formula1</code> <code class="k">into</code> <code class="o">@</code><code class="n">fastest</code><code class="p">;</code>

<code class="k">WITH</code> <code class="n">time_gap</code> <code class="k">AS</code> <code class="p">(</code>
  <code class="k">SELECT</code>
    <code class="k">position</code><code class="p">,</code>
    <code class="n">car</code><code class="p">,</code>
    <code class="n">driver</code><code class="p">,</code>
    <code class="n">time</code><code class="p">,</code>
    <code class="n">TIMESTAMPDIFF</code><code class="p">(</code><code class="k">SECOND</code><code class="p">,</code> <code class="n">time</code> <code class="p">,</code> <code class="o">@</code><code class="n">fastest</code><code class="p">)</code> <code class="k">AS</code> <code class="n">seconds</code>
  <code class="k">FROM</code> <code class="n">formula1</code>
<code class="p">),</code>

<code class="n">DIFFERENCES</code> <code class="k">AS</code> <code class="p">(</code>
  <code class="k">SELECT</code>
    <code class="k">position</code> <code class="k">as</code> <code class="n">pos</code><code class="p">,</code>
    <code class="n">driver</code><code class="p">,</code>
    <code class="n">car</code><code class="p">,</code>
    <code class="n">time</code><code class="p">,</code>
    <code class="n">seconds</code><code class="p">,</code>
    <code class="k">MOD</code><code class="p">(</code><code class="n">seconds</code><code class="p">,</code> <code class="mi">60</code><code class="p">)</code> <code class="k">AS</code> <code class="n">seconds_part</code><code class="p">,</code>
    <code class="k">MOD</code><code class="p">(</code><code class="n">seconds</code><code class="p">,</code> <code class="mi">3600</code><code class="p">)</code> <code class="k">AS</code> <code class="n">minutes_part</code>
  <code class="k">FROM</code> <code class="n">time_gap</code>
<code class="p">)</code>

<code class="k">SELECT</code>
  <code class="n">pos</code><code class="p">,</code>
  <code class="n">driver</code><code class="p">,</code>
  <code class="n">time</code><code class="p">,</code>
  <code class="n">CONCAT</code><code class="p">(</code>
    <code class="n">FLOOR</code><code class="p">(</code><code class="n">minutes_part</code> <code class="o">/</code> <code class="mi">60</code><code class="p">),</code> <code class="s1">' min '</code><code class="p">,</code>
    <code class="n">SUBSTRING_INDEX</code><code class="p">(</code><code class="n">SUBSTRING_INDEX</code><code class="p">(</code><code class="n">seconds_part</code><code class="p">,</code><code class="s1">'-'</code><code class="p">,</code><code class="mi">2</code><code class="p">),</code><code class="s1">'-'</code><code class="p">,</code><code class="o">-</code><code class="mi">1</code><code class="p">),</code><code class="s1">' secs'</code>
  <code class="p">)</code> <code class="k">AS</code> <code class="n">difference</code>
<code class="k">FROM</code> <code class="n">differences</code><code class="p">;</code>
<code class="o">+</code><code class="c1">------+-----------------+-------------------------+-----------------+</code>
<code class="o">|</code> <code class="n">pos</code>  <code class="o">|</code> <code class="n">driver</code>          <code class="o">|</code> <code class="n">time</code>                    <code class="o">|</code> <code class="n">difference</code>      <code class="o">|</code>
<code class="o">+</code><code class="c1">------+-----------------+-------------------------+-----------------+</code>
<code class="o">|</code>    <code class="mi">1</code> <code class="o">|</code> <code class="n">Valtteri</code> <code class="n">Bottas</code> <code class="o">|</code> <code class="mi">2021</code><code class="o">-</code><code class="mi">10</code><code class="o">-</code><code class="mi">08</code> <code class="mi">01</code><code class="p">:</code><code class="mi">31</code><code class="p">:</code><code class="mi">04</code><code class="p">.</code><code class="mi">103</code> <code class="o">|</code> <code class="mi">0</code> <code class="k">min</code> <code class="mi">0</code> <code class="n">secs</code>    <code class="o">|</code>
<code class="o">|</code>    <code class="mi">2</code> <code class="o">|</code> <code class="k">Max</code> <code class="n">Verstappen</code>  <code class="o">|</code> <code class="mi">2021</code><code class="o">-</code><code class="mi">10</code><code class="o">-</code><code class="mi">08</code> <code class="mi">01</code><code class="p">:</code><code class="mi">45</code><code class="p">:</code><code class="mi">58</code><code class="p">.</code><code class="mi">243</code> <code class="o">|</code> <code class="o">-</code><code class="mi">15</code> <code class="k">min</code> <code class="mi">54</code> <code class="n">secs</code> <code class="o">|</code>
<code class="o">|</code>    <code class="mi">3</code> <code class="o">|</code> <code class="n">Sergio</code> <code class="n">Perez</code>    <code class="o">|</code> <code class="mi">2021</code><code class="o">-</code><code class="mi">10</code><code class="o">-</code><code class="mi">08</code> <code class="mi">01</code><code class="p">:</code><code class="mi">46</code><code class="p">:</code><code class="mi">10</code><code class="p">.</code><code class="mi">342</code> <code class="o">|</code> <code class="o">-</code><code class="mi">16</code> <code class="k">min</code> <code class="mi">6</code> <code class="n">secs</code>  <code class="o">|</code>
<code class="o">+</code><code class="c1">------+-----------------+-------------------------+-----------------+</code></pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.3 Changing MySQL’s Date Format"><div class="sect1" id="nch-dates-dates-format"><h1>8.3 Changing MySQL’s Date Format</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820371429008"><h2>Problem</h2><p>You want to change the ISO format that MySQL uses for representing date
      values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820371428128"><h2>Solution</h2><p>You can’t. However, you can rewrite non-ISO input values into ISO
      format when storing dates, and you can rewrite ISO values to other
      formats for display with the <code>DATE_FORMAT()</code>
      function.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820371333008"><h2>Discussion</h2><p>The <em><code>YYYY-MM-DD</code></em> format that MySQL uses
      for <code>DATE</code> values follows
      the ISO 8601 standard for representing dates. Because the
      year, month, and day parts have a fixed length and appear left to right
      in date strings, this format has the useful property that dates sort
      naturally into the proper temporal order. <a data-type="xref" href="ch09.xhtml#nch-sort-sort-date">Recipe 9.5</a> and
      <a data-type="xref" href="ch10.xhtml#nch-sum-sum-date">Recipe 10.15</a>
      discuss ordering and grouping techniques for date-based values.</p><p>ISO format, although common, is not used by all database systems,
      which can cause problems if you move data between different systems.
      Moreover, people commonly like to represent dates in other formats such
      as <em><code>MM/DD/YY</code></em> or
      <em><code>DD-MM-YYYY</code></em>. This too can be a source of trouble, due to mismatches between human
      expectations of how dates should look and how MySQL actually represents
      them.</p><p>A question frequently asked by newcomers to MySQL is, <q>How
      do I tell MySQL to store dates in a specific format such as
      <em><code>MM/DD/YYYY</code></em>?</q> That’s the wrong
      question. Instead, ask, <q>If I have a date in a specific format,
      how can I store it in MySQL’s supported format, and vice versa?</q>
      MySQL always stores dates in ISO format, a fact with implications both
      for data entry (input) and for displaying query results (output):</p><ul><li><p>For data-entry purposes, to store values that are not in ISO
          format, you normally must rewrite them first. If you don’t want to
          rewrite them, you can store them as strings (for example, in
          a <code>CHAR</code> column). But
          then you can’t operate on them as dates.</p><p><a data-type="xref" href="ch13.xhtml#nch-xfer">Chapter 13</a> covers the topic of date rewriting
          for data entry, and <a data-type="xref" href="ch14.xhtml#nch-format">Chapter 14</a> discusses checking
          dates to verify that they’re valid. In some cases, if your values
          are close to ISO format, rewriting may not be necessary. For
          example, MySQL interprets the string values <code>87-1-7</code> and <code>1987-1-7</code> and the numbers <code>870107</code> and <code>19870107</code> as the date <code>1987-01-07</code> when storing them into a
          <code>DATE</code> column.</p></li><li><p>For display purposes, you can rewrite dates to non-ISO
          formats. The <code>DATE_FORMAT()</code>
          function provides a lot of flexibility for changing date values into
          other formats (see later in this section). You can also use
          functions such as <code>YEAR()</code> to
          extract parts of dates for display (see <a data-type="xref" href="#nch-dates-dates-decomp">Recipe 8.9</a>). For additional discussion, see
          <a data-type="xref" href="ch14.xhtml#nch-format-format-date-export">Recipe 14.17</a>.</p></li></ul><p>One way to rewrite non-ISO values for date entry is to use
      the <code>STR_TO_DATE()</code>
      function, which takes a string representing a temporal value and a
      format string that specifies the <q>syntax</q> of the value.
      Within the formatting string, use special sequences of the form <code>%</code><em><code>c</code></em>, where
      <em><code>c</code></em> specifies which part of the date to expect.
      For example, <code>%Y</code>, <code>%M</code>, and <code>%d</code>
      signify the four-digit year, the month name, and the two-digit day of
      the month. To insert the value <code>May</code>
      <code>13,</code> <code>2007</code> into a <code>DATE</code> column, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>INSERT INTO t (d) VALUES(STR_TO_DATE('May 13, 2007','%M %d, %Y'));</code></strong>
mysql&gt; <strong><code>SELECT d FROM t;</code></strong>
+------------+
| d          |
+------------+
| 2007-05-13 |
+------------+</pre><p>For date display, MySQL uses ISO format
      (<em><code>YYYY-MM-DD</code></em>) unless you tell it otherwise. To
      display dates or times in other formats, use the <code>DATE_FORMAT()</code> or <code>TIME_FORMAT()</code> function to rewrite them. If you require a more specialized format
      those functions cannot provide, write a stored function.</p><p>The <code>DATE_FORMAT()</code> function
      takes two arguments: a <code>DATE</code>, <code>DATETIME</code>, or <code>TIMESTAMP</code> value, and a string describing how to display the value. The
      format string uses the same kind of specifiers as <code>STR_TO_DATE()</code>. The following statement shows
      the values in the <code>date_val</code> table,
      both as MySQL displays them by default and as reformatted with <code>DATE_FORMAT()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DATE_FORMAT(d,'%M %d, %Y') FROM date_val;</code></strong>
+------------+----------------------------+
| d          | DATE_FORMAT(d,'%M %d, %Y') |
+------------+----------------------------+
| 1864-02-28 | February 28, 1864          |
| 1900-01-15 | January 15, 1900           |
| 1999-12-31 | December 31, 1999          |
| 2000-06-04 | June 04, 2000              |
| 2017-03-16 | March 16, 2017             |
+------------+----------------------------+</pre><p>Because <code>DATE_FORMAT()</code> produces
      long column headings, it’s often useful to provide an alias (see <a data-type="xref" href="ch05.xhtml#nch-select-select-column-alias">Recipe 5.2</a>) to make a heading more
      concise or meaningful:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DATE_FORMAT(d,'%M %d, %Y') AS date FROM date_val;</code></strong>
+------------+-------------------+
| d          | date              |
+------------+-------------------+
| 1864-02-28 | February 28, 1864 |
| 1900-01-15 | January 15, 1900  |
| 1999-12-31 | December 31, 1999 |
| 2000-06-04 | June 04, 2000     |
| 2017-03-16 | March 16, 2017    |
+------------+-------------------+</pre><p>The <a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html">MySQL Reference Manual</a>. provides a
      complete list of format sequences to use with <code>DATE_FORMAT()</code>, <code>TIME_FORMAT()</code>, and <code>STR_TO_DATE()</code>. The <a data-type="xref" href="#nch-dates-dates-format-syntax">Table 8-2</a> shows some
      of them:</p><table id="nch-dates-dates-format-syntax"><caption><span class="label">Table 8-2. </span>Format sequences to use with date and time formatting functions</caption><thead><tr><th>Sequence</th><th>Meaning</th></tr></thead><tbody><tr><td><code>%Y</code></td><td>Four-digit year</td></tr><tr><td><code>%y</code></td><td>Two-digit year</td></tr><tr><td><code>%M</code></td><td>Complete month name</td></tr><tr><td><code>%b</code></td><td>Month name, initial three letters</td></tr><tr><td><code>%m</code></td><td>Two-digit month of year (01..12)</td></tr><tr><td><code>%c</code></td><td>Month of year (1..12)</td></tr><tr><td><code>%d</code></td><td>Two-digit day of month
              (01..31)</td></tr><tr><td><code>%e</code></td><td>Day of month (1..31)</td></tr><tr><td><code>%W</code></td><td>Weekday name (Sunday..Saturday)</td></tr><tr><td><code>%r</code></td><td>12-hour time with AM or PM suffix</td></tr><tr><td><code>%T</code></td><td>24-hour time</td></tr><tr><td><code>%H</code></td><td>Two-digit hour</td></tr><tr><td><code>%i</code></td><td>Two-digit minute</td></tr><tr><td><code>%s</code></td><td>Two-digit second</td></tr><tr><td><code>%f</code></td><td>Six-digit microsecond</td></tr><tr><td><code>%%</code></td><td>Literal <code>%</code></td></tr></tbody></table><p>The time-related format sequences shown in the table are useful
      only when you pass <code>DATE_FORMAT()</code> a
      value that has both date and time parts (a <code>DATETIME</code> or <code>TIMESTAMP</code>). The following statement displays
      <code>DATETIME</code> values from the <code>datetime_val</code> table using formats that include
      the time of day:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>DATE_FORMAT(dt,'%c/%e/%y %r') AS format1,</code></strong>
    -&gt; <strong><code>DATE_FORMAT(dt,'%M %e, %Y %T') AS format2</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+----------------------+----------------------------+
| dt                  | format1              | format2                    |
+---------------------+----------------------+----------------------------+
| 1970-01-01 00:00:00 | 1/1/70 12:00:00 AM   | January 1, 1970 00:00:00   |
| 1999-12-31 09:00:00 | 12/31/99 09:00:00 AM | December 31, 1999 09:00:00 |
| 2000-06-04 15:45:30 | 6/4/00 03:45:30 PM   | June 4, 2000 15:45:30      |
| 2017-03-16 12:30:15 | 3/16/17 12:30:15 PM  | March 16, 2017 12:30:15    |
+---------------------+----------------------+----------------------------+</pre><p><code>TIME_FORMAT()</code> is similar to
      <code>DATE_FORMAT()</code>. It works with <code>TIME</code>, <code>DATETIME</code>, or <code>TIMESTAMP</code> values, but understands only
      time-related specifiers in the format string:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>TIME_FORMAT(dt, '%r') AS '12-hour time',</code></strong>
    -&gt; <strong><code>TIME_FORMAT(dt, '%T') AS '24-hour time'</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+--------------+--------------+
| dt                  | 12-hour time | 24-hour time |
+---------------------+--------------+--------------+
| 1970-01-01 00:00:00 | 12:00:00 AM  | 00:00:00     |
| 1999-12-31 09:00:00 | 09:00:00 AM  | 09:00:00     |
| 2000-06-04 15:45:30 | 03:45:30 PM  | 15:45:30     |
| 2017-03-16 12:30:15 | 12:30:15 PM  | 12:30:15     |
+---------------------+--------------+--------------+</pre><p>If <code>DATE_FORMAT()</code> or <code>TIME_FORMAT()</code> cannot produce the results that
      you want, write a stored function that does. Suppose that you want to
      convert 24-hour <code>TIME</code> values to
      12-hour format but with a suffix of <code>a.m.</code> or <code>p.m.</code> rather than <code>AM</code> or <code>PM</code>.
      The following function accomplishes that task. It uses <code>TIME_FORMAT()</code> to do most of the work, then
      strips the suffix supplied by <code>%r</code> and
      replaces it with the desired suffix:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">FUNCTION</code> <code class="n">time_ampm</code> <code class="p">(</code><code class="n">t</code> <code class="n">TIME</code><code class="p">)</code>
<code class="k">RETURNS</code> <code class="nb">VARCHAR</code><code class="p">(</code><code class="mi">13</code><code class="p">)</code> <code class="o">#</code> <code class="n">mm</code><code class="p">:</code><code class="n">dd</code><code class="p">:</code><code class="n">ss</code> <code class="err">{</code><code class="n">a</code><code class="p">.</code><code class="n">m</code><code class="p">.</code><code class="o">|</code><code class="n">p</code><code class="p">.</code><code class="n">m</code><code class="p">.</code><code class="err">}</code> <code class="n">format</code>
<code class="k">DETERMINISTIC</code>
<code class="k">RETURN</code> <code class="n">CONCAT</code><code class="p">(</code><code class="k">LEFT</code><code class="p">(</code><code class="n">TIME_FORMAT</code><code class="p">(</code><code class="n">t</code><code class="p">,</code> <code class="s1">'%r'</code><code class="p">),</code> <code class="mi">9</code><code class="p">),</code>
              <code class="n">IF</code><code class="p">(</code><code class="n">TIME_TO_SEC</code><code class="p">(</code><code class="n">t</code><code class="p">)</code> <code class="o">&lt;</code> <code class="mi">12</code><code class="o">*</code><code class="mi">60</code><code class="o">*</code><code class="mi">60</code><code class="p">,</code> <code class="s1">'a.m.'</code><code class="p">,</code> <code class="s1">'p.m.'</code><code class="p">));</code></pre><p>Use the function like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1, time_ampm(t1) FROM time_val;</code></strong>
+----------+---------------+
| t1       | time_ampm(t1) |
+----------+---------------+
| 15:00:00 | 03:00:00 p.m. |
| 05:01:30 | 05:01:30 a.m. |
| 12:30:20 | 12:30:20 p.m. |
+----------+---------------+</pre><p>For more information about writing stored functions, see <a data-type="xref" href="ch11.xhtml#nch-routines">Chapter 11</a>.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.4 Setting the Client Time Zone"><div class="sect1" id="nch-dates-dates-client-time-zone"><h1>8.4 Setting the Client Time Zone</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820371215472"><h2>Problem</h2><p>You have a client application that connects from a time zone different from the server.
      Consequently, when it stores <code>TIMESTAMP</code> values, they don’t have the correct
      UTC values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820371214112"><h2>Solution</h2><p>The client should set the <code>time_zone</code> system variable after connecting to the server.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820371212752"><h2>Discussion</h2><p>Time zone settings have an important effect on <code>TIMESTAMP</code>
      values:</p><ul><li><p>When the MySQL server starts, it examines its operating
          environment to determine its time zone. (To use a different value,
          start the server with the <code class="option">--default-time-zone</code>
          option.)</p></li><li><p>For each client that connects, the server interprets <code>TIMESTAMP</code> values with respect to the time
          zone associated with the client session. When a client inserts a
          <code>TIMESTAMP</code> value, the server
          converts it from the client time zone to UTC and stores the UTC value. (Internally, the server
          stores a <code>TIMESTAMP</code> value as the
          number of seconds since <code>1970-01-01</code> <code>00:00:00</code> UTC.) When the client retrieves a
          <code>TIMESTAMP</code> value, the server
          performs the reverse operation to convert the UTC value back to the
          client time zone.</p></li><li><p>The default session time zone for each client when it connects
          is the server time zone. If all clients are in the same time zone as
          the server, nothing special need be done for proper <code>TIMESTAMP</code> time zone conversion to occur.
          But if a client is in a time zone different from the server and it
          inserts <code>TIMESTAMP</code> values without
          making the proper time zone correction, the UTC values won’t be
          correct.</p></li></ul><p>Suppose that the server and client C1 are in the same time zone,
      and client C1 issues these statements:</p><pre data-type="programlisting">mysql&gt; <strong><code>CREATE TABLE t (ts TIMESTAMP);</code></strong>
mysql&gt; <strong><code>INSERT INTO t (ts) VALUES('2021-06-21 12:30:00');</code></strong>
mysql&gt; <strong><code>SELECT ts FROM t;</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2021-06-21 12:30:00 |
+---------------------+</pre><p>Here, client C1 sees the same value that it stored. A different
      client, C2, will also see the same value if it retrieves it, but if
      client C2 is in a different time zone, that value isn’t correct for its
      zone. Conversely, if client C2 stores a value, that value when returned
      by client C1 won’t be correct for the client C1 time zone.</p><p>To deal with this problem so that <code>TIMESTAMP</code> conversions use the proper time
      zone, a client should set its time zone explicitly by setting the
      session value of the <code>time_zone</code> system
      variable. Suppose that the server has a global time zone of six hours
      ahead of UTC. Each client initially is assigned that same value as its
      session time zone:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT @@global.time_zone, @@session.time_zone;</code></strong>
+--------------------+---------------------+
| @@global.time_zone | @@session.time_zone |
+--------------------+---------------------+
| SYSTEM             | SYSTEM              |
+--------------------+---------------------+</pre><p>When client C2 connects, it sees the same <code>TIMESTAMP</code> value as client C1:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT ts FROM t;</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2021-06-21 12:30:00 |
+---------------------+</pre><p>But that value is incorrect if client C2 is only four hours ahead
      of UTC. C2 should set its time zone after connecting so that retrieved
      <code>TIMESTAMP</code> values are properly
      adjusted for its own session:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET SESSION time_zone = '+04:00';</code></strong>
mysql&gt; <strong><code>SELECT @@global.time_zone, @@session.time_zone;</code></strong>
+--------------------+---------------------+
| @@global.time_zone | @@session.time_zone |
+--------------------+---------------------+
| SYSTEM             | +04:00              |
+--------------------+---------------------+
mysql&gt; <strong><code>SELECT ts FROM t;</code></strong>
+---------------------+
| ts                  |
+---------------------+
| 2021-06-21 16:30:00 |
+---------------------+</pre><p> To see the <code>System Timezone</code> 
      check global variables.</p><pre data-type="programlisting">mysql&gt; <strong><code>SHOW GLOBAL VARIABLES LIKE "system_time_zone";</code></strong>
+------------------+-------+
| Variable_name    | Value |
+------------------+-------+
| system_time_zone | UTC   |
+------------------+-------+</pre><p>The client time zone also affects the values displayed from
      functions that return the current date and time (see <a data-type="xref" href="#nch-dates-dates-current">Recipe 8.7</a>).</p></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820371212448"><h2>See Also</h2><p>To convert individual date-and-time values from one time zone
      to another, use the <code>CONVERT_TZ()</code> function (see <a data-type="xref" href="#nch-dates-dates-time-zone-convert">Recipe 8.6</a>).</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.5 Setting the Server Time Zone"><div class="sect1" id="nch-dates-dates-server-time-zone"><h1>8.5 Setting the Server Time Zone</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820371134304"><h2>Problem</h2><p>You have a localized application to serve customers, 
      but you want to have a global time zone setting. 
      </p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820371133200"><h2>Solution</h2><p>The server should set the <code>time_zone</code> system variable  to <code>SYSTEM</code> at the server.
        This setting should point to <code>UTC</code> value.
        Accordingly system timezone <code>system_time_zone</code>
        value should be set to <code>UTC</code>.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820371132208"><h2>Discussion</h2><p>MySQL Server maintains several time zone settings:
      </p><ul><li><p>The server system time zone. When MySQL starts it attempts to
          determine <code>system_time_zone</code> variable. In order to
          explicitly set the system time zone for MySQL set the <code>TZ</code>
          environment variable before starting <code>mysqld</code>. Alternatively
          start the <code>mysqld_safe</code> with its <code>--timezone</code>
          option. The values for these variables are permissible by your operating system settings.
          </p></li><li><p>The server current time zone is set by the global <code>time_zone</code>
          value. It’s generally set to <code>SYSTEM</code> on modern Linux operating systems.</p><pre data-type="programlisting">mysql&gt; <strong><code>SHOW GLOBAL VARIABLES LIKE "time_zone";</code></strong>
+---------------+--------+
| Variable_name | Value  |
+---------------+--------+
| time_zone     | SYSTEM |
+---------------+--------+</pre><p>You may choose to set the global timezone variable using 
         <code>SET GLOBAL</code> This will not change the <code> @@session.time_zone</code>
         value.
         </p><pre data-type="programlisting">mysql&gt; <strong><code>SET GLOBAL time_zone = "+03:00";</code></strong>
mysql&gt; <strong><code>SELECT @@global.time_zone, @@session.time_zone;</code></strong>
+--------------------+---------------------+
| @@global.time_zone | @@session.time_zone |
+--------------------+---------------------+
| +03:00             | SYSTEM              |
+--------------------+---------------------+</pre><p>The string indicating the <code>time_zone</code> value 
        offset from UTC (Universal Coordinated Time). Prior to MySQL 8.0.19, 
        this value had to be in the range '-12:59’ to '+13:00', inclusive; 
        beginning with MySQL 8.0.19, the permitted range is '-13:59’ to 
        '+14:00', inclusive. Populated time zones are not permitted unless they are
        pre-loaded to MySQL tables hence you can not use names like <code>UTC</code>:
        </p><pre data-type="programlisting">mysql&gt; <strong><code>SET GLOBAL time_zone = "US/Eastern" ;</code></strong>
ERROR 1298 (HY000): Unknown or incorrect time zone: 'US/Eastern'</pre><p>
        
        </p><p>For instructions on Populating the Timezone Tables see 
      <a href="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html#time-zone-installation">MySQL Reference
      Manual</a>.</p></li><li><p>The <code>system_time_zone</code> variable is set when the server
          inherits a time zone setting from the machine defaults. Unlike the <code>time_zone</code>
          variable this is not dynamic to set after the server starts. As of MySQL 8.0.26 if the server host
          time zone changes such as during daylight saving time <code>system_time_zone</code> will reflect 
          the change. If a change happens during execution of a query the previous value will be cached.
                </p><pre data-type="programlisting">mysql&gt; <strong><code>SHOW GLOBAL VARIABLES LIKE "system_time_zone";</code></strong>
+---------------+------------+
| Variable_name | Value      |
+---------------+------------+
| time_zone     | US/Eastern |
+---------------+------------+</pre><p>
        </p></li></ul></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.6 Shifting Temporal Values Between Time Zones"><div class="sect1" id="nch-dates-dates-time-zone-convert"><h1>8.6 Shifting Temporal Values Between Time Zones</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820371112080"><h2>Problem</h2><p>You have a date-and-time value, but need to know what it would be in a different time
      zone. For example, you’re having a teleconference with people in
      different parts of the world and you must tell them the meeting time in
      their local time zones.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820371111200"><h2>Solution</h2><p>Use the <code>CONVERT_TZ()</code>
      function.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820371109808"><h2>Discussion</h2><p>The <code>CONVERT_TZ()</code> function
      converts temporal values between time zones. It takes three arguments: a
      date-and-time value and two time zone indicators. The function
      interprets the date-and-time value as a value in the first time zone and
      returns the value shifted into the second time zone.</p><p>Suppose that we live in Chicago, Illinois in the US, and that we
      have a meeting with people in several other parts of the world. The
      <a data-type="xref" href="#nch-dates-dates-time-zone-convert-meeting">Table 8-3</a> shows the location of each meeting participant and the
      time zone name for each:</p><table id="nch-dates-dates-time-zone-convert-meeting"><caption><span class="label">Table 8-3. </span>Meeting participants</caption><thead><tr><th>Location</th><th>Time zone name</th></tr></thead><tbody><tr><td>Chicago, Illinois,
              US</td><td><code>US/Central </code></td></tr><tr><td>Istanbul, Turkey</td><td><code>Europe/Istanbul </code></td></tr><tr><td>London, United
              Kingdom</td><td><code>Europe/London </code></td></tr><tr><td>Edmonton, Alberta,
              Canada</td><td><code>America/Edmonton </code></td></tr><tr><td>Brisbane, Australia</td><td><code>Australia/Brisbane </code></td></tr></tbody></table><p>If the meeting is to take place at 8 AM local time for us on
      November 28, 2021, what time will that be for the other participants?
      The following statement uses <code>CONVERT_TZ()</code> to calculate the local times for
      each time zone:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @dt = '2021-11-28 08:00:00';</code></strong>
mysql&gt; <strong><code>SELECT @dt AS Chicago,</code></strong>
    -&gt; <strong><code>CONVERT_TZ(@dt,'US/Central','Europe/Istanbul') AS Istanbul,</code></strong>
    -&gt; <strong><code>CONVERT_TZ(@dt,'US/Central','Europe/London') AS London,</code></strong>
    -&gt; <strong><code>CONVERT_TZ(@dt,'US/Central','America/Edmonton') AS Edmonton,</code></strong>
    -&gt; <strong><code>CONVERT_TZ(@dt,'US/Central','Australia/Brisbane') AS Brisbane\G</code></strong>
*************************** 1. row ***************************
 Chicago: 2021-11-28 08:00:00
Istanbul: 2021-11-28 17:00:00
  London: 2021-11-28 14:00:00
Edmonton: 2021-11-28 07:00:00
Brisbane: 2021-11-29 00:00:00</pre><p>Let’s hope the Brisbane participant doesn’t mind being up after
      midnight.</p><p>The preceding example uses time zone names, so it requires that
      you have the time zone tables in the <code>mysql</code> database initialized with support for
      named time zones. (See the <a href="https://dev.mysql.com/doc/refman/8.0/en/time-zone-support.html">MySQL Reference Manual</a>
      for information about setting up the time zone tables.) If you can’t use
      named time zones, specify them in terms of their numeric relationship to
      UTC. (This can be a little trickier; you might need to account for
      daylight saving time.) The corresponding statement with numeric time zones
      looks like this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT @dt AS Chicago,</code></strong>
    -&gt; <strong><code>CONVERT_TZ(@dt,'-06:00','+03:00') AS Istanbul,</code></strong>
    -&gt; <strong><code>CONVERT_TZ(@dt,'-06:00','+00:00') AS London,</code></strong>
    -&gt; <strong><code>CONVERT_TZ(@dt,'-06:00','-07:00') AS Edmonton,</code></strong>
    -&gt; <strong><code>CONVERT_TZ(@dt,'-06:00','+10:00') AS Brisbane\G</code></strong>
*************************** 1. row ***************************
 Chicago: 2021-11-28 08:00:00
Istanbul: 2021-11-28 17:00:00
  London: 2021-11-28 14:00:00
Edmonton: 2021-11-28 07:00:00
Brisbane: 2021-11-29 00:00:00</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.7 Determining the Current Date or Time"><div class="sect1" id="nch-dates-dates-current"><h1>8.7 Determining the Current Date or Time</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820371089040"><h2>Problem</h2><p>You want to know what today’s date isand/or what time it is.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820371088096"><h2>Solution</h2><p>Use the <code>CURDATE()</code>, <code>CURTIME()</code>, or <code>NOW()</code> functions to obtain values expressed in the client session time zone.
      Use <code>UTC_DATE()</code>,
      <code>UTC_TIME()</code>, or <code>UTC_TIMESTAMP()</code> for values in UTC time.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820371087024"><h2>Discussion</h2><p>Some applications must know the current date or time, such as
      those that write timestamped log records. This kind of information is
      also useful for date calculations performed in relation to the current
      date, such as finding the first (or last) day of the month, or
      determining the date for Wednesday of next week.</p><p>The <code>CURDATE()</code> and <code>CURTIME()</code> functions return the current date
      and time separately, and <code>NOW()</code>
      returns both as a combined date-and-time value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CURDATE(), CURTIME(), NOW();</code></strong>
+------------+-----------+---------------------+
| CURDATE()  | CURTIME() | NOW()               |
+------------+-----------+---------------------+
| 2021-11-28 | 08:42:57  | 2021-11-28 08:42:57 |
+------------+-----------+---------------------+</pre><p><code>CURRENT_DATE</code>, <code>CURRENT_TIME</code>, and <code>CURRENT_TIMESTAMP</code> are synonyms for <code>CURDATE()</code>,
      <code>CURTIME()</code>, and <code>NOW()</code>, respectively.</p><p>The preceding functions return values in the client session time
      zone (see <a data-type="xref" href="#nch-dates-dates-client-time-zone">Recipe 8.4</a>). For
      values in UTC time, use the <code>UTC_DATE()</code>, <code>UTC_TIME()</code>, or <code>UTC_TIMESTAMP()</code> functions instead.</p><p>To determine the current date and time for an arbitrary time zone,
      pass the value of the appropriate UTC function to <code>CONVERT_TZ()</code> (see <a data-type="xref" href="#nch-dates-dates-time-zone-convert">Recipe 8.6</a>).</p><p>To obtain subparts of these values, such as the current day of the
      month or current hour of the day, use the decomposition techniques
      discussed in <a data-type="xref" href="#nch-dates-dates-decomp">Recipe 8.9</a>.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.8 Using TIMESTAMP or DATETIME to Track Row-Modification Times"><div class="sect1" id="nch-dates-dates-automatic"><h1>8.8 Using TIMESTAMP or DATETIME to Track Row-Modification Times</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820371070944"><h2>Problem</h2><p>You want to record row-creation time or last modification time
      automatically.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820371069888"><h2>Solution</h2><p>Use the auto-initialization and auto-update properties of the
      <code>TIMESTAMP</code> and <code>DATETIME</code> data types.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820371067904"><h2>Discussion</h2><p>MySQL supports <code>TIMESTAMP</code> and
      <code>DATETIME</code> data types that store
      date-and-time values. <a data-type="xref" href="#nch-dates-dates-types">Recipe 8.1</a> covers
      the range of values for these types. This recipe focuses on special
      column attributes that enable you to track row-creation and -update
      times automatically:</p><ul><li><p>A <code>TIMESTAMP</code> or <code>DATETIME</code> column declared with the <code>DEFAULT</code>
          <code>CURRENT_TIMESTAMP</code> attribute
          initializes automatically for new rows. Simply omit the column
          from <code>INSERT</code>
          statements and MySQL sets it to the row-creation time.</p></li><li><p>A <code>TIMESTAMP</code> or <code>DATETIME</code> column declared with the <code>ON</code> <code>UPDATE</code> <code>CURRENT_TIMESTAMP</code> attribute automatically
          updates to the current date and time when you change any other
          column in the row from its current value.</p></li></ul><p>These special properties make the <code>TIMESTAMP</code> and <code>DATETIME</code> data types particularly suited for
      applications that require recording the times at which rows are inserted
      or updated. The following discussion shows how to take advantage of
      these properties using <code>TIMESTAMP</code>
      columns. With some differences to be noted later, the discussion also
      applies to <code>DATETIME</code> columns.</p><div data-type="note" epub:type="note"><h6>Note</h6><p>The default <code>SQL_MODE</code> does not allow <code>NULL</code> values unless relaxed. Also <code>NO_ZERO_DATE</code> deprecated as of MySQL 8.0 
        should be used in conjunction with <code>STRICT MODE</code>.</p></div><p>Our example table looks like this:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">DROP</code> <code class="k">TABLE</code> <code class="n">IF</code> <code class="k">EXISTS</code> <code class="n">tsdemo</code><code class="p">;</code>
<code class="k">CREATE</code> <code class="k">TABLE</code> <code class="o">`</code><code class="n">tsdemo</code><code class="o">`</code> <code class="p">(</code>
<code class="o">`</code><code class="n">val</code><code class="o">`</code> <code class="nb">INT</code> <code class="n">UNSIGNED</code> <code class="k">NOT</code> <code class="k">NULL</code> <code class="n">AUTO_INCREMENT</code> <code class="k">PRIMARY</code> <code class="k">KEY</code><code class="p">,</code>
<code class="o">`</code><code class="n">ts_both</code><code class="o">`</code> <code class="k">TIMESTAMP</code> <code class="k">DEFAULT</code> <code class="k">CURRENT_TIMESTAMP</code> <code class="k">ON</code> <code class="k">UPDATE</code> <code class="k">CURRENT_TIMESTAMP</code><code class="p">,</code>
<code class="o">`</code><code class="n">ts_create</code><code class="o">`</code> <code class="k">TIMESTAMP</code> <code class="k">DEFAULT</code> <code class="k">CURRENT_TIMESTAMP</code><code class="p">,</code>
<code class="o">`</code><code class="n">ts_update</code><code class="o">`</code> <code class="k">TIMESTAMP</code> <code class="k">DEFAULT</code> <code class="k">CURRENT_TIMESTAMP</code> <code class="k">ON</code> <code class="k">UPDATE</code> <code class="k">CURRENT_TIMESTAMP</code>
<code class="p">)</code> <code class="n">ENGINE</code><code class="o">=</code><code class="n">InnoDB</code> <code class="p">;</code></pre><p>The <code>TIMESTAMP</code> columns have
      these properties:</p><ul><li><p><code>ts_both</code> auto-initializes
          and auto-updates. This is useful for tracking the time of any change
          to a row, for both inserts and updates.</p></li><li><p><code>ts_create</code> auto-initializes
          only. This is useful when you want a column to be set to the time at
          which a row is created, but remain constant thereafter.</p></li><li><p><code>ts_update</code> auto-updates
          only. It is set to the column default (or value you specify
          explicitly) at row-creation time and it auto-updates for changes to
          the row thereafter. The use cases for this are more limited—for
          example, to track row-creation and last-modification times
          separately (using <code>ts_update</code> in
          conjunction with <code>ts_create</code>),
          rather than together in a single column like <code>ts_both</code>.</p></li></ul><p>To see how the table works, insert some rows into the table (a few
      seconds apart so the timestamps differ), then select its
      contents:</p><pre data-type="programlisting">mysql&gt; <strong><code>INSERT INTO tsdemo (val,ts_both,ts_create,ts_update) 
    -&gt; VALUES(0,NULL,NULL,NULL);</code></strong>
mysql&gt; <strong><code>INSERT INTO tsdemo (val) VALUES(5);</code></strong>
mysql&gt; <strong><code>INSERT INTO tsdemo (val,ts_both,ts_create,ts_update)</code></strong>
    -&gt; <strong><code>VALUES(10,NULL,NULL,NULL);</code></strong>
mysql&gt; <strong><code>SELECT val, ts_both, ts_create, ts_update FROM tsdemo;</code></strong>
+-----+---------------------+---------------------+---------------------+
| val | ts_both             | ts_create           | ts_update           |
+-----+---------------------+---------------------+---------------------+
|   1 | 2022-03-06 14:34:17 | 2022-03-06 14:34:17 | 2022-03-06 14:34:17 |
|   5 | 2022-03-06 14:35:16 | 2022-03-06 14:35:16 | 2022-03-06 14:35:16 |
|  10 | 2022-03-06 14:35:34 | 2022-03-06 14:35:34 | 2022-03-06 14:35:34 |
+-----+---------------------+---------------------+---------------------+</pre><p>The first two <code>INSERT</code> statements
      shows that you can set the auto-initialize columns to the current date
      and time by omitting them from the <code>INSERT</code> statement entirely. The third insert shows
      that you can set a <code>TIMESTAMP</code> column
      to the current date and time by setting it explicitly to <code>NULL</code>, even one that does not auto-initialize.
      This <code>NULL</code>-assignment behavior is not
      specific to <code>INSERT</code> statements; it
      works for <code>UPDATE</code> as well. You
      can disable this special handling of <code>NULL</code> assignments, as we’ll cover later in this
      recipe.</p><p>To see auto-updating in action, issue a statement that changes one
      row’s <code>val</code> column and check its effect
      on the table’s contents. The result shows that the auto-update columns
      are updated (in the modified row only):</p><pre data-type="programlisting">mysql&gt; <strong><code>UPDATE tsdemo SET val = 11 WHERE val = 10;</code></strong>
mysql&gt; <strong><code>SELECT val, ts_both, ts_create, ts_update FROM tsdemo;</code></strong>
+-----+---------------------+---------------------+---------------------+
| val | ts_both             | ts_create           | ts_update           |
+-----+---------------------+---------------------+---------------------+
|   1 | 2022-03-06 14:34:17 | 2022-03-06 14:34:17 | 2022-03-06 14:34:17 |
|   5 | 2022-03-06 14:35:16 | 2022-03-06 14:35:16 | 2022-03-06 14:35:16 |
|  11 | 2022-03-06 14:38:04 | 2022-03-06 14:35:34 | 2022-03-06 14:38:04 |
+-----+---------------------+---------------------+---------------------+</pre><p>If you modify multiple rows, updates occur for the auto-update
      columns in each row:</p><pre data-type="programlisting">mysql&gt; <strong><code>UPDATE tsdemo SET val = val + 1;</code></strong>
mysql&gt; <strong><code>SELECT val, ts_both, ts_create, ts_update FROM tsdemo;</code></strong>
+-----+---------------------+---------------------+---------------------+
| val | ts_both             | ts_create           | ts_update           |
+-----+---------------------+---------------------+---------------------+
|   2 | 2022-03-06 14:38:45 | 2022-03-06 14:34:17 | 2022-03-06 14:38:45 |
|   6 | 2022-03-06 14:38:45 | 2022-03-06 14:35:16 | 2022-03-06 14:38:45 |
|  12 | 2022-03-06 14:38:45 | 2022-03-06 14:35:34 | 2022-03-06 14:38:45 |
+-----+---------------------+---------------------+---------------------+</pre><p>An <code>UPDATE</code> statement that
      doesn’t actually change any value in a row doesn’t modify auto-update
      columns. To see this, set every row’s <code>val</code> column to its current value, then review
      the table contents to see that auto-update columns retain their
      values:</p><pre data-type="programlisting">mysql&gt; <strong><code>UPDATE tsdemo SET val = val;</code></strong>
mysql&gt; <strong><code>SELECT val, ts_both, ts_create, ts_update FROM tsdemo;</code></strong>
+-----+---------------------+---------------------+---------------------+
| val | ts_both             | ts_create           | ts_update           |
+-----+---------------------+---------------------+---------------------+
|   2 | 2022-03-06 14:38:45 | 2022-03-06 14:34:17 | 2022-03-06 14:38:45 |
|   6 | 2022-03-06 14:38:45 | 2022-03-06 14:35:16 | 2022-03-06 14:38:45 |
|  12 | 2022-03-06 14:38:45 | 2022-03-06 14:35:34 | 2022-03-06 14:38:45 |
+-----+---------------------+---------------------+---------------------+</pre><p>As stated previously, automatic <code>TIMESTAMP</code> properties also apply to <code>DATETIME</code>, with some differences:</p><ul><li><p>For the first <code>TIMESTAMP</code>
          column in a table, if neither of the <code>DEFAULT</code> or <code>ON</code> <code>UPDATE</code> attributes are specified, the
          column is implicitly defined with both. For <code>DATETIME</code>, automatic properties never apply
          implicitly; only those specified explicitly.</p></li><li><p>It is not possible to set <code>NULL</code> to <code>TIMESTAMP</code> anymore.  To assign the current 
          timestamp, set the column to  <code>CURRENT_TIMESTAMP</code> or a synonym such as  
          <code>NOW()</code>.</p></li></ul><p>To determine for any given <code>TIMESTAMP</code> column what happens when <code>NULL</code> is assigned to it, use <code>SHOW</code> <code>CREATE</code>
      <code>TABLE</code> to see the column definition.
      If the definition includes the <code>NULL</code>
      attribute, assigning <code>NULL</code> stores
      <code>NULL</code>. If the definition includes the
      <code>NOT</code> <code>NULL</code> attribute, you can specify <code>NULL</code> as the value to be assigned, but you
      cannot <em>store</em> <code>NULL</code> because MySQL stores the current date and
      time instead.</p></div></section><section data-type="sect2" data-pdf-bookmark="See Also"><div class="sect2" id="idm45820370932432"><h2>See Also</h2><p>To simulate <code>TIMESTAMP</code>
      auto-initialization and auto-update properties for other temporal types,
      you can use triggers (see <a data-type="xref" href="ch11.xhtml#nch-routines">Chapter 11</a>). </p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.9 Extracting Parts of Dates or Times"><div class="sect1" id="nch-dates-dates-decomp"><h1>8.9 Extracting Parts of Dates or Times</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370923632"><h2>Problem</h2><p>You want to obtain just a part of a date or a time.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370922592"><h2>Solution</h2><p>Invoke a function specifically intended for extracting part of a
      temporal value, such as <code>MONTH()</code> or <code>MINUTE()</code>. This is usually the fastest method
      for component extraction if you need only a single component of a value.
      Alternatively, use a formatting function such as <code>DATE_FORMAT()</code> or <code>TIME_FORMAT()</code> with a format string that includes a specifier for the part of
      the value you want to obtain.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370919504"><h2>Discussion</h2><p>The following discussion shows different ways to extract parts of
      temporal values.</p><section data-type="sect3" data-pdf-bookmark="Decomposing dates or times using component-extraction&#10;        functions"><div class="sect3" id="idm45820370918448"><h3>Decomposing dates or times using component-extraction
        functions</h3><p>MySQL includes many functions for extracting date and time
        subparts. For example, <code>DATE()</code> and
        <code>TIME()</code> extract the date and time
        components of temporal values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt, DATE(dt), TIME(dt) FROM datetime_val;</code></strong>
+---------------------+------------+----------+
| dt                  | DATE(dt)   | TIME(dt) |
+---------------------+------------+----------+
| 1970-01-01 00:00:00 | 1970-01-01 | 00:00:00 |
| 1999-12-31 09:00:00 | 1999-12-31 | 09:00:00 |
| 2000-06-04 15:45:30 | 2000-06-04 | 15:45:30 |
| 2017-03-16 12:30:15 | 2017-03-16 | 12:30:15 |
+---------------------+------------+----------+</pre><p>The <a data-type="xref" href="#nch-dates-dates-decomp-extract">Table 8-4</a> shows some several component-extraction
        functions; consult the <a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days">MySQL Reference
        Manual</a> for
        a complete list. The date-related functions work with <code>DATE</code>, <code>DATETIME</code>, or <code>TIMESTAMP</code> values. The time-related functions
        work with <code>TIME</code>, <code>DATETIME</code>, or <code>TIMESTAMP</code> values:</p><table id="nch-dates-dates-decomp-extract"><caption><span class="label">Table 8-4. </span>Component-extraction functions</caption><thead><tr><th>Function</th><th>Return value</th></tr></thead><tbody><tr><td><code>YEAR() </code></td><td>Year of date</td></tr><tr><td><code>MONTH() </code></td><td>Month number
                (1..12)</td></tr><tr><td><code>MONTHNAME() </code></td><td>Month name (January..December)</td></tr><tr><td><code>DAYOFMONTH() </code></td><td>Day of month (1..31)</td></tr><tr><td><code>DAYNAME() </code></td><td>Day name (Sunday..Saturday)</td></tr><tr><td><code>DAYOFWEEK() </code></td><td>Day of week (1..7 for Sunday..Saturday)</td></tr><tr><td><code>WEEKDAY() </code></td><td>Day of week (0..6 for Monday..Sunday)</td></tr><tr><td><code>DAYOFYEAR() </code></td><td>Day of year (1..366)</td></tr><tr><td><code>HOUR() </code></td><td>Hour of time (0..23)</td></tr><tr><td><code>MINUTE() </code></td><td>Minute of time
                (0..59)</td></tr><tr><td><code>SECOND() </code></td><td>Second of time (0..59)</td></tr><tr><td><code>MICROSECOND() </code></td><td>Microsecond of time (0..59)</td></tr><tr><td><code>EXTRACT() </code></td><td>Varies</td></tr></tbody></table><p>Here’s an example:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt, YEAR(dt), DAYOFMONTH(dt), HOUR(dt), SECOND(dt)</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+----------+----------------+----------+------------+
| dt                  | YEAR(dt) | DAYOFMONTH(dt) | HOUR(dt) | SECOND(dt) |
+---------------------+----------+----------------+----------+------------+
| 1970-01-01 00:00:00 |     1970 |              1 |        0 |          0 |
| 1999-12-31 09:00:00 |     1999 |             31 |        9 |          0 |
| 2000-06-04 15:45:30 |     2000 |              4 |       15 |         30 |
| 2017-03-16 12:30:15 |     2017 |             16 |       12 |         15 |
+---------------------+----------+----------------+----------+------------+</pre><pre data-type="programlisting">mysql&gt; <strong><code>set @date_time="2021-11-24 22:11:12.000201";</code></strong>
    -&gt; <strong><code>SELECT HOUR(@date_time) as Hour, MINUTE(@date_time) 
    -&gt;  as Minute,SECOND(@date_time) as Second, MICROSECOND(@date_time) as MicroSecond;</code></strong>
+------+--------+--------+-------------+
| Hour | Minute | Second | MicroSecond |
+------+--------+--------+-------------+
|   22 |     11 |     12 |         201 |
+------+--------+--------+-------------+</pre><p>Functions such as <code>YEAR()</code> or
        <code>DAYOFMONTH()</code> extract values that
        have an obvious correspondence to a substring of the temporal value to
        which you apply them. Other component-extraction functions provide
        access to values that have no such correspondence. One is the
        day-of-year value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DAYOFYEAR(d) FROM date_val;</code></strong>
+------------+--------------+
| d          | DAYOFYEAR(d) |
+------------+--------------+
| 1864-02-28 |           59 |
| 1900-01-15 |           15 |
| 1999-12-31 |          365 |
| 2000-06-04 |          156 |
| 2017-03-16 |           75 |
+------------+--------------+</pre><p>Another is the day of the week, which is available by name or
        number:</p><ul><li><p><code>DAYNAME()</code> returns the
            complete day name. There is a <code>DATE_FORMAT(d, '%a')</code>  function for returning the
            three-character name abbreviation, that you can get it easily by
            passing the full name to <code>DATE_FORMAT()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DAYNAME(d), DATE_FORMAT(d, '%a') FROM date_val;</code></strong>
+------------+------------+----------------------+
| d          | DAYNAME(d) | DATE_FORMAT(d, '%a') |
+------------+------------+----------------------+
| 1864-02-28 | Sunday     | Sun                  |
| 1900-01-15 | Monday     | Mon                  |
| 1999-12-31 | Friday     | Fri                  |
| 2000-06-04 | Sunday     | Sun                  |
| 2017-03-16 | Thursday   | Thu                  |
+------------+------------+----------------------+</pre></li><li><p>To get the day of the week as a number, use <code>DAYOFWEEK()</code> or <code>WEEKDAY()</code>, but pay attention to the
            range of values each function returns. <code>DAYOFWEEK()</code> returns values from 1 to 7,
            corresponding to Sunday through Saturday. <code>WEEKDAY()</code> returns values from 0 to 6,
            corresponding to Monday through Sunday:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DAYNAME(d), DAYOFWEEK(d), WEEKDAY(d) FROM date_val;</code></strong>
+------------+------------+--------------+------------+
| d          | DAYNAME(d) | DAYOFWEEK(d) | WEEKDAY(d) |
+------------+------------+--------------+------------+
| 1864-02-28 | Sunday     |            1 |          6 |
| 1900-01-15 | Monday     |            2 |          0 |
| 1999-12-31 | Friday     |            6 |          4 |
| 2000-06-04 | Sunday     |            1 |          6 |
| 2017-03-16 | Thursday   |            5 |          3 |
+------------+------------+--------------+------------+</pre></li></ul><p><code>EXTRACT()</code> is another function
        for obtaining individual parts of temporal values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt, EXTRACT(DAY FROM dt), EXTRACT(HOUR FROM dt)</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+----------------------+-----------------------+
| dt                  | EXTRACT(DAY FROM dt) | EXTRACT(HOUR FROM dt) |
+---------------------+----------------------+-----------------------+
| 1970-01-01 00:00:00 |                    1 |                     0 |
| 1999-12-31 09:00:00 |                   31 |                     9 |
| 2000-06-04 15:45:30 |                    4 |                    15 |
| 2017-03-16 12:30:15 |                   16 |                    12 |
+---------------------+----------------------+-----------------------+</pre><p>The keyword indicating what to extract from the value should be
        a unit specifier such as <code>YEAR</code>,
        <code>MONTH</code>, <code>DAY</code>, <code>HOUR</code>, <code>MINUTE</code>, or <code>SECOND</code>. Unit specifiers are singular, not
        plural. (Check the <a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days">MySQL Reference
        Manual</a> for the
        full list.)</p><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820370880976"><h5>Obtaining the Current Year, Month, Day, Hour, Minute, or
          Second</h5><p>To obtain the current year, month, day, or day of week, apply the extraction functions shown in
          this recipe to <code>CURDATE()</code> or
          <code>NOW()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CURDATE(), YEAR(CURDATE()) AS year,</code></strong>
    -&gt; <strong><code>MONTH(CURDATE()) AS month, MONTHNAME(CURDATE()) AS monthname,</code></strong>
    -&gt; <strong><code>DAYOFMONTH(CURDATE()) AS day, DAYNAME(CURDATE()) AS dayname;</code></strong>
+------------+------+-------+-----------+------+-----------+
| CURDATE()  | year | month | monthname | day  | dayname   |
+------------+------+-------+-----------+------+-----------+
| 2021-11-24 | 2021 |    11 | November  |   24 | Wednesday |
+------------+------+-------+-----------+------+-----------+</pre><p>Similarly, to obtain the current hour, minute, or second,
          pass <code>CURTIME()</code> or
          <code>NOW()</code> to a time-component
          function:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT NOW(), HOUR(NOW()) AS hour,</code></strong>
    -&gt; <strong><code>MINUTE(NOW()) AS minute, SECOND(NOW()) AS second;</code></strong>
+---------------------+------+--------+--------+
| NOW()               | hour | minute | second |
+---------------------+------+--------+--------+
| 2021-11-24 06:55:40 |    6 |     55 |     40 |
+---------------------+------+--------+--------+</pre></div></aside></div></section><section data-type="sect3" data-pdf-bookmark="Decomposing dates or times using formatting functions"><div class="sect3" id="idm45820370918144"><h3>Decomposing dates or times using formatting functions</h3><p>The <code>DATE_FORMAT()</code> and
        <code>TIME_FORMAT()</code> functions reformat date and time values. By specifying appropriate
        format strings, you can extract individual parts of temporal
        values:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>DATE_FORMAT(dt,'%Y') AS year,</code></strong>
    -&gt; <strong><code>DATE_FORMAT(dt,'%d') AS day,</code></strong>
    -&gt; <strong><code>TIME_FORMAT(dt,'%H') AS hour,</code></strong>
    -&gt; <strong><code>TIME_FORMAT(dt,'%s') AS second</code></strong>
    -&gt; <strong><code>TIME_FORMAT(dt,'%f') AS microsecond</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+------+------+------+--------+-------------+
| dt                  | year | day  | hour | second | microsecond |
+---------------------+------+------+------+--------+-------------+
| 1970-01-01 00:00:00 | 1970 | 01   | 00   | 00     | 000000      |
| 1999-12-31 09:00:00 | 1999 | 31   | 09   | 00     | 000000      |
| 2000-06-04 15:45:30 | 2000 | 04   | 15   | 30     | 000000      |
| 2017-03-16 12:30:15 | 2017 | 16   | 12   | 15     | 000000      |
+---------------------+------+------+------+--------+-------------+</pre><p>Formatting functions are advantageous when you want to extract
        more than one part of a value, or display extracted values in a format
        different from the default. For example, to extract the entire date or
        time from <code>DATETIME</code> values,
        do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>DATE_FORMAT(dt,'%Y-%m-%d') AS 'date part',</code></strong>
    -&gt; <strong><code>TIME_FORMAT(dt,'%T') AS 'time part'</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+------------+-----------+
| dt                  | date part  | time part |
+---------------------+------------+-----------+
| 1970-01-01 00:00:00 | 1970-01-01 | 00:00:00  |
| 1999-12-31 09:00:00 | 1999-12-31 | 09:00:00  |
| 2000-06-04 15:45:30 | 2000-06-04 | 15:45:30  |
| 2017-03-16 12:30:15 | 2017-03-16 | 12:30:15  |
+---------------------+------------+-----------+</pre><p>To present a date in other than
        <em><code>YYYY-MM-DD</code></em> format or a time without the
        seconds part, do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>DATE_FORMAT(dt,'%M %e, %Y') AS 'descriptive date',</code></strong>
    -&gt; <strong><code>TIME_FORMAT(dt,'%H:%i') AS 'hours/minutes'</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+-------------------+---------------+
| dt                  | descriptive date  | hours/minutes |
+---------------------+-------------------+---------------+
| 1970-01-01 00:00:00 | January 1, 1970   | 00:00         |
| 1999-12-31 09:00:00 | December 31, 1999 | 09:00         |
| 2000-06-04 15:45:30 | June 4, 2000      | 15:45         |
| 2017-03-16 12:30:15 | March 16, 2017    | 12:30         |
+---------------------+-------------------+---------------+</pre></div></section></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.10 Synthesizing Dates or Times from Component Values"><div class="sect1" id="nch-dates-dates-synth"><h1>8.10 Synthesizing Dates or Times from Component Values</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370854208"><h2>Problem</h2><p>You want to combine the parts of a date or time to produce a complete date or time
      value. Or you want to replace parts of a date to produce another
      date.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370853264"><h2>Solution</h2><p>You have several options:</p><ul><li><p>Use <code>MAKETIME()</code> to construct
          a <code>TIME</code> value from hour, minute, and second parts.</p></li><li><p>Use <code>DATE_FORMAT()</code> or
          <code>TIME_FORMAT()</code> to combine
          parts of the existing value with parts you want to
          replace.</p></li><li><p>Pull out the parts that you need with component-extraction functions and recombine the parts
          with <code>CONCAT()</code>.</p></li></ul></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370848400"><h2>Discussion</h2><p>The reverse of splitting a date or time value into components is
      synthesizing a temporal value from its constituent parts. Techniques for
      date and time synthesis include using composition functions, formatting
      functions, and string concatenation.</p><p>The <code>MAKETIME()</code> function takes
      component hour, minute, and second values as arguments and combines them
      to produce a time:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT MAKETIME(10,30,58), MAKETIME(-5,0,11);</code></strong>
+--------------------+-------------------+
| MAKETIME(10,30,58) | MAKETIME(-5,0,11) |
+--------------------+-------------------+
| 10:30:58           | -05:00:11         |
+--------------------+-------------------+</pre><p>Date synthesis often is performed beginning with a given date,
      then keeping parts that you want to use and replacing the rest. For
      example, to produce the first day of the month in which a date falls,
      use <code>DATE_FORMAT()</code> to extract the year
      and month parts from the date, combining them with a day part of
      <code>01</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DATE_FORMAT(d,'%Y-%m-01') FROM date_val;</code></strong>
+------------+---------------------------+
| d          | DATE_FORMAT(d,'%Y-%m-01') |
+------------+---------------------------+
| 1864-02-28 | 1864-02-01                |
| 1900-01-15 | 1900-01-01                |
| 1999-12-31 | 1999-12-01                |
| 2000-06-04 | 2000-06-01                |
| 2017-03-16 | 2017-03-01                |
+------------+---------------------------+</pre><p><code>TIME_FORMAT()</code> can be used
      similarly. The following example produces time values that have the
      seconds part set to <code>00</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1, TIME_FORMAT(t1,'%H:%i:00') FROM time_val;</code></strong>
+----------+----------------------------+
| t1       | TIME_FORMAT(t1,'%H:%i:00') |
+----------+----------------------------+
| 15:00:00 | 15:00:00                   |
| 05:01:30 | 05:01:00                   |
| 12:30:20 | 12:30:00                   |
+----------+----------------------------+</pre><p>Another way to construct temporal values is to use date-part
      extraction functions in conjunction with <code>CONCAT()</code>. However, this method often is
      messier than the <code>DATE_FORMAT()</code>
      technique just discussed, and it sometimes yields slightly different
      results:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, CONCAT(YEAR(d),'-',MONTH(d),'-01') FROM date_val;</code></strong>
+------------+------------------------------------+
| d          | CONCAT(YEAR(d),'-',MONTH(d),'-01') |
+------------+------------------------------------+
| 1864-02-28 | 1864-2-01                          |
| 1900-01-15 | 1900-1-01                          |
| 1999-12-31 | 1999-12-01                         |
| 2000-06-04 | 2000-6-01                          |
| 2017-03-16 | 2017-3-01                          |
+------------+------------------------------------+</pre><p>Note that the month values in some of these dates have only a
      single digit. To ensure that the month has two digits—as required for
      ISO format—use <code>LPAD()</code> to add a leading zero as necessary:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, CONCAT(YEAR(d),'-',LPAD(MONTH(d),2,'0'),'-01')</code></strong>
    -&gt; <strong><code>FROM date_val;</code></strong>
+------------+------------------------------------------------+
| d          | CONCAT(YEAR(d),'-',LPAD(MONTH(d),2,'0'),'-01') |
+------------+------------------------------------------------+
| 1864-02-28 | 1864-02-01                                     |
| 1900-01-15 | 1900-01-01                                     |
| 1999-12-31 | 1999-12-01                                     |
| 2000-06-04 | 2000-06-01                                     |
| 2017-03-16 | 2017-03-01                                     |
+------------+------------------------------------------------+</pre><p><a data-type="xref" href="#nch-dates-dates-canonize">Recipe 8.18</a> shows other ways to
      solve the problem of producing ISO dates from not-quite-ISO
      dates.</p><p><code>TIME</code> values can be produced
      from hours, minutes, and seconds values using methods analogous to those
      for creating <code>DATE</code> values. For
      example, to change a <code>TIME</code> value so
      that its seconds part is <code>00</code>, extract
      the hour and minute parts, and then recombine them with <code>CONCAT()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1,</code></strong>
    -&gt; <strong><code>CONCAT(LPAD(HOUR(t1),2,'0'),':',LPAD(MINUTE(t1),2,'0'),':00')</code></strong>
    -&gt;   <strong><code>AS recombined</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+----------+------------+
| t1       | recombined |
+----------+------------+
| 15:00:00 | 15:00:00   |
| 05:01:30 | 05:01:00   |
| 12:30:20 | 12:30:00   |
+----------+------------+</pre><p>To produce a combined date-and-time value from separate date and
      time values, simply concatenate them separated by a space:</p><pre data-type="programlisting">mysql&gt; <strong><code> SET @d = '2009-06-03', @t = '16:15:08';</code></strong>
mysql&gt; <strong><code>SELECT @d, @t, CONCAT(@d,' ',@t);</code></strong>
+------------+----------+---------------------+
| @d         | @t       | CONCAT(@d,' ',@t)   |
+------------+----------+---------------------+
| 2009-06-03 | 16:15:08 | 2009-06-03 16:15:08 |
+------------+----------+---------------------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.11 Converting Between Temporal Values and Basic Units"><div class="sect1" id="nch-dates-dates-basic-units"><h1>8.11 Converting Between Temporal Values and Basic Units</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370824448"><h2>Problem</h2><p>You want to convert a temporal value such as a time or date to basic units such
      as seconds or days. This is often useful or necessary for performing
      temporal arithmetic operations (see <a data-type="xref" href="#nch-dates-dates-calc-difference">Recipe 8.12</a> and <a data-type="xref" href="#nch-dates-dates-calc-sum">Recipe 8.13</a>).</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370821536"><h2>Solution</h2><p>The conversion method depends on the type of value to be
      converted:</p><ul><li><p>To convert between time values and seconds, use the <code>TIME_TO_SEC()</code>
          and <code>SEC_TO_TIME()</code>
          functions.</p></li><li><p>To convert between date values and days, use the <code>TO_DAYS()</code>
          and <code>FROM_DAYS()</code> functions.</p></li><li><p>To convert between date-and-time values and seconds, use
          the <code>UNIX_TIMESTAMP()</code> and <code>FROM_UNIXTIME()</code> functions.</p></li></ul></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370816192"><h2>Discussion</h2><p>The following discussion shows how to convert several types of
      temporal values to basic units and vice versa.</p><section data-type="sect3" data-pdf-bookmark="Converting between times and seconds"><div class="sect3" id="idm45820370815152"><h3>Converting between times and seconds</h3><p><code>TIME</code> values are specialized
        representations of a simpler unit (seconds). To convert from one to
        the other, use the <code>TIME_TO_SEC()</code>
        and <code>SEC_TO_TIME()</code> functions.</p><p><code>TIME_TO_SEC()</code> converts a
        <code>TIME</code> value to the equivalent number of seconds, and <code>SEC_TO_TIME()</code> does the opposite. The
        following statement demonstrates a simple conversion in both
        directions:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1,</code></strong>
    -&gt; <strong><code>TIME_TO_SEC(t1) AS 'TIME to seconds',</code></strong>
    -&gt; <strong><code>SEC_TO_TIME(TIME_TO_SEC(t1)) AS 'TIME to seconds to TIME'</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+----------+-----------------+-------------------------+
| t1       | TIME to seconds | TIME to seconds to TIME |
+----------+-----------------+-------------------------+
| 15:00:00 |           54000 | 15:00:00                |
| 05:01:30 |           18090 | 05:01:30                |
| 12:30:20 |           45020 | 12:30:20                |
+----------+-----------------+-------------------------+</pre><p>To express time values as minutes, hours, or days, perform the
        appropriate divisions:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1,</code></strong>
    -&gt; <strong><code>TIME_TO_SEC(t1) AS 'seconds',</code></strong>
    -&gt; <strong><code>TIME_TO_SEC(t1)/60 AS 'minutes',</code></strong>
    -&gt; <strong><code>TIME_TO_SEC(t1)/(60*60) AS 'hours',</code></strong>
    -&gt; <strong><code>TIME_TO_SEC(t1)/(24*60*60) AS 'days'</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+----------+---------+----------+---------+--------+
| t1       | seconds | minutes  | hours   | days   |
+----------+---------+----------+---------+--------+
| 15:00:00 |   54000 | 900.0000 | 15.0000 | 0.6250 |
| 05:01:30 |   18090 | 301.5000 |  5.0250 | 0.2094 |
| 12:30:20 |   45020 | 750.3333 | 12.5056 | 0.5211 |
+----------+---------+----------+---------+--------+</pre><p>Use <code>FLOOR()</code> on the division results if you prefer integer values that have
        no fractional part.</p><p>If you pass <code>TIME_TO_SEC()</code> a
        date-and-time value, it extracts the time part and discards the date.
        This provides another means of extracting times from <code>DATETIME</code> (or
        <code>TIMESTAMP</code>) values, in addition to
        those already discussed in <a data-type="xref" href="#nch-dates-dates-decomp">Recipe 8.9</a>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>TIME_TO_SEC(dt) AS 'time part in seconds',</code></strong>
    -&gt; <strong><code>SEC_TO_TIME(TIME_TO_SEC(dt)) AS 'time part as TIME'</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+----------------------+-------------------+
| dt                  | time part in seconds | time part as TIME |
+---------------------+----------------------+-------------------+
| 1970-01-01 00:00:00 |                    0 | 00:00:00          |
| 1999-12-31 09:00:00 |                32400 | 09:00:00          |
| 2000-06-04 15:45:30 |                56730 | 15:45:30          |
| 2017-03-16 12:30:15 |                45015 | 12:30:15          |
+---------------------+----------------------+-------------------+</pre></div></section><section data-type="sect3" data-pdf-bookmark="Converting between dates and days"><div class="sect3" id="idm45820370797328"><h3>Converting between dates and days</h3><p>If you have a date but want a value in days, or vice versa, use the <code>TO_DAYS()</code> and <code>FROM_DAYS()</code> functions. Date-and-time values
        also can be converted to days if you can suffer loss of the time
        part since the year 0.</p><p><code>TO_DAYS()</code> converts a date to
        the corresponding number of days, and <code>FROM_DAYS()</code> does the opposite:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d,</code></strong>
    -&gt; <strong><code>TO_DAYS(d) AS 'DATE to days',</code></strong>
    -&gt; <strong><code>FROM_DAYS(TO_DAYS(d)) AS 'DATE to days to DATE'</code></strong>
    -&gt; <strong><code>FROM date_val;</code></strong>
+------------+--------------+----------------------+
| d          | DATE to days | DATE to days to DATE |
+------------+--------------+----------------------+
| 1864-02-28 |       680870 | 1864-02-28           |
| 1900-01-15 |       693975 | 1900-01-15           |
| 1999-12-31 |       730484 | 1999-12-31           |
| 2000-06-04 |       730640 | 2000-06-04           |
| 2017-03-16 |       736769 | 2017-03-16           |
+------------+--------------+----------------------+</pre><p>When using <code>TO_DAYS()</code>, it’s
        best to stick to the advice of the <a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days">MySQL Reference
        Manual</a> and avoid <code>DATE</code>
        values that occur before the beginning of the Gregorian calendar
        (1582). Changes in the lengths of calendar years and months prior to
        that date make it difficult to speak meaningfully of what the value of
        <q>day 0</q> might be. This differs from <code>TIME_TO_SEC()</code>, where the correspondence
        between a <code>TIME</code> value and the
        resulting seconds value is obvious and has a meaningful reference
        point of 0 seconds.</p><p>If you pass <code>TO_DAYS()</code> a
        date-and-time value, it extracts the date part and discards the time.
        This provides another means of extracting dates from <code>DATETIME</code> (or <code>TIMESTAMP</code>) values, in addition to those
        already discussed in <a data-type="xref" href="#nch-dates-dates-decomp">Recipe 8.9</a>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>TO_DAYS(dt) AS 'date part in days',</code></strong>
    -&gt; <strong><code>FROM_DAYS(TO_DAYS(dt)) AS 'date part as DATE'</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+-------------------+-------------------+
| dt                  | date part in days | date part as DATE |
+---------------------+-------------------+-------------------+
| 1970-01-01 00:00:00 |            719528 | 1970-01-01        |
| 1999-12-31 09:00:00 |            730484 | 1999-12-31        |
| 2000-06-04 15:45:30 |            730640 | 2000-06-04        |
| 2017-03-16 12:30:15 |            736769 | 2017-03-16        |
+---------------------+-------------------+-------------------+</pre></div></section><section data-type="sect3" data-pdf-bookmark="Converting between date-and-time values and seconds"><div class="sect3" id="idm45820370781952"><h3>Converting between date-and-time values and seconds</h3><p>For <code>DATETIME</code> or <code>TIMESTAMP</code> values that lie within the range of the <code>TIMESTAMP</code> data type (from the beginning of
        1970 partially through 2038), the <code>UNIX_TIMESTAMP()</code>
        and <code>FROM_UNIXTIME()</code> functions
        convert to and from the number of seconds elapsed since the beginning
        of 1970. The conversion to seconds offers higher precision for
        date-and-time values than a conversion to days, at the cost of a more
        limited range of values for which the conversion may be performed
        (<code>TIME_TO_SEC()</code> is unsuitable for
        this because it discards the date):</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>UNIX_TIMESTAMP(dt) AS seconds,</code></strong>
    -&gt; <strong><code>FROM_UNIXTIME(UNIX_TIMESTAMP(dt)) AS timestamp</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+------------+---------------------+
| dt                  | seconds    | timestamp           |
+---------------------+------------+---------------------+
| 1970-01-01 00:00:00 |      21600 | 1970-01-01 00:00:00 |
| 1999-12-31 09:00:00 |  946652400 | 1999-12-31 09:00:00 |
| 2000-06-04 15:45:30 |  960151530 | 2000-06-04 15:45:30 |
| 2017-03-16 12:30:15 | 1489685415 | 2017-03-16 12:30:15 |
+---------------------+------------+---------------------+</pre><p>There is a relationship between <q>UNIX</q> in the
        function names and the fact that the applicable range of values begins
        with 1970: the <q>Unix epoch</q> begins at <code>1970-01-01</code>
        <code>00:00:00</code> UTC. The epoch is time
        zero, or the reference point for measuring time in Unix systems. That
        being so, you may find it curious that the preceding example shows a
        <code>UNIX_TIMESTAMP()</code> value of <code>21600</code> for the first value in the <code>datetime_val</code> table. Why isn’t it <code>0</code>? The apparent discrepancy is due to the
        fact that the MySQL server interprets the <code>UNIX_TIMESTAMP()</code> argument as a value in the
        client’s local time zone and converts it to UTC (see <a data-type="xref" href="#nch-dates-dates-client-time-zone">Recipe 8.4</a>). Our server is in the US
        Central time zone, six hours (21,600 seconds) west of UTC. The 
        <code> DATETIME</code> interpreted based on the time zone and the 
        numbers would not change with a timestamp. 
        Change the session time zone to <code>'+00:00'</code> for
        UTC time and run the query again to observe a different result:</p><pre data-type="programlisting">mysql&gt; <strong><code>set time_zone = '+00:00';</code></strong>
mysql&gt; <strong><code>SELECT dt,</code></strong>
    -&gt; <strong><code>UNIX_TIMESTAMP(dt) AS seconds,</code></strong>
    -&gt; <strong><code>FROM_UNIXTIME(UNIX_TIMESTAMP(dt)) AS timestamp</code></strong>
    -&gt; <strong><code>FROM datetime_val;</code></strong>
+---------------------+------------+---------------------+
| dt                  | seconds    | timestamp           |
+---------------------+------------+---------------------+
| 1970-01-01 00:00:00 |          0 | 1970-01-01 00:00:00 |
| 1999-12-31 09:00:00 |  946630800 | 1999-12-31 09:00:00 |
| 2000-06-04 15:45:30 |  960133530 | 2000-06-04 15:45:30 |
| 2017-03-16 12:30:15 | 1489667415 | 2017-03-16 12:30:15 |
+---------------------+------------+---------------------+</pre><p><code>UNIX_TIMESTAMP()</code> can
        convert <code>DATE</code> values
        to seconds, too. It treats such values as having an implicit
        time-of-day part of <code>00:00:00</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>CURDATE(),</code></strong>
    -&gt; <strong><code>UNIX_TIMESTAMP(CURDATE()),</code></strong>
    -&gt; <strong><code>FROM_UNIXTIME(UNIX_TIMESTAMP(CURDATE()))\G</code></strong>
*************************** 1. row ***************************
                               CURDATE(): 2021-11-28
               UNIX_TIMESTAMP(CURDATE()): 1638046800
FROM_UNIXTIME(UNIX_TIMESTAMP(CURDATE())): 2021-11-28 00:00:00</pre></div></section></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.12 Calculating Intervals Between Dates or Times"><div class="sect1" id="nch-dates-dates-calc-difference"><h1>8.12 Calculating Intervals Between Dates or Times</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370759168"><h2>Problem</h2><p>You want to know how long it is between two dates or times; that is, the
      interval between them.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370758176"><h2>Solution</h2><p>To calculate an interval, use one of the temporal-difference
      functions, or convert your values to basic units and take the
      difference. The permitted functions depend on the types of the values
      for which you want to know the interval.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370757232"><h2>Discussion</h2><p>The following discussion shows several ways to perform interval
      calculations.</p><section data-type="sect3" data-pdf-bookmark="Calculating intervals with temporal-difference&#10;        functions"><div class="sect3" id="idm45820370756288"><h3>Calculating intervals with temporal-difference
        functions</h3><p>To calculate an interval in days between two date values, use the <code>DATEDIFF()</code> function:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @d1 = '2010-01-01', @d2 = '2009-12-01';</code></strong>
mysql&gt; <strong><code>SELECT DATEDIFF(@d1,@d2) AS 'd1 - d2', DATEDIFF(@d2,@d1) AS 'd2 - d1';</code></strong>
+---------+---------+
| d1 - d2 | d2 - d1 |
+---------+---------+
|      31 |     -31 |
+---------+---------+</pre><p><code>DATEDIFF()</code> also works with
        date-and-time values, but ignores the time part. This makes it
        suitable for producing day intervals for <code>DATE</code>,
        <code>DATETIME</code>, or <code>TIMESTAMP</code> values.</p><p>To calculate an interval between <code>TIME</code> values as another <code>TIME</code> value,
        use the <code>TIMEDIFF()</code>
        function:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @t1 = '12:00:00', @t2 = '16:30:00';</code></strong>
mysql&gt; <strong><code>SELECT TIMEDIFF(@t1,@t2) AS 't1 - t2', TIMEDIFF(@t2,@t1) AS 't2 - t1';</code></strong>
+-----------+----------+
| t1 - t2   | t2 - t1  |
+-----------+----------+
| -04:30:00 | 04:30:00 |
+-----------+----------+</pre><p><code>TIMEDIFF()</code> also works for
        date-and-time values. That is, it accepts either time or date-and-time
        values, but the types of the arguments must match.</p><p>A time interval expressed as a <code>TIME</code> value can be broken down into
        components using the techniques shown in <a data-type="xref" href="#nch-dates-dates-decomp">Recipe 8.9</a>. For example, to express a time
        interval in terms of its constituent hours, minutes, and seconds
        values, calculate time interval subparts using the <code>HOUR()</code>,
        <code>MINUTE()</code>, and <code>SECOND()</code> functions. (Don’t forget that if
        your intervals may be negative, you must take that into account.) The
        following SQL statement shows how to determine the components of the
        interval between the <code>t1</code> and
        <code>t2</code> columns of the <code>time_val</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1, t2,</code></strong>
    -&gt; <strong><code>TIMEDIFF(t2,t1) AS 't2 - t1 as TIME',</code></strong>
    -&gt; <strong><code>IF(TIMEDIFF(t2,t1) &gt;= 0,'+','-') AS sign,</code></strong>
    -&gt; <strong><code>HOUR(TIMEDIFF(t2,t1)) AS hour,</code></strong>
    -&gt; <strong><code>MINUTE(TIMEDIFF(t2,t1)) AS minute,</code></strong>
    -&gt; <strong><code>SECOND(TIMEDIFF(t2,t1)) AS second</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+----------+----------+-----------------+------+------+--------+--------+
| t1       | t2       | t2 - t1 as TIME | sign | hour | minute | second |
+----------+----------+-----------------+------+------+--------+--------+
| 15:00:00 | 15:00:00 | 00:00:00        | +    |    0 |      0 |      0 |
| 05:01:30 | 02:30:20 | -02:31:10       | -    |    2 |     31 |     10 |
| 12:30:20 | 17:30:45 | 05:00:25        | +    |    5 |      0 |     25 |
+----------+----------+-----------------+------+------+--------+--------+</pre><p>If you work with date or date-and-time values, the <code>TIMESTAMPDIFF()</code> function provides another
        way to calculate intervals. It enables you to specify the units in
        which intervals should be expressed:</p><pre data-type="programlisting">TIMESTAMPDIFF(<em><code>unit</code></em>,<em><code>val1</code></em>,<em><code>val2</code></em>)</pre><p><em><code>unit</code></em> is the interval unit and
        <em><code>val1</code></em> and <em><code>val2</code></em>
        are the values between which to calculate the interval. With <code>TIMESTAMPDIFF()</code>, you can express an interval
        in many different ways:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @dt1 = '1900-01-01 00:00:00', @dt2 = '1910-01-01 00:00:00';</code></strong>
mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>TIMESTAMPDIFF(MINUTE,@dt1,@dt2) AS minutes,</code></strong>
    -&gt; <strong><code>TIMESTAMPDIFF(HOUR,@dt1,@dt2) AS hours,</code></strong>
    -&gt; <strong><code>TIMESTAMPDIFF(DAY,@dt1,@dt2) AS days,</code></strong>
    -&gt; <strong><code>TIMESTAMPDIFF(WEEK,@dt1,@dt2) AS weeks,</code></strong>
    -&gt; <strong><code>TIMESTAMPDIFF(YEAR,@dt1,@dt2) AS years;</code></strong>
+---------+-------+------+-------+-------+
| minutes | hours | days | weeks | years |
+---------+-------+------+-------+-------+
| 5258880 | 87648 | 3652 |   521 |    10 |
+---------+-------+------+-------+-------+</pre><p>Permitted <em><code>unit</code></em> specifiers are
        <code>MICROSECOND</code>, <code>SECOND</code>, <code>MINUTE</code>, <code>HOUR</code>, <code>DAY</code>, <code>WEEK</code>, <code>MONTH</code>, <code>QUARTER</code>, or <code>YEAR</code>. Note that each is singular, not
        plural.</p><p>Be aware of these properties of <code>TIMESTAMPDIFF()</code>:</p><ul><li><p>Its value is negative if the first temporal value is greater
            than the second, which is opposite the order of the arguments for
            <code>DATEDIFF()</code> and <code>TIMEDIFF()</code>.</p></li><li><p>Despite the <code>TIMESTAMP</code> in
            its name, <code>TIMESTAMPDIFF()</code>
            arguments are not limited to the range of the <code>TIMESTAMP</code> data type.</p></li></ul></div></section><section data-type="sect3" data-pdf-bookmark="Time interval calculation using basic units"><div class="sect3" id="idm45820370755984"><h3>Time interval calculation using basic units</h3><p>To calculate intervals in seconds between pairs of time values,
        convert them to seconds with <code>TIME_TO_SEC()</code> and take the difference. To
        express the resulting interval as a <code>TIME</code> value, pass it to <code>SEC_TO_TIME()</code>. The following statement
        calculates the intervals between the <code>t1</code> and <code>t2</code>
        columns of the <code>time_val</code> table,
        expressing each interval both in seconds and as a <code>TIME</code>
        value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1, t2,</code></strong>
    -&gt; <strong><code>TIME_TO_SEC(t2) - TIME_TO_SEC(t1) AS 't2 - t1 (in seconds)',</code></strong>
    -&gt; <strong><code>SEC_TO_TIME(TIME_TO_SEC(t2) - TIME_TO_SEC(t1)) AS 't2 - t1 (as TIME)'</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+----------+----------+----------------------+-------------------+
| t1       | t2       | t2 - t1 (in seconds) | t2 - t1 (as TIME) |
+----------+----------+----------------------+-------------------+
| 15:00:00 | 15:00:00 |                    0 | 00:00:00          |
| 05:01:30 | 02:30:20 |                -9070 | -02:31:10         |
| 12:30:20 | 17:30:45 |                18025 | 05:00:25          |
+----------+----------+----------------------+-------------------+</pre></div></section><section data-type="sect3" data-pdf-bookmark="Date or date-and-time interval calculation using basic&#10;        units"><div class="sect3" id="idm45820370709392"><h3>Date or date-and-time interval calculation using basic
        units</h3><p>When you calculate an interval between dates by converting both
        dates to a common unit in relation to a given reference point and take
        the difference, the range of your values determines which conversions
        are available:</p><ul><li><p><code>DATE</code>, <code>DATETIME</code>, or <code>TIMESTAMP</code> values dating back to <code>1970-01-01</code> <code>00:00:00</code> UTC—the Unix epoch—can be converted to seconds elapsed since the
            epoch. With dates in that range, you can calculate intervals to an
            accuracy of one second.</p></li><li><p>Older dates from the beginning of the Gregorian calendar (1582) on can be converted to day
            values and used to compute intervals in days.</p></li><li><p>Dates that begin earlier than either of these reference
            points present more of a problem. In such cases, you may find that
            your programming language offers computations that are not
            available or are difficult to perform in SQL. If so, consider
            processing date values directly from within your API language. For
            example, the Date::Calc and Date::Manip modules are available
            from CPAN for use in Perl scripts.</p></li></ul><p>To calculate an interval in days between date or date-and-time
        values, convert them to days with <code>TO_DAYS()</code> and take the difference. For an
        interval in weeks, do the same thing and divide the result by
        seven:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @days = TO_DAYS('1884-01-01') - TO_DAYS('1883-06-05');</code></strong>
mysql&gt; <strong><code>SELECT @days AS days, @days/7 AS weeks;</code></strong>
+------+---------+
| days | weeks   |
+------+---------+
|  210 | 30.0000 |
+------+---------+</pre><p>You cannot convert days to months or years by simple division
        because those units vary in length. To yield date intervals expressed
        in those units, use <code>TIMESTAMPDIFF()</code>, discussed earlier in this
        recipe.</p><p>For date-and-time values occurring within the <code>TIMESTAMP</code> range from 1970 partially through
        2038, you can determine intervals to a resolution in seconds using the
        <code>UNIX_TIMESTAMP()</code> function. For
        intervals in other units, seconds are easily converted to minutes,
        hours, days, or weeks, as this expression shows for dates that lie two
        weeks apart:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @dt1 = '1984-01-01 09:00:00';</code></strong>
mysql&gt; <strong><code>SET @dt2 = @dt1 + INTERVAL 14 DAY;</code></strong>
mysql&gt; <strong><code>SET @interval = UNIX_TIMESTAMP(@dt2) - UNIX_TIMESTAMP(@dt1);</code></strong>
mysql&gt; <strong><code>SELECT @interval AS seconds,</code></strong>
    -&gt; <strong><code>@interval / 60 AS minutes,</code></strong>
    -&gt; <strong><code>@interval / (60 * 60) AS hours,</code></strong>
    -&gt; <strong><code>@interval / (24 * 60 * 60) AS days,</code></strong>
    -&gt; <strong><code>@interval / (7 * 24 * 60 * 60) AS weeks;</code></strong>
+---------+------------+----------+---------+--------+
| seconds | minutes    | hours    | days    | weeks  |
+---------+------------+----------+---------+--------+
| 1209600 | 20160.0000 | 336.0000 | 14.0000 | 2.0000 |
+---------+------------+----------+---------+--------+</pre><p>Use <code>FLOOR()</code> on the division results if you prefer integer values that have
        no fractional part.</p><p>For values that occur outside the <code>TIMESTAMP</code> range, this interval calculation
        method is more general (but messier):</p><ol><li><p>Take the difference in days between the date parts of the
            values and multiply by 24 × 60 × 60 to convert to seconds.</p></li><li><p>Adjust the result by the difference in seconds between the
            time parts of the values.</p></li></ol><p>Here’s an example, using two date-and-time values that lie
        slightly less than three days apart:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @dt1 = '1800-02-14 07:30:00';</code></strong>
mysql&gt; <strong><code>SET @dt2 = '1800-02-17 06:30:00';</code></strong>
mysql&gt; <strong><code>SET @interval =</code></strong>
    -&gt;   <strong><code>((TO_DAYS(@dt2) - TO_DAYS(@dt1)) * 24*60*60)</code></strong>
    -&gt;   <strong><code>+ TIME_TO_SEC(@dt2) - TIME_TO_SEC(@dt1);</code></strong>
mysql&gt; <strong><code>SELECT @interval AS seconds, SEC_TO_TIME(@interval) AS TIME;</code></strong>
+---------+----------+
| seconds | TIME     |
+---------+----------+
|  255600 | 71:00:00 |
+---------+----------+</pre><aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45820370690480"><h5>Do You Want an Interval or a Span?</h5><p>When you take a difference between dates (or times), consider
          whether you want an interval or a span. Taking a difference
          between dates gives you the interval from one date to the next. To
          determine the range spanned by the two dates, you must add a unit.
          For example, it’s a three-day interval from <code>2002-01-01</code> to <code>2002-01-04</code>, but together they span a range
          of four days. If you don’t get the results you expect from a
          difference-of-values calculation, consider whether an
          <q>off-by-one</q> correction is needed.</p></div></aside></div></section></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.13 Adding Date or Time Values"><div class="sect1" id="nch-dates-dates-calc-sum"><h1>8.13 Adding Date or Time Values</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370683344"><h2>Problem</h2><p>You want to add temporal values. For example, you want to add a given
      number of seconds to a time or determine what the date will be three
      weeks from today.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370682208"><h2>Solution</h2><p>To add date or time values, you have several options:</p><ul><li><p>Use one of the temporal-addition functions.</p></li><li><p>Use the <code>+</code> <code>INTERVAL</code> or <code>-</code> <code>INTERVAL</code> operator.</p></li><li><p>Convert the values to basic units, and take the sum.</p></li></ul><p>The applicable functions or operators depend on the types of the
      values.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370677552"><h2>Discussion</h2><p>The following discussion shows several ways to add temporal
      values.</p><section data-type="sect3" data-pdf-bookmark="Adding temporal values using temporal-addition functions or&#10;        operators"><div class="sect3" id="idm45820370676672"><h3>Adding temporal values using temporal-addition functions or
        operators</h3><p>To add a time to a time or date-and-time value, use the <code>ADDTIME()</code>
        function:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @t1 = '12:00:00', @t2 = '15:30:00';</code></strong>
mysql&gt; <strong><code>SELECT ADDTIME(@t1,@t2);</code></strong>
+------------------+
| ADDTIME(@t1,@t2) |
+------------------+
| 27:30:00         |
+------------------+
mysql&gt; <strong><code>SET @dt = '1984-03-01 12:00:00', @t = '12:00:00';</code></strong>
mysql&gt; <strong><code>SELECT ADDTIME(@dt,@t);</code></strong>
+----------------------------+
| TIMESTAMP(@d,@t)           |
+----------------------------+
| 1984-03-01 15:30:00.000000 |
+----------------------------+</pre><p>To add a time to a date or date-and-time value, use the <code>TIMESTAMP()</code>
        function:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @d = '1984-03-01', @t = '15:30:00';</code></strong>
mysql&gt; <strong><code>SELECT TIMESTAMP(@d,@t);</code></strong>
+---------------------+
| TIMESTAMP(@d,@t)    |
+---------------------+
| 1984-03-01 15:30:00 |
+---------------------+
mysql&gt; <strong><code>SET @dt = '1984-03-01 12:00:00', @t = '12:00:00';</code></strong>
mysql&gt; <strong><code>SELECT TIMESTAMP(@dt,@t);</code></strong>
+----------------------------+
| TIMESTAMP(@dt,@t)          |
+----------------------------+
| 1984-03-02 00:00:00.000000 |
+----------------------------+</pre><p>MySQL also provides <code>DATE_ADD()</code>
        and <code>DATE_SUB()</code> functions for adding
        intervals to dates and subtracting intervals from dates. Each function
        takes a date (or date-and-time) value <code>d</code> and an interval, expressed using the
        following syntax:</p><pre data-type="programlisting">DATE_ADD(d,INTERVAL <em><code>val unit</code></em>)
DATE_SUB(d,INTERVAL <em><code>val unit</code></em>)</pre><p>The <code>+</code> <code>INTERVAL</code> and <code>-</code> <code>INTERVAL</code> operators are similar:</p><pre data-type="programlisting">d + INTERVAL <em><code>val unit</code></em>
d - INTERVAL <em><code>val unit</code></em></pre><p><em><code>unit</code></em> is the interval unit and <em><code>val</code></em> is an
        expression indicating the number of units. Some common unit specifiers
        are <code>SECOND</code>, <code>MINUTE</code>, <code>HOUR</code>, <code>DAY</code>, <code>MONTH</code>, and <code>YEAR</code>. Note that each is singular, not
        plural. (Check the <a href="https://dev.mysql.com/doc/refman/8.0/en/date-and-time-functions.html#function_to-days">MySQL Reference
        Manual</a> for the
        full list.)</p><p>Use <code>DATE_ADD()</code> or <code>DATE_SUB()</code> to perform date arithmetic
        operations such as these:</p><ul><li><p>Determine the date three days from today:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CURDATE(), DATE_ADD(CURDATE(),INTERVAL 3 DAY);</code></strong>
++------------+------------------------------------+
| CURDATE()  | DATE_ADD(CURDATE(),INTERVAL 3 DAY) |
+------------+------------------------------------+
| 2021-11-24 | 2021-11-27                         |
+------------+------------------------------------+</pre></li><li><p>Find the date a week ago:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CURDATE(), DATE_SUB(CURDATE(),INTERVAL 1 WEEK);</code></strong>
+------------+-------------------------------------+
| CURDATE()  | DATE_SUB(CURDATE(),INTERVAL 1 WEEK) |
+------------+-------------------------------------+
| 2021-11-24 | 2021-11-17                          |
+------------+-------------------------------------+</pre></li><li><p>For questions where you need to know both the date and the
            time, begin with a <code>DATETIME</code> or
            <code>TIMESTAMP</code> value. To answer the question, <q>What time will it be
            in 60 hours?</q> do this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT NOW(), DATE_ADD(NOW(),INTERVAL 60 HOUR);</code></strong>
+---------------------+----------------------------------+
| NOW()               | DATE_ADD(NOW(),INTERVAL 60 HOUR) |
+---------------------+----------------------------------+
| 2021-11-24 22:44:19 | 2021-11-27 10:44:19              |
+---------------------+----------------------------------+</pre></li><li><p>Some interval specifiers have both date and time parts. The
            following adds 14.5 hours to the current date and time:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT NOW(), DATE_ADD(NOW(),INTERVAL '14:30' HOUR_MINUTE);</code></strong>
+---------------------+----------------------------------------------+
| NOW()               | DATE_ADD(NOW(),INTERVAL '14:30' HOUR_MINUTE) |
+---------------------+----------------------------------------------+
| 2021-11-24 22:46:37 | 2021-11-25 13:16:37                          |
+---------------------+----------------------------------------------+</pre><p>Similarly, adding 3 days and 4 hours produces this
            result:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT NOW(), DATE_ADD(NOW(),INTERVAL '3 4' DAY_HOUR);</code></strong>
+---------------------+-----------------------------------------+
| NOW()               | DATE_ADD(NOW(),INTERVAL '3 4' DAY_HOUR) |
+---------------------+-----------------------------------------+
| 2021-11-24 22:47:15 | 2021-11-28 02:47:15                     |
+---------------------+-----------------------------------------+</pre></li></ul><p><code>DATE_ADD()</code> and <code>DATE_SUB()</code> are interchangeable because one
        is the same as the other with the sign of the interval value flipped.
        These two expressions are equivalent for any date value <code>d</code>:</p><pre data-type="programlisting">DATE_ADD(d,INTERVAL -3 MONTH)
DATE_SUB(d,INTERVAL 3 MONTH)</pre><p>You can also use the <code>+</code>
        <code>INTERVAL</code> or <code>-</code> <code>INTERVAL</code> operator to perform date interval
        addition or subtraction:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CURDATE(), CURDATE() + INTERVAL 1 YEAR;</code></strong>
+------------+-----------------------------+
| CURDATE()  | CURDATE() + INTERVAL 1 YEAR |
+------------+-----------------------------+
| 2021-11-24 | 2022-11-24                  |
+------------+-----------------------------+
mysql&gt; <strong><code>SELECT NOW(), NOW() - INTERVAL '1 12' DAY_HOUR;</code></strong>
+---------------------+----------------------------------+
| NOW()               | NOW() - INTERVAL '1 12' DAY_HOUR |
+---------------------+----------------------------------+
| 2021-11-24 22:48:31 | 2021-11-23 10:48:31              |
+---------------------+----------------------------------+</pre><p><code>TIMESTAMPADD()</code> is an
        alternative function for adding intervals to date or
        date-and-time values. Its arguments are similar to those for <code>DATE_ADD()</code>, and the following equivalence holds:</p><pre data-type="programlisting">TIMESTAMPADD(<em><code>unit</code></em>,<em><code>interval</code></em>,d) = DATE_ADD(d,INTERVAL <em><code>interval</code></em> <em><code>unit</code></em>)</pre></div></section><section data-type="sect3" data-pdf-bookmark="Adding temporal values using basic units"><div class="sect3" id="idm45820370676368"><h3>Adding temporal values using basic units</h3><p>Another way to add intervals to date or date-and-time values is
        to perform temporal <q>shifting</q> via functions that convert
        to and from basic units. For background information about the
        applicable functions, see <a data-type="xref" href="#nch-dates-dates-basic-units">Recipe 8.11</a>.</p></div></section><section data-type="sect3" data-pdf-bookmark="Adding time values using basic units"><div class="sect3" id="idm45820370630944"><h3>Adding time values using basic units</h3><p>Adding times with basic units is similar to calculating
        intervals between times, except that you compute a sum rather than a
        difference. To add an interval value in seconds to a <code>TIME</code> value, convert the <code>TIME</code> to seconds so that both values are
        represented in the same units, add the values and convert the result
        back to a <code>TIME</code>. For example,
        two hours is 7,200 seconds (2 × 60 × 60), so the
        following statement adds two hours to each <code>t1</code> value in the <code>time_val</code> table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1,</code></strong>
    -&gt; <strong><code>SEC_TO_TIME(TIME_TO_SEC(t1) + 7200) AS 't1 plus 2 hours'</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+----------+-----------------+
| t1       | t1 plus 2 hours |
+----------+-----------------+
| 15:00:00 | 17:00:00        |
| 05:01:30 | 07:01:30        |
| 12:30:20 | 14:30:20        |
+----------+-----------------+</pre><p>If the interval itself is expressed as a <code>TIME</code>, it too should be converted to seconds
        before adding the values together. The following example calculates
        the sum of the two <code>TIME</code> values in
        each row of the <code>time_val</code>
        table:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1, t2,</code></strong>
    -&gt; <strong><code>TIME_TO_SEC(t1) + TIME_TO_SEC(t2)</code></strong>
    -&gt;   <strong><code>AS 't1 + t2 (in seconds)',</code></strong>
    -&gt; <strong><code>SEC_TO_TIME(TIME_TO_SEC(t1) + TIME_TO_SEC(t2))</code></strong>
    -&gt;   <strong><code>AS 't1 + t2 (as TIME)'</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+----------+----------+----------------------+-------------------+
| t1       | t2       | t1 + t2 (in seconds) | t1 + t2 (as TIME) |
+----------+----------+----------------------+-------------------+
| 15:00:00 | 15:00:00 |               108000 | 30:00:00          |
| 05:01:30 | 02:30:20 |                27110 | 07:31:50          |
| 12:30:20 | 17:30:45 |               108065 | 30:01:05          |
+----------+----------+----------------------+-------------------+</pre><p>It’s important to recognize that MySQL <code>TIME</code> values represent elapsed time, not time
        of day, so they don’t reset to 0 after reaching 24 hours. You can see
        this in the first and third output rows from the previous statement.
        To produce time-of-day values, enforce a 24-hour wraparound using a
        modulo operation before converting the seconds value back to a
        <code>TIME</code> value. The number of seconds
        in a day is 24 × 60 × 60, or 86,400. To convert any seconds value
        <code>s</code> to lie within a 24-hour range,
        use the <code>MOD()</code> function or the
        <code>%</code> modulo operator like this:</p><pre data-type="programlisting">MOD(s,86400)
s % 86400
s MOD 86400</pre><p>The three expressions are equivalent. Applying the first of them
        to the time calculations from the preceding example produces the
        following result:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT t1, t2,</code></strong>
    -&gt; <strong><code>MOD(TIME_TO_SEC(t1) + TIME_TO_SEC(t2), 86400)</code></strong>
    -&gt;   <strong><code>AS 't1 + t2 (in seconds)',</code></strong>
    -&gt; <strong><code>SEC_TO_TIME(MOD(TIME_TO_SEC(t1) + TIME_TO_SEC(t2), 86400))</code></strong>
    -&gt;   <strong><code>AS 't1 + t2 (as TIME)'</code></strong>
    -&gt; <strong><code>FROM time_val;</code></strong>
+----------+----------+----------------------+-------------------+
| t1       | t2       | t1 + t2 (in seconds) | t1 + t2 (as TIME) |
+----------+----------+----------------------+-------------------+
| 15:00:00 | 15:00:00 |                21600 | 06:00:00          |
| 05:01:30 | 02:30:20 |                27110 | 07:31:50          |
| 12:30:20 | 17:30:45 |                21665 | 06:01:05          |
+----------+----------+----------------------+-------------------+</pre><div data-type="note" epub:type="note"><h6>Note</h6><p>The permitted range of a <code>TIME</code> column is <code>-838:59:59</code> to <code>838:59:59</code> (that is, <code>-3020399</code> to <code>3020399</code> seconds). However, the range of
          <code>TIME</code>
          <em>expressions</em> can be greater, so when you add
          time values, you can easily produce a result that lies outside this
          range and cannot be stored as is into a <code>TIME</code> column.</p></div><p> Alternatively you can use <code>TIMESTAMPDIFF()</code>
        function to go outside of the <code>TIMEDIFF()</code> function 
        limits.
        </p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT NOW(),TIMESTAMPDIFF(minute,now(), '2023-01-01 00:00:00');</code></strong>
+---------------------+----------------------------------------------------+
| NOW()               | TIMESTAMPDIFF(minute,now(), '2023-01-01 00:00:00') |
+---------------------+----------------------------------------------------+
| 2022-03-07 06:38:40 |                                             431601 |
+---------------------+----------------------------------------------------+</pre><p>
        </p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT NOW(),TIMESTAMPDIFF(day,now(), '2023-01-01 00:00:00');</code></strong>
+---------------------+-------------------------------------------------+
| NOW()               | TIMESTAMPDIFF(day,now(), '2023-01-01 00:00:00') |
+---------------------+-------------------------------------------------+
| 2022-03-07 06:38:50 |                                             299 |
+---------------------+-------------------------------------------------+</pre><p>
        </p></div></section><section data-type="sect3" data-pdf-bookmark="Adding to date or date-and-time values using basic&#10;        units"><div class="sect3" id="idm45820370630640"><h3>Adding to date or date-and-time values using basic
        units</h3><p>Date or date-and-time values converted to basic units can be shifted to produce other
        dates. For example, to shift a date forward or backward a week (seven
        days), use <code>TO_DAYS()</code> and <code>FROM_DAYS()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @d = '1980-01-01';</code></strong>
mysql&gt; <strong><code>SELECT @d AS date,</code></strong>
    -&gt; <strong><code>FROM_DAYS(TO_DAYS(@d) + 7) AS 'date + 1 week',</code></strong>
    -&gt; <strong><code>FROM_DAYS(TO_DAYS(@d) - 7) AS 'date - 1 week';</code></strong>
+------------+---------------+---------------+
| date       | date + 1 week | date - 1 week |
+------------+---------------+---------------+
| 1980-01-01 | 1980-01-08    | 1979-12-25    |
+------------+---------------+---------------+</pre><p><code>TO_DAYS()</code> also can convert
        date-and-time values to days, if you don’t mind having it chop off the
        time part.</p><p>To preserve the time, you can use <code>UNIX_TIMESTAMP()</code> and <code>FROM_UNIXTIME()</code> instead, if the initial and resulting values both lie in the
        permitted range for <code>TIMESTAMP</code>
        values (from 1970 partially through 2038). The following statement
        shifts a <code>DATETIME</code> value forward and
        backward by an hour (3,600 seconds):</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @dt = '1980-01-01 09:00:00';</code></strong>
mysql&gt; <strong><code>SELECT @dt AS datetime,</code></strong>
    -&gt; <strong><code>FROM_UNIXTIME(UNIX_TIMESTAMP(@dt) + 3600) AS 'datetime + 1 hour',</code></strong>
    -&gt; <strong><code>FROM_UNIXTIME(UNIX_TIMESTAMP(@dt) - 3600) AS 'datetime - 1 hour';</code></strong>
+---------------------+---------------------+---------------------+
| datetime            | datetime + 1 hour   | datetime - 1 hour   |
+---------------------+---------------------+---------------------+
| 1980-01-01 09:00:00 | 1980-01-01 10:00:00 | 1980-01-01 08:00:00 |
+---------------------+---------------------+---------------------+</pre></div></section></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.14 Calculating Ages"><div class="sect1" id="nch-dates-dates-age"><h1>8.14 Calculating Ages</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370590752"><h2>Problem</h2><p>You want to know how old someone is.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370589760"><h2>Solution</h2><p>This is a date-arithmetic problem. It amounts to computing the
      interval between dates, but with a twist. For an age in years, it’s
      necessary to account for the relative placement of the start and end
      dates within the calendar year. For an age in months, it’s also
      necessary to account for the placement of the months and the days within
      the month.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370588816"><h2>Discussion</h2><p>Age determination is a type of date-interval calculation. However,
      you cannot simply compute a difference in days and divide by 365 because
      leap years throw off the calculation. (It is 365 days from 1995-03-01 to
      1996-02-29, but that is not a year in age terms.) Dividing by 365.25 is
      slightly more accurate, but still not correct for all dates.</p><p>To calculate ages, use the <code>TIMESTAMPDIFF()</code> function. Pass it a birth
      date, a current date, and the unit in which you want the age
      expressed:</p><pre data-type="programlisting">TIMESTAMPDIFF(<em><code>unit</code></em>,<em><code>birth</code></em>,<em><code>current</code></em>)</pre><p><code>TIMESTAMPDIFF()</code> handles the
      calculations necessary to adjust for differing month and year lengths
      and relative positions of the dates within the calendar year. Suppose
      that a <code>sibling</code> table lists the birth
      dates of Ilayda and her sister Lara. </p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT * FROM sibling;</code></strong>
+--------+------------+
| name   | birth      |
+--------+------------+
| Ilayda | 2002-12-17 |
| Lara   | 2009-06-03 |
+--------+------------+</pre><p>Using <code>TIMESTAMPDIFF()</code>, you can
      answer questions such as these:</p><ul><li><p>How old are the Alkin’s children today, in years, months and
          days?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name,DATE_FORMAT(birth,'%Y-%m-%d') as dob,</code></strong>
    -&gt; <strong><code>DATE_FORMAT(NOW(),'%Y-%m-%d') as today,</code></strong>
    -&gt; <strong><code>TIMESTAMPDIFF( YEAR, birth, NOW() ) as age_years',</code></strong>
    -&gt; <strong><code>FLOOR( TIMESTAMPDIFF( DAY, birth, now() ) % 30.4375 ) as age_days</code></strong>   
    -&gt; <strong><code>FROM sibling;</code></strong>
+--------+------------+------------+-----------+------------+----------+
| name   | dob        | today      | age_years | age_months | age_days |
+--------+------------+------------+-----------+------------+----------+
| Ilayda | 2002-12-17 | 2022-03-07 |        19 |          2 |       19 |
| Lara   | 2009-06-03 | 2022-03-07 |        12 |          9 |        3 |
+--------+------------+------------+-----------+------------+----------+</pre></li><li><p>How old was Ilayda when Lara was born, in years
          and months?</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT name, birth, '2009-06-03' AS 'Lara\'s birth', </code></strong>
    -&gt; <strong><code>TIMESTAMPDIFF(YEAR,birth,'2009-06-03') AS 'age in years',</code></strong>
    -&gt; <strong><code>TIMESTAMPDIFF( MONTH, birth,'2009-06-09' ) % 12 as age_months,</code></strong>
    -&gt; <strong><code>FLOOR( TIMESTAMPDIFF( DAY, birth,'2009-06-09' ) % 30.4375 ) as age_days</code></strong>
    -&gt; <strong><code>FROM sibling WHERE name &lt;&gt; 'Lara';</code></strong>
+--------+------------+--------------+-----------+------------+----------+
| name   | birth      | Lara's birth | age_years | age_months | age_days |
+--------+------------+--------------+-----------+------------+----------+
| Ilayda | 2002-12-17 | 2009-06-09   |         6 |          5 |       22 |
+--------+------------+--------------+-----------+------------+----------+</pre></li></ul><p>For further information about date calculation using these functions, 
      consult the <a href="https://dev.mysql.com/doc/refman/8.0/en/date-calculations.html">MySQL Reference Manual</a>.
      </p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.15 Finding the First Day, Last Day, or Length of a Month"><div class="sect1" id="nch-dates-dates-day-firstlast"><h1>8.15 Finding the First Day, Last Day, or Length of a Month</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370571040"><h2>Problem</h2><p>Given a date, you want to determine the date for the first or last day of the month
      in which the date occurs, or the first or last day for the month
      <em><code>n</code></em> months away. A related problem is to
      determine the number of days in a month.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370569552"><h2>Solution</h2><p>To determine the date for the first day in a month, use date
      shifting (an application of date arithmetic). To determine the date for
      the last day, use the <code>LAST_DAY()</code>
      function. To determine the number of days in a month, find the date for
      its last day and use it as the argument to <code>DAYOFMONTH()</code>.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370567664"><h2>Discussion</h2><p>Sometimes you have a reference date and want to reach a target
      date that doesn’t have a fixed relationship to the reference date. For
      example, the first or last days of the current month aren’t a fixed
      number of days from the current date.</p><p>To find the first day of the month for a given date, shift the
      date back by one fewer days than its <code>DAYOFMONTH()</code> value:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DATE_SUB(d,INTERVAL DAYOFMONTH(d)-1 DAY) AS '1st of month'</code></strong>
    -&gt; <strong><code>FROM date_val;</code></strong>
+------------+--------------+
| d          | 1st of month |
+------------+--------------+
| 1864-02-28 | 1864-02-01   |
| 1900-01-15 | 1900-01-01   |
| 1999-12-31 | 1999-12-01   |
| 2000-06-04 | 2000-06-01   |
| 2017-03-16 | 2017-03-01   |
+------------+--------------+</pre><p>In the general case, to find the first of the month for any month
      <em><code>n</code></em> months away from a given date, calculate
      the first of the month for the date and shift the result by
      <em><code>n</code></em> months:</p><pre data-type="programlisting">DATE_ADD(DATE_SUB(d,INTERVAL DAYOFMONTH(d)-1 DAY),INTERVAL <em><code>n</code></em> MONTH)</pre><p>For example, to find the first day of the previous and following
      months relative to a given date, <em><code>n</code></em> is
      <code>-1</code> and <code>1</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d,</code></strong>
    -&gt; <strong><code>DATE_ADD(DATE_SUB(d,INTERVAL DAYOFMONTH(d)-1 DAY),INTERVAL -1 MONTH)</code></strong>
    -&gt;   <strong><code>AS '1st of previous month',</code></strong>
    -&gt; <strong><code>DATE_ADD(DATE_SUB(d,INTERVAL DAYOFMONTH(d)-1 DAY),INTERVAL 1 MONTH)</code></strong>
    -&gt;   <strong><code>AS '1st of following month'</code></strong>
    -&gt; <strong><code>FROM date_val;</code></strong>
+------------+-----------------------+------------------------+
| d          | 1st of previous month | 1st of following month |
+------------+-----------------------+------------------------+
| 1864-02-28 | 1864-01-01            | 1864-03-01             |
| 1900-01-15 | 1899-12-01            | 1900-02-01             |
| 1999-12-31 | 1999-11-01            | 2000-01-01             |
| 2000-06-04 | 2000-05-01            | 2000-07-01             |
| 2017-03-16 | 2017-02-01            | 2017-04-01             |
+------------+-----------------------+------------------------+</pre><p>It’s easier to find the last day of the month for a given date because there is a
      function for it:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, LAST_DAY(d) AS 'last of month'</code></strong>
    -&gt; <strong><code>FROM date_val;</code></strong>
+------------+---------------+
| d          | last of month |
+------------+---------------+
| 1864-02-28 | 1864-02-29    |
| 1900-01-15 | 1900-01-31    |
| 1999-12-31 | 1999-12-31    |
| 2000-06-04 | 2000-06-30    |
| 2017-03-16 | 2017-03-31    |
+------------+---------------+</pre><p>For the general case, to find the last of the month for any month
      <em><code>n</code></em> months away from a given date, shift the
      date by that many months first, then pass it to <code>LAST_DAY()</code>:</p><pre data-type="programlisting">LAST_DAY(DATE_ADD(d,INTERVAL <em><code>n</code></em> MONTH))</pre><p>For example, to find the last day of the previous and following
      months relative to a given date, <em><code>n</code></em> is
      <code>-1</code> and <code>1</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d,</code></strong>
    -&gt; <strong><code>LAST_DAY(DATE_ADD(d,INTERVAL -1 MONTH))</code></strong>
    -&gt;   <strong><code>AS 'last of previous month',</code></strong>
    -&gt; <strong><code>LAST_DAY(DATE_ADD(d,INTERVAL 1 MONTH))</code></strong>
    -&gt;  <strong><code>AS 'last of following month'</code></strong>
    -&gt; <strong><code>FROM date_val;</code></strong>
+------------+------------------------+-------------------------+
| d          | last of previous month | last of following month |
+------------+------------------------+-------------------------+
| 1864-02-28 | 1864-01-31             | 1864-03-31              |
| 1900-01-15 | 1899-12-31             | 1900-02-28              |
| 1999-12-31 | 1999-11-30             | 2000-01-31              |
| 2000-06-04 | 2000-05-31             | 2000-07-31              |
| 2017-03-16 | 2017-02-28             | 2017-04-30              |
+------------+------------------------+-------------------------+</pre><p>To find the length of a month in days, determine the date of its last day with
      <code>LAST_DAY()</code>, then use <code>DAYOFMONTH()</code> to extract the day-of-month
      component from the result:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DAYOFMONTH(LAST_DAY(d)) AS 'days in month' FROM date_val;</code></strong>
+------------+---------------+
| d          | days in month |
+------------+---------------+
| 1864-02-28 |            29 |
| 1900-01-15 |            31 |
| 1999-12-31 |            31 |
| 2000-06-04 |            30 |
| 2017-03-16 |            31 |
+------------+---------------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.16 Finding the Day of the Week for a Date"><div class="sect1" id="nch-dates-dates-day-of-week"><h1>8.16 Finding the Day of the Week for a Date</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370539968"><h2>Problem</h2><p>You want to know the day of the week on which a date falls.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370539056"><h2>Solution</h2><p>Use the <code>DAYNAME()</code>
      function.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370537584"><h2>Discussion</h2><p>To determine the name of the day of the week for a given date, use
      <code>DAYNAME()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT CURDATE(), DAYNAME(CURDATE());</code></strong>
+------------+--------------------+
| CURDATE()  | DAYNAME(CURDATE()) |
+------------+--------------------+
| 2021-11-24 | Wednesday          |
+------------+--------------------+</pre><p><code>DAYNAME()</code> is often useful in
      conjunction with other date-related techniques. For example, to
      determine the day of the week for the first of the month, use the
      first-of-month expression from <a data-type="xref" href="#nch-dates-dates-day-firstlast">Recipe 8.15</a> as the argument to <code>DAYNAME()</code>:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @d = CURDATE();</code></strong>
mysql&gt; <strong><code>SET @first = DATE_SUB(@d,INTERVAL DAYOFMONTH(@d)-1 DAY);</code></strong>
mysql&gt; <strong><code>SELECT @d AS 'starting date',</code></strong>
    -&gt; <strong><code>@first AS '1st of month date',</code></strong>
    -&gt; <strong><code>DAYNAME(@first) AS '1st of month day';</code></strong>
+---------------+-------------------+------------------+
| starting date | 1st of month date | 1st of month day |
+---------------+-------------------+------------------+
| 2021-11-24    | 2021-11-01        | Monday           |
+---------------+-------------------+------------------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.17 Finding Dates for Any Weekday of a Given Week"><div class="sect1" id="nch-dates-dates-weekday-in-week"><h1>8.17 Finding Dates for Any Weekday of a Given Week</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370527744"><h2>Problem</h2><p>You want to compute the date of some weekday for the week in which a given
      date lies. Suppose that you want to know the date of the Tuesday that
      falls in the same week as <code>2014-07-09</code>.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370526224"><h2>Solution</h2><p>This is an application of date shifting. Figure out the number of
      days between the starting weekday of the given date and the desired day,
      and shift the date by that many days.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370525248"><h2>Discussion</h2><p>This section and the next describe how to convert one date to
      another when the target date is specified in terms of days of the week.
      To solve such problems, you need to know day-of-week values. Suppose you
      begin with a target date of <code>2014-07-09</code>. To determine the date for Tuesday
      of the week in which that date lies, the calculation depends on what
      weekday it is. If it’s a Monday, you add a day to produce <code>2014-07-10</code>, but if it’s a Wednesday, you
      subtract a day to produce <code>2014-07-08</code>.</p><p>MySQL provides two functions that are useful here. <code>DAYOFWEEK()</code> treats Sunday as the first day of
      the week and returns 1 through 7 for Sunday through Saturday. <code>WEEKDAY()</code>
      treats Monday as the first day of the week and returns 0 through 6 for
      Monday through Sunday. (The examples shown here use <code>DAYOFWEEK()</code>.) Another kind of day-of-week
      operation involves determining the name of the day. <code>DAYNAME()</code> can be used for that.</p><p>Calculations that determine one day of the week from another
      depend on the day you start from as well as the day you want to reach. I
      find it easiest to shift the reference date first to a known point
      relative to the beginning of the week, and then shift forward:</p><ol><li><p>Shift the reference date back by its <code>DAYOFWEEK()</code> value, which always produces
          the date for the Saturday preceding the week.</p></li><li><p>Shift the Saturday date by one day to reach the Sunday date,
          by two days to reach the Monday date, and so forth.</p></li></ol><p>In SQL, those operations can be expressed as follows for a date
      <code>d</code>, where <em><code>n</code></em>
      is 1 through 7 to produce the dates for Sunday through Saturday:</p><pre data-type="programlisting">DATE_ADD(DATE_SUB(d,INTERVAL DAYOFWEEK(d) DAY),INTERVAL <em><code>n</code></em> DAY)</pre><p>That expression splits the <q>shift back to Saturday</q>
      and <q>shift forward</q> phases into separate operations, but
      because the intervals for both <code>DATE_SUB()</code> and
      <code>DATE_ADD()</code> are in days, the
      expression can be simplified into a single <code>DATE_ADD()</code> call:</p><pre data-type="programlisting">DATE_ADD(d,INTERVAL <em><code>n</code></em>-DAYOFWEEK(d) DAY)</pre><p>Applying this formula to the dates in our <code>date_val</code> table, using an
      <em><code>n</code></em> of 1 for Sunday and 7 for Saturday to find
      the first and last days of the week, yields this result:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, DAYNAME(d) AS day,</code></strong>
    -&gt; <strong><code>DATE_ADD(d,INTERVAL 1-DAYOFWEEK(d) DAY) AS Sunday,</code></strong>
    -&gt; <strong><code>DATE_ADD(d,INTERVAL 7-DAYOFWEEK(d) DAY) AS Saturday</code></strong>
    -&gt; <strong><code>FROM date_val;</code></strong>
+------------+----------+------------+------------+
| d          | day      | Sunday     | Saturday   |
+------------+----------+------------+------------+
| 1864-02-28 | Sunday   | 1864-02-28 | 1864-03-05 |
| 1900-01-15 | Monday   | 1900-01-14 | 1900-01-20 |
| 1999-12-31 | Friday   | 1999-12-26 | 2000-01-01 |
| 2000-06-04 | Sunday   | 2000-06-04 | 2000-06-10 |
| 2017-03-16 | Thursday | 2017-03-12 | 2017-03-18 |
+------------+----------+------------+------------+</pre><p>To determine the date of some weekday in a week relative to that of the target date, modify the preceding procedure a bit. First, determine the date of the desired weekday in the week containing the target date and then shift the result into the desired week.</p><p>Calculating the date for a day of the week in some other week is a
      problem that breaks down into a day-within-week shift (using the formula
      just given) plus a week shift. These operations can be done in either
      order because the amount of shift within the week is the same whether or
      not you shift the reference date into a different week first. For
      example, to calculate Wednesday of a week by the preceding formula,
      <em><code>n</code></em> is 4. To compute the date for Wednesday two
      weeks ago, you can perform the day-within-week shift first, like
      this:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @target =</code></strong>
    -&gt; <strong><code>DATE_SUB(DATE_ADD(CURDATE(),INTERVAL 4-DAYOFWEEK(CURDATE()) DAY),</code></strong>
    -&gt; <strong><code>INTERVAL 14 DAY);</code></strong>
mysql&gt; <strong><code>SELECT CURDATE(), @target, DAYNAME(@target);</code></strong>
+------------+------------+------------------+
| CURDATE()  | @target    | DAYNAME(@target) |
+------------+------------+------------------+
| 2021-11-24 | 2021-11-10 | Wednesday        |
+------------+------------+------------------+</pre><p>Or you can perform the week shift first:</p><pre data-type="programlisting">mysql&gt; <strong><code>SET @target =</code></strong>
    -&gt; <strong><code>DATE_ADD(DATE_SUB(CURDATE(),INTERVAL 14 DAY),</code></strong>
    -&gt; <strong><code>INTERVAL 4-DAYOFWEEK(CURDATE()) DAY);</code></strong>
mysql&gt; <strong><code>SELECT CURDATE(), @target, DAYNAME(@target);</code></strong>
+------------+------------+------------------+
| CURDATE()  | @target    | DAYNAME(@target) |
+------------+------------+------------------+
| 2021-11-24 | 2021-11-10 | Wednesday        |
+------------+------------+------------------+</pre><p>Some applications need to determine dates such as the
      <em><code>n</code></em>-th instance of particular weekdays. For
      example, to administer a payroll for which paydays are the second and
      fourth Thursdays of each month, you must know what those dates are. One
      way to do this for any given month is to begin with the first-of-month
      date and shift it forward. It’s easy enough to shift the date to the
      Thursday in that week; the trick is to figure out how many weeks forward
      to shift the result to reach the second and fourth Thursdays. If the
      first of the month occurs on any day from Sunday through Thursday, you
      shift forward one week to reach the second Thursday. If the first of the
      month occurs on Friday or later, you shift forward by two weeks. The
      fourth Thursday is, of course, two weeks after that.</p><p>The following Perl code implements this logic to find all paydays
      in the year 2021. It runs a loop that constructs the first-of-month date
      for the months of the year. For each month, it issues a statement that
      determines the dates of the second and fourth Thursdays:</p><pre data-type="programlisting" data-code-language="perl"><code class="k">my</code> <code class="nv">$year</code> <code class="o">=</code> <code class="mi">2021</code><code class="p">;</code>
<code class="k">print</code> <code class="s">"MM/YYYY   2nd Thursday   4th Thursday\n"</code><code class="p">;</code>
<code class="k">foreach</code> <code class="k">my</code> <code class="nv">$month</code> <code class="p">(</code><code class="mi">1</code><code class="o">..</code><code class="mi">12</code><code class="p">)</code>
<code class="p">{</code>
  <code class="k">my</code> <code class="nv">$first</code> <code class="o">=</code> <code class="nb">sprintf</code> <code class="p">(</code><code class="s">"%04d-%02d-01"</code><code class="p">,</code> <code class="nv">$year</code><code class="p">,</code> <code class="nv">$month</code><code class="p">);</code>
  <code class="k">my</code> <code class="p">(</code><code class="nv">$thu2</code><code class="p">,</code> <code class="nv">$thu4</code><code class="p">)</code> <code class="o">=</code> <code class="nv">$dbh</code><code class="o">-&gt;</code><code class="n">selectrow_array</code> <code class="p">(</code><code class="sx">qq{</code>
<code class="sx">                  SELECT</code>
<code class="sx">                    DATE_ADD(</code>
<code class="sx">                      DATE_ADD(?,INTERVAL 5-DAYOFWEEK(?) DAY),</code>
<code class="sx">                      INTERVAL IF(DAYOFWEEK(?) &lt;= 5, 7, 14) DAY),</code>
<code class="sx">                    DATE_ADD(</code>
<code class="sx">                      DATE_ADD(?,INTERVAL 5-DAYOFWEEK(?) DAY),</code>
<code class="sx">                      INTERVAL IF(DAYOFWEEK(?) &lt;= 5, 21, 28) DAY)</code>
<code class="sx">                }</code><code class="p">,</code> <code class="nb">undef</code><code class="p">,</code> <code class="nv">$first</code><code class="p">,</code> <code class="nv">$first</code><code class="p">,</code> <code class="nv">$first</code><code class="p">,</code> <code class="nv">$first</code><code class="p">,</code> <code class="nv">$first</code><code class="p">,</code> <code class="nv">$first</code><code class="p">);</code>
  <code class="nb">printf</code> <code class="s">"%02d/%04d   %s     %s\n"</code><code class="p">,</code> <code class="nv">$month</code><code class="p">,</code> <code class="nv">$year</code><code class="p">,</code> <code class="nv">$thu2</code><code class="p">,</code> <code class="nv">$thu4</code><code class="p">;</code>
<code class="p">}</code></pre><p>The program produces this output:</p><pre data-type="programlisting">MM/YYYY   2nd Thursday   4th Thursday
MM/YYYY   2nd Thursday   4th Thursday
01/2021   2021-01-14     2021-01-28
02/2021   2021-02-11     2021-02-25
03/2021   2021-03-11     2021-03-25
04/2021   2021-04-08     2021-04-22
05/2021   2021-05-13     2021-05-27
06/2021   2021-06-10     2021-06-24
07/2021   2021-07-08     2021-07-22
08/2021   2021-08-12     2021-08-26
09/2021   2021-09-09     2021-09-23
10/2021   2021-10-14     2021-10-28
11/2021   2021-11-11     2021-11-25
12/2021   2021-12-09     2021-12-23</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.18 Canonizing Not-Quite-ISO Date Strings"><div class="sect1" id="nch-dates-dates-canonize"><h1>8.18 Canonizing Not-Quite-ISO Date Strings</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370445424"><h2>Problem</h2><p>You have a date that is in a format that’s close to, but not 
      exactly in, ISO format, and you want to convert it into an ISO format 
      date..</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370444544"><h2>Solution</h2><p>Canonize the date by passing it to a function that always returns
      an ISO-format date result.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370443552"><h2>Discussion</h2><p>In <a data-type="xref" href="#nch-dates-dates-synth">Recipe 8.10</a>, we ran into the
      problem that synthesizing dates with <code>CONCAT()</code> may
      produce values that are not quite in ISO format. For example, the
      following statement produces first-of-month values in which the month
      part may have only a single digit:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d, CONCAT(YEAR(d),'-',MONTH(d),'-01') FROM date_val;</code></strong>
+------------+------------------------------------+
| d          | CONCAT(YEAR(d),'-',MONTH(d),'-01') |
+------------+------------------------------------+
| 1864-02-28 | 1864-2-01                          |
| 1900-01-15 | 1900-1-01                          |
| 1999-12-31 | 1999-12-01                         |
| 2000-06-04 | 2000-6-01                          |
| 2017-03-16 | 2017-3-01                          |
+------------+------------------------------------+</pre><p><a data-type="xref" href="#nch-dates-dates-synth">Recipe 8.10</a> shows a technique
      using <code>LPAD()</code> for making
      sure the month values have two digits. Another way to standardize a
      close-to-ISO date is to use it in an expression that produces an ISO
      date result. For a date <code>d</code>, any of the
      following expressions will do:</p><pre data-type="programlisting">DATE_ADD(d,INTERVAL 0 DAY)
d + INTERVAL 0 DAY
FROM_DAYS(TO_DAYS(d))
STR_TO_DATE(d,'%Y-%m-%d')</pre><p>Using those expressions with the non-ISO results from the <code>CONCAT()</code> operation yields ISO format in
      several ways:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT</code></strong>
    -&gt; <strong><code>CONCAT(YEAR(d),'-',MONTH(d),'-01') AS 'non-ISO',</code></strong>
    -&gt; <strong><code>DATE_ADD(CONCAT(YEAR(d),'-',MONTH(d),'-01'),INTERVAL 0 DAY) AS 'ISO 1',</code></strong>
    -&gt; <strong><code>CONCAT(YEAR(d),'-',MONTH(d),'-01') + INTERVAL 0 DAY AS 'ISO 2',</code></strong>
    -&gt; <strong><code>FROM_DAYS(TO_DAYS(CONCAT(YEAR(d),'-',MONTH(d),'-01'))) AS 'ISO 3',</code></strong>
    -&gt; <strong><code>STR_TO_DATE(CONCAT(YEAR(d),'-',MONTH(d),'-01'),'%Y-%m-%d') AS 'ISO 4'</code></strong>
    -&gt; <strong><code>FROM date_val;</code></strong>
+------------+------------+------------+------------+------------+
| non-ISO    | ISO 1      | ISO 2      | ISO 3      | ISO 4      |
+------------+------------+------------+------------+------------+
| 1864-2-01  | 1864-02-01 | 1864-02-01 | 1864-02-01 | 1864-02-01 |
| 1900-1-01  | 1900-01-01 | 1900-01-01 | 1900-01-01 | 1900-01-01 |
| 1999-12-01 | 1999-12-01 | 1999-12-01 | 1999-12-01 | 1999-12-01 |
| 2000-6-01  | 2000-06-01 | 2000-06-01 | 2000-06-01 | 2000-06-01 |
| 2017-3-01  | 2017-03-01 | 2017-03-01 | 2017-03-01 | 2017-03-01 |
+------------+------------+------------+------------+------------+</pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="8.19 Selecting Rows Based on Temporal Characteristics"><div class="sect1" id="nch-dates-dates-where"><h1>8.19 Selecting Rows Based on Temporal Characteristics</h1><section data-type="sect2" data-pdf-bookmark="Problem"><div class="sect2" id="idm45820370356864"><h2>Problem</h2><p>You want to select rows based on temporal conditions.</p></div></section><section data-type="sect2" data-pdf-bookmark="Solution"><div class="sect2" id="idm45820370355856"><h2>Solution</h2><p>Use a date or time condition in the <code>WHERE</code> clause. This
      may be based on direct comparison of column values with known values. Or
      it may be necessary to apply a function to column values to convert them
      to a more appropriate form for testing, such as using <code>MONTH()</code> to test the month part of a date.</p></div></section><section data-type="sect2" data-pdf-bookmark="Discussion"><div class="sect2" id="idm45820370354032"><h2>Discussion</h2><p>Most of the preceding date-based techniques were illustrated by
      example statements that produce date or time values as output. To place
      date-based restrictions on the rows selected by a statement, use the
      same techniques in a <code>WHERE</code> clause.
      For example, you can select rows by looking for values that occur before
      or after a given date, within a date range, or that match particular
      month or day values.</p><section data-type="sect3" data-pdf-bookmark="Comparing dates to one another"><div class="sect3" id="idm45820370352416"><h3>Comparing dates to one another</h3><p>The following statements find rows from the <code>date_val</code> table that occur either before 1900
        or during the 1900s:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d FROM date_val where d &lt; '1900-01-01';</code></strong>
+------------+
| d          |
+------------+
| 1864-02-28 |
+------------+
mysql&gt; <strong><code>SELECT d FROM date_val where d BETWEEN '1900-01-01' AND '1999-12-31';</code></strong>
+------------+
| d          |
+------------+
| 1900-01-15 |
| 1999-12-31 |
+------------+</pre><p>When you don’t know the exact date needed for a comparison in a
        <code>WHERE</code> clause, you can often
        calculate it using an expression. For example, to perform an <q>on
        this day in history</q> statement to search for rows in a table
        named <code>history</code> to find events
        occurring exactly 50 years ago, do this:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">history</code> <code class="k">WHERE</code> <code class="n">d</code> <code class="o">=</code> <code class="n">DATE_SUB</code><code class="p">(</code><code class="n">CURDATE</code><code class="p">(),</code><code class="nb">INTERVAL</code> <code class="mi">50</code> <code class="k">YEAR</code><code class="p">);</code></pre><p>You see this kind of thing in newspapers that run columns
        showing what the news events were in times past. (In essence, the
        statement identifies those events that have reached their
        <em><code>n</code></em>-th anniversary.) To retrieve events that
        occurred <q>on this day</q> for any year rather than <q>on
        this date</q> for a specific year, the statement is a bit
        different. In that case, you need to find rows that match the current
        calendar day, ignoring the year. That topic is discussed in <a data-type="xref" href="#dates_to_calendar">“Comparing dates to calendar days”</a>.</p><p>Calculated dates are useful for range testing as well. For
        example, to find dates that occur later than 20 years ago, use <code>DATE_SUB()</code> to
        calculate the cutoff date:</p><pre data-type="programlisting">mysql&gt; <strong><code>SELECT d FROM date_val WHERE d &gt;= DATE_SUB(CURDATE(),INTERVAL 20 YEAR);</code></strong>
+------------+
| d          |
+------------+
| 1999-12-31 |
| 2000-06-04 |
| 2017-03-16 |
+------------+</pre><p>Note that the expression in the <code>WHERE</code> clause isolates the date column
        <code>d</code> on one side of the comparison
        operator. This is usually a good idea; if the column is indexed,
        placing it alone on one side of a comparison enables MySQL to process
        the statement more efficiently. To illustrate, the preceding <code>WHERE</code> clause can be written in a way that’s
        logically equivalent but much less efficient for MySQL to
        execute:</p><pre data-type="programlisting">WHERE DATE_ADD(d,INTERVAL 20 YEAR) &gt;= CURDATE();</pre><p>Here, the <code>d</code> column is used
        within an expression. That means <em>every</em> row must
        be retrieved so that the expression can be evaluated and tested, which
        makes any index on the column useless.</p><p>Sometimes it’s not so obvious how to rewrite a comparison to
        isolate a date column on one side. For example, the following <code>WHERE</code> clause uses only part of the date
        column in the comparisons:</p><pre data-type="programlisting">WHERE YEAR(d) &gt;= 1987 AND YEAR(d) &lt;= 1991;</pre><p>To rewrite the first comparison, eliminate the <code>YEAR()</code> call, and replace its right side with
        a complete date:</p><pre data-type="programlisting">WHERE d &gt;= '1987-01-01' AND YEAR(d) &lt;= 1991;</pre><p>Rewriting the second comparison is a little trickier. You can
        eliminate the <code>YEAR()</code> call on the
        left side, just as with the first expression, but you can’t just add
        <code>-01-01</code> to the year on the right
        side. That produces the following result, which is incorrect:</p><pre data-type="programlisting">WHERE d &gt;= '1987-01-01' AND d &lt;= '1991-01-01';</pre><p>That fails because dates from <code>1991-01-02</code> to <code>1991-12-31</code> fail the test, but should pass.
        To rewrite the second comparison correctly, do this:</p><pre data-type="programlisting">WHERE d &gt;= '1987-01-01' AND d &lt; '1992-01-01';</pre><p>Another use for calculated dates occurs frequently in
        applications that create rows that have a limited lifetime. Such
        applications must be able to determine which rows to delete when
        performing an expiration operation. You can approach this problem a
        couple ways:</p><ul><li><p>Store a date in each row indicating when it was created. (Do
            this by making the column a <code>TIMESTAMP</code> or by setting it to <code>NOW()</code>; see
            <a data-type="xref" href="#nch-dates-dates-automatic">Recipe 8.8</a> for details.) To
            perform an expiration operation later, determine which rows have a
            creation date that is too old by comparing that date to the
            current date. For example, the statement to expire rows that were
            created more than <em><code>n</code></em> days ago might look
            like this:</p><pre data-type="programlisting" data-code-language="sql">DELETE FROM mytbl WHERE create_date &lt; DATE_SUB(NOW(),INTERVAL <em><code>n</code></em> DAY);</pre></li><li><p>Store an explicit expiration date in each row by calculating
            the expiration date with <code>DATE_ADD()</code> when the row is created. For
            a row that should expire in <em><code>n</code></em> days, do
            this:</p><pre data-type="programlisting" data-code-language="sql">INSERT INTO mytbl (expire_date,...)
VALUES(DATE_ADD(NOW(),INTERVAL <em><code>n</code></em> DAY),...);</pre><p>To perform the expiration operation in this case, compare
            the expiration dates to the current date to see which have been
            reached:</p><pre data-type="programlisting" data-code-language="sql"><code class="k">DELETE</code> <code class="k">FROM</code> <code class="n">mytbl</code> <code class="k">WHERE</code> <code class="n">expire_date</code> <code class="o">&lt;</code> <code class="n">NOW</code><code class="p">();</code></pre></li></ul></div></section><section data-type="sect3" data-pdf-bookmark="Comparing times to one another"><div class="sect3" id="idm45820370282048"><h3>Comparing times to one another</h3><p>Comparisons involving times are similar to those involving
        dates. For example, to find times in the <code>t1</code> column that occurred from 9 AM to 2 PM,
        use an expression like one of these:</p><pre data-type="programlisting">WHERE t1 BETWEEN '09:00:00' AND '14:00:00';
WHERE HOUR(t1) BETWEEN 9 AND 14;</pre><p>For an indexed <code>TIME</code> column,
        the first method is more efficient. The second method has the
        property that it works not only for <code>TIME</code> columns, but for <code>DATETIME</code> and <code>TIMESTAMP</code> columns as well.</p></div></section><section data-type="sect3" data-pdf-bookmark="Comparing dates to calendar days"><div class="sect3" id="dates_to_calendar"><h3>Comparing dates to calendar days</h3><p>To answer questions about particular days of the year, use
        calendar-day testing. The following examples illustrate how to do this
        in the context of looking for birthdays:</p><ul><li><p>Who has a birthday today? This requires matching a
            particular calendar day, so you extract the month and day but
            ignore the year when performing comparisons:</p><pre data-type="programlisting">WHERE MONTH(d) = MONTH(CURDATE()) AND DAYOFMONTH(d) = DAYOFMONTH(CURDATE());</pre><p>This kind of statement commonly is applied to biographical
            data to find lists of actors, politicians, musicians, and so
            forth, who were born on a particular day of the year.</p><p>It’s tempting to use <code>DAYOFYEAR()</code> to solve <q>on this day</q> problems because it
            results in simpler statements. But <code>DAYOFYEAR()</code> doesn’t work properly for
            leap years. The presence of February 29 throws off the values for
            days from March through December.</p></li><li><p>Who has a birthday this month? In this case, it’s necessary
            to check only the month:</p><pre data-type="programlisting">WHERE MONTH(d) = MONTH(CURDATE());</pre></li><li><p>Who has a birthday next month? The trick here is that you
            can’t just add one to the current month to get the month number
            that qualifying dates must match. That gives you 13 for dates in
            December. To make sure that you get 1 (January), use either of the
            following techniques:</p><pre data-type="programlisting">WHERE MONTH(d) = MONTH(DATE_ADD(CURDATE(),INTERVAL 1 MONTH));
WHERE MONTH(d) = MOD(MONTH(CURDATE()),12)+1;</pre></li></ul></div></section></div></section></div></section></div></section></div></body></html>