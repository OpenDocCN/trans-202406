<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Building a Chart"><div class="chapter" id="building_a_chart">
<h1><span class="label">Chapter 4. </span>Building a Chart</h1>


<p class="lead">Charts are at the heart of Helm. In addition to installing them into a Kubernetes cluster or managing the instances of charts you’ve installed, you can build new charts or alter existing ones. In the next three chapters we will cover a lot of details about charts including creating them, the elements inside them, templating Kubernetes manifests, testing charts, dependencies, and more.</p>

<p>In this chapter you will learn how to create a new chart and learn about the many parts of a chart. This will include the use of several built-in commands that can help you in the chart development process.</p>

<p>Charts are the packages Helm works with. They are conceptually similar to<a data-type="indexterm" data-primary="package managers" data-secondary="charts as packages" id="idm46125996998184"/><a data-type="indexterm" data-primary="packages" data-secondary="charts as" id="idm46125996997208"/><a data-type="indexterm" data-primary="charts" data-secondary="as packages" data-secondary-sortas="packages" id="idm46125996996264"/><a data-type="indexterm" data-primary="charts" data-secondary="about" data-tertiary="templates" id="idm46125996995048"/><a data-type="indexterm" data-primary="templates" data-secondary="about charts" id="idm46125996993832"/> Debian packages used by APT or Formula used by Homebrew for macOS. The conceptual similarity is where the similarities end. Charts are designed to target Kubernetes as a platform that has its own unique style. At the heart of charts are templates to generate Kubernetes manifests that can be installed and managed in a cluster.</p>

<p>Before we dig into templates in <a data-type="xref" href="ch05.xhtml#developing_templates">Chapter 5</a>, let’s start by creating a basic fully functional chart. <a data-type="indexterm" data-primary="resources for learning" data-secondary="building anvil chart" id="idm46125996990968"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="Anvil example online source" id="idm46125996989944"/><a data-type="indexterm" data-primary="building charts" data-secondary="Anvil example online source" id="idm46125996988760"/>To do that we will cover an example chart named <em>anvil</em>. Using that chart you will learn about using Helm to generate a chart, the structure of charts and files within them, packaging charts, and linting charts. Reference the online source for this chart at <a href="https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil"><em class="hyperlink">https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil</em></a>.</p>






<section data-type="sect1" data-pdf-bookmark="The Chart Creation Command"><div class="sect1" id="idm46125996985944">
<h1>The Chart Creation Command</h1>

<p>Helm includes the <code>create</code> command to make it easy for you to create a chart of your own, and it’s a great way to get started.<a data-type="indexterm" data-primary="create command" id="ch04-build2"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="create command" id="ch04-build"/><a data-type="indexterm" data-primary="building charts" data-secondary="create command" id="ch04-build3"/><a data-type="indexterm" data-primary="templates" data-secondary="chart create command" id="ch04-build4"/><a data-type="indexterm" data-primary="Nginx" data-secondary="helm create command" id="idm46125996978424"/> This command creates a new Nginx chart, with a name of your choice, following best practices for a chart layout. Since Kubernetes clusters can have different methods to expose an application, this chart makes the way Nginx is exposed to network traffic configurable so it can be exposed in a wide variety of clusters.</p>

<p>The <code>create</code> command creates a chart for you, with all the required chart structure and files. These files are documented to help you understand what is needed, and the templates it provides showcase multiple Kubernetes manifests working together to deploy an application. In addition, you can install and test this chart right out of the box.</p>

<p>Throughout this chapter we will look at an example application named <em>anvil</em>. It is a simple application that will show you the structure of a chart and provide you the chance to alter a chart for a different application. To create the new chart, run the following command from a command prompt:</p>

<pre data-type="programlisting">$ helm create anvil</pre>

<p>This will create a new chart as a subdirectory of your current directory with the name <em>anvil</em>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125996973000">
<h5>Different Starting Points</h5>
<p>Nginx is a good starting point to showcase the parts of a chart and for basic stateless services.<a data-type="indexterm" data-primary="Nginx" data-secondary="helm create command" data-tertiary="about Nginx as default" id="idm46125996971560"/> However, if you regularly create charts that do not follow the Nginx model, a different starting point would be more helpful. For this purpose, Helm has a feature called <em>starter packs</em>, which <code>helm create</code> can utilize to provide a different starting point to generate a chart from. This is covered in <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a>.</p>
</div></aside>

<p>The new chart is a directory containing a number of files and folders. This does not include every file and folder—you will discover some more in the next couple chapters. These are the basic ones needed for a functioning chart:<a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="create command directory structure" id="idm46125996967432"/><a data-type="indexterm" data-primary="create command" data-secondary="directory structure" id="idm46125996966392"/><a data-type="indexterm" data-primary="templates" data-secondary="chart create command" data-tertiary="directory structure" id="idm46125996965448"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="create command directory structure" id="idm46125996964232"/><a data-type="indexterm" data-primary="building charts" data-secondary="create command" data-tertiary="directory structure" id="idm46125996963000"/><a data-type="indexterm" data-primary="directory structure from create command" id="idm46125996961784"/></p>

<pre id="chapter_5_new_chart_dir" data-type="programlisting">anvil
├── Chart.yaml <a class="co" id="co_building_a_chart_CO1-1" href="#callout_building_a_chart_CO1-1"><img src="Images/1.png" alt="1"/></a>
├── charts <a class="co" id="co_building_a_chart_CO1-2" href="#callout_building_a_chart_CO1-2"><img src="Images/2.png" alt="2"/></a>
├── templates <a class="co" id="co_building_a_chart_CO1-3" href="#callout_building_a_chart_CO1-3"><img src="Images/3.png" alt="3"/></a>
│   ├── NOTES.txt <a class="co" id="co_building_a_chart_CO1-4" href="#callout_building_a_chart_CO1-4"><img src="Images/4.png" alt="4"/></a>
│   ├── _helpers.tpl
│   ├── deployment.yaml
│   ├── ingress.yaml
│   ├── service.yaml
│   ├── serviceaccount.yaml
│   └── tests
│       └── test-connection.yaml <a class="co" id="co_building_a_chart_CO1-5" href="#callout_building_a_chart_CO1-5"><img src="Images/5.png" alt="5"/></a>
└── values.yaml <a class="co" id="co_building_a_chart_CO1-6" href="#callout_building_a_chart_CO1-6"><img src="Images/6.png" alt="6"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_building_a_chart_CO1-1" href="#co_building_a_chart_CO1-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>The <em>Chart.yaml</em> file contains metadata and some functionality controls for the chart.<a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="about" id="idm46125996945224"/></p></dd>
<dt><a class="co" id="callout_building_a_chart_CO1-2" href="#co_building_a_chart_CO1-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>Dependent charts can optionally be held in the <em>charts</em> directory. Chart dependencies are covered in <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a>. For now this will be an empty directory.</p></dd>
<dt><a class="co" id="callout_building_a_chart_CO1-3" href="#co_building_a_chart_CO1-3"><img src="Images/3.png" alt="3"/></a></dt>
<dd><p>Templates used to generate Kubernetes manifests are stored in the <em>templates</em> directory.</p></dd>
<dt><a class="co" id="callout_building_a_chart_CO1-4" href="#co_building_a_chart_CO1-4"><img src="Images/4.png" alt="4"/></a></dt>
<dd><p>The <em>NOTES.txt</em> file is a special template. When a chart is installed, the <em>NOTES.txt</em> template is rendered and displayed rather than being installed into a cluster.<a data-type="indexterm" data-primary="templates" data-secondary="NOTES.txt" id="idm46125996934024"/><a data-type="indexterm" data-primary="NOTES.txt template" id="idm46125996933048"/></p></dd>
<dt><a class="co" id="callout_building_a_chart_CO1-5" href="#co_building_a_chart_CO1-5"><img src="Images/5.png" alt="5" width="12" height="12"/></a></dt>
<dd><p>Templates can include tests that are not installed as part of the <code>install</code> or <code>upgrade</code> commands.<a data-type="indexterm" data-primary="templates" data-secondary="testing and create command" id="idm46125996928760"/><a data-type="indexterm" data-primary="testing" data-secondary="templates and create command" id="idm46125996927784"/> This chart includes a test that is used by the <code>helm test</code> command. Testing is covered in <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a>.</p></dd>
<dt><a class="co" id="callout_building_a_chart_CO1-6" href="#co_building_a_chart_CO1-6"><img src="Images/6.png" alt="6" width="12" height="12"/></a></dt>
<dd><p>Default values passed to the templates when Helm is rendering the manifests are in the <em>values.yaml</em> file. When you instantiate a chart, these values can be 
<span class="keep-together">overridden</span>.<a data-type="indexterm" data-primary="values.yaml file" data-secondary="Values from" data-tertiary="template default values" id="idm46125996921880"/><a data-type="indexterm" data-primary="templates" data-secondary="values.yaml file for default values" id="idm46125996920600"/></p></dd>
</dl>

<p>You can install this newly created chart without any modifications by running the following command:</p>

<pre data-type="programlisting">$ helm install myapp anvil</pre>

<p>When you run this command Helm will create an instance of the chart running in the cluster with the name <em>myapp</em>. It will install it using the currently configured connection and context you use for Kubernetes. Helm is using the same configuration you’re using when you use <code>kubectl</code>, the command-line application for Kubernetes. In that command the final argument of <em>anvil</em> is the directory where the chart is located.</p>

<p>The output from this command includes content generated by rendering the <em>NOTES.txt</em> template, as shown here:</p>

<pre data-type="programlisting">NAME: myapp
LAST DEPLOYED: Sun Apr  5 08:12:59 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1
NOTES:
1. Get the application URL by running these commands:
  export POD_NAME=$(kubectl get pods --namespace default ↵
    -l "app.kubernetes.io/name=anvil,app.kubernetes.io/instance=myapp" ↵
    -o jsonpath="{.items[0].metadata.name}")
  echo "Visit http://127.0.0.1:8080 to use your application"
  kubectl --namespace default port-forward $POD_NAME 8080:80</pre>

<p>The <code>NOTES</code> section contains information on connecting to the application. Depending on the values you pass into the chart when it is instantiated, this information can be very different. This chart can be configured to use a ClusterIP, NodePort, LoadBalancer, and Ingress to expose an application. By default, a ClusterIP is used.</p>

<p>If you follow the directions in the notes you will see the default Nginx web page to show you it’s running, as shown in <a data-type="xref" href="#chapter_5_nginx">Figure 4-1</a>.<a data-type="indexterm" data-primary="Nginx" data-secondary="web page indicating running" id="idm46125996911944"/></p>

<figure><div id="chapter_5_nginx" class="figure">
<img src="Images/lehe_0401.png" alt="Nginx" width="500"/>
<h6><span class="label">Figure 4-1. </span>Default Nginx web page when you visit the running application</h6>
</div></figure>

<p>The methods to expose the application are tied to built-in Kubernetes resource types rather than features of the application.<a data-type="indexterm" data-primary="Kubernetes" data-secondary="Helm" data-tertiary="methods to expose applications" id="idm46125996908136"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="resources" data-tertiary="methods to expose applications" id="idm46125996906872"/><a data-type="indexterm" data-primary="resources" data-secondary="methods to expose applications" id="idm46125996905640"/> That makes them portable to your custom applications. The methods to expose applications include:</p>
<dl>
<dt>ClusterIP</dt>
<dd>
<p>A configuration option on the Kubernetes <code>Service</code> resource type that <a data-type="indexterm" data-primary="ClusterIP" id="idm46125996902264"/>exposes the service on a cluster-level internal IP address.</p>
</dd>
<dt>NodePort</dt>
<dd>
<p>An alternative option for Kubernetes <code>Service</code> resources that exposes <a data-type="indexterm" data-primary="NodePort" id="idm46125996899624"/>the service on a static port of each node. A ClusterIP is automatically created as well.</p>
</dd>
<dt>LoadBalancer</dt>
<dd>
<p>A Kubernetes <code>Service</code> configuration option that exposes an application <a data-type="indexterm" data-primary="LoadBalancer" id="idm46125996896888"/>externally using a load balancer provided by the hosting provider.</p>
</dd>
<dt>Ingress</dt>
<dd>
<p>Ingress resources are additional resources to <code>Service</code>s that expose a <a data-type="indexterm" data-primary="Ingress" id="idm46125996894216"/>service over HTTP and HTTPS. An Ingress Controller, such as ingress-nginx, is required for this to work.</p>
</dd>
</dl>

<p>If you installed this chart into your cluster to test it, you can delete the instance from your cluster by running the following command:</p>

<pre data-type="programlisting">$ helm delete myapp</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When the chart is installed the image used for Nginx, by default, <a data-type="indexterm" data-primary="Nginx" data-secondary="images from Docker Official Images" id="idm46125996890824"/><a data-type="indexterm" data-primary="Docker" data-secondary="Nginx default images" id="idm46125996889752"/>is the latest version of the image from the <a href="https://oreil.ly/YghQP">Docker Official Images</a>. If the Kubernetes cluster you are working with does not have access to <em>hub.docker.com</em> you won’t be able to install the image. You would need to set the image to one your cluster has access to.</p>
</div>

<p>Now that a working chart has been scaffolded, let’s take a look at what’s inside and modify it for the Anvil application.<a data-type="indexterm" data-startref="ch04-build" id="idm46125996886728"/><a data-type="indexterm" data-startref="ch04-build2" id="idm46125996886024"/><a data-type="indexterm" data-startref="ch04-build3" id="idm46125996885352"/><a data-type="indexterm" data-startref="ch04-build4" id="idm46125996884680"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The Chart.yaml File"><div class="sect1" id="idm46125996985032">
<h1>The Chart.yaml File</h1>

<p>Look inside the <em>anvil</em> directory and you’ll find a file named <em>Chart.yaml</em>. <a data-type="indexterm" data-primary="building charts" data-secondary="Chart.yaml file" id="ch04-chym"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="Chart.yaml file" id="ch04-chym2"/><a data-type="indexterm" data-primary="Chart.yaml file" id="ch04-chym3"/><a data-type="indexterm" data-primary="YAML" data-secondary="Chart.yaml" id="ch04-chym4"/><a data-type="indexterm" data-primary="create command" data-secondary="Chart.yaml file" id="ch04-chym5"/><a data-type="indexterm" data-primary="templates" data-secondary="chart create command" data-tertiary="Chart.yaml file" id="ch04-chym6"/>The <em>Chart.yaml</em> file tells Helm and other tools about your chart. Other tools include Kubeapps (an on-premise catalog and application installer), the Artifact Hub (a listing of cloud native artifacts), and many others.</p>

<p>When you open the <em>Chart.yaml</em> file, you will see the contents shown in <a data-type="xref" href="#chapter_5_generated_chart_yaml">Example 4-1</a>.</p>
<div id="chapter_5_generated_chart_yaml" data-type="example">
<h5><span class="label">Example 4-1. </span>The generated Chart.yaml file</h5>

<pre data-type="programlisting">apiVersion: v2 <a class="co" id="co_building_a_chart_CO2-1" href="#callout_building_a_chart_CO2-1"><img src="Images/1.png" alt="1"/></a>
name: anvil <a class="co" id="co_building_a_chart_CO2-2" href="#callout_building_a_chart_CO2-2"><img src="Images/2.png" alt="2"/></a>
description: A Helm chart for Kubernetes

# A chart can be either an 'application' or a 'library' chart.
#
# Application charts are a collection of templates that can be packaged into ↵
  versioned archives
# to be deployed.
#
# Library charts provide useful utilities or functions for the chart developer.↵
  They're included as
# a dependency of application charts to inject those utilities and functions ↵
  into the rendering
# pipeline. Library charts do not define any templates and therefore cannot be ↵
  deployed.
type: application

# This is the chart version. This version number should be incremented each ↵
  time you make changes
# to the chart and its templates, including the app version.
version: 0.1.0 <a class="co" id="co_building_a_chart_CO2-3" href="#callout_building_a_chart_CO2-3"><img src="Images/3.png" alt="3"/></a>

# This is the version number of the application being deployed. This version ↵
  number should be
# incremented each time you make changes to the application. Versions are not ↵
  expected to
# follow Semantic Versioning. They should reflect the version the application ↵
  is using.
appVersion: 1.16.0</pre></div>
<dl class="calloutlist">
<dt><a class="co" id="callout_building_a_chart_CO2-1" href="#co_building_a_chart_CO2-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>The <code>apiVersion</code> tells Helm what structure the chart is using. An <code>apiVerison</code> of <code>v2</code> is designed for Helm v3.<a data-type="indexterm" data-primary="Helm" data-secondary="versions" data-tertiary="apiVersion in Chart.yaml file" id="idm46125996858232"/><a data-type="indexterm" data-primary="versions of Helm" data-secondary="apiVersion in Chart.yaml file" id="idm46125996856968"/><a data-type="indexterm" data-primary="apiVersion in Chart.yaml file" id="idm46125996856008"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="apiVersion" id="idm46125996855320"/></p></dd>
<dt><a class="co" id="callout_building_a_chart_CO2-2" href="#co_building_a_chart_CO2-2"><img src="Images/2.png" alt="2"/></a></dt>
<dd><p>The name is used to identify the chart in various places.</p></dd>
<dt><a class="co" id="callout_building_a_chart_CO2-3" href="#co_building_a_chart_CO2-3"><img src="Images/3.png" alt="3"/></a></dt>
<dd><p>Charts can have many versions. Helm uses the version information to order and identify charts.<a data-type="indexterm" data-primary="charts" data-secondary="versions" data-tertiary="Chart.yaml file" id="idm46125996849432"/></p></dd>
</dl>

<p>This <em>Chart.yaml</em> file contains numerous keys, of which only three are required. The <code>apiVersion</code> property tells Helm which version of a chart this is. Helm v3 can work with charts whose <code>apiVersion</code> is <code>v1</code> or <code>v2</code>. <code>v1</code> charts are those designed to work with previous versions of Helm. If your charts are designed to work with Helm v3 or newer you should set this to <code>v2</code>. The value of <code>name</code> is typically used as part of the name for Kubernetes resources. This means names are limited to lowercase alphanumeric, <code>-</code>, and <code>.</code> characters and must start and end with an alphanumeric character. Names are typically lowercase alphanumeric characters. The final required key is 
<span class="keep-together"><code>version</code></span>, containing the version of the chart. Versions are expected to follow Semantic Versioning, which was covered in <a data-type="xref" href="ch02.xhtml#Using_Helm">Chapter 2</a>.</p>

<p>You might notice that the style of a <em>Chart.yaml</em> file is similar but mildly different from those of Kubernetes manifests. <em>Chart.yaml</em> files are not the same format as custom resources but do contain some of the same properties. The original <em>Chart.yaml</em> files were designed back in 2015, long before Kubernetes custom resource definitions existed. While Helm has progressed in major versions, it has maintained a certain amount of backward compatibility over time to not disrupt users too much. This has led to differences between the <em>Chart.yaml</em> file format and Kubernetes manifests.</p>

<p><em>Chart.yaml</em> files also contain descriptive information, which is useful as it’s presented in user interfaces. The <code>description</code> field in <a data-type="xref" href="#chapter_5_generated_chart_yaml">Example 4-1</a> is one such field, but you can add additional fields, such as the following:</p>

<ul>
<li>
<p><code>home</code> is a URL to the chart or projects homepage.</p>
</li>
<li>
<p><code>icon</code> is an image (e.g., PNG or SVG file) in the form of a URL.<a data-type="indexterm" data-primary="icon property" id="idm46125996833512"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="icon property" id="idm46125996832728"/></p>
</li>
<li>
<p><code>maintainers</code> contains a list of maintainers. Each maintainer on the list can have a name, email, and URL.</p>
</li>
<li>
<p><code>keywords</code> can hold a list of keywords about the project.</p>
</li>
<li>
<p><code>sources</code> is for a list of URLs to source code for the project or chart.</p>
</li>
</ul>

<p>A full description of the properties in the <em>Chart.yaml</em> file are available in <a data-type="xref" href="app01.xhtml#appendix_a_chart_api_versions">Appendix A</a>, for reference.</p>

<p>The generated <em>Chart.yaml</em> file can be modified for the Anvil application. The following modifications update the required fields, add some descriptive files, and remove comments:<a data-type="indexterm" data-primary="icon property" data-secondary="example" id="idm46125996825160"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="icon property" data-tertiary="example" id="idm46125996824184"/></p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v2</code>
<code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">anvil</code>
<code class="nt">description</code><code class="p">:</code> <code class="l-Scalar-Plain">A surprise to catch something speedy.</code>
<code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">0.1.0</code>
<code class="nt">appVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">9.17.49</code>
<code class="nt">icon</code><code class="p">:</code> <code class="l-Scalar-Plain">https://wile.example.com/anvil.svg</code>
<code class="nt">keywords</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">road runner</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">anvil</code>
<code class="nt">home</code><code class="p">:</code> <code class="l-Scalar-Plain">https://wile.example.com/</code>
<code class="nt">sources</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">https://github.com/Masterminds/learning-helm/tree/main/chapter4/anvil</code>
<code class="nt">maintainers</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ACME Corp</code>
    <code class="nt">email</code><code class="p">:</code> <code class="l-Scalar-Plain">maintainers@example.com</code>
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">Wile E. Coyote</code>
    <code class="nt">email</code><code class="p">:</code> <code class="l-Scalar-Plain">wile@example.com</code></pre>

<p>One property that was in the generated <em>Chart.yaml</em> file but is not in the <a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="type property" data-tertiary="application default" id="idm46125996767128"/><a data-type="indexterm" data-primary="type property" data-secondary="application default" id="idm46125996765976"/>one for Anvil is <code>type</code>. Anvil is an application which is the default value for the <code>type</code> field, so the <code>type</code> field is not required. The other type of chart is a library chart, which is covered in <a data-type="xref" href="ch07.xhtml#chart_repositories">Chapter 7</a>.</p>

<p>The <code>appVersion</code> property is <a data-type="indexterm" data-primary="appVersion property" id="idm46125996761944"/>unique. It is both descriptive and regularly used within the templates. The <code>appVersion</code> property represents the version of the primary or combined application. For example, if the application being packaged was WordPress, it would be the version of WordPress.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The <code>icon</code> property is a URL, and that can include data URLs. <a href="https://oreil.ly/1gj45">Data URLs</a> enable<a data-type="indexterm" data-primary="icon property" id="idm46125996758136"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="icon property" id="idm46125996757400"/> you to embed small files in URL form. This is especially useful if the logo is a small SVG file. If a chart may be run in air-gapped on-premise environments or you do not want user interfaces constantly downloading a file from your web server, a data URL is a useful choice.<a data-type="indexterm" data-startref="ch04-chym" id="idm46125996756040"/><a data-type="indexterm" data-startref="ch04-chym2" id="idm46125996755368"/><a data-type="indexterm" data-startref="ch04-chym3" id="idm46125996754696"/><a data-type="indexterm" data-startref="ch04-chym4" id="idm46125996754024"/><a data-type="indexterm" data-startref="ch04-chym5" id="idm46125996753352"/><a data-type="indexterm" data-startref="ch04-chym6" id="idm46125996752680"/></p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Modifying Templates"><div class="sect1" id="idm46125996883752">
<h1>Modifying Templates</h1>

<p>In order to modify this chart for the Anvil application or your own custom application, <a data-type="indexterm" data-primary="templates" data-secondary="modifying" id="ch04-modtemp"/><a data-type="indexterm" data-primary="YAML" data-secondary="templates" data-tertiary="template modification" id="ch04-modtemp2"/><a data-type="indexterm" data-primary="YAML" data-secondary="Chart.yaml" data-tertiary="template modification" id="ch04-modtemp3"/><a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="modifying" id="ch04-modtemp4"/><a data-type="indexterm" data-primary="building charts" data-secondary="modifying templates" id="ch04-modtemp6"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="modifying templates" id="ch04-modtemp5"/><a data-type="indexterm" data-primary="Nginx" data-secondary="helm create command" id="idm46125996741992"/>you will need to understand and modify templates. Out of the box, the templates created by the <code>helm create</code> command run Nginx as a stateless application. In the example we are working through, Nginx will need to be replaced with Anvil.</p>

<p>Helm is written in the Go programming language, and Go includes template packages.<a data-type="indexterm" data-primary="Helm" data-secondary="Go programming language" data-tertiary="Helm written in" id="idm46125996739992"/><a data-type="indexterm" data-primary="Go programming language" data-secondary="Helm written in" id="idm46125996738744"/><a data-type="indexterm" data-primary="Go programming language" data-secondary="template engine" data-tertiary="template packages" id="idm46125996737800"/><a data-type="indexterm" data-primary="templates" data-secondary="modifying" data-tertiary="Go template packages" id="idm46125996736584"/><a data-type="indexterm" data-primary="building charts" data-secondary="modifying templates" data-tertiary="Go template packages" id="idm46125996735368"/><a data-type="indexterm" data-primary="Helm" data-secondary="Go programming language" data-tertiary="template packages" id="idm46125996734152"/> Helm leverages the text template package as the foundation for its templates. This template language is similar to other template languages and includes loops, if/then logic, functions, and more. An example template of a YAML file follows:<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="example template" id="idm46125996732552"/><a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="Values examples" id="idm46125996731336"/></p>

<pre data-type="programlisting">product: {{ .Values.product | default "rocket" | quote }}</pre>

<p>In this YAML file there is a key name of <code>product</code>. The value is generated using a template. <code>{{</code> and <code>}}</code> are the opening and closing brackets to enter and exit template logic. There are three parts to the template logic separated by a <code>|</code>. This is called a pipeline, and it works the same way as a pipeline in Unix-based systems. The value or output of a function on the left is passed in as the last argument to the next item in the pipeline. In this case, the pipeline starts with the value from the property in <code>.Values.product</code>. This comes from the data object passed in when the templates are rendered. The value of this data is piped as the last argument to the <code>default</code> function, which is one of the functions provided by Helm. If the value passed in is empty, the <code>default</code> function uses the default value of <code>"rocket"</code>, ensuring there is a value. This is then sent to the <code>quote</code> function, which ensures the string is wrapped in quotes before writing it to the template.</p>

<p>The <code>.</code> at the start of <code>.Values.product</code> is important. This is considered the root object in the current scope. <code>.Values</code> is a property on the root object.</p>








<section data-type="sect2" data-pdf-bookmark="The Deployment"><div class="sect2" id="idm46125996722440">
<h2>The Deployment</h2>

<p>Helm charts can hold templates for any Kubernetes resource type you might use. <a data-type="indexterm" data-primary="Deployment (Kubernetes)" data-secondary="template" id="ch04-depl"/><a data-type="indexterm" data-primary="templates" data-secondary="Deployment" id="ch04-depl2"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Deployment" data-tertiary="template" id="ch04-depl3"/><a data-type="indexterm" data-primary="building charts" data-secondary="Deployment template" id="ch04-depl6"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="Deployment template" id="ch04-depl5"/>That includes <code>StatefulSet</code>s, <code>Job</code>s, <code>PersistentVolumeClaim</code>s, <code>Service</code>s, and much more. The chart created with <code>helm create</code> is designed to run a stateless service as a Kubernetes Deployment. The example application we are using here for Anvil is a stateless application, which means it will work well as a deployment.</p>

<p>To understand the <code>Deployment</code> template, we can take a look at the <em>deployment.yaml</em> file<a data-type="indexterm" data-primary="YAML" data-secondary="deployment.yaml file" id="ch04-depym"/><a data-type="indexterm" data-primary="Deployment (Kubernetes)" data-secondary="deployment.yaml file" id="ch04-depym3"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Deployment" data-tertiary="deployment.yaml file" id="ch04-depym2"/><a data-type="indexterm" data-primary="create command" data-secondary="deployment.yaml file" id="ch04-depym4"/> in the <em>templates</em> directory of the chart. The following is the templated version of the <code>Deployment</code> up to the <code>spec</code> section:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apps/v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="p-Indicator">{{</code> <code class="nv">include "anvil.fullname" .</code> <code class="p-Indicator">}}</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="p-Indicator">{{</code><code class="nv">- include "anvil.labels" . | nindent 4</code> <code class="p-Indicator">}}</code></pre>

<p>This looks very similar to the start of a Kubernetes manifest. It has an <code>apiVersion</code>, the <code>kind</code>, and <code>metadata</code>. Once you get into the <code>metadata</code> you’ll notice the templating begins.</p>
<div data-type="tip"><h6>Tip</h6>
<p>If you are unfamiliar with the structure of Kubernetes Deployments, you can read about them in the <a href="https://oreil.ly/aIuIE">Kubernetes documentation</a>.</p>
</div>

<p>The <code>include</code> template function enables including the output of one template<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="functions in example" id="idm46125999384248"/> in another template, and this works in pipelines. The first argument to the <code>include</code> function is the name of the template to use. The <code>.</code> passed in as the second argument is the root object. This is passed in so the properties and functions on the root object can be used within the called template.</p>

<p><em>anvil.fullname</em> and <em>anvil.labels</em> are two reusable templates included in the chart via the <em>_helpers.tpl</em> file. (The _ at the start of the name causes it to bubble up to the top of directory listings so you can easily find it among your templates; Helm does not render them into Kubernetes manifests but does make templates in them available for use.) <em>anvil.fullname</em> provides a name based on the name chosen when the chart is instantiated, and <em>anvil.labels</em> provides labels following Kubernetes best practices. The functions are covered in more depth in <a data-type="xref" href="ch05.xhtml#developing_templates">Chapter 5</a>.</p>

<p>After the <code>metadata</code> section of the template is the <code>spec</code> section, which reads as follows:<a data-type="indexterm" data-primary="templates" data-secondary="syntax of templates" data-tertiary="Values examples" id="idm46125999367864"/></p>

<pre id="chapter_5_deployment_spec" data-type="programlisting" data-code-language="yaml"><code class="nt">spec</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">replicas</code><code class="p">:</code><code> </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code> </code><code class="nv">.Values.replicaCount</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>  </code><code class="nt">selector</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">matchLabels</code><code class="p">:</code><code>
</code><code>      </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">include</code><code class="nv"> </code><code class="nv">"anvil.selectorLabels"</code><code class="nv"> </code><code class="nv">.</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">6</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>  </code><code class="nt">template</code><code class="p">:</code><code>
</code><code>    </code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>      </code><code class="nt">labels</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">include</code><code class="nv"> </code><code class="nv">"anvil.selectorLabels"</code><code class="nv"> </code><code class="nv">.</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">8</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>    </code><code class="nt">spec</code><code class="p">:</code><code>
</code><code>    </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">with</code><code class="nv"> </code><code class="nv">.Values.imagePullSecrets</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="nt">imagePullSecrets</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">toYaml</code><code class="nv"> </code><code class="nv">.</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">8</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>    </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">end</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="nt">serviceAccountName</code><code class="p">:</code><code> </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code> </code><code class="nv">include</code><code class="nv"> </code><code class="nv">"anvil.serviceAccountName"</code><code class="nv"> </code><code class="nv">.</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="nt">securityContext</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">toYaml</code><code class="nv"> </code><code class="nv">.Values.podSecurityContext</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">8</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="nt">containers</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code> </code><code class="nv">.Chart.Name</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>          </code><code class="nt">securityContext</code><code class="p">:</code><code>
</code><code>            </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">toYaml</code><code class="nv"> </code><code class="nv">.Values.securityContext</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">12</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>          </code><code class="nt">image</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">{{</code><code class="nv"> </code><code class="s">.Values.image.repository</code><code class="nv"> </code><code class="s">}}:{{</code><code class="nv"> </code><code class="s">.Values.image.tag</code><code class="nv"> </code><code class="s">|</code><code class="nv"> </code><code class="s">default↵</code><code>
</code><code>            </code><code class="s">.Chart.AppVersion</code><code class="nv"> </code><code class="s">}}</code><code class="s">"</code><code> </code><a class="co" id="co_building_a_chart_CO3-1" href="#callout_building_a_chart_CO3-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code>          </code><code class="nt">imagePullPolicy</code><code class="p">:</code><code> </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code> </code><code class="nv">.Values.image.pullPolicy</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>          </code><code class="nt">ports</code><code class="p">:</code><code>
</code><code>            </code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">http</code><code>
</code><code>              </code><code class="nt">containerPort</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">80</code><code>
</code><code>              </code><code class="nt">protocol</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">TCP</code><code>
</code><code>          </code><code class="nt">livenessProbe</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">httpGet</code><code class="p">:</code><code>
</code><code>              </code><code class="nt">path</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">/</code><code>
</code><code>              </code><code class="nt">port</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">http</code><code>
</code><code>          </code><code class="nt">readinessProbe</code><code class="p">:</code><code>
</code><code>            </code><code class="nt">httpGet</code><code class="p">:</code><code>
</code><code>              </code><code class="nt">path</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">/</code><code>
</code><code>              </code><code class="nt">port</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">http</code><code>
</code><code>          </code><code class="nt">resources</code><code class="p">:</code><code>
</code><code>            </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">toYaml</code><code class="nv"> </code><code class="nv">.Values.resources</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">12</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">with</code><code class="nv"> </code><code class="nv">.Values.nodeSelector</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="nt">nodeSelector</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">toYaml</code><code class="nv"> </code><code class="nv">.</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">8</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">end</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>    </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">with</code><code class="nv"> </code><code class="nv">.Values.affinity</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="nt">affinity</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">toYaml</code><code class="nv"> </code><code class="nv">.</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">8</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>    </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">end</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>    </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">with</code><code class="nv"> </code><code class="nv">.Values.tolerations</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>      </code><code class="nt">tolerations</code><code class="p">:</code><code>
</code><code>        </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">toYaml</code><code class="nv"> </code><code class="nv">.</code><code class="nv"> </code><code class="nv">|</code><code class="nv"> </code><code class="nv">nindent</code><code class="nv"> </code><code class="nv">8</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code><code>
</code><code>    </code><code class="p-Indicator">{</code><code class="p-Indicator">{</code><code class="nv">-</code><code class="nv"> </code><code class="nv">end</code><code> </code><code class="p-Indicator">}</code><code class="p-Indicator">}</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_building_a_chart_CO3-1" href="#co_building_a_chart_CO3-1"><img src="Images/1.png" alt="1"/></a></dt>
<dd><p>The location and version of the container image is configurable via values.</p></dd>
</dl>

<p>The <code>spec</code> section completes the deployment. Most of this section is filling in data with the properties on <code>.Values</code>. There are a few elements that are hardcoded, such as the ports used to expose the application. Anvil is exposed over HTTP on port 80, so we do not need to change the port. If your containers are exposed on different ports, you will need to make changes here.</p>

<p>The value of <code>image</code> for the container is set using values. You won’t find the location of the image hardcoded here. This is useful for those cases where the image location needs to be set to a different location when a chart is instantiated. It means we need to change the location in the default values.</p>

<p>The properties on <code>.Values</code> are computed based on a number of factors. <a data-type="indexterm" data-primary="values.yaml file" data-secondary="Values from" id="idm46125998249224"/><a data-type="indexterm" data-primary="Values" data-secondary="values.yaml file providing" id="idm46125998248216"/>The default values and starting point are based on the values provided by the <em>values.yaml</em> file in the chart. The <em>values.yaml</em> file is covered in the next section. These values can be overridden by values passed in when the chart is instantiated. The <em>helm</em> CLI has flags to pass in values directly (i.e., <code>--set</code>, <code>--set-file</code>, and <code>--set-string</code>) or to pass in a file with values (i.e., <code>-f</code> or <code>--values</code>). The values are merged together, with those being passed in later taking precedence.</p>

<p>Templates are a large topic and typically make up the bulk of a chart. <a data-type="xref" href="ch05.xhtml#developing_templates">Chapter 5</a> is dedicated to templates.<a data-type="indexterm" data-startref="ch04-modtemp" id="idm46125998250264"/><a data-type="indexterm" data-startref="ch04-modtemp2" id="idm46125998328232"/><a data-type="indexterm" data-startref="ch04-modtemp3" id="idm46125998327560"/><a data-type="indexterm" data-startref="ch04-modtemp4" id="idm46125998326888"/><a data-type="indexterm" data-startref="ch04-depl" id="idm46125998326216"/><a data-type="indexterm" data-startref="ch04-depl2" id="idm46125998325544"/><a data-type="indexterm" data-startref="ch04-depym" id="idm46125998319528"/><a data-type="indexterm" data-startref="ch04-depl3" id="idm46125998318856"/><a data-type="indexterm" data-startref="ch04-depym2" id="idm46125998318184"/><a data-type="indexterm" data-startref="ch04-depym3" id="idm46125998317512"/><a data-type="indexterm" data-startref="ch04-modtemp5" id="idm46125998316840"/><a data-type="indexterm" data-startref="ch04-modtemp6" id="idm46125998316168"/><a data-type="indexterm" data-startref="ch04-depl5" id="idm46125998269960"/><a data-type="indexterm" data-startref="ch04-depl6" id="idm46125998269288"/><a data-type="indexterm" data-startref="ch04-depym4" id="idm46125998268616"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Using the Values File"><div class="sect1" id="idm46125996721816">
<h1>Using the Values File</h1>

<p>When someone instantiates an application in a Kubernetes cluster from a chart, <a data-type="indexterm" data-primary="building charts" data-secondary="values.yaml file" id="ch04-val3"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="values.yaml file" id="ch04-val2"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="building charts" id="ch04-val"/><a data-type="indexterm" data-primary="YAML" data-secondary="values.yaml file" data-tertiary="building charts" id="ch04-val4"/><a data-type="indexterm" data-primary="create command" data-secondary="values.yaml file" id="ch04-val5"/><a data-type="indexterm" data-primary="templates" data-secondary="chart create command" data-tertiary="values.yaml file" id="ch04-val6"/>they don’t need to supply all the values used in the templates. If they did, it would provide for a difficult user experience. This is where the <em>values.yaml</em> file comes in.</p>

<p>Charts include a <em>values.yaml</em> file that sits alongside the <em>Chart.yaml</em> file in the root of a chart. <a data-type="indexterm" data-primary="templates" data-secondary="values.yaml file for default values" id="idm46125998263000"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="Values from" data-tertiary="template default values" id="idm46125998351208"/>The <em>values.yaml</em> file contains the default values used by the chart, and it is a form of documentation for the custom values that can be passed into a chart.</p>

<p><em>values.yaml</em> is an unstructured YAML file. There are some common and useful practices, which will be covered shortly, but nothing is required in the format of the YAML. This enables chart creators to provide a structure and information that works well for them. A <em>values.yaml</em> file can contain numerous things, from simple substitution for Kubernetes manifest properties to elements needed for application-specific business logic.</p>








<section data-type="sect2" data-pdf-bookmark="Container Images"><div class="sect2" id="idm46125998365400">
<h2>Container Images</h2>

<p>The opening part of the <em>values.yaml</em> file created by <code>helm create</code> contains the <a data-type="indexterm" data-primary="values.yaml file" data-secondary="building charts" data-tertiary="container images" id="idm46125998362808"/><a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="values.yaml file" id="idm46125998355704"/><a data-type="indexterm" data-primary="images (container images)" data-secondary="values.yaml file" id="idm46125998354488"/>image information along with some opening documentation and information on replicas:</p>

<pre id="chapter_5_values_image" data-type="programlisting" data-code-language="yaml"><code class="c1"># Default values for anvil.</code><code>
</code><code class="c1"># This is a YAML-formatted file.</code><code>
</code><code class="c1"># Declare variables to be passed into your templates.</code><code>

</code><code class="nt">replicaCount</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">1</code><code>

</code><code class="nt">image</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">repository</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ghcr.io/masterminds/learning-helm/anvil-app</code><code> </code><a class="co" id="co_building_a_chart_CO4-1" href="#callout_building_a_chart_CO4-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code>  </code><code class="nt">pullPolicy</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">IfNotPresent</code><code> </code><a class="co" id="co_building_a_chart_CO4-2" href="#callout_building_a_chart_CO4-2"><img src="Images/2.png" alt="2"/></a><code>
</code><code>  </code><code class="c1"># Overrides the image tag whose default is the chart version.</code><code>
</code><code>  </code><code class="nt">tag</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">"</code><code> </code><a class="co" id="co_building_a_chart_CO4-3" href="#callout_building_a_chart_CO4-3"><img src="Images/3.png" alt="3"/></a><code>

</code><code class="nt">imagePullSecrets</code><code class="p">:</code><code> </code><code class="p-Indicator">[</code><code class="p-Indicator">]</code><code> </code><a class="co" id="co_building_a_chart_CO4-4" href="#callout_building_a_chart_CO4-4"><img src="Images/4.png" alt="4"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_building_a_chart_CO4-1" href="#co_building_a_chart_CO4-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The location of the image. It has been updated to reflect the location of Anvil.</p></dd>
<dt><a class="co" id="callout_building_a_chart_CO4-2" href="#co_building_a_chart_CO4-2"><img src="Images/2.png" alt="2" width="12" height="12"/></a></dt>
<dd><p>A policy of <code>IfNotPresent</code> means that the image will be cached in the Kubernetes cluster by the version being used. <code>Always</code> is another option that bypasses the cache and always downloads from the repository.</p></dd>
<dt><a class="co" id="callout_building_a_chart_CO4-3" href="#co_building_a_chart_CO4-3"><img src="Images/3.png" alt="3" width="12" height="12"/></a></dt>
<dd><p>By default this chart uses the <code>appVersion</code> as the tag. If an image tag is specified, it is used instead of the <code>appVersion</code>.</p></dd>
<dt><a class="co" id="callout_building_a_chart_CO4-4" href="#co_building_a_chart_CO4-4"><img src="Images/4.png" alt="4" width="12" height="12"/></a></dt>
<dd><p>A list of pull secrets is used when credentials are needed to access a container registry location that is protected with a username and password.</p></dd>
</dl>

<p>This chart and the values represent an application bundled as a single image. The patterns used in the <em>values.yaml</em> file are designed with that in mind. For example, there is only one image location. If your applications have multiple images, each image would have a section containing much of the information here. This includes <code>replicaCount</code>, which is the number of <code>replicas</code> Kubernetes will use when the <code>Deployment</code> is 
<span class="keep-together">created</span>.</p>

<p>The <code>image</code> section contains details about the image. The <code>repository</code> contains the location of the image to use while the <code>pullPolicy</code> tells Kubernetes how often to fetch or cache the images. If a moving tag, such as <code>stable</code>, is used, the <code>pullPolicy</code> should be set to <code>Always</code> so that changes are picked up. Since a version is being used, the default <code>pullPolicy</code> is set to <code>IfNotPresent</code> so that a cached version can be used if available. The <code>tag</code> property provides an opportunity to set a tag that is different from the <code>appVersion</code> set in the <em>Chart.yaml</em> file.</p>

<p>You might notice there is no method to set a digest when fetching an image.<a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="digest in values.yaml file" id="idm46125998538760"/><a data-type="indexterm" data-primary="images (container images)" data-secondary="digest" data-tertiary="values.yaml file" id="idm46125998419672"/> Digests can be different when images are in different repositories. For example, if the Anvil image were copied from Docker Hub to Quay, another image repository, the digest would change for the same image even if the tag and content remained the same. <a data-type="xref" href="ch05.xhtml#developing_templates">Chapter 5</a> provides an example of adding in support for a digest to a chart, if that is desired.</p>

<p>If you need to pull an image from a container registry with access controls, <a data-type="indexterm" data-primary="Secrets (Kubernetes)" data-secondary="pull secrets" id="idm46125998416632"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Secrets" data-tertiary="pull secrets" id="idm46125998525576"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Secrets" data-tertiary="image registry with access controls" id="idm46125998524360"/><a data-type="indexterm" data-primary="pull secrets" id="idm46125998523176"/><a data-type="indexterm" data-primary="containers" data-secondary="container images" data-tertiary="image registry with access controls" id="idm46125998522504"/><a data-type="indexterm" data-primary="images (container images)" data-secondary="image registry" data-tertiary="access controls" id="idm46125998434856"/><a data-type="indexterm" data-primary="security" data-secondary="pull secrets for" id="idm46125998433624"/><a data-type="indexterm" data-primary="Secrets (Kubernetes)" data-secondary="image registry with access controls" id="idm46125998432680"/><a data-type="indexterm" data-primary="access controls with pull secrets" id="idm46125998431720"/>Kubernetes needs to know how to do that. This happens through the use of pull secrets. <code>imagePullSecrets</code> allows you to list the names of pull secrets with access to private registries. Reference the <a href="https://oreil.ly/BL-VO">documentation for creating a pull secret</a>.</p>

<p>The generated chart has some security considerations built in that can be enabled or otherwise configured. <a data-type="indexterm" data-primary="service account from create command" id="idm46125998438584"/><a data-type="indexterm" data-primary="create command" data-secondary="service account created" id="idm46125998437912"/><a data-type="indexterm" data-primary="building charts" data-secondary="create command" data-tertiary="service account created" id="idm46125998436968"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="create command service account" id="idm46125998497928"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="building charts" data-tertiary="service account" id="idm46125998496744"/>A service account for the chart instance is created by default, while the other options are opt-in. The following is what is generated by <code>helm</code> 
<span class="keep-together"><code>create</code></span>:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">serviceAccount</code><code class="p">:</code>
  <code class="c1"># Specifies whether a service account should be created</code>
  <code class="nt">create</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>
  <code class="c1"># Annotations to add to the service account</code>
  <code class="nt">annotations</code><code class="p">:</code> <code class="p-Indicator">{}</code>
  <code class="c1"># The name of the service account to use.</code>
  <code class="c1"># If not set and create is true, a name is generated using the fullname ↵</code>
    <code class="l-Scalar-Plain">template</code>
  <code class="nt">name</code><code class="p">:</code>

<code class="nt">podSecurityContext</code><code class="p">:</code> <code class="p-Indicator">{}</code>
  <code class="c1"># fsGroup: 2000</code>

<code class="nt">securityContext</code><code class="p">:</code> <code class="p-Indicator">{}</code>
  <code class="c1"># capabilities:</code>
  <code class="c1">#   drop:</code>
  <code class="c1">#   - ALL</code>
  <code class="c1"># readOnlyRootFilesystem: true</code>
  <code class="c1"># runAsNonRoot: true</code>
  <code class="c1"># runAsUser: 1000</code></pre>

<p>You will notice that most of the properties in the configuration are comments and are inactive. When the chart is rendered with the values as comments, there is no value for those properties. The value is empty. By having a structure and values as comments the chart is documenting the structure and default values that can be used but isn’t turning on those features.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Exposing Services"><div class="sect2" id="idm46125998364776">
<h2>Exposing Services</h2>

<p>The next section of the <em>values.yaml</em> file deals with exposing the application for others to consume:<a data-type="indexterm" data-primary="values.yaml file" data-secondary="building charts" data-tertiary="exposing services" id="idm46125998486856"/></p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">service</code><code class="p">:</code>
  <code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">ClusterIP</code>
  <code class="nt">port</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code>

<code class="nt">ingress</code><code class="p">:</code>
  <code class="nt">enabled</code><code class="p">:</code> <code class="l-Scalar-Plain">false</code>
  <code class="nt">annotations</code><code class="p">:</code> <code class="p-Indicator">{}</code>
    <code class="c1"># kubernetes.io/ingress.class: nginx</code>
    <code class="c1"># kubernetes.io/tls-acme: "true"</code>
  <code class="nt">hosts</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">host</code><code class="p">:</code> <code class="l-Scalar-Plain">chart-example.local</code>
      <code class="nt">paths</code><code class="p">:</code> <code class="p-Indicator">[]</code>
  <code class="nt">tls</code><code class="p">:</code> <code class="p-Indicator">[]</code>
  <code class="c1">#  - secretName: chart-example-tls</code>
  <code class="c1">#    hosts:</code>
  <code class="c1">#      - chart-example.local</code></pre>

<p>In Kubernetes there are two built-in objects you can use to expose applications. <a data-type="indexterm" data-primary="Service (Kubernetes)" data-secondary="exposing applications" id="idm46125998499432"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Service" data-tertiary="exposing applications" id="idm46125998631624"/><a data-type="indexterm" data-primary="service.yaml" id="idm46125998630472"/><a data-type="indexterm" data-primary="YAML" data-secondary="service.yaml" id="idm46125998629800"/><a data-type="indexterm" data-primary="create command" data-secondary="service.yaml" id="idm46125998621608"/><a data-type="indexterm" data-primary="manifests" data-secondary="building charts" id="idm46125998620664"/>The first is a <code>Service</code>. The <code>service</code> property will let you select the type of <code>Service</code> being used. While <code>ClusterIP</code> is used by default, other options such as <code>NodePort</code> and 
<span class="keep-together"><code>LoadBalancer</code></span> can be used. The few lines of YAML in the <code>service</code> section are paired with the generated <em>service.yaml</em> template to create a full Service manifest to upload to Kubernetes.</p>

<p>The second built-in object is the <code>Ingress</code> manifest, which can be paired with a <code>Service</code>, and the chart has the capability to generate them. <a data-type="indexterm" data-primary="Ingress" data-secondary="manifests in building charts" id="idm46125998544856"/><a data-type="indexterm" data-primary="enabled property" id="idm46125998543816"/><code>Ingress</code> configuration provides a means to show off a common pattern found in charts: the use of an <code>enabled</code> property to turn features on and off. In this case <code>ingress.enabled</code> is set to <code>false</code>. When Helm renders the templates and sees a value of false, the <code>Ingress</code> manifest is skipped. <a data-type="indexterm" data-primary="ingress.yaml file" id="idm46125998562728"/><a data-type="indexterm" data-primary="create command" data-secondary="ingress.yaml file" id="idm46125998561992"/>This is due to the use of an <code>if</code> logic statement in the <code>Ingress</code> template found in the generated <em>ingress.yaml</em> file.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125998545800">
<h5>Ingress Controllers</h5>
<p>For a functional ingress setup you need more than an <code>Ingress</code> resource in Kubernetes. <a data-type="indexterm" data-primary="Ingress" data-secondary="Ingress Controller" id="idm46125998557048"/>The <code>Ingress</code> resource you can include in a chart connects the Ingress Controller to a <code>Service</code>. You will need to have an Ingress Controller running in your cluster because one is not included by default. <a data-type="indexterm" data-primary="Nginx" data-secondary="Ingress Controller" id="idm46125998554984"/><a data-type="indexterm" data-primary="resources for learning" data-secondary="Nginx Ingress Controller" id="idm46125998576264"/>The Kubernetes community provides the <a href="https://oreil.ly/vc3ed">Nginx Ingress Controller</a>, which is a good default option.</p>
</div></aside>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Resource Limits"><div class="sect2" id="idm46125998574248">
<h2>Resource Limits</h2>

<p>When you run applications in production, it is a good practice to set resource limits.<a data-type="indexterm" data-primary="values.yaml file" data-secondary="building charts" data-tertiary="resource limits" id="idm46125998572712"/><a data-type="indexterm" data-primary="resource limits" id="idm46125998570600"/> This prevents, for example, a memory leak in one container from disrupting other containers. When a chart author creates a chart that others are going to use, they may not know where it will be installed and how many resources will be available there. Could this be installed on a laptop by a developer or someone testing out the chart? Or, might this be installed on large production servers? To handle this variance in environment, the recommendation is to put in resource limits and then turn them into comments. This can be found in the next section of the <em>values.yaml</em> file:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">resources</code><code class="p">:</code> <code class="p-Indicator">{}</code>
  <code class="c1"># We usually recommend not to specify default resources and to leave this as</code>
  <code class="c1"># a conscious choice for the user. This also increases chances charts run on</code>
  <code class="c1"># environments with little resources, such as Minikube. If you do want to</code>
  <code class="c1"># specify resources, uncomment the following lines, adjust them as necessary,</code>
  <code class="c1"># and remove the curly braces after 'resources:'.</code>
  <code class="c1"># limits:</code>
  <code class="c1">#   cpu: 100m</code>
  <code class="c1">#   memory: 128Mi</code>
  <code class="c1"># requests:</code>
  <code class="c1">#   cpu: 100m</code>
  <code class="c1">#   memory: 128Mi</code></pre>

<p>Those who install applications use these numbers as recommendations when they instantiate a chart. These numbers are the default values that have been set for a simple Nginx setup as it was generated. They work for the Anvil application. If your application will need different values, you will need to update these.</p>

<p>Workloads have the ability to specify details about where they are executed in a cluster by the settings node selector, tolerations, and affinity. Although these more advanced features are often not used, it is a good idea to include them in a chart for those who need them. The generated <em>values.yaml</em> file and templates take this into account. The following example has generated YAML keys for these advanced 
<span class="keep-together">features</span>. The values are empty by default with an expectation that the person who installs the chart will set values as appropriate for their installation:<a data-type="indexterm" data-startref="ch04-val" id="idm46125998598584"/><a data-type="indexterm" data-startref="ch04-val2" id="idm46125998597912"/><a data-type="indexterm" data-startref="ch04-val3" id="idm46125998597240"/><a data-type="indexterm" data-startref="ch04-val4" id="idm46125998596568"/><a data-type="indexterm" data-startref="ch04-val5" id="idm46125998595896"/><a data-type="indexterm" data-startref="ch04-val6" id="idm46125998595224"/></p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">nodeSelector</code><code class="p">:</code> <code class="p-Indicator">{}</code>

<code class="nt">tolerations</code><code class="p">:</code> <code class="p-Indicator">[]</code>

<code class="nt">affinity</code><code class="p">:</code> <code class="p-Indicator">{}</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Packaging the Chart"><div class="sect1" id="idm46125998267768">
<h1>Packaging the Chart</h1>

<p>You can package the files and directories of a chart into a single archive file. This is useful for many reasons, including:<a data-type="indexterm" data-primary="building charts" data-secondary="packaging the chart" id="ch04-pkg"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="packaging the chart" id="ch04-pkg2"/><a data-type="indexterm" data-primary="archive file from packaging chart" id="ch04-pkg3"/><a data-type="indexterm" data-primary="packages" data-secondary="packaging a chart" id="ch04-pkg4"/><a data-type="indexterm" data-primary="charts" data-secondary="packaging" id="ch04-pkg5"/></p>

<ul>
<li>
<p>For distribution to other people. One of the powerful aspects of a package manager is where someone with knowledge of running an application packages it up so that others, who don’t have intimate knowledge of the platform or application, can run it.</p>
</li>
<li>
<p>When a version of an application needs to be taken through a multienvironment test process. An example of this process is where there are development, quality assurance (QA), and production environments and the application needs to pass QA prior to going into production.</p>
</li>
<li>
<p>When developing a multiservice application and developers need to run services built or otherwise handled by others as part of their development setup.</p>
</li>
</ul>

<p>In each of these situations it is often simpler to pass around a single file for the chart than a directory structure.</p>

<p>Chart versions bring another wrinkle to the way you distribute and consume charts.<a data-type="indexterm" data-primary="charts" data-secondary="versions" data-tertiary="distribution of charts" id="idm46125998752040"/><a data-type="indexterm" data-primary="OCI (open container initiative) registries" data-secondary="chart versions" id="idm46125998750792"/> You or someone consuming your chart may need to use different versions of the chart. This is why it’s useful to store and share different versions using chart repositories or Open Container Initiative (OCI) registries, covered in <a data-type="xref" href="ch07.xhtml#chart_repositories">Chapter 7</a>. In these environments, storing and sharing many files in a collection of directory structures for each version is far from simple.</p>

<p>Helm has the ability to build a chart archive. Each chart archive is a gzipped TAR file with the extension <em>.tgz</em>. Any tool that can create, extract, and otherwise work on gzipped TAR files will work with Helm’s chart archives.</p>

<p>When Helm generates the archive files, they are named using a pattern of 
<span class="keep-together"><em><code>chart name</code>-<code>version</code>.tgz</em></span>. Helm<a data-type="indexterm" data-primary="archive file from packaging chart" data-secondary="naming protocol" id="idm46125998776056"/><a data-type="indexterm" data-primary="names" data-secondary="chart archive files" id="idm46125998806088"/> expects this same pattern when consuming them. The <em><code>chart name</code></em> is the name you will find inside the <em>Chart.yaml</em> file and the <em><code>version</code></em> is the chart version. This enables multiple versions of the same chart to be stored alongside each other. You can package Anvil as an archive by running:<a data-type="indexterm" data-primary="package command" id="idm46125998803304"/></p>

<pre data-type="programlisting">$ helm package anvil</pre>

<p>In this case <code>anvil</code> is the path to the location where the <em>anvil</em> chart source is located. By default, the <code>helm package</code> command will place the archive in the directory you were in when you ran the command.</p>

<p>There are some useful flags you can use when packaging a chart:</p>
<dl>
<dt><code>--dependency-update</code> (<code>-u</code>)</dt>
<dd>
<p>Tells Helm to update the dependent charts prior to creating the archive. This will update the <em>Chart.lock</em> file and place a copy of the dependent charts in the <em>chart</em> directory. Dependencies are covered in more detail in <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a>.</p>
</dd>
<dt><code>--destination</code> (<code>-d</code>)</dt>
<dd>
<p>Enables you to set the location to put the chart archive if it is different from the current working directory.</p>
</dd>
<dt><code>--app-version</code></dt>
<dd>
<p>Can be used to set the 
<span class="keep-together"><code>appVersion</code></span> property of the <em>Chart.yaml</em> file. This is especially useful if you create new releases of the chart for each new release of your application running within the container and there is no other change to the chart. Automation can use a flag like this as part of the process to build the new version.</p>
</dd>
<dt><code>--version</code></dt>
<dd>
<p>Updates the chart’s version. This is useful if you’re updating the <code>appVersion</code> using the command line as part of the process to package a chart.</p>
</dd>
<dt>Flags for Pretty Good Privacy (PGP) signing charts</dt>
<dd>
<p>Helm charts can be cryptographically signed and verified.<a data-type="indexterm" data-primary="security" data-secondary="Pretty Good Privacy signing" id="idm46125998975592"/><a data-type="indexterm" data-primary="Pretty Good Privacy (PGP)" id="idm46125998974648"/><a data-type="indexterm" data-primary="charts" data-secondary="security" data-tertiary="Pretty Good Privacy" id="idm46125998974008"/> The <code>package</code> command has flags for the signing portion of the process, while commands like <code>install</code> and <code>upgrade</code> have flags for the verification portion of the process. <a data-type="xref" href="ch06.xhtml#advanced_charts">Chapter 6</a> covers this process.</p>
</dd>
</dl>

<p>Sometimes you will have files in a chart directory that you do not want to include in the chart archive. Optionally, in a chart directory there can be a <em>.helmignore</em> file. This is similar to a <em>.gitignore</em> file for Git. The <code>helm create</code> command used earlier created one with the following contents:</p>

<pre data-type="programlisting"># Patterns to ignore when building packages.
# This supports shell glob matching, relative path matching, and
# negation (prefixed with !). Only one pattern per line.
.DS_Store
# Common VCS dirs
.git/
.gitignore
.bzr/
.bzrignore
.hg/
.hgignore
.svn/
# Common backup files
*.swp
*.bak
*.tmp
*.orig
*~
# Various IDEs
.project
.idea/
*.tmproj
.vscode/</pre>

<p>Many of these extensions and patterns may look familiar because they come from various version control systems and code editors.</p>

<p>When the chart archive is created, you usually don’t want to include elements like your version control system data. The <em>.helmignore</em> file provides a place to specify what to skip. This file needs to be at the top level of the chart.</p>

<p>Helm is designed to work with the archive files the same way it works with directory structures. Commands like <code>helm install</code> and <code>helm lint</code>, which will be covered shortly, can be passed an archive file the same way they can be passed a directory.<a data-type="indexterm" data-startref="ch04-pkg" id="idm46125998507384"/><a data-type="indexterm" data-startref="ch04-pkg2" id="idm46125998506680"/><a data-type="indexterm" data-startref="ch04-pkg3" id="idm46125998506008"/><a data-type="indexterm" data-startref="ch04-pkg4" id="idm46125998735800"/><a data-type="indexterm" data-startref="ch04-pkg5" id="idm46125998735128"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Linting Charts"><div class="sect1" id="idm46125998746088">
<h1>Linting Charts</h1>

<p>When developing charts, especially when working with YAML templates,<a data-type="indexterm" data-primary="templates" data-secondary="debugging" data-tertiary="linting charts" id="idm46125998732888"/><a data-type="indexterm" data-primary="charts" data-secondary="building" data-tertiary="linting" id="idm46125998731640"/><a data-type="indexterm" data-primary="building charts" data-secondary="linting" id="idm46125998730424"/><a data-type="indexterm" data-primary="linting charts" id="idm46125998729480"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="linting charts" id="idm46125998728808"/> it can be easy to make a mistake or miss something. To help you catch errors, bugs, style issues, and other suspicious elements, the Helm client includes a linter. This linter can be used during chart development and as part of any testing processes.</p>

<p>To use the linter, use the <code>lint</code> command on a chart as a directory or a packaged archive:</p>

<pre data-type="programlisting">$ helm lint anvil
==&gt; Linting anvil

1 chart(s) linted, 0 chart(s) failed</pre>

<p>The first line is the command you run, while the following lines are output by Helm. In this case there were no issues. You could use this command on an archive file like the one in the previous section. To do that, change the <code>anvil</code> argument, set to the directory location for the chart, to the archive file <em>anvil-0.1.0.tgz</em>.</p>

<p>This command is able to lint multiple charts in a single command. For example, if you had a second chart called <em>mychart</em> and wanted to lint it alongside <em>anvil</em>, you could run the following command:</p>

<pre data-type="programlisting">$ helm lint anvil mychart</pre>

<p>The three levels of actionable feedback about charts Helm provides are info, warning, and errors. Info-level feedback is informational; charts can be installed with info-level feedback. Info-level feedback causes Helm to have an exit code of 0. Error-level feedback means there is a problem with the chart. If a chart generates an Invalid manifest for Kubernetes, such as YAML being invalid, Helm will generate an error. Errors cause Helm to have a nonzero exit code, which is useful to catch issues in automated testing tools. In the middle are warning messages. These messages address findings that may cause issues. By default, warning messages cause Helm to have an exit code of 0, but Helm adds a <code>--strict</code> flag that causes the exit codes to be nonzero. You can choose how to handle these in automation.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46125999318744">
<h5>Exit Codes</h5>
<p>When an application exits, it provides a <a href="https://oreil.ly/zHz8g">code or status</a> to the parent that executed it.<a data-type="indexterm" data-primary="exit codes" id="idm46125999316680"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="exit codes" id="idm46125999315976"/><a data-type="indexterm" data-primary="testing" data-secondary="exit codes" id="idm46125999075272"/> When you run Helm this is usually the operating system, command prompt, or shell. A zero exit status means that the application exited without any issues. A nonzero exit status means there was a problem. Automated testing systems often use exit codes to know when to continue or stop. Typically, when an application used in automated testing returns a nonzero exit code, the automated processes end and people are notified of an error.</p>
</div></aside>

<p>In this case there were no issues found with the <em>anvil</em> chart. A default chart, created by <code>helm create</code>, will have a single info message about a <a data-type="indexterm" data-primary="Chart.yaml file" data-secondary="icon property" data-tertiary="missing" id="idm46125999072120"/><a data-type="indexterm" data-primary="icon property" data-secondary="missing" id="idm46125999070872"/>missing <code>icon</code> property in the <em>Chart.yaml</em> file. This is an info-level notice so that people are aware it is missing. The missing icon will not affect the operation of the chart, but it will affect the way it is displayed in user interfaces.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46125998733864">
<h1>Conclusion</h1>

<p>Creating a simple chart for your application is straightforward when you use the <code>helm create</code> command. Even when your applications are more complicated, the structure of charts is able to accommodate them, and the <code>helm create</code> command can help you. With a few minor modifications made in this chapter you can install the Anvil chart using <code>helm install</code> and see the custom application running in your cluster. You can use this same flow to create your own charts.</p>

<p>In the next chapter you will learn about creating templates with an emphasis on how the template language works and how you can apply it to Kubernetes templates stored in charts. Templates are usually the largest part of a chart where you will spend the most time. Understanding what you have available to you when you create templates will make the process of developing them faster and easier.</p>
</div></section>







</div></section></div></body></html>