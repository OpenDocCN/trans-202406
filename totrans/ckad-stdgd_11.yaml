- en: Chapter 11\. Deployment Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying an application (bundled into a container image) to one or many Pods
    is only the beginning of its life cycle within a Kubernetes cluster. Periodically,
    developers will produce and publish new container image tags to ship bug fixes
    and new features. Manually updating Pods with a new container image tag one by
    one would be extremely tedious. Kubernetes offers the Deployment primitive to
    streamline the process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 10](ch10.xhtml#deployments) explained how to automatically roll out
    a new release using the Deployment primitive. In this chapter, we will discuss
    the built-in deployment strategies supported by the primitive. We’ll also talk
    about other deployment strategies that require deliberate human decisions. Each
    deployment strategy is presented with an example featuring their benefits and
    potential trade-offs. More deployment strategies exist, but they will not be covered
    in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Some deployment strategies require the use of concepts not yet discussed. Jump
    to [Chapter 14](ch14.xhtml#container_probes) for coverage of container probes.
    Reference [Chapter 21](ch21.xhtml#services) for more information on the purpose
    of Services.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling Deployment Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Deployment primitive employs rolling deployment as the default deployment
    strategy, also referred to as ramped deployment. It’s called “ramped” because
    the Deployment gradually transitions replicas from the old version to a new version
    in batches. The Deployment automatically creates a new ReplicaSet for the desired
    change after the user updates the Pod template.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-1](#deployment_strategy_rolling_update) shows a snapshot in time
    during the rollout process.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1101](Images/ckd2_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. The rolling deployment strategy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this scenario, the user initiated an update of the application version from
    1.0.0 to 2.0.0\. As a result, the Deployment creates a new ReplicaSet and starts
    up Pods running the new application version while at the same time scaling down
    the old version. The Service routes network traffic to either the old or new version
    of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Deployment uses the rolling deployment strategy by default. The runtime value
    for the attribute `spec.strategy.type` is `RollingUpdate`. Users can fine-tune
    this strategy. You can use the attributes `spec.strategy.rollingUpdate.maxUnavailable`
    and `spec.strategy.rollingUpdate.maxSurge` to change the rollout rate. Both attributes
    can use a fixed integer (for example, 3) or assign a percentage of the total required
    number of Pods (for example, 33%). The default value for `maxUnavailable` and
    `maxSurge` is 25%.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute `maxUnavailable` specifies the maximum number of Pods that can
    be unavailable during the update process. For example, if you set the value to
    40%, then the old ReplicaSet can scale down to 60% immediately when the rolling
    update starts.
  prefs: []
  type: TYPE_NORMAL
- en: The attribute `maxSurge` specifies the maximum number of Pods that can be created
    over the desired number of Pods. For example, if you set the value to 10%, the
    total number of new and old Pods cannot exceed a total of 110% after the new ReplicaSet
    has been created.
  prefs: []
  type: TYPE_NORMAL
- en: Independent of the values assigned to the attributes `maxUnavailable` and `maxSurge`,
    all replicas controlled by the old ReplicaSet will be ramped down to 0 over time
    until all replicas controlled by the new ReplicaSet equals the value of `spec.replicas`.
  prefs: []
  type: TYPE_NORMAL
- en: It’s recommended to define a readiness probe for the Pod template to ensure
    that a replica is ready to handle incoming requests. The attribute `spec.minReadySeconds`
    specifies the number of seconds a replica needs to be available for before it
    is made available to incoming requests.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 11-1](#yaml_manifest_deployment_rolling_update) shows the usage of
    those attributes in the context of a full Deployment YAML manifest stored in the
    file *deployment-rolling-update.yaml*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-1\. A Deployment configured with a rolling update strategy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_deployment_strategies_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The percentage of Pods that can be unavailable during the update.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_deployment_strategies_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The percentage of Pods that can temporarily exceed the total number of replicas.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_deployment_strategies_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The number of seconds for which the readiness probe in a Pod needs to be healthy
    until the rollout process can continue.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_deployment_strategies_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The readiness probe for all replicas referred to by `spec.minReadySeconds`.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of assigned values to `maxUnavailable` and `maxSurge` determines
    the runtime behavior and speed of a rollout. You will adjust those parameters
    to find the most suitable combination for your application.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases and Trade-Offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The rolling deployment is a fitting deployment strategy for rolling out a new
    application version with zero downtime. Depending on the number of replicas the
    Deployment manages, this process can be relatively slow, as old versions of the
    applications are ramped down and new versions of the application are ramped up
    in batches.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to mention that this deployment strategy comes with a potential
    risk. Old and new versions of the application run in parallel. Breaking changes
    introduced with the new version can lead to unexpected and hard-to-debug errors
    for consumers if they haven’t adapted their client software to the latest changes.
    It’s a good idea to roll out a new application version in a backward-compatible
    fashion, for example by using a versioned API, to avoid running into this situation.
  prefs: []
  type: TYPE_NORMAL
- en: Fixed Deployment Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fixed deployment strategy will terminate replicas with the old application
    version at once before creating another ReplicaSet that controls replicas running
    the new application version.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-2](#deployment_strategy_fixed) illustrates the rollout process while
    updating the Pod template from application version 1.0.0 to 2.0.0\. All replicas
    of the old ReplicaSet are shut down simultaneously. Then, the replicas controlled
    by the new ReplicaSet are started. During this process, the Service may not be
    able to reach any of the replicas, which can lead to unnecessary downtime for
    consumers.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1102](Images/ckd2_1102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. The fixed deployment strategy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To configure the fixed deployment strategy for a Deployment, set the attribute
    `spec.strategy.type` to `Recreate`. Internally, this strategy type will automatically
    assign the total number of replicas to the attribute `maxUnavailable`. No other
    configuration options need to be provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 11-2](#yaml_manifest_deployment_fixed) shows the `Recreate` strategy
    type in the context of a full Deployment YAML manifest stored in the file *deployment-fixed.yaml*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-2\. A Deployment configured with a fixed deployment strategy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_deployment_strategies_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The strategy type for configuring fixed deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning a readiness probe to containers defined by the Pod template isn’t
    strictly necessary because all replicas with the old application version will
    be shut down at once. Nevertheless, it still makes sense to verify that the application
    is up and running by defining a readiness probe before incoming traffic can reach
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases and Trade-Offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fixed deployment strategy is suitable for situations where application downtime
    is acceptable. For example, it’s great if you want to roll out a new application
    to a developer environment for testing purposes. For production environments,
    this deployment strategy may work if you announce an outage time window to customers.
  prefs: []
  type: TYPE_NORMAL
- en: Blue-Green Deployment Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The blue-green deployment strategy (sometimes referred to as red-black deployment
    strategy) figuratively uses blue as a representation of the old application version
    and green as a representation of the new application version. Both application
    versions will be operated at the same time with an equal number of replicas.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes routes traffic to the blue deployment, while the development or test
    team rolls out and tests the green deployment. Traffic is switched over to the
    green deployment as soon as it is considered production-ready. At that point,
    the team managing the application can decommission the blue deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-3](#deployment_strategy_blue_green) shows two Deployments managing
    replicas with different application versions. The Services can switch network
    traffic from the old application version to the new application version by changing
    the label selection.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1103](Images/ckd2_1103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3\. The blue-green deployment strategy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blue-green deployment is not a built-in strategy you can configure within the
    Deployment resource. You will have to create a Deployment object for both application
    versions. The Service routes traffic to replicas managed by either the blue or
    the green Deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 11-3](#yaml_manifest_deployment_blue) shows a blue Deployment YAML
    manifest stored in the file *deployment-blue.yaml* specifying the container image
    `httpd:2.4.23-alpine` in the Pod template.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-3\. A blue Deployment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_deployment_strategies_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Uses the label assignment `type: blue` to any replica managed by the corresponding
    ReplicaSet.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_deployment_strategies_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The old application version `2.4.23-alpine`.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a green deployment that runs the newer container image `httpd:2.4.57-alpine`,
    simply create another Deployment object. Note that the label used for the Pod
    template is different than for the blue deployment. [Example 11-4](#yaml_manifest_deployment_green)
    shows the green Deployment definition in the file *deployment-green.yaml*.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-4\. A green Deployment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_deployment_strategies_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Uses the label assignment `type: green` to any replica managed by the corresponding
    ReplicaSet.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_deployment_strategies_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The new application version `2.4.57-alpine`.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the Service is the Kubernetes object responsible for routing
    network traffic to the old or new application version. [Example 11-5](#yaml_manifest_deployment_blue_green_service)
    shows a Service object.
  prefs: []
  type: TYPE_NORMAL
- en: Example 11-5\. The Service routing network traffic to a blue deployment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_deployment_strategies_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The label selector pointing to replicas managed by the blue deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The resource declaration currently points to the blue deployment; to switch
    to green, simply change the label selection from `type: blue` to `type: green`.
    At that point, you can delete the blue Deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases and Trade-Offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The blue-green deployment strategy is suitable for deployment scenarios where
    complex upgrades need to be performed without downtime to consumers. This situation
    may arise if a rollout requires a data migration or if multiple, dependent software
    components need to be changed at once. Should a rollback to the old application
    version be required, a simple change of the label selection in the Service will
    do.
  prefs: []
  type: TYPE_NORMAL
- en: On the downside, it’s worth mentioning that you will need more hardware resources
    than for other deployment strategies. If you need five replicas to run the old
    application version, then you will need the same amount of resources for the new
    application version, assuming the resource requirements won’t differ.
  prefs: []
  type: TYPE_NORMAL
- en: Canary Deployment Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The canary deployment strategy is similar to the blue-green deployment; however,
    you’d make the new application version available to only a subset of consumers.
    With this approach, you can implement A/B testing of new features or if you need
    to gather metrics about consumer behavior. Based on the defined set of success
    criteria, traffic to the new application version can be increased gradually. The
    goal is to shut down the old application version completely.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-4](#deployment_strategy_canary) shows how the Service sends traffic
    to both application versions.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1104](Images/ckd2_1104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-4\. The canary deployment strategy
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Deployment 1 controls application version v1.0.0\. Deployment 2 controls application
    version v2.0.0\. Deployments 1 and 2 use the same label assignment in their Pod
    template. The Service selects the label key-value pair(s) defined by both Deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a Kubernetes cluster, you represent each application version with the help
    of a Deployment object. You want to roll out the new application version with
    fewer replicas than the current application version by assigning a smaller value
    to the attribute `spec.replicas`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows the truncated definition of the Deployment
    controlling the old application version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the new application version, assign a smaller number of replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To ensure that replicas for old and new application versions receive requests
    from consumers, the assigned Pod template label(s) in both Deployment objects
    need to be the same. Ensure that the Service selects those label(s), as shown
    in this truncated Service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_deployment_strategies_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Selects the label assigned to both Deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases and Trade-Offs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Organization typically use the canary deployment strategy to roll out experimental
    features or changes with potential impact on system performance. You can evaluate
    your success criteria while making the new feature available to only a subset
    of consumers. Implementing a canary deployment usually requires fewer hardware
    resources than the blue-green deployment as the number of replicas with the new
    application version is much lower.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A deployment is the process of making a software change available to end users
    or programs. You need to consider two aspects: the procedure of how to deploy
    a change and the routing of network traffic to the application. Select an appropriate
    deployment strategy based on use case, application type, and trade-offs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Deployment primitive, Kubernetes natively supports two deployment
    strategies: the rolling deployment and the fixed deployment. The rolling deployment,
    specified by the `RollingUpdate` strategy, rolls out a change gradually in batches.
    The fixed deployment, configured by the `Recreate` strategy, first shuts down
    the old application version and then brings up the new application version.'
  prefs: []
  type: TYPE_NORMAL
- en: The blue-green and canary deployment strategies can be set up by creating a
    second Deployment object that manages the new application version in parallel
    with the old one. The Service then routes network traffic to replicas of both
    application versions (blue-green) or transitions consumers to the new application
    version over time (canary).
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand how to configure strategies native to the Deployment primitive
  prefs: []
  type: TYPE_NORMAL
- en: The exam may confront you with different deployment strategies. You need to
    understand how to implement the most common strategies and how to modify an existing
    deployment scenario. Learn how to configure the built-in strategies in the Deployment
    primitive and their options for fine-tuning the runtime behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Practice multi-phased deployment strategies
  prefs: []
  type: TYPE_NORMAL
- en: You can implement even more sophisticated deployment scenarios with the help
    of the Deployment and Service primitives. Examples are the blue-green and canary
    deployment strategies, which require a multi-phased rollout process. Expose yourself
    to implementation techniques and rollout procedures. Operators provided by the
    Kubernetes community, e.g., [Argo Rollouts](https://argo-rollouts.readthedocs.io/en/stable/),
    offer higher-level abstractions for more sophisticated deployment strategies.
    The exam does not require you to understand external tooling to implement deployment
    strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_007.xhtml#appendix_a_deployment_strategies).
  prefs: []
  type: TYPE_NORMAL
- en: 'One of your teammates created a Deployment YAML manifest to operate the container
    image `grafana/grafana:9.5.9`. Create the Deployment object from the YAML manifest
    file `deployment-grafana.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You need to update all replicas with the container image `grafana/grafana:10.1.2`.
    Make sure that the rollout happens in batches of two replicas at a time. Ensure
    that a readiness probe is defined.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this exercise, you will set up a blue-green Deployment scenario. You’ll first
    create the initial (blue) Deployment and expose it with a Service. Later, you
    will create a second (green) Deployment and switch over traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Deployment named `nginx-blue` with 3 replicas. The Pod template of
    the Deployment should use container image `nginx:1.23.0` and assign the label
    `version=blue`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Expose the Deployment with a Service of type ClusterIP named `nginx`. Map the
    incoming and outgoing port to 80\. Select the Pod with label `version=blue`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run a temporary Pod with the container image `alpine/curl:3.14` to make a call
    against the Service using `curl`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a second Deployment named `nginx-green` with 3 replicas. The Pod template
    of the Deployment should use container image `nginx:1.23.4` and assign the label
    `version=green`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Change the Service’s label selection so that traffic will be routed to the Pods
    controlled by the Deployment `nginx-green`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delete the Deployment named `nginx-blue`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Run a temporary Pod with the container image `alpine/curl:3.14` to make a call
    against the Service.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
