<html><head></head><body><section data-pdf-bookmark="Chapter 6. Exploring Docker" data-type="chapter" epub:type="chapter"><div class="chapter" id="exploring_docker">&#13;
<h1><span class="label">Chapter 6. </span>Exploring Docker</h1>&#13;
&#13;
&#13;
<p>Now that you have some experience working with containers and images, we can explore some of Docker’s other capabilities. In this chapter, we’ll continue to use the <code>docker</code> command-line tool to talk to the running <code>dockerd</code> server that you’ve configured while visiting some of the other fundamental commands.</p>&#13;
&#13;
<p>Docker provides commands to do several additional things easily:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Printing the Docker version</p>&#13;
</li>&#13;
<li>&#13;
<p>Viewing the server information</p>&#13;
</li>&#13;
<li>&#13;
<p>Downloading image updates</p>&#13;
</li>&#13;
<li>&#13;
<p>Inspecting containers</p>&#13;
</li>&#13;
<li>&#13;
<p>Entering a running container</p>&#13;
</li>&#13;
<li>&#13;
<p>Returning a result</p>&#13;
</li>&#13;
<li>&#13;
<p>Viewing logs</p>&#13;
</li>&#13;
<li>&#13;
<p>Monitoring statistics</p>&#13;
</li>&#13;
<li>&#13;
<p>And much more…</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s take a look at these as well as some of the additional community tooling that &#13;
<span class="keep-together">augments</span> Docker’s native capabilities.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Printing the Docker Version" data-type="sect1"><div class="sect1" id="idm46803145656576">&#13;
<h1>Printing the Docker Version</h1>&#13;
&#13;
<p>If you completed the last chapter, you have a working Docker daemon on a Linux server or VM, and you’ve started a base container to make sure it’s all working. If you haven’t set that up already and you want to try out the steps in the rest of the book, you’ll want to follow the installation steps in <a data-type="xref" href="ch03.html#installing_docker">Chapter 3</a> before you move on with this section.</p>&#13;
&#13;
<p>The absolute simplest thing<a data-primary="Docker" data-primary-sortas="docker-a" data-secondary="version displayed" data-type="indexterm" id="idm46803145653616"/><a data-primary="version of Docker displayed" data-type="indexterm" id="idm46803145652368"/> you can do with Docker is print the versions of the various components. It might not sound like much, but this is a useful tool to have because Docker is built from a multitude of components whose versions will directly dictate what functionality is available to you. Knowing how to show the version will also help you troubleshoot certain types of connection issues between the client and server. For example, the Docker client might give you a cryptic message about mismatched API versions, and it’s nice to be able to translate that into Docker versions so you know which component needs updating. This command talks to the remote Docker server, so if the client can’t connect to the server for any reason, the client will report an error and then only print out the client version information. If you find that you are having connectivity problems, you should probably revisit the steps in the last chapter.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You can always directly log in to the Docker server<a data-primary="Docker client" data-primary-sortas="docker-a" data-secondary="docker commands on server instead" data-type="indexterm" id="idm46803145650352"/><a data-primary="Docker server" data-primary-sortas="docker-a" data-secondary="command execution instead of via client" data-type="indexterm" id="idm46803145649136"/> and run <code>docker</code> commands from a shell on the server if you are troubleshooting issues or simply do not want to use the <code>docker</code> client to connect to a remote system. On most Docker servers, this will require either <code>root</code> privileges or membership in the <code>docker</code> group to connect to the Unix domain socket that Docker is listening on.</p>&#13;
</div>&#13;
&#13;
<p>Since we just installed all of the Docker components at the same time, when we run <code>docker version</code>, we should see that all of our versions match:<a data-primary="docker version" data-primary-sortas="docker-z" data-type="indexterm" id="idm46803145644848"/><a data-primary="Docker client" data-primary-sortas="docker-a" data-secondary="version command" data-type="indexterm" id="idm46803145643872"/><a data-primary="Docker daemon" data-primary-sortas="docker-a" data-secondary="version command" data-type="indexterm" id="idm46803145642656"/><a data-primary="APIs" data-secondary="Docker daemon" data-tertiary="version command" data-type="indexterm" id="idm46803145641440"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>version<code class="w"/>&#13;
<code class="go">Client:</code>&#13;
<code class="go"> Cloud integration: v1.0.24</code>&#13;
<code class="go"> Version:           20.10.17</code>&#13;
<code class="go"> API version:       1.41</code>&#13;
<code class="go"> Go version:        go1.17.11</code>&#13;
<code class="go"> Git commit:        100c701</code>&#13;
<code class="go"> Built:             Mon Jun  6 23:04:45 2022</code>&#13;
<code class="go"> OS/Arch:           darwin/amd64</code>&#13;
<code class="go"> Context:           default</code>&#13;
<code class="go"> Experimental:      true</code>&#13;
&#13;
<code class="go">Server: Docker Desktop 4.10.1 (82475)</code>&#13;
<code class="go"> Engine:</code>&#13;
<code class="go">  Version:          20.10.17</code>&#13;
<code class="go">  API version:      1.41 (minimum version 1.12)</code>&#13;
<code class="go">  Go version:       go1.17.11</code>&#13;
<code class="go">  Git commit:       a89b842</code>&#13;
<code class="go">  Built:            Mon Jun  6 23:01:23 2022</code>&#13;
<code class="go">  OS/Arch:          linux/amd64</code>&#13;
<code class="go">  Experimental:     false</code>&#13;
<code class="go"> containerd:</code>&#13;
<code class="go">  Version:          1.6.6</code>&#13;
<code class="go">  GitCommit:        10c12954828e7c7c9b6e0ea9b0c02b01407d3ae1</code>&#13;
<code class="go"> runc:</code>&#13;
<code class="go">  Version:          1.1.2</code>&#13;
<code class="go">  GitCommit:        v1.1.2-0-ga916309</code>&#13;
<code class="go"> docker-init:</code>&#13;
<code class="go">  Version:          0.19.0</code>&#13;
<code class="go">  GitCommit:        de40ad0</code></pre>&#13;
&#13;
<p>Notice how we have different sections representing the client and server. In this case, we have a matching client and server since we just installed them together. But it’s important to note that this won’t always be the case. Hopefully, in your production systems, you can manage to keep the same version running on most systems. But it’s not uncommon for development environments and build systems to have slightly different versions.</p>&#13;
&#13;
<p>API clients and libraries will usually work across a large number of Docker versions, depending on which API version they require. In the <code>Server</code> section, we can see that the current API version is 1.41 and the minimum API it will serve is 1.12. This is useful information when you’re working with third-party clients, and now you know how to verify this information.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Server Information" data-type="sect1"><div class="sect1" id="idm46803145609680">&#13;
<h1>Server Information</h1>&#13;
&#13;
<p>We can also find out a lot about<a data-primary="Docker server" data-primary-sortas="docker-a" data-secondary="exploring" data-type="indexterm" id="ch06-serv"/><a data-primary="docker system" data-primary-sortas="docker-z" data-secondary="info" data-tertiary="exploring the server" data-type="indexterm" id="ch06-serv2"/><a data-primary="Linux" data-secondary="kernel" data-tertiary="version displayed via system info" data-type="indexterm" id="idm46803145604576"/> the Docker server via the Docker client. Later we’ll talk more about what all of this means, but you can find out which filesystem backend the Docker server is running, which kernel version it is on, which operating system it is running on, which plug-ins are installed, which runtime is being used, and how many containers and images are currently stored there. <code>docker system info</code> will present you with something similar to this, which has been shortened for brevity:<a data-primary="plug-ins for Docker" data-secondary="displayed via docker system info" data-type="indexterm" id="idm46803145602832"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>system<code class="w"> </code>info<code class="w"/>&#13;
<code class="go">Client:</code>&#13;
<code class="go">…</code>&#13;
<code class="go"> Plugins:</code>&#13;
<code class="go">  buildx: Docker Buildx (Docker Inc., v0.8.2)</code>&#13;
<code class="go">  compose: Docker Compose (Docker Inc., v2.6.1)</code>&#13;
<code class="go">  extension: Manages Docker extensions (Docker Inc., v0.2.7)</code>&#13;
<code class="go">  sbom: View the packaged-based Software Bill Of Materials (SBOM) …</code>&#13;
<code class="go">  scan: Docker Scan (Docker Inc., v0.17.0)</code>&#13;
&#13;
<code class="go">Server:</code>&#13;
<code class="go"> Containers: 11</code>&#13;
<code class="go">…</code>&#13;
<code class="go"> Images: 6</code>&#13;
<code class="go"> Server Version: 20.10.17</code>&#13;
<code class="go"> Storage Driver: overlay2</code>&#13;
<code class="go">…</code>&#13;
<code class="go"> Plugins:</code>&#13;
<code class="go">  Volume: local</code>&#13;
<code class="go">  Network: bridge host ipvlan macvlan null overlay</code>&#13;
<code class="go">  Log: awslogs fluentd gcplogs gelf journald json-file local logentries …</code>&#13;
<code class="go">…</code>&#13;
<code class="go"> Runtimes: io.containerd.runc.v2 io.containerd.runtime.v1.linux runc</code>&#13;
<code class="go"> Default Runtime: runc</code>&#13;
<code class="go">…</code>&#13;
<code class="go"> Kernel Version: 5.10.104-linuxkit</code>&#13;
<code class="go"> Operating System: Docker Desktop</code>&#13;
<code class="go"> OSType: linux</code>&#13;
<code class="go"> Architecture: x86_64</code>&#13;
<code class="go">…</code></pre>&#13;
&#13;
<p>Depending on how your Docker daemon is set up, this might look somewhat different. Don’t be concerned about that; this is just to give you an example. Here we can see that our server is a Docker Desktop release running the 5.10.104 Linux kernel and backed with the <code>overlay2</code> filesystem driver. We also have a few images and containers on the server. With a fresh install, this number should be zero.</p>&#13;
&#13;
<p>The information about plug-ins is worth pointing out here. It’s telling us about all the things this installation of Docker supports. On a fresh install, things will look more or less like this, depending on which new plug-ins are distributed with Docker. Docker itself is made up of many different plug-ins all working together. This is powerful because it means it’s also possible to install several other plug-ins contributed by members of the community. It’s useful to be able to see which are installed even if you just want to make sure Docker has recognized one that you recently added.</p>&#13;
&#13;
<p>In most installations, <em>/var/lib/docker</em> will be the<a data-primary="default root directory" data-type="indexterm" id="idm46803145543696"/><a data-primary="root directory default" data-type="indexterm" id="idm46803145542960"/><a data-primary="dockerd" data-primary-sortas="docker-z" data-secondary="--data-root for root directory" data-secondary-sortas="data-root" data-type="indexterm" id="idm46803145542288"/> default root directory used to store images and containers. If you need to change this, you can edit your Docker startup scripts to launch the daemon, with the <code>--data-root</code> argument pointing to a new storage location. To test this by hand, you could run something like this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>sudo<code class="w"> </code>dockerd<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>-H<code class="w"> </code>unix:///var/run/docker.sock<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>--data-root<code class="o">=</code><code class="s2">"/data/docker"</code><code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>By default, <a href="https://oreil.ly/jp7iK">the configuration file for the Docker server</a><sup><a data-type="noteref" href="ch06.html#idm46803145473376" id="idm46803145473376-marker">1</a></sup> can be found<a data-primary="Docker server" data-primary-sortas="docker-a" data-secondary="daemon.json configuration file location" data-type="indexterm" id="idm46803145471456"/><a data-primary="configuration" data-secondary="daemon.json for Docker server" data-type="indexterm" id="idm46803145470304"/><a data-primary="dockerd" data-primary-sortas="docker-z" data-secondary="daemon.json configuration file" data-seealso="daemon.json configuration file" data-type="indexterm" id="idm46803145469392"/><a data-primary="daemon.json configuration file" data-secondary="location of" data-type="indexterm" id="idm46803145467968"/> in <em>/etc/docker/daemon.json</em>. Most of the arguments that we discuss passing directly to <code>dockerd</code> can be permanently set in this file. If you are using Docker Desktop, you are advised to modify this file in the Docker Desktop UI.</p>&#13;
</div>&#13;
&#13;
<p>We will talk more about runtimes later, but here you can see that we have three runtimes installed. <a data-primary="runc as containerd default runtime" data-type="indexterm" id="idm46803145446576"/><a data-primary="runtimes" data-secondary="runc as default for containerd" data-type="indexterm" id="idm46803145445968"/><a data-primary="runtimes" data-secondary="containerd and its runtimes" data-tertiary="runc as default" data-type="indexterm" id="idm46803145445120"/>The <code>runc</code> runtime is the default Docker runtime. If you think of Linux containers, you are usually thinking about the type of container that <code>runc</code> builds. On this server, we also have the <code>io.containerd.runc.v2</code> and <code>io.containerd.runtime.v1.linux</code> runtimes installed. We’ll talk more about some other runtimes in <a data-type="xref" href="ch11.html#advanced_topics">Chapter 11</a>.<a data-startref="ch06-serv" data-type="indexterm" id="idm46803145441504"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Downloading Image Updates" data-type="sect1"><div class="sect1" id="idm46803145440800">&#13;
<h1>Downloading Image Updates</h1>&#13;
&#13;
<p>We’re going to use an Ubuntu base image<a data-primary="OCI images" data-secondary="downloading updates" data-type="indexterm" id="idm46803145439136"/><a data-primary="OCI images" data-secondary="updates downloaded" data-type="indexterm" id="idm46803145438160"/><a data-primary="pulling images" data-secondary="image updates" data-type="indexterm" id="idm46803145437216"/> for the following examples. Even if you already grabbed the <code>ubuntu:latest</code> base image once, you can <code>pull</code> it again and it will automatically pick up any updates that have been published since you last ran it.</p>&#13;
&#13;
<p>This is because <code>latest</code> is a tag that,<a data-primary="latest tag" data-type="indexterm" id="idm46803145434144"/><a data-primary="image tags" data-secondary="latest tag" data-type="indexterm" id="idm46803145433408"/> by convention, is supposed to represent the latest build of the container. However, the <code>latest</code> tag is controversial, since it is not permanently pinned to a specific image and can have different meanings across different projects. Some people use it to point to the most recent stable release, some use it to point to the last build produced by their CI/CD system, and others simply refuse to tag any of their images with <code>latest</code>. That being said, it is still in wide use and can be useful in preproduction environments where the convenience of using it outweighs the lack of assurances that a real version provides:<a data-primary="docker image" data-primary-sortas="docker-z" data-secondary="pull" data-tertiary="latest tag" data-type="indexterm" id="idm46803145431424"/></p>&#13;
&#13;
<p>Invoking <code>docker image pull</code> will look like this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>image<code class="w"> </code>pull<code class="w"> </code>ubuntu:latest<code class="w"/>&#13;
&#13;
<code class="go">latest: Pulling from library/ubuntu</code>&#13;
<code class="go">405f018f9d1d: Pull complete</code>&#13;
<code class="go">Digest: sha256:b6b83d3c331794420340093eb706a6f152d9c1fa51b262d9bf34594887c2c7ac</code>&#13;
<code class="go">Status: Downloaded newer image for ubuntu:latest</code>&#13;
<code class="go">docker.io/library/ubuntu:latest</code></pre>&#13;
&#13;
<p>That command pulled down only the layers that have changed since we last ran the command. You might see a longer or shorter list, or even an empty list, depending on when you last pulled the image, what changes have been pushed to the registry since then, and how many layers the target image contains.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>It’s good to remember that even<a data-primary="latest tag" data-secondary="deployment and" data-type="indexterm" id="idm46803145405584"/><a data-primary="image tags" data-secondary="latest tag" data-tertiary="deployment and" data-type="indexterm" id="idm46803145404640"/><a data-primary="Docker client" data-primary-sortas="docker-a" data-secondary="latest tag during deployment" data-type="indexterm" id="idm46803145403424"/> though you pulled <code>latest</code>, Docker won’t automatically keep the local image up to date for you. You’ll be responsible for doing that yourself. However, if you deploy an image based on a newer copy of <code>ubuntu:latest</code>, the Docker client will download the missing layers during the deployment just like you would expect. Keep in mind that this is the behavior of the Docker client, and other libraries or API tools may not behave this way. It’s highly recommended that you always deploy production code using a fixed version tag rather than the <code>latest</code> tag. This helps guarantee that you get the version you expect and there are no unexpected surprises.</p>&#13;
</div>&#13;
&#13;
<p>In addition to referring to items in the registry by the <code>latest</code> tag or another version number tag, you can refer to them by<a data-primary="tags" data-secondary="content-addressable tag" data-type="indexterm" id="idm46803145399920"/><a data-primary="OCI images" data-secondary="content-addressable tag" data-type="indexterm" id="idm46803145398944"/><a data-primary="docker image" data-primary-sortas="docker-z" data-secondary="pull" data-tertiary="content-addressable tag" data-type="indexterm" id="idm46803145398000"/><a data-primary="hashes" data-secondary="SHA-256 content-addressable tag" data-type="indexterm" id="idm46803145396512"/><a data-primary="hashes" data-secondary="container references in commands" data-type="indexterm" id="idm46803145395600"/> their content-addressable tag, which looks like this:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">sha256:b6b83d3c331794420340093eb706a6f152d9c1fa51b262d9bf34594887c2c7ac</pre>&#13;
&#13;
<p>These are generated as a hashed sum of the contents of the image and are a very precise identifier. This is by far the safest way to refer to Docker images when you need to make sure you are getting the exact version you expect because these can’t be moved like a version tag. The syntax for pulling them from the registry is very similar, but note the <code>@</code> in the tag:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>image<code class="w"> </code>pull<code class="w"> </code>ubuntu@sha256:b6b83d3c331794420340093eb706a6f152d…<code class="w"/></pre>&#13;
&#13;
<p>Unlike most Docker commands where you may shorten the hash, you cannot do that with SHA-256 hashes. You must use the full hash here.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inspecting a Container" data-type="sect1"><div class="sect1" id="idm46803145440208">&#13;
<h1>Inspecting a Container</h1>&#13;
&#13;
<p>Once you have a container created,<a data-primary="Linux containers" data-secondary="inspecting a container" data-type="indexterm" id="idm46803145370592"/><a data-primary="debugging" data-secondary="containers" data-tertiary="inspecting a container" data-type="indexterm" id="idm46803145369616"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="inspect" data-type="indexterm" id="idm46803145348224"/> running or not, you can now use <code>docker</code> to see how it was configured. This is often useful in debugging and also has some other information that can be useful for identifying a container.</p>&#13;
&#13;
<p>For this example, go ahead and start up a container:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>-t<code class="w"> </code>ubuntu<code class="w"> </code>/bin/bash<code class="w"/>&#13;
<code class="go">3c4f916619a5dfc420396d823b42e8bd30a2f94ab5b0f42f052357a68a67309b</code></pre>&#13;
&#13;
<p>We can list all our running containers with <code>docker container ls</code> to ensure everything is running as expected, and to copy the container ID:<a data-primary="hashes" data-secondary="container ID hash" data-tertiary="displaying via docker container ls" data-type="indexterm" id="idm46803145318000"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>ls<code class="w"/>&#13;
<code class="go">CONTAINER ID  IMAGE         COMMAND     … STATUS        …  NAMES</code>&#13;
<code class="go">3c4f916619a5  ubuntu:latest "/bin/bash" … Up 31 seconds …  angry_mestorf</code></pre>&#13;
&#13;
<p class="pagebreak-before">In this case, our ID is <code>3c4f916619a5</code>. We could also use <code>angry_mestorf</code>, which is the dynamic name assigned to our container. Many underlying tools need the unique container ID though, so it’s useful to get into the habit of looking at that first. As we mentioned earlier, the ID as shown is the truncated (or short) version, but Docker treats these interchangeably with the long versions. As is the case in many version control systems, this hash is just the prefix of a much longer hash. Internally, the kernel uses a 64-byte hash to identify the container. But that’s painful for humans to use, so Docker supports the shortened hash.</p>&#13;
&#13;
<p>The output to <code>docker container inspect</code> is pretty verbose, so we’ll cut it down in the following code block to a few values worth pointing out. You should look at the full output to see what else you think is interesting:<a data-primary="hashes" data-secondary="container ID hash" data-tertiary="displaying via docker container inspect" data-type="indexterm" id="idm46803145313488"/><a data-primary="environment variables" data-secondary="PATH" data-type="indexterm" id="idm46803145312304"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>inspect<code class="w"> </code>3c4f916619a5<code class="w"/></pre>&#13;
&#13;
<pre class="nomargin" data-code-language="json" data-type="programlisting"><code class="p">[{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"Id"</code><code class="p">:</code><code class="w"> </code><code class="s2">"3c4f916619a5dfc420396d823b42e8bd30a2f94ab5b0f42f052357a68a67309b"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"Created"</code><code class="p">:</code><code class="w"> </code><code class="s2">"2022-07-17T17:26:53.611762541Z"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"Args"</code><code class="p">:</code><code class="w"> </code><code class="p">[],</code><code class="w"/>&#13;
<code class="w">    </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"Image"</code><code class="p">:</code><code class="w"> </code><code class="s2">"sha256:27941809078cc9b2802deb2b0bb6feed6c…7f200e24653533701ee"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"Config"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Hostname"</code><code class="p">:</code><code class="w"> </code><code class="s2">"3c4f916619a5"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Env"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">          </code><code class="s2">"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">],</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Cmd"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">            </code><code class="s2">"/bin/bash"</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">],</code><code class="w"/>&#13;
<code class="w">        </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Image"</code><code class="p">:</code><code class="w"> </code><code class="s2">"ubuntu"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="err">…</code><code class="w"/>&#13;
<code class="p">}]</code><code class="w"/></pre>&#13;
&#13;
<p>Note that long <code>"Id"</code> string. <a data-primary="hashes" data-secondary="container ID hash" data-tertiary="long form" data-type="indexterm" id="idm46803145078256"/>That’s the full unique identifier of this container. Luckily we can use the short version, even if that’s still not especially convenient. We can also see that the exact time when the container was created is much more precise than what <code>docker container ls</code> gives us.</p>&#13;
&#13;
<p>Some other interesting things are shown here as well: the top-level command in the container, the environment that was passed to it at creation time, the image on which it’s based, and the hostname inside the container. All of these are configurable at container creation time if you need to do so. The usual method for passing configuration to containers, for example, is via environment variables, so being able to see how a container was configured via <code>docker container inspect</code> can reveal a lot when you’re debugging.</p>&#13;
&#13;
<p>You can go ahead and stop the current container by running something like <code>docker container stop 3c4f916619a5</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exploring the Shell" data-type="sect1"><div class="sect1" id="idm46803145371600">&#13;
<h1>Exploring the Shell</h1>&#13;
&#13;
<p>Let’s get a container running with<a data-primary="Linux containers" data-secondary="inspecting a container" data-tertiary="exploring the shell" data-type="indexterm" id="idm46803145171216"/><a data-primary="shell running in a container" data-type="indexterm" id="idm46803145169968"/> just an interactive <code>bash</code> shell so we can take a look around. We’ll do that, as we did before, by running something like this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-it<code class="w"> </code>ubuntu:22.04<code class="w"> </code>/bin/bash<code class="w"/></pre>&#13;
&#13;
<p>That will run an Ubuntu 22.04 LTS container with the bash shell as the top-level process. By specifying the <code>22.04</code> tag, we can be sure to get a particular version of the image. So, when we start that container, what processes are running?<a data-primary="processes" data-secondary="container bash shell processes" data-type="indexterm" id="idm46803145158624"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">root@35fd1ad27228:/# </code>ps<code class="w"> </code>-ef<code class="w"/>&#13;
<code class="go">UID        PID  PPID  C STIME TTY          TIME CMD</code>&#13;
<code class="go">root         1     0  0 17:45 pts/0    00:00:00 /bin/bash</code>&#13;
<code class="go">root         9     1  0 17:47 pts/0    00:00:00 ps -ef</code></pre>&#13;
&#13;
<p>Wow, that’s not much, is it? It turns out that when we told <code>docker</code> to start <code>bash</code>, we didn’t get anything but that. We’re inside a whole Linux distribution image, but no other processes started for us automatically. We only got what we asked for. It’s good to keep that in mind going forward.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Linux containers don’t, by default, start anything in the background as a full VM would. They’re a lot lighter weight than that and therefore don’t start an <code>init</code> system. You can, of course, run a whole <code>init</code> system if you need to, or the <a href="https://github.com/krallin/tini"><code>tini init</code> system</a> that is built into Docker, but you have to ask for it. We’ll talk about that more in <a data-type="xref" href="ch07.html#debug_docker">Chapter 7</a>.</p>&#13;
</div>&#13;
&#13;
<p>That’s how we get a shell running in a container. Feel free to poke around and see what else looks interesting inside the container. You might have a pretty limited set of commands available. You’re in a base Ubuntu distribution, though, so you can fix that by using <code>apt-get update</code>, followed by <code>apt-get install…</code> to download more packages. However, these applications are only going to be around for the life of this container. You’re modifying the top layer of the container, not the base image! Containers are by nature ephemeral, so anything you do inside this container won’t outlast it.</p>&#13;
&#13;
<p>When you are done in the container, make sure to <code>exit</code> the shell, which will then naturally stop the container:<a data-primary="shell running in a container" data-secondary="exiting shell stops container" data-type="indexterm" id="idm46803145039584"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">root@35fd1ad27228:/# </code><code class="nb">exit</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Returning a Result" data-type="sect1"><div class="sect1" id="idm46803145172320">&#13;
<h1>Returning a Result</h1>&#13;
&#13;
<p>How inefficient would it be to spin up<a data-primary="Linux containers" data-secondary="returning a result" data-type="indexterm" id="ch06-resu"/><a data-primary="exit codes" data-secondary="container returning a result" data-type="indexterm" id="ch06-resu2"/><a data-primary="virtual machines (VM)" data-secondary="containers versus" data-tertiary="no operating system boot-up" data-type="indexterm" id="idm46803145017776"/> a whole VM to run one command and get the results? You usually wouldn’t want to do this because it would be very time-consuming and would require booting a whole operating system to simply execute one command. But Docker and Linux containers do not work the same way as VMs do: containers are very lightweight and don’t have to boot up like an operating system does. Running something like a quick background job and waiting for the exit code is a normal use case for a Linux container. You can think of it as a way to get remote access to a containerized system and have access to any of the individual commands inside that container with the ability to pipe data to and from them and return exit codes.</p>&#13;
&#13;
<p>This can be useful in lots of scenarios: you might, for instance, have system health checks run this way remotely or have a series of machines with processes that you spin up via Docker to process a workload and then return. <a data-primary="stdout" data-secondary="output from container" data-type="indexterm" id="idm46803145013440"/><a data-primary="stderr" data-secondary="output from container" data-type="indexterm" id="idm46803145012464"/>The <code>docker</code> command-line tools proxy the results to the local machine. If you run the remote command in foreground mode and don’t specify doing otherwise, <code>docker</code> will redirect its <code>stdin</code> to the remote process, and the remote process’s <code>stdout</code> and <code>stderr</code> to your terminal. The only things we have to do to get this functionality are to run the command in the foreground and not allocate a TTY on the remote. This is also the default configuration! No command-line options are required.</p>&#13;
&#13;
<p>When we run these commands, Docker creates a new container, executes the command that we requested inside the container’s namespaces and cgroups, removes the container, and then exits so that nothing is left running or taking up unnecessary disk space between invocations. The following code should give you an idea of the types of things that you can do:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>ubuntu:22.04<code class="w"> </code>/bin/false<code class="w"/>&#13;
<code class="gp">$ </code><code class="nb">echo</code><code class="w"> </code><code class="nv">$?</code><code class="w"/>&#13;
<code class="go">1</code></pre>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>ubuntu:22.04<code class="w"> </code>/bin/true<code class="w"/>&#13;
<code class="gp">$ </code><code class="nb">echo</code><code class="w"> </code><code class="nv">$?</code><code class="w"/>&#13;
<code class="go">0</code></pre>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>ubuntu:22.04<code class="w"> </code>/bin/cat<code class="w"> </code>/etc/passwd<code class="w"/>&#13;
&#13;
<code class="go">root:x:0:0:root:/root:/bin/bash</code>&#13;
<code class="go">daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin</code>&#13;
<code class="go">…</code>&#13;
<code class="go">nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin</code>&#13;
<code class="go">_apt:x:100:65534::/nonexistent:/usr/sbin/nologin</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>ubuntu:22.04<code class="w"> </code>/bin/cat<code class="w"> </code>/etc/passwd<code class="w"> </code><code class="p">|</code><code class="w"> </code>wc<code class="w"> </code>-l<code class="w"/>&#13;
&#13;
<code class="go">19</code></pre>&#13;
&#13;
<p>Here we executed <code>/bin/false</code> on the remote server, which will always exit with a status of <code>1</code>. Notice how <code>docker</code> proxied that result to us in the local terminal. Just to prove that it returns other results, we also run <code>/bin/true</code>, which will always return a <code>0</code>. And there it is.</p>&#13;
&#13;
<p>Then we actually ask <code>docker</code> to run <code>cat /etc/passwd</code> on the remote container. What we get is a printout of the <em>/etc/passwd</em> file contained inside that container’s filesystem. <a data-primary="pipe (|)" data-secondary="container output" data-type="indexterm" id="idm46803144861424"/>Because that’s just regular output on <em>stdout</em>, we can pipe it into local commands just like we would anything else.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The previous code pipes the output into the local <code>wc</code> command, not a <code>wc</code> command in the container. The pipe itself is not passed to the container. If you want to pass the whole command, including the pipes, to the server, you need to invoke a complete shell on the remote side and pass a quoted command, like <code>bash -c "&lt;your command&gt; | &lt;something else&gt;"</code>. In the previous code, that would be <code>docker container run ubuntu:22.04 /bin/</code> &#13;
<span class="keep-together"><code>bash -c "</code></span> <code>/bin/cat /etc/passwd | wc -l"</code>.<a data-startref="ch06-resu" data-type="indexterm" id="idm46803144856000"/><a data-startref="ch06-resu2" data-type="indexterm" id="idm46803144855296"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Inside a Running Container" data-type="sect1"><div class="sect1" id="inside_containers">&#13;
<h1>Getting Inside a Running Container</h1>&#13;
&#13;
<p>You can pretty easily get a shell running<a data-primary="Linux containers" data-secondary="inspecting a container" data-tertiary="getting inside a running container" data-type="indexterm" id="ch06-inside"/><a data-primary="shell running in a container" data-secondary="getting inside a running container" data-type="indexterm" id="ch06-inside2"/><a data-primary="Linux containers" data-secondary="inside a running container" data-type="indexterm" id="ch06-inside3"/><a data-primary="debugging" data-secondary="getting inside a running container" data-type="indexterm" id="ch06-inside4"/><a data-primary="shell running in a container" data-secondary="getting inside a running container" data-tertiary="about" data-type="indexterm" id="idm46803144847680"/><a data-primary="Linux containers" data-secondary="inside a running container" data-tertiary="about" data-type="indexterm" id="idm46803144846432"/><a data-primary="debugging" data-secondary="getting inside a running container" data-tertiary="about" data-type="indexterm" id="idm46803144845200"/> in a new container, based on almost any image, as we demonstrated earlier with <code>docker container run</code>. But it’s not the same as getting a new shell inside an existing container that is actively running your application. Every time you use <code>docker container run</code>, you get a new container. But if you have an existing container that is running an application and you need to debug it from inside the container, you need something else.</p>&#13;
&#13;
<p>Using <code>docker container exec</code> is the <a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="exec" data-tertiary="new interactive process in container" data-type="indexterm" id="idm46803144842112"/><a data-primary="processes" data-secondary="new interactive process in container" data-type="indexterm" id="idm46803144840592"/><a data-primary="Linux containers" data-secondary="inside a running container" data-tertiary="docker container exec" data-type="indexterm" id="idm46803144839632"/><a data-primary="shell running in a container" data-secondary="getting inside a running container" data-tertiary="docker container exec" data-type="indexterm" id="idm46803144838400"/><a data-primary="debugging" data-secondary="getting inside a running container" data-tertiary="docker container exec" data-type="indexterm" id="idm46803144837152"/>Docker-native way to get a new interactive process in a container, but there is also a more Linux-native way to do it, called <code>nsenter</code>. We will take a look at <code>docker container exec</code> in this section and cover <code>nsenter</code> later in <a data-type="xref" href="ch11.html#nsenter">“nsenter”</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You may be wondering why you would ever want to do this. In development, this can be very useful when you are actively building and testing your application. This is the mechanism that <a href="https://containers.dev">development containers</a> use in IDEs like <a href="https://code.visualstudio.com/docs/devcontainers/containers">Visual Studio Code</a>.</p>&#13;
&#13;
<p>In production, it isn’t considered good practice to SSH into your production servers, and this is roughly the same thing; but there are times when it’s very important to see what’s going on inside the actual environment, and this can help you out in those situations.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="docker container exec" data-type="sect2"><div class="sect2" id="idm46803144830704">&#13;
<h2>docker container exec</h2>&#13;
&#13;
<p>First, let’s take a look at the easiest and best way to get inside a running container. The <code>dockerd</code> server and <code>docker</code> command-line tool support remotely executing a new process in a running container via the <code>docker container exec</code> command. So let’s start up a container in background mode and then enter it using <code>docker container exec</code> and invoking a shell.</p>&#13;
&#13;
<p>The command you invoke doesn’t have to be a shell: it’s possible to run individual commands inside the container and see their results outside it using <code>docker container exec</code>. But if you want to get inside the container to look around, a shell is the easiest way to do that.</p>&#13;
&#13;
<p>To run <code>docker container exec</code>, we’ll need our container’s ID. For this demo, let’s create a container that will just run the <code>sleep</code> command for 600 seconds:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>-d<code class="w"> </code>--rm<code class="w">  </code>ubuntu:22.04<code class="w"> </code>sleep<code class="w"> </code><code class="m">600</code><code class="w"/>&#13;
<code class="go">9f09ac4bcaa0f201e31895b15b479d2c82c30387cf2c8a46e487908d9c285eff</code></pre>&#13;
&#13;
<p>The short ID for this container is <code>9f09ac4bcaa0</code>. We can now use that to get inside the container with <code>docker container exec</code>. The command line for that, unsurprisingly, looks a lot like the command line for <code>docker container run</code>. <a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="exec" data-tertiary="-it for interactive terminal" data-tertiary-sortas="it" data-type="indexterm" id="idm46803144818992"/>We request an interactive session and a pseudo-TTY with the <code>-i</code> and <code>-t</code> flags:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code><code class="nb">exec</code><code class="w"> </code>-it<code class="w"> </code>9f09ac4bcaa0<code class="w"> </code>/bin/bash<code class="w"/>&#13;
<code class="gp">root@9f09ac4bcaa0:/#</code></pre>&#13;
&#13;
<p>Note that we got a command line back that tells us the ID of the container we’re running inside. That’s pretty useful for keeping track of where we are. <a data-primary="processes" data-secondary="inside a running container" data-type="indexterm" id="idm46803144796240"/><a data-primary="ps command" data-type="indexterm" id="idm46803144795392"/>We can now run a normal Linux <code>ps</code> to see what else is running inside our container. We should see the <code>sleep</code> process that was created when the container was originally started:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">root@9f09ac4bcaa0:/# </code>ps<code class="w"> </code>-ef<code class="w"/>&#13;
<code class="go">UID        PID  PPID  C STIME TTY          TIME CMD</code>&#13;
<code class="go">root         1     0  0 20:22 ?        00:00:00 sleep 600</code>&#13;
<code class="go">root         7     0  0 20:23 pts/0    00:00:00 /bin/bash</code>&#13;
<code class="go">root        15     7  0 20:23 pts/0    00:00:00 ps -ef</code></pre>&#13;
&#13;
<p>Type <code>exit</code> to get out of the container when you are done.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>You can also run additional processes<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="exec" data-tertiary="-d for running background processes" data-tertiary-sortas="d" data-type="indexterm" id="idm46803144764064"/> in the background via <code>docker container exec</code>. You use the <code>-d</code> option just like with <code>docker container run</code>. But you should think hard about doing that for anything but debugging because you lose the repeatability of the image deployment if you depend on this mechanism. Other people would then have to know what to pass to <code>docker container exec</code> to get the desired functionality. If you’re tempted to do this, you would probably reap bigger gains from rebuilding your container image to launch both processes in a repeatable way. If you need to signal to the software inside the container to take some action like rotating logs or reloading a configuration, it is cleaner to leverage <code>docker container kill -s &lt;SIGNAL&gt;</code> with the standard Unix signal name to pass information to the process inside the container.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="docker volume" data-type="sect2"><div class="sect2" id="idm46803144830080">&#13;
<h2>docker volume</h2>&#13;
&#13;
<p>Docker supports a <code>volume</code> subcommand<a data-primary="shell running in a container" data-secondary="getting inside a running container" data-tertiary="docker volume" data-type="indexterm" id="ch06-vol"/><a data-primary="Linux containers" data-secondary="inside a running container" data-tertiary="docker volume" data-type="indexterm" id="ch06-vol2"/><a data-primary="docker volume" data-primary-sortas="docker-z" data-secondary="about" data-type="indexterm" id="idm46803144723216"/><a data-primary="storage volumes for Linux containers" data-secondary="docker volume command" data-type="indexterm" id="idm46803144722000"/> that makes it possible to list all of the volumes stored in your root directory and then discover additional information about them, including where they are physically stored on the server.</p>&#13;
&#13;
<p>These volumes are not bind-mounted; instead, they are special data containers that provide a useful method for persisting data.</p>&#13;
&#13;
<p>If we run a normal <code>docker</code> command that bind-mounts a directory, we’ll notice that it does not create any Docker volumes:<a data-primary="docker volume" data-primary-sortas="docker-z" data-secondary="ls" data-type="indexterm" id="idm46803144707376"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>volume<code class="w"> </code>ls<code class="w"/>&#13;
<code class="go">DRIVER              VOLUME NAME</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>-v<code class="w"> </code>/tmp:/tmp<code class="w"> </code>ubuntu:latest<code class="w"> </code>sleep<code class="w"> </code><code class="m">120</code><code class="w"/>&#13;
<code class="go">6fc97c50fb888054e2d01f0a93ab3b3db172b2cd402fc1cd616858b2b5138857</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>volume<code class="w"> </code>ls<code class="w"/>&#13;
<code class="go">DRIVER              VOLUME NAME</code></pre>&#13;
&#13;
<p>However, you can easily create a new volume with a command like this:<a data-primary="docker volume" data-primary-sortas="docker-z" data-secondary="create" data-type="indexterm" id="idm46803144695200"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>volume<code class="w"> </code>create<code class="w"> </code>my-data<code class="w"/></pre>&#13;
&#13;
<p>If you then list all your volumes, you should see something like this:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>volume<code class="w"> </code>ls<code class="w"/>&#13;
&#13;
<code class="go">DRIVER              VOLUME NAME</code>&#13;
<code class="go">local               my-data</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>volume<code class="w"> </code>inspect<code class="w"> </code>my-data<code class="w"/></pre>&#13;
&#13;
<pre class="nomargin" data-code-language="json" data-type="programlisting"><code class="p">[</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"CreatedAt"</code><code class="p">:</code><code class="w"> </code><code class="s2">"2022-07-31T16:19:42Z"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Driver"</code><code class="p">:</code><code class="w"> </code><code class="s2">"local"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Labels"</code><code class="p">:</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Mountpoint"</code><code class="p">:</code><code class="w"> </code><code class="s2">"/var/lib/docker/volumes/my-data/_data"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"my-data"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Options"</code><code class="p">:</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"Scope"</code><code class="p">:</code><code class="w"> </code><code class="s2">"local"</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">]</code><code class="w"/></pre>&#13;
&#13;
<p>Now you can start a container with this data volume attached to it by running the following:<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="--mount storage volume" data-tertiary-sortas="mount" data-type="indexterm" id="idm46803144565696"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp"> $ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">     </code>--mount<code class="w"> </code><code class="nv">source</code><code class="o">=</code>my-data,target<code class="o">=</code>/app<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">     </code>ubuntu:latest<code class="w"> </code>touch<code class="w"> </code>/app/my-persistent-data<code class="w"/></pre>&#13;
&#13;
<p>That container created a file in the data volume and then immediately exited.</p>&#13;
&#13;
<p>If we now mount that data volume to a different container, we will see that our data is still there:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>--mount<code class="w"> </code><code class="nv">source</code><code class="o">=</code>my-data,target<code class="o">=</code>/app<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>fedora:latest<code class="w"> </code>ls<code class="w"> </code>-lFa<code class="w"> </code>/app/my-persistent-data<code class="w"/>&#13;
&#13;
<code class="go">-rw-r--r-- 1 root root 0 Jul 31 16:24 /app/my-persistent-data</code></pre>&#13;
&#13;
<p>And finally, you can delete the data volume when you are done with it by running the following:<a data-primary="docker volume" data-primary-sortas="docker-z" data-secondary="rm" data-type="indexterm" id="idm46803144439264"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>volume<code class="w"> </code>rm<code class="w"> </code>my-data<code class="w"/>&#13;
&#13;
<code class="go">my-data</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you try to delete a volume that is in use by a container (whether it is running or not), you’ll get an error like this:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">Error response from daemon: unable to remove volume:&#13;
    remove my-data: volume is in use - [&#13;
    d0763e6e8d79e55850a1d3ab21e9d…,&#13;
    4b40d52978ea5e784e66ddca8bc22…]</pre>&#13;
</div>&#13;
&#13;
<p>These commands should help you explore your containers in great detail. Once we’ve explained namespaces more in <a data-type="xref" href="ch11.html#advanced_topics">Chapter 11</a>, you’ll get a better understanding of exactly how all these pieces interact and combine to create a container.<a data-startref="ch06-inside" data-type="indexterm" id="idm46803144400800"/><a data-startref="ch06-inside2" data-type="indexterm" id="idm46803144400304"/><a data-startref="ch06-inside3" data-type="indexterm" id="idm46803144399696"/><a data-startref="ch06-inside4" data-type="indexterm" id="idm46803144399088"/><a data-startref="ch06-vol" data-type="indexterm" id="idm46803144398480"/><a data-startref="ch06-vol2" data-type="indexterm" id="idm46803144397872"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logging" data-type="sect1"><div class="sect1" id="docker_logs">&#13;
<h1>Logging</h1>&#13;
&#13;
<p>Logging is a critical part of any production application.<a data-primary="logging" data-secondary="about" data-type="indexterm" id="idm46803144395200"/> When things go wrong, logs can be a critical tool in restoring service, so they need to be done well. There are some common ways in which we expect to interact with application logs on Linux systems, some better than others. If you’re running an application process on a box, you might expect the output to go to a local logfile that you could read through. Or perhaps you might expect the output to simply be logged to the kernel buffer where it can be read from <code>dmesg</code>. <a data-primary="Linux" data-secondary="systemd" data-tertiary="logging" data-type="indexterm" id="idm46803144380512"/>Or, as on many modern Linux distributions with <code>systemd</code>, you might expect logs to be available from <code>journalctl</code>. Because of the container’s restrictions and how Docker is constructed, none of these will work without at least some configuration on your part. But that’s OK because logging has first-class support in Docker.</p>&#13;
&#13;
<p>Docker makes logging easier in a few critical ways. First, it captures all of the normal text output from applications in the containers it manages. <a data-primary="stdout" data-secondary="captured in logging" data-type="indexterm" id="idm46803144378016"/><a data-primary="stderr" data-secondary="captured in logging" data-type="indexterm" id="idm46803144377040"/>Anything sent to <code>stdout</code> or <code>stderr</code> in the container is captured by the Docker daemon and streamed into a configurable logging backend. Secondly, like many other parts of Docker, this system is pluggable, and there are lots of powerful options available to you as plug-ins. But let’s not dive into the deep end just yet.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="docker container logs" data-type="sect2"><div class="sect2" id="idm46803144374976">&#13;
<h2>docker container logs</h2>&#13;
&#13;
<p>We’ll start with the simplest Docker use case:<a data-primary="logging" data-secondary="docker container logs command" data-secondary-sortas="docker-z" data-type="indexterm" id="ch06-conlog"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="logs" data-type="indexterm" id="ch06-conlog2"/> the default logging mechanism. There are limitations to this mechanism, which we’ll explain in a minute, but for the most common use cases, it works well, and it’s very convenient. If you are running Docker in development, this is probably the only logging strategy you’ll use there. This logging method has been there from the very beginning and is well understood and supported. <a data-primary="json-file logging plug-in" data-type="indexterm" id="ch06-jf"/><a data-primary="logging" data-secondary="json-file logging plug-in" data-type="indexterm" id="ch06-jf2"/><a data-primary="JSON" data-secondary="json-file logging plug-in" data-type="indexterm" id="ch06-jf3"/><a data-primary="plug-ins for Docker" data-secondary="json-file logging" data-type="indexterm" id="ch06-jf4"/>The mechanism is the <code>json-file</code> method. The <code>docker container logs</code> command exposes most users to this.</p>&#13;
&#13;
<p>As implied by the name, when you run the default <code>json-file</code> logging plug-in, your application’s logs are streamed by the Docker daemon into a JSON file for each container. This lets us retrieve logs for any container at any time.</p>&#13;
&#13;
<p>We can display some logs by starting an <code>nginx</code> container:<a data-primary="logging" data-secondary="displaying via nginx container" data-type="indexterm" id="idm46803144347072"/><a data-primary="nginx container for displaying logs" data-type="indexterm" id="idm46803144346096"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="nginx container for log display" data-type="indexterm" id="idm46803144345456"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>--name<code class="w"> </code>nginx-test<code class="w"> </code>--rm<code class="w"> </code>nginx:latest<code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">and then:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>logs<code class="w"> </code>nginx-test<code class="w"/>&#13;
<code class="go">…</code>&#13;
<code class="go">2022/07/31 16:36:05 [notice] 1#1: using the "epoll" event method</code>&#13;
<code class="go">2022/07/31 16:36:05 [notice] 1#1: nginx/1.23.1</code>&#13;
<code class="go">2022/07/31 16:36:05 [notice] 1#1: built by gcc 10.2.1 20210110 (Debian 10.2.1-6)</code>&#13;
<code class="go">2022/07/31 16:36:05 [notice] 1#1: OS: Linux 5.10.104-linuxkit</code>&#13;
<code class="go">…</code></pre>&#13;
&#13;
<p>This is nice because Docker allows you to get the logs remotely, right from the command line, on demand. That’s very useful for low-volume logging.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>To limit the log output to more recent logs,<a data-primary="logging" data-secondary="displaying via nginx container" data-tertiary="--since option to filter" data-tertiary-sortas="since" data-type="indexterm" id="idm46803144324544"/> you can use the <span class="keep-together"><code>--since</code></span> option to display logs only after a specified RFC 3339 date (e.g., 2002-10-02T10:00:00-05:00), Unix timestamp (e.g., 1450071961), standard timestamp (e.g., 20220731), or Go duration string (e.g., 5m45s). You can also use <code>--tail</code> followed by the number of lines you would like to tail.</p>&#13;
</div>&#13;
&#13;
<p>The actual files backing this logging<a data-primary="logging" data-secondary="log file location on server" data-type="indexterm" id="idm46803144293776"/><a data-primary="Docker server" data-primary-sortas="docker-a" data-secondary="log file location" data-type="indexterm" id="idm46803144292832"/><a data-primary="stdout" data-secondary="captured in logging" data-tertiary="log file json.log" data-type="indexterm" id="idm46803144291616"/><a data-primary="stderr" data-secondary="captured in logging" data-tertiary="log file json.log" data-type="indexterm" id="idm46803144290400"/> are on the Docker server itself, by default in <em>/var/lib/docker/containers/<code>&lt;container_id&gt;</code>/</em> where the <code><em>&lt;container_id&gt;</em></code> is replaced by the actual container ID. If you take a look at the file named &#13;
<span class="keep-together"><code><em>&lt;container_id&gt;</em>-json.log</code>,</span> you’ll see that it’s a file with each line representing a JSON object. It will look something like this:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="nt">"log"</code><code class="p">:</code><code class="s2">"2022/07/31 16:36:05 [notice] 1#1: using the \"epoll\" event method\n"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"stream"</code><code class="p">:</code><code class="s2">"stderr"</code><code class="p">,</code><code class="nt">"time"</code><code class="p">:</code><code class="s2">"2022-07-31T16:36:05.189234362Z"</code><code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>That <code>log</code> field is exactly what was sent to <code>stdout</code> on the process in question; the <code>stream</code> field tells us that this was <code>stdout</code> and not <code>stderr</code>, and the precise time that the Docker daemon received it is provided in the <code>time</code> field. It’s an uncommon format for logging, but it’s structured rather than just a raw stream, which is beneficial if you want to do anything with the logs later.</p>&#13;
&#13;
<p>Like a logfile, you can also tail the Docker logs live with <code>docker container logs -f</code>:<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="logs" data-tertiary="-f for live display" data-tertiary-sortas="f" data-type="indexterm" id="idm46803144237728"/><a data-primary="logging" data-secondary="live display stream" data-type="indexterm" id="idm46803144236048"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>logs<code class="w"> </code>-f<code class="w"> </code>nginx-test<code class="w"/>&#13;
<code class="go">…</code>&#13;
<code class="go">2022/07/31 16:36:05 [notice] 1#1: start worker process 35</code>&#13;
<code class="go">2022/07/31 16:36:05 [notice] 1#1: start worker process 36</code>&#13;
<code class="go">2022/07/31 16:36:05 [notice] 1#1: start worker process 37</code>&#13;
<code class="go">2022/07/31 16:36:05 [notice] 1#1: start worker process 38</code></pre>&#13;
&#13;
<p class="pagebreak-before">This looks identical to the usual <code>docker container logs</code>, but the client will continue to wait for, and then display, new messages as they are received from the server, much like the Linux command line <code>tail -f</code>. You can type Ctrl-C to exit the logs stream at any time:<a data-primary="exiting via Ctrl-C" data-secondary="logs stream" data-type="indexterm" id="idm46803144226672"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="go">---</code>&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>stop<code class="w"> </code>nginx-test<code class="w"/>&#13;
<code class="go">---</code></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>By configuring the tag log option<a data-primary="logging" data-secondary="changing default log tag" data-type="indexterm" id="idm46803144197360"/> similar to <code>--log-opt tag="{{.ImageName}}/{{.ID}}"</code>, it is possible to change the default log tag (which every log line will start with) to something more useful. By default, Docker logs will be tagged with the first 12 characters of the container ID.</p>&#13;
</div>&#13;
&#13;
<p>For single-host logging, this mechanism is pretty good. Its shortcomings are around log rotation, remote access to the logs once they’ve been rotated, and disk space usage for high-volume logging. Despite being backed by a JSON file, this mechanism performs well enough that most production applications can log this way if that’s the solution that works for you. But if you have a more complex environment, you’re going to want something more robust and with centralized logging capabilities.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The default settings for <code>dockerd</code> do not currently<a data-primary="logging" data-secondary="log rotation" data-type="indexterm" id="idm46803144168128"/><a data-primary="daemon.json configuration file" data-secondary="logging settings" data-type="indexterm" id="idm46803144167120"/> enable log rotation. You’ll want to make sure you specify the <code>--log-opt</code> <code>max-size</code> and <code>--log-opt</code> <code>max-file</code> settings via the command line or the &#13;
<span class="keep-together"><em>daemon.json</em></span> configuration file if you are running in production. Those settings limit the largest file size before rotation and the maximum number of logfiles to keep, respectively. <code>max-file</code> does not do anything unless you’ve also set <code>max-size</code> to tell Docker when to rotate the logs. When this is enabled, the <code>docker container logs</code> mechanism will return data only from the current logfile.<a data-startref="ch06-conlog" data-type="indexterm" id="idm46803144142064"/><a data-startref="ch06-conlog2" data-type="indexterm" id="idm46803144141456"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Advanced Logging" data-type="sect2"><div class="sect2" id="idm46803144374352">&#13;
<h2>More Advanced Logging</h2>&#13;
&#13;
<p>For those times when the default mechanism<a data-primary="logging" data-secondary="advanced logging" data-type="indexterm" id="ch06-adv"/> isn’t enough—and at scale, it’s probably not—Docker also supports configurable logging backends. This list of plug-ins is constantly growing. Currently supported are the <code>json-file</code> we described earlier, as well as <code>syslog</code>, <code>fluentd</code>, <code>journald</code>, <code>gelf</code>, <code>awslogs</code>, <code>splunk</code>, <code>gcplogs</code>, <code>local</code>, and <code>logentries</code>, which are used for sending logs to various popular logging frameworks and services.</p>&#13;
&#13;
<p class="pagebreak-before">That’s a big list of plug-ins we just threw out there. <a data-primary="logging" data-secondary="advanced logging" data-tertiary="syslog" data-type="indexterm" id="idm46803144133168"/><a data-primary="daemon.json configuration file" data-secondary="--log-driver option" data-secondary-sortas="log-driver" data-type="indexterm" id="idm46803144131984"/><a data-primary="logging" data-secondary="changing log driver" data-type="indexterm" id="idm46803144130800"/>The supported option that currently is the simplest for running Docker at scale is sending your container logs to <code>syslog</code> directly from Docker. You can specify this on the Docker command line with the <code>--log-driver=syslog</code> option or set it as the default in the <em>daemon.json</em> file for all containers.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>The <em>daemon.json</em> file is the <a data-primary="logging" data-secondary="configuration via daemon.json" data-seealso="daemon.json configuration file" data-type="indexterm" id="idm46803144126832"/><a data-primary="daemon.json configuration file" data-secondary="location of" data-type="indexterm" id="idm46803144125616"/><a data-primary="Docker Desktop" data-primary-sortas="docker-a" data-secondary="daemon.json file editing" data-type="indexterm" id="idm46803144124704"/><a data-primary="daemon.json configuration file" data-secondary="location of" data-tertiary="Docker Desktop" data-type="indexterm" id="idm46803144123520"/><a data-primary="Docker server" data-primary-sortas="docker-a" data-secondary="daemon.json configuration file location" data-type="indexterm" id="idm46803144122288"/><a data-primary="Docker server" data-primary-sortas="docker-a" data-secondary="daemon.json configuration file location" data-tertiary="Docker Desktop" data-type="indexterm" id="idm46803144121056"/>configuration for the <code>dockerd</code> server. It can usually be found in the <em>/etc/docker/</em> directory on the server. For Docker Desktop, this file can be edited in Preferences → Docker Engine from the UI. If you change this file, you will need to restart Docker Desktop or the <code>dockerd</code> daemon.</p>&#13;
</div>&#13;
&#13;
<p>There are also several third-party plug-ins available. We’ve seen mixed results from third-party plug-ins, primarily because they complicate installing and maintaining Docker. However, you may find that there is a third-party implementation that’s perfect for your system, and it might be worth the installation and maintenance hassle.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Some caveats apply to all of the logging drivers. For example, <a data-primary="logging" data-secondary="about" data-tertiary="one logging driver at a time" data-type="indexterm" id="idm46803144116496"/>Docker supports only one at a time. This means that you can use the <code>syslog</code> or <code>gelf</code> logging driver, but not along with the &#13;
<span class="keep-together"><code>json-file</code></span> driver. <a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="logs" data-tertiary="non-functional with some logging drivers" data-type="indexterm" id="idm46803144113392"/><a data-primary="logging" data-secondary="advanced logging" data-tertiary="journald" data-type="indexterm" id="idm46803144111840"/>Unless you run <code>json-file</code> or <code>journald</code>, you will lose the ability to use the <code>docker container logs</code> command! This may not be expected and is a big consideration when you are changing the driver.</p>&#13;
&#13;
<p>Some plug-ins are designed to send the logs to a remote endpoint and keep a local JSON copy for the <code>docker container logs</code> command, but you will need to determine if the plug-in that you want to use supports this.  There are too many gotchas to go through for each driver, but you should keep in mind the trade-off between guaranteed delivery of logs and the potential for breaking your Docker deployment. UDP-based solutions or other nonblocking options are recommended.<a data-startref="ch06-jf" data-type="indexterm" id="idm46803144108288"/><a data-startref="ch06-jf2" data-type="indexterm" id="idm46803144107584"/><a data-startref="ch06-jf3" data-type="indexterm" id="idm46803144106912"/><a data-startref="ch06-jf4" data-type="indexterm" id="idm46803144106240"/></p>&#13;
</div>&#13;
&#13;
<p>Traditionally, most Linux systems have some kind of syslog receiver, whether it be <code>syslog</code>, <code>rsyslog</code>, or any of the many other options. This protocol in its various forms has been around for a long time and is fairly well supported by most deployments. When migrating to Docker from a traditional Linux or Unix environment, many companies already have syslog infrastructure in place, which means this is often the easiest migration path as well.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Many newer Linux distributions are<a data-primary="logging" data-secondary="advanced logging" data-tertiary="journald" data-type="indexterm" id="idm46803144103184"/><a data-primary="Linux" data-secondary="systemd" data-tertiary="logging" data-type="indexterm" id="idm46803144101936"/> based on the <code>systemd</code> init system and therefore use <code>journald</code> for logging by default, which is different from <code>syslog</code>.</p>&#13;
</div>&#13;
&#13;
<p>While syslog is a traditional solution, it has its problems. The Docker syslog driver supports TLS, TCP, and UDP connection options, which sounds great, but you should be cautious about streaming logs from Docker to a remote log server over TCP or TLS. The problem with this is that they are both run on top of connection-oriented TCP sessions, and Docker tries to connect to the remote logging server at the time of container startup. If it fails to make the connection, it will block trying to start the container. If you are running this as your default logging mechanism, this can strike at any time on any deployment.</p>&#13;
&#13;
<p>This is not a particularly usable state for production systems, and thus it is recommended that you use the UDP option for syslog logging if you intend to use the <code>syslog</code> driver. This does mean your logs are not encrypted and do not have guaranteed delivery. There are various philosophies around logging, and you’ll need to balance your need for logs against the reliability of your system. We tend to recommend erring on the side of reliability, but if you run in a secure audit environment, you may have different priorities.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You can log directly to a remote syslog-compatible server from a single container by setting the log option <code>syslog-address</code> similar to this: <code>--log-opt syslog-address=udp://192.168.42.42:123</code>.</p>&#13;
</div>&#13;
&#13;
<p>One final caveat to be aware of regarding<a data-primary="logging" data-secondary="advanced logging" data-tertiary="blocking by default" data-type="indexterm" id="idm46803144095264"/><a data-primary="logging" data-secondary="changing blocking to non-blocking" data-type="indexterm" id="idm46803144094016"/> most of the logging plug-ins: they are blocking by default, which means that logging back-pressure can cause issues with your application. You can change this behavior by setting <code>--log-opt mode=non-blocking</code> and then setting the maximum buffer size for logs to something like <code>--log-opt max-buffer-size=4m</code>. Once these are set, the application will no longer block when that buffer fills up. Instead, the oldest loglines in memory will be dropped. Again, reliability needs to be weighed here against your business’s need to receive all the logs.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Some third-party libraries and programs write to the filesystem for various (and sometimes unexpected) reasons.<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="--read-only" data-tertiary-sortas="read-only" data-type="indexterm" id="idm46803144090528"/><a data-primary="filesystem layers of Linux containers" data-secondary="read-only to prevent filesystem writes" data-type="indexterm" id="idm46803144088832"/><a data-primary="read-only" data-secondary="preventing filesystem writes" data-type="indexterm" id="idm46803144087808"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="--mount storage volume" data-tertiary-sortas="mount" data-type="indexterm" id="idm46803144086848"/><a data-primary="tmpfs for writable within read-only" data-secondary="logging" data-type="indexterm" id="idm46803144085088"/> If you are trying to design clean containers that do not write directly into the container filesystem, you should consider utilizing the <span class="keep-together"><code>--read-only</code></span> and <code>--mount type=tmpfs</code> options to <code>docker container run</code> that we discussed in <a data-type="xref" href="ch04.html#docker_images">Chapter 4</a>. Writing logs <em>inside</em> the container is not recommended. It makes them hard to get to, prevents them from being preserved beyond the container life span, and can wreak havoc with the Docker filesystem backend.<a data-startref="ch06-adv" data-type="indexterm" id="idm46803144081040"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Monitoring Docker" data-type="sect1"><div class="sect1" id="idm46803144140384">&#13;
<h1>Monitoring Docker</h1>&#13;
&#13;
<p>Among the most important requirements<a data-primary="monitoring" data-secondary="about" data-type="indexterm" id="idm46803144078960"/> for production systems is that they are observable and measurable. A production system where you are blind to how it’s behaving won’t serve you well. In modern operations environments, we want to monitor everything meaningful and report as many useful statistics as we can. Docker supports container health checks and some basic reporting capabilities via <code>docker container stats</code> and <code>docker system events</code>. We’ll show you those and then look at a community offering from Google that does some nice graphing output, and then we’ll take a look at a—currently experimental—feature of Docker that exports container metrics to the Prometheus monitoring system.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Container Statistics" data-type="sect2"><div class="sect2" id="idm46803144076864">&#13;
<h2>Container Statistics</h2>&#13;
&#13;
<p>Let’s start with the CLI tools that ship with Docker itself.<a data-primary="monitoring" data-secondary="container statistics" data-tertiary="about" data-type="indexterm" id="idm46803144075312"/><a data-primary="Linux containers" data-secondary="monitoring" data-see="monitoring" data-type="indexterm" id="idm46803144073984"/> The <code>docker</code> CLI has an endpoint for viewing important statistics of running containers. The command-line tool can stream from this endpoint and every few seconds report back on one or more listed containers, giving basic statistics information about what’s happening. <code>docker container stats</code>, like the Linux <code>top</code> command, takes over the current terminal and updates the same lines on the screen with the current information. It’s hard to show that in print so we’ll just give an example, but this updates every few seconds by default.<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="stats" data-type="indexterm" id="ch06-stats"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Command-line statistics" data-type="sect3"><div class="sect3" id="idm46803144069840">&#13;
<h3>Command-line statistics</h3>&#13;
&#13;
<p>Start an active container:<a data-primary="monitoring" data-secondary="container statistics" data-tertiary="command-line statistics" data-type="indexterm" id="ch06-clis"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>--name<code class="w"> </code>stress<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>docker.io/spkane/train-os:latest<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>stress<code class="w"> </code>-v<code class="w"> </code>--cpu<code class="w"> </code><code class="m">2</code><code class="w"> </code>--io<code class="w"> </code><code class="m">1</code><code class="w"> </code>--vm<code class="w"> </code><code class="m">2</code><code class="w"> </code>--vm-bytes<code class="w"> </code>128M<code class="w"> </code>--timeout<code class="w"> </code>60s<code class="w"/></pre>&#13;
&#13;
<p>Then run the <code>stats</code> command to look at the new container:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>stats<code class="w"> </code>stress<code class="w"/>&#13;
<code class="go">CONTAINER ID NAME   CPU %   MEM USAGE/LIMIT   MEM % NET I/O   BLOCK I/O PIDS</code>&#13;
<code class="go">1a9f52f0855f stress 476.50% 36.09MiB/7.773GiB 0.45% 1.05kB/0B 0B/0B     6</code></pre>&#13;
&#13;
<p>You can type Ctrl-C to exit the <code>stats</code> stream at any time.<a data-primary="exiting via Ctrl-C" data-secondary="stats stream" data-type="indexterm" id="idm46803144030864"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You can use the <code>--no-stream</code> option to get<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="stats" data-tertiary="--no-stream" data-tertiary-sortas="no-stream" data-type="indexterm" id="idm46803144028560"/><a data-primary="debugging" data-secondary="monitoring" data-see="monitoring" data-type="indexterm" id="idm46803144026736"/> a single-point-in-time set of statistics that will not update and will return you back to the command line after the command completes.</p>&#13;
</div>&#13;
&#13;
<p>Let’s break that rather dense output down into some manageable chunks. We have the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The container ID (but not the name).</p>&#13;
</li>&#13;
<li>&#13;
<p>The amount of CPU it’s currently consuming. One hundred percent is equivalent to one whole CPU core.</p>&#13;
</li>&#13;
<li>&#13;
<p>The amount of memory it has in use, followed by the maximum amount it’s allowed to use.</p>&#13;
</li>&#13;
<li>&#13;
<p>Network and block I/O statistics.</p>&#13;
</li>&#13;
<li>&#13;
<p>The number of active processes inside the container.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Some of these will be more useful than others for debugging, so let’s take a look at what you can do with them.</p>&#13;
&#13;
<p>One of the more helpful pieces<a data-primary="memory resources for container" data-secondary="monitoring via docker container stats" data-type="indexterm" id="idm46803143985920"/> of output here is the percentage of memory used versus the limit that was set for the container. One common problem with running production containers is that overly aggressive memory limits can cause the Linux kernel’s OOM killer to stop the container over and over again. The <code>stats</code> command can help you identify and troubleshoot these types of issues.</p>&#13;
&#13;
<p>Concerning I/O statistics, if you run all of your applications in containers, then this summary can make it very clear where your I/O is going from the system. Before containers, this was much harder to figure out!</p>&#13;
&#13;
<p>The number of active processes<a data-primary="processes" data-secondary="monitoring via docker container stats" data-type="indexterm" id="idm46803143983664"/> inside the container helps debug as well. If you have an application that is spawning children without reaping them, this can expose it pretty quickly.</p>&#13;
&#13;
<p>One great feature of <code>docker container stats</code> is that it can show not just one container but all of them in a single summary. That can be pretty revealing, even on boxes where you think you know what they are doing.</p>&#13;
&#13;
<p>That is all useful and easy to digest because it’s human formatted and available on the command line. But there is an additional endpoint on the Docker API that provides a <em>lot</em> more information than is shown in the client. We’ve steered away from directly utilizing the API in this book so far, but in this case, the data provided by the API is so much richer than the client that we’ll go ahead and use <code>curl</code> to make an API request and see what our container is doing. It’s nowhere near as nice to read, but there is a lot more detail.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Remember that basically everything<a data-primary="APIs" data-secondary="everything the Docker client can do" data-type="indexterm" id="idm46803143957472"/><a data-primary="Docker client" data-primary-sortas="docker-a" data-secondary="API can do programmatically" data-type="indexterm" id="idm46803143956432"/> that the <code>docker</code> client can do can be done directly through the Docker APIs. This means that you can programmatically do very similar things in your applications if there is a need.</p>&#13;
</div>&#13;
&#13;
<p>The example in <a data-type="xref" href="#stats_api_endpoint">“stats API endpoint”</a> is a good intro to calling the API directly.<a data-startref="ch06-stats" data-type="indexterm" id="idm46803143953248"/><a data-startref="ch06-clis" data-type="indexterm" id="idm46803143952576"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="stats API endpoint" data-type="sect3"><div class="sect3" id="stats_api_endpoint">&#13;
<h3>stats API endpoint</h3>&#13;
&#13;
<p>The <code>/stats/</code> endpoint that we’ll hit on<a data-primary="monitoring" data-secondary="container statistics" data-tertiary="stats API endpoint" data-type="indexterm" id="ch06-stapi"/><a data-primary="APIs" data-secondary="stats endpoint for monitoring" data-type="indexterm" id="ch06-stapi2"/><a data-primary="stats API endpoint for monitoring" data-type="indexterm" id="ch06-stapi3"/><a data-primary="JSON" data-secondary="stats API endpoint for monitoring" data-type="indexterm" id="ch06-stapi4"/> the API will continue to stream statistics to us as long as we keep the connection open. <a data-primary="jq tool for output formatting" data-type="indexterm" id="idm46803143944032"/><a data-primary="JSON" data-secondary="daemon.json" data-see="daemon.json configuration file" data-type="indexterm" id="idm46803143943344"/>Since as humans we can’t easily parse the JSON, we’ll just ask for one line and then use the tool <code>jq</code> to “pretty-print” it. For this command to work, you’ll need to have <code>jq</code> installed (version 2.6 or later). If you don’t and you still want to see the JSON output, you can skip the pipe to <code>jq</code>, but you’ll get plain, ugly JSON back. If you already have a favorite JSON pretty printer, feel free to use that instead.</p>&#13;
&#13;
<p>Most Docker daemons will be installed with the API available only on the Unix domain socket and not published on TCP. <a data-primary="curl" data-secondary="Docker /events API call" data-type="indexterm" id="idm46803143939952"/>So we’ll use <code>curl</code> from the Docker server host itself to call the API. If you plan to monitor this endpoint in production, you would need to expose the Docker API on a TCP port. This is not something that we recommend, but the <a href="https://dockr.ly/2Lzuox2">Docker documentation</a> will walk you through this.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you are not on the Docker server or using Docker Desktop locally, you may need to inspect the contents of the <code>DOCKER_HOST</code> environment variable, using something like <code>echo $DOCKER_HOST</code>, to discover the hostname or IP address of the Docker server that you are using.</p>&#13;
</div>&#13;
&#13;
<p>First, start up a container that you can read statistics from:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>--name<code class="w"> </code>stress<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>docker.io/spkane/train-os:latest<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>stress<code class="w"> </code>-v<code class="w"> </code>--cpu<code class="w"> </code><code class="m">2</code><code class="w"> </code>--io<code class="w"> </code><code class="m">1</code><code class="w"> </code>--vm<code class="w"> </code><code class="m">2</code><code class="w"> </code>--vm-bytes<code class="w"> </code>128M<code class="w"> </code>--timeout<code class="w"> </code>60s<code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">Now that the container is running, you can get an ongoing stream of statistics about the container in JSON format by running something like <code>curl</code> with your container’s name or hash.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In the following examples, we are running <code>curl</code> against the Docker socket, but you could just as easily run it against the Docker port if it is available.</p>&#13;
</div>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>curl<code class="w"> </code>--no-buffer<code class="w"> </code>-XGET<code class="w"> </code>--unix-socket<code class="w"> </code>/var/run/docker.sock<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>http://docker/containers/stress/stats<code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This JSON stream of statistics will not stop on its own. So for now, we can use the Ctrl-C key combination to stop it.</p>&#13;
</div>&#13;
&#13;
<p>To get a single group of statistics, we can run something similar to this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>curl<code class="w"> </code>-s<code class="w"> </code>-XGET<code class="w"> </code>--unix-socket<code class="w"> </code>/var/run/docker.sock<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>http://docker/containers/stress/stats<code class="w"> </code><code class="p">|</code><code class="w"> </code>head<code class="w"> </code>-n<code class="w"> </code><code class="m">1</code><code class="w"> </code><code class="p">|</code><code class="w"> </code>jq<code class="w"/></pre>&#13;
&#13;
<p>And finally, if we have <a href="https://stedolan.github.io/jq">jq</a> or another tool capable of pretty-printing JSON, we can make this output human readable, as shown here:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>curl<code class="w"> </code>-s<code class="w"> </code>-XGET<code class="w"> </code>--unix-socket<code class="w"> </code>/var/run/docker.sock<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>http://docker/containers/stress/stats<code class="w"> </code><code class="p">|</code><code class="w"> </code>head<code class="w"> </code>-n<code class="w"> </code><code class="m">1</code><code class="w"> </code><code class="p">|</code><code class="w"> </code>jq<code class="w"/></pre>&#13;
&#13;
<pre class="nomargin" data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"read"</code><code class="p">:</code><code class="w"> </code><code class="s2">"2022-07-31T17:41:59.10594836Z"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"preread"</code><code class="p">:</code><code class="w"> </code><code class="s2">"0001-01-01T00:00:00Z"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"pids_stats"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"current"</code><code class="p">:</code><code class="w"> </code><code class="mi">6</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"limit"</code><code class="p">:</code><code class="w"> </code><code class="mi">18446744073709552000</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"blkio_stats"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"io_service_bytes_recursive"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"major"</code><code class="p">:</code><code class="w"> </code><code class="mi">254</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"minor"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"op"</code><code class="p">:</code><code class="w"> </code><code class="s2">"read"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"value"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">},</code><code class="w"/>&#13;
<code class="err">…</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"num_procs"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"storage_stats"</code><code class="p">:</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"cpu_stats"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"cpu_usage"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"total_usage"</code><code class="p">:</code><code class="w"> </code><code class="mi">101883204000</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"usage_in_kernelmode"</code><code class="p">:</code><code class="w"> </code><code class="mi">43818021000</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"usage_in_usermode"</code><code class="p">:</code><code class="w"> </code><code class="mi">58065183000</code><code class="w"/>&#13;
<code class="err">…</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"memory_stats"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"usage"</code><code class="p">:</code><code class="w"> </code><code class="mi">183717888</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"stats"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"active_anon"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"active_file"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="err">…</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"limit"</code><code class="p">:</code><code class="w"> </code><code class="mi">8346021888</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"/stress"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"id"</code><code class="p">:</code><code class="w"> </code><code class="s2">"9be7c9de26864ac97e07fc3d8e3ffb5bb52cc2ba49f569d4ba8d407f8747851f"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"networks"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"eth0"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"rx_bytes"</code><code class="p">:</code><code class="w"> </code><code class="mi">1046</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">"rx_packets"</code><code class="p">:</code><code class="w"> </code><code class="mi">9</code><code class="p">,</code><code class="w"/>&#13;
<code class="err">…</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>There is <em>a lot</em> of information in there.  We’ve cut it down to prevent wasting any more trees or electrons than necessary, but even so, there is a lot to digest. The main idea is to let you see how much data is available from the API about each container. We won’t spend much time going into the details, but you can get quite detailed memory usage information, as well as block I/O and CPU usage information.</p>&#13;
&#13;
<p>If you are doing your own monitoring, this is a great endpoint to hit as well. A drawback, however, is that it’s one endpoint per container, so you can’t get the statistics about all containers from a single call.<a data-startref="ch06-stapi" data-type="indexterm" id="idm46803143374384"/><a data-startref="ch06-stapi2" data-type="indexterm" id="idm46803143373744"/><a data-startref="ch06-stapi3" data-type="indexterm" id="idm46803143373072"/><a data-startref="ch06-stapi4" data-type="indexterm" id="idm46803143469904"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Container Health Checks" data-type="sect2"><div class="sect2" id="health_checks">&#13;
<h2>Container Health Checks</h2>&#13;
&#13;
<p>As with any other application,<a data-primary="Linux containers" data-secondary="health checks" data-type="indexterm" id="ch06-health"/><a data-primary="health checks for Linux containers" data-type="indexterm" id="ch06-health2"/><a data-primary="monitoring" data-secondary="health checks for Linux containers" data-type="indexterm" id="ch06-health3"/> when you launch a container it is possible that it will start and run but never actually enter a healthy state where it could receive traffic. Production systems also fail, and your application may become unhealthy at some point during its life, so you need to be able to deal with that.</p>&#13;
&#13;
<p>Many production environments have standardized ways to health-check applications. Unfortunately, there’s no clear standard for how to do that across organizations, and it’s unlikely that many companies do it in the same way. For this reason, monitoring systems have been built to handle that complexity so that they can work in a lot of different production systems. It’s a clear place where a standard would be a big win.</p>&#13;
&#13;
<p>To help remove this complexity and standardize on a universal interface, Docker has added a health-check mechanism. Following the shipping container metaphor, Linux containers should really look the same to the outside world no matter what is inside the container, so Docker’s health-check mechanism not only standardizes health checking for containers but also maintains the isolation between what is inside the container and what it looks like on the outside. This means that containers from Docker Hub or other shared repositories can implement a standardized health-checking mechanism, and it will work in any other Docker environment designed to run production containers.</p>&#13;
&#13;
<p>Health checks are a build-time configuration<a data-primary="Dockerfiles" data-primary-sortas="docker-a" data-secondary="HEALTH CHECK definition" data-type="indexterm" id="idm46803143606800"/> item and are created with a &#13;
<span class="keep-together"><code>HEALTHCHECK</code></span> definition in the <em>Dockerfile</em>. This directive tells the Docker daemon what command it can run inside the container to ensure the container is in a healthy state. <a data-primary="exit codes" data-secondary="health checks" data-type="indexterm" id="idm46803143604192"/>As long as the command exits with a code of zero (0), Docker will consider the container to be healthy. Any other exit code will indicate to Docker that the container is not in a healthy state, at which point appropriate action can be taken by a scheduler or monitoring system.</p>&#13;
&#13;
<p>We will be using the following project to explore Docker Compose in a few chapters. But, for the moment, it includes a useful example of Docker health checks. Go ahead and pull down a copy of the code, and then navigate into the &#13;
<span class="keeptogether"><em>rocketchat-hubot-demo/mongodb/docker/</em></span> directory:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>git<code class="w"> </code>clone<code class="w"> </code>https://github.com/spkane/rocketchat-hubot-demo.git<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>--config<code class="w"> </code>core.autocrlf<code class="o">=</code>input<code class="w"/>&#13;
<code class="gp">$ </code><code class="nb">cd</code><code class="w"> </code>rocketchat-hubot-demo/mongodb/docker<code class="w"/></pre>&#13;
&#13;
<p>In this directory, you will see a <em>Dockerfile</em> and a script called <code>docker-healthcheck</code>. If you view the <em>Dockerfile</em>, this is all that you will see:</p>&#13;
&#13;
<pre data-code-language="docker" data-type="programlisting"><code class="k">FROM</code><code class="w"> </code><code class="s">docker.io/bitnami/mongodb:4.4</code><code class="w"/>&#13;
<code class="c"># Newer Upstream Dockerfile:</code><code class="w"/>&#13;
<code class="c"># https://github.com/bitnami/containers/blob/</code><code class="w"/>&#13;
<code class="c"># f9fb3f8a6323fb768fd488c77d4f111b1330bd0e/bitnami/mongodb</code><code class="w"/>&#13;
<code class="c"># /5.0/debian-11/Dockerfile</code><code class="w"/>&#13;
&#13;
<code class="k">COPY</code><code class="w"> </code>docker-healthcheck<code class="w"> </code>/usr/local/bin/<code class="w"/>&#13;
&#13;
<code class="c"># Useful Information:</code><code class="w"/>&#13;
<code class="c"># https://docs.docker.com/engine/reference/builder/#healthcheck</code><code class="w"/>&#13;
<code class="c"># https://docs.docker.com/compose/compose-file/#healthcheck</code><code class="w"/>&#13;
<code class="k">HEALTHCHECK</code><code class="w"> </code><code class="k">CMD</code><code class="w"> </code><code class="p">[</code><code class="s2">"docker-healthcheck"</code><code class="p">]</code><code class="w"/></pre>&#13;
&#13;
<p>It is very short because we are basing this on the <a href="https://oreil.ly/Is1yt">upstream Mongo image</a>,<sup><a data-type="noteref" href="ch06.html#idm46803143337184" id="idm46803143337184-marker">2</a></sup> and our image inherits a lot of things from that, including the entry point, default command, and port to expose.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Bitnami significantly refactored their container repositories in early 2023, so this link points to a slightly newer version of the <em>Dockerfile</em> that targets MongoDB 5.0. We are using MongoDB 4.4 in this example, but the link should still get the point across.</p>&#13;
</div>&#13;
&#13;
<pre data-code-language="docker" data-type="programlisting"><code class="k">EXPOSE</code><code class="w"> </code><code class="s">27017</code><code class="w"/>&#13;
<code class="k">ENTRYPOINT</code><code class="w"> </code><code class="p">[</code><code class="w"> </code><code class="s2">"/opt/bitnami/scripts/mongodb/entrypoint.sh"</code><code class="w"> </code><code class="p">]</code><code class="w"/>&#13;
<code class="k">CMD</code><code class="w"> </code><code class="p">[</code><code class="w"> </code><code class="s2">"/opt/bitnami/scripts/mongodb/run.sh"</code><code class="w"> </code><code class="p">]</code><code class="w"/></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Be aware that Docker will forward traffic to a container’s ports even when the container and underlying processes are still spinning up.</p>&#13;
</div>&#13;
&#13;
<p>So, in our <em>Dockerfile</em> we are only adding a single script that can health-check our container, and defining a health-check command that runs that script.</p>&#13;
&#13;
<p>You can build the container like this:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>image<code class="w"> </code>build<code class="w"> </code>-t<code class="w"> </code>mongo-with-check:4.4<code class="w"> </code>.<code class="w"/>&#13;
<code class="go"> =&gt; [internal] load build definition from Dockerfile                      0.0s</code>&#13;
<code class="go"> =&gt; =&gt; transferring dockerfile: 37B                                       0.0s</code>&#13;
<code class="go"> =&gt; [internal] load .dockerignore                                         0.0s</code>&#13;
<code class="go"> =&gt; =&gt; transferring context: 2B                                           0.0s</code>&#13;
<code class="go"> =&gt; [internal] load metadata for docker.io/bitnami/mongodb:4.4            0.5s</code>&#13;
<code class="go"> =&gt; [internal] load build context                                         0.0s</code>&#13;
<code class="go"> =&gt; =&gt; transferring context: 40B                                          0.0s</code>&#13;
<code class="go"> =&gt; CACHED [1/2] FROM docker.io/bitnami/mongodb:4.4@sha256:9162…ae209     0.0s</code>&#13;
<code class="go"> =&gt; [2/2] COPY docker-healthcheck /usr/local/bin/                         0.0s</code>&#13;
<code class="go"> =&gt; exporting to image                                                    0.0s</code>&#13;
<code class="go"> =&gt; =&gt; exporting layers                                                   0.0s</code>&#13;
<code class="go"> =&gt; =&gt; writing image sha256:a6ef…da808                                    0.0s</code>&#13;
<code class="go"> =&gt; =&gt; naming to docker.io/library/mongo-with-check:4.4                   0.0s</code></pre>&#13;
&#13;
<p>And then run the container and look at the <code>docker container ls</code> output:<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="ls" data-tertiary="health check" data-type="indexterm" id="idm46803143299040"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>-d<code class="w"> </code>--rm<code class="w"> </code>--name<code class="w"> </code>mongo-hc<code class="w"> </code>mongo-with-check:4.4<code class="w"/>&#13;
<code class="go">5a807c892428ab0641232c82bd477fc8d1142c9e15c27d5946b8bfe7056e2695</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>ls<code class="w"/>&#13;
<code class="go">… IMAGE                   … STATUS                      PORTS     …</code>&#13;
<code class="go">… mongo-with-check:4.4 … Up 1 second (health: starting) 27017/tcp …</code></pre>&#13;
&#13;
<p>You should notice that the <code>STATUS</code> column now has a <code>health</code> section in parentheses. Initially, this will display <code>health: starting</code> as the container is starting up. You can change the amount of time that Docker waits for the container to initialize using the <code>--health-start-period</code> argument to <code>docker container run</code>. The status will change to <code>healthy</code> once the container is up and the health check is successful. It might take this container 40+ seconds to transition into a healthy state:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>ls<code class="w"/>&#13;
<code class="go">… IMAGE                   … STATUS               PORTS     …</code>&#13;
<code class="go">… mongo-with-check:4.4 … Up 32 seconds (healthy) 27017/tcp …</code></pre>&#13;
&#13;
<p>You can query this status directly, using the <code>docker container inspect</code> command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>inspect<code class="w"> </code>--format<code class="o">=</code><code class="s1">'{{.State.Health.Status}}'</code><code class="w"> </code>mongo-hc<code class="w"/>&#13;
<code class="go">healthy</code>&#13;
&#13;
<code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>inspect<code class="w"> </code>--format<code class="o">=</code><code class="s1">'{{json .State.Health}}'</code><code class="w"> </code>mongo-hc<code class="w"> </code><code class="p">|</code><code class="w"> </code>jq<code class="w"/></pre>&#13;
&#13;
<pre class="nomargin" data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"Status"</code><code class="p">:</code><code class="w"> </code><code class="s2">"healthy"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"FailingStreak"</code><code class="p">:</code><code class="w"> </code><code class="mi">0</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"Log"</code><code class="p">:</code><code class="w"> </code><code class="p">[</code><code class="w"/>&#13;
<code class="w">    </code><code class="err">…</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">]</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>If your container begins failing its health check, the status will change to <code>unhealthy</code>, and you can then determine how to handle the situation:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>ls<code class="w"/>&#13;
<code class="go">… IMAGE                   … STATUS                PORTS     …</code>&#13;
<code class="go">… mongo-with-check:4.4 … Up 9 minutes (unhealthy) 27017/tcp …</code></pre>&#13;
&#13;
<p>At this point, you can stop the container by simply running <code>docker container stop mongo-hc</code>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>As with most systems, you can configure<a data-primary="Dockerfiles" data-primary-sortas="docker-a" data-secondary="HEALTH CHECK definition" data-tertiary="--health-interval" data-tertiary-sortas="health-interval" data-type="indexterm" id="idm46803143075456"/><a data-primary="health checks for Linux containers" data-secondary="--health-interval" data-secondary-sortas="health-interval" data-type="indexterm" id="idm46803143073696"/><a data-primary="Linux containers" data-secondary="health checks" data-tertiary="--health-interval" data-tertiary-sortas="health-interval" data-type="indexterm" id="idm46803143072512"/><a data-primary="monitoring" data-secondary="health checks for Linux containers" data-tertiary="--health-interval" data-tertiary-sortas="health-interval" data-type="indexterm" id="idm46803143055568"/> a lot of details about your health checks, including how often Docker checks the health (<code>--health-interval</code>), how many failures are required to cause the container to be marked unhealthy (<code>--health-retries</code>), and more. You can even disable the health check completely &#13;
<span class="keep-together">(<code>--no-healthcheck</code>)</span> if needed.</p>&#13;
</div>&#13;
&#13;
<p>This feature is very useful, and you should strongly consider using it in all of your containers. This will help you improve both the reliability of your environment and the visibility you have into how things are running in it. It is also supported by many production schedulers and monitoring systems, so it should be easy to implement.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As always, the usefulness of a health check is largely determined by how well written it is and how accurately it determines the state of the service.<a data-startref="ch06-health" data-type="indexterm" id="idm46803143050480"/><a data-startref="ch06-health2" data-type="indexterm" id="idm46803143049776"/><a data-startref="ch06-health3" data-type="indexterm" id="idm46803143049104"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="docker system events" data-type="sect2"><div class="sect2" id="idm46803143612480">&#13;
<h2>docker system events</h2>&#13;
&#13;
<p>The <code>dockerd</code> daemon internally generates<a data-primary="monitoring" data-secondary="Docker system events" data-type="indexterm" id="ch06-se"/><a data-primary="system events" data-type="indexterm" id="ch06-se2"/><a data-primary="event stream around container lifecycle" data-type="indexterm" id="ch06-se3"/><a data-primary="docker system" data-primary-sortas="docker-z" data-secondary="events" data-type="indexterm" id="ch06-se4"/> an events stream around the container lifecycle. This is how various parts of the system find out what is going on in other parts. You can also tap into this stream to see what lifecycle events are happening for containers on your Docker server. This, as you probably expect by now, is implemented in the <code>docker</code> CLI tool as another command-line argument. When you run this command, it will block and continually stream messages to you. Behind the scenes, this is a long-lived HTTP request to the Docker API that returns messages in JSON blobs as they occur. The <code>docker</code> CLI tool decodes them and prints some data to the terminal.</p>&#13;
&#13;
<p>This events stream is useful in monitoring scenarios or triggering additional actions, like wanting to be alerted when a job completes. For debugging purposes, it allows you to see when a container died even if Docker restarts it later. Down the road, this is a place where you might also find yourself directly implementing some tooling against the API.</p>&#13;
&#13;
<p>In one terminal, go ahead and run the <code>events</code> command:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>system<code class="w"> </code>events<code class="w"/></pre>&#13;
&#13;
<p>You will notice that nothing happens.</p>&#13;
&#13;
<p>In another terminal, go ahead and launch the following short-lived container:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>--name<code class="w"> </code>sleeper<code class="w"> </code>debian:latest<code class="w"> </code>sleep<code class="w"> </code><code class="m">5</code><code class="w"/></pre>&#13;
&#13;
<p>In the original terminal that is running the <code>events</code> command, you should now see something like this:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">…09:59.606… container create d6… (image=debian:latest, name=sleeper)&#13;
…09:59.610… container attach d6… (image=debian:latest, name=sleeper)&#13;
…09:59.631… network connect ea… (container=d60b…, name=bridge, type=bridge)&#13;
…09:59.827… container start d6… (image=debian:latest, name=sleeper)&#13;
…10:04.854… container die d6… (exitCode=0, image=debian:latest, name=sleeper)&#13;
…10:04.907… network disconnect ea… (container=d60b…, name=bridge, type=bridge)&#13;
…10:04.922… container destroy d6… (image=debian:latest, name=sleeper)</pre>&#13;
&#13;
<p>You can type Ctrl-C to exit the events stream at any time.<a data-primary="exiting via Ctrl-C" data-secondary="events stream" data-type="indexterm" id="idm46803142977824"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>As with the Docker statistics,<a data-primary="curl" data-secondary="Docker system event" data-type="indexterm" id="idm46803142978528"/> you can access the Docker system events via <code>curl</code> using a command like <code>curl --no-buffer -XGET --unix-socket /var/run/docker.sock <a class="bare" href="http://docker/events"><em class="hyperlink">http://docker/events</em></a></code>.</p>&#13;
</div>&#13;
&#13;
<p>In this example, we ran a short-lived container that simply counted 5 seconds and then exited.</p>&#13;
&#13;
<p>The <code>container create</code>, <code>container attach</code>, <code>network connect</code>, and <code>container start</code> events are all the steps required to get the container into a running state. When the container exits, the events stream logs a <code>container die</code>, <code>network disconnect</code>, and <code>container destroy</code> message. Each one of these marks a step in completely tearing down the container. Docker also helpfully tells us the ID of the image that the container is running on. This can be useful for tying deployments to events, for example, because a deployment usually involves a new image.</p>&#13;
&#13;
<p>If you have a server where containers<a data-primary="debugging" data-secondary="docker system events" data-type="indexterm" id="idm46803142952816"/> are not staying up, the <code>docker system events</code> stream is pretty helpful in seeing what’s going on and when. But if you’re not watching it at the time, Docker very helpfully caches some of the events, and you can still get at them for some time afterward. You can ask it to display events after a time with the <code>--since</code> option, or before with the <code>--until</code> option. You can also use both to limit the window to a narrow scope of time when an issue you are investigating may have occurred. Both options take ISO time formats like those in the previous example (e.g., 2018-02-18T14:03:31-08:00).</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>There are a few specific event types that you should go out of your way to monitor:<a data-primary="memory resources for container" data-secondary="out of memory" data-tertiary="Docker system events" data-type="indexterm" id="idm46803142943184"/></p>&#13;
<dl>&#13;
<dt><code>container oom</code></dt>&#13;
<dd>&#13;
<p>Appears when a container runs out of memory</p>&#13;
</dd>&#13;
<dt><code>container exec_create</code></dt>&#13;
<dt><code>container exec_start</code></dt>&#13;
<dt><code>container exec_die</code></dt>&#13;
<dd>&#13;
<p>Appear when someone has used <code>docker container exec</code> to enter a container, which could signal a security incident<a data-startref="ch06-se" data-type="indexterm" id="idm46803142937136"/><a data-startref="ch06-se2" data-type="indexterm" id="idm46803142936432"/><a data-startref="ch06-se3" data-type="indexterm" id="idm46803142935760"/><a data-startref="ch06-se4" data-type="indexterm" id="idm46803142918688"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="cAdvisor" data-type="sect2"><div class="sect2" id="idm46803143029360">&#13;
<h2>cAdvisor</h2>&#13;
&#13;
<p><code>docker container stats</code> and <code>docker system events</code> are useful but don’t<a data-primary="monitoring" data-secondary="cAdvisor" data-type="indexterm" id="Ch06-cAdv"/><a data-primary="cAdvisor for monitoring" data-type="indexterm" id="Ch06-cAdv2"/> get us graphs to look at yet. And graphs are pretty helpful when we’re trying to see trends. Of course, other people have filled some of this gap. When you begin to explore the options for monitoring Docker, you will find that many of the major monitoring tools now provide some functionality to help you improve the visibility into your containers’ performance and ongoing state.</p>&#13;
&#13;
<p>In addition to the commercial tooling provided by companies like Datadog, GroundWork, and New Relic, there are plenty of options for free, open source tools like Prometheus or even Nagios. We’ll talk about Prometheus in <a data-type="xref" href="#prom_monitoring">“Prometheus Monitoring”</a>. Soon after Docker was introduced, Google released its internal container monitoring tool as a well-maintained open source project on GitHub, called <a href="https://github.com/google/cadvisor">cAdvisor</a>. Although cAdvisor can be run outside of Docker, by now you’re probably not surprised to hear that the easiest implementation of cAdvisor is to simply run it as a Linux container.</p>&#13;
&#13;
<p>To install cAdvisor on most Linux systems, all you need to do is run this code.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This command is intended to be run directly on a Linux Docker server. It will not work properly when run from a Windows or macOS system.<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="-d/--detach" data-tertiary-sortas="d" data-type="indexterm" id="idm46803142910384"/></p>&#13;
</div>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--volume<code class="o">=</code>/:/rootfs:ro<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--volume<code class="o">=</code>/var/run:/var/run:ro<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--volume<code class="o">=</code>/sys:/sys:ro<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--volume<code class="o">=</code>/var/lib/docker/:/var/lib/docker:ro<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--volume<code class="o">=</code>/dev/disk/:/dev/disk:ro<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--publish<code class="o">=</code><code class="m">8080</code>:8080<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--detach<code class="o">=</code><code class="nb">true</code><code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--name<code class="o">=</code>cadvisor<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--privileged<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--rm<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--device<code class="o">=</code>/dev/kmsg<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>gcr.io/cadvisor/cadvisor:latest<code class="w"/>&#13;
&#13;
<code class="go">Unable to find image 'cadvisor/cadvisor:latest' locally</code>&#13;
<code class="go">Pulling repository cadvisor/cadvisor</code>&#13;
<code class="go">f0643dafd7f5: Download complete</code>&#13;
<code class="go">…</code>&#13;
<code class="go">ba9b663a8908: Download complete</code>&#13;
<code class="go">Status: Downloaded newer image for cadvisor/cadvisor:latest</code>&#13;
<code class="go">f54e6bc0469f60fd74ddf30770039f1a7aa36a5eda6ef5100cddd9ad5fda350b</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>On Red Hat Enterprise Linux (RHEL)-based systems, you may need to add the following line to the <code>docker container run</code> command shown here: &#13;
<span class="keep-together"><code>--volume=/cgroup:/cgroup \</code>.</span></p>&#13;
</div>&#13;
&#13;
<p>Once you have done this, you will be able to navigate to your Docker host on port 8080 to see the cAdvisor web interface (e.g., <em>http://172.17.42.10:8080/</em>) and the various detailed charts it has for the host and individual containers (see <a data-type="xref" href="#figure6-1">Figure 6-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure6-1">&#13;
<img alt="cAdvisor CPU Graphs" src="assets/dur3_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>cAdvisor CPU graphs (example)</h6>&#13;
</div></figure>&#13;
&#13;
<p>cAdvisor provides a REST API endpoint, which can easily be queried for detailed information by your monitoring systems:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>curl<code class="w"> </code>http://172.17.42.10:8080/api/v2.1/machine/<code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">You can find details about the cAdvisor API in <a href="https://github.com/google/cadvisor/blob/master/docs/api_v2.md">the official documentation</a>.</p>&#13;
&#13;
<p>The amount of detail provided by cAdvisor should be sufficient for many of your graphing and monitoring needs.<a data-startref="Ch06-cAdv" data-type="indexterm" id="idm46803142844512"/><a data-startref="Ch06-cAdv2" data-type="indexterm" id="idm46803142843904"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Prometheus Monitoring" data-type="sect1"><div class="sect1" id="prom_monitoring">&#13;
<h1>Prometheus Monitoring</h1>&#13;
&#13;
<p>The <a href="https://prometheus.io">Prometheus</a> monitoring system<a data-primary="monitoring" data-secondary="Prometheus for" data-type="indexterm" id="ch06-pro"/><a data-primary="Prometheus for monitoring" data-type="indexterm" id="ch06-pro2"/> has become a popular solution for monitoring distributed systems. It works largely on a pull model, where it reaches out and gathers statistics from endpoints on a timed basis. Docker has an endpoint that was built for Prometheus and makes it easy to integrate your container stats into a Prometheus monitoring system. At the time of this writing, the endpoint is currently experimental and not enabled in the <code>dockerd</code> server by default. Our brief experience with it shows that it seems to work well, and it’s a pretty slick solution, as we’ll show you. We should point out that this solution is for monitoring the <code>dockerd</code> server, in contrast to the other solutions, which exposed information about the containers.</p>&#13;
&#13;
<p>To export metrics to Prometheus, we need to reconfigure the <code>dockerd</code> server to enable the experimental features and to expose the metrics listener on a port of our choice. This is nice because we don’t have to expose the whole Docker API on a TCP listener to get metrics out of the system—a security win at the expense of a little more configuration. <a data-primary="daemon.json configuration file" data-secondary="Prometheus settings for monitoring" data-type="indexterm" id="idm46803142832368"/><a data-primary="--experimental option for Prometheus monitoring" data-primary-sortas="experimental" data-type="indexterm" id="idm46803142831456"/><a data-primary="daemon.json configuration file" data-secondary="experimental and metrics-addr for monitoring" data-type="indexterm" id="idm46803142830544"/><a data-primary="--metrics-addr option for Prometheus monitoring" data-primary-sortas="metrics-addr" data-type="indexterm" id="idm46803142829664"/>To do that, we can either provide the <span class="keep-together"><code>--experimental</code></span> and <code>--metrics-addr=</code> options on the command line, or we can put them into the <em>daemon.json</em> file that the daemon uses to configure itself. Because many current distributions run <code>systemd</code>, and changing configurations there is highly dependent on your installation, we’ll use the <em>daemon.json</em> option since it’s more portable. We’ll demonstrate this on Ubuntu Linux 22.04 LTS. On this distribution, the file is usually not present to begin with. So let’s put one there using your favorite editor.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>As previously mentioned, the <em>daemon.json</em> file for<a data-primary="Docker Desktop" data-primary-sortas="docker-a" data-secondary="daemon.json file editing" data-type="indexterm" id="idm46803142760352"/><a data-primary="Docker server" data-primary-sortas="docker-a" data-secondary="daemon.json configuration file location" data-tertiary="Docker Desktop" data-type="indexterm" id="idm46803142759264"/><a data-primary="daemon.json configuration file" data-secondary="location of" data-tertiary="Docker Desktop" data-type="indexterm" id="idm46803142757808"/> Docker Desktop can be edited in Preferences → Docker Engine from the UI. If you change this file, you will need to restart Docker Desktop or the <code>dockerd</code> daemon.</p>&#13;
</div>&#13;
&#13;
<p>Adjust or add the following lines to the <em>daemon.json</em> file:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"experimental"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">"metrics-addr"</code><code class="p">:</code><code class="w"> </code><code class="s2">"0.0.0.0:9323"</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>You should now have a file that contains only what you just pasted and nothing else.</p>&#13;
<div class="less_space pagebreak-before" data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Any time you make a service available<a data-primary="security" data-secondary="metrics and" data-type="indexterm" id="idm46803142734384"/> on the network, you need to consider what security risks you might introduce. We believe the benefit of making metrics available is worth the trade-off, but you should think through the repercussions in your scenario. For example, making metrics available on the public internet is probably not a good idea in almost all cases.</p>&#13;
</div>&#13;
&#13;
<p>When we restart Docker, we’ll now have a listener on all addresses on port 9323. That’s where Prometheus will connect to get the metrics. But first, we need to restart the <code>dockerd</code> server. Docker Desktop automatically takes care of the restart for you, but if you are on the Linux Docker server, <a data-primary="systemctl to start Docker server" data-secondary="restarting the server" data-type="indexterm" id="idm46803142729104"/>then you can run something like <code>sudo systemctl restart docker</code> to restart the daemon. You should not get any errors returned from the restart. If you do, you likely have something set incorrectly in the <em>daemon.json</em> file.</p>&#13;
&#13;
<p>Now you can test the metrics endpoint with <code>curl</code>:</p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>curl<code class="w"> </code>-s<code class="w"> </code>http://localhost:9323/metrics<code class="w"> </code><code class="p">|</code><code class="w"> </code>head<code class="w"> </code>-15<code class="w"/>&#13;
&#13;
<code class="gp"># </code>HELP<code class="w"> </code>builder_builds_failed_total<code class="w"> </code>Number<code class="w"> </code>of<code class="w"> </code>failed<code class="w"> </code>image<code class="w"> </code>builds<code class="w"/>&#13;
<code class="gp"># </code>TYPE<code class="w"> </code>builder_builds_failed_total<code class="w"> </code>counter<code class="w"/>&#13;
<code class="go">builder_builds_failed_total{reason="build_canceled"} 0</code>&#13;
<code class="go">builder_builds_failed_total{reason="build_target_not_reachable_error"} 0</code>&#13;
<code class="go">builder_builds_failed_total{reason="command_not_supported_error"} 0</code>&#13;
<code class="go">builder_builds_failed_total{reason="dockerfile_empty_error"} 0</code>&#13;
<code class="go">builder_builds_failed_total{reason="dockerfile_syntax_error"} 0</code>&#13;
<code class="go">builder_builds_failed_total{reason="error_processing_commands_error"} 0</code>&#13;
<code class="go">builder_builds_failed_total{reason="missing_onbuild_arguments_error"} 0</code>&#13;
<code class="go">builder_builds_failed_total{reason="unknown_instruction_error"} 0</code>&#13;
<code class="gp"># </code>HELP<code class="w"> </code>builder_builds_triggered_total<code class="w"> </code>Number<code class="w"> </code>of<code class="w"> </code>triggered<code class="w"> </code>image<code class="w"> </code>builds<code class="w"/>&#13;
<code class="gp"># </code>TYPE<code class="w"> </code>builder_builds_triggered_total<code class="w"> </code>counter<code class="w"/>&#13;
<code class="go">builder_builds_triggered_total 0</code>&#13;
<code class="gp"># </code>HELP<code class="w"> </code>engine_daemon_container_actions_seconds<code class="w"> </code>The<code class="w"> </code>number<code class="w"> </code>of<code class="w"> </code>seconds<code class="w"> </code>it<code class="w"/>&#13;
<code class="gp"># </code>takes<code class="w"> </code>to<code class="w"> </code>process<code class="w"> </code>each<code class="w"> </code>container<code class="w"> </code>action<code class="w"/>&#13;
<code class="gp"># </code>TYPE<code class="w"> </code>engine_daemon_container_actions_seconds<code class="w"> </code>histogram<code class="w"/></pre>&#13;
&#13;
<p>If you run this locally, you should get very similar output. It might not be identical, and that’s OK as long as you get something that is not an error message.</p>&#13;
&#13;
<p>So now we have a place where Prometheus can get to our statistics. But we need to have Prometheus running somewhere, right? We can easily do that by spinning up a container. But first, we need to write a simple config. We’ll put it in &#13;
<span class="keep-together"><em>/tmp/prometheus/prometheus.yaml</em>.</span> You can use your favorite editor to put the following into the file:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="c1"># Scrape metrics every 5 seconds and name the monitor 'stats-monitor'</code><code class="w"/>&#13;
<code class="nt">global</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">scrape_interval</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5s</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">external_labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">monitor</code><code class="p">:</code><code class="w"> </code><code class="s">'stats-monitor'</code><code class="w"/>&#13;
&#13;
<code class="c1"># We're going to name our job 'DockerStats' and we'll connect to the docker0</code><code class="w"/>&#13;
<code class="c1"># bridge address to get the stats. If your docker0 has a different IP address</code><code class="w"/>&#13;
<code class="c1"># then use that instead. 127.0.0.1 and localhost will not work.</code><code class="w"/>&#13;
<code class="nt">scrape_configs</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">job_name</code><code class="p">:</code><code class="w"> </code><code class="s">'DockerStats'</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">static_configs</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">targets</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">'172.17.0.1:9323'</code><code class="p-Indicator">]</code><code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For Docker Desktop, you can also use <code>host.docker.internal:9323</code> or <code>gateway.docker.internal:9323</code> in place of the <code>172.17.0.1:9323</code> shown here. Both of these hostnames will point to the container’s IP address.</p>&#13;
</div>&#13;
&#13;
<p>As noted in the file, you should use the IP address of your <code>docker0</code> bridge here, or the IP address of your <code>ens3</code> or <code>eth0</code> interface since <code>localhost</code> and <code>127.0.0.1</code> are not routable from the container. The address we used here is the usual default for <code>docker0</code>, so it’s probably the right one for you.</p>&#13;
&#13;
<p>Now that we’ve written that out, we need to start up the container using this config:<a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="run" data-tertiary="Prometheus monitor" data-type="indexterm" id="idm46803142553824"/></p>&#13;
&#13;
<pre data-code-language="console" data-type="programlisting"><code class="gp">$ </code>docker<code class="w"> </code>container<code class="w"> </code>run<code class="w"> </code>--rm<code class="w"> </code>-d<code class="w"> </code>-p<code class="w"> </code><code class="m">9090</code>:9090<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>-v<code class="w"> </code>/tmp/prometheus/prometheus.yaml:/etc/prometheus.yaml<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">    </code>prom/prometheus<code class="w"> </code>--config.file<code class="o">=</code>/etc/prometheus.yaml<code class="w"/></pre>&#13;
&#13;
<p>That will run the container and volume-mount the config file we made into the container so that it will find the settings it needs to monitor our Docker endpoint. If it starts up cleanly, you should now be able to open your browser and navigate to port 9090 on your host. There you will get a Prometheus window, something like <a data-type="xref" href="#figure6-2">Figure 6-2</a>.</p>&#13;
&#13;
<p>In the following figure, you’ll see that we’ve selected one of the metrics, the <code>engine_daemon_events_total</code>, and graphed it over a short period. You can easily query any of the other metrics in the drop-down. Further work and exploration with Prometheus would allow you to define alerts and alerting policies based on these metrics as well. And it is easy to monitor so much more than just the <code>dockerd</code> server. You can also expose metrics for Prometheus from your applications. <a data-primary="dockprom for monitoring" data-type="indexterm" id="idm46803142488384"/><a data-primary="monitoring" data-secondary="dockprom for" data-type="indexterm" id="idm46803142487712"/>If you’re intrigued and want to look at something more advanced, you might take a look at <a href="https://github.com/stefanprodan/dockprom">dockprom</a>, which leverages Grafana to make nice dashboards and also queries your container metrics like those in the Docker API <code>/stats</code> endpoint.<a data-startref="ch06-pro" data-type="indexterm" id="idm46803142485360"/><a data-startref="ch06-pro2" data-type="indexterm" id="idm46803142484624"/></p>&#13;
&#13;
<figure><div class="figure" id="figure6-2">&#13;
<img alt="Prometheus web UI" src="assets/dur3_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>Prometheus event graph (example)</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exploration" data-type="sect1"><div class="sect1" id="idm46803142842384">&#13;
<h1>Exploration</h1>&#13;
&#13;
<p>This should give you all the basics you need to start running containers. It’s probably worth downloading a container or two from the Docker Hub registry and exploring a bit on your own to get used to the commands we just learned. There are many other things you can do with Docker, including but not limited to the following:<a data-primary="copying files in and out of container" data-type="indexterm" id="idm46803142481120"/><a data-primary="docker container" data-primary-sortas="docker-z" data-secondary="cp to copy files in and out of container" data-type="indexterm" id="idm46803142480448"/><a data-primary="docker image" data-primary-sortas="docker-z" data-secondary="save for saving image to tarball" data-type="indexterm" id="idm46803142479264"/><a data-primary="saving a docker image to a tarball" data-type="indexterm" id="idm46803142478080"/><a data-primary="OCI images" data-secondary="saving to a tarball" data-type="indexterm" id="idm46803142477440"/><a data-primary="docker image" data-primary-sortas="docker-z" data-secondary="import to load an image from a tarball" data-type="indexterm" id="idm46803142476496"/><a data-primary="loading an image from a tarball" data-type="indexterm" id="idm46803142475312"/><a data-primary="OCI images" data-secondary="loading from a tarball" data-type="indexterm" id="idm46803142474672"/><a data-primary="OCI images" data-secondary="filesystem layers" data-tertiary="loading from a tarball" data-type="indexterm" id="idm46803142473728"/></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Copying files in and out of the container with <code>docker container cp</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Saving an image to a tarball with <code>docker image save</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Loading an image from a tarball with <code>docker image import</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Docker has a huge feature set that you will likely grow into over time. Each new release adds more functionality as well. We’ll get into a lot more detail later on about many of the other commands and features, but keep in mind that Docker’s whole feature set is very large.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Wrap-Up" data-type="sect1"><div class="sect1" id="idm46803142448864">&#13;
<h1>Wrap-Up</h1>&#13;
&#13;
<p>In the next chapter, we’ll dive into more technical details about how Docker works and how you can use this knowledge to debug your containerized applications.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46803145473376"><sup><a href="ch06.html#idm46803145473376-marker">1</a></sup> Full URL: <a class="bare" href="https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file"><em class="hyperlink">https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-configuration-file</em></a></p><p data-type="footnote" id="idm46803143337184"><sup><a href="ch06.html#idm46803143337184-marker">2</a></sup> Full URL: <a class="bare" href="https://github.com/bitnami/containers/blob/f9fb3f8a6323fb768fd488c77d4f111b1330bd0e/bitnami/mongodb/5.0/debian-11/Dockerfile"><em class="hyperlink">https://github.com/bitnami/containers/blob/f9fb3f8a6323fb768fd488c77d4f111b1330bd0e/bitnami/mongodb/5.0/debian-11/Dockerfile</em></a></p></div></div></section></body></html>