<html><head></head><body><section data-pdf-bookmark="Chapter 2. Developer Workflows" data-type="chapter" epub:type="chapter"><div class="chapter" id="developer_workflows">&#13;
<h1><span class="label">Chapter 2. </span>Developer Workflows</h1>&#13;
&#13;
&#13;
<p>Kubernetes<a data-primary="development clusters" data-secondary="purpose of" data-type="indexterm" id="id478"/><a data-primary="clusters" data-secondary="development" data-see="development clusters" data-type="indexterm" id="id479"/><a data-primary="developer workflows" data-see="development clusters" data-type="indexterm" id="id480"/> was built for reliably operating software. It simplifies deploying and managing applications with an application-oriented API, self-healing properties, and useful tools like Deployments for zero downtime rollout of software. Although all these tools are useful, they don’t do much to make it easier to develop applications for Kubernetes. This is where developer workflows come into play. Even though many clusters are designed to run production applications and thus are rarely accessed by developer workflows, it is critical to enable development workflows to target Kubernetes, and this typically means having a cluster or at least part of a cluster that is intended for development. Setting up such a cluster to facilitate easy development of applications for Kubernetes is critical to ensuring success with Kubernetes. If there is no code being built for your cluster, the cluster itself isn’t accomplishing much.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Goals" data-type="sect1"><div class="sect1" id="id12">&#13;
<h1>Goals</h1>&#13;
&#13;
<p>Before <a data-primary="development clusters" data-secondary="goals of" data-type="indexterm" id="dev-cluster-goals"/>we describe the best practices for building out development clusters, it is worth stating our goals for such clusters. Obviously, the ultimate goal is to enable developers to rapidly and easily build applications on Kubernetes, but what does that really mean in practice, and how is that reflected in practical features of the development cluster?</p>&#13;
&#13;
<p>To answer this, let’s start by identifying phases of developer interaction with the cluster.</p>&#13;
&#13;
<p>The first <a data-primary="onboarding phase (development clusters)" data-type="indexterm" id="id481"/>phase is <em>onboarding</em>. This is when a new developer joins the team.&#13;
This phase includes giving the user a login to the cluster as well as getting them oriented to&#13;
their first deployment. The goal for this phase is to get a developer’s feet wet in a minimal&#13;
amount of time. You should set a key performance indicator (KPI) goal for this process. A reasonable&#13;
goal would be that a user could go from nothing to the current application at HEAD running in less than&#13;
half an hour. Every time someone is new to the team, test how you are doing against this goal.</p>&#13;
&#13;
<p>The second phase<a data-primary="developing phase (development clusters)" data-type="indexterm" id="id482"/> is <em>developing</em>. This is the day-to-day activity of the developer. The goal for this&#13;
phase is to ensure rapid iteration and debugging. Developers need to quickly and repeatedly push&#13;
code to the cluster. They also need to be able to easily test their code and debug it when it isn’t&#13;
operating properly. The KPI for this phase is more challenging to measure, but you can estimate it&#13;
by measuring the time to get a pull request (PR) or change up and running in the cluster, or with&#13;
surveys of the user’s perceived productivity, or both. You will also be able to measure this in the&#13;
overall productivity of your teams.</p>&#13;
&#13;
<p>The third phase<a data-primary="testing phase (development clusters)" data-type="indexterm" id="id483"/> is <em>testing</em>. This phase is interweaved with developing and&#13;
is used to validate the code before submission and merging. The goals for this&#13;
phase are two-fold. First, the developer should be able to run all tests for their environment&#13;
before a PR is submitted. Second, all tests should automatically run before code is merged into&#13;
the repository. In addition to these goals&#13;
you should also set a KPI for the length of time the tests take to run. As your&#13;
project becomes more complex, it’s natural for more and more tests to take a longer&#13;
time. As this happens, it might become valuable to identify a smaller set of smoke&#13;
tests that a developer can use for initial validation before submitting a PR. You&#13;
should also have a very strict KPI <a data-primary="test flakiness" data-type="indexterm" id="id484"/><a data-primary="flaky tests" data-type="indexterm" id="id485"/>around <em>test flakiness</em>. A flaky test is one that&#13;
occasionally (or not so occasionally) fails. In any reasonably active project, a&#13;
flakiness rate of more than one failure per one thousand runs will lead to&#13;
developer friction. You need to ensure that your cluster environment does not&#13;
lead to flaky tests. Whereas sometimes flaky tests occur due to problems in&#13;
the code, they can also occur because of interference in the development&#13;
environment (e.g., running out of resources and noisy neighbors). You should&#13;
ensure that your development environment is free of such issues by measuring&#13;
test flakiness and acting quickly to<a data-primary="development clusters" data-secondary="goals of" data-startref="dev-cluster-goals" data-type="indexterm" id="id486"/> fix it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Building a Development Cluster" data-type="sect1"><div class="sect1" id="id185">&#13;
<h1>Building a Development Cluster</h1>&#13;
&#13;
<p>When <a data-primary="development clusters" data-secondary="shared" data-tertiary="multiple clusters versus" data-type="indexterm" id="dev-cluster-single-multiple"/><a data-primary="shared development clusters" data-secondary="multiple clusters versus" data-type="indexterm" id="shared-dev-cluster-multiple"/><a data-primary="multiple clusters" data-secondary="shared clusters versus" data-type="indexterm" id="multiple-dev-cluster-shared"/>people begin to think about developing on Kubernetes, one of the first&#13;
choices that occurs is whether to build a single large development cluster&#13;
or to have one cluster per developer. Note that this choice only makes sense&#13;
in an environment in which dynamic cluster creation is easy, such as the public&#13;
cloud. In physical environments, it’s possible that one large cluster is the&#13;
only choice.</p>&#13;
&#13;
<p>If you do have a choice, you should consider the pros and cons of each option.&#13;
If you choose to have a development cluster per user, the significant downside&#13;
of this approach is that it will be more expensive and less efficient, and you will have a large number&#13;
of different development clusters to manage. The extra costs come from the&#13;
fact that each cluster is likely to be heavily underutilized. Also, with&#13;
developers creating different clusters, it becomes more difficult to track and&#13;
garbage-collect resources that are no longer in use. The advantage of the&#13;
cluster-per-user approach is simplicity: each developer can self-service&#13;
manage their own cluster, and from isolation, it’s much more difficult for different&#13;
developers to step on one another’s toes.</p>&#13;
&#13;
<p>On the other hand, a single development cluster will be significantly more&#13;
efficient; you can likely sustain the same number of developers on a shared&#13;
cluster for one-third the price (or less). Plus, it’s much easier&#13;
for you to install shared cluster services, for example, monitoring and&#13;
logging, which makes it significantly easier to produce a developer-friendly&#13;
cluster. The downside of a shared development cluster is the&#13;
process of user management and potential interference between developers.&#13;
Because the process of adding new users and namespaces to the Kubernetes&#13;
cluster isn’t currently streamlined, you will need to activate a process&#13;
to onboard new developers. Although Kubernetes resource management&#13;
and Role-Based Access Control (RBAC) can reduce the probability that two developers conflict, it is&#13;
always possible that a user will <em>brick</em> the development cluster by&#13;
consuming too many resources so that other applications and developers&#13;
won’t schedule. Additionally, you will still need to ensure that developers&#13;
don’t leak and forget about resources they’ve created. This is somewhat&#13;
easier, though, than the approach in which developers each create their own clusters.</p>&#13;
&#13;
<p>Even though both approaches are feasible, generally, our recommendation is to&#13;
have a single large cluster for all developers. Although there are challenges&#13;
in interference between developers, they can be managed, and ultimately the&#13;
cost efficiency and ability to easily add organization-wide capabilities to the&#13;
cluster outweigh the risks of interference. But you will need to invest in a&#13;
process for onboarding developers, resource management, and garbage collection.&#13;
Our recommendation would be to try a single large cluster as a first option.&#13;
As your organization grows (or if it is already large), you might consider having&#13;
a cluster per team or group (10 to 20 people) rather than a giant cluster for&#13;
hundreds of users. This can make both billing and management easier. Moving to multiple clusters can make it more complicated to ensure consistency, but tools like fleet management can make it easier to manage groups<a data-primary="development clusters" data-secondary="shared" data-startref="dev-cluster-single-multiple" data-tertiary="multiple clusters versus" data-type="indexterm" id="id487"/><a data-primary="shared development clusters" data-secondary="multiple clusters versus" data-startref="shared-dev-cluster-multiple" data-type="indexterm" id="id488"/><a data-primary="multiple clusters" data-secondary="shared clusters versus" data-startref="multiple-dev-cluster-shared" data-type="indexterm" id="id489"/> of clusters.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up a Shared Cluster for Multiple Developers" data-type="sect1"><div class="sect1" id="id186">&#13;
<h1>Setting Up a Shared Cluster for Multiple Developers</h1>&#13;
&#13;
<p>When <a data-primary="development clusters" data-secondary="shared" data-tertiary="setting up" data-type="indexterm" id="dev-cluster-share-setup"/>setting up a large cluster, the primary goal is to ensure that multiple&#13;
users can simultaneously use the cluster without stepping on one another’s toes.&#13;
The obvious way to separate your different developers is with Kubernetes&#13;
namespaces. Namespaces <a data-primary="namespaces" data-secondary="purpose of" data-type="indexterm" id="id490"/>can serve as scopes for the deployment of services&#13;
so that one user’s frontend service doesn’t interfere with another user’s&#13;
frontend service. Namespaces are also scopes for RBAC, ensuring that one developer cannot accidentally delete another&#13;
developer’s work. Thus, in a shared cluster it makes sense to use a namespace&#13;
as a developer’s workspace. The processes for onboarding users and&#13;
creating and securing a namespace are described in the following sections.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Onboarding Users" data-type="sect2"><div class="sect2" id="id13">&#13;
<h2>Onboarding Users</h2>&#13;
&#13;
<p>Before <a data-primary="shared development clusters" data-secondary="setting up" data-tertiary="onboarding users" data-type="indexterm" id="share-dev-setup-onboard"/><a data-primary="users" data-secondary="onboarding" data-type="indexterm" id="user-onboard"/><a data-primary="onboarding phase (development clusters)" data-type="indexterm" id="onboard-shared"/><a data-primary="identity management for shared development clusters" data-type="indexterm" id="id-manage-share"/>you can assign a user to a namespace, you have to onboard that user&#13;
to the Kubernetes cluster itself. To achieve this, there are two options.&#13;
You can use certificate-based authentication to create a new certificate&#13;
for the user and give them<a data-primary="kubeconfig files" data-type="indexterm" id="id491"/> a <em>kubeconfig</em> file that they can use to log in,&#13;
or you can configure your cluster to use an external identity system (for&#13;
example, Microsoft Entra ID or AWS  Identity and Access Management [IAM]) for cluster access.</p>&#13;
&#13;
<p>In general, using an external identity system is a best practice because&#13;
it doesn’t require that you maintain two different sources of identity. Additionally, most external systems use short-lived tokens rather than long-lived certificates so the accidental disclosure of a token has a time-bound security impact. If at all possible you should restrict your&#13;
developers to proving their identity via an external identity provider.</p>&#13;
&#13;
<p>Unfortunately, <a data-primary="certificates for shared development clusters" data-type="indexterm" id="certificate-share"/>in some cases this isn’t possible and you need to use certificates.&#13;
Fortunately, you can use the Kubernetes certificate API for creating&#13;
and managing such certificates. Here’s the process for adding a new&#13;
user to an existing cluster.</p>&#13;
&#13;
<p>First, you need to generate a certificate-signing request to generate&#13;
a new certificate. Here is a simple Go program to do this:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kn">package</code><code class="w"> </code><code class="nx">main</code><code class="w"/>&#13;
&#13;
<code class="kn">import</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">	</code><code class="s">"crypto/rand"</code><code class="w"/>&#13;
<code class="w">	</code><code class="s">"crypto/rsa"</code><code class="w"/>&#13;
<code class="w">	</code><code class="s">"crypto/x509"</code><code class="w"/>&#13;
<code class="w">	</code><code class="s">"crypto/x509/pkix"</code><code class="w"/>&#13;
<code class="w">	</code><code class="s">"encoding/asn1"</code><code class="w"/>&#13;
<code class="w">	</code><code class="s">"encoding/pem"</code><code class="w"/>&#13;
<code class="w">	</code><code class="s">"os"</code><code class="w"/>&#13;
<code class="p">)</code><code class="w"/>&#13;
&#13;
<code class="kd">func</code><code class="w"> </code><code class="nx">main</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">name</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">user</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Args</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code><code class="w"/>&#13;
&#13;
<code class="w">	</code><code class="nx">key</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">rsa</code><code class="p">.</code><code class="nx">GenerateKey</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">Reader</code><code class="p">,</code><code class="w"> </code><code class="mi">1024</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">		</code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">keyDer</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x509</code><code class="p">.</code><code class="nx">MarshalPKCS1PrivateKey</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">keyBlock</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">pem</code><code class="p">.</code><code class="nx">Block</code><code class="p">{</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">Type</code><code class="p">:</code><code class="w">  </code><code class="s">"RSA PRIVATE KEY"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">Bytes</code><code class="p">:</code><code class="w"> </code><code class="nx">keyDer</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">	</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">keyFile</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Create</code><code class="p">(</code><code class="nx">name</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">"-key.pem"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">		</code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">pem</code><code class="p">.</code><code class="nx">Encode</code><code class="p">(</code><code class="nx">keyFile</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">keyBlock</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">keyFile</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>&#13;
&#13;
<code class="w">	</code><code class="nx">commonName</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">user</code><code class="w"/>&#13;
<code class="w">	</code><code class="c1">// You may want to update these too</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">emailAddress</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"someone@myco.com"</code><code class="w"/>&#13;
&#13;
<code class="w">	</code><code class="nx">org</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"My Co, Inc."</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">orgUnit</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"Widget Farmers"</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">city</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"Seattle"</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">state</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"WA"</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">country</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="s">"US"</code><code class="w"/>&#13;
&#13;
<code class="w">	</code><code class="nx">subject</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">pkix</code><code class="p">.</code><code class="nx">Name</code><code class="p">{</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">CommonName</code><code class="p">:</code><code class="w">         </code><code class="nx">commonName</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">Country</code><code class="p">:</code><code class="w">            </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="nx">country</code><code class="p">},</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">Locality</code><code class="p">:</code><code class="w">           </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="nx">city</code><code class="p">},</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">Organization</code><code class="p">:</code><code class="w">       </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="nx">org</code><code class="p">},</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">OrganizationalUnit</code><code class="p">:</code><code class="w"> </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="nx">orgUnit</code><code class="p">},</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">Province</code><code class="p">:</code><code class="w">           </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="nx">state</code><code class="p">},</code><code class="w"/>&#13;
<code class="w">	</code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">	</code><code class="nx">asn1</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">asn1</code><code class="p">.</code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">subject</code><code class="p">.</code><code class="nx">ToRDNSequence</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">	</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">		</code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">csr</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x509</code><code class="p">.</code><code class="nx">CertificateRequest</code><code class="p">{</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">RawSubject</code><code class="p">:</code><code class="w">         </code><code class="nx">asn1</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">EmailAddresses</code><code class="p">:</code><code class="w">     </code><code class="p">[]</code><code class="kt">string</code><code class="p">{</code><code class="nx">emailAddress</code><code class="p">},</code><code class="w"/>&#13;
<code class="w">		</code><code class="nx">SignatureAlgorithm</code><code class="p">:</code><code class="w"> </code><code class="nx">x509</code><code class="p">.</code><code class="nx">SHA256WithRSA</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">	</code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">	</code><code class="nx">bytes</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">x509</code><code class="p">.</code><code class="nx">CreateCertificateRequest</code><code class="p">(</code><code class="nx">rand</code><code class="p">.</code><code class="nx">Reader</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">csr</code><code class="p">,</code><code class="w"> </code><code class="nx">key</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">		</code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="p">}</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">csrFile</code><code class="p">,</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">:=</code><code class="w"> </code><code class="nx">os</code><code class="p">.</code><code class="nx">Create</code><code class="p">(</code><code class="nx">name</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="s">".csr"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="k">if</code><code class="w"> </code><code class="nx">err</code><code class="w"> </code><code class="o">!=</code><code class="w"> </code><code class="kc">nil</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">		</code><code class="nb">panic</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">	</code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">	</code><code class="nx">pem</code><code class="p">.</code><code class="nx">Encode</code><code class="p">(</code><code class="nx">csrFile</code><code class="p">,</code><code class="w"> </code><code class="o">&amp;</code><code class="nx">pem</code><code class="p">.</code><code class="nx">Block</code><code class="p">{</code><code class="nx">Type</code><code class="p">:</code><code class="w"> </code><code class="s">"CERTIFICATE REQUEST"</code><code class="p">,</code><code class="w"> </code><code class="nx">Bytes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">bytes</code><code class="p">})</code><code class="w"/>&#13;
<code class="w">	</code><code class="nx">csrFile</code><code class="p">.</code><code class="nx">Close</code><code class="p">()</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>You can run this as follows:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">go<code class="w"> </code>run<code class="w"> </code>csr-gen.go<code class="w"> </code>client<code class="w"> </code>&lt;user-name&gt;<code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>This creates files called <em>client-key.pem</em> and <em>client.csr</em>.&#13;
You can then run the following script to create and download a new certificate:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="ch">#!/bin/bash</code>&#13;
&#13;
<code class="nv">csr_name</code><code class="o">=</code><code class="s2">"my-client-csr"</code><code class="w"/>&#13;
<code class="nv">name</code><code class="o">=</code><code class="s2">"</code><code class="si">${</code><code class="nv">1</code><code class="k">:-</code><code class="nv">my</code><code class="p">-user</code><code class="si">}</code><code class="s2">"</code><code class="w"/>&#13;
&#13;
<code class="nv">csr</code><code class="o">=</code><code class="s2">"</code><code class="si">${</code><code class="nv">2</code><code class="si">}</code><code class="s2">"</code><code class="w"/>&#13;
&#13;
&#13;
cat<code class="w"> </code><code class="s">&lt;&lt;EOF | kubectl create -f -</code>&#13;
<code class="s">apiVersion: certificates.k8s.io/v1</code>&#13;
<code class="s">kind: CertificateSigningRequest</code>&#13;
<code class="s">metadata:</code>&#13;
<code class="s">  name: ${csr_name}</code>&#13;
<code class="s">spec:</code>&#13;
<code class="s">  groups:</code>&#13;
<code class="s">  - system:authenticated</code>&#13;
<code class="s">  request: $(cat ${csr} | base64 | tr -d '\n')</code>&#13;
<code class="s">  usages:</code>&#13;
<code class="s">  - key encipherment</code>&#13;
<code class="s">  - client auth</code>&#13;
<code class="s">EOF</code><code class="w"/>&#13;
&#13;
<code class="nb">echo</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"Approving signing request."</code><code class="w"/>&#13;
kubectl<code class="w"> </code>certificate<code class="w"> </code>approve<code class="w"> </code><code class="si">${</code><code class="nv">csr_name</code><code class="si">}</code><code class="w"/>&#13;
&#13;
<code class="nb">echo</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"Downloading certificate."</code><code class="w"/>&#13;
kubectl<code class="w"> </code>get<code class="w"> </code>csr<code class="w"> </code><code class="si">${</code><code class="nv">csr_name</code><code class="si">}</code><code class="w"> </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s1">'{.status.certificate}'</code><code class="w"> </code><code class="se">\</code>&#13;
<code class="w">	</code><code class="p">|</code><code class="w"> </code>base64<code class="w"> </code>--decode<code class="w"> </code>&gt;<code class="w"> </code><code class="k">$(</code>basename<code class="w"> </code><code class="si">${</code><code class="nv">csr</code><code class="si">}</code><code class="w"> </code>.csr<code class="k">)</code>.crt<code class="w"/>&#13;
&#13;
<code class="nb">echo</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"Cleaning up"</code><code class="w"/>&#13;
kubectl<code class="w"> </code>delete<code class="w"> </code>csr<code class="w"> </code><code class="si">${</code><code class="nv">csr_name</code><code class="si">}</code><code class="w"/>&#13;
&#13;
<code class="nb">echo</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"Add the following to the 'users' list in your kubeconfig file:"</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"- name: </code><code class="si">${</code><code class="nv">name</code><code class="si">}</code><code class="s2">"</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"  user:"</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"    client-certificate: </code><code class="si">${</code><code class="nv">PWD</code><code class="si">}</code><code class="s2">/</code><code class="k">$(</code>basename<code class="w"> </code><code class="si">${</code><code class="nv">csr</code><code class="si">}</code><code class="w"> </code>.csr<code class="k">)</code><code class="s2">.crt"</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"    client-key: </code><code class="si">${</code><code class="nv">PWD</code><code class="si">}</code><code class="s2">/</code><code class="k">$(</code>basename<code class="w"> </code><code class="si">${</code><code class="nv">csr</code><code class="si">}</code><code class="w"> </code>.csr<code class="k">)</code><code class="s2">-key.pem"</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"/>&#13;
<code class="nb">echo</code><code class="w"> </code><code class="s2">"Next you may want to add a role-binding for this user."</code><code class="w"/></pre>&#13;
&#13;
<p>This script prints out the final information that you can add to a <em>kubeconfig</em> file&#13;
to enable that user. Of course, the user has no access privileges, so you will&#13;
need to apply Kubernetes RBAC for the user to grant them privileges to a <a data-primary="shared development clusters" data-secondary="setting up" data-startref="share-dev-setup-onboard" data-tertiary="onboarding users" data-type="indexterm" id="id492"/><a data-primary="users" data-secondary="onboarding" data-startref="user-onboard" data-type="indexterm" id="id493"/><a data-primary="onboarding phase (development clusters)" data-startref="onboard-shared" data-type="indexterm" id="id494"/><a data-primary="identity management for shared development clusters" data-startref="id-manage-share" data-type="indexterm" id="id495"/><a data-primary="certificates for shared development clusters" data-startref="certificate-share" data-type="indexterm" id="id496"/>namespace.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating and Securing a Namespace" data-type="sect2"><div class="sect2" id="id14">&#13;
<h2>Creating and Securing a Namespace</h2>&#13;
&#13;
<p>The<a data-primary="shared development clusters" data-secondary="setting up" data-tertiary="creating/securing namespaces" data-type="indexterm" id="share-dev-setup-create-namespace"/><a data-primary="namespaces" data-secondary="creating/securing" data-type="indexterm" id="namespace-create-secure"/><a data-primary="security" data-secondary="namespaces" data-type="indexterm" id="secure-namespace"/> first step in provisioning a namespace is actually&#13;
just creating it. You can do this using <strong><code>kubectl create namespace my-namespace</code></strong>.</p>&#13;
&#13;
<p>But the truth is that when you create a namespace, you want to attach a bunch of&#13;
metadata to that namespace, for example, the contact information for the team that&#13;
builds the component deployed into the namespace. Generally, this is in the form of annotations; you can either generate the YAML file using some templating, such as <a href="https://oreil.ly/vvtTF">Jinja</a>&#13;
or others, or you can create and then annotate the namespace. A simple script to do&#13;
this looks like:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting"><code class="nv">ns</code><code class="o">=</code><code class="s1">'my-namespace'</code><code class="w"/>&#13;
<code class="nv">team</code><code class="o">=</code><code class="s1">'some team'</code><code class="w"/>&#13;
kubectl<code class="w"> </code>create<code class="w"> </code>namespace<code class="w"> </code><code class="si">${</code><code class="nv">ns</code><code class="si">}</code><code class="w"/>&#13;
kubectl<code class="w"> </code>annotate<code class="w"> </code>namespace<code class="w"> </code><code class="si">${</code><code class="nv">ns</code><code class="si">}</code><code class="w"> </code><code class="nv">team</code><code class="o">=</code><code class="si">${</code><code class="nv">team</code><code class="si">}</code><code class="w"/></pre>&#13;
&#13;
<p>When the namespace is created, you want to secure it by ensuring that you can grant&#13;
access to the namespace to a specific user. To do this, you can bind a role&#13;
to a user in the context of that namespace. You do this by<a data-primary="RoleBinding objects" data-type="indexterm" id="id497"/><a data-primary="users" data-secondary="binding to namespaces" data-type="indexterm" id="user-bind-namespace"/><a data-primary="binding" data-secondary="users to namespaces" data-type="indexterm" id="bind-user-namespace"/> creating a <code>RoleBinding</code>&#13;
object within the namespace itself. The <code>RoleBinding</code> might look like this:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RoleBinding</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">example</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-namespace</code><code class="w"/>&#13;
<code class="nt">roleRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterRole</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">edit</code><code class="w"/>&#13;
<code class="nt">subjects</code><code class="p">:</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">User</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myuser</code><code class="w"/></pre>&#13;
&#13;
<p>To create it, you simply run <code>kubectl create -f role-binding.yaml</code>. Note that you&#13;
can reuse this binding as much as you want as long as you update the namespace in&#13;
the binding to point to the correct namespace. If you ensure that the user&#13;
doesn’t have any other role bindings, you can be assured that this namespace is&#13;
the only part of the cluster to which the user has access. A reasonable practice&#13;
is to also grant reader access to the entire cluster; in this way developers can see&#13;
what others are doing in case it is interfering with their work. Be careful in granting&#13;
such read access, however, because it will include access to secret resources in&#13;
the cluster. Generally, in a development cluster this is OK because everyone is in the&#13;
same organization and the secrets are used only for development; however, if this&#13;
is a concern, then you can create a more fine-grained role that eliminates the ability&#13;
to read secrets.</p>&#13;
&#13;
<p>If you want to limit the resources consumed by a particular namespace to put a cap on costs or ensure that resources are fairly distributed among developers, you can use the ResourceQuota resource to set a limit to the total number&#13;
of resources that any particular namespace consumes. For example, the following quota&#13;
limits the namespace to 10 cores and 100 GB of memory for both Request&#13;
and Limit for the pods in the<a data-primary="shared development clusters" data-secondary="setting up" data-startref="share-dev-setup-create-namespace" data-tertiary="creating/securing namespaces" data-type="indexterm" id="id498"/><a data-primary="namespaces" data-secondary="creating/securing" data-startref="namespace-create-secure" data-type="indexterm" id="id499"/><a data-primary="security" data-secondary="namespaces" data-startref="secure-namespace" data-type="indexterm" id="id500"/><a data-primary="users" data-secondary="binding to namespaces" data-startref="user-bind-namespace" data-type="indexterm" id="id501"/><a data-primary="binding" data-secondary="users to namespaces" data-startref="bind-user-namespace" data-type="indexterm" id="id502"/> namespace:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ResourceQuota</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">limit-compute</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">my-namespace</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">hard</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1"># These look a little odd because they're not nested</code><code class="w"/>&#13;
<code class="err">	</code><code class="c1"># but they refer to the requests and limit fields in</code><code class="w"/>&#13;
<code class="err">	</code><code class="c1"># a Pod</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">requests.cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"10"</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">requests.memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">100Gi</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">limits.cpu</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">10</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">limits.memory</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">100Gi</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing Namespaces" data-type="sect2"><div class="sect2" id="id15">&#13;
<h2>Managing Namespaces</h2>&#13;
&#13;
<p>Now <a data-primary="shared development clusters" data-secondary="setting up" data-tertiary="managing namespaces" data-type="indexterm" id="share-dev-setup-manage-namespace"/><a data-primary="namespaces" data-secondary="managing" data-type="indexterm" id="namespace-manage"/><a data-primary="assigning namespaces" data-type="indexterm" id="assign-namespace"/><a data-primary="users" data-secondary="assigning namespaces" data-type="indexterm" id="user-assign-namespace"/>that you have seen how to onboard a new user and how to&#13;
create a namespace to use as a workspace, the&#13;
question remains how to assign a developer to the namespace.&#13;
As with many things, there is no single perfect answer;&#13;
rather, there are two approaches. The first is to give each user their&#13;
own namespace as part of the onboarding process. This is&#13;
useful because after a user is onboarded, they always have a dedicated&#13;
workspace in which they can develop and manage their applications.&#13;
However, making the developer’s namespace too persistent encourages&#13;
the developer to leave things lying around in the namespace after&#13;
they are done with them, and garbage-collecting and accounting&#13;
individual resources is more complicated. An alternate approach&#13;
is to temporarily create and assign a namespace with a <a data-primary="bounded time to live (TTL) namespaces" data-type="indexterm" id="id503"/>bounded&#13;
time to live (TTL). This ensures that the developer thinks of&#13;
the resources in the cluster as transient and that it is&#13;
easy to build automation around the deletion of entire namespaces&#13;
when their TTL has expired.</p>&#13;
&#13;
<p>In the bounded TTL model, when the developer wants to begin a new project,&#13;
they use a tool to allocate a new namespace for the project.&#13;
When they create the namespace, it has a selection&#13;
of metadata associated with the namespace for management and&#13;
accounting. Obviously, this metadata includes the TTL&#13;
for the namespace, but it also includes the developer to which&#13;
it is assigned, the resources that should be allocated to the&#13;
namespace (e.g., CPU and memory), and the team and purpose&#13;
of the namespace. This metadata ensures that you can both track&#13;
resource usage and delete the namespace at the right time.</p>&#13;
&#13;
<p>Developing the tooling to allocate namespaces on demand can&#13;
seem like a challenge, but simple tooling is relatively easy&#13;
to develop. For example, you can achieve the allocation of a new namespace&#13;
with a simple script that creates the&#13;
namespace and prompts for the relevant metadata to attach&#13;
to the namespace.</p>&#13;
&#13;
<p>If you want to get more integrated with Kubernetes, you can <a data-primary="CRDs (custom resource definitions)" data-secondary="allocating namespaces" data-type="indexterm" id="id504"/>use&#13;
custom resource definitions (CRDs) to enable users to dynamically&#13;
create and allocate new namespaces using the <code>kubectl</code> tool.&#13;
If you have the time and inclination, this is definitely a good&#13;
practice because  it makes namespace management declarative and&#13;
also enables the use of Kubernetes RBAC.</p>&#13;
&#13;
<p>After you have tooling to enable the allocation of namespaces,&#13;
you also need to add tooling to reap namespaces when their TTL&#13;
has expired. Again, you can accomplish this with a simple script&#13;
that examines the namespaces and deletes those that have&#13;
an expired TTL.</p>&#13;
&#13;
<p>You can build this script into a container and use a <code>ScheduledJob</code>&#13;
to run it at an interval like once per hour. These combined tools can ensure that developers can easily allocate&#13;
independent resources for their project as needed, but those&#13;
resources will also be reaped at the proper interval to ensure&#13;
that you don’t have wasted resources and that old resources don’t get in the&#13;
way of new <a data-primary="shared development clusters" data-secondary="setting up" data-startref="share-dev-setup-manage-namespace" data-tertiary="managing namespaces" data-type="indexterm" id="id505"/><a data-primary="namespaces" data-secondary="managing" data-startref="namespace-manage" data-type="indexterm" id="id506"/><a data-primary="assigning namespaces" data-startref="assign-namespace" data-type="indexterm" id="id507"/><a data-primary="users" data-secondary="assigning namespaces" data-startref="user-assign-namespace" data-type="indexterm" id="id508"/>development.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cluster-Level Services" data-type="sect2"><div class="sect2" id="id16">&#13;
<h2>Cluster-Level Services</h2>&#13;
&#13;
<p>In addition<a data-primary="shared development clusters" data-secondary="setting up" data-tertiary="cluster-level services" data-type="indexterm" id="id509"/><a data-primary="cluster-level services" data-type="indexterm" id="id510"/><a data-primary="Logging as a Service (LaaS)" data-type="indexterm" id="id511"/> to using tooling to allocate and manage namespaces, there&#13;
are also useful cluster-level services, and it’s a good idea&#13;
to enable them in your development cluster. The first is log&#13;
aggregation to a central Logging as a Service (LaaS) system. One of the easiest&#13;
things for a developer to do to understand the operation of their&#13;
application is to write something to STDOUT. Although you can&#13;
access these logs via <code>kubectl logs</code>, that log is limited in&#13;
length and is not particularly searchable. If you instead&#13;
automatically ship those logs to a LaaS system&#13;
such as a cloud service or an Elasticsearch cluster, developers&#13;
can easily search through logs for relevant information as well&#13;
as aggregate logging information across multiple containers <a data-primary="development clusters" data-secondary="shared" data-startref="dev-cluster-share-setup" data-tertiary="setting up" data-type="indexterm" id="id512"/>in&#13;
their service.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enabling Developer Workflows" data-type="sect1"><div class="sect1" id="id345">&#13;
<h1>Enabling Developer Workflows</h1>&#13;
&#13;
<p>Now that we have successfully set up a shared cluster and we can onboard&#13;
new application developers to the cluster itself, we need to&#13;
actually get them developing their application. Remember that one of the KPIs we are measuring is the time from onboarding to an&#13;
initial application running in the cluster. It’s clear that via the&#13;
just-described onboarding scripts we can quickly authenticate a user&#13;
to a cluster and allocate a namespace, but what about&#13;
getting started with the application? Unfortunately, even though a few techniques can help with this process, it generally requires&#13;
more convention than automation to get the initial application up&#13;
and running. In the following sections, we describe one approach&#13;
to achieving this; it is by no means the only approach or the only&#13;
solution. You can optionally apply the approach as is or be inspired&#13;
by the ideas to arrive at your own solution.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Initial Setup" data-type="sect2"><div class="sect2" id="id17">&#13;
<h2>Initial Setup</h2>&#13;
&#13;
<p>One of the<a data-primary="development clusters" data-secondary="dependencies, installing" data-type="indexterm" id="dev-cluster-dependency-install"/><a data-primary="dependencies, installing" data-type="indexterm" id="depend-install"/><a data-primary="installing" data-secondary="dependencies" data-type="indexterm" id="install-depend"/> main challenges to deploying an application is the installation&#13;
of all the dependencies. In many cases, especially in modern&#13;
microservice architectures, to even get started developing on one&#13;
of the microservices requires the deployment of multiple dependencies,&#13;
either databases or other microservices. Although the deployment of the&#13;
application itself is relatively straightforward, the task of&#13;
identifying and deploying all the dependencies to build the complete&#13;
application is often a frustrating case of trial and error married with&#13;
incomplete or out-of-date instructions.</p>&#13;
&#13;
<p>To address this issue, it is often valuable to introduce a convention&#13;
for describing and installing dependencies. This can be seen as the&#13;
equivalent of something like <code>npm install</code>, which installs all the&#13;
required JavaScript dependencies. Eventually, there is likely to be&#13;
a tool similar to <code>npm</code> that provides this service for Kubernetes-based&#13;
applications, but until then, the best practice is to rely on convention&#13;
within your team.</p>&#13;
&#13;
<p>One such option for a convention is the creation of a <em>setup.sh</em> script&#13;
within the root directory of all project repositories. The&#13;
responsibility of this script is to create all dependencies within&#13;
a particular namespace to ensure that all the application’s dependencies&#13;
are correctly created. For example, a setup script might look like the&#13;
following:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">kubectl<code class="w"> </code>create<code class="w"> </code>my-service/database-stateful-set-yaml<code class="w"/>&#13;
kubectl<code class="w"> </code>create<code class="w"> </code>my-service/middle-tier.yaml<code class="w"/>&#13;
kubectl<code class="w"> </code>create<code class="w"> </code>my-service/configs.yaml<code class="w"/></pre>&#13;
&#13;
<p>You could then integrate this script with npm by adding the following&#13;
to your <span class="keep-together"><em>package.json</em>:</span></p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="err">...</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">"scripts"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">"setup"</code><code class="p">:</code><code class="w"> </code><code class="s2">"./setup.sh"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="err">...</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>With this setup, a new developer can simply run <code>npm run setup</code>, and&#13;
the cluster dependencies will be installed. Obviously, this particular&#13;
integration is Node.js/npm specific. In other programming languages,&#13;
it will make more sense to integrate with the language-specific tooling.&#13;
For example, in Java you might integrate with a Maven <em>pom.xml</em> file&#13;
instead.</p>&#13;
&#13;
<p>For more generic workflows, both GitHub and Visual Studio&#13;
Code have recently standardized on “devcontainers,” which are containers that&#13;
are described by a Dockerfile stored in the <code>.devcontainer/</code> folder&#13;
in the repository. When built, they construct a complete environment&#13;
for starting development on that<a data-primary="development clusters" data-secondary="dependencies, installing" data-startref="dev-cluster-dependency-install" data-type="indexterm" id="id513"/><a data-primary="dependencies, installing" data-startref="depend-install" data-type="indexterm" id="id514"/><a data-primary="installing" data-secondary="dependencies" data-startref="install-depend" data-type="indexterm" id="id515"/> repository.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enabling Active Development" data-type="sect2"><div class="sect2" id="id187">&#13;
<h2>Enabling Active Development</h2>&#13;
&#13;
<p>Having<a data-primary="development clusters" data-secondary="Deployment resource, rolling out" data-type="indexterm" id="id516"/><a data-primary="Deployment resource" data-secondary="rolling out" data-type="indexterm" id="id517"/><a data-primary="rollouts" data-secondary="Deployment resource" data-type="indexterm" id="id518"/> set up the developer workspace with the required dependencies, the next&#13;
task is to enable developers to iterate on their application quickly. The&#13;
first prerequisite for this is the ability to build and push a container&#13;
image. Let’s assume that you have this already set up; if not, you can read how to do this in a number of other online resources and books.</p>&#13;
&#13;
<p>After you have built and pushed a container image, the task&#13;
is to roll it out to the cluster. Unlike traditional rollouts, in the case of developer iteration, maintaining availability is really not a concern. Thus, the easiest way to deploy new code is to simply delete the Deployment object associated with the previous Deployment and then create a new Deployment pointing to the newly built image. It is also possible to update an existing Deployment in place, but this will trigger the rollout logic in the Deployment resource. Although it is possible to configure a Deployment to roll out code quickly, doing so introduces a difference between the development environment&#13;
and the production environment that can be dangerous or destabilizing.&#13;
Imagine, for example, that you accidentally push the development&#13;
configuration of the Deployment into production; you will suddenly deploy new versions to production without appropriate&#13;
testing and delays between phases of the rollout. Because of this&#13;
risk and because there is an alternative, the best practice is to&#13;
delete and recreate the Deployment.</p>&#13;
&#13;
<p>Just like installing dependencies, it is also a good practice to&#13;
make a script for performing this Deployment. An example <em>deploy.sh</em>&#13;
script might look like the following:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">kubectl<code class="w"> </code>delete<code class="w"> </code>-f<code class="w"> </code>./my-service/deployment.yaml<code class="w"/>&#13;
perl<code class="w"> </code>-pi<code class="w"> </code>-e<code class="w"> </code><code class="s1">'s/${old_version}/${new_version}/'</code><code class="w"> </code>./my-service/deployment.yaml<code class="w"/>&#13;
kubectl<code class="w"> </code>create<code class="w"> </code>-f<code class="w"> </code>./my-service/deployment.yaml<code class="w"/></pre>&#13;
&#13;
<p>As before, you can integrate this with existing programming language&#13;
tooling so that (for example) a developer can simply run <code>npm run deploy</code>&#13;
to deploy their new code into the cluster.</p>&#13;
&#13;
<p>As you build this automation it is often useful to integrate it into&#13;
a continuous integration and delivery (CI/CD) tool such as GitHub Actions,&#13;
Azure DevOps, or Jenkins. Integration with a CI/CD tool makes it much easier&#13;
to enable further automation like automatic deployment on merging a developer’s PR.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Enabling Testing and Debugging" data-type="sect2"><div class="sect2" id="id18">&#13;
<h2>Enabling Testing and Debugging</h2>&#13;
&#13;
<p>After a <a data-primary="development clusters" data-secondary="testing/debugging" data-type="indexterm" id="id519"/><a data-primary="testing" data-secondary="development clusters" data-type="indexterm" id="id520"/><a data-primary="debugging development clusters" data-type="indexterm" id="id521"/>user has successfully deployed the development version of their&#13;
application, they need to test it and, if there are problems, debug any&#13;
issues with the application. This can also be a hurdle when developing in&#13;
Kubernetes because it is not always clear how to interact with your <a data-primary="kubectl command" data-type="indexterm" id="id522"/>cluster.&#13;
The <code>kubectl</code> command line is a veritable Swiss Army knife of tools to&#13;
achieve this, from <code>kubectl logs</code> to <code>kubectl exec</code> and <code>kubectl port-forward</code>,&#13;
but learning how to use all the different options and achieving&#13;
familiarity with the tool can take a considerable amount of experience.&#13;
Furthermore, because the tool runs in the terminal, it often requires the&#13;
composition of multiple windows to simultaneously examine both the source&#13;
code for the application and the running application itself.</p>&#13;
&#13;
<p>To streamline the testing and debugging experience, Kubernetes tooling&#13;
is increasingly being integrated into development environments, for example,&#13;
the open source extension for<a data-primary="Visual Studio (VS) Code for Kubernetes" data-type="indexterm" id="id523"/> Visual Studio (VS) Code for Kubernetes.&#13;
The extension is easily installed for free from the VS Code marketplace.&#13;
When installed, it automatically discovers any clusters that you already&#13;
have in your <em>kubeconfig</em> file and provides a tree-view navigation&#13;
pane for you to see the contents of your cluster at a glance.</p>&#13;
&#13;
<p>In addition to being able to see your cluster state at a glance, the&#13;
integration allows a developer to use the tools available via <code>kubectl</code>&#13;
in an intuitive, discoverable way. From the tree view, if you right-click a Kubernetes pod, you can immediately use port forwarding to bring&#13;
a network connection from the pod directly to the local machine. Likewise,&#13;
you can access the logs for the pod or even get a terminal within the&#13;
running container.</p>&#13;
&#13;
<p>The integration of these commands with prototypical&#13;
user interface expectations (e.g., right-click shows a context menu),&#13;
as well as the integration of these experiences alongside the code for&#13;
the application itself, enables developers with minimal Kubernetes&#13;
experience to rapidly become productive in the development cluster.</p>&#13;
&#13;
<p>Of course this VS Code extension isn’t the only integration&#13;
between Kubernetes and a development environment; there are several others&#13;
that you can install depending on your choice of programming environment&#13;
and style (<code>vi</code>, <code>emacs</code>, etc.).</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up a Development Environment Best Practices" data-type="sect1"><div class="sect1" id="id188">&#13;
<h1>Setting Up a Development Environment Best Practices</h1>&#13;
&#13;
<p>Setting up <a data-primary="development clusters" data-secondary="best practices" data-type="indexterm" id="dev-cluster-best-practice"/><a data-primary="best practices" data-secondary="development clusters" data-type="indexterm" id="best-practice-dev-cluster"/>development workflows on Kubernetes is key to productivity and is pivotal for productive and happy development teams. Following these best practices will help to ensure that developers are up and running quickly:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Think about developer experience in three phases: onboarding, developing, and testing. Make sure that the development environment you build supports all&#13;
three of these phases.</p>&#13;
</li>&#13;
<li>&#13;
<p>When building a development cluster, you can choose between one large cluster&#13;
and a cluster per developer. There are pros and cons to each, but generally&#13;
a single large cluster is a better approach.</p>&#13;
</li>&#13;
<li>&#13;
<p>When you add users to a cluster, add them with their own identity and access&#13;
to their own namespace. Use resource limits to restrict how much of the&#13;
cluster they can use.</p>&#13;
</li>&#13;
<li>&#13;
<p>When managing namespaces, think about how you can reap old, unused resources.&#13;
Developers will have bad hygiene about deleting unused things. Use automation&#13;
to clean it up for them.</p>&#13;
</li>&#13;
<li>&#13;
<p>Think about cluster-level services like logs and monitoring that you can&#13;
set up for all users. Sometimes, cluster-level dependencies like databases&#13;
are also useful to set up on behalf of all users using templates like<a data-primary="development clusters" data-secondary="best practices" data-startref="dev-cluster-best-practice" data-type="indexterm" id="id524"/><a data-primary="best practices" data-secondary="development clusters" data-startref="best-practice-dev-cluster" data-type="indexterm" id="id525"/> Helm&#13;
charts.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id346">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We’ve reached a place where creating a Kubernetes cluster, especially in&#13;
the cloud, is a relatively straightforward exercise, but enabling&#13;
developers to productively use such a cluster is significantly less&#13;
obvious and easy. When thinking about enabling developers to successfully&#13;
build applications on Kubernetes, it’s important to think about the&#13;
key goals around onboarding, iterating, testing, and debugging applications.&#13;
Likewise, it pays to invest in some basic tooling specific to user onboarding,&#13;
namespace provisioning, and cluster services like basic log aggregation.&#13;
Viewing a development cluster and your code repositories as an opportunity&#13;
to standardize and apply best practices will ensure that you have happy&#13;
and productive developers successfully building code to deploy to your&#13;
production Kubernetes clusters.</p>&#13;
</div></section>&#13;
</div></section></body></html>