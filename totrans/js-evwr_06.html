<html><head></head><body><section data-pdf-bookmark="Chapter 5. Database" data-type="chapter" epub:type="chapter"><div class="chapter" id="database">&#13;
<h1><span class="label">Chapter 5. </span>Database</h1>&#13;
&#13;
&#13;
<p><a data-primary="database" data-type="indexterm" id="ix_ch05-asciidoc0"/>When<a data-primary="database" data-secondary="about" data-type="indexterm" id="idm45339509760120"/> I was a kid, I obsessively collected sports cards of all types. A&#13;
big part of collecting the cards was organizing them. I kept the star&#13;
players in one box, basketball superstar Michael Jordan had an entire box dedicated to his cards, and the rest of my cards were kept organized by sport, and suborganized by team. This organization method enabled me to store the&#13;
cards safely and easily find the card that I was looking for at any&#13;
given time. Little did I know, but a storage system like this is the&#13;
tangible equivalent to a database. At its core, a database allows us to&#13;
store information and retrieve it later.</p>&#13;
&#13;
<p>When I first started out with web development, I found databases&#13;
intimidating. I would see instructions for running a database and&#13;
entering obscure SQL commands, and it felt like an additional level of&#13;
abstraction that I couldn’t wrap my head around. Thankfully, I was eventually able to scale the wall and am no longer intimidated by a SQL table join, so if you are where I was, I want you to know that it is possible to navigate the world of databases.</p>&#13;
&#13;
<p>In this book we’ll be using <a href="https://www.mongodb.com">MongoDB</a> as our&#13;
database of choice. I’ve chosen Mongo because it is a popular choice in&#13;
the Node.js ecosystem and is a great database to get&#13;
started with for anyone who is new to the topic. Mongo stores our data&#13;
in “documents” that work like JavaScript objects. This means that we&#13;
will be able to write and retrieve information in a format that is&#13;
familiar to any JavaScript developer. However, if you have a database&#13;
that you strongly prefer, such as PostgreSQL, the topics covered in this&#13;
book are transferable to any type of system with a little work.</p>&#13;
&#13;
<p>Before we can work with Mongo, we will need to ensure that the MongoDB&#13;
server is running locally. This is something that is required&#13;
throughout development. To do so, follow the instructions for your system in <a data-type="xref" href="ch01.html#our-dev-environment">Chapter 1</a>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Getting Started with MongoDB" data-type="sect1"><div class="sect1" id="idm45339509726600">&#13;
<h1>Getting Started with MongoDB</h1>&#13;
&#13;
<p><a data-primary="database" data-secondary="MongoDB" data-type="indexterm" id="ix_ch05-asciidoc1"/><a data-primary="MongoDB" data-type="indexterm" id="ix_ch05-asciidoc2"/>With<a data-primary="MongoDB" data-secondary="getting started with" data-type="indexterm" id="idm45339509722392"/> Mongo running, let’s explore how we can interact with Mongo directly from our terminal, using the Mongo shell. Begin by opening the MongoDB shell by typing the<a data-primary="mongo command" data-type="indexterm" id="idm45339509721112"/> <code>mongo</code> command:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>mongo</pre>&#13;
&#13;
<p>After running this command, you should see information about your MongoDB&#13;
shell, the local server connection, and some additional&#13;
information printed to the terminal. We can now interact&#13;
directly with MongoDB from within the terminal application. We can create&#13;
a database as well as switch to a new database with the<a data-primary="use command" data-type="indexterm" id="idm45339509679752"/> <code>use</code> command.&#13;
Let’s create a database called <code>learning</code>:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>use learning</pre>&#13;
&#13;
<p>In my card collection, described at the beginning of the chapter, I kept&#13;
my cards organized in separate boxes. MongoDB brings with it the same&#13;
concept, called <a data-primary="collections, defined" data-type="indexterm" id="idm45339509699096"/><em>collections</em>. A collection is how we group&#13;
similar documents together. For example, a blog application may have a&#13;
collection for posts, another for users, and a third for comments. If we&#13;
were to compare a collection to a JavaScript object, it would be the top-level object, while documents are the individual objects within. We can&#13;
visualize it like so:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">collection</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nb">document</code><code class="o">:</code> <code class="p">{},</code>&#13;
  <code class="nb">document</code><code class="o">:</code> <code class="p">{},</code>&#13;
  <code class="nb">document</code><code class="o">:</code> <code class="p">{}.</code>&#13;
  <code class="p">...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this information in hand, let’s create a document within a&#13;
collection in our <code>learning</code> database. We’ll create a <code>pizza</code> collection&#13;
where we will store documents with a pizza type. Enter the following into the MongoDB shell:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>db.pizza.save<code class="o">({</code> <code class="nb">type</code>: <code class="s2">"Cheese"</code> <code class="o">})</code></pre>&#13;
&#13;
<p>If this is successful, we should see a returned result that reads:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">WriteResult<code class="o">({</code> <code class="s2">"nInserted"</code> : <code class="m">1</code> <code class="o">})</code></pre>&#13;
&#13;
<p>We can also write multiple entries into the database at once:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">$</code> <code class="nx">db</code><code class="p">.</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">save</code><code class="p">([{</code><code class="nx">type</code><code class="o">:</code> <code class="s2">"Veggie"</code><code class="p">},</code> <code class="p">{</code><code class="nx">type</code><code class="o">:</code> <code class="s2">"Olive"</code><code class="p">}])</code></pre>&#13;
&#13;
<p>Now that we’ve written some documents to our database, let’s retrieve&#13;
them. To do so, we’ll use MongoDB’s <code>find</code> method. To see&#13;
all of the documents in the collection, run a <a data-primary="find command" data-type="indexterm" id="idm45339509634264"/><code>find</code> command with empty parameters:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">$</code> <code class="nx">db</code><code class="p">.</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">find</code><code class="p">()</code></pre>&#13;
&#13;
<p>We should now see all three entries in the database. In addition to&#13;
storing the data, MongoDB automatically assigns a unique ID to each&#13;
entry. The results should look something like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"5c7528b223ab40938c7dc536"</code><code class="p">),</code> <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Cheese"</code> <code class="p">}</code>&#13;
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"5c7529fa23ab40938c7dc53e"</code><code class="p">),</code> <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Veggie"</code> <code class="p">}</code>&#13;
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"5c7529fa23ab40938c7dc53f"</code><code class="p">),</code> <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Olive"</code> <code class="p">}</code></pre>&#13;
&#13;
<p>We can also find individual documents, both by property values as well&#13;
as with Mongo’s assigned ID:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">$</code> <code class="nx">db</code><code class="p">.</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"Cheese"</code> <code class="p">})</code>&#13;
<code class="nx">$</code> <code class="nx">db</code><code class="p">.</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code> <code class="nx">_id</code><code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"A DOCUMENT ID HERE"</code><code class="p">)</code> <code class="p">})</code></pre>&#13;
&#13;
<p>Not only do we want to be able to find documents, but it’s also useful&#13;
to be able to update them. We can do so by using Mongo’s <code>update</code>&#13;
method, which accepts a first parameter of a document to change and a&#13;
second parameter of the change to the document. Let’s update our&#13;
<code>Veggie</code> pizza to be a <code>Mushroom</code> pizza:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">$</code> <code class="nx">db</code><code class="p">.</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">update</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"Veggie"</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"Mushroom"</code> <code class="p">})</code></pre>&#13;
&#13;
<p>Now, if we run <a data-primary="find command" data-type="indexterm" id="idm45339509347736"/><code>db.pizza.find()</code>, we should see that your document&#13;
has been <span class="keep-together">updated:</span></p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"5c7528b223ab40938c7dc536"</code><code class="p">),</code> <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Cheese"</code> <code class="p">}</code>&#13;
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"5c7529fa23ab40938c7dc53e"</code><code class="p">),</code> <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Mushroom"</code> <code class="p">}</code>&#13;
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"5c7529fa23ab40938c7dc53f"</code><code class="p">),</code> <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Olive"</code> <code class="p">}</code></pre>&#13;
&#13;
<p>As with updating a document, we can also remove one using Mongo’s&#13;
<code>remove</code> method. Let’s remove the mushroom pizza from our&#13;
database:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">$</code> <code class="nx">db</code><code class="p">.</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">remove</code><code class="p">({</code> <code class="nx">type</code><code class="o">:</code> <code class="s2">"Mushroom"</code> <code class="p">})</code></pre>&#13;
&#13;
<p>Now if we perform a <code>db.pizza.find()</code> query, we will see only two&#13;
entries within our collection. If we decided that we no longer wanted to&#13;
include any of the data, we could run the <code>remove</code> method without an empty&#13;
object parameter, which will wipe out our entire collection:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">$</code> <code class="nx">db</code><code class="p">.</code><code class="nx">pizza</code><code class="p">.</code><code class="nx">remove</code><code class="p">({})</code></pre>&#13;
&#13;
<p>We’ve now successfully used the MongoDB shell to create a database, add&#13;
documents to a collection, update those documents, and remove them.&#13;
These fundamental database operations will provide a solid&#13;
footing as we integrate a database into our project. In development, we&#13;
can also access our database using the MongoDB shell. This can prove&#13;
helpful for tasks such as debugging and manually removing or updating&#13;
entries.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Connecting MongoDB to Our Application" data-type="sect1"><div class="sect1" id="connecting-mongo-to-our-application.">&#13;
<h1>Connecting MongoDB to Our Application</h1>&#13;
&#13;
<p><a data-primary="MongoDB" data-secondary="connecting" data-type="indexterm" id="ix_ch05-asciidoc3"/>Now that you’ve learned a bit about using MongoDB from the shell, let’s&#13;
connect it to our API application. To do this, we’ll be using the<a data-primary="Mongoose Object Document Mapper (ODM)" data-type="indexterm" id="idm45339509239336"/><a data-primary="ODM (Mongoose Object Document Mapper)" data-type="indexterm" id="idm45339509238696"/>&#13;
<a href="https://mongoosejs.com">Mongoose Object Document Mapper (ODM)</a>. Mongoose&#13;
is a library that simplifies working with MongoDB in Node.js&#13;
applications by reducing and streamlining boilerplate code, through the&#13;
use of its schema-based modeling solution. Yes, you read that right—another schema! As you’ll see, once we’ve defined our database schema,&#13;
working with MongoDB via Mongoose is similar to the types of&#13;
commands we wrote within the Mongo shell.</p>&#13;
&#13;
<p>We will first need to update our <em>.env</em> file with the URL of our local&#13;
database. This will allow us to set the database URL in whatever&#13;
environment we are working (such as local development and production).&#13;
The default URL of a local MongoDB server is&#13;
<em>mongodb://localhost:27017</em>, to which we’ll add the name of&#13;
our database. So, within our <em>.env</em> file, we will set a <code>DB_HOST</code> variable&#13;
with the URL of our Mongo database instance as follows:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">DB_HOST</code><code class="o">=</code>mongodb://localhost:27017/notedly</pre>&#13;
&#13;
<p>The next step in working with a database in our application is to&#13;
connect to it. Let’s write some code that will connect our&#13;
application to our database at startup. To do this, we’ll first create&#13;
a new file within the <em>src</em> directory, named <em>db.js</em>. Within <em>db.js</em>&#13;
we’ll write our database connection code. We’ll also include a function&#13;
to <code>close</code> our database connection, which will prove useful for testing&#13;
the application.</p>&#13;
&#13;
<p>In <em>src/db.js</em>, enter the following:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Require the mongoose library</code>&#13;
<code class="kr">const</code> <code class="nx">mongoose</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'mongoose'</code><code class="p">);</code>&#13;
&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">connect</code><code class="o">:</code> <code class="nx">DB_HOST</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="c1">// Use the Mongo driver's updated URL string parser</code>&#13;
    <code class="nx">mongoose</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'useNewUrlParser'</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code>&#13;
    <code class="c1">// Use findOneAndUpdate() in place of findAndModify()</code>&#13;
    <code class="nx">mongoose</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'useFindAndModify'</code><code class="p">,</code> <code class="kc">false</code><code class="p">);</code>&#13;
    <code class="c1">// Use createIndex() in place of ensureIndex()</code>&#13;
    <code class="nx">mongoose</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'useCreateIndex'</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code>&#13;
    <code class="c1">// Use the new server discovery and monitoring engine</code>&#13;
    <code class="nx">mongoose</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="s1">'useUnifiedTopology'</code><code class="p">,</code> <code class="kc">true</code><code class="p">);</code>&#13;
    <code class="c1">// Connect to the DB</code>&#13;
    <code class="nx">mongoose</code><code class="p">.</code><code class="nx">connect</code><code class="p">(</code><code class="nx">DB_HOST</code><code class="p">);</code>&#13;
    <code class="c1">// Log an error if we fail to connect</code>&#13;
    <code class="nx">mongoose</code><code class="p">.</code><code class="nx">connection</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s1">'error'</code><code class="p">,</code> <code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>&#13;
        <code class="s1">'MongoDB connection error. Please make sure MongoDB is running.'</code>&#13;
      <code class="p">);</code>&#13;
      <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">();</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">},</code>&#13;
&#13;
  <code class="nx">close</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">mongoose</code><code class="p">.</code><code class="nx">connection</code><code class="p">.</code><code class="nx">close</code><code class="p">();</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Now we’ll update our <em>src/index.js</em> to call this connection. To do so,&#13;
we will first import our <em>.env</em> configuration as well as the <em>db.js</em>&#13;
file. Within the imports, at the top of the file, add these&#13;
imports:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">require</code><code class="p">(</code><code class="s1">'dotenv'</code><code class="p">).</code><code class="nx">config</code><code class="p">();</code>&#13;
<code class="kr">const</code> <code class="nx">db</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./db'</code><code class="p">);</code></pre>&#13;
&#13;
<p>I like to store the <code>DB_HOST</code> value that is defined in the <em>.env</em>&#13;
file as a variable. Add this variable directly below the <code>port</code>&#13;
variable definition:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">DB_HOST</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">DB_HOST</code><code class="p">;</code></pre>&#13;
&#13;
<p>We can then call our connection, by adding the following to the&#13;
<em>src/index.js</em> file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">db</code><code class="p">.</code><code class="nx">connect</code><code class="p">(</code><code class="nx">DB_HOST</code><code class="p">);</code></pre>&#13;
&#13;
<p>The <em>src/index.js</em> file will now read as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">ApolloServer</code><code class="p">,</code> <code class="nx">gql</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code>&#13;
<code class="nx">require</code><code class="p">(</code><code class="s1">'dotenv'</code><code class="p">).</code><code class="nx">config</code><code class="p">();</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">db</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./db'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Run the server on a port specified in our .env file or port 4000</code>&#13;
<code class="kr">const</code> <code class="nx">port</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">4000</code><code class="p">;</code>&#13;
<code class="c1">// Store the DB_HOST value as a variable</code>&#13;
<code class="kr">const</code> <code class="nx">DB_HOST</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">DB_HOST</code><code class="p">;</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">notes</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'1'</code><code class="p">,</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="s1">'This is a note'</code><code class="p">,</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'2'</code><code class="p">,</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="s1">'This is another note'</code><code class="p">,</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="s1">'Harlow Everly'</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'3'</code><code class="p">,</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="s1">'Oh hey look, another note!'</code><code class="p">,</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="s1">'Riley Harrison'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">];</code>&#13;
&#13;
<code class="c1">// Construct a schema, using GraphQL's schema language</code>&#13;
<code class="kr">const</code> <code class="nx">typeDefs</code> <code class="o">=</code> <code class="nx">gql</code><code class="sb">`</code>&#13;
<code class="sb">  type Note {</code>&#13;
<code class="sb">    id: ID</code>&#13;
<code class="sb">    content: String</code>&#13;
<code class="sb">    author: String</code>&#13;
<code class="sb">  }</code>&#13;
&#13;
<code class="sb">  type Query {</code>&#13;
<code class="sb">    hello: String</code>&#13;
<code class="sb">    notes: [Note]</code>&#13;
<code class="sb">    note(id: ID): Note</code>&#13;
<code class="sb">  }</code>&#13;
&#13;
<code class="sb">  type Mutation {</code>&#13;
<code class="sb">    newNote(content: String!): Note</code>&#13;
<code class="sb">  }</code>&#13;
<code class="sb">`</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Provide resolver functions for our schema fields</code>&#13;
<code class="kr">const</code> <code class="nx">resolvers</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'Hello world!'</code><code class="p">,</code>&#13;
    <code class="nx">notes</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">notes</code><code class="p">,</code>&#13;
    <code class="nx">note</code><code class="o">:</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">notes</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">note</code> <code class="o">=&gt;</code> <code class="nx">note</code><code class="p">.</code><code class="nx">id</code> <code class="o">===</code> <code class="nx">args</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">Mutation</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">newNote</code><code class="o">:</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="kd">let</code> <code class="nx">noteValue</code> <code class="o">=</code> <code class="p">{</code>&#13;
        <code class="nx">id</code><code class="o">:</code> <code class="nx">notes</code><code class="p">.</code><code class="nx">length</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code>&#13;
        <code class="nx">content</code><code class="o">:</code> <code class="nx">args</code><code class="p">.</code><code class="nx">content</code><code class="p">,</code>&#13;
        <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code>&#13;
      <code class="p">};</code>&#13;
      <code class="nx">notes</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">noteValue</code><code class="p">);</code>&#13;
      <code class="k">return</code> <code class="nx">noteValue</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Connect to the database</code>&#13;
<code class="nx">db</code><code class="p">.</code><code class="nx">connect</code><code class="p">(</code><code class="nx">DB_HOST</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Apollo Server setup</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code> <code class="nx">typeDefs</code><code class="p">,</code> <code class="nx">resolvers</code> <code class="p">});</code>&#13;
&#13;
<code class="c1">// Apply the Apollo GraphQL middleware and set the path to /api</code>&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">applyMiddleware</code><code class="p">({</code> <code class="nx">app</code><code class="p">,</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'/api'</code> <code class="p">});</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">({</code> <code class="nx">port</code> <code class="p">},</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>&#13;
    <code class="sb">`GraphQL Server running at http://localhost:</code><code class="si">${</code><code class="nx">port</code><code class="si">}${</code><code class="nx">server</code><code class="p">.</code><code class="nx">graphqlPath</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>Though the actual functionality has not changed, if you run&#13;
<code>npm run dev</code>, the application should successfully connect to the&#13;
database and run without errors<a data-startref="ix_ch05-asciidoc3" data-type="indexterm" id="idm45339508947656"/>.<a data-startref="ix_ch05-asciidoc2" data-type="indexterm" id="idm45339508947032"/><a data-startref="ix_ch05-asciidoc1" data-type="indexterm" id="idm45339508946360"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reading and Writing Data from Our Application" data-type="sect1"><div class="sect1" id="reading-and-writing-data-from-our-application">&#13;
<h1>Reading and Writing Data from Our Application</h1>&#13;
&#13;
<p><a data-primary="database" data-secondary="reading/writing data from application" data-type="indexterm" id="ix_ch05-asciidoc4"/>Now that we can connect to our database, let’s write the code&#13;
needed to read and write data to it from within the application.&#13;
Mongoose allows us to define how the data will be stored in our database&#13;
as a JavaScript object, and we can then store and act upon data that fits&#13;
that model structure. With this in mind, let’s create our object,&#13;
referred to as a <a data-primary="Mongoose schema" data-type="indexterm" id="idm45339508560136"/><a data-primary="schemas" data-secondary="Mongoose" data-type="indexterm" id="idm45339508559464"/>Mongoose schema.</p>&#13;
&#13;
<p>First, create a folder within our <em>src</em> directory called <em>models</em> to&#13;
house this schema file. In this folder, create a&#13;
file named <em>note.js</em>. Within <em>src/models/note.js</em>, we’ll start&#13;
by defining the basic setup of the file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Require the mongoose library</code>&#13;
<code class="kr">const</code> <code class="nx">mongoose</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'mongoose'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Define the note's database schema</code>&#13;
<code class="kr">const</code> <code class="nx">noteSchema</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Schema</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Define the 'Note' model with the schema</code>&#13;
<code class="kr">const</code> <code class="nx">Note</code> <code class="o">=</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">model</code><code class="p">(</code><code class="s1">'Note'</code><code class="p">,</code> <code class="nx">noteSchema</code><code class="p">);</code>&#13;
<code class="c1">// Export the module</code>&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">Note</code><code class="p">;</code></pre>&#13;
&#13;
<p>Next, we will define our schema, within the <a data-primary="noteSchema" data-type="indexterm" id="idm45339508475912"/><code>noteSchema</code> variable. Similar&#13;
to the in-memory data example, our current schema will, for now, include&#13;
the content of the note as well as a hardcoded string representing the&#13;
author. We’ll also include the option to include timestamps for our&#13;
notes, which will be automatically stored when a note is created or&#13;
edited. We’ll be adding functionality to our note schema as&#13;
we go.</p>&#13;
&#13;
<p>Our Mongoose schema will be structured as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Define the note's database schema</code>&#13;
<code class="kr">const</code> <code class="nx">noteSchema</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Schema</code><code class="p">(</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="c1">// Assigns createdAt and updatedAt fields with a Date type</code>&#13;
    <code class="nx">timestamps</code><code class="o">:</code> <code class="kc">true</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">);</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h1>Data Permanence</h1>&#13;
<p>We’ll be updating and changing our data model throughout development,&#13;
at times removing all of the data from our database. As a result, I&#13;
wouldn’t recommend using this API to store important things like class&#13;
notes, a list of your friends’ birthdays, or the directions to your&#13;
favorite pizza place.</p>&#13;
</div>&#13;
&#13;
<p>Our overall <em>src/models/note.js</em> file should now read as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// Require the mongoose library</code>&#13;
<code class="kr">const</code> <code class="nx">mongoose</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'mongoose'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Define the note's database schema</code>&#13;
<code class="kr">const</code> <code class="nx">noteSchema</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">Schema</code><code class="p">(</code>&#13;
  <code class="p">{</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>&#13;
      <code class="nx">type</code><code class="o">:</code> <code class="nb">String</code><code class="p">,</code>&#13;
      <code class="nx">required</code><code class="o">:</code> <code class="kc">true</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">},</code>&#13;
  <code class="p">{</code>&#13;
    <code class="c1">// Assigns createdAt and updatedAt fields with a Date type</code>&#13;
    <code class="nx">timestamps</code><code class="o">:</code> <code class="kc">true</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">);</code>&#13;
&#13;
<code class="c1">// Define the 'Note' model with the schema</code>&#13;
<code class="kr">const</code> <code class="nx">Note</code> <code class="o">=</code> <code class="nx">mongoose</code><code class="p">.</code><code class="nx">model</code><code class="p">(</code><code class="s1">'Note'</code><code class="p">,</code> <code class="nx">noteSchema</code><code class="p">);</code>&#13;
<code class="c1">// Export the module</code>&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">Note</code><code class="p">;</code></pre>&#13;
&#13;
<p class="pagebreak-before">To simplify importing our models into our Apollo Server Express&#13;
application, we’ll add an <em>index.js</em> file to the <em>src/models</em> directory. This will combine our models into a single JavaScript module. While this isn’t strictly necessary, I find it to be a good pattern to follow as applications and database models grow. In <em>src/models/index.js</em> we’ll import our note model and&#13;
add it to a <code>models</code> object to be exported:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">Note</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./note'</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">models</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Note</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">models</code><code class="p">;</code></pre>&#13;
&#13;
<p>We can now incorporate our database models into our Apollo Server&#13;
Express application code by importing our models into the <em>src/index.js</em>&#13;
file:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">models</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./models'</code><code class="p">);</code></pre>&#13;
&#13;
<p>With our database model code imported, we can adapt our resolvers to&#13;
save and read from the database, rather than an in-memory variable. To&#13;
do this, we’ll rewrite the <code>notes</code> query to pull the notes from the&#13;
database by using the <a data-primary="find()" data-type="indexterm" id="idm45339508234056"/>MongoDB <code>find</code> method:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">notes</code><code class="o">:</code> <code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">find</code><code class="p">();</code>&#13;
<code class="p">},</code></pre>&#13;
&#13;
<p>With our server running, we can visit the GraphQL Playground in our&#13;
browser and run our <code>notes</code> query:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">notes</code> <code class="p">{</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">author</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The expected result will be an empty array, since we have yet to add any data to our database (<a data-type="xref" href="#db-notes-query">Figure 5-1</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="s2">"data"</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="s2">"notes"</code><code class="o">:</code> <code class="p">[]</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="db-notes-query">&#13;
<img alt="A notes query in the GraphQL Playground" src="assets/jsev_0501.png"/>&#13;
<h6><span class="label">Figure 5-1. </span>A notes query</h6>&#13;
</div></figure>&#13;
&#13;
<p>To update our <code>newNote</code> mutation to add a note to our database, we’ll&#13;
use our <a data-primary="create()" data-type="indexterm" id="idm45339508109640"/>MongoDB model’s <code>create</code> method, which we’ll accept an object.&#13;
For now, we will continue to hardcode the author’s name:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">newNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">create</code><code class="p">({</code>&#13;
    <code class="nx">content</code><code class="o">:</code> <code class="nx">args</code><code class="p">.</code><code class="nx">content</code><code class="p">,</code>&#13;
    <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can now visit the GraphQL Playground and write a mutation that will&#13;
add a note to our database:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">mutation</code> <code class="p">{</code>&#13;
  <code class="nx">newNote</code> <code class="p">(</code><code class="nx">content</code><code class="o">:</code> <code class="s2">"This is a note in our database!"</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="nx">content</code>&#13;
   <code class="nx">author</code>&#13;
   <code class="nx">id</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">Our mutation will return a new note, which contains the content we&#13;
placed in our argument, the author’s name, as well as a MongoDB-generated ID (<a data-type="xref" href="#db-new-note-mutation">Figure 5-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="db-new-note-mutation">&#13;
<img alt="A new note mutation in the GraphQL Playground" src="assets/jsev_0502.png"/>&#13;
<h6><span class="label">Figure 5-2. </span>A mutation creates a new note in the database</h6>&#13;
</div></figure>&#13;
&#13;
<p>If we now rerun our <code>notes</code> query, we should see our note retrieved from&#13;
the database! (See <a data-type="xref" href="#db-notes-query-2">Figure 5-3</a>.)</p>&#13;
&#13;
<figure><div class="figure" id="db-notes-query-2">&#13;
<img alt="The notes query with data in the GraphQLPlayground" src="assets/jsev_0503.png"/>&#13;
<h6><span class="label">Figure 5-3. </span>Our notes query returns the data from the database</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">The last step is to rewrite our <code>note</code>s query to pull a specific note&#13;
from our database, using the unique ID that MongoDB assigns to each&#13;
entry. To do so, we’ll use Mongoose’s <code>findbyId</code> method:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">note</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can now write a query, using the unique ID we see in our <code>notes</code>&#13;
query or <code>newNote</code> mutation, to retrieve an individual note from our&#13;
database. To do so, we’ll write a <code>note</code> query with an <code>id</code> argument (<a data-type="xref" href="#db-note-query">Figure 5-4</a>):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">query</code> <code class="p">{</code>&#13;
  <code class="nx">note</code><code class="p">(</code><code class="nx">id</code><code class="o">:</code> <code class="s2">"5c7bff794d66461e1e970ed3"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">id</code>&#13;
    <code class="nx">content</code>&#13;
    <code class="nx">author</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="caution"><h1>Your Note ID</h1>&#13;
<p>The ID used in the previous example is unique to my local database. Be sure to copy an ID from your own query or mutation results.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="db-note-query">&#13;
<img alt="A query for an individual note in the GraphQL Playground" src="assets/jsev_0504.png"/>&#13;
<h6><span class="label">Figure 5-4. </span>A query for an individual note</h6>&#13;
</div></figure>&#13;
&#13;
<p>Our final <em>src/index.js</em> file will look as follows:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'express'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="p">{</code> <code class="nx">ApolloServer</code><code class="p">,</code> <code class="nx">gql</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'apollo-server-express'</code><code class="p">);</code>&#13;
<code class="nx">require</code><code class="p">(</code><code class="s1">'dotenv'</code><code class="p">).</code><code class="nx">config</code><code class="p">();</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">db</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./db'</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">models</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./models'</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Run our server on a port specified in our .env file or port 4000</code>&#13;
<code class="kr">const</code> <code class="nx">port</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">4000</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">DB_HOST</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">DB_HOST</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Construct a schema, using GraphQL's schema language</code>&#13;
<code class="kr">const</code> <code class="nx">typeDefs</code> <code class="o">=</code> <code class="nx">gql</code><code class="sb">`</code>&#13;
<code class="sb">  type Note {</code>&#13;
<code class="sb">    id: ID</code>&#13;
<code class="sb">    content: String</code>&#13;
<code class="sb">    author: String</code>&#13;
<code class="sb">  }</code>&#13;
&#13;
<code class="sb">  type Query {</code>&#13;
<code class="sb">    hello: String</code>&#13;
<code class="sb">    notes: [Note]</code>&#13;
<code class="sb">    note(id: ID): Note</code>&#13;
<code class="sb">  }</code>&#13;
&#13;
<code class="sb">  type Mutation {</code>&#13;
<code class="sb">    newNote(content: String!): Note</code>&#13;
<code class="sb">  }</code>&#13;
<code class="sb">`</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Provide resolver functions for our schema fields</code>&#13;
<code class="kr">const</code> <code class="nx">resolvers</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">Query</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">hello</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s1">'Hello world!'</code><code class="p">,</code>&#13;
    <code class="nx">notes</code><code class="o">:</code> <code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">find</code><code class="p">();</code>&#13;
    <code class="p">},</code>&#13;
    <code class="nx">note</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">findById</code><code class="p">(</code><code class="nx">args</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">},</code>&#13;
  <code class="nx">Mutation</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">newNote</code><code class="o">:</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">parent</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="nx">await</code> <code class="nx">models</code><code class="p">.</code><code class="nx">Note</code><code class="p">.</code><code class="nx">create</code><code class="p">({</code>&#13;
        <code class="nx">content</code><code class="o">:</code> <code class="nx">args</code><code class="p">.</code><code class="nx">content</code><code class="p">,</code>&#13;
        <code class="nx">author</code><code class="o">:</code> <code class="s1">'Adam Scott'</code>&#13;
      <code class="p">});</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>&#13;
&#13;
<code class="nx">db</code><code class="p">.</code><code class="nx">connect</code><code class="p">(</code><code class="nx">DB_HOST</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Apollo Server setup</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ApolloServer</code><code class="p">({</code> <code class="nx">typeDefs</code><code class="p">,</code> <code class="nx">resolvers</code> <code class="p">});</code>&#13;
&#13;
<code class="c1">// Apply the Apollo GraphQL middleware and set the path to /api</code>&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">applyMiddleware</code><code class="p">({</code> <code class="nx">app</code><code class="p">,</code> <code class="nx">path</code><code class="o">:</code> <code class="s1">'/api'</code> <code class="p">});</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">({</code> <code class="nx">port</code> <code class="p">},</code> <code class="p">()</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>&#13;
    <code class="sb">`GraphQL Server running at http://localhost:</code><code class="si">${</code><code class="nx">port</code><code class="si">}${</code><code class="nx">server</code><code class="p">.</code><code class="nx">graphqlPath</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>We can now read and write data from our database with our GraphQL API!&#13;
Try adding more notes, viewing the full list of notes using the <code>notes</code>&#13;
query, and viewing the content of individual notes by utilizing the&#13;
<code>note</code> query.<a data-startref="ix_ch05-asciidoc4" data-type="indexterm" id="idm45339507882392"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339508944776">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>In this chapter you learned to use MongoDB and the Mongoose library with our API. A database, such as MongoDB, allows us to securely store and retrieve our application’s data. An object modeling library, such as Mongoose, simplifies working with a database by providing tools for database queries and data validation. In the next chapter, we’ll update our API to have full CRUD (create, read, update, and delete) functionality with our database content.<a data-startref="ix_ch05-asciidoc0" data-type="indexterm" id="idm45339507880456"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>