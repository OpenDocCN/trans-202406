- en: Chapter 14\. Syntax Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: “TypeScript does not add
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: to the JavaScript runtime.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: …was that all a lie?!
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: When TypeScript was first released in 2012, web applications were growing in
    complexity faster than plain JavaScript was adding features that supported the
    deep complexity. The most popular JavaScript language flavor at the time, CoffeeScript,
    had made its mark diverging from JavaScript by introducing new and exciting syntactic
    constructs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, extending JavaScript syntax with new runtime features specific to
    a superset language such as TypeScript is considered bad practice for several
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, runtime syntax extensions might conflict with new syntax in
    newer versions of JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They make it more difficult for programmers new to the language to understand
    where JavaScript ends and other languages begin.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They increase complexity of transpilers that take superset language code and
    emit JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, it is with a heavy heart and deep regret that I must inform you that
    the early TypeScript designers introduced three syntax extensions to JavaScript
    in the TypeScript language:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes, which aligned with JavaScript classes as the spec was ratified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enums, a straightforward syntactic sugar akin to a plain object of keys and
    values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces, a solution predating modern modules to structure and arrange code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TypeScript’s “original sin” of runtime syntax extensions to JavaScript is fortunately
    not a design decision the language has made since its early years. TypeScript
    does not add new runtime syntax constructs until they have made significant progress
    through the ratification process to be added to JavaScript itself.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript classes ended up looking and behaving almost identical to JavaScript
    classes (phew!) with the exception of `useDefineForClassFields` behavior (a configuration
    option not covered in this book) and parameter properties (covered here). Enums
    are still used in some projects because they are occasionally useful. Virtually
    no new projects use namespaces anymore.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript also adopted an experimental proposal for JavaScript “decorators”
    that I’ll cover as well.
  prefs: []
  type: TYPE_NORMAL
- en: Class Parameter Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I recommend avoiding using class parameter properties unless you’re working
    in a project that heavily uses classes or a framework that would benefit from
    them.
  prefs: []
  type: TYPE_NORMAL
- en: It is common in JavaScript classes to want to take in a parameter in a constructor
    and immediately assign it to a class property.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Engineer` class takes in a single `area` parameter of type `string` and
    assigns it to an `area` property of type `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript includes a shorthand syntax for declaring these kinds of “parameter
    properties”: properties that are assigned to a member property of the same type
    at the beginning of a class constructor. Placing `readonly` and/or one of the
    privacy modifiers—`public`, `protected`, or `private`—in front of the parameter
    to a constructor indicates to TypeScript to also declare a property of that same
    name and type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous `Engineer` example could be rewritten in TypeScript using a parameter
    property for `area`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Parameter properties are assigned at the very beginning of the class constructor
    (or after the `super()` call if the class is derived from a base class). They
    can be intermixed with other parameters and/or properties on a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `NamedEngineer` class declares a regular property `fullName`,
    a regular parameter `name`, and a parameter property `area`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Its equivalent TypeScript without parameter properties looks similar, but with
    a couple more lines of code to explicitly assign `area`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Parameter properties are a sometimes-debated issue in the TypeScript community.
    Most projects prefer to avoid them categorically, as they’re a runtime syntax
    extension and therefore suffer from the same drawbacks I mentioned earlier. They
    also can’t be used with the newer `#` class private fields syntax.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, they’re quite nice when used in projects that heavily favor
    creating classes. Parameter properties solve a convenience issue of needing to
    declare the parameter property name and type twice, which is inherent to TypeScript
    and not JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Experimental Decorators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I recommend avoiding decorators if at all possible until a version of ECMAScript
    is ratified with decorator syntax. If you’re working in a version of a framework
    such as Angular or NestJS that recommends using TypeScript decorators, the framework’s
    documentation will guide how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Many other languages that contain classes allow annotating, or decorating, those
    classes and/or their members with some kind of runtime logic to modify them. *Decorator*
    functions are a proposal for JavaScript to allow annotating classes and members
    by placing a `@` and the name of a function first.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code snippet shows just the syntax for using a decorator
    on a class `MyClass`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Decorators have not yet been ratified in ECMAScript, so TypeScript does not
    support them by default as of version 4.7.2. However, TypeScript does include
    an `experimentalDecorators` compiler option that allows for an old experimental
    version of them to be used in code. It can be enabled via the `tsc` CLI or in
    a TSConfig file, shown here, like other compiler options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Each usage of a decorator will execute once, as soon as the entity it’s decorating
    is created. Each kind of decorator—accessor, class, method, parameter, and property—receives
    a different set of arguments describing the entity it’s decorating.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this `logOnCall` decorator used on a `Greeter` class method receives
    the `Greeter` class itself, the key of the property (`"log"`), and a `descriptor`
    object describing the property. Modifying `descriptor.value` to log before calling
    the original `greet` method on the `Greeter` class “decorates” the `greet` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I won’t delve into the nuances and specifics of how the old `experimentalDecorators`
    works for each of the possible decorator types. TypeScript’s decorator support
    is experimental and does not align with the latest drafts of the ECMAScript proposal.
    Writing your own decorators in particular is rarely justified in any TypeScript
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Enums
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: I recommend not to use enums unless you have a set of literals that are repeated
    often, can all be described by a common name, and whose code would be much easier
    to read if switched to an enum.
  prefs: []
  type: TYPE_NORMAL
- en: Most programming languages contain the concept of an “enum,” or enumerated type,
    to represent a set of related values. Enums can be thought of as a set of literal
    values stored in an object with a friendly name for each value.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript does not include an enum syntax because traditional objects can
    be used in place of them. For example, while HTTP status codes can be stored and
    used as numbers, many developers find it more readable to store them in an object
    that keys them by their friendly name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The tricky thing with enum-like objects in TypeScript is that there isn’t a
    great type system way to represent that a value must be one of their values. One
    common method is to use the `keyof` and `typeof` type modifiers from [Chapter 9,
    “Type Modifiers”](ch09.xhtml#type_modifiers_chapter) to hack one together, but
    that’s a fair amount of syntax to type out.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `StatusCodeValue` type uses the previous `StatusCodes` value
    to create a type union of its possible status code number values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript provides an `enum` syntax for creating an object with literal values
    of type `number` or `string`. Start with the `enum` keyword, then a name of an
    object—conventionally in PascalCase—then an `{}` object containing comma-separated
    keys in the enum. Each key can optionally use `=` before an initial value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous `StatusCodes` object would look like this `StatusCode` enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As with class names, an enum name such as `StatusCode` can be used as the type
    name in a type annotation. Here, the `statusCode` variable of type `StatusCode`
    may be given `StatusCode.Ok` or a number value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TypeScript allows any number to be assigned to a numeric enum value as a convenience
    at the cost of a little type safety. `statusCode = -1` would have also been allowed
    in the previous code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: Enums compile down to an equivalent object in output compiled JavaScript. Each
    of their members becomes an object member key with the corresponding value, and
    vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous `enum StatusCode` would create roughly the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Enums are a mildly contentious topic in the TypeScript community. On the one
    hand, they violate TypeScript’s general mantra of never adding new runtime syntax
    constructs to JavaScript. They present a new non-JavaScript syntax for developers
    to learn and have a few quirks around options such as `preserveConstEnums`, covered
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, they’re quite useful for explicitly declaring known sets
    of values. Enums are used extensively in both the TypeScript and VS Code source
    repositories!
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Numeric Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enum members don’t need to have an explicit initial value. When values are omitted,
    TypeScript will start the first value off with `0` and increment each subsequent
    value by `1`. Allowing TypeScript to choose the values for enum members is a good
    option when the value doesn’t matter beyond being unique and associated with the
    key name.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `VisualTheme` enum allows TypeScript to choose the values entirely, resulting
    in three integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The emitted JavaScript looks the same as if the values had been set explicitly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In enums with numeric values, any members missing an explicit value will be
    `1` greater than the previous value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, a `Direction` enum might only care that its `Top` member has
    a value of `1` and the remaining values are also positive integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Its output JavaScript would also look the same as if the remaining members
    had explicit values `2`, `3`, and `4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Modifying the order of an enum will cause the underlying number to change. If
    you persist these values somewhere, such as a database, be careful of changing
    the enum order or removing an entry. Your data may suddenly be corrupt because
    the saved number will no longer represent what your code expects.
  prefs: []
  type: TYPE_NORMAL
- en: String-Valued Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enums may also use strings for their members instead of numbers.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `LoadStyle` enum uses friendly string values for its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Output JavaScript for enums with string member values looks structurally the
    same as enums with numeric member values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: String valued enums are handy for aliasing shared constants under legible names.
    Instead of using a type union of string literals, string valued enums allow for
    more powerful editor autocompletions and renames of those properties—as covered
    in [Chapter 12, “Using IDE Features”](ch12.xhtml#using_ide_features).
  prefs: []
  type: TYPE_NORMAL
- en: One downside of string member values is that they cannot be computed automatically
    by TypeScript. Only enum members that follow a member with a numeric value are
    allowed to be computed automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript would be able to provide an implicit value of `9001` in this enum’s
    `ImplicitNumber` because the previous member value is the number `9000`, but its
    `NotAllowed` member would issue an error because it follows a string member value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In theory, you could make an enum with both numeric and string member values.
    In practice, that enum would likely be unnecessarily confusing, so you probably
    shouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Const Enums
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because enums create a runtime object, using them produces more code than the
    common alternative strategy of unions of literal values. TypeScript allows declaring
    enums with the `const` modifier in front of them to tell TypeScript to omit their
    objects definition and property lookups from compiled JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `DisplayHint` enum is used as a value for a `displayHint` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The output compiled JavaScript code would be missing the enum declaration altogether
    and would use a comment for the enum’s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For projects where it’s still desirable to create enum object definitions, a
    `preserveConstEnums` compiler option does exist that would keep the enum declaration
    itself in existence. Values would still directly use literals instead of accessing
    them on the enum object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code snippet would still omit the property lookup in its compiled
    JavaScript output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`preserveConstEnums` can help reduce the size of emitted JavaScript code, though
    not all ways to transpile TypeScript code support it. See [Chapter 13, “Configuration
    Options”](ch13.xhtml#configuration_options) for more information on the `isolatedModules`
    compiler option and when `const` enums may not be supported.'
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Unless you are authoring DefinitelyTyped type definitions for an existing package,
    do not use namespaces. Namespaces do not match up to modern JavaScript module
    semantics. Their automatic member assignments can make code confusing to read.
    I only mention them because you may come across them in *.d.ts* files.
  prefs: []
  type: TYPE_NORMAL
- en: Back before ECMAScript modules were ratified, it wasn’t uncommon for web applications
    to bundle much of their output code into a single file loaded by the browser.
    Those giant single files often created global variables to hold references to
    important values across different areas of the project. It was simpler for pages
    to include that one file than to set up an old module loader such as RequireJS—and
    oftentimes more performant to load, since many servers didn’t yet support HTTP/2
    download streaming. Projects made for a single-file output needed a way to organize
    sections of code and those global variables.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript language provided one solution with the concept of “internal
    modules,” now referred to as namespaces. A *namespace* is a globally available
    object with “exported” contents available to call as members of that object. Namespaces
    are defined with the `namespace` keyword followed by a `{}` block of code. Everything
    in that namespace block is evaluated inside a function closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `Randomized` namespace creates a `value` variable and uses it internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Its output JavaScript creates a `Randomized` object and evaluates the contents
    of the block inside a function, so the `value` variable isn’t available outside
    of the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Namespaces and the `namespace` keyword were originally called “modules” and
    "`module`,” respectively, in TypeScript. That was a regrettable choice in hindsight
    given the rise of modern module loaders and ECMAScript modules. The `module` keyword
    is still occasionally found in very old projects, but can—and should—be safely
    replaced with `namespace`.
  prefs: []
  type: TYPE_NORMAL
- en: Namespace Exports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key feature of namespaces that made them useful was that a namespace could
    “export” contents by making them a member of the namespace object. Other areas
    of code can then refer to that member by name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a `Settings` namespace exports `describe`, `name`, and `version` values
    used internally and externally to the namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The output JavaScript shows that the values are always referenced as members
    of `Settings` (e.g., `Settings.name`) in both internal and external usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'By using a `var` for the output object and referencing exported contents as
    members of those objects, namespaces by design work well when split across multiple
    files. The previous `Settings` namespace could be rewritten across multiple files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output JavaScript, concatenated together, would look roughly like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In both the single-file and multiple-file declaration forms, the output object
    at runtime is one with three keys. Roughly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The key difference with using a namespace is that it can be split across different
    files and members can still refer to each other under the namespace’s name.
  prefs: []
  type: TYPE_NORMAL
- en: Nested Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Namespaces can be “nested” to indefinite levels by either exporting a namespace
    from within another namespace or putting one or more `.` periods inside a name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following two namespace declarations would behave identically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'They both compile to structurally identical code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Nested namespaces are a handy way to enforce more delineation between sections
    within larger projects organized with namespaces. Many developers opted to use
    a root namespace by the name of their project—perhaps inside a namespace for their
    company and/or organization—and child namespaces for each major area of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces in Type Definitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The only redeeming quality for namespaces today—and the only reason why I opted
    to include them in this book—is that they can be useful for DefinitelyTyped type
    definitions. Many JavaScript libraries—particularly older web application staples
    such as jQuery—are set up to be included in web browsers with a traditional, non-module
    `<script>` tag. Their typings need to indicate that they create a global variable
    available to all code—structure perfectly captured by namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, many browser-capable JavaScript libraries are set up both to be
    imported in more modern module systems and also to create a global namespace.
    TypeScript allows a module type definition to include an `export as namespace`,
    followed by a global name, to indicate the module is also available globally under
    that name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this declaration file for a module exports a `value` and is available
    globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The type system would know that both `import("my-example-lib")` and `window.libExample`
    would give back the module, with a `value` property of type `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Prefer Modules Over Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of using namespaces, the previous examples’ *settings/constants.ts*
    file and *settings/describe.ts* file could be rewritten for modern standards with
    ECMAScript modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript code structured with namespaces can’t be easily tree-shaken (have
    unused files removed) in modern builders such as Webpack because namespaces create
    implicit, rather than explicitly declared, ties between files the way ECMAScript
    modules do. It is generally strongly preferred to write runtime code using ECMAScript
    modules and not TypeScript namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of 2022, TypeScript itself is written in namespaces, but the TypeScript team
    is working on migrating over to modules. Who knows, maybe by the time you’re reading
    this, they’ll have finished that conversion! Fingers crossed.
  prefs: []
  type: TYPE_NORMAL
- en: Type-Only Imports and Exports
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’d like to end this chapter on a positive note. One last set of syntax extensions,
    type-only imports and exports, can be quite useful and don’t add any complexity
    to output emitted JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript’s transpiler will remove values used only in the type system from
    imports and exports in files because they aren’t used in runtime JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following *index.ts* file creates an `action` variable and
    an `ActivistArea` type, then later exports both of them with a standalone export
    declaration. When compiling it to *index.js*, TypeScript’s transpiler would know
    to remove `ActivistArea` from that standalone export declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Knowing to remove re-exported types such as that `ActivistArea` requires knowledge
    of the TypeScript type system. Transpilers such as Babel that act on a single
    file at a time don’t have access to the TypeScript type system to know whether
    each name is only used in the type system. TypeScript’s `isolatedModules` compiler
    option, covered in [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options),
    helps make sure code will transpile in tools other than TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript allows adding the `type` modifier in front of individual imported
    names or the entire `{...}` object in `export` and `import` declarations. Doing
    so indicates they’re only meant to be used in the type system. Marking a default
    import of a package as `type` is allowed as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following snippet, only the `value` import and export are kept when
    *index.ts* is transpiled to the output *index.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Some TypeScript developers even prefer to opt into using type-only imports to
    make it more clear which imports are only used as types. If an import is marked
    as type-only, attempting to use it as a runtime value will trigger a TypeScript
    error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `ClassOne` is imported normally and can be used at runtime, but
    `ClassTwo` cannot because it is imported as a type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Instead of adding complexity to emitted JavaScript, type-only imports and exports
    make it clear to transpilers outside of TypeScript when it’s possible to remove
    pieces of code. Most TypeScript developers therefore don’t treat them with the
    distaste given to the previous syntax extensions covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you worked with some of the JavaScript syntax extensions included
    in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring class parameter properties in class constructors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using decorators to augment classes and their fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Representing groups of values with enums
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using namespaces to create groupings across files or in type definitions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type-only imports and exports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/syntax-extensions*](https://learningtypescript.com/syntax-extensions).
  prefs: []
  type: TYPE_NORMAL
- en: What do you call the cost of supporting legacy JavaScript extensions in TypeScript?
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Sin tax.”
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
