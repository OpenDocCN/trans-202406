["```\nfunction doWork() {\n  // Get the <p> element to change\n  const statusElement = document.getElementById('status');\n\n  // Track the time and the number of passes through the loop\n  const startTime = Date.now();\n  let counter = 0;\n\n  statusElement.innerText = 'Processing started';\n\n  while ((Date.now() - startTime < 10000)) {\n    counter += 1;\n    statusElement.innerText = `Just generated number ${counter}`;\n  }\n\n  statusElement.innerText = 'Processing completed';\n}\n```", "```\nfunction doWorkInChunks() {\n   // Get the <p> element to change\n   const statusElement = document.getElementById(\"status\");\n\n   // Track the time and the number of passes through the loop\n   const startTime = Date.now();\n   let counter = 0;\n\n   statusElement.innerText = 'Processing started';\n\n   // Create an anonymous function that does one chunk of work\n   const doChunkedTask = () => {\n      if (Date.now() - startTime < 10000) {\n        counter += 1;\n        statusElement.innerText = `Just generated number ${counter}`;\n\n        // Call the function again, for the next chunk\n        setTimeout(doChunkedTask, 0);\n      }\n      else {\n        statusElement.innerText = 'Processing completed';\n     }\n   };\n\n  // Start the process by calling the function for the first time\n  doChunkedTask();\n}\n```", "```\n// Create the promise\nconst promise = fetch(\n 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Eagle_nebula_pillars.jpg');\n\n// Supply a function that logs successful requests\npromise.then( function onSuccess(response) {\n  console.log(`HTTP status: ${response.status}`);\n});\n\n// Supply a function that logs errors\npromise.catch( function onError(error) {\n  console.error(`Error: ${error}`);\n});\n\n// Supply a function that runs either way\npromise.finally( function onFinally() {\n  console.log('All done');\n});\n```", "```\nfetch(\n 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Eagle_nebula_pillars.jpg')\n.then(response => {\n  console.log(`HTTP status: ${response.status}`);\n})\n.catch(error => {\n  console.error(`Error: ${error}`);\n})\n.finally(() => {\n  console.log('All done');\n});\n```", "```\nfetch(\n 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Eagle_nebula_pillars.jpg')\n.then(response => response.blob())\n.then(blob => {\n  const img = document.getElementById('imgDownload');\n  img.src = URL.createObjectURL(blob);\n});\n```", "```\nfetch(\n 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Eagle_nebula_pillars.jpg')\n.then(response => {\n  if (!response.ok) {\n    // Ordinarily, it's not an error if the server responds to our request\n    // Now, let's treat any response other than HTTP 200 OK as an error\n    throw new Error(`HTTP code: ${response.status}`);\n  }\n  else {\n    return response.blob();\n  }\n})\n.then(blob => {\n  const img = document.getElementById('imgDownload');\n  img.src = URL.createObjectURL(blob);\n})\n.catch(error => {\n  console.log('An error occurred in the first or second promise');\n});\n```", "```\nfunction factorializeNumber(number, successCallback, failureCallback) {\n  if (number < 0) {\n    failureCallback(\n      new Error('Factorials are only defined for positive numbers'));\n  }\n  else if (number !== Math.trunc(number)) {\n    failureCallback(new Error('Factorials are only defined for integers'));\n  }\n  else {\n    setTimeout( () => {\n      if (number === 0 || number === 1) {\n        successCallback(1);\n      }\n      else {\n        let result = number;\n        while (number > 1) {\n          number -= 1;\n          result *= number;\n        }\n        successCallback(result);\n      }\n    }, 5000);  // This hard-coded 5-second delay simulates a long async process\n  }\n}\n```", "```\nfunction logResult(result) {\n  console.log(`5! = ${result}`);\n}\n\nfunction logError(error) {\n  console.log(`Error: ${error.message}`);\n}\n\nfactorializeNumber(5, logResult, logError);\n```", "```\nfunction factorializeNumberPromise(number) {\n  return new Promise((resolve, reject) => {\n    factorializeNumber(number,\n      result => {\n        resolve(result);\n      },\n      error => {\n        reject(error);\n      });\n  });\n}\n```", "```\nfactorializeNumberPromise(5)\n.then( result => {\n  console.log(`5! = ${result}`);\n});\n```", "```\nfactorializeNumberPromise('Bad value')\n.then( result => {\n  console.log(`6! = ${result}`);\n})\n.catch( error => {\n  console.log(error);\n});\n```", "```\nfunction(resolve, reject) {\n  ...\n}\n```", "```\nfunction(resolve, reject) {\n  factorializeNumber(number,\n    function successCallback(result) {\n      resolve(result);\n    },\n    ...\n  );\n}\n```", "```\nfunction(resolve, reject) {\n  factorializeNumber(number,\n    function successCallback(result) {\n      resolve(result);\n    },\n    function failureCallback(error) {\n      reject(error);\n    });\n  );\n}\n```", "```\nfunction randomWaitPromise() {\n  return new Promise((resolve, reject) => {\n    // Decide how long to wait\n    const waitMilliseconds = Math.round(Math.random() * 10000);\n\n    // Simulate an asynchronous task with setTimeout()\n    setTimeout(() => {\n      console.log(`Resolved after ${waitMilliseconds}`);\n\n      // Return the number of seconds waited\n      resolve(waitMilliseconds);\n    }, waitMilliseconds);\n  });\n}\n```", "```\n// Create three promises\nconst promise1 = randomWaitPromise();\nconst promise2 = randomWaitPromise();\nconst promise3 = randomWaitPromise();\nconst promises = [promise1, promise2, promise3];\n\n// Wait for all of them, then log the result\nPromise.all(promises).then(values => {\n  console.log(`All done with: ${values}`);\n});\n```", "```\nResolved after 790\nResolved after 4329\nResolved after 6238\nAll done with: 790,6238,4329\n```", "```\nconsole.log('taskPromise is working asynchronously');\nawait taskPromise;\nconsole.log('taskPromise has finished');\n```", "```\nconst url =\n 'https://upload.wikimedia.org/wikipedia/commons/b/b2/Eagle_nebula_pillars.jpg';\n\nfetch(url)\n.then(response => {\n  // The fetch operation has completed\n  console.log(`HTTP status: ${response.status}`);\n  console.log('All asynchronous steps completed');\n})\n```", "```\n`async` function getImage() {\n  const url =\n'https://upload.wikimedia.org/wikipedia/commons/b/b2/Eagle_nebula_pillars.jpg';\n\n  const response = `await` fetch(url);\n\n  // The fetch operation has completed and the promise is resolved or rejected\n  console.log(`HTTP status: ${response.status}`);\n}\n\ngetImage().then(() => {\n  console.log('All asynchronous steps completed');\n});\n\n```", "```\nasync function getImage() {\n  const url =\n'https://upload.wikimedia.org/wikipedia/commons/b/b2/Eagle_nebula_pillars.jpg';\n\n  try {\n    const response = await fetch(url);\n    console.log(`HTTP status: ${response.status}`);\n  }\n  catch(err) {\n    console.error(`Error: ${error}`);\n  }\n  finally {\n    console.log('All done');\n  }\n}\n```", "```\nasync function getImage() {\n  const url =\n   'https://upload.wikimedia.org/wikipedia/commons/b/b2/Eagle_nebula_pillars.jpg';\n\n  // Wait (asynchronously) for the response\n  const response = `await` fetch(url);\n\n  if (response.ok) {\n    // Wait (asynchronously) for the blob to be read\n    const blob = `await` response.blob();\n\n    // Now show the image\n    const img = document.getElementById('imgDownload');\n    img.src = URL.createObjectURL(blob);\n  }\n}\n\n```", "```\nconst response = await fetch(url);\n```", "```\nasync function getImage() {\n  ...\n}\n```", "```\n// This probably isn't right, because you're discarding the Promise object\ngetImage();\n```", "```\ngetImage()\n.then(response => {\n  console.log('Image download finished');\n})\n.catch(error => {\n  console.error(`Error: ${error}`);\n});\n```", "```\nconst step1 = await someAsyncTask();\n\nif (step1 === someResult) {\n  const step2 = await differentAsyncTask();\n  ...\n}\nelse {\n  const step2 = await anotherAsyncTask();\n  ...\n}\n```", "```\nconst response1 = await slowFunction(dataObject1);\nconst response2 = await slowFunction(dataObject2);\nconst response3 = await slowFunction(dataObject3);\n```", "```\nconst promise1 = slowFunction(dataObject1);\nconst promise2 = slowFunction(dataObject2);\nconst promise3 = slowFunction(dataObject3);\n\nconst response1 = await promise1;\nconst response2 = await promise2;\nconst response3 = await promise3;\n```", "```\nfunction* getRandomIntegers(max) {\n  while (true) {\n    yield Math.floor(Math.random() * Math.floor(max) + 1);\n  }\n}\n```", "```\nconst randomGenerator = getRandomIntegers(6);\n\n// Get 10 random values between 1 and 6\nfor (let i=0; i<10; i++) {\n  console.log(randomGenerator.next());\n}\n```", "```\n`async` function* getRandomIntegers(max) {\n  while (true) {\n    yield Math.floor(Math.random() * Math.floor(max) + 1);\n  }\n}\n```", "```\nconst randomGenerator = getRandomIntegers(6);\n\n// Get 10 random values between 1 and 6\nfor (let i=0; i<10; i++) {\n  const promise = randomGenerator.next();\n  console.log('Received promise.');\n  promise.then(result => console.log(`Received result: ${result.value}`));\n}\n```", "```\n// This function uses a for await loop to perform consecutive awaits async function searchRandomNumbers(searchNumber, generator) {\n  `for` `await` (const value of generator) {\n    console.log(value);\n    if (value === searchNumber) return;\n  }\n}\n\n// Use the searchRandomNumbers() function to generate random numbers // from 1 to 100, asynchronously, until we find 42 const randomGenerator = getRandomIntegers(100);\nsearchRandomNumbers(42, randomGenerator).then(result => {\n  console.log('Number found');\n});\n\n```", "```\nasync function* getRandomWebIntegers(max) {\n  // Construct a URL to get a random number in the requested range\n  const url = https://www.random.org/integers/?num=1&min=1&max=' + max +\n  '&col=1&base=10&format=plain&rnd=new';\n\n  while (true) {\n    // Start the request (and wait asynchronously for the response)\n    const response = await fetch(url);\n\n    // Start reading the text asynchronously\n    const text = await response.text();\n\n    // Yield the result and wait for the next request\n    yield Number(text);\n  }\n}\n```", "```\n// Keep a reference to the worker so we can cancel it, if needed\nlet worker;\n\nfunction startSearch() {\n  // Create the worker\n  worker = new Worker('prime-worker.js');\n\n  const statusDisplay = document.getElementById('status');\n  statusDisplay.textContent = 'Search started.';\n\n  // Report error message on the page\n  worker.onerror = error => {\n    statusDisplay.textContent = error.message;\n  };\n\n  // Respond to messages from the worker, and display the final result\n  // (the list of primes) on the page when it's received\n  worker.onmessage = event => {\n    const primes = event.data;\n\n    document.getElementById('primeContainer').textContent = primes.join(', ');\n  };\n\n  // Get the search range and tell the worker to start\n  const fromNumber = document.getElementById('from').value;\n  const toNumber = document.getElementById('to').value;\n  worker.postMessage({from: fromNumber, to: toNumber});\n}\n```", "```\n// This is the code the worker uses to handle messages from the page\nonmessage = (event) => {\n  // Get the sent object from event.data and call the time-consuming\n  // findPrimes() method to do the search\n  const primes = findPrimes(Number(event.data.from), Number(event.data.to));\n\n  // Send back the result\n  postMessage(primes);\n};\n```", "```\nfunction cancelSearch() {\n  // Cancel the worker, provided the page has created it\n  if (worker) worker.terminate();\n}\n```", "```\nworker = new Worker('prime-worker.js');\n```", "```\nworker.postMessage({from: fromNumber, to: toNumber});\n```", "```\npostMessage(primes);\n```", "```\nonmessage = function(event) {\n  // Perform the prime number search.\n  const primes = findPrimes(Number(event.data.from), Number(event.data.to));\n\n  // Send back the results.\n  postMessage(\n    {messageType: \"PrimeList\", data: primes}\n  );\n};\n```", "```\nfunction findPrimes(fromNumber, toNumber) {\n  // Prepare the prime number search range\n  ...\n\n  // This is the loop that searches for primes\n  for (let i = 0; i < list.length; i+=1) {\n\n    // Check if the current number is prime\n    ...\n\n    // Calculate and report the progress\n    var progress = Math.round(i/list.length*100);\n\n    // Only send a progress update if the progress has changed at least 1%\n    if (progress !== previousProgress) {\n      postMessage(\n       {messageType: 'Progress', data: progress}\n      );\n      previousProgress = progress;\n    }\n\n  }\n\n  // Clean up and return the list of prime numbers\n  ...\n}\n```", "```\nworker.onmessage = event => {\n  const message = event.data;\n\n  if (message.messageType === 'PrimeList') {\n    const primes = message.data;\n    document.getElementById('primeContainer').textContent = primes.join(', ');\n  }\n  else if (message.messageType === 'Progress') {\n    statusDisplay.textContent = `${message.data} % done ...`;\n  }\n};\n```"]