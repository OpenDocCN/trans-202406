- en: Chapter 2\. Using MySQL Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 2.0 Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We discussed the mysql Client Program in [Chapter 1](ch01.xhtml#nch-mysql).
    MySQL Shell is modern alternative client. In addition to SQL, it supports non-relational
    syntax for the database queries, also known as NoSQL, via JavaScript or Python
    programming interface and provides reach set of features to automate routine tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will discuss how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to MySQL Shell and select the right protocol.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select SQL, JavaScript or Python interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use both SQL and NoSQL syntax.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control output format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use MySQL Shell built-in utilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script to automate your custom needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Admin API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Re-use your scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although MySQL Shell is a standard tool for certain tasks, it is not included
    in MySQL packages and needs to be installed separately. You can download it from
    the [MySQL Shell download page](https://dev.mysql.com/downloads/shell/) or install
    using the standard package manager of your operating system. We will not cover
    MySQL Shell installation in this book, because it is straight forward.
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL Shell’s command name is *mysqlsh*. You can invoke it by typing *mysqlsh*
    in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'MySQL Shell supports two protocols: the classic MySQL protocol (similar to
    the one that the *mysql* client uses), and the new X protocol. X protocol is a
    modern protocol that communicates with the MySQL server on a separate port (default
    is 33060). It supports both SQL and NoSQL APIs, and provides asynchronous API,
    allowing clients to send multiple queries to the server without waiting for the
    result from the previous ones. X protocol is preferred way to work with MySQL
    Shell. It is especially important if you want to use NoSQL features.'
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Connecting to MySQL Server with MySQL Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you invoke *mysqlsh* it opens new session, but does not connect to any
    MySQL Server.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use command *\connect* inside MySQL Shell or provide your MySQL server URI at
    startup.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL Shell allows you to connect to MySQL server after you started the tool
    by providing connections options as a command line parameter. You may also put
    default connection parameters in a startup script.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Shell is flexible regarding connection options. You can supply them as
    a URI or name-value pairs, similar to one that *mysql* client accepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'URI uses this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: where meanings of the parameters explained in the [Table 2-1](#nch-mysqlshell-mysqlshell-connecting-uri).
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Connection Options in URI
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Explanation | Default |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `scheme` | A protocol to use. Could be one of `mysql` if you want to use
    Classic protocol or `mysqlx` for X protocol. | `mysqlx` |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | User name to connect as. | Your operating system account. |'
  prefs: []
  type: TYPE_TB
- en: '| `password` | Password | Asks for a password. |'
  prefs: []
  type: TYPE_TB
- en: '| `host` | Host to connect to. | No default. This is the only **required**
    parameter unless option `socket` is specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `port` | Port to connect to. | 3306 for the Classic protocol and 33060 for
    the X protocol. |'
  prefs: []
  type: TYPE_TB
- en: '| `socket` | Socket, used for the localhost connection. | You must provide
    this or the `host` parameter. |'
  prefs: []
  type: TYPE_TB
- en: '| `schema` | Database schema to connect to. | No value. Do not select any schema.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `option` | Any additional option you want to use. | No value. Choose any
    or no option. |'
  prefs: []
  type: TYPE_TB
- en: 'So, to connect to MySQL server on your local machine using interactive interface,
    type *\connect 127.0.0.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will create a connection using X protocol.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When connecting without specifying user name MySQL Shell uses the operating
    system login. This is why connection is created for user `sveta` and not for the
    user `cbuser` we used everywhere else in the book. We will cover how to specify
    MySQL user account when connecting later.
  prefs: []
  type: TYPE_NORMAL
- en: To exit from the MySQL Shell session use command `\exit` or `\quit` and its
    short form `\q`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect interactively using a socket, type *\c (/var/run/mysqld/mysqld.sock)*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will create connection using Classic protocol. If you want to connect via
    socket with X protocol use `mysqlx_socket`. You will find value of the `mysqlx_socket`
    if run query
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Command *\connect* has shorter version *\c* that we used in the connection
    via socket example. Note parentheses in the command argument. Without parentheses
    the command will fail with syntax error. Alternatively you can replace all following
    slash symbols with their URI encoded value `%2F`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To connect using URI when opening a MySQL Shell session, use the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this case we specified a user name and a password via command line and selected
    `cookbook` as a default database.
  prefs: []
  type: TYPE_NORMAL
- en: When connecting while invoking *mysqlsh* command you can also specify connection
    credentials separately, similar to when you connected with the *mysql* client.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If you want to specify default schema, you need to pass it as a parameter to
    the configuration option `schema`. Otherwise *mysqlsh* will treat it as a host
    name and fail with an error.
  prefs: []
  type: TYPE_NORMAL
- en: Inside MySQL Shell you can also specify options via named parameters. First
    you need to create a dictionary with connection parameters, then pass it as an
    option to the *connect()* method of the built-in automatically created `shell`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about how to connect to MySQL Server via MySQL Shell,
    see [MySQL Shell Connections](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-connections.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Selecting the Protocol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don’t want to use MySQL Shell’s default, and you want to select either the
    X protocol or the classic protocol yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To select X protocol: use one of options `mysqlx`, `mx`, `sqlx`. To select
    classic protocol: use one of options `mysql`, `mc` and `sqlc`.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL Shell selects protocol automatically using connection options and server
    response. If a port or socket option is not used, it tries to connect using a
    default portor socket for the X protocol. If that’s not available, it defaults
    to the classic protocol. If this is not a desired behavior or you simply want
    to control which protocol to use explicitly, you can specify it by passing options
    `mysqlx`, `mx`, `sqlx` when starting the *mysqlsh* client to select X protocol
    and options `mysql`, `mc` and `sqlc` to select classic protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside MySQL Shell, when opening a new connection, specify value for the `scheme`
    key when passing options to the `connectionData` dictionary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, when specifying a URI, you can prefix connection options by
    the `scheme`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If the specified protocol could not be used MySQL Shell will fail with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can find details of your current MySQL Shell connection by running command
    *shell.status()*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: MySQL Shell, like MySQL CLI, allows to customize its prompt. To do it you need
    to edit file `prompt.json`, located in the configuration home of MySQL Shell.
    This is a file in JSON format. MySQL Shell comes with good number of custom templates
    of the prompt and the `README.prompt` file, explaining how to modify the prompt.
  prefs: []
  type: TYPE_NORMAL
- en: We will not cover in detail how to customize the MySQL Shell user prompt, but
    will remove the host, port, and protocol information from the default prompt,
    so our examples will take less space in the book.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration home of the MySQL Shell is either `~/.mysqlsh/` on Unix or `%AppData%\MySQL\mysqlsh\`
    on Windows. You can overwrite this location if set variable `MYSQLSH_USER_CONFIG_HOME`.
    `README.prompt` and examples are located in the `share/mysqlsh/prompt/` directory
    under MySQL Shell installation root.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about *mysqlsh* command options, see [A.1 mysqlsh
    — The MySQL Shell](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysqlsh.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Selecting SQL, JavaScript or Python Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL Shell starts in the wrong mode, and you want to select a different mode
    than the default.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use options `sql`, `js` or `py` or switch the mode after starting *mysqlsh*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default MySQL Shell starts in JavaScript mode. You can see it by looking
    at the prompt string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can change default mode if start the tool with the option `--sql` to select
    SQL mode or `--py` to select Python mode. To select JavaScript mode explicitly
    at startup use option `--js`. You will see that the prompt message of the MySQL
    Shell client will change to the selected mode. Here, we select the Python mode.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For SQL mode you can explicitly instruct the tool to use not only desired mode,
    but also a desired protocol with option `sqlx` to select X protocol and option
    `sqlc` to select Classic protocol. This could be handy when you connect via default
    TCP/IP port.
  prefs: []
  type: TYPE_NORMAL
- en: Inside *mysqlsh* you can change the processing mode with commands *\js*, *\py*,
    and *\sql* to switch to Javascript, Python, and SQL modes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 2.4 Running SQL Session
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to have functionality that’s a *mysql* client has, but you do not want
    to leave MySQL Shell.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use SQL mode.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With SQL mode MySQL Shell behaves exactly the same as the *mysql* client that
    we describe in [Chapter 1](ch01.xhtml#nch-mysql). You can run queries, control
    output using *\pager* command, edit SQL in the system editor with *\edit* command,
    execute SQL from a file with *\source* command and execute a system shell commands
    with *\system*. You can view and edit the command line history.
  prefs: []
  type: TYPE_NORMAL
- en: There is no shortcut `\d` for the *delimiter* command, but the command itself
    works.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There is no *tee* command. If you want to log query results into a file, set
    the pager to `tee -a <DESIRED LOG FILE LOCATION>`. However, it will not log SQL
    statements. They are available only in the history file.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'By default MySQL Shell does not save history between client sessions. This
    means that you cannot access your previous commands once you exit the shell. You
    can overwrite this behavior if enable option `history.autoSave`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 2.5 Running SQL in JavaScript Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are in JavaScript mode, but want to execute traditional SQL
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the command *\sql*, or use the methods `sql()` and `runSQL()` that belong
    to the class `Session`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript mode supports the object-oriented style of querying your database.
    Or, you can run plain SQL.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run single SQL statement and get results like you can in the
    MySQL client without leaving JavaScript mode use command *\sql*. In the example
    below we run plain SQL statement, selecting data from the table `limbs` for things
    that have two or more arms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The object-oriented style of running SQL is more flexible and provides more
    options. To run single statement use method *runSQL* of the class `Session`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you connect to MySQL Shell it creates a default instance of the class `Session`.
    It is accessible via global object `session`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method *runSQL* supports placeholders: just replace variable values with `?`
    sign and pass parameters as an array.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine this method with standard JavaScript syntax and create a script
    that can do more than just running SQL queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_select_max_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Select maximum number of arms, stored in the `limbs` table.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_fetch_one_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Method *session.sql.execute()* returns a `SqlResult` object that has a method,
    called *fetchOne*, returning the first row of the result set.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_get_field_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Since our query is supposed to return one row we did not traverse the result
    set, but simply called a method *getField* that takes a column name or its alias
    as a parameter, to get maxium number of arms, stored in the table `limbs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_for_loop_co)'
  prefs: []
  type: TYPE_NORMAL
- en: We used this number as a stopping condition for the *for* loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_bind_co)'
  prefs: []
  type: TYPE_NORMAL
- en: In the loop we executed queries to get number of the species with the specified
    number of arms. We used method *sql* and its method *bind* to bind value of the
    loop iterator `i` to the query.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_result_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Check if we received a result and if number of arms is greater than 0.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_print_co)'
  prefs: []
  type: TYPE_NORMAL
- en: 'If both conditions are true: print the result.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you execute *sql* or *runSQL* methods separately MySQL Shell calls method
    *execute* for them automatically. But if using these methods in more complicated
    code, like in the loops or multiple-statements blocks you need to call method
    *execute* explicitly. Otherwise only last statement will be executed and all previous
    invocations will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about MySQL Shell API, see the [ShellAPI in the advanced
    MySQL User Reference Manual](https://dev.mysql.com/doc/dev/mysqlsh-api-javascript/8.0/group___shell_a_p_i.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Running SQL in Python Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are in Python mode, but want to execute traditional SQL
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the command *\sql*, or the methods `sql`, `run_sql` of the class `Session`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as we saw with JavaScript mode, the Python mode also supports the *\sql*
    command. You can use it if you want to execute a SQL statement and do not want
    to do anything with its result. The following code selects all rows from the table
    `movies`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Method names in Python mode are slightly different from those in JavaScript
    mode. Thus, to run SQL statement, using `Session` object and bind parameters to
    it as an array use method *run_sql*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example selects all movies, created before 2000.
  prefs: []
  type: TYPE_NORMAL
- en: You can program in Python as well as in JavaScript. For example, if you want
    to know the number of movies each actor was featured in as well as years when
    they were starred, join table `movies` with table `movies_actors`, then print
    result using Python code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_query_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the query and fetch all the rows that it returns into a variable `myres`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_loop_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Traverse this variable in a *for ... in* loop.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_print_py_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Print result.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you are not familiar with the query syntax yet, do not worry: we will discuss
    ways of querying data in [Chapter 5](ch05.xhtml#nch-select) and how to join two
    or more tables in [Recipe 16.0](ch16.xhtml#nch-multi-multi-intro).'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about Python MySQL Shell API, use command *\? mysqlx*
    inside the Python shell session.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 Working with Tables in JavaScript Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to query your tables using object-oriented style in JavaScript mode.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use method *getTable* to select a table, then methods *select*, *count*, *insert*,
    *update*, *delete* to select, retrieve number of rows, insert, update or delete
    from the table.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL Shell supports object-oriented syntax for querying and modifying database
    objects. Thus, to select all rows from the table `limbs` we can use *select* method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In the listing above we firstly selected schema using *getDefaultSchema* method,
    then selected a table with method *getTable* and, finally, retrieved all rows
    with *select*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Method *select* returns `TableSelect` object that supports methods allowing
    to specify `WHERE` condition, `ORDER BY`, `GROUP BY` clauses and other features
    that SQL `SELECT` has. It also supports prepared statements and parameters binding.
    Thus, to select only those species from the table `limbs` that have four or more
    legs and order them by number of legs try the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that here we are using named parameters for placeholders instead of question
    marks like we did when queried database with SQL.
  prefs: []
  type: TYPE_NORMAL
- en: MySQL Shell API also supports methods to insert, update and delete data in the
    object-oriented style as well as starting and finishing transactions. Like, if
    we want to experiment with `cookbook` database without actually modifying data
    we can do it inside a transaction.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_jst_limbs_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Save the table object for the table `limbs` into a variable `limbs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_jst_transaction_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Start a transaction, so we can rollback our experiments.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_jst_insert_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Insert two rows into table `limbs` using method *insert* that takes list of
    columns as a parameter and method *values* that takes list of values to be inserted
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_jst_count_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Check the number of rows that now exist in the table.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_jst_update_co)'
  prefs: []
  type: TYPE_NORMAL
- en: If look back to the rows that we inserted you may notice an error. A dog actually
    has four legs and not two legs and two arms. To fix this mistake call method *update*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](Images/6.png)](#co_jst_select_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Following *select* call confirmed that our changes were applied to the table
    `limbs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](Images/7.png)](#co_jst_delete_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Then we figured out that cats and dogs are not always friends with each other
    and removed a cat from the table with method *delete*.
  prefs: []
  type: TYPE_NORMAL
- en: '[![8](Images/8.png)](#co_jst_count2_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Confirm that the cat was successfully removed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![9](Images/9.png)](#co_jst_rollback_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Roll back the transaction to restore the table to its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: '[![10](Images/10.png)](#co_jst_confirm_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Methods *count* and *select* confirm that the table is in its initial state.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since we executed all statements one-by-one in the interactive session we ommitted
    method *execute*. This method required if you are executing SQL commands in loops
    or program scripts.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about how to work with tables in JavaScript mode,
    see [User Reference Manual for the object `Table`](https://dev.mysql.com/doc/dev/mysqlsh-api-javascript/8.0/classmysqlsh_1_1mysqlx_1_1_table.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 Working with Tables in Python Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have tables in your database and want to work with them in Python mode.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the method *get_table* to get the Table object, then the methods *select*,
    *count*, *insert*, *update*, *delete* to select, retrieve number of rows, insert,
    update or delete from the table.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like JavaScript, Python supports working with tables in object-oriented style.
    Thus, to select all rows from the table `movies` try method *select* of the class
    `Table`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example we used the method *get_schema* that allows us to select any
    schema stored in the database to which the session user has been granted access.
  prefs: []
  type: TYPE_NORMAL
- en: Python mode supports methods, allowing to modify data in the tables as well
    as transaction statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our examples we will save tables `movies` and `movies_actors` into the
    variables first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will open a transaction, so our changes will appy either to both tables
    or to none at all, and we will insert a movie *“Darkest Hour”* starring Gary Oldman.
    Finally, we will commit the transaction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'To find all movies, starring Gary Oldman, we will use SQL query, because X
    API does not support joins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Oops! The year for the movie *“Darkest Hour”* is not correct in one of tables.
    Let’s update it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_pyt_begin_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Start a transaction, so we update either all tables, or no tables.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_pyt_update_movies_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Update table `movies`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_pyt_update_movies_actors_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Update table `movies_actors`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_pyt_commit_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Commit the changes.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_pyt_confirm_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Confirm that the changes were applied to the table.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to remove our newly inserted movie we can use method *delete*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In this example we also started transaction first, then called method *delete*
    on two tables and, finally, committed the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about accessing tables in object-oriented style while
    in Python mode, see interactive help of the MySQL Shell that could be invoked
    by a command *\?*.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 Working with Collections in JavaScript Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have semi-structured data and want to use MySQL as a Document Store. You
    also want to query your data with NoSQL, without leaving programming style of
    your preferred language.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `Collection` object and its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL supports not only SQL syntax, but also NoSQL. When you use SQL you query
    tables and when you use NoSQL you query collections. Physically such collections
    are stored in tables that have three columns: generated unique identifier that
    is also a primary key, a `JSON` column that stores the document and an internal
    column that stores JSON schema. You can create a collection by using the method
    *createCollection* of the class `Schema`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The code above creates NoSQL collection `CollectionLimbs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Collections support schema validation. There is no method to add a schema validation
    for the existent collection, but we can add schema when creating the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Once NoSQL collection is created you can insert, update, delete and search documents.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to insert documents from the table `limbs` into collection `CollectionLimbs`
    we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_jsc_select_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Select all rows from the table `limbs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_jsc_fetch_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Method *fetchOneObject* returns a dictionary object.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_jsc_convert_co)'
  prefs: []
  type: TYPE_NORMAL
- en: A dictionary object cannot be saved in the collection without converting it
    to the proper JSON object. Therefore we converted it into JSON string first, then
    created an expression out of this string that could be inserted into the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_jsc_add_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Method *add* inserts a document into the collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](Images/5.png)](#co_jsc_execute_co)'
  prefs: []
  type: TYPE_NORMAL
- en: Method *execute* is required all the time when we update a database inside script
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: We enclosed the code into curly braces, because otherwise, if code put on the
    multiple lines, MySQL Shell will output result of *session.getCurrentSchema().getTable('limbs').select().execute()*
    and variable `limbs` will contain only diagnostic message about the number of
    rows affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can examine data, just inserted into the collection `CollectionLimbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: You can also modify and remove documents from your collections. We will show
    examples on how to do it in [Recipe 2.10](#nch-mysqlshell-mysqlshell-python-collections)
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about how to use MySQL with JSON documents and NoSQL,
    see [Chapter 19](ch19.xhtml#nch-json).
  prefs: []
  type: TYPE_NORMAL
- en: 2.10 Working with Collections in Python Mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use DocumentStore and NoSQL in Python mode.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `Collection` object and its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as you can do in the JavaScript mode, you can also work with NoSQL in Python
    mode. Syntax is also similar to JavaScript mode. However, method names follow
    naming style, recommended for the programs, written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to assign a collection to a variable use method *get_collection* of the
    class `Schema`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'To select documents use method *find*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Method *find* supports arguments, allowing to search for specific documents,
    similarly to the syntax of the clause `WHERE` in SQL. It also allows to aggregate
    results, sort them and select specific fields. It does not support joining of
    the collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'To insert a new document use method *add*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'To modify existing row use either method *add_or_replace_one* or *modify*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Method *add_or_replace_one* takes document `_id` as the first parameter and
    a JSON document as the second one. If a document with specified `_id` is not found,
    it inserts new document. If found: replaces existing one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Method *modify* takes a search condition as an argument and returns an object
    of the class `CollectionModify` that supports methods, allowing to modify parameters
    such as *set*. You can chain calls to method `set` as many times as needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To check if we successfully changed quantity of arms and legs for the newly
    inserted documents `cat` and `dog` we can use method *find*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Method *remove* deletes documents from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Method *remove* supports searching condition similarly to the *modify* and *find*
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about using MySQL with JSON documents and NoSQL,
    see [Chapter 19](ch19.xhtml#nch-json).
  prefs: []
  type: TYPE_NORMAL
- en: 2.11 Controlling the Output Format
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to print results in a format, different from the default.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the configuration option `resultFormat`, or the command-line parameters
    `--result-format`, `--table`, `--tabbed`, `--vertical`, or `--json`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default MySQL Shell prints result in a table format, similar to the default
    one of the *mysql* client. However, this format could be customized.
  prefs: []
  type: TYPE_NORMAL
- en: Inside MySQL Shell you can do it with help of the command *\option* or the method
    *set* of the `shell.options` member of the class `Shell`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to print content of the table `artist` in tabbed format run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To switch to the vertical format run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'JSON format supports few options. By default, if the value of the option `resultFormat`
    is set to `json` or MySQL Shell started with option `--json` it is same as `json/pretty`
    or `--json=pretty` that means that the result printed as a JSON, formatted for
    better readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Options `ndjson`, `json/raw` or `--json=raw` produce more compact raw JSON output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Option `json/array` represents result as an array of JSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: That could be especially useful if selecting the data from the command line
    and later passing it to another program.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In the code above we started *mysqlsh* with the option `-i` that enables interative
    mode, so MySQL Shell behaves like if it was run interactively and option `--quiet-start=2`
    that disables all welcome messages. Then we set option `--result-format` to `json/array`
    to enable JSON array output, used option `--execute` to select from the table
    `artist` and passed output to the *jq* command that removed all metadata information
    and printed only names of artists.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Command *head -n -1* removes last line from the result that shows number of
    rows, returned by the method *select*. Note that specifying negative number as
    a command *head -n* parameter may not work everywhere. If you or on such a system
    you can ignore error message that the command *jq* will print or redirect it somewhere
    else:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When JSON wrapping is enabled at the MySQL Shell startup with option `--json[=pretty|raw]`
    it will also print diagnostic information in the resulting JSON output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you enabled JSON output using command-line option `--result-format=json[/pretty|/raw|/array]`
    this additional information is not printed.
  prefs: []
  type: TYPE_NORMAL
- en: All output formats are independent from how you select data and available in
    all modes.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about MySQL Shell output formats, see [MySQL User
    Reference Manual](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-output-formats.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2.12 Running Reports with MySQL Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to run periodic reports.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the commands *\show* and *\watch*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL Shell commands *\show* and *\watch* execute reports, both built-in and
    user-defined. *\show* executes a report once while *\watch* runs the report continiously,
    until interrupted.
  prefs: []
  type: TYPE_NORMAL
- en: Report is a pre-defined sequence of commands. Reports may support arguments.
    For example, the built-in report `query` takes SQL query as an argument. Built-in
    report `thread` reports details about a specific thread. By default it reports
    details about the current thead.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Built-in report `thread` queries tables in `performance_schema` and `sys`, therefore
    you should connect as a user that has `SELECT` privilege on `performance_schema`
    and `sys` schemas and `EXECUTE` privilege on `sys` schema. Otherwise the report
    will fail with an <q>Access denied</q> error.
  prefs: []
  type: TYPE_NORMAL
- en: But report `thread` supports arguments, so you can specify, for example, `Connection
    ID` of the thread and output information about the specific one.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The output of the `thread` report is similar to the stdandard `PROCESSLIST`
    output, but contains additional information, such as `Transaction state` and `Previous
    statement`. The latter could be especially useful when you are figuring out what
    is preventing your transaction from finishing. For example, if one of the transactions
    runs in multiple statements and locks a record, it may cause other transactions
    to wait until the lock is released. But since the statement was already executed
    it would not be visible in the regular `PROCESSLIST` output.
  prefs: []
  type: TYPE_NORMAL
- en: Even more useful information could be found in the `threads` report that by
    default outputs information about all threads belong to the current user. It runs
    the MySQL Shell session, but can print information about all the threads running
    on the server and also fiter them and define output format.
  prefs: []
  type: TYPE_NORMAL
- en: For example, to find all blocked and blocking transactions you can define option
    `--where "nblocked > 0 or nblocking > 0"`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Thus in the example above thread with `Connection ID 3268` is trying to execute
    an update
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: ', but is blocked by another transcation. Otherwise, the thread with `Connection
    ID 1386` is not executing anything, but blocks a thread. Its previous statement
    was'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: that blocks all rows in the table `adcount` for writing. This way we easily
    found why the *UPDATE* in the connection 3268 cannot finish at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: The report *threads* has more options. You can find all of them if run *\show*
    command with the report name, followed by the option `--help`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All MySQL Shell commands support help options. For built-in commands run *\?
    COMMAND*, *\help COMMAND* or *\h COMMAND*. For commands with parameters additionally
    try option *--help*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Command *\watch* not only executes report, but does it repeatedly, with certain
    intervals. It could be very useful when you want to watch changes of the certain
    parameter. For example, to watch number of internal temporary tables, created
    to resolve queries, run command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The query uses operator `LIKE` and patterns to much names of two system variables.
    We discuss how operator `LIKE` works and matches patterns at [Recipe 7.10](ch07.xhtml#nch-strings-strings-pat-sql)
  prefs: []
  type: TYPE_NORMAL
- en: The query runs with a default interval 2 seconds. The parameter `--nocls` instructs
    the command to not clear the screen before printing the latest result. To stop
    watching issue termination command *Ctrl+C*.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 2.13 Using MySQL Shell Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use MySQL Shell utilities.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript or Python modes: use the methods of the global `util` object
    interactively or pass the method via the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL Shell comes with a number of the built-in utilities that allows you to
    perform common adminstrative tasks, such as checking if your MySQL Server could
    be safely updated to the new version or making a reserve copy of the data. These
    utilities could be called as methods of the global object `util` in JavaScript
    and Python modes or specified as a command line option.
  prefs: []
  type: TYPE_NORMAL
- en: To find out which utilities MySQL Shell supports run the command *\? util*.
    The names of methods are different in JavaScript and Python modes and follow naming
    best practices for each of languages. Global object `util` is not available in
    the SQL mode, as well as utilities.
  prefs: []
  type: TYPE_NORMAL
- en: To figure out how one or another utility works use the help command with the
    name of the utility as an argument. For example, *\? checkForServerUpgrade* will
    print exhausted help for the upgrade checker utility in JavaScript mode. *\? dump_instance*
    will print detailed usage instructions for the utility that dumps the instance
    in Python mode.
  prefs: []
  type: TYPE_NORMAL
- en: Calling utility methods is no different than calling any other method. For example,
    the following code exports table limbs into file `limbs.csv` in fully-quoted CSV
    format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You need to create directory `BACKUP/cookbook` before running this command or
    use different location.
  prefs: []
  type: TYPE_NORMAL
- en: 'This Python code restores the table into the table limbs in the database test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: We omitted all but necessary options for the import example to make it shorter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use *import_table* you need to be in the Classic protocol session.
    Otherwise the command will fail with an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is always good to read error messages, because they clearly show what is
    wrong and often contain instructions on how to fix the failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another error you can hit is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'To bypass this error enable `local_infile` option with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Or leave this example until you get to the [Chapter 13](ch13.xhtml#nch-xfer)
    that covers export and import of the MySQL database objects.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you do not understand what the utility is doing in these examples: do not
    worry. We will cover export and import of the MySQL database objects in [Chapter 13](ch13.xhtml#nch-xfer).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run utilities without entering interactive mode you may specify
    them after the two dashes, following standard *mysqlsh* options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: In this example we first specified the command name, then added two dashes,
    followed by the global object name, the method we wanted to use, the connection
    string and, finally, the method arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command line uses the method names of either JavaScript mode Camel case
    syntax: *checkForServerUpgrade*, the Kebab case syntax: *check-for-server-upgrade*,
    or the Snake case syntax: *check_for_server_upgrade*. For more information on
    how to use global objects without entering interactive mode use command *\? cmdline*
    interactively.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can use `--` syntax to call methods of other global objects on the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: However, not all global objects are supported. Check *\? cmdline* for the list
    of supported objects.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about MySQL Shell utilities, see [MySQL Shell Utilities](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-utilities.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2.14 Using the Admin API to Automate Replication Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to automate routine DBA tasks, such as deploying MySQL servers.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use AdminAPI.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'MySQL Shell supports not only the X Dev API for querying the database, but
    also the AdminAPI allowing you to manage InnoDB ReplicaSet and InnoDB Cluster.
    AdminAPI consists of three classes: `Dba`, `Cluster` and `ReplicaSet`.'
  prefs: []
  type: TYPE_NORMAL
- en: AdminAPI is accessible from the global object `dba` of class `DBA`. It allows
    you to configure MySQL instances and start either a standalone sandbox, or ReplicaSet,
    or Cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure a standalone sandbox use the method *deploySandboxInstance* in
    the JavaScript mode or *deploy_sandbox_instance* in Python mode. This method takes
    a port number and a dicitionary of parameters as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a sandbox instance with X port 13010 and enabled binary log
    with a name, starting from *cookbook*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop the instance use method *stopSandboxInstance* in JavaScript mode or
    *stop_sandbox_instance* in Python mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'To destroy the instance use method *deleteSandboxInstance* in JavaScript mode
    or *delete_sandbox_instance* in Python mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Global object `dba` is accessible from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Global object `dba` is not available in SQL mode.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about using AdminApi to create and manage a ReplicaSet,
    see [Recipe 3.17](ch03.xhtml#nch-replication-replication-automation). For additional
    information about using AdminApi to create and manage InnoDB Cluster, see [“InnoDB
    Cluster”](ch03.xhtml#nch-replication-replication-automation-innodbcluster)
  prefs: []
  type: TYPE_NORMAL
- en: 2.15 Working with JavaScript Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to work with your documents as objects, and you want to modify them
    and store them in the database using own methods and properties.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an object that will have all necessary methods to communicate with the
    database and use it as a prototype of your data objects.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript is an object-oriented programming language and it is easy to create
    objects, modify them, and store them in the database. Sometimes it maybe easier
    to simply write *myObject.save()* instead of calling the full chain of methods
    of the X DevAPI Collection class. For example you may want to replace the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: with single
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: call.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript supports inheritance, therefore you can create an object that will
    have all necessary methods, working with the `Collection` class methods, and use
    it as a prototype of the object, containing your business logic.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create as en example a `CookbookCollection` object that will have the
    methods *find*, *save* and *remove*. They will search for an object in the collection,
    save it after modification and remove from the database if necessary. The `CookbookCollection`
    object will also have a property `collection` that will store an object, representing
    collection where our object is stored.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make our methods very simple for clarity, we will not add error
    handling. You can add this functionality yourself. For example, if a user forgets
    to set a collection property, you can throw a custom exception or have a default
    collection that will be used instead. We are relying on JavaScript built-in exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started and create our object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'First we define the property collection where the object is stored. We do not
    set the name of the collection here, because want our prototype to work with any
    collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Function *find* searches the collection using any search condition. It could
    be `''_id = "00006002f0650000000000000061"''` or `''thing="human"''`. In other
    words: any condition, that the method *Collection.find* accepts. Then we fetch
    one document and return it as a result. We intentionally did not add any unique
    check code or any other way to ensure that there is only one document, satisfying
    our condition, because wanted to make the example as simple as possible and have
    it working with any collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'The method *save* stores the object in the database. If there is no `_id` field
    in the object that usually means that there is no such object yet in the database.
    So, we use the method *add* to insert it into the database and set the property
    `_id` of the object to the value, generated by MySQL. If such a property already
    exists that either means that such object is already in the database or we want
    to set `_id` explicitly. In this case we use method *addOrReplaceOne* that either
    adds new object with the specified unique identifier or replaces existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: The method *remove* deletes the record from the database and additionally deletes
    property `_id` of our object, so that, in case we want to store it in the database
    again, it will be considered as a new one and new unique identifier will be generated.
    We remove property `_id` from both prototype and the object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the collection `CollectionLimbs` that we created in the [Recipe 2.9](#nch-mysqlshell-mysqlshell-js-collections)
    as an example. First, we retrieve it from the current `session` and set as a `collection`
    property of the `CookbookCollection` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In [Recipe 2.9](#nch-mysqlshell-mysqlshell-js-collections) we rolled back all
    our modifications to the `CollectionLimbs`. If you continued your own experiments
    further before running examples in this recipe, execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let’s create an object `cat` with 2 arms and 2 legs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to store our cat in the database we need to assign object `CookbookCollection`
    as a prototype of the object `cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can save our object in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check if we can retrieve such an object with method *find*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also confirm that our object now has `_id` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Do you see anything wrong here? Yes! The cat has two arms and two legs while
    usually cats have no arms and four legs. Let’s fix it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Now our cat is in good shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to clean up the collection and leave it in a state as it was before
    our experiments we can remove document `cat` from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'We may also notice that the property `cat._id` does not exist in our object
    anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: If we decide to store the object in the database again new unique identifier
    will be generated.
  prefs: []
  type: TYPE_NORMAL
- en: You will find `CookbookCollection` code in the file *mysql_shell/CookbookCollection.js*
    of the `recipes` distribution.
  prefs: []
  type: TYPE_NORMAL
- en: 2.16 Filling Test Data Using Python’s Data Science Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to fill a test table with partially random data. For example, you need
    IDs to follow a sequence. You also want them to have realistic names and surnames.
    The rest of values in the table could be random, but index should have certain
    cardinality.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Script data population using Python and its specific data science modules.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We often are in a situation when it is necessary to fill a table with fake data
    that mimics real world data for testing purposes. For example, when you develop
    an application and want to check what happens if the volume of data stored in
    it will increase. Or you hit a situation where a particular query works slow in
    production and you want to experiment on the test server, but do not want to copy
    production data due to security or performance reasons. This task may also be
    required when you want to ask third-party consultants for help.
  prefs: []
  type: TYPE_NORMAL
- en: 'One such example is the table `patients` that we use in [Recipe 24.12](ch24.xhtml#nch-security-security-views).
    This is a table, storing patients records that spent more than one day in a hospital.
    It stores such data as national ID, name, surname, gender, diagnosis of the person
    and outcome, such as dates that this patient spent in the hospital and if they
    were recovered, checked out with same symphtoms or even died. You can find details
    if run *SHOW CREATE TABLE* command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Of course, we could not even think about using real data for examples with this
    table. However, we still want to pretend that the data is real. For example, names
    and surnames should be ones that are popular. Like someone named John Doe or Ann
    Smith, genders should correspond to right names. E.g. John is, likely, a male
    and Ann is, likely, a female. Ages should fail in realistic range, departure date
    should be greater than the date when the patient arrived to the hospital, and
    it is unlikely that a patient would spend 10 years there. So we need a smart way
    to fill the table with fake values.
  prefs: []
  type: TYPE_NORMAL
- en: Python is a programming language often used for data analysis and statistics.
    It has libraries, such as `pandas`, that help to manipulate with large data sets.
    It has convenient methods to read and generate data. This is why Python is one
    of the ideal ways to perform our task.
  prefs: []
  type: TYPE_NORMAL
- en: To use module `pandas` in MySQL Shell you need to have it installed on your
    machine and add the path where the library is located, into MySQL Shell’s `sys.path`.
    Here are the steps that will help you to perform this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'First check which version of Python MySQL Shell is running. In our case this
    is version 3.7.7:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'MySQL Shell does not come with *python* executable and *pip* that you can run
    from outside MySQL Shell. Therefore you need to install the same version as the
    MySQL Shell’s Python. We preferred to keep system-wide installed version 3.8.5
    untouched and install the same version which our MySQL Shell instance used: 3.7.7
    into a local directory from the source code. You may decide to have the same version
    system-wide.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the necessary version of Python is installed check where it stores its
    modules and add this directory to the `sys.path` of the MySQL Shell:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H6
  type: TYPE_NORMAL
- en: To avoid typing this command each time when you want to use modules that are
    not part of the MySQL Shell distribution, add this command to the Python mode
    configuration file. This file, by default, is located at `~/.mysqlsh/mysqlshrc.py`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install necessary packages. For our example we used `numpy`, `pandas`, `random`,
    `string` and `datetime`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once these prerequisites are met we are ready to fill our table with example
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Data filling step-by-step
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we need to import all necessary packages. Type the following in the
    MySQL Shell Python protocol session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Now we are ready to generate data.
  prefs: []
  type: TYPE_NORMAL
- en: For names and surnames we decided to use real names found in the datasets, available
    on the Internet. You will find datasets we used, their licenses and distribution
    rights in the directory *datasets* of the `recipes` distribution. For diagnoses
    we also used publicly available data of the top 8 diagnosises with their frequency,
    and fake diagnose “Data Phobia” with even higher frequency. Data for genders is
    stored together with names. All other values are generated. We did not care if
    this data looks real. For example, we may end up with a 16-year-old patient dying
    from Alcoholic liver disease that will unlikely happen in real life, but for demonstrating
    purposes that should be enough. However, Python allows to solve such collisions.
    You may change our example, so it will create even more realistic data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is convenient to have a variable, defining the final number of rows in the
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Now, once we are ready, let’s discuss how we will process each of the table
    `patients` column.
  prefs: []
  type: TYPE_NORMAL
- en: Names and genders
  prefs: []
  type: TYPE_NORMAL
- en: 'Names and genders are stored in file `top-350-male-and-female-names-since-1848-2019-02-26.csv`
    in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: That means each row contains a rank from 1 to 350, one name that is traditionally
    female, and one name that is traditionally male of this rank and count of such
    names. We are not interested in the rank and count. We just need female and male
    names with gender information. Therefore we need to perform slight manipulation
    on this dataset after reading.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we read the file using *read_csv* method of `pandas`. We will read the
    file twice: once for traditional female names and once for traditional male names.
    We will use only the `Female Name` column in the first attempt and only `Male
    Name` column in the second attempt. We will also rename this column, so it corresponds
    name of the column in our database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done add a `gender` column to our datasets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: 'And, finally, concatenate two datasets into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to read file `top-350-male-and-female-names-since-1848-2019-02-26.csv`
    it should be either in current working directory or you need to provide absolute
    path to this file. To find your current working directory, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the working directory, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: This will allow to read files, located in `/mysqlcookbook/recipes/datasets`.
    Adjust directory path to reflect your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Method `concat` of the Python module `pandas` works similarly to SQL `UNION`
    clause.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can examine content of our dataset that uses `pandas` data structure `DataFrame`
    by typing its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: Number of rows in the DataFrame is smaller than the number of rows we want to
    have in our table, so we need to generate more. We also want to shuffle the data,
    so we have random distribution of names. We will use method *sample* for this
    purpose. Since we are creating a set, larger than the initial one, we need to
    specify an option `replace=True`. We will also re-create index for the new DataFrame
    using method *pandas.Series*, so it will be ordered.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Surnames
  prefs: []
  type: TYPE_NORMAL
- en: 'For surnames we will use a dataset, stored in the file `Names_2010Census.csv`.
    It has multiple columns, such as a rank, the number of surnames and so on. But
    we are only interested in the first column: `name`. We also do not need last row
    of this file, containing a record for `ALL OTHER NAMES`. Surnames in this file
    are stored in uppercase. We could format them differently, but we decided to leave
    them as is. We will also rename column `name` to `surname`, so it is a same as
    in our table definition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '*pandas* prints a warning that it will use slower, but more powerful `python`
    engine to process the file, but this warning can be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: We will shuffle surnames using the same method that we used for the names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: Diagnoses
  prefs: []
  type: TYPE_NORMAL
- en: We manually prepared file `diagnosis.csv` that is just of 9 diagnosises, therefore
    we only need to read it and do not need to specify any option.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: Diagnoses are different from the names and surnames, because they have different
    frequency and we want them distributed in our final dataset according to those
    frequencies. Therefore we will pass parameter `weights` to the method `sample`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Results
  prefs: []
  type: TYPE_NORMAL
- en: 'Data type for results is `ENUM` that could contain only three possible values:
    `R` for recovered, `N` for not recovered and `D` for dead. We would not use any
    source for such results, but generate a DataFrame interactively.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'We added a frequency to our results. These frequencies have nothing to do with
    reality: we only need them to distribute our results differently.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we have a frequency for our results we will generate the data set similarly
    like we did for diagnosises.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: The table
  prefs: []
  type: TYPE_NORMAL
- en: Our main datasets are prepared. Now we can start inserting rows into the table
    one-by-one.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s retrieve a `Table` object, so we can query it comfortably.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Then start the loop
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: All subsequent generations will be proceeded in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: National ID
  prefs: []
  type: TYPE_NORMAL
- en: 'Format of the national ID can vary between countries and we simply need something
    unique that can follow some pattern. We decided to use format of two digits, followed
    by two uppercase letters and followed by six digits. To generate random digits
    we will use method *randrange* of the module `random` and to generate letters
    we will use method *sample* from the module `random`. We will use pre-defined
    set `string.ascii_uppercase` as a dataset to sample. Then we will join generated
    array to empty string, so it will create a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: Age
  prefs: []
  type: TYPE_NORMAL
- en: 'For the age we will simpy choose a number between 15 and 99\. We would not
    care about frequency of ages or about how many of patients of certain age have
    a certain disease:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Dates which a patient spent in the hospital
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `date_arrived` column we decided to just use any date in year 2020\.
    We can generate such a date by specifying a start date as January 1, 2020 and
    using method *timedelta*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'For the column `date_departed` we will use the same idea, but we will use `date_arrived`
    as a starting date and interval of two months:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This code creates values for `date_arrived` and `date_departed` as `datetime`
    Python objects that could not be inserted into MySQL table, therefore we need
    to convert them into string format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Preparing the row
  prefs: []
  type: TYPE_NORMAL
- en: 'We have values to be inserted into `i-`th row of our table into columns `national_id`,
    `age`, `date_arrived` and `date_departed`. But rest of the values are stored in
    `DataFrame`s of exactly desired number of rows size. We only need to retrieve
    specific row from the `DataFrame`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: Inserting row into a table
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to insert a row into our table. We will use method *insert*
    of the class `Table` that we discussed in detail in [Recipe 2.8](#nch-mysqlshell-mysqlshell-python-tables):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Putting all together
  prefs: []
  type: TYPE_NORMAL
- en: It maybe convenient to define the code we just wrote as a function, so we can
    re-use it. Let’s create one, called *generate_patients_data*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check how it works by truncating table patients and then calling the
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: We can also store this function in a file and re-use it later. We will discuss
    re-using user code in [Recipe 2.17](#nch-mysqlshell-mysqlshell-reuse).
  prefs: []
  type: TYPE_NORMAL
- en: You will find code of the function *generate_patients_data* in file *mysql_shell/generate_patients_data.py*
    of the `recipes` distribution.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about Python module `pandas`, see [pandas documentation](https://pandas.pydata.org/pandas-docs/stable/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: 2.17 Reusing Your Scripts for MySQL Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You wrote code for MySQL Shell and want to re-use it later.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Store your work, and later load the files using the command *\source*. Or, set
    up the files as startup scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MySQL Shell allows to re-use your code. You can do it either by using command
    *\source* or by setting your scripts to be executed at startup. Let’s examine
    each of these possibilities in detail.
  prefs: []
  type: TYPE_NORMAL
- en: The command *\source* is available for each of modes and works similarly to
    the command *\source* of *mysql* client. The only difference is that your source
    files should be written in the same language as the selected mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to load the object `CookbookCollection` that we discussed in [Recipe
    2.15](#nch-mysqlshell-mysqlshell-javascript), we can type this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: As you see, it immediately becomes available for use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly you can import the definition of the function *generate_patients_data*
    that we discussed in [Recipe 2.16](#nch-mysqlshell-mysqlshell-python):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, in SQL mode, we can load any SQL file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to execute scripts at startup you need to edit file `mysqlshrc.js`
    for JavaScript mode and `mysqlshrc.py` for Python mode, located in one of the
    locations that MySQL Shell uses to search for the startup scripts. These can be
    located in any of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The global configuration file, located in `/etc/mysql/mysqlsh/mysqlshrc.[js|py]`
    on Unix, or `%PROGRAMDATA%\MySQL\mysqlsh\mysqlshrc.[js|py]` on Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your personal configuration file, located either under `$HOME/.mysqlsh/mysqlshrc.[js|py]`
    on Unix, or under `%APPDATA%\MySQL\mysqlsh\mysqlshrc.[js|py]` on Windows. Alternatively
    you can specify the variable `MYSQLSH_USER_CONFIG_HOME` and store file `mysqlshrc.[js|py]`
    under it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `share/mysqlsh` directory, located either under MySQL Shell installation
    root or specified by the variable `MYSQLSH_HOME`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Format of the `mysqlshrc.[js|py]` is the same as for the corresponding modes.
    Thus, to pre-load the `CookbookCollection` object, you need to convert `CookbookCollection.js`
    into a module by exporting our object `CookbookCollection`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you need to put two lines in the file `mysqlshrc.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: In the first line we added a directory where our modules are located into the
    modules search path. On the second line we imported the module itself. Object
    `CookbookCollection` is available as a property of the global object `cookbook`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: MySQL Shell uses Node.js modules. Use [Node.js documentation](https://nodejs.org/api/modules.html)
    to find details about how to write and use JavaScript modules in MySQL Shell.
  prefs: []
  type: TYPE_NORMAL
- en: '*CookbookCollectionModule.js* is located in the *mysql_shell* directory of
    the `recipes` distribution.'
  prefs: []
  type: TYPE_NORMAL
- en: To import the Python function `generate_patients_data` in the startup script
    we need to add instruction *import mysqlsh* to our Python file, because at the
    time when the module is loaded, global objects of the MySQL Shell are not yet
    available. We will also change the line
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: to
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: Otherwise Python will fail with an error that the name `session` is not yet
    defined.
  prefs: []
  type: TYPE_NORMAL
- en: We will name our module `cookbook.py` for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: In our function we use local paths from the current directory to the files,
    therefore we will change the default search path to the directory that has all
    datasets in it. To do this we will import module `os` and use its method `chdir`.
    Then we simply import module `cookbook`. Resulting `mysqlshrc.py` will have this
    code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: Module *cookbook.py* is located in the *mysql_shell* directory of the `recipes`
    distribution.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For additional information about customizing MySQL Shell with external scripts,
    see [Customizing MySQL Shell](https://dev.mysql.com/doc/mysql-shell/8.0/en/mysql-shell-customizing.html)
    in the MySQL User Reference Manual.
  prefs: []
  type: TYPE_NORMAL
