<html><head></head><body><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Running Your First BPF Programs"><div class="chapter" id="running_your_first_BPF_programs">
<h1><span class="label">Chapter 2. </span>Running Your First BPF Programs</h1>


<p>The BPF VM is capable of running instructions in response to events triggered by the kernel. However, not all BPF programs have access to all events triggered by the kernel. When you load a program into the BPF VM, you need to decide which type of program you’re running. This informs the kernel about where your program is going to be triggered. It also tells the BPF verifier which helpers are going to be allowed in your program. When you choose the program type, you’re also choosing the interface that your program is implementing. This interface ensures that you have access to the appropriate type of data, and whether your program can access network packets directly or not.</p>

<p>In this chapter, we show you how to write your first BPF programs. We also guide you around the different types of BPF programs that you can create (as of the writing of this book). Over the years, the kernel developers have been adding different entry points to which you can attach BPF programs. This work is not complete yet, and they are finding new ways to take advantage of BPF every day. We’re going to focus on some of the most useful types of programs in this chapter, with the intention of giving you a taste of what you can do with BPF. We go over many additional examples in future chapters on how to write BPF programs.</p>

<p>This chapter will also cover the role that the BPF verifier plays in running your programs. This component validates that your code is safe to execute and helps you to write programs that won’t cause unexpected results, such as memory exhaustion or sudden kernel crashes. But let’s begin with the basics of writing your own BPF programs from scratch.</p>






<section data-type="sect1" data-pdf-bookmark="Writing BPF Programs"><div class="sect1" id="idm46623568851992">
<h1>Writing BPF Programs</h1>

<p>The most common way to write BPF programs is by using a subset of C compiled with LLVM.<a data-type="indexterm" data-primary="C language" data-secondary="BPF programs in" id="idm46623568850264"/><a data-type="indexterm" data-primary="programs (BPF)" data-secondary="writing" id="idm46623568849288"/><a data-type="indexterm" data-primary="LLVM compiler" id="idm46623568848344"/> LLVM is a general-purpose compiler that can emit different types of bytecode. In this case, LLVM will output BPF assembly code that we will load into the kernel later. We’re not going to show you much BPF assembly in this book. After a long discussion, we decided that it’s better to show you examples of how to use it in specific circustances, but you can easily find several references online or in the BPF man pages. We do show short examples of BPF assembly in future chapters, where writing assembly is more appropriate than C, like Seccomp filters to control incoming system calls in the kernel. We talk more about Seccomp in <a data-type="xref" href="ch08.html#kernel_security">Chapter 8</a>.</p>

<p>The kernel provides the syscall <code>bpf</code> to load programs into the BPF VM after they are compiled. This syscall is used for other operations besides loading programs, and you’ll see more usage examples in later chapters. The kernel also provides several utilities that abstract the loading of BPF programs for you.<a data-type="indexterm" data-primary="programs (BPF)" data-secondary="writing" data-tertiary="Hello World example" id="idm46623568844920"/> In this first code example we use those helpers to show you the “Hello World” example of BPF:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;linux/bpf.h&gt;</code>
<code class="cp">#define SEC(NAME) __attribute__((section(NAME), used))</code>

<code class="n">SEC</code><code class="p">(</code><code class="s">"tracepoint/syscalls/sys_enter_execve"</code><code class="p">)</code>
<code class="kt">int</code> <code class="n">bpf_prog</code><code class="p">(</code><code class="kt">void</code> <code class="o">*</code><code class="n">ctx</code><code class="p">)</code> <code class="p">{</code>
  <code class="kt">char</code> <code class="n">msg</code><code class="p">[]</code> <code class="o">=</code> <code class="s">"Hello, BPF World!"</code><code class="p">;</code>
  <code class="n">bpf_trace_printk</code><code class="p">(</code><code class="n">msg</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">msg</code><code class="p">));</code>
  <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code>

<code class="kt">char</code> <code class="n">_license</code><code class="p">[]</code> <code class="n">SEC</code><code class="p">(</code><code class="s">"license"</code><code class="p">)</code> <code class="o">=</code> <code class="s">"GPL"</code><code class="p">;</code></pre>

<p>There are a few interesting concepts in this first program. We’re using the attribute <code>SEC</code> to inform the BPF VM when we want to run this program. <a data-type="indexterm" data-primary="tracepoints" id="idm46623567546168"/>In this case, we will run this BPF program when a tracepoint in an <code>execve</code> system call is detected. Tracepoints are static marks in the kernel’s binary code that allow developers to inject code to inspect the kernel’s execution. We talk in detail about tracepoints in <a data-type="xref" href="ch04.html#tracing_with_bpf">Chapter 4</a>, but for now you need to know only that <code>execve</code> is an instruction that executes other programs. So we’re going to see the message <code>Hello, BPF World!</code> every time the kernel detects that a program executes another program.</p>

<p>At the end of this example we also specify the license for this program. Because the Linux kernel is licensed under GPL, it can load only programs licensed as GPL too. <a data-type="indexterm" data-primary="licenses, GPL" id="idm46623566007288"/>If we set the license to something else, the kernel will refuse to load our program. We’re using <code>bpf_trace_printk</code> to print a message in the kernel tracing log; you can find this log in <em>/sys/kernel/debug/tracing/trace_pipe</em>.</p>

<p>We’re going to use <code>clang</code> to compile this first program into a valid ELF binary file.<a data-type="indexterm" data-primary="clang utility" id="idm46623566960440"/><a data-type="indexterm" data-primary="ELF (Executable and Linkable Format)" data-secondary="compiling program into ELF binary file" id="idm46623562237192"/> This is the format that the kernel expects to load. We’re going to save our first program in a file called <code>bpf_program.c</code> so we can compile it:</p>

<pre data-type="programlisting" data-code-language="bash">clang -O2 -target bpf -c bpf_program.c -o bpf_program.o</pre>

<p>You’ll find some scripts to compile these programs in the <a href="https://oreil.ly/lbpf-repo">GitHub repository with the code example for the book</a>, so you don’t need to memorize this <code>clang</code> command.</p>

<p>Now that we have compiled our first BPF program, we need to load it in the kernel.<a data-type="indexterm" data-primary="programs (BPF)" data-secondary="loading into the kernel" id="idm46623567549704"/> As we mentioned, we use a special helper that the kernel provides to abstract the boilerplate of compiling and loading the program. This helper is called <code>load_bpf_file</code>, and it takes a binary file and tries to load it in the kernel. You can find this helper in the <a href="https://oreil.ly/lbpf-repo">GitHub repository with all the examples in the book</a>, in the <em>bpf_load.h</em> file, as shown here:</p>

<pre data-type="programlisting" data-code-language="c"><code class="cp">#include &lt;stdio.h&gt;</code>
<code class="cp">#include &lt;uapi/linux/bpf.h&gt;</code>
<code class="cp">#include "bpf_load.h"</code>

<code class="kt">int</code> <code class="nf">main</code><code class="p">(</code><code class="kt">int</code> <code class="n">argc</code><code class="p">,</code> <code class="kt">char</code> <code class="o">**</code><code class="n">argv</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="n">load_bpf_file</code><code class="p">(</code><code class="s">"hello_world_kern.o"</code><code class="p">)</code> <code class="o">!=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
    <code class="n">printf</code><code class="p">(</code><code class="s">"The kernel didn't load the BPF program</code><code class="se">\n</code><code class="s">"</code><code class="p">);</code>
    <code class="k">return</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="n">read_trace_pipe</code><code class="p">();</code>

  <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>We’re going to use a script to compile this program and link it as an ELF binary. In this case, we don’t need to specify a target, because this program won’t be loaded in the BPF VM. We need to use an external library, and writing a script makes it easier to put it all together:</p>

<pre data-type="programlisting" data-code-language="c"><code class="n">TOOLS</code><code class="o">=</code><code class="p">..</code><code class="o">/</code><code class="p">..</code><code class="o">/</code><code class="p">..</code><code class="o">/</code><code class="n">tools</code>
<code class="n">INCLUDE</code><code class="o">=</code><code class="p">..</code><code class="o">/</code><code class="p">..</code><code class="o">/</code><code class="p">..</code><code class="o">/</code><code class="n">libbpf</code><code class="o">/</code><code class="n">include</code>
<code class="n">HEADERS</code><code class="o">=</code><code class="p">..</code><code class="o">/</code><code class="p">..</code><code class="o">/</code><code class="p">..</code><code class="o">/</code><code class="n">libbpf</code><code class="o">/</code><code class="n">src</code>
<code class="n">clang</code> <code class="o">-</code><code class="n">o</code> <code class="n">loader</code> <code class="o">-</code><code class="n">l</code> <code class="n">elf</code> \
  <code class="o">-</code><code class="n">I</code><code class="err">$</code><code class="p">{</code><code class="n">INCLUDE</code><code class="p">}</code> \
  <code class="o">-</code><code class="n">I</code><code class="err">$</code><code class="p">{</code><code class="n">HEADERS</code><code class="p">}</code> \
  <code class="o">-</code><code class="n">I</code><code class="err">$</code><code class="p">{</code><code class="n">TOOLS</code><code class="p">}</code> \
  <code class="err">$</code><code class="p">{</code><code class="n">TOOLS</code><code class="p">}</code><code class="o">/</code><code class="n">bpf_load</code><code class="p">.</code><code class="n">c</code> \
  <code class="n">loader</code><code class="p">.</code><code class="n">c</code></pre>

<p>If you want to run this program, you can execute this final binary by using <code>sudo</code>: <code>sudo ./loader</code>. <code>sudo</code> is a Linux command that’s going to give you root privileges in your computer.<a data-type="indexterm" data-primary="sudo command" data-secondary="running BPF program" id="idm46623561560792"/><a data-type="indexterm" data-primary="programs (BPF)" data-secondary="running" id="idm46623561559816"/> If you don’t run this program with <code>sudo</code>, you’ll get an error message because most BPF programs can be loaded in the kernel only by a user who has root privileges.</p>

<p>When you run this program, you’ll start to see our <code>Hello, BPF World!</code> message after a few seconds, even if you’re not doing anything with your computer. This is because programs running behind the scenes in your computer might be executing other <span class="keep-together">programs</span>.</p>

<p>When you stop this program, the message will stop showing up in your terminal. BPF programs are unloaded from the VM as soon as the programs that load them terminate. In the coming chapters, we explore how to make BPF programs persistent, even after their loaders terminate, but we don’t want to introduce too many concepts just yet. This is an important concept to keep in mind because in many situations, you’ll want your BPF programs to run in the background, collecting data from your system, regardless of whether other processes are running.</p>

<p>Now that you’ve seen the basic structure for a BPF program, we can dive into which types of programs you can write, which will give you access to different subsystems within the Linux kernel.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="BPF Program Types"><div class="sect1" id="idm46623568851368">
<h1>BPF Program Types</h1>

<p>Although there is no clear categorization within programs, you’ll quickly realize that all the types covered in this section are divided in two categories, depending on what their main purpose is.<a data-type="indexterm" data-primary="programs (BPF)" data-secondary="types of" id="ix_progtyp"/><a data-type="indexterm" data-primary="BPF" data-secondary="program types" id="ix_BPFprog"/></p>

<p>The first category is <em>tracing</em>. Many of the programs that you can write will help you better understand what’s happening in your system. They give you direct information about the behavior of your system and the hardware it’s running on. They can access memory regions related to specific programs, and extract execution traces from running processes. They also give you direct access to the resources allocated for each specific process, from file descriptors to CPU and memory usage.</p>

<p>The second category is <em>networking</em>. These types of programs allow you to inspect and manipulate the network traffic in your system. They let you filter packets coming from the network interface, or even reject those packets completely. Different types of programs can be attached to different stages of network processing within the kernel. This has advantages and disadvantages. For example, you can attach BPF programs to network events as soon as your network driver receives a packet, but this program will have access to less information about the packet, because the kernel doesn’t have enough information to offer you yet. On the other end of the spectrum, you can attach BPF programs to network events immediately before they are passed to user-space. In this case, you’ll have much more information about the packet, which will help you make better-informed decisions, but you’ll need to pay the cost of completely processing the packet.</p>

<p>The list of program types that we show next is not divided into categories; we’re introducing these types in the chronological order in which they were added to the kernel. We’ve moved the least used of these programs to the end of this section, and we’ll focus for now on the ones that will be more useful for you. If you’re curious about any program that we’re not covering in detail here, you can learn more about all of them in <a href="https://oreil.ly/qXl0F"><code>man 2 bpf</code></a>.</p>








<section data-type="sect2" data-pdf-bookmark="Socket Filter Programs"><div class="sect2" id="idm46623561545288">
<h2>Socket Filter Programs</h2>

<p><code>BPF_PROG_TYPE_SOCKET_FILTER</code> was the first program type to be added to the Linux kernel. <a data-type="indexterm" data-primary="socket filter programs" id="idm46623561543672"/>When you attach a BPF program to a raw socket, you get access to all the packets processed by that socket. Socket filter programs don’t allow you to modify the contents of those packets or to change the destination for those packets; they give you access to them for observability purposes only. The metadata that your program receives contains information related to the network stack such as the protocol type that’s being used to deliver the packet.</p>

<p>We cover socket filtering and other network programs in more detail in <a data-type="xref" href="ch06.html#linux_networking">Chapter 6</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Kprobe Programs"><div class="sect2" id="idm46623561540920">
<h2>Kprobe Programs</h2>

<p>As you’ll see in <a data-type="xref" href="ch04.html#tracing_with_bpf">Chapter 4</a>, in which we talk about tracing, kprobes are functions that you can attach dynamically to certain call points in the kernel.<a data-type="indexterm" data-primary="kprobe programs" id="idm46623561538584"/> BPF kprobe program types allow you to use BPF programs as kprobe handlers. They are defined with the type <code>BPF_PROG_TYPE_KPROBE</code>. The BPF VM ensures that your kprobe programs are always safe to run, which is an advantage from traditional kprobe modules. You still need to remember that kprobes are not considered stable entry points in the kernel, so you’ll need to ensure that your kprobe BPF programs are compatible with the specific kernel versions that you’re using.</p>

<p>When you write a BPF program that’s attached to a kprobe, you need to decide whether it will be executed as the first instruction in the function call or when the call completes. You need to declare this behavior in the section header of your BPF program. For example, if you want to inspect the arguments when the kernel invokes an <code>exec</code> syscall, you’ll attach the program at the beginning of the call. In this case, you need to set the section header <code>SEC("kprobe/sys_exec")</code>. If you want to inspect the returned value of invoking an <code>exec</code> syscall, you need to set the section header <code>SEC("kretprobe/sys_exec")</code>.</p>

<p>We talk a lot more about kprobes in later chapters of this book. They are a fundamental piece to understanding tracing with BPF.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Tracepoint Programs"><div class="sect2" id="idm46623561533528">
<h2>Tracepoint Programs</h2>

<p>This type of program allows you to attach BPF programs to the tracepoint handler provided by the kernel.<a data-type="indexterm" data-primary="tracepoint programs" id="idm46623561532072"/> Tracepoint programs are defined with the type <code>BPF_PROG_TYPE_TRACEPOINT</code>. As you’ll see in <a data-type="xref" href="ch04.html#tracing_with_bpf">Chapter 4</a>, tracepoints are static marks in the kernel’s codebase that allow you to inject arbitrary code for tracing and debugging purposes. They are less flexible than kprobes, because they need to be defined by the kernel beforehand, but they are guaranteed to be stable after their introduction in the kernel. This gives you a much higher level of predictability when you want to debug your system.</p>

<p>All tracepoints in your system are defined within the directory <em>/sys/kernel/debug/tracing/events</em>. There you’ll find each subsystem that includes any tracepoints and that you can attach a BPF program to. One interesting fact is that BPF declares its own tracepoints, so you can write BPF programs that inspect the behavior of other BPF programs. The BPF tracepoints are defined in <em>/sys/kernel/debug/tracing/events/bpf</em>. There, for example, you can find the tracepoint definition for <em>bpf_prog_load</em>. This means you can write a BPF program that inspects when other BPF programs are loaded.</p>

<p>Like kprobes, tracepoints are another fundamental piece to understand tracing with BPF. We talk more about them in the coming chapters and show you how to write programs to take advantage of them.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="XDP Programs"><div class="sect2" id="idm46623561526680">
<h2>XDP Programs</h2>

<p>XDP programs allow you to write code that’s executed very early on when a network packet arrives at the kernel.<a data-type="indexterm" data-primary="XDP programs" id="idm46623561525224"/> They are defined with the type <code>BPF_PROG_TYPE_XDP</code>. It exposes only a limited set of information from the packet given that the kernel has not had much time to process the information itself. Because the packet is executed early on, you have a much higher level of control over how to handle that packet.</p>

<p>XDP programs define several actions that you can control and that allow you to decide what to do with the packet. You can return <code>XDP_PASS</code> from your XDP program, which means that the packet should be passed to the next subsystem in the kernel. You can also return <code>XDP_DROP</code>, which means that the kernel should ignore this packet completely and do nothing else with it. You can also return <code>XDP_TX</code>, which means that the packet should be forwarded back to the network interface card (NIC) that received the packet in the first place.</p>

<p>This level of control opens the door to many interesting programs in the networking layer. XDP has become one of the main components in BPF, which is why we’ve included a specific chapter about it in this book. In <a data-type="xref" href="ch07.html#express_data_path_XDP">Chapter 7</a>, we discuss many powerful use cases for XDP, like implementing programs to protect your network against distributed denial-of-service (DDoS) attacks.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Perf Event Programs"><div class="sect2" id="idm46623561519608">
<h2>Perf Event Programs</h2>

<p>These types of BPF programs allow you to attach your BPF code to <em>Perf events</em>. They are<a data-type="indexterm" data-primary="Perf event programs" id="idm46623561517896"/> defined with the type <code>BPF_PROG_TYPE_PERF_EVENT</code>. Perf is an internal profiler in the kernel that emits performance data events for hardware and software. You can use it to monitor many things, from your computer’s CPU to any software running on your system. When you attach a BPF program to Perf events, your code will be executed every time Perf generates data for you to analyze.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Cgroup Socket Programs"><div class="sect2" id="idm46623561515960">
<h2>Cgroup Socket Programs</h2>

<p>These types of programs allow you to attach BPF logic to control groups (cgroups). <a data-type="indexterm" data-primary="cgroup socket programs" id="idm46623561514664"/>They are defined with the type <code>BPF_PROG_TYPE_CGROUP_SKB</code>. They allow cgroups to control network traffic within the processes that they contain. With these programs, you can decide what to do with a network packet before it’s delivered to a process in the cgroup. Any packet that the kernel tries to deliver to any process in the same cgroup will pass through one of these filters. At the same time, you can decide what to do when a process in the cgroup sends a network packet through that interface.</p>

<p>As you can see, their behavior is similar to <code>BPF_PROG_TYPE_SOCKET_FILTER</code> programs. The main difference is that <code>BPF_PROG_TYPE_CGROUP_SKB</code> programs are attached to all processes within a cgroup, rather than specific processes; this behavior applies to current and future sockets created in the given cgroup. BPF programs attached to cgroups become useful in container environments where groups of processes are constrained by cgroups and where you can apply the same policies to all of them without having to identify each one independently. <a href="https://github.com/cilium/cilium">Cillium</a>, a popular open source project that provides load balancing and security capabilities for Kubernetes, uses cgroup socket programs extensively to apply its policies in groups rather than in isolated containers.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Cgroup Open Socket Programs"><div class="sect2" id="idm46623561509880">
<h2>Cgroup Open Socket Programs</h2>

<p>These types of programs allow you to execute code when any process in a cgroup opens a network socket.<a data-type="indexterm" data-primary="cgroup open socket programs" id="idm46623561508472"/> This behavior is similar to the programs attached to cgroup socket buffers, but instead of giving you access to the packets as they come through the network, they allow you to control what happens when a process opens a new socket. They are defined with the type <code>BPF_PROG_TYPE_CGROUP_SOCK</code>. This is useful to provide security and access control over groups of programs that can open sockets without having to restrict capabilities per process individually.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Socket Option Programs"><div class="sect2" id="idm46623561506472">
<h2>Socket Option Programs</h2>

<p>These types of programs allow you to modify socket connection options at runtime, while a packet transits through <a data-type="indexterm" data-primary="socket option programs" id="idm46623561505048"/>several stages in the kernel’s networking stack. They are attached to cgroups, much like <code>BPF_PROG_TYPE_CGROUP_SOCK</code> and <code>BPF_PROG_TYPE_CGROUP_SKB</code>, but unlike those program types, they can be invoked several times during the connection’s lifecycle. These programs are defined with the type <code>BPF_PROG_TYPE_SOCK_OPS</code>.</p>

<p>When you create a BPF program with this type, your function call receives an argument called <code>op</code> that represents the operation that the kernel is about to execute with the socket connection; therefore, you know at which point the program is invoked in the connection’s lifecycle. With this information in hand, you can access data such as network IP addresses and connection ports, and you can modify the connection options to set timeouts and alter the round-trip delay time for a given packet.</p>

<p>For example, Facebook uses this to set short recovery time objectives (RTOs) for connections within the same datacenter. The RTO is the time that a system, or network connection in this case, is expected to be recovered after a failure. This objective also represents how long the system can be unavailable before suffering from unacceptable consequences. In Facebook’s case, it assumes that machines in the same datacenter should have a short RTO, and Facebook modifies this threshold by using a BPF <span class="keep-together">program</span>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Socket Map Programs"><div class="sect2" id="idm46623561499400">
<h2>Socket Map Programs</h2>

<p><code>BPF_PROG_TYPE_SK_SKB</code> programs give you access to socket maps and socket redirects.<a data-type="indexterm" data-primary="socket map prograams" id="idm46623561497752"/> As you’ll learn in the next chapter, socket maps allow you to keep references to several sockets. When you have these references, you can use special helpers to redirect an incoming packet from a socket to a different socket. This is interesting when you want to implement load-balancing capabilities with BPF. By keeping track of several sockets, you can forward network packets between them without leaving the kernel-space. Projects like Cillium and <a href="https://oreil.ly/wDtfR">Facebook’s Katran</a> make extensive use of these types of programs for network traffic control.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Cgroup Device Programs"><div class="sect2" id="idm46623561495528">
<h2>Cgroup Device Programs</h2>

<p>This type of program allows you to decide whether an operation within a cgroup can be executed for a given device.<a data-type="indexterm" data-primary="cgroup device programs" id="idm46623561494072"/> These programs are defined with the type <code>BPF_PROG_TYPE_CGROUP_DEVICE</code>. The first implementation of cgroups (v1) has a mechanism that allows you to set permissions for specific devices; however, the second iteration of cgroups lacks this feature. This type of program was introduced to supply that functionality. At the same time, being able to write a BPF program gives you more flexibility to set those permissions when you need them.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Socket Message Delivery Programs"><div class="sect2" id="idm46623561492008">
<h2>Socket Message Delivery Programs</h2>

<p>These types of programs let you control whether a message sent to a socket should be delivered. <a data-type="indexterm" data-primary="socket message delivery programs" id="idm46623561464856"/><a data-type="indexterm" data-primary="message delivery programs (socket)" id="idm46623561464136"/>They are defined with the type <code>BPF_PROG_TYPE_SK_MSG</code>. When the kernel creates a socket, it stores the socket in the aforementioned socket map. This map gives the kernel quick access to specific groups of sockets. When you attach a socket message BPF program to a socket map, all messages sent to those sockets will be filtered by the program before delivering them. Before filtering messages, the kernel copies the data in the message so that you can read it and decide what to do with it. These programs have two possible return values: <code>SK_PASS</code> and <code>SK_DROP</code>. You use the first one if you want the kernel to send the message to the socket, and you use the latter one if you want the kernel to ignore the message and not deliver it to the socket.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Raw Tracepoint Programs"><div class="sect2" id="idm46623561461112">
<h2>Raw Tracepoint Programs</h2>

<p>We talked earlier about a type of program that accesses tracepoints in the kernel.<a data-type="indexterm" data-primary="raw tracepoint programs" id="idm46623561459784"/> The kernel developers added a new tracepoint program to address the need of accessing the tracepoint arguments in the raw format held by the kernel. This format gives you access to more detailed information about the task that the kernel is executing; however, it has a small performance overhead. Most of the time, you’ll want to use regular tracepoints in your programs to avoid that performance overhead, but it’s good to keep in mind that you can also access the raw arguments when needed by using raw tracepoints. These programs are defined with the type <code>BPF_PROG_TYPE_RAW_TRACEPOINT</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Cgroup Socket Address Programs"><div class="sect2" id="idm46623561457592">
<h2>Cgroup Socket Address Programs</h2>

<p>This type of program allows you to manipulate the IP addresses and port numbers that user-space programs are attached to when they are controlled by specific cgroups.<a data-type="indexterm" data-primary="cgroup socket address programs" id="idm46623561456072"/> There are use cases when your system uses several IP addresses when you want to ensure that a specific set of user-space programs use the same IP address and port. These BPF programs give you the flexibility to manipulate those bindings when you put those user-space programs in the same cgroup. This ensures that all incoming and outgoing connections from those applications use the IP and port that the BPF program provides. These programs are defined with the following type: <code>BPF_PROG_TYPE_CGROUP_SOCK_ADDR</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Socket Reuseport Programs"><div class="sect2" id="idm46623561454040">
<h2>Socket Reuseport Programs</h2>

<p><code>SO_REUSEPORT</code> is an option in the kernel that allows multiple processes in the same host to be bound to the same port.<a data-type="indexterm" data-primary="socket reuseport prograams" id="idm46623561452280"/> This option allows higher performance in accepted network connections when you want to distribute load across multiple threads.</p>

<p>The <code>BPF_PROG_TYPE_SK_REUSEPORT</code> program type allows you to write BPF programs that hook into the logic that the kernel uses to decide whether it’s going to reuse a port. You can prevent programs from reusing the same port if your BPF program returns <code>SK_DROP</code>, and you also can inform the kernel to follow its own reuse routine when you return <code>SK_PASS</code> from these BPF programs.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Flow Dissection Programs"><div class="sect2" id="idm46623561448968">
<h2>Flow Dissection Programs</h2>

<p>The flow dissector is a component of the kernel that keeps track of the different layers that a network <a data-type="indexterm" data-primary="flow dissection programs" id="idm46623561447496"/>packet needs to go through, from when it arrives to your system to when it’s delivered to a user-space program. It allows you to control the flow of the packet using different classification methods. The built-in dissector in the kernel is called the <em>Flower classifier</em>, and it’s used by firewalls and other filtering devices to decide what to do with specific packets.</p>

<p><code>BPF_PROG_TYPE_FLOW_DISSECTOR</code> programs are designed to hook logic in the flow dissector path. They provide security guarantees that the built-in dissector cannot provide, such as ensuring that the program always terminates, which might not be guaranteed in the built-in dissector. These BPF programs can modify the flow that network packets follow within the kernel.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Other BPF Programs"><div class="sect2" id="idm46623561444520">
<h2>Other BPF Programs</h2>

<p>We’ve talked about program types that we’ve seen used in different environments, but it’s worth noting that there are a few other additional BPF program types that we haven’t covered yet. These are programs that we mention only briefly here:</p>
<dl>
<dt>Traffic classifier programs</dt>
<dd>
<p><code>BPF_PROG_TYPE_SCHED_CLS</code> and <code>BPF_PROG_TYPE_SCHED_ACT</code> are two types of BPF programs that allow you to classify network traffic and modify some properties of the packets in the socket buffer.<a data-type="indexterm" data-primary="traffic classifier programs" id="idm46623561440136"/></p>
</dd>
<dt>Lightweight tunnel programs</dt>
<dd>
<p><code>BPF_PROG_TYPE_LWT_IN</code>, <code>BPF_PROG_TYPE_LWT_OUT</code>, <code>BPF_PROG_TYPE_LWT_XMIT</code> and <code>BPF_PROG_TYPE_LWT_SEG6LOCAL</code> are types of BPF programs that allow you to attach code to the kernel’s lightweight tunnel infrastructure.<a data-type="indexterm" data-primary="lightweight tunnel programs" id="idm46623561436360"/><a data-type="indexterm" data-primary="tunnels, lightweight tunnel programs" id="idm46623561435624"/></p>
</dd>
<dt>Infrared device programs</dt>
<dd>
<p><code>BPF_PROG_TYPE_LIRC_MODE2</code> programs allow you to attach BPF programs via connections to infrared devices, such as remote controllers, for fun.<a data-type="indexterm" data-primary="infrared device programs" id="idm46623561433224"/></p>
</dd>
</dl>

<p>These programs are specialized, and their usage has not been widely adopted for the community.</p>

<p>Next, we talk about how BPF guarantees that your programs won’t cause a catastrophic failure in your system after the kernel loads them. This is an important topic because understanding how a program loads also influences how to write those <span class="keep-together">programs</span>.<a data-type="indexterm" data-primary="programs (BPF)" data-secondary="types of" data-startref="ix_progtyp" id="idm46623561430504"/><a data-type="indexterm" data-primary="BPF (Berkeley Packet Filter)" data-secondary="program types" data-startref="ix_BPFprog" id="idm46623561429224"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="The BPF Verifier"><div class="sect1" id="idm46623561554024">
<h1>The BPF Verifier</h1>

<p>Allowing anyone to execute arbitrary code inside the Linux kernel always sounds like a terrible idea at first. <a data-type="indexterm" data-primary="verifier" id="ix_veri"/>The risk of running BPF programs in production systems would be too high if it weren’t for the BPF verifier. In the words of Dave S. Miller, one of the kernel networking maintainers, “The only thing sitting between our eBPF programs and a deep dark chasm of destruction is the eBPF verifier.”</p>

<p>Obviously, the BPF verifier is also a program running on your system, and it’s the object of high scrutiny to ensure that it does its job correctly. In the past years, security researchers have discovered some vulnerabilities in the verifier that allowed attackers to access random memory in the kernel, even as unprivileged users. You can read more about vulnerabilities like that one in the Common Vulnerabilities and Exposures (CVE) catalog, a list of known security threads sponsored by the United States Department of Homeland Security. For example, CVE-2017-16995 describes how any user could read and write kernel memory and bypass the BPF verifier.</p>

<p>In this section we guide you through the measures that the verifier takes to prevent problems like the one just described.</p>

<p>The first check that the verifier performs is a static analysis of the code that the VM is going to load. The objective of this first check is to ensure that the program has an expected end. To do this, the verifier creates a direct acyclic graph (DAG) with the code. Each instruction that the verifier analyzes becomes a node in the graph, and each node is linked to the next instruction. After the verifier generates this graph, it performs a depth first search (DFS) to ensure that the program finishes and the code doesn’t include dangerous paths. This means it will traverse each branch of the graph, all the way to the bottom of the branch, to guarantee that there are no recursive cycles.</p>

<p>These are the conditions why the verifier might reject your code during this first check:</p>

<ul>
<li>
<p>The program doesn’t include control loops. To ensure that the program doesn’t get stuck in an infinite loop, the verifier rejects any kind of control loop. There have been proposals to allow loops in BPF programs, but as of this writing, none of them has been adopted.</p>
</li>
<li>
<p>The program doesn’t try to execute more instructions than the maximum allowed by the kernel. At this time, the maximum number of instructions to execute is 4,096. This limitation is in place to prevent BPF from running forever. In <a data-type="xref" href="ch03.html#bpf_maps">Chapter 3</a>, we discuss how to nest different BPF programs to work around this limitation in a safe way.</p>
</li>
<li>
<p>The program doesn’t include any unreachable instruction, such as conditions or functions that are never executed. This prevents loading dead code in the VM, which would also delay the termination of the BPF program.</p>
</li>
<li>
<p>The program doesn’t try to jump outside its bounds.</p>
</li>
</ul>

<p>The second check that the verifier performs is a dry run of the BPF program. This means that the verifier will try to analyze every instruction that the program is going to execute to ensure that it doesn’t execute any invalid instruction. This execution also checks that all memory pointers are accessed and dereferenced correctly. Finally, the dry run informs the verifier about the control flows in the program to ensure that no matter which control path the program takes, it arrives to the <code>BPF_EXIT</code> instruction. To do this, the verifier keeps track of all visited branch paths in a stack, which it evaluates before taking a new path to ensure that it doesn’t visit a specific path more than once. After these two checks pass, the verifier considers the program to be safe to <span class="keep-together">execute</span>.</p>

<p>The <code>bpf</code> syscall allows you to debug the verifier’s checks if you’re interested in seeing how your programs are analyzed.<a data-type="indexterm" data-primary="bpf system calls" data-secondary="debugging verifier's checks" id="idm46623561412968"/> When you load a program with this syscall, you can set several attributes that will make the verifier print its operation log:</p>

<pre data-type="programlisting" data-code-language="c"><code class="k">union</code> <code class="n">bpf_attr</code> <code class="n">attr</code> <code class="o">=</code> <code class="p">{</code>
  <code class="p">.</code><code class="n">prog_type</code> <code class="o">=</code> <code class="n">type</code><code class="p">,</code>
  <code class="p">.</code><code class="n">insns</code>     <code class="o">=</code> <code class="n">ptr_to_u64</code><code class="p">(</code><code class="n">insns</code><code class="p">),</code>
  <code class="p">.</code><code class="n">insn_cnt</code>  <code class="o">=</code> <code class="n">insn_cnt</code><code class="p">,</code>
  <code class="p">.</code><code class="n">license</code>   <code class="o">=</code> <code class="n">ptr_to_u64</code><code class="p">(</code><code class="n">license</code><code class="p">),</code>
  <code class="p">.</code><code class="n">log_buf</code>   <code class="o">=</code> <code class="n">ptr_to_u64</code><code class="p">(</code><code class="n">bpf_log_buf</code><code class="p">),</code>
  <code class="p">.</code><code class="n">log_size</code>  <code class="o">=</code> <code class="n">LOG_BUF_SIZE</code><code class="p">,</code>
  <code class="p">.</code><code class="n">log_level</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
<code class="p">};</code>

<code class="n">bpf</code><code class="p">(</code><code class="n">BPF_PROG_LOAD</code><code class="p">,</code> <code class="o">&amp;</code><code class="n">attr</code><code class="p">,</code> <code class="k">sizeof</code><code class="p">(</code><code class="n">attr</code><code class="p">));</code></pre>

<p>The <code>log_level</code> field tells the verifier whether to print any log. It will print its log when you set it to 1, and it won’t print anything if you set it to 0. If you want to print the verifier log, you also need to provide a log buffer and its size. This buffer is a multiline string that you can print to inspect the decisions that the verifier took.</p>

<p>The BPF verifier plays a big role in keeping your system secure and available while you run arbitrary programs within the kernel, although it might be difficult to understand why it makes some decisions sometimes. Don’t despair if you bump into verification issues trying to load your programs. During the rest of this book, we guide you through safe examples that will help you understand how to write your own programs in a secure way too.</p>

<p>The next section covers how BPF structures program information in memory. The way a program structured will help make clear how to access the BPF internals, helping you debug and understand how programs behave.<a data-type="indexterm" data-primary="verifier" data-startref="ix_veri" id="idm46623561346456"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="BPF Type Format"><div class="sect1" id="idm46623561427784">
<h1>BPF Type Format</h1>

<p>The BPF Type Format (BTF) is a collection of metadata structures that enhances the debug information for BPF programs, maps, and functions.<a data-type="indexterm" data-primary="BTF (BPF Type Format)" id="idm46623561344168"/> BTF includes source information, so tools like BPFTool, which we talk about in <a data-type="xref" href="ch05.html#bpf_utilities">Chapter 5</a>, can show you a much richer interpretation of BPF data. This metadata is stored in the binary program under a special “.BFT” metadata section. BTF information is useful to make your programs easier to debug, but it increases the size of binary files significantly because it needs to keep track of type information for everything declared in your program. The BPF verifier also uses this information to ensure that the structure types defined by your program are correct.</p>

<p>BTF is used exclusively to annotate C types.<a data-type="indexterm" data-primary="C language" data-secondary="annotating C types with BPF Type Format" id="idm46623561341592"/> BPF compilers like LLVM know how to include that information for you, so you don’t need to go through the cumbersome task of adding that information to each structure. However, in some cases, the toolchain still needs some annotations to enhance your programs. In later chapters we describe how those annotations come into play and how tools like BPFTool display this information.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="BPF Tail Calls"><div class="sect1" id="idm46623561339864">
<h1>BPF Tail Calls</h1>

<p>BPF programs can call other BPF programs by using <em>tail calls</em>.<a data-type="indexterm" data-primary="tail calls" id="idm46623561338088"/> This is a powerful feature because it allows you to assemble more complex programs by combining smaller BPF functions. Kernel versions prior to 5.2 have a hard limit on the number of machine instructions that a BPF program can generate. This limit was set to 4,096 to ensure that programs can terminate in a reasonable amount of time. However, as people built more complex BPF programs, they needed a way to extend the instruction limit imposed by the kernel, and this is where tail calls come into play. The instruction limit increases to one million instructions starting in version 5.2 of the kernel. Tail call nesting is also limited, to 32 calls in this case, which means that you can combine up to 32 programs in a chain to generate a more complex solution to your <span class="keep-together">problems</span>.</p>

<p>When you call a BPF program from another BPF program, the kernel resets the program context completely. It’s important to keep this in mind because you’ll probably need a way to share information between <span class="keep-together">programs</span>. The context object that each BPF program receives as its argument won’t help us with this data sharing problem. In the next chapter, we talk about BPF maps as a way to share information between <span class="keep-together">programs</span>. There we also show you an example of how to use tail calls to jump from one BPF program to another.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46623561333160">
<h1>Conclusion</h1>

<p>In this chapter we guided you through the first code examples to understand BPF programs. We also described all the types of programs that you can write with BPF. Don’t worry if some of the concepts presented here don’t make sense yet; as we advance through the book, we show you more examples of those programs. We also covered the important verification steps that BPF takes to ensure that your programs are safe to run.</p>

<p>In the next chapter we dive a little bit more into those programs and show more examples. We also talk about how BPF programs communicate with their counterparts in user-space and how they share information.</p>
</div></section>







</div></section></body></html>