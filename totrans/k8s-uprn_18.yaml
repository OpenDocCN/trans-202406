- en: Chapter 18\. Accessing Kubernetes from Common Programming Languages
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章. 从常见编程语言访问 Kubernetes
- en: Though most of this book is dedicated to using declarative YAML configurations,
    either directly via `kubectl` or through tools like Helm, there are situations
    when it is necessary to interact with the Kubernetes API directly from a programming
    language. For example, the authors of the [Helm tool](https://helm.sh) itself
    needed to write that application in a programming language. More generally, this
    is common if you need to write some additional tool, like a `kubectl` plug-in,
    or a more complex piece of code, like a Kubernetes operator.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本书大部分内容都致力于使用声明性 YAML 配置，直接通过 `kubectl` 或者像 Helm 这样的工具，但有些情况下必须直接从编程语言与 Kubernetes
    API 进行交互。例如，[Helm 工具](https://helm.sh) 的作者们就需要用编程语言来编写该应用程序。更普遍地说，如果你需要编写额外的工具，比如
    `kubectl` 插件，或者像 Kubernetes 运算符这样的更复杂的代码，这是很常见的情况。
- en: Much of the Kubernetes ecosystem is written in the Go programming language.
    As a result, the Go language has the richest and most extensive client. However,
    there are a high-quality clients for most common programming languages (and even
    some uncommon ones as well). Because there is already so much documentation and
    so many examples of how to use the Go client, this chapter will cover the basics
    of interacting with the Kubernetes API server with examples in Python, Java, and
    .NET.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 生态系统的大部分内容都是用 Go 编程语言编写的。因此，Go 语言拥有最丰富和最广泛的客户端。不过，对于大多数常见的编程语言（甚至一些不常见的语言），都有高质量的客户端。由于已经有了大量关于如何使用
    Go 客户端的文档和示例，本章将涵盖使用 Python、Java 和 .NET 示例与 Kubernetes API 服务器进行交互的基础知识。
- en: 'The Kubernetes API: A Client’s Perspective'
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes API：客户端视角
- en: At the end of the day, the Kubernetes API server is just an HTTP(S) server and
    that is exactly how each client library perceives it, though each client has a
    lot of additional logic that implements the various API calls and serializes to
    and from JSON. Given this, you might be tempted to simply use a plain HTTP client
    to work with the Kubernetes APIs, but the client libraries wrap these various
    HTTP calls into meaningful APIs that make your code more readable (e.g., `readNamespacedPod(...)`),
    and meaningful typed object-models that facilitate static type checking and therefore
    result in fewer bugs (e.g., `Deployment`). Perhaps more importantly, the client
    libraries also implement Kubernetes-specific capabilities, like loading authorization
    information from a *kubeconfig* file or from a Pod’s environment. The clients
    also provide implementations of the non-RESTful parts of the Kubernetes API surface
    area like port-forward, logs, and watches. We’ll describe these advanced capabilities
    in later sections.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 归根结底，Kubernetes API 服务器只是一个 HTTP(S) 服务器，每个客户端库都会以此方式来看待它，尽管每个客户端都有大量的附加逻辑来实现各种
    API 调用，并且在 JSON 序列化和反序列化方面。因此，你可能会倾向于简单地使用普通的 HTTP 客户端来处理 Kubernetes API，但客户端库会将这些不同的
    HTTP 调用封装成有意义的 API（例如 `readNamespacedPod(...)`），以使你的代码更易读，并提供有意义的类型化对象模型，从而促进静态类型检查，减少错误（例如
    `Deployment`）。也许更重要的是，客户端库还实现了 Kubernetes 特定的功能，如从 *kubeconfig* 文件或 Pod 环境中加载授权信息。客户端还提供了
    Kubernetes API 表面的非 RESTful 部分的实现，如端口转发、日志和监听功能。我们将在后续章节中描述这些高级功能。
- en: OpenAPI and Generated Client Libraries
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OpenAPI 和生成的客户端库
- en: The set of resources and functions in the Kubernetes API is huge. There are
    many different resources in different API groups and many different operations
    on each of these resources. Keeping up with all of these different resources and
    resource versions would be a massive (and unmistakably boring) undertaking if
    developers had to hand-author all of these API calls. Especially when considering
    that clients have to be handwritten across each of the programming languages.
    Instead, the clients take a different approach, and the basics of interacting
    with the Kubernetes API server are all generated by a computer program that is
    sort of like a compiler in reverse. The code generator for the API clients takes
    a data specification for the Kubernetes API and uses this specification to generate
    a client for a specific language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 中的资源和功能集合非常庞大。不同的 API 组中有许多不同的资源，以及每个资源上的许多不同操作。如果开发者需要手工编写所有这些
    API 调用，那将是一个非常庞大（并且无疑令人枯燥）的任务。特别是考虑到客户端必须在各种编程语言中手工编写。相反，客户端采用了不同的方法，与 Kubernetes
    API 服务器进行交互的基础都是由一个类似于反向编译器的计算机程序生成的。API 客户端的代码生成器采用 Kubernetes API 的数据规范，并使用这些规范为特定语言生成客户端。
- en: The Kubernetes API is expressed in a format known as OpenAPI, which is the most
    common schema for representing RESTful APIs. To give you a sense of the size of
    the Kubernetes API, the [OpenAPI specification](https://oreil.ly/3gRIW) found
    on GitHub is over four megabytes in size. That’s a pretty big text file! The official
    Kubernetes client libraries are all generated using the same core code generation
    logic, which can be found on [GitHub](https://oreil.ly/F39uK). It is unlikely
    that you will actually have to generate the client libraries yourself, but nonetheless,
    it is useful to understand the process by which these libraries are created. In
    particular, because most of the client code is generated, updates and fixes can’t
    be made directly in the generated client code, since it would be overwritten the
    next time the API was generated. Instead, when an error in a client is found,
    fixes need to be made to either the OpenAPI specification (if the error is in
    the specification itself) or the code generator (if the error is in the generated
    code). Although this process can seem excessively complex, it is the only way
    that a small number of Kubernetes client authors can keep up with the breadth
    of the Kubernetes API.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 采用称为 OpenAPI 的格式表示，这是表示 RESTful API 的最常见模式。为了让你感受到 Kubernetes
    API 的规模，GitHub 上的 [OpenAPI 规范](https://oreil.ly/3gRIW) 文件大小超过四兆字节。这是一个相当大的文本文件！所有官方的
    Kubernetes 客户端库都是使用相同的核心代码生成逻辑生成的，你可以在 [GitHub](https://oreil.ly/F39uK) 上找到这些逻辑。虽然你不太可能需要自己生成客户端库，但了解生成这些库的过程仍然是有用的。特别是因为大部分客户端代码是生成的，因此无法直接在生成的客户端代码中进行更新和修复，因为下次生成
    API 时会被覆盖。因此，当发现客户端中的错误时，需要修复 OpenAPI 规范（如果错误在规范本身中）或代码生成器（如果错误在生成的代码中）。尽管这个过程看起来过于复杂，但这是少数
    Kubernetes 客户端作者能够跟上 Kubernetes API 广度的唯一方式。
- en: But What About kubectl x?
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 但是 `kubectl x` 呢？
- en: When you start implementing your own logic for interacting with the Kubernetes
    API, it probably won’t be long before you find yourself asking how to do `kubectl
    x`. Most people start with the `kubectl` tool when they learn Kubernetes and consequently
    expect that there is a 1-1 mapping between the capabilities in `kubectl` and the
    Kubernetes API. While some commands are directly represented in the Kubernetes
    API (e.g., `kubectl get pods`), most of the more sophisticated features are actually
    a larger number of API calls with complex logic in the `kubectl` tool.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始实现自己的逻辑与 Kubernetes API 交互时，可能不久就会想知道如何执行 `kubectl x`。大多数人在学习 Kubernetes
    时都是从 `kubectl` 工具开始的，因此他们预期 `kubectl` 和 Kubernetes API 之间有一对一的映射关系。虽然某些命令在 Kubernetes
    API 中直接表示（例如 `kubectl get pods`），但大多数更复杂的功能实际上是通过多个具有复杂逻辑的 API 调用在 `kubectl` 工具中实现的。
- en: This balance between client-side and server-side features has been a design
    trade-off since the beginning of Kubernetes. Many features that are now present
    in the API server began as client-side implementations in `kubectl`. For example,
    the rollout capabilities now implemented on the server by the Deployment resource
    were previously implemented in the client. Likewise, until recently, `kubectl
    apply ...` was only available within the command-line tool, but was migrated to
    the server as the server-side `apply` capabilities that will be discussed later
    in this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Kubernetes 起初以来，客户端和服务器端功能之间的平衡一直是一个设计折衷。现在在 API 服务器上实现的许多功能最初是在 `kubectl`
    中作为客户端实现的。例如，现在由 Deployment 资源在服务器上实现的发布功能，以前是在客户端上实现的。同样，直到最近，`kubectl apply
    ...` 只能在命令行工具内使用，但已迁移到服务器作为服务器端的 `apply` 功能，将在本章后面讨论。
- en: Despite the general trajectory toward server-side implementations, there are
    still significant capabilities that remain in the client. Each of these capabilities
    must be reimplemented in each client library. Parity with the `kubectl` command
    line tool varies between languages. The Java client in particular has built a
    thick client that emulates much of the `kubectl` functionality.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管总体上朝向服务器端实现发展，仍然有一些显著功能留在客户端。这些功能必须在每个客户端库中重新实现。不同语言之间的与 `kubectl` 命令行工具的兼容性也各不相同。特别是
    Java 客户端已经构建了一个模拟大部分 `kubectl` 功能的厚客户端。
- en: If you can’t find the functionality that you are looking for in your client
    library, a useful trick is to add the `--v=10` flag to your `kubectl` command.
    That will turn on verbose logging, including all of the HTTP requests and responses
    sent to the Kubernetes API server. You can use this logging to reconstruct much
    of what `kubectl` is doing. If you still need to dig deeper, the `kubectl` source
    code is also available within the Kubernetes repository.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在您的客户端库中找不到所需的功能，一个有用的技巧是在您的 `kubectl` 命令中添加 `--v=10` 标志。这将打开详细日志记录，包括发送到
    Kubernetes API 服务器的所有 HTTP 请求和响应。您可以使用此日志来重构 `kubectl` 所做的大部分工作。如果您仍然需要深入挖掘，`kubectl`
    的源代码也可以在 Kubernetes 仓库中找到。
- en: Programming the Kubernetes API
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程 Kubernetes API
- en: Now you have a deeper perspective about how the Kubernetes API works and how
    the client and server interact. In the following sections, we’ll go through how
    to authenticate to the Kubernetes API server and interact with resources. We’ll
    close with advanced topics from writing operators to interacting with Pods for
    interactive operations.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您对 Kubernetes API 如何工作以及客户端和服务器如何交互有了更深入的理解。在接下来的章节中，我们将介绍如何对 Kubernetes API
    服务器进行认证并与资源进行交互。最后，我们将涉及从编写运算符到与 Pod 进行交互操作的高级主题。
- en: Installing the Client Libraries
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装客户端库
- en: 'Before you can start programming with the Kubernetes API, you need to find
    the client libraries. We will be using the official client libraries produced
    by the Kubernetes project itself, though there are also a number of high-quality
    clients developed as independent projects. The client libraries are all hosted
    under the kubernetes-client repository on GitHub:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Kubernetes API 进行编程之前，您需要找到客户端库。我们将使用 Kubernetes 项目本身生产的官方客户端库，尽管也有许多作为独立项目开发的高质量客户端。这些客户端库都托管在
    GitHub 上的 kubernetes-client 仓库下：
- en: '[Python](https://oreil.ly/ku6mT)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Python](https://oreil.ly/ku6mT)'
- en: '[Java](https://oreil.ly/aUSkD)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Java](https://oreil.ly/aUSkD)'
- en: '[.NET](https://oreil.ly/9J8iy)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[.NET](https://oreil.ly/9J8iy)'
- en: Each of these projects features a compatibility matrix to show which versions
    of the client work with which versions of the Kubernetes API and also give instructions
    for installing the libraries using the package managers (e.g., `npm`) associated
    with a particular programming language.^([1](ch18.xhtml#idm45664072010864))
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目中的每一个都具有兼容性矩阵，显示客户端的哪些版本适用于 Kubernetes API 的哪些版本，并提供使用特定编程语言的软件包管理器（例如 `npm`）安装库的说明。^([1](ch18.xhtml#idm45664072010864))
- en: Authenticating to the Kubernetes API
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证到 Kubernetes API
- en: The Kubernetes API server wouldn’t be very safe if it allowed anyone in the
    world to access it and read or write the resources that it orchestrates. Consequently,
    the first step in programming the Kubernetes API is connecting to it and identifying
    yourself for authentication. Because the API server is an HTTP server at its core,
    these methods of authentication are core HTTP authentication methods. The very
    first implementations of Kubernetes used basic HTTP authentication via a user
    and password combination, but this approach has been deprecated in favor of more
    modern authentication infrastructure.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许世界上任何人访问 Kubernetes API 并读取或写入其编排的资源，那么 Kubernetes API 服务器将不会很安全。因此，编程访问
    Kubernetes API 的第一步是连接到 API 并进行身份验证。由于 API 服务器在其核心是一个 HTTP 服务器，所以这些身份验证方法是核心的
    HTTP 身份验证方法。最初的 Kubernetes 实现使用基本的 HTTP 身份验证通过用户和密码组合进行身份验证，但是这种方法已被更现代的身份验证基础设施所取代。
- en: If you have been using the `kubectl` command-line tool for your interactions
    with Kubernetes, you may not have considered the implementation details of authentication.
    Fortunately, the client libraries generally make it easy to connect to the API.
    However, a basic understanding of how Kubernetes authentication works is still
    useful for debugging when things go wrong.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您一直使用 `kubectl` 命令行工具与 Kubernetes 交互，可能未考虑过认证的实现细节。幸运的是，客户端库通常使连接到 API 变得简单。但是，了解
    Kubernetes 认证的基本工作原理仍然有助于在出现问题时进行调试。
- en: 'There are two basic ways that the `kubectl` tool and clients obtain authentication
    information: from a kubeconfig file and from the context of a Pod within the Kubernetes
    cluster.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 工具和客户端获取认证信息的两种基本方式：来自 kubeconfig 文件和来自 Kubernetes 集群中 Pod 的上下文。'
- en: 'Code that is not running inside a Kubernetes cluster requires a kubeconfig
    file to provide the necessary information for authentication. By default, the
    client searches for this file in *${HOME}/.kube/config* or the `$KUBECONFIG` environment
    variables. If the `KUBECONFIG` variable is present, it takes precedence over any
    config file located in the default home location. The kubeconfig file contains
    all of the information necessary to access the Kubernetes API server. The clients
    all have easy-to-use calls to create a client either from the default locations
    or from a kubeconfig file supplied in the code itself:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 不在 Kubernetes 集群内运行的代码需要一个 kubeconfig 文件来提供认证所需的信息。默认情况下，客户端会在 *${HOME}/.kube/config*
    或 `$KUBECONFIG` 环境变量指定的位置搜索此文件。如果存在 `KUBECONFIG` 变量，则优先于默认的主目录位置中的任何配置文件。kubeconfig
    文件包含访问 Kubernetes API 服务器所需的所有信息。客户端都有易于使用的调用方式，可以从默认位置或代码中提供的 kubeconfig 文件创建客户端：
- en: '*Python*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*Java*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*.NET*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Authentication for many cloud providers occurs via an external executable that
    knows how to generate a token for the Kubernetes cluster. This executable is often
    installed as part of the cloud provider’s command-line tooling. When you write
    code to interact with the Kubernetes API, you need to make sure that this executable
    is also available in the context where the code is running so that it can be executed
    to obtain the token.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 许多云提供商的认证通过一个外部可执行文件完成，该文件知道如何为 Kubernetes 集群生成令牌。此可执行文件通常作为云提供商命令行工具的一部分安装。当您编写与
    Kubernetes API 交互的代码时，需要确保在代码运行的上下文中也可执行此可执行文件以获取令牌。
- en: 'Within the context of a Pod in a Kubernetes cluster, the code running in the
    Pod has access to a Kubernetes service account that is associated with that Pod.
    The files containing the relevant token and certificate authority are placed into
    the Pod by Kubernetes as a volume when the Pod is created. Within a Kubernetes
    cluster, the API server is always available at a fixed DNS name, generally `kubernetes`.
    Because all of the necessary data is present in the Pod, a kubeconfig file is
    unnecessary and the client can synthesize its configuration from its context.
    The clients all have easy-to-use calls to create such an “in cluster” client:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群中 Pod 的上下文中，运行在 Pod 中的代码可以访问与该 Pod 关联的 Kubernetes 服务账户。包含相关令牌和证书授权的文件在创建
    Pod 时由 Kubernetes 作为卷放置在 Pod 中。在 Kubernetes 集群中，API 服务器始终位于固定的 DNS 名称下，通常为 `kubernetes`。因为
    Pod 中存在所有必要的数据，所以不需要 kubeconfig 文件，客户端可以从其上下文中合成其配置。客户端都有易于使用的调用方式来创建这样的“集群内”客户端：
- en: '*Python*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '*Java*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '*.NET*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The default service account associated with Pods has minimal roles (RBAC) granted
    to it. This means that by default, the code running in a Pod can’t do much with
    the Kubernetes API. If you are getting authorization errors, you may need to adjust
    the service account to one that is specific to your code and has access to the
    necessary roles in the cluster.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Pod 相关联的默认服务账户被授予了最低的角色（RBAC）。这意味着，默认情况下，运行在 Pod 中的代码对 Kubernetes API 的操作有限。如果你遇到授权错误，可能需要调整服务账户，选择一个特定于你的代码并具有集群中必要角色权限的账户。
- en: Accessing the Kubernetes API
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问 Kubernetes API
- en: The most common ways that people interact with the Kubernetes API is via basic
    operations like creating, listing, and deleting resources. Because all of the
    clients are generated from the same OpenAPI specification, they all follow the
    same rough pattern. Before diving into the code, there are a couple more details
    of the Kubernetes API that are necessary to understand.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 人们与 Kubernetes API 交互的最常见方式是通过基本操作，如创建、列出和删除资源。因为所有客户端都是从相同的 OpenAPI 规范生成的，它们都遵循相同的大致模式。在深入代码之前，还有几个关于
    Kubernetes API 的细节是必须理解的。
- en: In Kubernetes, there is a distinction between namespaced and cluster-level resources.
    *Namespaced* resources exist within a Kubernetes namespace; for example, a Pod
    or Deployment may exist in the `kube-system` namespace. *Cluster-level* resources
    exist only once throughout the entire cluster. The most obvious example of such
    a resource is a Namespace, but other cluster-level resources include CustomResourceDefinitions
    and ClusterRoleBindings. This distinction is important because it is preserved
    in the function calls that you use to access the resources. For example, to list
    Pods in the `default` namespace in Python, you would write `api.list_namespaced_pods('default')`.
    To list Namespaces, you would write `api.list_namespaces()`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，有命名空间和集群级别的资源区别。*命名空间* 资源存在于 Kubernetes 命名空间内；例如，Pod 或 Deployment
    可能存在于 `kube-system` 命名空间中。*集群级别* 资源则只存在于整个集群中的一个实例。最明显的例子是 Namespace，但其他集群级别的资源还包括
    CustomResourceDefinitions 和 ClusterRoleBindings。这种区别很重要，因为它在你访问资源时的函数调用中得以体现。例如，要在
    Python 中列出 `default` 命名空间中的 Pods，你需要编写 `api.list_namespaced_pods('default')`。要列出命名空间，你需要编写
    `api.list_namespaces()`。
- en: The second concept you need to understand is an *API group*. In Kubernetes,
    all of the resources are grouped into different sets of APIs. This is largely
    hidden from users of the `kubectl` tool, though you may have seen it within the
    `apiVersion` field in a YAML specification of a Kubernetes object. When programming
    against the Kubernetes API, this grouping becomes important, because often each
    API group has its own client for interacting with that set of resources. For example,
    to create a client to interact with a Deployment resource (which exists in the
    `apps/v1` API group and version) you create a `new AppsV1Api()` object that knows
    how to interact with all resources in the `apps/v1` API group and version. An
    example of how to create a client for an API group is shown in the following section.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个你需要理解的概念是*API组*。在 Kubernetes 中，所有资源都被分组到不同的 API 集合中。尽管使用 `kubectl` 工具的用户可能不太会注意到这一点，但你可能在
    Kubernetes 对象的 YAML 规范的 `apiVersion` 字段中看到过。当针对 Kubernetes API 进行编程时，这种分组变得很重要，因为通常每个
    API 组都有其自己的客户端来与该组资源进行交互。例如，要创建一个用于与 Deployment 资源交互的客户端（该资源存在于 `apps/v1` API
    组和版本中），你需要创建一个 `new AppsV1Api()` 对象，它知道如何与 `apps/v1` API 组和版本中的所有资源进行交互。如何为 API
    组创建客户端的示例将在以下部分展示。
- en: 'Putting It All Together: Listing and Creating Pods in Python, Java, and .NET'
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有内容汇总：在 Python、Java 和 .NET 中列出和创建 Pods
- en: 'We’re now ready to actually write some code. Begin by creating a client object,
    then use that to list the Pods in the “default” namespace; here is code to do
    that in Python, Java, and .NET:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好实际编写一些代码了。首先创建一个客户端对象，然后使用它来列出“default”命名空间中的 Pods；以下是在 Python、Java
    和 .NET 中实现的代码：
- en: '*Python*'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '*Java*'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '*.NET*'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE8]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once you have figured out how to list, read, and delete objects, the next common
    task is creating new objects. The API call to create the object is easy enough
    to figure out (e.g., `create_namespaced_pod` in Python), but actually defining
    the new Pod resources can be more complicated.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你弄清楚如何列出、读取和删除对象，下一个常见任务就是创建新对象。调用 API 来创建对象是相对容易理解的（例如，在 Python 中使用 `create_namespaced_pod`），但实际定义新
    Pod 资源可能更加复杂。
- en: 'Here’s how you create a Pod in Python, Java, and .NET:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是在 Python、Java 和 .NET 中创建 Pod 的方法：
- en: '*Python*'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*Java*'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '*.NET*'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Creating and Patching Objects
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和修补对象
- en: 'When you explore the client API for Kubernetes, you will notice that there
    are seemingly three different ways to manipulate resources, namely `create`, `replace`,
    and `patch`. These three verbs represent slightly different semantics for interacting
    with resources:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当你探索 Kubernetes 的客户端 API 时，你会注意到似乎有三种不同的方法来操作资源，分别是`create`、`replace`和`patch`。这三个动词代表着与资源交互的略微不同的语义：
- en: Create
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Create
- en: As you can tell from the name, this creates a new resource. However, it will
    fail if the resource already exists.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名称所示，这将创建一个新的资源。但是，如果资源已经存在，则会失败。
- en: Replace
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Replace
- en: This replaces an existing resource completely, without looking at the existing
    resource. When you use `replace`, you have to specify a complete resource.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完全替换现有资源，而不查看现有资源。当使用`replace`时，必须指定完整的资源。
- en: Patch
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Patch
- en: This modifies an existing resource, leaving untouched the parts of the resource
    that did not change. When using `patch`, you use a special Patch resource rather
    than sending the resource (e.g., the Pod) that you are modifying.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这修改了现有资源，未改变资源的未更改部分。在使用`patch`时，您使用特殊的 Patch 资源而不是发送要修改的资源（例如 Pod）。
- en: Note
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Patching a resource can be complicated. In many cases, it is easier to just
    replace it. However, in some cases, especially with large resources, patching
    the resource can be much more efficient in terms of network bandwidth and API
    server processing. Additionally, multiple actors can patch different parts of
    the resource simultaneously without worrying about write conflicts, which reduces
    overhead.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对资源进行修补可能会很复杂。在许多情况下，直接替换会更容易。然而，在某些情况下，特别是对于大型资源，修补资源在网络带宽和 API 服务器处理方面可能更高效。此外，多个操作者可以同时修补资源的不同部分，而无需担心写冲突，这减少了开销。
- en: 'To patch a Kubernetes resource, you have to create a Patch object representing
    the change that you want to make to the resource. There are three formats for
    this patch supported by Kubernetes: JSON Patch, JSON Merge Patch, and strategic
    merge patch. The first two patch formats are RFC standards used in other places,
    and the third is a Kubernetes-developed patch format. Each of the patch formats
    has advantages and disadvantages. In these examples, we will use JSON Patch because
    it is the simplest to understand.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要修补 Kubernetes 资源，必须创建一个表示要对资源进行的更改的 Patch 对象。Kubernetes 支持三种此补丁的格式：JSON Patch、JSON
    Merge Patch 和策略性合并补丁。前两种补丁格式是其他地方使用的 RFC 标准，第三种是 Kubernetes 开发的补丁格式。每种补丁格式都有优缺点。在这些示例中，我们将使用
    JSON Patch，因为它最简单易懂。
- en: 'Here’s how you patch a Deployment to increase the replicas to three:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何将 Deployment 修补以增加副本数到三个的方法：
- en: '*Python*'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '*Java*'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*.NET*'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE14]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In each of these code samples, the Deployment resource has been patched to set
    the number of replicas in the deployment to three.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些代码示例中，Deployment 资源已被修补以将部署中的副本数设置为三。
- en: Watching Kubernetes APIs for Changes
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监视 Kubernetes API 的变化
- en: Resources in Kubernetes are declarative. They represent the desired state of
    the system. To make that desired state a reality, a program must watch the desired
    state for changes and take action to make the current state of the world match
    the desired state.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的资源是声明性的。它们代表系统的期望状态。为了使这个期望的状态成为现实，程序必须监视期望的状态以进行更改，并采取行动使世界的当前状态与期望的状态匹配。
- en: Because of this pattern, one of the most common tasks when programming against
    the Kubernetes API is to watch for changes to a resource and then take some action
    based on those changes. The easiest way to do this is through polling. *Polling*
    simply calls the list function described above at a constant interval (such as
    every 60 seconds) and enumerates all of the resources that the code is interested
    in. While this code is easy to write, it has numerous drawbacks for both the client
    code and the API server. Polling introduces unnecessary latency, since waiting
    for the polling cycle to come around introduces delays for changes that occur
    just after the previous poll completed. Additionally, polling causes heavier load
    on the API server because it repeatedly returns resources that haven’t changed.
    While many simple clients begin by using polling, too many clients polling the
    API server can overload it and add latency.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种模式，针对 Kubernetes API 编程时最常见的任务之一是监视资源的变化，然后根据这些变化采取某些操作。最简单的方法是通过轮询来实现。*轮询*
    简单地在固定的间隔（如每 60 秒）调用上述列出资源的函数，并枚举代码感兴趣的所有资源。虽然这种代码编写起来很容易，但对客户端代码和 API 服务器都有很多缺点。轮询引入不必要的延迟，因为等待轮询周期导致在上一次轮询完成后发生的更改存在延迟。此外，轮询会导致
    API 服务器负载加重，因为它反复返回未更改的资源。虽然许多简单的客户端开始使用轮询，但太多客户端轮询 API 服务器可能会使其超载并增加延迟。
- en: To solve this problem, the Kuberentes API also provides *watch*, or event-based,
    semantics. Using a `watch` call, you can register interest in specific changes
    with the API server and, instead of repeatedly polling, the API server will send
    notifications whenever a change occurs. In practical terms, the client performs
    a hanging GET to the HTTP API server. The TCP connection that underlies this HTTP
    request stays open for the duration of the watch, and the server writes a response
    to that stream (but does not close the stream) whenever a change occurs.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为解决这个问题，Kubernetes API 还提供了 *watch* 或基于事件的语义。使用 `watch` 调用，您可以向 API 服务器注册对特定更改的兴趣，而不是重复轮询，API
    服务器会在发生更改时发送通知。在实际操作中，客户端执行一个持续的 GET 到 HTTP API 服务器。支持这个 HTTP 请求的 TCP 连接在整个 watch
    期间保持打开状态，服务器在每次更改时向该流写入响应（但不关闭流）。
- en: 'From a programmatic perspective, `watch` semantics enable event-based programming,
    changing a `while` loop that repeatedly polls into a collection of callbacks.
    Here are examples of watching Pods for changes:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 从程序角度来看，`watch` 语义支持基于事件的编程，将重复轮询的 `while` 循环改为一组回调函数。以下是监视 Pod 变化的示例：
- en: '*Python*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE15]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Java*'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*.NET*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In each of these examples, rather than a repetitive polling loop, the watch
    API call delivers each change to a resource to a callback provided by the user.
    This both reduces latency and load on the Kubernetes API server.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，与重复轮询循环不同，`watch` API 调用将每个资源的每个变化传递给用户提供的回调函数。这既减少了延迟，也减少了 Kubernetes
    API 服务器的负载。
- en: Interacting with Pods
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与 Pod 交互
- en: The Kubernetes API also provides functions for directly interacting with the
    applications running in a Kubernetes Pod. The `kubectl` tool provides a number
    of commands for interacting with Pods, namely `logs`, `exec`, and `port-forward`,
    and it is possible to use each of these from within custom code as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 还提供了直接与运行在 Kubernetes Pod 中的应用程序进行交互的函数。`kubectl` 工具提供了许多与 Pod
    交互的命令，包括 `logs`、`exec` 和 `port-forward`，也可以从自定义代码中使用这些命令。
- en: Note
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Because the `logs`, `exec`, and `port-forward` APIs are nonstandard in a RESTful
    sense, they require custom logic in the client libraries and are thus somewhat
    less consistent between the different clients. Unfortunately, there is no option
    other than learning the implementation for each language.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `logs`、`exec` 和 `port-forward` API 在 RESTful 视角上是非标准的，它们在客户端库中需要定制逻辑，因此在不同的客户端之间可能不太一致。不幸的是，除了学习每种语言的实现之外，没有其他选择。
- en: When getting the logs for a Pod, you have to decide if you are going to read
    the Pod logs to get a snapshot of their current state or if you are going to stream
    them to receive new logs as they happen. If you stream the logs (the equivalent
    of `kubectl logs -f ...`), you create an open connection to the API server, and
    new log lines are written to this stream as they are written to the Pod. If not,
    you simply receive the current contents of the logs.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当获取 Pod 的日志时，您必须决定是读取 Pod 日志以获取其当前状态的快照，还是将其流式传输以在发生时接收新的日志。如果流式传输日志（相当于 `kubectl
    logs -f ...`），则会创建到 API 服务器的开放连接，并且新的日志行将像写入 Pod 一样写入到此流中。否则，您只会接收日志的当前内容。
- en: 'Here’s how you both read and stream the logs:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何同时读取和流式传输日志的方法：
- en: '*Python*'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '*Java*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '*.NET*'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Another common task is to execute some command within a Pod and get the output
    of running that task. You can use the `kubectl exec ...` command on the command
    line. Under the hood, the API that implements this is creating a WebSocket connection
    to the API server. WebSockets enable multiple streams of data (in this case, `stdin`,
    `stdout`, and `stderr`) to coexist on the same HTTP connection. If you’ve never
    had experience with WebSockets, don’t worry; the details of interacting with WebSockets
    are handled by the client libraries.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的任务是在 Pod 中执行某个命令并获取运行该任务的输出。您可以在命令行上使用 `kubectl exec ...` 命令。在幕后，实现此功能的
    API 正在创建到 API 服务器的 WebSocket 连接。WebSocket 可以在同一 HTTP 连接上同时存在多个数据流（在本例中是 `stdin`、`stdout`
    和 `stderr`）。如果您从未使用过 WebSocket，不用担心；客户端库会处理与 WebSocket 的交互细节。
- en: 'Here’s how you execute the `ls /foo` command in a Pod:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是如何在 Pod 中执行 `ls /foo` 命令的方法：
- en: '*Python*'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE21]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '*Java*'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE22]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*.NET*'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE23]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In addition to running commands in a Pod, you can also port-forward network
    connections from a Pod to code running on the local machine. Like `exec`, the
    port-forwarded traffic goes over a WebSocket. It is up to your code what it does
    with this port-forwarded socket. You could simply send a single request and receive
    a response as a string of bytes, or you could build a complete proxy server (like
    what `kubectl port-forward` does) to serve arbitrary requests through this proxy.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在 Pod 中运行命令外，您还可以将网络连接从 Pod 端口转发到运行在本地机器上的代码。与 `exec` 类似，端口转发的流量通过 WebSocket
    进行。由您的代码决定如何处理此端口转发的套接字。您可以简单地发送一个请求并作为字节字符串接收响应，或者您可以构建一个完整的代理服务器（类似于 `kubectl
    port-forward`），通过此代理处理任意请求。
- en: 'Regardless of what you intend to do with the connection, here’s how you set
    up port-forwarding:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您打算如何处理连接，这里是如何设置端口转发的方法：
- en: '*Python*'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '*Python*'
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '*Java*'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '*Java*'
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '*.NET*'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '*.NET*'
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Each of these examples creates a connection from port 8080 in a Pod to port
    8080 in your program. The code returns the byte streams necessary, communicating
    across this port-forwarding channel. You can use these streams for sending and
    receiving messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 每个示例都在 Pod 中的端口 8080 上创建到程序端口 8080 的连接。该代码返回必要的字节流，通过这种端口转发通道进行通信。您可以使用这些流来发送和接收消息。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概要
- en: The Kubernetes API provides rich and powerful functionality for you to write
    custom code. Writing your applications in the language that best suits a task
    or a persona shares the power of the orchestration API with as many Kubernetes
    users as possible. When you’re ready to move beyond scripting calls to the `kubectl`
    executable, the Kubernetes client libraries provide a way to dive deep into the
    API to build an operator, a monitoring agent, a new user interface, or whatever
    your imagination can dream up.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 提供了丰富且强大的功能，让您编写自定义代码。将您的应用程序编写成最适合任务或个人角色的语言，与尽可能多的 Kubernetes
    用户分享编排 API 的功能。当您准备好超越对 `kubectl` 可执行文件的脚本调用时，Kubernetes 客户端库提供了一种方式，深入 API 构建操作员、监控代理、新用户界面或您的想象力可以梦想到的任何东西。
- en: ^([1](ch18.xhtml#idm45664072010864-marker)) We did not include [JavaScript](https://oreil.ly/8mw5F)
    examples for brevity, but it is also actively developed.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch18.xhtml#idm45664072010864-marker)) 为了简洁起见，我们没有包含 [JavaScript](https://oreil.ly/8mw5F)
    示例，但它也在积极开发中。
