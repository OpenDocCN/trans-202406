<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. The Type System"><div class="chapter" id="the_type_system">
<h1><span class="label">Chapter 2. </span>The Type System</h1>

<blockquote>
<p>JavaScript’s power</p>

<p>Comes from flexibility</p>

<p>Be careful with that!</p></blockquote>

<p>I talked briefly in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch01.xhtml#from_javascript_to_typescript">Chapter 1, “From JavaScript to TypeScript”</a> about the existence of a “type checker” in TypeScript that looks at your code, understands how it’s meant to work, and lets you know where you might have messed up.
But how does a type checker work, really?</p>






<section data-type="sect1" data-pdf-bookmark="What’s in a Type?"><div class="sect1" id="idm45584693803920">
<h1>What’s in a Type?</h1>

<p>A<a data-type="indexterm" data-primary="types" data-secondary="described" id="type-describe"/><a data-type="indexterm" data-primary="type checking" data-secondary="in TypeScript" id="type-check-typescript2"/><a data-type="indexterm" data-primary="TypeScript" data-secondary="type checking in" id="typescript-typecheck2"/><a data-type="indexterm" data-primary="variables" data-seealso="types" id="idm45584693798576"/> “type” is a description of what a JavaScript value <em>shape</em> might be.
By “shape” I mean which properties and methods exist on a value, and what the built-in <code>typeof</code> operator would describe it as.</p>

<p>For example, when you create a variable with the initial value <code>"Aretha"</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">singer</code> <code class="o">=</code> <code class="s2">"Aretha"</code><code class="p">;</code></pre>

<p>TypeScript<a data-type="indexterm" data-primary="infer, variable types" id="idm45584693780688"/> can infer, or figure out, that the <code>singer</code> variable is of <em>type</em> string.</p>

<p>The<a data-type="indexterm" data-primary="types" data-secondary="primitives and" id="type-primitive"/><a data-type="indexterm" data-primary="primitives" id="primitive"/> most basic types in TypeScript correspond to the seven basic kinds of primitives in <a data-type="indexterm" data-primary="JavaScript" data-secondary="primitives" id="idm45584693788912"/><a data-type="indexterm" data-primary="null type" data-secondary="as primitive" data-secondary-sortas="primitive" id="idm45584693776496"/><a data-type="indexterm" data-primary="undefined primitive" id="idm45584693775280"/><a data-type="indexterm" data-primary="boolean primitive" id="idm45584693774608"/><a data-type="indexterm" data-primary="string primitive" id="idm45584693773936"/><a data-type="indexterm" data-primary="number primitive" id="idm45584693773264"/><a data-type="indexterm" data-primary="bigint primitive" id="idm45584693772592"/><a data-type="indexterm" data-primary="symbol primitive" id="idm45584693771920"/>JavaScript:</p>

<ul>
<li>
<p><code>null</code></p>
</li>
<li>
<p><code>undefined</code></p>
</li>
<li>
<p><code>boolean</code> // <code>true</code> or <code>false</code></p>
</li>
<li>
<p><code>string</code> // <code>""</code>, <code>"Hi!"</code>, <code>"abc123"</code>, …</p>
</li>
<li>
<p><code>number</code> // <code>0</code>, <code>2.1</code>, <code>-4</code>, …</p>
</li>
<li>
<p><code>bigint</code> // <code>0n</code>, <code>2n</code>, <code>-4n</code>, …</p>
</li>
<li>
<p><code>symbol</code> // <code>Symbol()</code>, <code>Symbol("hi")</code>, …</p>
</li>
</ul>

<p>For each of these values, TypeScript understands the type of the value to be one of the seven basic primitives:</p>

<ul>
<li>
<p><code>null; // null</code></p>
</li>
<li>
<p><code>undefined; // undefined</code></p>
</li>
<li>
<p><code>true; // boolean</code></p>
</li>
<li>
<p><code>"Louise"; // string</code></p>
</li>
<li>
<p><code>1337; // number</code></p>
</li>
<li>
<p><code>1337n; // bigint</code></p>
</li>
<li>
<p><code>Symbol("Franklin"); // symbol</code></p>
</li>
</ul>

<p>If you ever forget the name of a primitive, you can type a <code>let</code> variable with a primitive value into the <a href="https://typescriptlang.org/play">TypeScript Playground</a> or an IDE and hover your mouse over the variable’s name.
The resultant popover will include the name of the primitive, such as this screenshot showing hovering over a string <a data-type="indexterm" data-primary="types" data-secondary="primitives and" data-startref="type-primitive" id="idm45584693734624"/><a data-type="indexterm" data-primary="primitives" data-startref="primitive" id="idm45584693733376"/>variable (<a data-type="xref" href="#playground_primitive_hover">Figure 2-1</a>).</p>

<figure class="width-50"><div id="playground_primitive_hover" class="figure">
<img src="Images/lets_0201.png" alt="TypeScript showing a string variable's type in its hover information." width="600" height="181"/>
<h6><span class="label">Figure 2-1. </span>TypeScript showing a string variable’s type in its hover information</h6>
</div></figure>

<p>TypeScript is also smart enough to be able to infer the type of a variable whose starting value is computed.
In this example, TypeScript knows that the ternary expression always results in a string, so the <code>bestSong</code> variable is a <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Inferred type: string</code>
<code class="kd">let</code> <code class="nx">bestSong</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
  <code class="o">?</code> <code class="s2">"Chain of Fools"</code>
  <code class="o">:</code> <code class="s2">"Respect"</code><code class="p">;</code></pre>

<p>Back in the <a href="https://typescriptlang.org/play">TypeScript Playground</a> or your IDE, try hovering your cursor on that <code>bestSong</code> variable.
You should see some info box or message telling you that TypeScript has inferred the <code>bestSong</code> variable to be type <code>string</code> (<a data-type="xref" href="#hovering_let_string_computed">Figure 2-2</a>).</p>

<figure><div id="hovering_let_string_computed" class="figure">
<img src="Images/lets_0202.png" alt="TypeScript reporting a 'let' variable as being its string literal type from its ternary expression." width="261" height="84"/>
<h6><span class="label">Figure 2-2. </span>TypeScript reporting a <code>let</code> variable as being its <code>string</code> literal type from its ternary expression</h6>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Recall <a data-type="indexterm" data-primary="primitives" data-secondary="objects vs." id="idm45584693703248"/><a data-type="indexterm" data-primary="objects" data-secondary="primitives vs." id="idm45584693702240"/>the differences between objects and primitives in JavaScript: classes such as <code>Boolean</code> and <code>Number</code> wrap around their primitive equivalents.
TypeScript best practice is generally to refer to the lower-case names, such as <code>boolean</code> and <code>number</code>, <a data-type="indexterm" data-primary="types" data-secondary="described" data-startref="type-describe" id="idm45584693699472"/>respectively.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Type Systems"><div class="sect2" id="idm45584693697936">
<h2>Type Systems</h2>

<p>A <em>type system</em> is <a data-type="indexterm" data-primary="TypeScript" data-secondary="type system in" id="typescript-typesystem"/><a data-type="indexterm" data-primary="type systems" id="typesystem"/>the set of rules for how a programming language understands what types the constructs in a program may have.</p>

<p>At its core, TypeScript’s type system works by:</p>

<ul>
<li>
<p>Reading in your code and understanding all the types and values in existence</p>
</li>
<li>
<p>For each value, seeing what type its initial declaration indicates it may contain</p>
</li>
<li>
<p>For each value, seeing all the ways it’s used later on in code</p>
</li>
<li>
<p>Complaining to the user if a value’s usage doesn’t match with its type</p>
</li>
</ul>

<p>Let’s walk through this type inference process in detail.</p>

<p>Take the following snippet, in which TypeScript is emitting a type error about a member property being erroneously called as a function:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="s2">"Whitney"</code><code class="p">;</code>
<code class="nx">firstName</code><code class="p">.</code><code class="nx">length</code><code class="p">();</code>
<code class="c1">//        ~~~~~~</code>
<code class="c1">//  This expression is not callable.</code>
<code class="c1">//    Type 'Number' has no call signatures</code></pre>

<p>TypeScript came to that complaint by, in order:</p>
<ol>
<li>
<p>Reading in the code and understanding there to be a variable named <code>firstName</code></p>
</li>
<li>
<p>Concluding that <code>firstName</code> is of type <code>string</code> because its initial value is a <code>string</code>, <code>"Whitney"</code></p>
</li>
<li>
<p>Seeing that the code is trying to access a <code>.length</code> member of <code>firstName</code> and call it like a function</p>
</li>
<li>
<p>Complaining that the <code>.length</code> member of a string is a number, not a function <em>(it can’t be called like a function)</em></p>
</li>

</ol>

<p>Understanding TypeScript’s type system is an important skill for understanding TypeScript code.
Code snippets in this chapter and throughout the rest of this book will display more and more complex types that TypeScript will be able to infer <a data-type="indexterm" data-primary="TypeScript" data-secondary="type system in" data-startref="typescript-typesystem" id="idm45584693619296"/><a data-type="indexterm" data-primary="type systems" data-startref="typesystem" id="idm45584693618320"/><a data-type="indexterm" data-primary="type checking" data-secondary="in TypeScript" data-startref="type-check-typescript2" id="idm45584693617408"/><a data-type="indexterm" data-primary="TypeScript" data-secondary="type checking in" data-startref="typescript-typecheck2" id="idm45584693616192"/>from code.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Kinds of Errors"><div class="sect2" id="idm45584693697312">
<h2>Kinds of Errors</h2>

<p>While writing TypeScript, the two kinds of “errors” you’ll come across most frequently are:</p>
<dl>
<dt>Syntax</dt>
<dd>
<p>Blocking TypeScript from being converted to JavaScript</p>
</dd>
<dt>Type</dt>
<dd>
<p>Something mismatched has been detected by the type checker</p>
</dd>
</dl>

<p>The differences between the two are important.</p>










<section data-type="sect3" data-pdf-bookmark="Syntax errors"><div class="sect3" id="idm45584693609552">
<h3>Syntax errors</h3>

<p>Syntax<a data-type="indexterm" data-primary="errors" data-secondary="syntax errors" id="idm45584693608048"/><a data-type="indexterm" data-primary="syntax errors" id="idm45584693607040"/> errors are when TypeScript detects incorrect syntax that it cannot understand as code.
These block TypeScript from being able to properly generate output JavaScript from your file.
Depending on the tooling and settings you’re using to convert your TypeScript code to JavaScript, you might still get some kind of JavaScript output (in default <code>tsc</code> settings, you will).
But if you do, it likely won’t look like what you expect.</p>

<p>This input TypeScript has a syntax error for an unexpected <code>let</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="kd">let</code> <code class="nx">wat</code><code class="p">;</code>
<code class="c1">//      ~~~</code>
<code class="c1">// Error: ',' expected.</code></pre>

<p>Its compiled JavaScript output, depending on the TypeScript compiler version, may look something like:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="kd">let</code><code class="p">,</code> <code class="nx">wat</code><code class="p">;</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>Although TypeScript will do its best to output JavaScript code regardless of syntax errors, the output code will likely not be what you wanted.
It’s best to fix syntax errors before attempting to run the output JavaScript.</p>
</div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Type errors"><div class="sect3" id="idm45584693591216">
<h3>Type errors</h3>

<p>Type errors<a data-type="indexterm" data-primary="errors" data-secondary="type errors" id="error-type"/><a data-type="indexterm" data-primary="type errors" id="type-error"/> occur when your syntax is valid but the TypeScript type checker has detected an error with the program’s types.
These do not block TypeScript syntax from being converted to JavaScript.
They do, however, often indicate something will crash or behave unexpectedly if your code is allowed to run.</p>

<p>You saw this in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch01.xhtml#from_javascript_to_typescript">Chapter 1, “From JavaScript to TypeScript”</a> with the <code>console.blub</code> example, where the code was syntactically valid but TypeScript could detect it would likely crash when run:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">console</code><code class="p">.</code><code class="nx">blub</code><code class="p">(</code><code class="s2">"Nothing is worth more than laughter."</code><code class="p">);</code>
<code class="c1">//      ~~~~</code>
<code class="c1">// Error: Property 'blub' does not exist on type 'Console'.</code></pre>

<p>Even though TypeScript may output JavaScript code despite the presence of type errors, type errors are generally a sign that the output JavaScript likely won’t run the way you wanted.
It’s best to read them and consider fixing any reported issues before running JavaScript.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Some projects are configured to block running code during development until all TypeScript type errors—not just syntax—are fixed.
Many developers, myself included, generally find this to be annoying and unnecessary.
Most projects have a way to not be blocked, such as with the <em>tsconfig.json</em> file and configuration options covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>.</p>
</div>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Assignability"><div class="sect1" id="idm45584693803328">
<h1>Assignability</h1>

<p>TypeScript <a data-type="indexterm" data-primary="types" data-secondary="assignability" id="idm45584693528896"/><a data-type="indexterm" data-primary="variables" data-secondary="assignability of types" id="idm45584693527888"/><a data-type="indexterm" data-primary="assignability" data-secondary="described" id="idm45584693526944"/>reads variables’ initial values to determine what type those variables are allowed to be.
If it later sees an assignment of a new value to that variable, it will check if that new value’s type is the same as the variable’s.</p>

<p>TypeScript is fine with later assigning a different value of the same type to a variable.
If a variable is, say, initially a <code>string</code> value, later assigning it another <code>string</code> would be fine:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">firstName</code> <code class="o">=</code> <code class="s2">"Carole"</code><code class="p">;</code>
<code class="nx">firstName</code> <code class="o">=</code> <code class="s2">"Joan"</code><code class="p">;</code></pre>

<p>If TypeScript sees an assignment of a different type, it will give us a type error.
We couldn’t, say, initially declare a variable with a <code>string</code> value and then later on put in a <code>boolean</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">lastName</code> <code class="o">=</code> <code class="s2">"King"</code><code class="p">;</code>
<code class="nx">lastName</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
<code class="c1">// Error: Type 'boolean' is not assignable to type 'string'.</code></pre>

<p>TypeScript’s checking of whether a value is allowed to be provided to a function call or variable is called <em>assignability</em>: whether that value is <em>assignable</em> to the expected type it’s passed to.
This will be an important term in later chapters as we compare more complex objects.</p>








<section data-type="sect2" data-pdf-bookmark="Understanding Assignability Errors"><div class="sect2" id="idm45584693475920">
<h2>Understanding Assignability Errors</h2>

<p>Errors <a data-type="indexterm" data-primary="errors" data-secondary="assignability errors" id="idm45584693474720"/><a data-type="indexterm" data-primary="assignability" data-secondary="errors" id="idm45584693473712"/>in the format “Type…is not assignable to type…” will be some of the most common types of errors you’ll see when writing TypeScript code.</p>

<p>The first type mentioned in that error message is the value the code is attempting to assign to a recipient.
The second type mentioned is the recipient being assigned the first type.
For example, when we wrote <code>lastName = true</code> in the previous snippet, we were trying to <em>assign</em> the value of <code>true</code>—type <code>boolean</code>—to the recipient variable <code>lastName</code>—type <code>string</code>.</p>

<p>You’ll see more and more complex assignability issues as you progress through this book.
Remember to read them carefully to understand reported differences between actual and expected types.
Doing so will make it much easier to work with TypeScript when it’s giving you grief over syntax errors.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Type Annotations"><div class="sect1" id="idm45584693468864">
<h1>Type Annotations</h1>

<p>Sometimes<a data-type="indexterm" data-primary="type annotations" data-secondary="described" id="type-anno-describe"/><a data-type="indexterm" data-primary="variables" data-secondary="type annotations" id="variables-typeanno"/> a variable doesn’t have an initial value for TypeScript to read.
TypeScript won’t attempt to figure out the initial type of the variable from later uses.
It’ll consider the variable by default to be implicitly the <code>any</code> type: indicating that it could be anything in the world.</p>

<p>Variables that can’t have their initial type inferred go through what’s called<a data-type="indexterm" data-primary="evolving any type" id="idm45584693423824"/><a data-type="indexterm" data-primary="types" data-secondary="evolving any" id="idm45584693423120"/><a data-type="indexterm" data-primary="any type" data-secondary="evolving any" id="idm45584693422176"/><a data-type="indexterm" data-primary="variables" data-secondary="evolving any type" id="idm45584693421232"/> an <em>evolving any</em>: rather than enforce any particular type, TypeScript will evolve its understanding of the variable’s type each time a new value is assigned.</p>

<p>Here, assigning the evolving <code>any</code> variable <code>rocker</code> is first assigned a string, which means it has string methods such as <code>toUpperCase</code>, but then is evolved into a <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">rocker</code><code class="p">;</code> <code class="c1">// Type: any</code>

<code class="nx">rocker</code> <code class="o">=</code> <code class="s2">"Joan Jett"</code><code class="p">;</code> <code class="c1">// Type: string</code>
<code class="nx">rocker</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Ok</code>

<code class="nx">rocker</code> <code class="o">=</code> <code class="mf">19.58</code><code class="p">;</code> <code class="c1">// Type: number</code>
<code class="nx">rocker</code><code class="p">.</code><code class="nx">toPrecision</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">rocker</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
<code class="c1">//     ~~~~~~~~~~~</code>
<code class="c1">// Error: 'toUpperCase' does not exist on type 'number'.</code></pre>

<p>TypeScript was able to catch that we were calling the <code>toUpperCase()</code> method on a variable evolved to type <code>number</code>.
However, it wasn’t able to tell us earlier whether it was intentional that we were evolving the variable from <code>string</code> to <code>number</code> in the first place.</p>

<p>Allowing variables to be evolving <code>any</code> typed—and using the <code>any</code> type in general—partially defeats the purpose of TypeScript’s type checking!
TypeScript works best when it knows what types your values are meant to be.
Much of TypeScript’s type checking can’t be applied to <code>any</code> typed values because they don’t have known types to be checked.
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a> will cover how to configure TypeScript’s implicit <code>any</code> complaints.</p>

<p>TypeScript provides a syntax for declaring the type of a variable without having to assign it an initial value, called a <em>type annotation</em>.
A type annotation is placed after the name of a variable and includes a colon followed by the name of a type.</p>

<p>This type annotation indicates the <code>rocker</code> variable is meant to be type <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">rocker</code>: <code class="nx">string</code><code class="p">;</code>
<code class="nx">rocker</code> <code class="o">=</code> <code class="s2">"Joan Jett"</code><code class="p">;</code></pre>

<p>These type annotations exist only for TypeScript—they don’t affect the runtime code and are not valid JavaScript syntax.
If you run <code>tsc</code> to compile TypeScript source code to JavaScript, they’ll be erased.
For example, the previous example would be compiled to roughly the following JavaScript:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// output .js file</code>
<code class="kd">let</code> <code class="nx">rocker</code><code class="p">;</code>
<code class="nx">rocker</code> <code class="o">=</code> <code class="s2">"Joan Jett"</code><code class="p">;</code></pre>

<p>Assigning a value whose type is not assignable to the variable’s annotated type will cause a type error.</p>

<p>This snippet assigns a number to a <code>rocker</code> variable previously declared as type <code>string</code>, causing a type error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">rocker</code>: <code class="nx">string</code><code class="p">;</code>
<code class="nx">rocker</code> <code class="o">=</code> <code class="mf">19.58</code><code class="p">;</code>
<code class="c1">// Error: Type 'number' is not assignable to type 'string'.</code></pre>

<p>You’ll see through the next few chapters how type annotations allow you to augment TypeScript’s insights into your code, allowing it to give you better features during development.
TypeScript contains an assortment of new pieces of syntax, such as these type annotations that exist only in the type system.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Nothing that exists only in the type system gets copied over into emitted JavaScript.
TypeScript types don’t affect emitted JavaScript.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Unnecessary Type Annotations"><div class="sect2" id="idm45584693269376">
<h2>Unnecessary Type Annotations</h2>

<p>Type annotations allow us to provide information to TypeScript that it wouldn’t have been able to glean on its own.
You could also use them on variables that have immediately inferable types, but you wouldn’t be telling TypeScript anything it doesn’t already know.</p>

<p>The following <code>: string</code> type annotation is redundant because TypeScript could already infer that <code>firstName</code> be of type <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">firstName</code>: <code class="nx">string</code> <code class="o">=</code> <code class="s2">"Tina"</code><code class="p">;</code>
<code class="c1">//           ~~~~~~~~ Does not change the type system...</code></pre>

<p>If you do add a type annotation to a variable with an initial value, TypeScript will check that it matches the type of the variable’s value.</p>

<p>The following <code>firstName</code> is declared to be of type <code>string</code>, but its initializer is the <code>number</code> <code>42</code>, which TypeScript sees as an incompatibility:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">firstName</code>: <code class="nx">string</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
<code class="c1">//  ~~~~~~~~~</code>
<code class="c1">// Error: Type 'number' is not assignable to type 'string'.</code></pre>

<p>Many developers—myself included—generally prefer not to add type annotations on variables where the type annotations wouldn’t change anything.
Having to manually write out type annotations can be cumbersome—especially when they change, and for the complex types I’ll show you later in this book.</p>

<p>It can sometimes be useful to include explicit type annotations on variables to clearly document the code and/or to make TypeScript protected against accidental changes to the variable’s type.
We’ll see in later chapters how explicit type annotations can sometimes explicitly tell TypeScript information it wouldn’t have inferred<a data-type="indexterm" data-primary="type annotations" data-secondary="described" data-startref="type-anno-describe" id="idm45584693205520"/><a data-type="indexterm" data-primary="variables" data-secondary="type annotations" data-startref="variables-typeanno" id="idm45584693204400"/> normally.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Type Shapes"><div class="sect1" id="idm45584693427744">
<h1>Type Shapes</h1>

<p>TypeScript <a data-type="indexterm" data-primary="type shapes" id="type-shape"/><a data-type="indexterm" data-primary="variables" data-secondary="type shapes" id="variable-type-shape"/><a data-type="indexterm" data-primary="objects" data-secondary="type shapes" id="objects-type-shape"/>does more than check that the values assigned to variables match their original types.
TypeScript also knows what member properties should exist on objects.
If you attempt to access a property of a variable, TypeScript will make sure that property is known to exist on that variable’s type.</p>

<p>Suppose we declare a <code>rapper</code> variable of type <code>string</code>.
Later on, when we use that <code>rapper</code> variable, operations that TypeScript knows work on strings are allowed:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">rapper</code> <code class="o">=</code> <code class="s2">"Queen Latifah"</code><code class="p">;</code>
<code class="nx">rapper</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// ok</code></pre>

<p>Operations that TypeScript doesn’t know to work on strings will not be allowed:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">rapper</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s1">'!'</code><code class="p">);</code>
<code class="c1">//     ~~~~</code>
<code class="c1">// Property 'push' does not exist on type 'string'.</code></pre>

<p>Types can also be more complex shapes, most notably objects.
In the following snippet, TypeScript knows the <code>birthNames</code> object doesn’t have a <code>middleName</code> key and complains:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">cher</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">firstName</code><code class="o">:</code> <code class="s2">"Cherilyn"</code><code class="p">,</code>
  <code class="nx">lastName</code><code class="o">:</code> <code class="s2">"Sarkisian"</code><code class="p">,</code>
<code class="p">};</code>

<code class="nx">cher</code><code class="p">.</code><code class="nx">middleName</code><code class="p">;</code>
<code class="c1">//   ~~~~~~~~~~</code>
<code class="c1">//   Property 'middleName' does not exist on type</code>
<code class="c1">//   '{ firstName: string; lastName: string; }'.</code></pre>

<p>TypeScript’s understanding of object shapes allows it to report issues with the usage of objects, not just assignability.
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.xhtml#objects">Chapter 4, “Objects”</a> will describe more of TypeScript’s powerful features around objects and object<a data-type="indexterm" data-primary="type shapes" data-startref="type-shape" id="idm45584693061424"/><a data-type="indexterm" data-primary="variables" data-secondary="type shapes" data-startref="variable-type-shape" id="idm45584693088560"/><a data-type="indexterm" data-primary="objects" data-secondary="type shapes" data-startref="objects-type-shape" id="idm45584693087344"/> types.</p>








<section data-type="sect2" data-pdf-bookmark="Modules"><div class="sect2" id="idm45584693085872">
<h2>Modules</h2>

<p>The<a data-type="indexterm" data-primary="TypeScript" data-secondary="modules" id="typescript-modules"/><a data-type="indexterm" data-primary="modules" data-secondary="described" id="module-describe"/><a data-type="indexterm" data-primary="importing" data-secondary="via modules" id="import-module"/><a data-type="indexterm" data-primary="exporting" data-secondary="via modules" id="export-module"/><a data-type="indexterm" data-primary="sharing code via modules" id="share-module"/> JavaScript programming language did not include a specification for how files can share code between each other until relatively recently in its history.
ECMAScript 2015 added<a data-type="indexterm" data-primary="ECMAScript Modules (ESM)" id="idm45584693077760"/><a data-type="indexterm" data-primary="ESM (ECMAScript Modules)" id="idm45584693077120"/> “ECMAScript modules,” or ESM, to standardize <code>import</code> and <code>export</code> syntax between files.</p>

<p>For reference, this module file imports a <code>value</code> from a sibling <code>./values</code> file and exports a <code>doubled</code> variable:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">value</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./values"</code><code class="p">;</code>

<code class="kr">export</code> <code class="kr">const</code> <code class="nx">doubled</code> <code class="o">=</code> <code class="nx">value</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code></pre>

<p>To match with the ECMAScript specification, in this book I’ll use the following nomenclature:</p>
<dl>
<dt>Module</dt>
<dd>
<p>A file with a top-level <code>export</code> or <code>import</code></p>
</dd>
<dt>Script</dt>
<dd>
<p>Any <a data-type="indexterm" data-primary="scripts" id="script-describe"/>file that is not a module</p>
</dd>
</dl>

<p>TypeScript is able to work with those modern module files as well as older files.
Anything declared in a module file will be available only in that file unless an explicit <code>export</code> statement in that file exports it.
A variable declared in one module with the same name as a variable declared in another file won’t be considered a naming conflict (unless one file imports the other file’s variable).</p>

<p>The following <code>a.ts</code> and <code>b.ts</code> files are both modules that export a similarly named <code>shared</code> variable without issue.
<code>c.ts</code> causes a type error because it has a naming conflict between an imported <code>shared</code> and its own value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// a.ts</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">shared</code> <code class="o">=</code> <code class="s2">"Cher"</code><code class="p">;</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// b.ts</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">shared</code> <code class="o">=</code> <code class="s2">"Cher"</code><code class="p">;</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// c.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">shared</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./a"</code><code class="p">;</code>
<code class="c1">//       ~~~~~~</code>
<code class="c1">// Error: Import declaration conflicts with local declaration of 'shared'.</code>

<code class="kr">export</code> <code class="kr">const</code> <code class="nx">shared</code> <code class="o">=</code> <code class="s2">"Cher"</code><code class="p">;</code>
<code class="c1">//           ~~~~~~</code>
<code class="c1">// Error: Individual declarations in merged declaration</code>
<code class="c1">// 'shared' must be all exported or all local.</code></pre>

<p>If a file is a script, though, TypeScript will consider it to be globally scoped, meaning all scripts have access to its contents.
That means variables declared in a script file cannot have the same name as variables declared in other script files.</p>

<p>The following <code>a.ts</code> and <code>b.ts</code> files are considered scripts because they do not have module-style <code>export</code> or <code>import</code> statements.
That means their variables of the same name conflict with each other as if they were declared in the same file:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// a.ts</code>
<code class="kr">const</code> <code class="nx">shared</code> <code class="o">=</code> <code class="s2">"Cher"</code><code class="p">;</code>
<code class="c1">//    ~~~~~~</code>
<code class="c1">// Cannot redeclare block-scoped variable 'shared'.</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// b.ts</code>
<code class="kr">const</code> <code class="nx">shared</code> <code class="o">=</code> <code class="s2">"Cher"</code><code class="p">;</code>
<code class="c1">//    ~~~~~~</code>
<code class="c1">// Cannot redeclare block-scoped variable 'shared'.</code></pre>

<p>If you see these “Cannot redeclare…” errors in a TypeScript file, it may be because you have yet to add an <code>export</code> or <code>import</code> statement to the file.
Per the ECMAScript specification, if you need a file to be a module without an <code>export</code> or <code>import</code> statement, you can add an <code>export {};</code> somewhere in the file to force it to be a<a data-type="indexterm" data-primary="scripts" data-startref="script-describe" id="idm45584692849584"/> module:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="c1">// a.ts and b.ts</code>
<code class="kr">const</code> <code class="nx">shared</code> <code class="o">=</code> <code class="s2">"Cher"</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="kr">export</code> <code class="p">{};</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>TypeScript will not recognize the types of imports and exports in TypeScript files written using older module systems such as CommonJS.
TypeScript will generally see values returned from CommonJS-style <code>require</code> functions to be typed <a data-type="indexterm" data-primary="TypeScript" data-secondary="modules" data-startref="typescript-modules" id="idm45584692818528"/><a data-type="indexterm" data-primary="modules" data-secondary="described" data-startref="module-describe" id="idm45584692817280"/><a data-type="indexterm" data-primary="importing" data-secondary="via modules" data-startref="import-module" id="idm45584692816064"/><a data-type="indexterm" data-primary="exporting" data-secondary="via modules" data-startref="export-module" id="idm45584692814848"/><a data-type="indexterm" data-primary="sharing code via modules" data-startref="share-module" id="idm45584692813632"/>as <code>any</code>.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584693202592">
<h1>Summary</h1>

<p>In this chapter, you saw how TypeScript’s type system works at its core:</p>

<ul>
<li>
<p>What a “type” is and the primitive types recognized by TypeScript</p>
</li>
<li>
<p>What a “type system” is and how TypeScript’s type system understands code</p>
</li>
<li>
<p>How type errors compare to syntax errors</p>
</li>
<li>
<p>Inferred variable types and variable assignability</p>
</li>
<li>
<p>Type annotations to explicitly declare variable types and avoid evolving <code>any</code> types</p>
</li>
<li>
<p>Object member checking on type shapes</p>
</li>
<li>
<p>ECMAScript module files’ declaration scoping compared to script files</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/the-type-system"><em class="hyperlink">https://learningtypescript.com/the-type-system</em></a>.</p>
</div>
<blockquote class="joke">
<p>Why did the number and string break up?</p>

<p>They weren’t each other’s types.</p></blockquote>
</div></section>







</div></section></div></body></html>