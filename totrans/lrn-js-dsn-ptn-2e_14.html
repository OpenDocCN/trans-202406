<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Application Structure for React.js"><div class="chapter" id="app-structure-for-react">
<h1><span class="label">Chapter 14. </span>Application Structure for React.js</h1>


<p>When building small hobby projects<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="about" id="idm45017684305808"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="about" id="idm45017684304560"/> or trying a new concept or library, developers can start adding files to a folder without a plan or organizing structure. These could include CSS, helper components, images, and pages. A single folder for all resources becomes unmanageable as the project grows. Any respectably sized codebase should be organized into an application folder structure based on logical criteria. The decision on how to structure your files and application components could be a personal/team choice. It would also generally depend on the application domain and technology used.</p>

<p>This chapter mainly focuses on folder structures for React.js applications that could help in better management of our projects as they grow.</p>






<section data-type="sect1" data-pdf-bookmark="Introduction"><div class="sect1" id="idm45017684302848">
<h1>Introduction</h1>

<p>React.js itself does not provide<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="introduction" id="ch14-intro"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="introduction" id="ch14-intro2"/> a guideline on structuring projects but does suggest a few commonly used approaches. Let’s look at these and understand their pros and cons before discussing folder structures for projects with added complexities and Next.js applications.</p>

<p>At the high level, you can group files in a React application in <a href="https://oreil.ly/Tkwai">two ways</a>:</p>
<dl>
<dt>Group by feature</dt>
<dd>
<p>Create folders for every application module, feature, or route.</p>
</dd>
<dt>Group by file type</dt>
<dd>
<p>Create folders for different types of files.</p>
</dd>
</dl>

<p>Let us look at this classification in detail.</p>








<section data-type="sect2" data-pdf-bookmark="Group by Module, Feature, or Route"><div class="sect2" id="idm45017684293568">
<h2>Group by Module, Feature, or Route</h2>

<p>In this case, the file structure would<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="group by module, feature, or route" id="idm45017684292096"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="introduction" data-tertiary="group by module, feature, or route" id="idm45017684290880"/> mirror the business model or the application flow. For example, if you have an ecommerce application, you will have folders for product, productlist, checkout, etc. The CSS, JSX components, tests, subcomponents, or helper libraries explicitly required for the product module reside in the product folder:</p>

<pre data-type="programlisting">common/
  Avatar.js
  Avatar.css
  ErrorUtils.js
  ErrorUtils.test.js
product/
  index.js
  product.css
  price.js
  product.test.js
checkout/
  index.js
  checkout.css
  checkout.test.js</pre>

<p>The advantage of grouping files by feature is that if there is a change to the module, all the affected files are colocated in the same folder, and the change gets localized to a specific part of the code.</p>

<p>The disadvantage is common components, logic, or styles used across modules should be identified periodically to avoid repetition and promote consistency and reuse.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Group by File Type"><div class="sect2" id="idm45017684287856">
<h2>Group by File Type</h2>

<p>In this type of grouping, you<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="group by file type" id="idm45017684286352"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="introduction" data-tertiary="group by file type" id="idm45017684285104"/> would create different folders for CSS, components, test files, images, libraries, etc. Thus, logically related files would reside in different folders based on the file type:</p>

<pre data-type="programlisting">css/
  global.css
  checkout.css
  product.css
lib/
  date.js
  currency.js
  gtm.js
pages/
  product.js
  productlist.js
  checkout.js</pre>

<p>The advantages of this approach are:</p>

<ul>
<li>
<p>You have a standard structure that you can reuse across projects.</p>
</li>
<li>
<p>Newer team members with little knowledge of the application-specific logic can still find files for something like styles or tests.</p>
</li>
<li>
<p>Common components (such as date pickers) and styles imported in different routes or modules can be changed once to ensure that the effect is seen across the application.</p>
</li>
</ul>

<p>The disadvantages are:</p>

<ul>
<li>
<p>A change in logic for a specific module would likely require changes in files across different folders.</p>
</li>
<li>
<p>As the number of features in the application grows, the number of files in different folders would increase, making it difficult to find a specific file.</p>
</li>
</ul>

<p>Either of these approaches could be easy to set up for small- to mid-sized applications with a small number of files (50 to 100) per folder. For larger projects, however, you may want to go for a hybrid approach based on the logical structure of your application. Let us look at some of the possibilities.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Hybrid Grouping Based on Domain and Common Components"><div class="sect2" id="idm45017684276112">
<h2>Hybrid Grouping Based on Domain and Common Components</h2>

<p>Here you would group all common<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="hybrid grouping" id="idm45017684273952"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="introduction" data-tertiary="hybrid grouping" id="idm45017684272704"/> components required across the application in a Components folder and all application flow-specific routes or features in a <a href="https://oreil.ly/rJQaz">domain folder</a> (the name could be <em>domain</em>, <em>pages</em>, or <em>routes</em>). Every folder can have subfolders for specific components and related files:</p>

<pre data-type="programlisting">css/
  global.css
components/
  User/
    profile.js
    profile.test.js
    avatar.js
  date.js
  currency.js
  gtm.js
  errorUtils.js
domain/
  product/
    product.js
    product.css
    product.test.js
  checkout/
    checkout.js
    checkout.css
    checkout.test.js</pre>

<p>Thus, you can combine the advantages of both “Group by file type” and “Group by feature” by colocating related files, which change together frequently and common reusable components and styles used across the application.</p>

<p>Depending on the complexity of the application, you can modify this to a flatter structure without subfolders or a more nested structure:</p>
<dl>
<dt>Flatter structure</dt>
<dd>
<p>The following example illustrates a flatter structure:</p>
</dd>
</dl>

<pre data-type="programlisting">    domain/
        product.js
        product.css
        product.test.js
        checkout.js
        checkout.css
        checkout.test.js</pre>
<dl>
<dt>Nested structure</dt>
<dd>
<p>The following example shows a more nested structure:</p>
</dd>
</dl>

<pre data-type="programlisting">    domain/
        product/
            productType/
                features.js
                features.css
                size.js
            price/
                listprice.js
                discount.js</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>It’s best to avoid deep nesting with more than three to four levels because it becomes harder to write relative imports between folders or update those imports when the files are moved.</p>
</div>

<p>A variation to this approach is to create folders based on views or routes, in addition to those based on domain, as discussed <a href="https://oreil.ly/WiRca">here</a>. A routing component can then coordinate the view to be displayed based on the current route. <a href="https://oreil.ly/6PwMu">Next.js</a> uses a <a data-type="indexterm" data-startref="ch14-intro" id="idm45017684259472"/><a data-type="indexterm" data-startref="ch14-intro2" id="idm45017684258736"/>similar 
<span class="keep-together">structure.</span></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Application Structure for Modern React Features"><div class="sect1" id="idm45017684275520">
<h1>Application Structure for Modern React Features</h1>

<p>Modern React apps use different features<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="modern React features" id="ch14-mod"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="modern React features" id="ch14-mod2"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="modern React features" data-tertiary="about" id="idm45017684253072"/> such as Redux, stateful containers, Hooks, and Styled Components. Let’s see where the code related to these would fit in the application structure proposed in the previous section.</p>








<section data-type="sect2" data-pdf-bookmark="Redux"><div class="sect2" id="idm45017684251440">
<h2>Redux</h2>

<p>Redux documentation <a href="https://oreil.ly/iH1aX">strongly recommends</a> colocating<a data-type="indexterm" data-primary="application structure in React" data-secondary="modern React features" data-tertiary="Redux" id="idm45017684249200"/><a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="Redux" id="idm45017684247952"/><a data-type="indexterm" data-primary="Redux" data-secondary="application structure" id="idm45017684246736"/> logic for a given feature in one place. Within a given feature folder, the Redux logic for that feature should be written as a single “slice” file, preferably using the Redux Toolkit <code>createSlice</code> API. The file bundles {<code>actionTypes, actions, reducer</code>} to a self-contained, isolated module. <a data-type="indexterm" data-primary="“ducks” pattern" data-primary-sortas="ducks pattern" id="idm45017684244800"/>This is also known as the <a href="https://oreil.ly/UOqb5">“ducks” pattern</a> (from Redux). For example, as given <a href="https://oreil.ly/0gpXl">here</a>:</p>

<pre data-type="programlisting">/src
    index.tsx: Entry point file that renders the React component tree
    /app
        store.ts: store setup
        rootReducer.ts: root reducer (optional)
        App.tsx: root React component
    /common: hooks, generic components, utils, etc
    /features: contains all "feature folders"
    /todos: a single feature folder
        todosSlice.ts: Redux reducer logic and associated actions
        Todos.tsx: a React component</pre>

<p>Another comprehensive example that uses Redux without creating containers or Hooks is available <a href="https://oreil.ly/xMZiu">here</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Containers"><div class="sect2" id="idm45017684240320">
<h2>Containers</h2>

<p>If you have structured your code<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="containers" id="idm45017684238960"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="modern React features" data-tertiary="containers" id="idm45017684237712"/><a data-type="indexterm" data-primary="containers in application structure" id="idm45017684236480"/> to categorize components into <a href="https://oreil.ly/JeYgI">presentational components and stateful container components</a>, you can create a separate folder for the container components. Containers let you separate complex stateful logic from other aspects of the component:</p>

<pre data-type="programlisting">/src
    /components
        /component1
            index.js
            styled.js

    /containers
        /container1</pre>

<p>You can find a complete structure for an app with containers in <a href="https://oreil.ly/JeYgI">the same article</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Hooks"><div class="sect2" id="idm45017684232688">
<h2>Hooks</h2>

<p>Hooks can fit into the hybrid structure<a data-type="indexterm" data-primary="application structure in React" data-secondary="modern React features" data-tertiary="Hooks" id="idm45017684230928"/><a data-type="indexterm" data-primary="React Hooks (Hooks)" data-secondary="application structure" id="idm45017684229616"/><a data-type="indexterm" data-primary="Hooks (React Hooks)" data-secondary="application structure" id="idm45017684228672"/> just like any other type of code. You can have a folder at the app level for common Hooks that can be consumed by all React 
<span class="keep-together">components.</span> React Hooks used by only one component should remain in the 
<span class="keep-together">component’s</span> file or a separate <em>hooks.js</em> file in the component’s folder. You can find a sample structure <a href="https://oreil.ly/rtT1n">here</a>:</p>

<pre data-type="programlisting">/components
    /productList
        index.js
        test.js
        style.css
        hooks.js

/hooks
    /useClickOutside
      index.js
    /useData
      index.js</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Styled Components"><div class="sect2" id="idm45017684223776">
<h2>Styled Components</h2>

<p>If you are using Styled Components<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="Styled Components" id="idm45017684222448"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="modern React features" data-tertiary="Styled Components" id="idm45017684221200"/><a data-type="indexterm" data-primary="CSS (Cascading Style Sheets)" data-secondary="Styled Components instead of" id="idm45017684219968"/><a data-type="indexterm" data-primary="style.js file" id="idm45017684218992"/> instead of CSS, you can have <em>style.js</em> files instead of the component-level CSS files mentioned earlier. For example, if you have a 
<span class="keep-together"><code>titlebar</code></span> component, the structure would be something like this:</p>

<pre data-type="programlisting">/src/components/button/
    index.js
    style.js</pre>

<p>An application-level <a href="https://oreil.ly/OARQ8"><em>theme.js</em> file</a> <a data-type="indexterm" data-primary="theme.js file" id="idm45017684214544"/><a data-type="indexterm" data-primary="globals component" id="idm45017684213808"/>would contain the values for colors to be used for background and text. A <a href="https://oreil.ly/LzmtQ">globals component</a> could include definitions for common style elements that other components can use.<a data-type="indexterm" data-startref="ch14-mod" id="idm45017684212352"/><a data-type="indexterm" data-startref="ch14-mod2" id="idm45017684211648"/></p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Other Best Practices"><div class="sect1" id="idm45017684210720">
<h1>Other Best Practices</h1>

<p>In addition to folder structure,<a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="other best practices" id="idm45017684209232"/><a data-type="indexterm" data-primary="application structure in React" data-secondary="other best practices" id="idm45017684207984"/> some other best practices that you can consider when structuring your React applications are as follows:</p>

<ul>
<li>
<p>Use <a href="https://oreil.ly/trM4V">import aliasing</a> to help<a data-type="indexterm" data-primary="import aliasing" id="idm45017684204784"/><a data-type="indexterm" data-primary="Babel for import aliasing" id="idm45017684204048"/><a data-type="indexterm" data-primary="webpack" data-secondary="import aliasing" id="idm45017684203360"/> with long relative paths for common imports. This can be done using both Babel and <a href="https://oreil.ly/cSkCS">webpack</a> configurations.</p>
</li>
<li>
<p><a href="https://oreil.ly/Za7Yt">Wrap third-party libraries</a> with your API so that they can be swapped if required.<a data-type="indexterm" data-primary="APIs" data-secondary="wrapping third-party libraries" id="idm45017684200016"/></p>
</li>
<li>
<p>Use <a href="https://oreil.ly/8kL84">PropTypes</a> with components to ensure type checking for property values.<a data-type="indexterm" data-primary="PropTypes with components" id="idm45017684197456"/></p>
</li>
</ul>

<p>Build performance depends on the number of files and dependencies. If you’re using a bundler such as webpack, a few suggestions for improving build times may be 
<span class="keep-together">helpful.</span></p>

<p class="less_space pagebreak-before">When using a <a href="https://oreil.ly/zXFkv">loader</a>, apply<a data-type="indexterm" data-primary="loaders" id="idm45017684194032"/> it to only those modules that need to be transformed by it. For example:</p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'path'</code><code class="p">);</code>

<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>
  <code class="c1">//...</code>
 <code class="nx">module</code><code class="o">:</code> <code class="p">{</code>
   <code class="nx">rules</code><code class="o">:</code> <code class="p">[</code>
     <code class="p">{</code>
       <code class="nx">test</code><code class="o">:</code> <code class="sr">/\.js$/</code><code class="p">,</code>
       <code class="nx">include</code><code class="o">:</code> <code class="nx">path</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s1">'src'</code><code class="p">),</code>
       <code class="nx">loader</code><code class="o">:</code> <code class="s1">'babel-loader'</code><code class="p">,</code>
      <code class="p">},</code>
    <code class="p">],</code>
  <code class="p">},</code>
<code class="p">};</code></pre>

<p>If you’re using hybrid/nested folder structures, the following <a href="https://oreil.ly/slT4K">example from webpack</a> shows how to include and load files from different paths in the structure:<a data-type="indexterm" data-primary="webpack" data-secondary="including and loading files from different paths" id="idm45017684162832"/></p>

<pre data-type="programlisting" data-code-language="javascript"><code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'path'</code><code class="p">);</code>

<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">{</code>
  <code class="c1">//...</code>
  <code class="nx">module</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">rules</code><code class="o">:</code> <code class="p">[</code>
      <code class="p">{</code>
       <code class="nx">test</code><code class="o">:</code> <code class="sr">/\.css$/</code><code class="p">,</code>
       <code class="nx">include</code><code class="o">:</code> <code class="p">[</code>
          <code class="c1">// Include paths relative to the current directory starting with</code>
          <code class="c1">// `app/styles` e.g. `app/styles.css`, `app/styles/styles.css`,</code>
          <code class="c1">// `app/stylesheet.css`</code>
          <code class="nx">path</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s1">'app/styles'</code><code class="p">),</code>

         <code class="c1">// add an extra slash to only include the content of the directory</code>
         <code class="c1">// `vendor/styles/`</code>
         <code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s1">'vendor/styles/'</code><code class="p">),</code>
        <code class="p">],</code>
      <code class="p">},</code>
    <code class="p">],</code>
  <code class="p">},</code>
<code class="p">};</code></pre>

<p>Files that do not have an <code>import</code>, <code>require</code>, <code>define</code>, etc. to reference other modules need not be parsed for dependencies. <a data-type="indexterm" data-primary="application structure in React" data-secondary="noParse option" id="idm45017684067520"/><a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="noParse option" id="idm45017684066576"/>You can avoid parsing them using the <a href="https://oreil.ly/UjYPF"><code>noParse</code> option</a>.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Application Structure for Next.js Apps"><div class="sect1" id="idm45017684008640">
<h1>Application Structure for Next.js Apps</h1>

<p><a href="https://oreil.ly/ZeU0P">Next.js</a> is a<a data-type="indexterm" data-primary="application structure in React" data-secondary="Next.js apps" id="idm45017684006768"/><a data-type="indexterm" data-primary="React (React.js)" data-secondary="application structure" data-tertiary="Next.js apps" id="idm45017684005920"/><a data-type="indexterm" data-primary="Next.js" data-secondary="application structure" id="idm45017684004768"/> production-ready framework for scalable React apps. While you can use the hybrid structures, all the routes in the app must be grouped under the pages folder. (URL of the page = the root URL + relative path in the pages folder).</p>

<p>Extending the structures discussed previously, you can have folders for common components, styles, Hooks, and utility functions. Code related on account of the domain can be structured into functional components that different routes can use. Finally, you will have the pages folder for all routes. Here’s an example for this based on <a href="https://oreil.ly/AAv12">this guide</a>:</p>

<pre data-type="programlisting">--- public/
  Favicon.ico
  images/
--- common/
    components/
      datePicker/
        index.js
        style.js
    hooks/
    utils/
    styles/
--- modules/
    auth/
      auth.js
      auth.test.js
    product/
      product.js
      product.test.js
--- pages/
    _app.js
    _document.js
    index.js
        /products
      [id].js</pre>

<p>Next.js also provides <a href="https://oreil.ly/Kim4W">examples</a> for many different types of apps. You can bootstrap these using <code>create-next-app</code> to create the template folder structure provided by Next.js. For example, to create the template for a basic <a href="https://oreil.ly/ym0kh">blog app</a>, use:</p>

<pre data-type="programlisting">yarn create next-app --example blog my-blog</pre>
</div></section>






<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Summary"><div class="sect1" id="idm45017683998688">
<h1>Summary</h1>

<p>This chapter discussed multiple different options for structuring React projects. Depending on the size, type, and components used in the project, you can choose the one most relevant to yours. Sticking to a defined pattern for structuring a project would help you explain it to other team members and prevent projects from getting disorganized and unnecessarily complicated.</p>

<p>The next chapter is the concluding chapter of this book and provides additional links that might be helpful when learning about JavaScript design patterns.</p>
</div></section>
</div></section></div></body></html>