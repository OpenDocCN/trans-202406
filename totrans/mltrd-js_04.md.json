["```\nconst http = require('http');\n\nhttp.createServer((req, res) => {\n  res.end('Hello, World!\\n');\n}).listen(3000);\n```", "```\nconst http = require('http');\nconst cluster = require('cluster'); ![1](Images/1.png)\n\nif (cluster.isPrimary) { ![2](Images/2.png)\n  cluster.fork(); ![3](Images/3.png)\n  cluster.fork();\n  cluster.fork();\n  cluster.fork();\n} else {\n  http.createServer((req, res) => {\n    res.end('Hello, World!\\n');\n  }).listen(3000); ![4](Images/4.png)\n}\n```", "```\nconst { Worker } = require('worker_threads');\n\nconst worker = new Worker('/path/to/worker-file-name.js'); ![1](Images/1.png)\n```", "```\nconst {\n  Worker,\n  isMainThread,\n  workerData\n} = require('worker_threads');\nconst assert = require('assert');\n\nif (isMainThread) { ![1](Images/1.png)\n  const worker = new Worker(__filename, { workerData: { num: 42 } });\n} else {\n  assert.strictEqual(workerData.num, 42);\n}\n```", "```\nconst {\n  Worker,\n  isMainThread,\n  parentPort\n} = require('worker_threads');\n\nif (isMainThread) {\n  const worker = new Worker(__filename);\n  worker.on('message', msg => {\n    worker.postMessage(msg);\n  });\n} else {\n  parentPort.on('message', msg => {\n    console.log('We got a message from the main thread:', msg);\n  });\n  parentPort.postMessage('Hello, World!');\n}\n```", "```\nconst {\n  Worker,\n  isMainThread,\n  MessageChannel,\n  workerData\n} = require('worker_threads');\n\nif (isMainThread) {\n  const { port1, port2 } = new MessageChannel();\n  const worker = new Worker(__filename, {\n    workerData: {\n      port: port2\n    },\n    transferList: [port2]\n  });\n  port1.on('message', msg => {\n    port1.postMessage(msg);\n  });\n} else {\n  const { port } = workerData;\n  port.on('message', msg => {\n    console.log('We got a message from the main thread:', msg);\n  });\n  port.postMessage('Hello, World!');\n}\n```", "```\nconst crypto = require('crypto');\n\nconst big64arr = new BigUint64Array(1)\nfunction random64() {\n  crypto.randomFillSync(big64arr);\n  return big64arr[0];\n}\n```", "```\nfunction sumDigitsSquared(num) {\n  let total = 0n;\n  while (num > 0) {\n    const numModBase = num % 10n;\n    total += numModBase ** 2n;\n    num = num / 10n;\n  }\n  return total;\n}\n\nfunction isHappy(num) {\n  while (num != 1n && num != 4n) {\n    num = sumDigitsSquared(num);\n  }\n  return num === 1n;\n}\n\nfunction isHappycoin(num) {\n  return isHappy(num) && num % 10000n === 0n;\n}\n```", "```\nlet count = 0;\nfor (let i = 1; i < 10_000_000; i++) {\n  const randomNum = random64();\n  if (isHappycoin(randomNum)) {\n    process.stdout.write(randomNum.toString() + ' ');\n    count++;\n  }\n}\n\nprocess.stdout.write('\\ncount ' + count + '\\n');\n```", "```\n$ node happycoin.js\n```", "```\n5503819098300300000 ...  [ 125 more entries ] ... 5273033273820010000\ncount 127\n```", "```\nconst {\n  Worker,\n  isMainThread,\n  parentPort\n} = require('worker_threads');\n```", "```\nconst THREAD_COUNT = 4;\n\nif (isMainThread) {\n  let inFlight = THREAD_COUNT;\n  let count = 0;\n  for (let i = 0; i < THREAD_COUNT; i++) {\n    const worker = new Worker(__filename);\n    worker.on('message', msg => {\n      if (msg === 'done') {\n        if (--inFlight === 0) {\n          process.stdout.write('\\ncount ' + count + '\\n');\n        }\n      } else if (typeof msg === 'bigint') {\n        process.stdout.write(msg.toString() + ' ');\n        count++;\n      }\n    })\n  }\n} else {\n  for (let i = 1; i < 10_000_000/THREAD_COUNT; i++) {\n    const randomNum = random64();\n    if (isHappycoin(randomNum)) {\n      parentPort.postMessage(randomNum);\n    }\n  }\n  parentPort.postMessage('done');\n}\n```", "```\n$ node happycoin-threads.js\n```", "```\n17241719184686550000 ... [ 137 more entries ] ... 17618203841507830000\ncount 139\n\n```", "```\nconst Piscina = require('piscina');\n\nif (!Piscina.isWorkerThread) { ![1](Images/1.png)\n  const piscina = new Piscina({ filename: __filename }); ![2](Images/2.png)\n  piscina.run(9).then(squareRootOfNine => { ![3](Images/3.png)\n    console.log('The square root of nine is', squareRootOfNine);\n  });\n}\n\nmodule.exports = num => Math.sqrt(num); ![4](Images/4.png)\n```", "```\nconst Piscina = require('piscina');\nconst assert = require('assert');\n\nif (!Piscina.isWorkerThread) {\n  const piscina = new Piscina({ filename: __filename });\n  for (let i = 0; i < 10_000_000; i++) {\n    piscina.run(i).then(squareRootOfI => {\n      assert.ok(typeof squareRootOfI === 'number');\n    });\n  }\n}\n\nmodule.exports = num => Math.sqrt(num);\n```", "```\nFATAL ERROR: Reached heap limit Allocation failed\n    - JavaScript heap out of memory\n 1: 0xb12b00 node::Abort() [node]\n 2: 0xa2fe25 node::FatalError(char const*, char const*) [node]\n 3: 0xcf8a9e v8::Utils::ReportOOMFailure(v8::internal::Isolate*,\n    char const*, bool) [node]\n 4: 0xcf8e17 v8::internal::V8::FatalProcessOutOfMemory(v8::internal::Isolate*,\n    char const*, bool) [node]\n 5: 0xee2d65  [node]\n[ ... 13 more lines of a not-particularly-useful C++ stacktrace ... ]\nAborted (core dumped)\n```", "```\nconst Piscina = require('piscina');\nconst assert = require('assert');\nconst { once } = require('events');\n\nif (!Piscina.isWorkerThread) {\n  const piscina = new Piscina({\n    filename: __filename,\n    maxQueue: 'auto' ![1](Images/1.png)\n  });\n  (async () => { ![2](Images/2.png)\n    for (let i = 0; i < 10_000_000; i++) {\n      if (piscina.queueSize === piscina.options.maxQueue) { ![3](Images/3.png)\n        await once(piscina, 'drain'); ![4](Images/4.png)\n      }\n      piscina.run(i).then(squareRootOfI => {\n        assert.ok(typeof squareRootOfI === 'number');\n      });\n    }\n  })();\n}\n\nmodule.exports = num => Math.sqrt(num);\n```", "```\nconst Piscina = require('piscina');\n```", "```\nconst THREAD_COUNT = 4;\n\nif (!Piscina.isWorkerThread) { ![1](Images/1.png)\n  const piscina = new Piscina({\n    filename: __filename, ![2](Images/2.png)\n    minThreads: THREAD_COUNT, ![3](Images/3.png)\n    maxThreads: THREAD_COUNT\n  });\n  let done = 0;\n  let count = 0;\n  for (let i = 0; i < THREAD_COUNT; i++) { ![4](Images/4.png)\n    (async () => {\n      const { total, happycoins } = await piscina.run(); ![5](Images/5.png)\n      process.stdout.write(happycoins);\n      count += total;\n      if (++done === THREAD_COUNT) { ![6](Images/6.png)\n        console.log('\\ncount', count);\n      }\n    })();\n  }\n}\n```", "```\nmodule.exports = () => {\n  let happycoins = '';\n  let total = 0;\n  for (let i = 0; i < 10_000_000/THREAD_COUNT; i++) { ![1](Images/1.png)\n    const randomNum = random64();\n    if (isHappycoin(randomNum)) {\n      happycoins += randomNum.toString() + ' ';\n      total++;\n    }\n  }\n  return { total, happycoins }; ![2](Images/2.png)\n}\n```", "```\n$ npm init -y\n$ npm install piscina\n$ node happycoin-piscina.js\n```"]