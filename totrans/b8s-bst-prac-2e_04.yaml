- en: Chapter 4\. Configuration, Secrets, and RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The composable nature of containers allows us as operators to introduce configuration
    data into a container at runtime. This makes it possible for us to decouple an
    application’s function from the environment it runs in. By means of the conventions
    allowed in the container runtime to pass through either environment variables
    or mount external volumes into a container at runtime, you can effectively change
    the configuration of the application upon its instantiation. As a developer, it
    is important to consider the dynamic nature of this behavior and allow for the
    use of environment variables or the reading of configuration data from a specific
    path available to the application runtime user.
  prefs: []
  type: TYPE_NORMAL
- en: When moving sensitive data such as secrets into a native Kubernetes API object,
    it is important to understand how Kubernetes secures access to the API. The most
    commonly implemented security method in use in Kubernetes is Role-Based Access
    Control (RBAC) to implement a fine-grained permission structure around actions
    that can be taken against the API by specific users or groups. This chapter covers
    some of the best practices regarding RBAC and also provides a small primer.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration Through ConfigMaps and Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes allows you to natively provide configuration information to our applications
    through ConfigMaps or secret resources. The main differentiator between the two
    is the way a pod stores the receiving information and how the data is stored in
    the etcd data store.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very common to have applications consume configuration information through
    some type of mechanism such as command-line arguments, environment variables,
    or files that are available to the system. Containers allow the developer to decouple
    this configuration information from the application, which allows for true application
    portability. The ConfigMap API allows for the injection of supplied configuration
    information. ConfigMaps are very adaptable to the application’s requirements and
    can provide key/value pairs or complex bulk data such as JSON, XML, or proprietary
    configuration data.
  prefs: []
  type: TYPE_NORMAL
- en: The ConfigMaps not only provide configuration information for pods, but they
    can also provide information to be consumed for more complex system services such
    as controllers, CRDs, operators, and so on. As mentioned earlier, the ConfigMap
    API is meant more for string data that is not really sensitive data. If your application
    requires more sensitive data, the Secrets API is more appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: For your application to use the ConfigMap data, it can be injected as either
    a volume mounted into the pod or as environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many of the attributes and reasons for which you would want to use a ConfigMap
    apply to secrets. The main differences lie in the fundamental nature of a secret.
    Secret data should be stored and handled in a way that can be easily hidden and
    possibly encrypted at rest if the environment is configured as such. The secret
    data is represented as base64-encoded information, and it is critical to understand
    that this is not encrypted. As soon as the secret is injected into the pod, the
    pod itself can see the secret data in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secret data is meant to be small amounts of data, limited by default in Kubernetes
    to 1 MB in size for the base64-encoded data, so ensure that the actual data is
    approximately 750 KB because of the overhead of the encoding. There are three
    types of secrets in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`generic`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is typically just regular key/value pairs that are created from a file,
    a directory, or from string literals using the `--from-literal=` parameter, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`docker-registry`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is used by the kubelet when passed in a pod template if there is an `imagePullsecret`
    to provide the credentials needed to authenticate to a private Docker registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`tls`'
  prefs: []
  type: TYPE_NORMAL
- en: 'This creates a Transport Layer Security (TLS) secret from a valid public/private
    key pair. As long as the cert is in a valid PEM format, the key pair will be encoded
    as a secret and can be passed to the pod to use for SSL/TLS needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Secrets are also mounted into tmpfs only on the nodes that have a pod that requires
    the secret and are deleted when the pod that needs the secret is gone. This prevents
    any secrets from being left behind on the disk of the node. Although this might
    seem secure, it is important to know that, by default, secrets are stored in the
    etcd data store of Kubernetes in plain text, and it is important that the system
    administrators or cloud service provider take efforts to ensure the security of
    the etcd environment, including mTLS between the etcd nodes and enabling encryption
    at rest for the etcd data. More recent versions of Kubernetes use etcd3 and have
    the ability to enable etcd native encryption; however, this is a manual process
    that must be configured in the API server configuration by specifying a provider
    and the appropriate key media to properly encrypt secret data held in etcd. As
    of Kubernetes v1.10 (it has been promoted to beta in v1.12), we have the KMS provider,
    which promises to provide a more secure key process by using third-party KMS systems
    to hold the proper keys.
  prefs: []
  type: TYPE_NORMAL
- en: Common Best Practices for the ConfigMap and Secrets APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The majority of issues that arise from the use of a ConfigMap or secret are
    incorrect assumptions about how changes are handled when the data held by the
    object is updated. By understanding the rules of the road and adding a few tricks
    to make it easier to abide by those rules, you can steer away from trouble:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To support dynamic changes to your application without having to redeploy new
    versions of the pods, mount your ConfigMaps/Secrets as a volume and configure
    your application with a file watcher to detect the changed file data and reconfigure
    itself as needed. The following code shows a Deployment that mounts a ConfigMap
    and a Secret file as a volume:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are a couple of things to consider when using `volumeMounts`. First, as
    soon as the ConfigMap/Secret is created, add it as a volume in your pod’s specification.
    Then mount that volume into the container’s filesystem. Each property name in
    the ConfigMap/Secret will become a new file in the mounted directory, and the
    contents of each file will be the value specified in the ConfigMap/Secret. Second,
    avoid mounting ConfigMaps/Secrets using the `volumeMounts.subPath` property. This
    will prevent the data from being dynamically updated in the volume if you update
    a ConfigMap/Secret with new data.
  prefs: []
  type: TYPE_NORMAL
- en: ConfigMaps/Secrets must exist in the namespace for the pods that will consume
    them prior to the pod being deployed. The optional flag can be used to prevent
    the pods from not starting if the ConfigMap/Secret is not present.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an admission controller to ensure specific configuration data or to prevent
    deployments that do not have specific configuration values set. An example would
    be if you require all production Java workloads to have certain JVM properties
    set in production environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re using Helm to release applications into your environment, you can
    use a life cycle hook to ensure the ConfigMap/Secret template is deployed before
    the Deployment is applied.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some applications require their configuration to be applied as a single file
    such as a JSON or YAML file. ConfigMap/Secret allows an entire block of raw data
    by using the `|` symbol, as demonstrated here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If the application uses system environment variables to determine its configuration,
    you can use the injection of the ConfigMap data to create an environment variable
    mapping into the pod. There are two main ways to do this: mounting every key/value
    pair in the ConfigMap as a series of environment variables into the pod using
    `envFrom` and then using `configMapRef` or `secretRef`, or assigning individual
    keys with their respective values using the `configMapKeyRef` or `secretKeyRef`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re using the `configMapKeyRef` or `secretKeyRef` method, be aware that
    if the actual key does not exist, this will prevent the pod from starting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you’re loading all the key/value pairs from the ConfigMap/Secret into the
    pod using `envFrom`, any keys that are considered invalid environment values will
    be skipped; however, the pod will be allowed to start. The event for the pod will
    have an event with reason `InvalidVariableNames` and the appropriate message about
    which key was skipped. The following code is an example of a Deployment with a
    ConfigMap and Secret reference as an environment variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If there is a need to pass command-line arguments to your containers, environment
    variable data can be sourced using `$(ENV_KEY)` interpolation syntax:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When consuming ConfigMap/Secret data as environment variables, it is very important
    to understand that updates to the data in the ConfigMap/Secret will *not* update
    in the pod and will require a pod restart. This can be done either by deleting
    the pods and letting the ReplicaSet controller create a new pod, or by triggering
    a Deployment update, which will follow the proper application update strategy
    as declared in the Deployment specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It is easier to assume that all changes to a ConfigMap/Secret require an update
    to the entire Deployment; this ensures that even if you’re using environment variables
    or volumes, the code will take the new configuration data. To make this easier,
    you can use a CI/CD pipeline to update the `name` property of the ConfigMap/Secret
    and also update the reference in the Deployment, which will then trigger a Deployment
    update through normal Kubernetes update strategies. We will explore this in the
    following example code. If you’re using Helm to release your application code
    into Kubernetes, you can take advantage of an annotation in the Deployment template
    to check the `sha256` checksum of the ConfigMap/Secret. This triggers Helm to
    update the Deployment using the `helm upgrade` command when the data within a
    ConfigMap/Secret is changed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Best Practices Specific to Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because of the nature of sensitive data of the Secrets API, there are naturally
    more specific best practices, which are mainly around the security of the data
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your workload does not need to access the Kubernetes API directly it is
    good practice to block the automounting of the API Credential for the Service
    Account (Default or operator created). This will reduce the API calls to the API
    server as a watch is used to update the API credential data upon the credential
    expiring. In very large clusters or clusters with a lot of pods, this will reduce
    the calls to the Control Plane thus reducing a possible cause of performance degradation.
    This can be defined on the ServiceAccount or the Pod Spec itself:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The original specification for the Secrets API outlined a pluggable architecture
    to allow the actual storage of the secret to be configurable based on requirements.
    Solutions such as HashiCorp Vault, Aqua Security, Twistlock, AWS Secrets Manager,
    Google Cloud KMS, or Azure Key Vault allow the use of external storage systems
    for secret data using a higher level of encryption and auditability than what
    is offered natively in Kubernetes. The Linux Foundation project ExternalSecrets
    Operator provides a native way to provide this functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Assign an `imagePullSecrets` to a `serviceaccount` that the pod will use to
    automatically mount the secret without having to declare it in the `pod.spec`.
    You can patch the default service account for the namespace of your application
    and add the `imagePullSecrets` to it directly. This automatically adds it to all
    pods in the namespace:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Use CI/CD capabilities to get secrets from a secure vault or encrypted store
    with a Hardware Security Module (HSM) during the release pipeline. This allows
    for separation of duties. Security management teams can create and encrypt the
    secrets, and developers just need to reference the names of the secret expected.
    This is also the preferred DevOps process to ensure a more dynamic application
    delivery process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working in large, distributed environments, it is very common that some
    type of security mechanism is needed to prevent unauthorized access to critical
    systems. There are numerous strategies around how to limit access to resources
    in computer systems, but the majority all go through the same phases. Using an
    analogy of a common experience such as flying to a foreign country can help explain
    the processes that happen in systems like Kubernetes. We can use the common traveler’s
    experience with a passport, travel visa, and customs or border guards to show
    the process:'
  prefs: []
  type: TYPE_NORMAL
- en: Passport (subject authentication)
  prefs: []
  type: TYPE_NORMAL
- en: Usually you need to have a passport issued by some government agency that will
    offer some sort of verification as to who you are. This would be equivalent to
    a user account in Kubernetes. Kubernetes relies on an external authority to authenticate
    users; however, service accounts are a type of account that is managed directly
    by Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Visa or travel policy (authorization)
  prefs: []
  type: TYPE_NORMAL
- en: Countries will have formal agreements to accept travelers holding passports
    from other countries through formal short-term agreements such as visas. The visas
    will also outline what the visitor may do and for how long they may stay in the
    visiting country, depending on the specific type of visa. This would be equivalent
    to authorization in Kubernetes. Kubernetes has different authorization methods,
    but RBAC is the one used most. This allows very granular access to different API
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Border patrol or customs (admission control)
  prefs: []
  type: TYPE_NORMAL
- en: When entering a foreign country, usually there is a body of authority that will
    check the requisite documents, including the passport and visa, and, in many cases,
    inspect what is being brought into the country to ensure it abides by that country’s
    laws. In Kubernetes this is equivalent to admission controllers. Admission controllers
    can allow, deny, or change the requests into the API based upon rules and policies
    that are defined. Kubernetes has many built-in admission controllers such as PodSecurity,
    ResourceQuota, and ServiceAccount controllers. Kubernetes also allows for dynamic
    controllers through the use of validating or mutating admission controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The focus of this section is the least understood and the most avoided of these
    three areas: RBAC. Before we outline some of the best practices, we first must
    present a primer on Kubernetes RBAC.'
  prefs: []
  type: TYPE_NORMAL
- en: RBAC Primer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The RBAC process in Kubernetes has three main components that need to be defined:
    the subject, the rule, and the role binding.'
  prefs: []
  type: TYPE_NORMAL
- en: Subjects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first component is the subject, the item that is actually being checked
    for access. The subject is usually a user, a service account, or a group. As mentioned
    earlier, users as well as groups are handled outside of Kubernetes by the authorization
    module used. We can categorize these as basic authentication, x.509 client certificates,
    or bearer tokens. The most common implementations use either x.509 client certificates
    or some type of bearer token using something like an OpenID Connect system such
    as Azure Active Directory (Azure AD), Salesforce, or Google.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Service accounts in Kubernetes are different from user accounts in that they
    are namespace bound and internally stored in Kubernetes; they are meant to represent
    processes, not people, and are managed by native Kubernetes controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Simply stated, this is the actual list of actions that can be performed on
    a specific object (resource) or a group of objects in the API. Verbs align to
    typical create, read, update, and delete (CRUD) type operations but with some
    added capabilities in Kubernetes such as `watch`, `list`, and `exec`. The objects
    align to the different API components and are grouped together in categories.
    Pod objects, as an example, are part of the core API and can be referenced with
    `apiGroup: ""`, whereas deployments are under the app API group. This is the real
    power of the RBAC process and probably what intimidates and confuses people when
    creating proper RBAC controls.'
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Roles allow the definition of scope of the rules defined. Kubernetes has two
    types of roles, `role` and `clusterRole`, the difference being that `role` is
    specific to a namespace, and `clusterRole` is a cluster-wide role across all namespaces.
    An example role definition with namespace scope would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: RoleBindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The RoleBinding allows a mapping of a subject like a user or group to a specific
    role. Bindings also have two modes: `roleBinding`, which is specific to a namespace,
    and `clusterRoleBinding`, which is across the entire cluster. Here’s an example
    RoleBinding with namespace scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: RBAC Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RBAC is a critical component of running a secure, dependable, and stable Kubernetes
    environment. The concepts underlying RBAC can be complex; however, adhering to
    a few best practices can ease some of the major stumbling blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications that are developed to run in Kubernetes rarely ever need an RBAC
    role and RoleBinding associated to them. Only if the application code interacts
    directly with the Kubernetes API does the application require RBAC configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the application does need to directly access the Kubernetes API to perhaps
    change configuration depending on endpoints being added to a service, or if it
    needs to list all the pods in a specific namespace, the best practice is to create
    a new service account that is then specified in the pod specification. Then, create
    a role that has the least amount of privileges needed to accomplish its goal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use an OpenID Connect service that enables identity management and, if needed,
    two-factor authentication. This will allow for a higher level of identity authentication.
    Map user groups to roles that have the least amount of privileges needed to accomplish
    the job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along with the aforementioned practice, you should use Just in Time (JIT) access
    systems to allow site reliability engineers (SREs), operators, and those who might
    need to have escalated privileges for a short period of time to accomplish a very
    specific task. Alternatively, these users should have different identities that
    are more heavily audited for sign-on, and those accounts should have more elevated
    privileges assigned by the user account or group bound to a role.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Specific service accounts should be used for CI/CD tools that deploy into your
    Kubernetes clusters. This ensures auditability within the cluster and an understanding
    of who might have deployed or deleted any objects in a cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re still using Helm v2 to deploy applications, the default service account
    is Tiller, deployed to `kube-system`. It is better to deploy Tiller into each
    namespace with a service account specifically for Tiller that is scoped for that
    namespace. In the CI/CD tool that calls the Helm install/upgrade command, as a
    prestep, initialize the Helm client with the service account and the specific
    namespace for the Deployment. The service account name can be the same for each
    namespace, but the namespace should be specific. It is advised to move to Helm
    v3 because one of its core principles is that Tiller is no longer needed to run
    in a cluster. The new architecture is completely client based and uses the RBAC
    access of the user calling the Helm commands. This is in alignment with the preferred
    approach of client-based tooling to the Kubernetes API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit any applications that require `watch` and `list` on the Secrets API. This
    basically allows the application or the person who deployed the pod to view the
    secrets in that namespace. If an application needs to access the Secrets API for
    specific secrets, limit using `get` on any specific secrets that the application
    needs to read outside of those that it is directly assigned.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Principles for developing applications for cloud native delivery is a topic
    for another day, but it is universally accepted that strict separation of configuration
    from code is a key principle for success. With native objects for nonsensitive
    data, the ConfigMap API, and for sensitive data, the Secrets API, Kubernetes can
    now manage this process in a declarative approach. As more and more critical data
    is represented and stored natively in the Kubernetes API, it is critical to secure
    access to those APIs through proper gated security processes such as RBAC and
    integrated authentication systems.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ll see throughout the rest of this book, these principles permeate every
    aspect of the proper deployment of services into a Kubernetes platform to build
    a stable, reliable, secure, and robust system.
  prefs: []
  type: TYPE_NORMAL
