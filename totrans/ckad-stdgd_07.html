<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Volumes" class="praise"><div class="dedication" id="volumes">
<h1 class="calibre14"><span class="keep-together">Chapter 7. </span>Volumes</h1>


<p class="author1">A container’s temporary filesystem is isolated from any other container or Pod and is not persisted beyond a Pod restart. A Pod can define a Volume and mount it to a 
<span class="keep-together">container.</span></p>

<p class="author1">Ephemeral Volumes exist for the lifespan of a Pod. They are useful if you want to share data between multiple containers running in the Pod. Persistent Volumes preserve data beyond the lifespan of a Pod. They are a good option for applications that require data to exist longer, e.g., in the form of storage for a database-driven application. In this chapter, we’ll exercise the use of different Volumes types in a Pod.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id475">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objective:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Utilize persistent and ephemeral volumes</p>
</li>
</ul>
</div></aside>






<section data-type="sect1" data-pdf-bookmark="Working with Storage" class="praise"><div class="dedication" id="id206">
<h1 class="calibre17">Working with Storage</h1>

<p class="author1">Applications running in a container can use the temporary filesystem to read and write files. In case of a container crash or a cluster/node restart, the kubelet will restart the container. Any data that had been written to the temporary filesystem is lost and cannot be retrieved. The container effectively starts with a clean slate.</p>

<p class="author1">There are many uses cases for wanting to mount a Volume in a container. We’ll see one of the most prominent use cases in <a data-type="xref" href="ch08.xhtml#multi_container_pods" class="calibre10">Chapter 8</a>: using an ephemeral Volume to exchange data between a main application container and a sidecar. <a data-type="xref" href="#tmp_file_system_volume" class="calibre10">Figure 7-1</a> illustrates the differences between the temporary filesystem of a container and the use of a Volume.</p>

<figure class="calibre35"><div id="tmp_file_system_volume" class="figure">
<img src="Images/ckd2_0701.png" alt="ckd2 0701" class="calibre73"/>
<h6 class="calibre32"><span class="keep-together">Figure 7-1. </span>A container using the temporary filesystem versus a Volume</h6>
</div></figure>








<section data-type="sect2" data-pdf-bookmark="Volume Types" class="praise"><div class="dedication" id="id207">
<h2 class="calibre33">Volume Types</h2>

<p class="author1">Every Volume needs to define a type. The type determines the medium that backs the Volume and its runtime behavior.</p>
<dl class="calibre18">
<dt class="calibre19">Ephemeral Volumes</dt>
<dd class="calibre20">
<p class="calibre21">These exist for the lifespan of a Pod. Ephemeral Volumes are useful if you want to share data between multiple containers running in the Pod or if you can easily reconstruct the data stored on the Volume upon a Pod restart.</p>
</dd>
<dt class="calibre19">Persistent Volumes</dt>
<dd class="calibre20">
<p class="calibre21">These preserve data beyond the lifespan of a Pod. Persistent Volumes are a good option for applications that require data to exist longer, for example, in the form of storage for a database-driven application.</p>
</dd>
</dl>

<p class="author1">The Kubernetes documentation offers a long list of Volume types. <a data-type="xref" href="#table_volume_types" class="calibre10">Table 7-1</a> provides a select list of Volume types that I have found to be most relevant to the exam.</p>
<table id="table_volume_types" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 7-1. </span>Volume types most relevant to exam</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Type</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">emptyDir</code></p></td>
<td class="calibre65"><p class="author1">Empty directory in Pod with read/write access. Only persisted for the lifespan of a Pod. A good choice for cache implementations or data exchange between containers of a Pod.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">hostPath</code></p></td>
<td class="calibre65"><p class="author1">File or directory from the host node’s filesystem. Supported only on single-node clusters and not meant for production.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">configMap</code>, <code class="calibre60">secret</code></p></td>
<td class="calibre65"><p class="author1">Provides a way to inject configuration data. For practical examples, see <a data-type="xref" href="ch19.xhtml#configmaps_secrets" class="calibre10">Chapter 19</a>.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">nfs</code></p></td>
<td class="calibre65"><p class="author1">An existing NFS (Network File System) share. Preserves data after Pod restart.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">persistentVolumeClaim</code></p></td>
<td class="calibre65"><p class="author1">Claims a Persistent Volume. For more information, see <a data-type="xref" href="#creating_pvc" class="calibre10">“Creating PersistentVolumeClaims”</a>.</p></td>
</tr>
</tbody>
</table>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Ephemeral Volumes" class="praise"><div class="dedication" id="id208">
<h2 class="calibre33">Ephemeral Volumes</h2>

<p class="author1">Defining an ephemeral Volume for a Pod requires two steps. First, you need to declare the Volume itself using the attribute <code class="calibre15">spec.volumes[]</code>. As part of the definition, you provide the name and the type. Just declaring the Volume won’t be 
<span class="keep-together">sufficient.</span> Second, the Volume needs to be mounted to a path of the consuming container via <code class="calibre15">spec.containers[].volumeMounts[]</code>. The mapping between the Volume and the Volume mount occurs through the matching name.</p>










<section data-type="sect3" data-pdf-bookmark="Creating and mounting an ephemeral Volume" class="praise"><div class="dedication" id="id209">
<h3 class="calibre44">Creating and mounting an ephemeral Volume</h3>

<p class="author1">In <a data-type="xref" href="#ephemeral_volume" class="calibre10">Example 7-1</a>, stored in the file <em class="calibre3">pod-with-volume.yaml</em> here, you can see the definition of a Volume with type <code class="calibre15">emptyDir</code>. The Volume has been mounted to the path <em class="calibre3">/var/log/nginx</em> inside the container named <code class="calibre15">nginx</code>.</p>
<div id="ephemeral_volume" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 7-1. </span>A Pod defining and mounting a ephemeral Volume</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">business-app</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">logs-volume</code><code class="w"></code>
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="calibre15">{}</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx:1.25.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/var/log/nginx</code><code class="w"></code>
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">logs-volume</code><code class="w"></code></pre></div>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Interacting with the Volume" class="praise"><div class="dedication" id="id210">
<h3 class="calibre44">Interacting with the Volume</h3>

<p class="author1">Let’s create the Pod and see if we can interact with the mounted Volume. The following commands open an interactive shell after the Pod’s creation, then navigate to the mount path. You can see that the Volume type <code class="calibre15">emptyDir</code> initializes the mount path as an empty directory. New files and directories can be created as needed without 
<span class="keep-together">limitations:</span></p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create -f pod-with-volume.yaml</strong>
pod/business-app created
<strong class="calibre38">$ kubectl get pod business-app</strong>
NAME           READY   STATUS    RESTARTS   AGE
business-app   1/1     Running   0          43s
<strong class="calibre38">$ kubectl exec business-app -it -- /bin/sh</strong>
# cd /var/log/nginx
# pwd
/var/log/nginx
# ls
# touch app-logs.txt
# ls
app-logs.txt
</pre>

<p class="author1">For an illustrative use case of the <code class="calibre15">emptyDir</code> Volume type mounted by more than one container, see <a data-type="xref" href="ch08.xhtml#multi_container_pods" class="calibre10">Chapter 8</a>.</p>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Persistent Volumes" class="praise"><div class="dedication" id="id211">
<h2 class="calibre33">Persistent Volumes</h2>

<p class="author1">Data stored on Volumes outlives a container restart. In many applications, the data lives far beyond the life cycles of the applications, container, Pod, nodes, and even the clusters themselves. Data persistence ensures the life cycles of the data are decoupled from the life cycles of the cluster resources. A typical example would be data persisted by a database. That’s the responsibility of a persistent Volume. Kubernetes models persist data with the help of two primitives: the PersistentVolume and the PersistentVolumeClaim.</p>

<p class="author1">The PersistentVolume is the primitive representing a piece of storage in a Kubernetes cluster. It is completely decoupled from the Pod and therefore has its own life cycle. The object captures the source of the storage (e.g., storage made available by a cloud provider). A PersistentVolume is either provided by a Kubernetes administrator or assigned dynamically by mapping to a storage class.</p>

<p class="author1">The PersistentVolumeClaim requests the resources of a PersistentVolume—for example, the size of the storage and the access type. In the Pod, you will use the type 
<span class="keep-together"><code class="calibre15">persistentVolumeClaim</code></span> to mount the abstracted PersistentVolume by using the 
<span class="keep-together">PersistentVolumeClaim.</span></p>

<p class="author1"><a data-type="xref" href="#pvc_relationship" class="calibre10">Figure 7-2</a> shows the relationship between the Pod, the PersistentVolumeClaim, and the PersistentVolume.</p>

<figure class="calibre35"><div id="pvc_relationship" class="figure">
<img src="Images/ckd2_0702.png" alt="ckd2 0702" class="calibre74"/>
<h6 class="calibre32"><span class="keep-together">Figure 7-2. </span>Claiming a PersistentVolume from a Pod</h6>
</div></figure>










<section data-type="sect3" data-pdf-bookmark="Static versus dynamic provisioning" class="praise"><div class="dedication" id="id212">
<h3 class="calibre44">Static versus dynamic provisioning</h3>

<p class="author1">A PersistentVolume can be created statically or dynamically. If you go with the static approach, then you first need to create a storage device and then reference it by explicitly creating an object of kind PersistentVolume. The dynamic approach doesn’t require you to create a PersistentVolume object. It will be automatically created from the PersistentVolumeClaim by setting a storage class name using the attribute <code class="calibre15">spec.storageClassName</code>.</p>

<p class="author1">A storage class is an abstraction concept that defines a class of storage device (e.g., storage with slow or fast performance) used for different application types. It’s the job of a Kubernetes administrator to set up storage classes. For a deeper discussion on storage classes, see <a data-type="xref" href="#understanding_storage_class" class="calibre10">“Storage Classes”</a>. For now, we’ll focus on the static provisioning of PersistentVolumes.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Creating PersistentVolumes" class="praise"><div class="dedication" id="creating_pv">
<h3 class="calibre44">Creating PersistentVolumes</h3>

<p class="author1">When you create a PersistentVolume object yourself, we refer to the approach as static provisioning. A PersistentVolume can be created only by using the manifest-first approach. At this time, <code class="calibre15">kubectl</code> doesn’t allow the creation of a PersistentVolume using the <code class="calibre15">create</code> command. Every PersistentVolume needs to define the storage capacity using <code class="calibre15">spec.capacity</code> and an access mode set via <code class="calibre15">spec.accessModes</code>. See <a data-type="xref" href="#configuring_pv" class="calibre10">“Configuration options for a PersistentVolume”</a> for more information on the configuration options available to a PersistentVolume.</p>

<p class="author1"><a data-type="xref" href="#yaml_manifest_persistent_volume" class="calibre10">Example 7-2</a> creates a PersistentVolume named <code class="calibre15">db-pv</code> with a storage capacity of 1Gi and read/write access by a single node. The attribute <code class="calibre15">hostPath</code> mounts the directory 
<span class="keep-together"><em class="calibre3">/data/db</em></span> from the host node’s filesystem. We’ll store the YAML manifest in the file <code class="calibre15">db-pv.yaml</code>.</p>
<div id="yaml_manifest_persistent_volume" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 7-2. </span>YAML manifest defining a PersistentVolume</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">PersistentVolume</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-pv</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">capacity</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="calibre15">1Gi</code><code class="w"></code>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">ReadWriteOnce</code><code class="w"></code>
<code class="w">  </code><code class="nt">hostPath</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/data/db</code><code class="w"></code></pre></div>

<p class="author1">When you inspect the created PersistentVolume, you’ll find most of the information you provided in the manifest. The status <code class="calibre15">Available</code> indicates that the object is ready to be claimed. The reclaim policy determines what should happen with the PersistentVolume after it has been released from its claim. By default, the object will be retained. The following example uses the short-form command <code class="calibre15">pv</code> to avoid having to type <code class="calibre15">persistentvolume</code>:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create -f db-pv.yaml</strong>
persistentvolume/db-pv created
<strong class="calibre38">$ kubectl get pv db-pv</strong>
NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    \
  CLAIM   STORAGECLASS   REASON   AGE
db-pv   1Gi        RWO            Retain           Available \
                                  10s</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Configuration options for a PersistentVolume" class="praise"><div class="dedication" id="configuring_pv">
<h3 class="calibre44">Configuration options for a PersistentVolume</h3>

<p class="author1">A PersistentVolume offers a variety of configuration options that determine their innate runtime behavior. For the exam, it’s important to understand the volume mode, access mode, and reclaim policy configuration options.</p>












<section data-type="sect4" data-pdf-bookmark="Volume mode" class="praise"><div class="dedication" id="id215">
<h4 class="calibre75">Volume mode</h4>

<p class="author1">The volume mode handles the type of device. That’s a device either meant to be consumed from the filesystem or backed by a block device. The most common case is a filesystem device. You can set the volume mode using the attribute <code class="calibre15">spec.volumeMode</code>. <a data-type="xref" href="#persistentvolume_volume_modes" class="calibre10">Table 7-2</a> shows all available volume modes.</p>
<table id="persistentvolume_volume_modes" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 7-2. </span>PersistentVolume volume modes</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Type</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1">
<span class="keep-together"><code class="calibre60">Filesystem</code></span></p></td>
<td class="calibre65"><p class="author1">Default. Mounts the volume into a directory of the consuming Pod. Creates a filesystem first if the volume is backed by a block device and the device is empty.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">Block</code></p></td>
<td class="calibre65"><p class="author1">Used for a volume as a raw block device without a filesystem on it.</p></td>
</tr>
</tbody>
</table>

<p class="author1">The volume mode is not rendered by default in the console output of the <code class="calibre15">get pv</code> command. You will need to provide the <code class="calibre15">-o wide</code> command-line option to see the <code class="calibre15">VOLUMEMODE</code> column, as shown here:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get pv -o wide</strong>
NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS    \
CLAIM   STORAGECLASS   REASON   AGE   VOLUMEMODE
db-pv   1Gi        RWO            Retain           Available \
                                19m   Filesystem</pre>
</div></section>












<section data-type="sect4" data-pdf-bookmark="Access mode" class="praise"><div class="dedication" id="id216">
<h4 class="calibre75">Access mode</h4>

<p class="author1">Each PersistentVolume can express how it can be accessed using the attribute <code class="calibre15">spec.accessModes</code>. For example, you can define that the volume can be mounted only by a single Pod in a read or write mode or that a volume is read-only but accessible from different nodes simultaneously. <a data-type="xref" href="#persistentvolume_access_modes" class="calibre10">Table 7-3</a> provides an overview of the available access modes. The short-form notation of the access mode is usually rendered in outputs of specific commands, e.g., <code class="calibre15">get pv</code> or <code class="calibre15">describe pv</code>.</p>
<table id="persistentvolume_access_modes" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 7-3. </span>PersistentVolume access modes</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Type</th>
<th class="calibre63">Short Form</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">ReadWriteOnce</code></p></td>
<td class="calibre65"><p class="author1">RWO</p></td>
<td class="calibre65"><p class="author1">Read/write access by a single node</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">ReadOnlyMany</code></p></td>
<td class="calibre65"><p class="author1">ROX</p></td>
<td class="calibre65"><p class="author1">Read-only access by many nodes</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">ReadWriteMany</code></p></td>
<td class="calibre65"><p class="author1">RWX</p></td>
<td class="calibre65"><p class="author1">Read/write access by many nodes</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">ReadWriteOncePod</code></p></td>
<td class="calibre65"><p class="author1">RWOP</p></td>
<td class="calibre65"><p class="author1">Read/write access mounted by a single Pod</p></td>
</tr>
</tbody>
</table>

<p class="author1">The following command parses the access modes from the PersistentVolume named <code class="calibre15">db-pv</code>. As you can see, the returned value is an array underlining the fact that you can assign multiple access modes at once:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pv db-pv -o jsonpath='{.spec.accessModes}'</strong>
["ReadWriteOnce"]
</pre>
</div></section>












<section data-type="sect4" data-pdf-bookmark="Reclaim policy" class="praise"><div class="dedication" id="id217">
<h4 class="calibre75">Reclaim policy</h4>

<p class="author1">Optionally, you can also define a reclaim policy for a PersistentVolume. The reclaim policy specifies what should happen to a PersistentVolume object when the bound PersistentVolumeClaim is deleted (see <a data-type="xref" href="#persistentvolume_reclaim_policy" class="calibre10">Table 7-4</a>). For dynamically created PersistentVolumes, the reclaim policy can be set via the attribute <code class="calibre15">.reclaimPolicy</code> in the storage class. For statically created PersistentVolumes, use the attribute <code class="calibre15">spec.persistentVolumeReclaimPolicy</code> in the PersistentVolume definition.</p>
<table id="persistentvolume_reclaim_policy" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 7-4. </span>PersistentVolume reclaim policies</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Type</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">Retain</code></p></td>
<td class="calibre65"><p class="author1">Default. When PersistentVolumeClaim is deleted, the PersistentVolume is “released” and can be reclaimed.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">Delete</code></p></td>
<td class="calibre65"><p class="author1">Deletion removes PersistentVolume and its associated storage.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">Recycle</code></p></td>
<td class="calibre65"><p class="author1">This value is deprecated. You should use one of the other values.</p></td>
</tr>
</tbody>
</table>

<p class="author1">This command retrieves the assigned reclaim policy of the PersistentVolume named <code class="calibre15">db-pv</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pv db-pv -o jsonpath='{.spec.persistentVolumeReclaimPolicy}'</strong>
Retain
</pre>
</div></section>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Creating PersistentVolumeClaims" class="praise"><div class="dedication" id="creating_pvc">
<h3 class="calibre44">Creating PersistentVolumeClaims</h3>

<p class="author1">The next object we’ll need to create is the PersistentVolumeClaim. Its purpose is to bind the PersistentVolume to the Pod. Let’s look at the YAML manifest stored in the file <em class="calibre3">db-pvc.yaml</em>, shown in <a data-type="xref" href="#yaml_manifest_persistent_volume_claim" class="calibre10">Example 7-3</a>.</p>
<div id="yaml_manifest_persistent_volume_claim" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 7-3. </span>Definition of a PersistentVolumeClaim</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">PersistentVolumeClaim</code><code class="w"></code>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-pvc</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">ReadWriteOnce</code><code class="w"></code>
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"></code>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="calibre15">256Mi</code><code class="w"></code></pre></div>

<p class="author1">What we’re saying is: “Give me a PersistentVolume that can fulfill the resource request of 256Mi and provides the access mode <code class="calibre15">ReadWriteOnce</code>.” Static provisioning should use an empty string for the attribute <code class="calibre15">spec.storageClassName</code> if you do not want it to automatically assign the default storage class. The binding to an appropriate PersistentVolume happens automatically based on those criteria.</p>

<p class="author1">After creating the PersistentVolumeClaim, the status is set as <code class="calibre15">Bound</code>, which means that the binding to the PersistentVolume was successful. Once the associated binding occurs, nothing else can bind to it. The binding relationship is one-to-one. Nothing else can bind to the PersistentVolume once claimed. The following <code class="calibre15">get</code> command uses the short-form <code class="calibre15">pvc</code> instead of <code class="calibre15">persistentvolumeclaim</code>:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create -f db-pvc.yaml</strong>
persistentvolumeclaim/db-pvc created
<strong class="calibre38">$ kubectl get pvc db-pvc</strong>
NAME     STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE
db-pvc   Bound    db-pv    1Gi        RWO                           111s</pre>

<p class="author1">The PersistentVolume has not been mounted by a Pod yet. Therefore, inspecting the details of the object shows <code class="calibre15">&lt;none&gt;</code>. Using the <code class="calibre15">describe</code> command is a good way to verify if the PersistentVolumeClaim was mounted properly:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl describe pvc db-pvc</strong>
...
Used By:       &lt;none&gt;
...</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Mounting PersistentVolumeClaims in a Pod" class="praise"><div class="dedication" id="mounting_persistent_volume">
<h3 class="calibre44">Mounting PersistentVolumeClaims in a Pod</h3>

<p class="author1">All that’s left is to mount the PersistentVolumeClaim in the Pod that wants to consume it. You already learned how to mount a volume in a Pod. The big difference here, shown in <a data-type="xref" href="#pod_referencing_persistent_volume_claim" class="calibre10">Example 7-4</a>, is using <code class="calibre15">spec.volumes[].persistentVolumeClaim</code> and providing the name of the PersistentVolumeClaim.</p>
<div id="pod_referencing_persistent_volume_claim" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 7-4. </span>A Pod referencing a PersistentVolumeClaim</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">app-consuming-pvc</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">app-storage</code><code class="w"></code>
<code class="w">    </code><code class="nt">persistentVolumeClaim</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">claimName</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-pvc</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">alpine:3.18.2</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">app</code><code class="w"></code>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="calibre15">[</code><code class="s">"/bin/sh"</code><code class="calibre15">]</code><code class="w"></code>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="calibre15">[</code><code class="s">"-c"</code><code class="calibre15">,</code><code class="w"> </code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">60;</code><code class="nv"> </code><code class="s">done;"</code><code class="calibre15">]</code><code class="w"></code>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/mnt/data"</code><code class="w"></code>
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">app-storage</code><code class="w"></code></pre></div>

<p class="author1">Let’s assume we stored the configuration in the file <em class="calibre3">app-consuming-pvc.yaml</em>. After creating the Pod from the manifest, you should see the Pod transitioning into the <code class="calibre15">Ready</code> state. The <code class="calibre15">describe</code> command will provide additional information on the 
<span class="keep-together">volume:</span></p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create -f app-consuming-pvc.yaml</strong>
pod/app-consuming-pvc created
<strong class="calibre38">$ kubectl get pods</strong>
NAME                READY   STATUS    RESTARTS   AGE
app-consuming-pvc   1/1     Running   0          3s
<strong class="calibre38">$ kubectl describe pod app-consuming-pvc</strong>
...
Volumes:
  app-storage:
    Type:       PersistentVolumeClaim (a reference to a PersistentVolumeClaim \
                in the same namespace)
    ClaimName:  db-pvc
    ReadOnly:   false
...</pre>

<p class="author1">The PersistentVolumeClaim now also shows the Pod that mounted it:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl describe pvc db-pvc</strong>
...
Used By:       app-consuming-pvc
...</pre>

<p class="author1">You can now go ahead and open an interactive shell to the Pod. Navigating to the mount path at <em class="calibre3">/mnt/data</em> gives you access to the underlying PersistentVolume:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl exec app-consuming-pvc -it -- /bin/sh</strong>
/ # cd /mnt/data
/mnt/data # ls -l
total 0
/mnt/data # touch test.db
/mnt/data # ls -l
total 0
-rw-r--r--    1 root     root             0 Sep 29 23:59 test.db</pre>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Storage Classes" class="praise"><div class="dedication" id="understanding_storage_class">
<h2 class="calibre33">Storage Classes</h2>

<p class="author1">A storage class is a Kubernetes primitive that defines a specific type or “class” of storage. Typical storage characteristics can be the type (e.g., fast SSD storage versus remote cloud storage or the backup policy for storage). The storage class is used to provision a PersistentVolume dynamically based on its criteria. In practice, this means that you do not have to create the PersistentVolume object yourself. The 
<span class="keep-together">provisioner</span> assigned to the storage class takes care of it. Most Kubernetes cloud providers come with a list of existing provisioners. Minikube already creates a default storage class named <code class="calibre15">standard</code>, which you can query with the following command:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get storageclass</strong>
NAME                 PROVISIONER                RECLAIMPOLICY \
  VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
standard (default)   k8s.io/minikube-hostpath   Delete        \
  Immediate           false                  108d</pre>










<section data-type="sect3" data-pdf-bookmark="Creating storage classes" class="praise"><div class="dedication" id="creating_storage_class">
<h3 class="calibre44">Creating storage classes</h3>

<p class="author1">Storage classes can be created declaratively only with the help of a YAML manifest. At a minimum, you need to declare the provisioner. All other attributes are optional and use default values if not provided upon creation. Most provisioners let you set parameters specific to the storage type. <a data-type="xref" href="#storage_class_gce" class="calibre10">Example 7-5</a> defines a storage class on Google Compute Engine denoted by the provisioner <code class="calibre15">kubernetes.io/gce-pd</code>.</p>
<div id="storage_class_gce" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 7-5. </span>Definition of a storage class</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">storage.k8s.io/v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">StorageClass</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">fast</code><code class="w"></code>
<code class="nt">provisioner</code><code class="p">:</code><code class="w"> </code><code class="calibre15">kubernetes.io/gce-pd</code><code class="w"></code>
<code class="nt">parameters</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">pd-ssd</code><code class="w"></code>
<code class="w">  </code><code class="nt">replication-type</code><code class="p">:</code><code class="w"> </code><code class="calibre15">regional-pd</code><code class="w"></code></pre></div>

<p class="author1">If you saved the YAML contents in the file <em class="calibre3">fast-sc.yaml</em>, then the following command will create the object. The storage class can be listed using the <code class="calibre15">get storageclass</code> command:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl create -f fast-sc.yaml</strong>
storageclass.storage.k8s.io/fast created
<strong class="calibre38">$ kubectl get storageclass</strong>
NAME                 PROVISIONER                RECLAIMPOLICY \
  VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE
fast                 kubernetes.io/gce-pd       Delete        \
  Immediate           false                  4s
...</pre>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Using storage classes" class="praise"><div class="dedication" id="id222">
<h3 class="calibre44">Using storage classes</h3>

<p class="author1">Provisioning a PersistentVolume dynamically requires assigning of the storage class when you create the PeristentVolumeClaim. <a data-type="xref" href="#yaml_manifest_persistent_volume_claim_storage_class" class="calibre10">Example 7-6</a> shows the usage of the attribute <code class="calibre15">spec.storageClassName</code> for assigning the storage class named <code class="calibre15">standard</code>.</p>
<div id="yaml_manifest_persistent_volume_claim_storage_class" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 7-6. </span>Using a storage class in a PersistentVolumeClaim</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">PersistentVolumeClaim</code><code class="w"></code>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">db-pvc</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">accessModes</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">ReadWriteOnce</code><code class="w"></code>
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="nt">requests</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">storage</code><code class="p">:</code><code class="w"> </code><code class="calibre15">512Mi</code><code class="w"></code>
<code class="w">  </code><code class="nt">storageClassName</code><code class="p">:</code><code class="w"> </code><code class="calibre15">standard</code><code class="w"></code></pre></div>

<p class="author1">The corresponding PersistentVolume object will be created only if the storage class can provision a fitting PersistentVolume using its provisioner. It’s important to understand that Kubernetes does not render an error or warning message if it isn’t the case.</p>

<p class="author1">The following command renders the created PersistentVolumeClaim and PersistentVolume. As you can see, the name of the dynamically provisioned PersistentVolume uses a hash to ensure a unique naming:</p>

<pre data-type="programlisting" class="calibre37"><strong class="calibre38">$ kubectl get pv,pvc</strong>
NAME                                                       CAPACITY \
  ACCESS MODES  RECLAIM POLICY  STATUS  CLAIM           STORAGECLASS \
  REASON  AGE
persistentvolume/pvc-b820b919-f7f7-4c74-9212-ef259d421734   512Mi \
    RWO           Delete          Bound   default/db-pvc  standard \
                  2s

NAME                          STATUS  VOLUME                                  \
CAPACITY  ACCESS MODES  STORAGECLASS  AGE
persistentvolumeclaim/db-pvc  Bound   pvc-b820b919-f7f7-4c74-9212-ef259d421734 \
512Mi     RWO           standard      2s</pre>

<p class="author1">The steps for mounting the PersistentVolumeClaim from a Pod are the same as for static and dynamic provisioning. Refer to <a data-type="xref" href="#mounting_persistent_volume" class="calibre10">“Mounting PersistentVolumeClaims in a Pod”</a> for more information.</p>
</div></section>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id223">
<h1 class="calibre17">Summary</h1>

<p class="author1">Kubernetes offers the concept of a Volume to implement the use case. A Pod mounts a Volume to a path in the container. Kubernetes offers a wide range of Volume types to fulfill different requirements.</p>

<p class="author1">PersistentVolumes store data beyond a Pod or cluster/node restart. Those objects are decoupled from the Pod’s life cycle and are therefore represented by a Kubernetes primitive. The PersistentVolumeClaim abstracts the underlying implementation details of a PersistentVolume and acts as an intermediary between Pod and 
<span class="keep-together">PersistentVolume.</span></p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id224">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Practice defining and consuming ephemeral Volumes</dt>
<dd class="calibre20">
<p class="calibre21">Volumes are a cross-cutting concept applied in different areas of the exam. Know where to find the relevant documentation for defining a Volume as well as the multitude of ways to consume a Volume from a container. Definitely read <a data-type="xref" href="ch19.xhtml#configmaps_secrets" class="calibre10">Chapter 19</a> for a deep dive on how to mount ConfigMaps and Secrets as a Volume, and <a data-type="xref" href="ch08.xhtml#multi_container_pods" class="calibre10">Chapter 8</a> for sharing a Volume between two containers.</p>
</dd>
<dt class="calibre19">Internalize the mechanics of defining and consuming a PersistentVolume</dt>
<dd class="calibre20">
<p class="calibre21">Creating a PersistentVolume involves a couple of moving parts. Understand the configuration options for PersistentVolumes and PersistentVolumeClaims and how they play together. Try to emulate situations that prevent a successful binding of a PersistentVolumeClaim. Then fix the situation by taking counteractions. Internalize the short-form commands <code class="calibre15">pv</code> and <code class="calibre15">pvc</code> to save precious time during the exam.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id225">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_003.xhtml#appendix_a_volumes" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Create a Pod YAML manifest with two containers that use the image <code class="calibre15">alpine:3.12.0</code>. Provide a command for both containers that keep them running forever.</p>

<p class="author1">Define a Volume of type <code class="calibre15">emptyDir</code> for the Pod. Container 1 should mount the Volume to path <em class="calibre3">/etc/a</em>, and container 2 should mount the Volume to path <em class="calibre3">/etc/b</em>.</p>

<p class="author1">Open an interactive shell for container 1 and create the directory <em class="calibre3">data</em> in the mount path. Navigate to the directory and create the file <em class="calibre3">hello.txt</em> with the contents “Hello World.” Exit out of the container.</p>

<p class="author1">Open an interactive shell for container 2 and navigate to the directory <em class="calibre3">/etc/b/data</em>. Inspect the contents of file <em class="calibre3">hello.txt</em>. Exit out of the container.</p>
</li>
<li class="calibre56">
<p class="author1">Create a PersistentVolume named <code class="calibre15">logs-pv</code> that maps to the <code class="calibre15">hostPath</code> <em class="calibre3">/var/logs</em>. The access mode should be <code class="calibre15">ReadWriteOnce</code> and <code class="calibre15">ReadOnlyMany</code>. Provision a storage capacity of 5Gi. Ensure that the status of the PersistentVolume shows 
<span class="keep-together"><code class="calibre15">Available</code>.</span></p>

<p class="author1">Create a PersistentVolumeClaim named <code class="calibre15">logs-pvc</code>. It uses <code class="calibre15">ReadWriteOnce</code> access. Request a capacity of 2Gi. Ensure that the status of the PersistentVolume shows <code class="calibre15">Bound</code>.</p>

<p class="author1">Mount the PersistentVolumeClaim in a Pod running the image <code class="calibre15">nginx</code> at the mount path <em class="calibre3">/var/log/nginx</em>.</p>

<p class="author1">Open an interactive shell to the container and create a new file named <em class="calibre3">my-nginx.log</em> in <em class="calibre3">/var/log/nginx</em>. Exit out of the Pod.</p>

<p class="author1">Delete the Pod and re-create it with the same YAML manifest. Open an interactive shell to the Pod, navigate to the directory <em class="calibre3">/var/log/nginx</em>, and find the file you created before.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>