- en: Chapter 1\. Full Stack Development in the Era of Serverless Computing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: People have typically associated cloud computing with backend development and
    DevOps. However, over the past few years, this has started to change. With the
    rise of *functions as a service* (FaaS), combined with powerful abstractions in
    the form of managed services, cloud providers have lowered the barrier to entry
    for developers new to cloud computing, and for traditionally frontend developers.
  prefs: []
  type: TYPE_NORMAL
- en: Using modern tools, frameworks, and services like Amazon Web Services (AWS)
    Amplify and Firebase (among others), a single developer can leverage their existing
    skill set and knowledge of a single framework and ecosystem (like JavaScript)
    to build scalable full stack applications complete with all of the features that
    would in the past have required teams of highly skilled backend and DevOps engineers
    to build and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: This book focuses on bridging the gap between frontend and backend development
    by taking advantage of this new generation of tools and services using the Amplify
    Framework. Here you’ll learn how to build scalable applications in the cloud directly
    from your frontend environment using the Amplify Command Line Interface (CLI).
    You’ll create and interact with various APIs and AWS services, such as authentication
    using Amazon Cognito, cloud storage using Amazon S3, APIs using Amazon API Gateway
    and AWS AppSync, and databases using Amazon DynamoDB.
  prefs: []
  type: TYPE_NORMAL
- en: By the final chapter, you will understand how to build real-world full stack
    applications in the cloud leveraging AWS services on the backend and React on
    the frontend. You’ll also learn how to use modern APIs from React, like hooks,
    and functional components, as well as React Context for global state management.
  prefs: []
  type: TYPE_NORMAL
- en: Modern Serverless Philosophy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The term *serverless* is commonly associated with FaaS. Though you will find
    varying definitions as to what it means, the term has recently grown to encompass
    more of a philosophy than a shared definition.
  prefs: []
  type: TYPE_NORMAL
- en: Many times when people talk about serverless, they are really describing how
    to most efficiently deliver business value with a focus on writing business logic,
    instead of coding supporting infrastructure for your business logic. Adopting
    a serverless mindset allows you to do this by consciously going out of your way
    to find and leverage FaaS, managed services, and smart abstractions, while only
    building custom solutions if an existing service just doesn’t yet exist.
  prefs: []
  type: TYPE_NORMAL
- en: More and more companies and developers are taking this approach, as it doesn’t
    make sense to reinvent the wheel. With the increase in popularity of this philosophy,
    there has also been an explosion of services and tools made available from startups
    and cloud providers to provide offerings that simplify backend complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'For an academic take on what *serverless* means, you may wish to read the 2019
    paper written by a group at UC Berkeley, “Cloud Programming Simplified: A Berkeley
    View on Serverless Computing,”^([1](ch01.xhtml#idm45364356233672)). In this paper,
    the authors expanded the definition of *serverless*:'
  prefs: []
  type: TYPE_NORMAL
- en: While cloud functions—packaged as FaaS (Function as a Service) offerings—represent
    the core of serverless computing, cloud platforms also provide specialized serverless
    frameworks that cater to specific application requirements as BaaS (Backend as
    a Service) offerings. Put simply, serverless computing = FaaS + BaaS.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Backend as a service* (BaaS) typically refers to managed services like databases
    (Firestore, Amazon DynamoDB), authentication services (Auth0, Amazon Cognito),
    and artificial intelligence services (Amazon Rekognition, Amazon Comprehend),
    among other managed services. Berkeley’s redefinition of what serverless means
    underscores what is happening in the broader spectrum of this discussion as cloud
    providers begin to build more and better-managed services and put them in this
    bucket of serverless.'
  prefs: []
  type: TYPE_NORMAL
- en: Characteristics of a Serverless Application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand something about the philosophy around serverless, what
    are some of the characteristics of a serverless application? Though you may get
    varying answers as to what serverless is, following are some traits and characteristics
    that are generally agreed upon by the industry.
  prefs: []
  type: TYPE_NORMAL
- en: Decreased operational responsibilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Serverless architectures typically allow you to shift more of your operational
    responsibilities to a cloud provider or third party.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you decide to implement FaaS, the only thing you should have to worry
    about is the code running in your function. All of the server patching, updating,
    maintaining, and upgrading is no longer your responsibility. This goes back to
    the core of what cloud computing, and by extension serverless, attempts to offer:
    a way to spend less time managing infrastructure and spend more time building
    features and delivering business value.'
  prefs: []
  type: TYPE_NORMAL
- en: Heavy use of managed services
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Managed services usually assume responsibility for providing a defined set of
    features. They are serverless in the sense that they scale seamlessly, don’t require
    any server operations or need to manage uptime, and, most importantly, are essentially
    codeless.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of a Serverless Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These days there are many ways to architect an application. The decisions that
    are made early on will impact not only the application life cycle, but also the
    development teams and ultimately the company or organization. In this book, I
    advocate for building your applications using serverless technologies and methodologies
    and lay out some ways in which you can do this. But what are the advantages of
    building your application like this, and why is serverless becoming so popular?
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the primary advantages of going serverless is out-of-the-box scalability.
    When building your application, you don’t have to worry about what would happen
    if the application becomes wildly popular and you onboard a large number of new
    users quickly—the cloud provider will handle this for you.
  prefs: []
  type: TYPE_NORMAL
- en: The cloud provider automatically scales your application, running the code in
    response to each interaction. In a serverless function, your code runs in parallel
    and individually processes each trigger (in turn, scaling with the size of the
    workload).
  prefs: []
  type: TYPE_NORMAL
- en: Not having to worry about scaling your servers and databases is a great advantage.
    It’s one less thing you have to worry about when architecting your application.
  prefs: []
  type: TYPE_NORMAL
- en: Cost
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The pricing models of serverless architectures and traditional cloud-based or
    on-premises infrastructures differ greatly.
  prefs: []
  type: TYPE_NORMAL
- en: With the traditional approach, you often paid for computing resources whether
    or not they were utilized. This meant that if you wanted to make sure your application
    would scale, you needed to prepare for the largest workload you thought you might
    see regardless of whether you actually reached that point. This approach meant
    you were paying for unused resources for the majority of the life of your application.
  prefs: []
  type: TYPE_NORMAL
- en: With serverless technologies, you pay only for what you use. With FaaS, you’re
    billed based on the number of requests for your functions, the time it takes for
    your function code to execute, and the reserved memory for each function. With
    managed services like Amazon Rekognition, you are only charged for the images
    processed and minutes of video processed, etc.—again paying only for what you
    use.
  prefs: []
  type: TYPE_NORMAL
- en: This allows you to build features and applications with essentially no up-front
    infrastructure costs. Only if your application begins seeing increasing adoption
    and scaling do you begin to have to pay for the service.
  prefs: []
  type: TYPE_NORMAL
- en: The bill from your cloud provider is only one part of the total cost of your
    cloud infrastructure—there’s also the operations’ salaries. That cost decreases
    if you have fewer ops resources.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, building applications in this way usually facilitates a faster
    time to market, decreasing overall development time and, therefore, development
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: Developer velocity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With fewer features to build, developer velocity increases. Being able to spin
    up the types of features that are typical for most applications (e.g., databases,
    authentication, storage, and APIs) allows you to quickly focus on writing the
    core functionality and business logic for the features that you want to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Experimentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are not investing a lot of time building out repetitive features, you
    are able to experiment more easily and with less risk.
  prefs: []
  type: TYPE_NORMAL
- en: When shipping a new feature, you often assess the risk (time and money involved
    with building the feature) against the possible return on investment (ROI). As
    the risk involved in trying out new things decreases, you are free to test out
    ideas that in the past may not have seen the light of day.
  prefs: []
  type: TYPE_NORMAL
- en: '*A/B testing* (also known as *bucket testing* or *split testing*) is a way
    to compare multiple versions of an application to determine which one performs
    best. Because of the increase in developer velocity, serverless applications usually
    enable you to A/B test different ideas much more quickly and easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Security and stability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Because the services that you are subscribing to are the core competency of
    the service provider maintaining them, you are usually getting something that
    is much more polished and more secure than you could have built yourself. Imagine
    that a company’s core business model has been, for many years, the delivery of
    a pristine authentication service, having fixed issues and edge cases for thousands
    of companies and customers.
  prefs: []
  type: TYPE_NORMAL
- en: Now, imagine trying to replicate a service like that within your own team or
    organization. Though this is completely possible, choosing to use a service built
    and maintained by those whose only job is to build and maintain that exact thing
    is a safe bet that will ultimately save you time and money.
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of using these service providers is that they will strive
    for the least amount of downtime possible. This means that they are taking on
    the burden of not only building, deploying, and maintaining these services, but
    also doing everything they can to make sure that they are stable.
  prefs: []
  type: TYPE_NORMAL
- en: Less code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Most engineers will agree that, at the end of the day, code is a liability.
    What has value is the feature that the code delivers, not the code itself. When
    you find ways to deliver these features while simultaneously limiting the amount
    of code you need to maintain, and even doing away with the code completely, you
    are reducing overall complexity in your application.
  prefs: []
  type: TYPE_NORMAL
- en: With less complexity comes fewer bugs, easier onboarding for new engineers,
    and overall less cognitive load for those maintaining and adding new features.
    A developer can hook into these services and implement features with no knowledge
    of the actual backend implementation and with little to no backend code at all.
  prefs: []
  type: TYPE_NORMAL
- en: Different Implementations of Serverless
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s take a look at the different ways that you can build serverless applications
    as well as some of the differences between them.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the first serverless implementations, the Serverless Framework, is the
    most popular. It is a free and open source framework, launched in October 2015
    under the name JAWS, and written using Node.js. At first, the Serverless Framework
    only supported AWS, but then it added support for cloud providers like Google
    and Microsoft Azure, among others.
  prefs: []
  type: TYPE_NORMAL
- en: The Serverless Framework utilizes a combination of a configuration file (*serverless.yml*),
    CLI, and function code to provide a nice experience for people wanting to deploy
    serverless functions and other AWS services to the cloud from a local environment.
    Getting up and running with the Serverless Framework can present a somewhat steep
    learning curve, especially for developers new to cloud computing. There is much
    terminology to learn and a lot that goes into understanding how cloud services
    work in order to build anything more than just a “Hello World” application.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the Serverless Framework is a good option if you understand to some
    extent how cloud infrastructure works, and are looking for something that will
    work with other cloud providers in addition to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS Serverless Application Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The [AWS Serverless Application Model](https://oreil.ly/ApIoW) (AWS SAM) is
    an open source framework, released November 18, 2016, and built and maintained
    by AWS and the community. This framework only supports AWS.
  prefs: []
  type: TYPE_NORMAL
- en: SAM allows you to build serverless applications by defining the API Gateway
    APIs, AWS Lambda functions, and Amazon DynamoDB tables needed by your serverless
    application in YAML files. It uses a combination of YAML configuration and function
    code and a CLI to create, manage, and deploy serverless applications.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of SAM is that it is an extension of AWS CloudFormation, which
    is very powerful and allows you to do almost anything in AWS. This can also be
    a disadvantage to developers new to cloud computing and not familiar with AWS
    services, permissions, roles, and terminology, as you have to already be familiar
    with how the services work, the naming conventions to set them up, and how to
    wire it all together.
  prefs: []
  type: TYPE_NORMAL
- en: SAM is a good choice if you are familiar with AWS and are only deploying your
    serverless applications to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Amplify Framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Amplify Framework is a combination of four things: CLI, client library,
    toolchain, and web-hosting platform. Amplify’s purpose is to provide an easy way
    for developers to build and deploy full stack web and mobile applications that
    leverage the cloud. It enables not only features such as serverless functions
    and authentication, but also GraphQL APIs, machine learning (ML), storage, analytics,
    push notifications, and more.'
  prefs: []
  type: TYPE_NORMAL
- en: Amplify provides an easy entry point into the cloud by doing away with terminology
    and acronyms that may be unfamiliar to newcomers to AWS and instead uses a category-name
    approach for referring to services. Rather than referring to the authentication
    service as Amazon Cognito, it’s referred to as *auth*, and the framework just
    uses Amazon Cognito under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Other options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More companies have started providing abstractions over serverless functions,
    usually intending to improve the negative user experience traditionally associated
    with working directly with AWS Lambda. A few popular options among these are Apex,
    Vercel, Cloudflare Workers, and Netlify Functions.
  prefs: []
  type: TYPE_NORMAL
- en: Many of these tools and frameworks still actually use AWS or some other cloud
    provider under the hood, so you are essentially going to be paying more in exchange
    for what they argue is a better user experience. Most of these tools do not offer
    much of the other suite of services available from AWS or other cloud providers;
    things like authentication, AI and ML services, complex object storage, and analytics
    may or may not be part of their offerings.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in learning other ways of developing serverless applications,
    I would recommend checking out these options.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to AWS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I’ll give an overview of AWS and talk about why something like
    the Amplify Framework exists.
  prefs: []
  type: TYPE_NORMAL
- en: About AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AWS, a subsidiary of Amazon, was the first company to provide on-demand cloud
    computing platforms to developers. It first launched in 2004 with a single service:
    Amazon Simple Queue Service (Amazon SQS). In 2006, they officially relaunched
    with a total of three services: Amazon SQS, Amazon S3, and Amazon EC2\. Since
    2006, AWS has grown and remains the largest cloud computing provider in the world,
    continuing to add services every year. AWS now offers more than two hundred services.'
  prefs: []
  type: TYPE_NORMAL
- en: With the current state of cloud computing moving more toward serverless technologies,
    the barrier to entry is being lowered. However, it is still often tough for either
    a frontend developer or someone new to cloud computing to get started.
  prefs: []
  type: TYPE_NORMAL
- en: With this new serverless paradigm, AWS saw an opportunity to create a framework
    that focused on enabling these traditionally frontend developers and developers
    new to cloud computing to get started building cloud applications.
  prefs: []
  type: TYPE_NORMAL
- en: Full Stack Serverless on AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Full stack serverless* is about providing developers with everything needed
    on both ends of the stack to accomplish their objective of building scalable applications
    as quickly as possible. Here, we’ll look at how you can build applications in
    this way using AWS tools and services.'
  prefs: []
  type: TYPE_NORMAL
- en: Amplify CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re starting out with AWS, the sheer number of services can be overwhelming.
    In addition to the many services to sort between, each service often has its own
    steep learning curve. To help ease this, AWS has created the *Amplify CLI*.
  prefs: []
  type: TYPE_NORMAL
- en: The Amplify CLI provides an easy entry point for developers wanting to build
    applications on AWS. The CLI allows developers to create, configure, update, and
    delete cloud services directly from their frontend environment.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a service-name approach (as used by the AWS Console and many other
    tools, like CloudFormation), the CLI takes a category-name approach. AWS has many
    service names (for example, Amazon S3, Amazon Cognito, and Amazon Pinpoint), which
    can be confusing to new developers. Rather than using the service names to create
    and configure these services, the CLI uses names like *storage* (Amazon S3), *auth*
    (Amazon Cognito), and *analytics* (Amazon Pinpoint) to give you a way to understand
    what the service actually does versus simply giving the service name.
  prefs: []
  type: TYPE_NORMAL
- en: The CLI has a host of commands that allow you to create, update, configure,
    and remove services without having to leave your frontend environment. You can
    also spin up and deploy new environments using the CLI in order to test out new
    features without affecting the main environment.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created and deployed features using the CLI, you can then use the
    Amplify client libraries to begin interacting with the services from your client-side
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Amplify client
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Building full stack applications requires a combination of both client-side
    tooling and backend services. In the past, the main way to interact with AWS services
    was using an AWS software development kit (SDK) such as Java, .NET, Node.js, and
    Python. These SDKs work well, but none of them are particularly well-suited for
    client-side development. Before Amplify, there was no simple method for building
    client-side applications using AWS. If you look at the documentation for the AWS
    Node.js SDK, you’ll also notice that it presents a steep learning curve for developers
    new to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: The Amplify client is a library made especially to provide an easy-to-use API
    for JavaScript applications that need to interact with AWS services. Amplify also
    has client SDKs for React Native, native iOS, and native Android.
  prefs: []
  type: TYPE_NORMAL
- en: The approach that the Amplify client takes is to provide a higher level of abstraction
    and bake in best practices to provide a declarative, easy-to-use API. At the same
    time, it gives you full control over the interactions with your backend. It’s
    also built especially with the client in mind, with features like WebSocket and
    GraphQL subscription support. It utilizes localStorage for the browser and AsyncStorage
    for React Native to store security tokens like `IdTokens` and `AccessTokens` to
    persist user authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Amplify also provides UI components for popular frontend and mobile frameworks
    including React, React Native, Vue, Angular, Ionic, native Android, and native
    iOS. These framework-specific components allow you to quickly get up and running
    with common features like authentication and complex object storage and retrieval
    without having to build out the frontend UI and deal with state.
  prefs: []
  type: TYPE_NORMAL
- en: The Amplify Framework does not support the entire suite of AWS services; instead,
    it supports a subset of them with almost all of them falling into the category
    of serverless. Using Amplify, it wouldn’t make much sense to offer support for
    interacting with with EC2, but it makes a lot of sense to offer support for working
    with Representational State Transfer (REST) and GraphQL APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Amplify was created as an end-to-end solution to fill a previously unfilled
    gap, but it also encompasses a new way to build full stack cloud applications.
  prefs: []
  type: TYPE_NORMAL
- en: AWS AppSync
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: AWS AppSync is a managed *API layer* that uses GraphQL to make it easy for applications
    to interact with any data source, REST API, or microservice.
  prefs: []
  type: TYPE_NORMAL
- en: The API layer is one of the most important parts of an application. Modern applications
    typically interact with a large number of backend services and APIs; things like
    databases, managed services, third-party APIs, and storage solutions, among others.
    *Microservice architecture* is the usual term used for a large application built
    using a combination of modular components or services.
  prefs: []
  type: TYPE_NORMAL
- en: Most services and APIs will have varying implementation details, which creates
    a challenge when you’re working with a microservice architecture. This leads to
    inconsistent and sometimes messy code, as well as more cognitive load on the frontend
    developers making requests to these APIs.
  prefs: []
  type: TYPE_NORMAL
- en: One good approach to working with a microservice architecture is to provide
    a consistent API gateway layer that then takes all of the requests and forwards
    them on to the backend services. This allows a consistent interaction layer for
    your client to interact with, making development easier on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: 'GraphQL, a technology created and open sourced by Facebook, offers an especially
    good abstraction for creating an API gateway. GraphQL introduces a defined and
    consistent specification for interacting with APIs in the form of three operations:
    *queries* (reads), *mutations* (writes/updates), and *subscriptions* (real-time
    data). These operations are defined as part of a main *schema* that also provides
    a contract between the client and the server in the form of GraphQL types. GraphQL
    operations are not bound to any specific data source, so you as a developer are
    free to use them to interact with anything from a database, an HTTP endpoint,
    a microservice, or even a serverless function.'
  prefs: []
  type: TYPE_NORMAL
- en: Typically, when building a GraphQL API, you need to deal with building, deploying,
    maintaining, and configuring your own API. With AWS AppSync, you can instead offload
    the server and API management as well as the security to AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Modern applications often also have concerns such as real-time and offline support.
    Another benefit of AppSync is that it has built-in support for offline (Amplify
    client SDKs) as well as real time (GraphQL subscriptions) to enable developers
    to build these types of applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, you will be using AWS AppSync along with various data sources
    (like DynamoDB for NoSQL and AWS Lambda for serverless functions) as the main
    API layer.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to the AWS Amplify CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will be using Amplify CLI throughout this book to create and manage your
    cloud services. To learn how it works, you’ll be creating and deploying a service
    using the CLI in this section. Once the service is deployed, you’ll also learn
    how to remove it and then delete any backend resources associated with the deployment.
    Let’s take a look at how you can create your first service.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Configuring the Amplify CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, you first need to install and configure the Amplify CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To use the CLI, you will first need to have Node.js version 10.x or greater
    and npm version 5.x or greater installed on your machine. To install Node.js,
    I recommend either visiting the [Node.js installation page](https://nodejs.org/en)
    and following the installation instructions or using [Node Version Manager](https://github.com/nvm-sh/nvm)
    (NVM).
  prefs: []
  type: TYPE_NORMAL
- en: After the CLI has been installed, you next need to configure it with an identity
    and access management (IAM) user in your AWS account. To do so, you’ll configure
    the CLI with a reference to a set of user credentials (access key ID and secret
    access key). Using these credentials, you’ll be able to create AWS services on
    behalf of this user directly from the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new user and configure the CLI, you’ll run the `configure` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This will walk you through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Specify the AWS region.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will allow you to choose the region in which you’d like to create your
    user (and, by extension, the services associated with this user). Choose the region
    closest to you or a preferred region.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Specify the username.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This name will be the local reference of the user that you will be creating
    in your AWS account. I suggest using a name that you’ll be able to recognize later
    when referencing it, such as *amplify-cli-us-east-1-user* or *mycompany-cli-admin*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you enter your name, the CLI will open up the AWS IAM dashboard. From
    here, you can accept the defaults by clicking Next: Permissions, Next: Tags, Next:
    Review, and Create user to create the IAM user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next screen, you will be given the IAM user credentials: the access
    key ID and secret access key. See [Figure 1-1](#fig1a).'
  prefs: []
  type: TYPE_NORMAL
- en: '![AWS IAM Dashboard IAM User](Images/fssl_0101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-1\. AWS IAM dashboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Back in the CLI, paste in the values for the access key ID and secret access
    key. Now you’ve successfully configured the CLI and you can begin creating new
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Your First Amplify Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the CLI has been installed and configured, you can create your first
    project. This step is usually done within the root of your client application.
    Since you will be using React for most of this book, we’ll start by initializing
    a new React project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to install the Amplify that you’ll be using on the client. The
    libraries you’ll be using are AWS Amplify and AWS Amplify React for the React-specific
    UI components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you can create an Amplify project. To do so, you’ll run the `init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This will walk you through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Enter a name for the project.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will be the local name for the project, usually something that describes
    what the project is or what it does.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Enter a name for the environment.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will be a reference to the initial environment that you will be working
    in. Typical environments in this workflow could be something like *dev*, *local*,
    or *prod* but could be anything that makes sense to you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Choose your default editor.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will set your editor preference. The CLI will later use this preference
    to open your text editor with files that are part of the current project.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Choose the type of app that you’re building.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will determine whether the CLI should configure, build, and run commands
    if you are using JavaScript. For this example, choose *javascript*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*What JavaScript framework are you using?*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will determine a few base build and start commands. For this example, choose
    *react*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Choose your source directory path.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows you to set the directory where your source code will live. For this
    example, choose *src*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Choose your distribution directory path.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For web projects, this will be the folder containing the complied JavaScript
    source code as well as your favicon, HTML, and CSS files. For this example, choose
    *build*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Choose your build command.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This specifies the command for compiling and bundling your JavaScript code.
    For this example, use *npm run-script build*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Choose your start command.*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This specifies the command to server your application locally. For this example,
    use *npm run-script start*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Do you want to use an AWS profile?*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, choose *Y* and then pick the AWS profile you created when you ran `amplify
    configure`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, the Amplify CLI will initialize your new Amplify project. When the initialization
    is complete, you will have two additional resources created for you in your project:
    a file called *aws-exports* located in the *src* directory and a folder named
    *amplify* located in your root directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The aws-exports file
  prefs: []
  type: TYPE_NORMAL
- en: The *aws-exports* file is a key-value pairing of the resource categories created
    for you by the CLI along with their credentials.
  prefs: []
  type: TYPE_NORMAL
- en: The amplify folder
  prefs: []
  type: TYPE_NORMAL
- en: 'This folder holds all of the code and configuration files for your Amplify
    project. In this folder you’ll see two subfolders: the *backend* and *#current-cloud-backend*
    folders.'
  prefs: []
  type: TYPE_NORMAL
- en: The *backend* folder
  prefs: []
  type: TYPE_NORMAL
- en: This folder contains all of the local code for your project such as the GraphQL
    schema for an AppSync API, the source code for any serverless functions, and infrastructure
    as code representing the current local status of the Amplify project.
  prefs: []
  type: TYPE_NORMAL
- en: The *#current-cloud-backend* folders
  prefs: []
  type: TYPE_NORMAL
- en: This folder holds the code and configurations that reflect what resources were
    deployed in the cloud with your last Amplify `push` command. It helps the CLI
    differentiate between the configuration of the resources already provisioned in
    the cloud and what is currently in your local *backend* directory (which reflects
    your local changes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve initialized your project, you can add your first cloud service:
    *authentication*.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Deploying Your First Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a new service, you can use the `add` command from Amplify:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will walk you through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do you want to use the default authentication and security configuration?*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This gives you the option of creating an authentication service using a default
    configuration (MFA on sign-up, password at sign-in), creating an authentication
    configuration with social providers, or creating a completely custom authentication
    configuration. For this example, choose *Default configuration*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*How do you want users to be able to sign in?*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will allow you to specify the required sign-in property. For this example,
    accept the default by choosing *Username*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Do you want to configure advanced settings?*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will allow you to walk through additional advanced settings for things
    like additional sign-up attributes and Lambda triggers. You do not need any of
    these for this example, so accept the default by choosing *No, I am done*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, you’ve successfully configured the authentication service and are now
    ready to deploy. To deploy the authentication service, you can run the `push`
    command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Are you sure you want to continue?*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose *Y*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the deployment is complete, your authentication service has successfully
    been created. Congratulations, you’ve deployed your first feature. Now, let’s
    test it out.
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to interact with the authentication service in a React
    application. You can use the `Auth` class from Amplify, which has over 30 methods
    available (methods like `signUp`, `signIn`, `signOut`, etc.), or you can use the
    framework-specific components like `withAuthenticator` that will scaffold out
    an entire authentication flow, complete with preconfigured UI. Let’s try out the
    `withAuthenticator` higher-order (HOC) component.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, configure the React app to work with Amplify. To do so, open *src/index.js*
    and add the following code below the last `import` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the app has been configured and you can begin interacting with the authentication
    service. Next, open *src/App.js* and update the file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, you can test it out by launching the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Now, your app should be launched with the preconfigured authentication flow
    in front of it. See [Figure 1-2](#fig1b).
  prefs: []
  type: TYPE_NORMAL
- en: '![AWS Amplify withAuthenticator Component](Images/fssl_0102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1-2\. withAuthenticator HOC component
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Deleting the Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you no longer need a feature or a project, you can remove it using the
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove an individual feature, you can run the `remove` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete an entire Amplify project along with all of the corresponding resources
    that have been deployed in your account, you can run the `delete` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud computing is growing at a rapid pace as more and more companies have come
    to rely on the cloud for the majority of their workloads. With this growth in
    usage, knowledge of cloud computing is becoming a valuable addition to your skill
    set.
  prefs: []
  type: TYPE_NORMAL
- en: The paradigm of serverless, a subset of cloud computing, is also rapidly growing
    in popularity among business users, as it offers all of the benefits of cloud
    computing while also featuring automatic scaling, while needing little to no maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Tools like the Amplify Framework are making it easier for developers of all
    backgrounds to get up and running with cloud as well as serverless computing.
    In the next chapters, you’ll learn how to build real-world full stack serverless
    applications in the cloud, utilizing cloud services and the Amplify Framework.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch01.xhtml#idm45364356233672-marker)) Eric Jonas, Johann Schleier-Smith
    et al. “Cloud Programming Simplified: A Berkeley View on Serverless Computing”
    (Feb. 10, 2019), [*http://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.html*](http://www2.eecs.berkeley.edu/Pubs/TechRpts/2019/EECS-2019-3.html).'
  prefs: []
  type: TYPE_NORMAL
