- en: Chapter 5\. BPF Utilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve talked about how you can write BPF programs to get more visibility
    within your systems. Over the years, many developers have built tools with BPF
    for that same purpose. In this chapter we talk about several of the off-the-shelf
    tools that you can use every day. Many of these tools are advanced versions of
    some BPF programs that you’ve already seen. Others are tools that will help you
    gain direct visibility into your own BPF programs.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter covers some tools that will help you in your day-to-day work with
    BPF. We begin by covering BPFTool, a command-line utility to get more information
    about your BPF programs. We cover BPFTrace and `kubectl-trace`, which will help
    you write BPF programs more efficiently with a concise domain-specific language
    (DSL). Finally, we talk about eBPF Exporter, an open source project to integrate
    BPF with Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: BPFTool
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BPFTool is a kernel utility for inspecting of BPF programs and maps. This tool
    doesn’t come installed by default on any Linux distribution, and it’s in heavy
    development, so you’ll want to compile the version that best supports your Linux
    kernel. We cover the version of BPFTool distributed with version 5.1 of the Linux
    kernel.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections we discuss how to install BPFTool onto your system and
    how to use it to observe and change the behavior of your BPF programs and maps
    from the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install BPFTool, you need to download a copy of the kernel’s source code.
    There might be some packages for your specific Linux distribution online, but
    we’re going to cover how to install it from the source because it’s not too complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Use Git to clone the repository from GitHub with **`git clone https://github.com/torvalds/linux`**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out the specific kernel version tag with `git checkout v5.1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the kernel’s source, navigate to the directory where BPFTool’s source
    is stored with `cd tools/bpf/bpftool`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and install this tool with `make && sudo make install`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can check that BPFTool is correctly installed by checking its version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Feature Display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the basic operations that you can perform with BPFTool is scanning your
    system to know which BPF features you have access to. This is great when you don’t
    remember which version of the kernel introduced which kind of programs or whether
    the BPF JIT compiler is enabled. To find out the answer to those questions, and
    many others, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll get some long output with details about all the supported BPF features
    in your systems. For brevity, we show you a cropped version of that output here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this output you can see that our system allows unprivileged users to execute
    the syscall `bpf`, this call is restricted to certain operations. You can also
    see that the JIT is enabled. Newer versions of the kernel enable this JIT by default,
    and it helps greatly in compiling BPF programs. If your system doesn’t have it
    enabled, you can run this command to enable it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The feature output also shows you which program types and map types are enabled
    in your system. This command exposes much more information than what we’re showing
    you here, like BPF helpers supported by program type and many other configuration
    directives. Feel free to dive into them while exploring your system.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing what features you have at your disposal can be useful, especially if
    you need to dive into an unknown system. With that, we’re ready to move on to
    other interesting BPFTool features, like inspecting loaded programs.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting BPF Programs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BPFTool gives you direct information about BPF programs on the kernel. It allows
    you to investigate what’s already running in your system. It also allows you to
    load and pin new BPF programs that have been previously compiled from your command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'The best starting point to learn how to use BPFTool to work with programs is
    by inspecting what you have running in your system. To do that, you can run the
    command `bpftool prog show`. If you’re using Systemd as your init system, you
    probably already have a few BPF programs loaded and attached to some cgroups;
    we talk about these a little later. The output of running that command will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The numbers on the left side, before the colon, are the program identifiers;
    we use them later to investigate what these programs are all about. From this
    output you can also learn which kinds of programs your system is running. In this
    case, the system is running three BPF programs attached to cgroup socket buffers.
    The loading time will likely match when you booted your system if those programs
    were actually started by Systemd. You can also see how much memory those programs
    are currently using and the identifiers for the maps associated with them. All
    of this is useful at first glance, and because we have the program identifiers,
    we can dive a little bit deeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can add the program identifier to the previous command as an extra argument:
    `bpftool prog show id 52`. With that, BPFTool will show you the same information
    you saw before, but only for the program identified by the ID 52; that way, you
    can filter out information that you don’t need. This command also supports a `--json`
    flag to generate some JSON output. This JSON output is very convenient if you
    want to manipulate the output. For example, tools like `jq` will give you a more
    structured formatting for this data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also perform more advanced manipulations and filter only the information
    that you’re interested in. In the next example, we’re interested only in knowing
    the BPF program identifier, which type of program it is, and when it was loaded
    in the kernel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When you know a program identifier, you can also get a dump of the whole program
    using BPFTool; this can be handy when you need to debug the BPF bytecode generated
    by a compiler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This program loaded in our kernel by Systemd is inspecting packet data by using
    the helper `bpf_skb_load_bytes`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a more visual representation of this program, including instruction
    jumps, you can use the `visual` keyword in this command. That will generate the
    output in a format that you can convert to a graph representation with tools like
    `dotty`, or any other program that can draw graphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You can see the visual representation for a small Hello World program in [Figure 5-1](#prog_dump_visual).
  prefs: []
  type: TYPE_NORMAL
- en: '![Visual representation of a BPF program](assets/lbpf_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Visual representation of a BPF program
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you’re running version 5.1 or newer of the kernel, you’ll also have access
    to runtime statistics. They tell you how long the kernel is spending on your BPF
    programs. This feature might not be enabled in your system by default; you’ll
    need to run this command first to let the kernel know that it needs to show you
    that data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'When the stats are enabled, you’ll get two more pieces of information when
    you run BPFTool: the total amount of time that the kernel has spent running that
    program (`run_time_ns`), and how many times it has run it (`run_cnt`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But BPFTool doesn’t only allow you to inspect how your programs are doing;
    it also lets you load new programs into the kernel and attach some of them to
    sockets and cgroups. For example, we can load one of our previous programs and
    pin it to the BPF file system, with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Because the program is pinned to the filesystem, it won’t terminate after running,
    and we can see that it’s still loaded with the previous `show` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, BPFTool gives you a lot of information about the programs loaded
    in your kernel without having to write and compile any code. Let’s see how to
    work with BPF maps next.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting BPF Maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides giving you access to inspect and manipulate BPF programs, BPFTool can
    give you access to the BPF maps that those programs are using. The command to
    list all maps and filter maps by their identifiers is similar to the `show` command
    that you saw previously. Instead of asking BPFTool to display information for
    `prog`, let’s ask it to show us information for `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Those maps match the identifiers that you saw earlier attached to your programs.
    You can also filter maps by their ID, in the same way we filtered programs by
    their ID earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use BPFTool to create and update maps and to list all the elements
    within a map. Creating a new map requires the same information that you provide
    when you initialize a map along with one of your programs. We need to specify
    which type of map we want to create, the size of the keys and values, and its
    name. Because we’re not initializing the map along with a program, we also need
    to pin it to the BPF filesystem so that we can use it later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you list the maps in the system after running that command, you’ll see the
    new map at the bottom of the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After you’ve created the map, you can update and delete elements like we’d do
    inside a BPF program.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that you cannot remove elements from fixed-size arrays; you can only
    update them. But you can totally delete elements from other maps, like hash maps.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to add a new element to the map or update an existing one, you
    can use the `map update` command. You can grab the map identifier from the previous
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If you try to update an element with an invalid key or value, BPFTool will
    return an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'BPFTool can give you a dump of all the elements in a map if you need to inspect
    its values. You can see how BPF initializes all of the elements to a null value
    when you create fixed-size array maps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the most powerful options that BPFTool gives you is that you can attach
    precreated maps to new programs and replace the maps that they would initialize
    with those preallocated maps. That way, you can give programs access to saved
    data from the beginning, even if you didn’t write the program to read a map from
    the BPF file system. To do that, you need to set the map you want to initialize
    when you load the program with BPFTool. You can specify the map by the ordered
    identifier that it would have when the program loads it, for example 0 for the
    first map, 1 for the second one, and so on. You can also specify the map by its
    name, which is usually more convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example we attach the map that we just created to a new program. In
    this case, we replace the map by its name, because we know that the program initializes
    a map called `counter`. You can also use the map’s index position with the keyword
    `idx`, as in `idx 0`, if that’s easier to remember for you.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing BPF maps directly from the command line is useful when you need to
    debug message passing in real time. BPFTool gives you direct access in a convenient
    way. Besides introspecting programs and maps, you can use BPFTool to extract much
    more information from the kernel. Let’s see how to access specific interfaces
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Programs Attached to Specific Interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes you’ll find yourself wondering which programs are attached to specific
    interfaces. BPF can load programs that work on top of cgroups, Perf events, and
    network packets. The subcommands `cgroup`, `perf`, and `net` can help you trace
    back attachments on those interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: The `perf` subcommand lists all programs attached to tracing points in the system,
    like kprobes, uprobes, and tracepoints; you can see that listing by running `bpftool
    perf show`.
  prefs: []
  type: TYPE_NORMAL
- en: The `net` subcommand lists programs attached to XDP and Traffic Control. Other
    attachments, like socket filters and reuseport programs, are accessible only by
    using `iproute2`. You can list the attachments to XDP and TC with `bpftool net
    show`, like you’ve seen with other BPF objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `cgroup` subcommand lists all programs attached to cgroups. This
    subcommand is a little bit different than the other ones you’ve seen. `bpftool
    cgroup show` requires the path to the cgroup you want to inspect. If you want
    to list all the attachments in all cgroups in the system, you’ll need to use `bpftool
    cgroup tree`, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to BPFTool, you can verify that your programs are attached correctly
    to any interface in the kernel, giving you quick visibility access to cgroups,
    Perf, and the network interface.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve talked about how you can enter different commands in your terminal
    to debug how your BPF programs behave. However, remembering all these commands
    can be cumbersome when you need them the most. Next we describe how to load several
    commands from plain-text files so that you can build a set of scripts that you
    can keep handy without having to retain each option that we’ve talked about.
  prefs: []
  type: TYPE_NORMAL
- en: Loading Commands in Batch Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s common to run several commands over and over while you’re trying to analyze
    the behavior of one or multiple systems. You might end up with a collection of
    commands that you use frequently as part of your toolchain. BPFTool’s batch mode
    is for you if you don’t want to type those commands every single time.
  prefs: []
  type: TYPE_NORMAL
- en: 'With batch mode, you can write all of the commands that you want to execute
    in a file and run all of them at once. You can also write comments in this file
    by starting a line with #. However, this execution mode is not atomic. BPFTool
    executes commands line by line, and it will abort the execution if one of the
    commands fails, leaving the system in the state it was in after running the latest
    successful command.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a short example of a file that batch mode can process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If you save those commands in a file called */tmp/batch_example.txt*, you’ll
    be able to load it with `bpftool batch file /tmp/batch_example.txt`. You’ll get
    output similar to the following snippet when you run this command for the first
    time, but if you try to run it again, the command will exit with no output because
    we already have a map with the name `hash_map` in the system, and the batch execution
    will fail in the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Batch mode is one of our favorite options in BPFTool. We recommend keeping these
    batch files in a version control system so that you can share them with your team
    to create your own set of utility tools. Before jumping to our next favorite utility,
    let’s see how BPFTool can help you understand the BPF Type Format better.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying BTF Information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BPFTool can display BPF Type Format (BTF) information for any given binary object
    when it is present. As we mentioned in [Chapter 2](ch02.html#running_your_first_BPF_programs),
    BTF annotates program structures with metadata information to help you debug programs.
  prefs: []
  type: TYPE_NORMAL
- en: For example, it can give you the source file and line numbers for each instruction
    in a BPF program when you add the keyword `linum` to `prog dump`.
  prefs: []
  type: TYPE_NORMAL
- en: More recent versions of BPFTool include a new `btf` subcommand to help you dive
    into your programs. The initial focus of this command is to visualize structure
    types. For example, `bpftool btf dump id 54` shows all of the BFT types for the
    program loaded with an ID of 54.
  prefs: []
  type: TYPE_NORMAL
- en: These are some of the things you can use BPFTool for. It’s a low-friction entry
    point to any system, especially if you don’t work on that system on a day-to-day
    basis.
  prefs: []
  type: TYPE_NORMAL
- en: BPFTrace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: BPFTrace is a high-level tracing language for BPF. It allows you to write BPF
    programs with a concise DSL, and save them as scripts that you can execute without
    having to compile and load them in the kernel manually. The language is inspired
    by other well-known tools, like awk and DTrace. If you’re familiar with DTrace
    and you’ve always missed being able to use it on Linux, you’re going to find in
    BPFTrace a great substitute.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using BPFTrace over writing programs directly with
    BCC or other BPF tooling is that BPFTrace provides a lot of built-in functionality
    that you don’t need to implement yourself, such as aggregating information and
    creating histograms. On the other hand, the language that BPFTrace uses is much
    more limited, and it will get in your way if you try to implement advanced programs.
    In this section, we show you the most important aspects of the language. We recommend
    going to the [BPFTrace repository on GitHub](https://github.com/iovisor/bpftrace)
    to learn about it.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can install BPFTrace in several ways, although its developers recommend
    you use one of the prebuilt packages for your specific Linux distribution. They
    also maintain a document with all the installation options and prerequisites for
    your system in their repository. There, you’ll find instructions in the [installation
    document](https://oreil.ly/h9Pha).
  prefs: []
  type: TYPE_NORMAL
- en: Language Reference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The programs that BPFTrace executes have a terse syntax. We can divide them
    into three sections: header, action blocks, and footer. The header is a special
    block that BPFTrace executes when it loads the program; it’s commonly used to
    print some information at the top of the output, like a preamble. In the same
    way, the footer is a special block that BPFTrace executes once before terminating
    the program. Both the header and footer are optional sections in a BPFTrace program.
    A BPFTrace program must have at least one *action block*. Action blocks are where
    we specify the probes that we want to trace and the actions we perform when the
    kernel fires the events for those probes. The next snippet shows you these three
    sections in a basic example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The header section is always marked with the keyword `BEGIN`, and the footer
    section is always marked with the keyword `END`. These keywords are reserved by
    BPFTrace. Action block identifiers define the probe to which you want to attach
    the BPF action. In the previous example, we printed a log line every time the
    kernel opens a file.
  prefs: []
  type: TYPE_NORMAL
- en: Besides identifying the program sections, we can already see a few more details
    about the language syntax in the previous examples. BPFTrace provides some helpers
    that are translated to BPF code when the program is compiled. The helper `printf`
    is a wrapper around the C function `printf`, which prints program details when
    you need it. `str` is a built-in helper that translates a C pointer to its string
    representation. Many kernel functions receive pointers to characters as arguments;
    this helper translates those pointers to strings for you.
  prefs: []
  type: TYPE_NORMAL
- en: BPFTrace could be considered a dynamic language in the sense that it doesn’t
    know the number of arguments a probe might receive when it’s executed by the kernel.
    This is why BPFTrace provides argument helpers to access the information that
    the kernel processes. BPFTrace generates these helpers dynamically depending on
    the number of arguments the block receives, and you can access the information
    by its position in the list of arguments. In the previous example, `arg1` is the
    reference to the second argument in the `open` syscall, which makes reference
    to the file path.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute this example, you can save it in a file and run BPFTrace with the
    file path as the first argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'BPFTrace’s language is designed with scripting in mind. In the previous examples,
    you’ve seen the terse version of the language, so you can get familiar with it.
    But many of the programs that you can write with BPFTrace fit on one single line.
    You don’t need to store those one-line programs in files to execute them; you
    can run them with the option `-e` when you execute BPFTrace. For example, the
    previous counter example can be a one-liner by collapsing the action block into
    a single line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know a little bit more about BPFTrace’s language, let’s see how
    to use it in several scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you run the previous example, you probably get a stream of files that your
    system is constantly opening, until you press Ctrl-C to exit the program. That’s
    because we’re telling BPF to print every file descriptor that the kernel opens.
    There are situations when you want to execute the action block only for specific
    conditions. BPFTrace calls that *filtering*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can associate one filter to each action block. They are evaluated like
    action blocks, but the action does not execute if the filter returns a false value.
    They also have access to the rest of the language, including probe arguments and
    helpers. These filters are encapsulated within two slashes after the action header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we refine our action block to be executed only when the file
    the kernel is opening is the file that we’re using to store this example. If you
    run the program with the new filter, you’ll see that it prints the header, but
    it stops printing there. This is because every file that was triggering our action
    before is being skipped now thanks to our new filter. If you open the example
    file several times in a different terminal, you’ll see how the kernel executes
    the action when the filter matches our file path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: BPFTrace’s filtering capabilities are super helpful to hide information that
    you don’t need, keeping data scoped to what you really care about. Next we talk
    about how BPFTrace makes working with maps seamless.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic Mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One handy feature that BPFTrace implements is dynamic map associations. It can
    generate BPF maps dynamically that you can use for many of the operations you’ve
    seen throughout the book. All map associations start with the character `@`, followed
    by the name of the map that you want to create. You can also associate update
    elements in those maps by assigning them values.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take the example that we started this section with, we could aggregate
    how often our system opens specific files. To do that, we need to count how many
    times the kernel runs the `open` syscall on a specific file, and then store those
    counters in a map. To identify those aggregations, we can use the file path as
    the map’s key. This is how our action block would look in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run your program again, you’ll get output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, BPFTrace prints the contents of the map when it stops the program
    execution. And as we expected, it’s aggregating how often the kernel is opening
    the files in our system. By default, BPFTrace is always going to print the contents
    of every map it creates when it terminates. You don’t need to specify that you
    want to print a map; it always assumes that you want to. You can change that behavior
    by clearing the map inside the `END` block by using the built-in function `clear`.
    This works because printing maps always happens after the footer block is executed.
  prefs: []
  type: TYPE_NORMAL
- en: BPFTrace dynamic mapping is super convenient. It removes a lot of boilerplate
    required to work with maps and focuses on helping you to collect data easily.
  prefs: []
  type: TYPE_NORMAL
- en: BPFTrace is a powerful tool for your day-to-day tasks. Its scripting language
    gives you enough flexibility to access every aspect of your system without the
    ceremony of having to compile and load your BPF program into the kernel manually,
    and this can help you trace and debug problems in your system from the get-go.
    Check out the reference guide in its GitHub repository to learn how to take advantage
    of all of its built-in capabilities, such as automatic histograms and stack trace
    aggregations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section we explore how to use BPFTrace inside Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: kubectl-trace
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`kubectl-trace` is a fantastic plug-in for the Kubernetes command line, `kubectl`.
    It helps you schedule BPFTrace programs in your Kubernetes cluster without having
    to install any additional packages or modules. It does this by scheduling a Kubernetes
    job with a container image that has everything you need to run the program installed
    already. This image is called `trace-runner`, and it’s also available in the public
    Docker registry.'
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to install `kubectl-trace` from its source repository using Go’s toolchain
    because its developers don’t provide any binary package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`kubectl`’s plug-in system will automatically detect this new add-on after
    Go’s toolchain compiles the program and puts it in the path. `kubectl-trace` automatically
    downloads the Docker images that it needs to run in your cluster the first time
    that you execute it.'
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting Kubernetes Nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use `kubectl-trace` to target nodes and pods where containers run, and
    you can also use it to target processes running on those containers. In the first
    case, you can run pretty much any BPF program that you’d like. However, in the
    second case, you’re restricted to running only the programs that attach user-space
    probes to those processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to run a BPF program on a specific node, you need a proper identifier
    so that Kubernetes schedules the job in the appropriate place. After you have
    that identifier, running the program is similar to running the programs you saw
    earlier. This is how we would run our one-liner to count file openings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the program is exactly the same, but we’re using the command
    `kubectl trace run` to schedule it in a specific cluster node. We use the syntax
    `node/...` to tell `kubectl-trace` that we’re targetting a node in the cluster.
    If we want to target a specific pod, we’d replace `node/` with `pod/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running a program on a specific container requires longer syntax; let’s see
    an example first and go through it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: There are two interesting things to highlight in this command. The first is
    that we need the name of the application running in the container to be able to
    find its process; this corresponds with the `application_name` in our example.
    You’ll want to use the name of the binary that’s executed in the container, for
    example `nginx` or `memcached`. Usually, containers run only one process, but
    this gives us extra guarantees that we’re attaching our program to the correct
    process. The second aspect to highlight is the inclusion of `$container_pid` in
    our BPF program. This is not a BPFTrace helper, but a placeholder that `kubectl-trace`
    uses as a replacement for the process identifier. Before running the BPF program,
    the trace-runner substitutes the placeholder with the appropriate identifier,
    and it attaches our program to the correct process.
  prefs: []
  type: TYPE_NORMAL
- en: If you run Kubernetes in production, `kubectl-trace` will make your life much
    easier when you need to analyze your containers’ behavior.
  prefs: []
  type: TYPE_NORMAL
- en: In this and the previous sections, we’ve focused on tools to help you run BPF
    programs more efficiently, even within container environments. In the next section
    we talk about a nice tool to integrate data gathering from BPF programs with Prometheus,
    a well-known open source monitoring system.
  prefs: []
  type: TYPE_NORMAL
- en: eBPF Exporter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: eBPF Exporter is a tool that allows you to export custom BPF tracing metrics
    to Prometheus. Prometheus is a highly scalable monitoring and alerting system.
    One key factor that makes Prometheus different from other monitoring systems is
    that it uses a pull strategy to fetch metrics, instead of expecting the client
    to push metrics to it. This allows users to write custom exporters that can gather
    metrics from any system, and Prometheus will pull them using a well-defined API
    schema. eBPF Exporter implements this API to fetch tracing metrics from BPF programs
    and import them into Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: Installation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although eBPF Exporter offers binary packages, we recommend installing it from
    source because there are often no new releases. Building from source also gives
    you access to newer functionality built on top of modern versions of BCC, the
    BPF Compiler Collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install eBPF Exporter from the source, you need to have BCC and Go’s toolchain
    already installed on your computer. With those prerequisites, you can use Go to
    download and build the binary for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Exporting Metrics from BPF
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: eBPF Exporter is configured using YAML files, in which you can specify the metrics
    that you want to collect from the system, the BPF program that generates those
    metrics, and how they translate to Prometheus. When Prometheus sends a request
    to eBPF Exporter to pull metrics, this tool translates the information that the
    BPF programs are collecting to metric values. Fortunately, eBPF Exporter bundles
    many programs that collect very useful information from your system, like instructions
    per cycle (IPC) and CPU cache hit rates.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple configuration file for eBPF Exporter includes three main sections.
    In the first section, you define the metrics that you want Prometheus to pull
    from the system. Here is where you translate the data collected in BPF maps to
    metrics that Prometheus understands. Following is an example of these translations
    from the project’s examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We’re defining a metric called `timer_start_total`, which aggregates how often
    the kernel starts a timer. We also specify that we want to collect this information
    from a BPF map called `counts`. Finally, we define a translation function for
    the map keys. This is necessary because map keys are usually pointers to the information,
    and we want to send Prometheus the actual function names.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second section in this example describes the probes we want to attach our
    BPF program to. In this case, we want to trace the timer start calls; we use the
    tracepoint `timer:timer_start` for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we’re telling eBPF Exporter that we want to attach the BPF function `tracepoint__timer__timer_start`
    to this specific tracepoint. Let’s see how to declare that function next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The BPF program is inlined within the YAML file. This is probably one of our
    less favorite parts of this tool because YAML is particular about whitespacing,
    but it works for small programs like this one. eBPF Exporter uses BCC to compile
    programs, so we have access to all its macros and helpers. The previous snippet
    uses the macro `TRACEPOINT_PROBE` to generate the final function that we’ll attach
    to our tracepoint with the name `tracepoint__timer__timer_start`.
  prefs: []
  type: TYPE_NORMAL
- en: Cloudflare uses eBPF Exporter to monitor metrics across all of its datacenters.
    The company made sure to bundle the most common metrics that you’ll want to export
    from your systems. But as you can see, it’s relatively easy to extend with new
    metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we talked about some of the our favorite tools for system analysis.
    These tools are general enough to have them on hand when you need to debug any
    kind of anomaly on your system. As you can see, all these tools abstract the concepts
    that we saw in the previous chapters to help you use BPF even when the environment
    is not ready for it. This is one of the many advantages of BPF before other analysis
    tools; because any modern Linux kernel includes the BPF VM, you can build new
    tools on top that take advantage of these powerful capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: There are many other tools that use BPF for similar purposes, such as Cilium
    and Sysdig, and we encourage you to try them.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter and [Chapter 4](ch04.html#tracing_with_bpf) dealt mostly with system
    analysis and tracing, but there is much more that you can do with BPF. In the
    next chapters we dive into its networking capabilities. We show you how to analyze
    traffic in any network and how to use BPF to control messages in your network.
  prefs: []
  type: TYPE_NORMAL
