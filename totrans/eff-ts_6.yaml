- en: Chapter 6\. Types Declarations and @types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency management can be confusing in any language, and TypeScript is no
    exception. This chapter will help you build a mental model for how dependencies
    work in TypeScript and show you how to work through some of the issues that can
    come up with them. It will also help you craft your own type declaration files
    to publish and share with others. By writing great type declarations, you can
    help not just your own project but the entire TypeScript community.
  prefs: []
  type: TYPE_NORMAL
- en: 'Item 45: Put TypeScript and @types in devDependencies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Node Package Manager, npm, is ubiquitous in the JavaScript world. It provides
    both a repository of JavaScript libraries (the npm registry) and a way to specify
    which versions of them you depend on (*package.json*).
  prefs: []
  type: TYPE_NORMAL
- en: 'npm draws a distinction between a few types of dependencies, each of which
    goes in a separate section of *package.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dependencies`'
  prefs: []
  type: TYPE_NORMAL
- en: These are packages that are required to run your JavaScript. If you import `lodash`
    at runtime, then it should go in `dependencies`. When you publish your code on
    npm and another user installs it, it will also install these dependencies. (These
    are known as transitive dependencies.)
  prefs: []
  type: TYPE_NORMAL
- en: '`devDependencies`'
  prefs: []
  type: TYPE_NORMAL
- en: These packages are used to develop and test your code but are not required at
    runtime. Your test framework would be an example of a `devDependency`. Unlike
    `dependencies`, these are *not* installed transitively with your packages.
  prefs: []
  type: TYPE_NORMAL
- en: '`peerDependencies`'
  prefs: []
  type: TYPE_NORMAL
- en: These are packages that you require at runtime but don’t want to be responsible
    for tracking. The canonical example is a plug-in. Your jQuery plug-in is compatible
    with a range of versions of jQuery itself, but you’d prefer that the user select
    one, rather than you choosing for them.
  prefs: []
  type: TYPE_NORMAL
- en: Of these, `dependencies` and `devDependencies` are by far the most common. As
    you use TypeScript, be aware of which type of dependency you’re adding. Because
    TypeScript is a development tool and TypeScript types do not exist at runtime
    ([Item 3](ch01.html#independent)), packages related to TypeScript generally belong
    in `devDependencies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first dependency to consider is TypeScript itself. It is possible to install
    TypeScript system-wide, but this is generally a bad idea for two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: There’s no guarantee that you and your coworkers will always have the same version
    installed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It adds a step to your project setup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make TypeScript a `devDependency` instead. That way you and your coworkers will
    always get the correct version when you run `npm install`. And updating your TypeScript
    version follows the same pattern as updating any other package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your IDE and build tools will happily discover a version of TypeScript installed
    in this way. On the command line you can use `npx` to run the version of `tsc`
    installed by npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next type of dependency to consider is *type dependencies* or `@types`.
    If a library itself does not come with TypeScript type declarations, then you
    may still be able to find typings on DefinitelyTyped, a community-maintained collection
    of type definitions for JavaScript libraries. Type definitions from DefinitelyTyped
    are published on the npm registry under the `@types` scope: `@types/jquery` has
    type definitions for the jQuery, `@types/lodash` has types for Lodash, and so
    on. These `@types` packages only contain the *types*. They don’t contain the implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Your `@types` dependencies should also be `devDependencies`, even if the package
    itself is a direct dependency. For example, to depend on React and its type declarations,
    you might run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in a *package.json* file that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The idea here is that you should publish JavaScript, not TypeScript, and your
    JavaScript does not depend on the `@types` when you run it. There are a few things
    that can go wrong with `@types` dependencies, and the next item will delve deeper
    into this topic.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Avoid installing TypeScript system-wide. Make TypeScript a `devDependency` of
    your project to ensure that everyone on the team is using a consistent version.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put `@types` dependencies in `devDependencies`, not `dependencies`. If you need
    `@types` at runtime, then you may want to rework your process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 46: Understand the Three Versions Involved in Type Declarations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency management rarely conjures up happy feelings for software developers.
    Usually you just want to use a library and not think too much about whether its
    transitive dependencies are compatible with yours.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bad news is that TypeScript doesn’t make this any better. In fact, it makes
    dependency management quite a bit *more* complicated. This is because instead
    of having a single version to worry about, you now have three:'
  prefs: []
  type: TYPE_NORMAL
- en: The version of the package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version of its type declarations (`@types`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The version of TypeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If any of these versions get out of sync with one another, you can run into
    errors that may not be clearly related to dependency management. But as the saying
    goes, “make things as simple as possible but no simpler.” Understanding the full
    complexity of TypeScript package management will help you diagnose and fix problems.
    And it will help you make more informed decisions when it comes time to publish
    type declarations of your own.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how dependencies in TypeScript are supposed to work. You install a package
    as a direct dependency, and you install its types as a dev dependency (see [Item
    45](#dev-dependencies)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that the major and minor versions (`16.8`) match but that the patch versions
    (`.6` and `.19`) do not. This is exactly what you want to see. The `16.8` in the
    `@types` version means that these type declarations describe the API of version
    `16.8` of `react`. Assuming the `react` module follows good semantic versioning
    hygiene, the patch versions (`16.8.1`, `16.8.2`, …) will not change its public
    API and will not require updates to the type declarations. But the type declarations
    *themselves* might have bugs or omissions. The patch versions of the `@types`
    module correspond to these sorts of fixes and additions. In this case, there were
    many more updates to the type declarations than the library itself (19 versus
    6).
  prefs: []
  type: TYPE_NORMAL
- en: This can go wrong in a few ways.
  prefs: []
  type: TYPE_NORMAL
- en: First, you might update a library but forget to update its type declarations.
    In this case you’ll get type errors whenever you try to use new features of the
    library. If there were breaking changes to the library, you might get runtime
    errors despite your code passing the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: The solution is usually to update your type declarations so that the versions
    are back in sync. If the type declarations have not been updated, you have a few
    options. You can use an augmentation in your own project to add new functions
    and methods that you’d like to use. Or you can contribute updated type declarations
    back to the community.
  prefs: []
  type: TYPE_NORMAL
- en: Second, your type declarations might get ahead of your library. This can happen
    if you’ve been using a library without its typings (perhaps you gave it an `any`
    type using `declare module`) and try to install them later. If there have been
    new releases of the library and its type declarations, your versions might be
    out of sync. The symptoms of this are similar to the first problem, just in reverse.
    The type checker will be comparing your code against the latest API, while you’ll
    be using an older one at runtime. The solution is to either upgrade the library
    or downgrade the type declarations until they match.
  prefs: []
  type: TYPE_NORMAL
- en: Third, the type declarations might require a newer version of TypeScript than
    you’re using in your project. Much of the development of TypeScript’s type system
    has been motivated by an attempt to more precisely type popular JavaScript libraries
    like Lodash, React, and Ramda. It makes sense that the type declarations for these
    libraries would want to use the latest and greatest features to get you better
    type safety.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this happens, you’ll experience it as type errors in the `@types` declarations
    themselves. The solution is to either upgrade your TypeScript version, use an
    older version of the type declarations, or, if you really can’t update TypeScript,
    stub out the types with `declare module`. It is possible for a library to provide
    different type declarations for different versions of TypeScript via `typesVersions`,
    but this is rare: at the time of this writing, fewer than 1% of the packages on
    DefinitelyTyped did so.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install `@types` for a specific version of TypeScript, you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The version matching between libraries and their types is best effort and may
    not always be correct. But the more popular the library is, the more likely it
    is that its type declarations will get this right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fourth, you can wind up with duplicate `@types` dependencies. Say you depend
    on `@types/foo` and `@types/bar`. If `@types/bar` depends on an incompatible version
    of `@types/foo`, then npm will attempt to resolve this by installing both versions,
    one in a nested folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: While this is sometimes OK for node modules that are used at runtime, it almost
    certainly won’t be OK for type declarations, which live in a flat global namespace.
    You’ll see this as errors about duplicate declarations or declarations that cannot
    be merged. You can track down why you have a duplicate type declaration by running
    `npm ls @types/foo`. The solution is typically to update your dependency on `@types/foo`
    or `@types/bar` so that they are compatible. Transitive `@types` dependencies
    like these are often a source of trouble. If you’re publishing types, see [Item
    51](#mirror-types-for-deps) for ways to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some packages, particularly those written in TypeScript, choose to bundle their
    own type declarations. This is usually indicated by a `"types"` field in their
    *package.json* which points to a *.d.ts* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Does this solve all our problems? Would I even be asking if the answer was “yes”?
  prefs: []
  type: TYPE_NORMAL
- en: Bundling types *does* solve the problem of version mismatch, particularly if
    the library itself is written in TypeScript and the type declarations are generated
    by `tsc`. But bundling has some problems of its own.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, what if there’s an error in the bundled types that can’t be fixed through
    augmentation? Or the types worked fine when they were published, but a new TypeScript
    version has since been released which flags an error. With `@types` you could
    depend on the library’s implementation but not its type declarations. But with
    bundled types, you lose this option. One bad type declaration might keep you stuck
    on an old version of TypeScript. Contrast this with DefinitelyTyped: as TypeScript
    is developed, Microsoft runs it against all the type declarations on DefinitelyTyped.
    Breaks are fixed quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Second, what if your types depend on another library’s type declarations? Usually
    this would be a `devDependency` ([Item 45](#dev-dependencies)). But if you publish
    your module and another user installs it, they won’t get your `devDependencies`.
    Type errors will result. On the other hand, you probably don’t want to make it
    a direct dependency either, since then your JavaScript users will install `@types`
    modules for no reason. [Item 51](#mirror-types-for-deps) discusses the standard
    workaround for this situation. But if you publish your types on DefinitelyTyped,
    this is not a problem at all: you declare your type dependency there and only
    your TypeScript users will get it.'
  prefs: []
  type: TYPE_NORMAL
- en: Third, what if you need to fix an issue with the type declarations of an old
    version of your library? Would you be able to go back and release a patch update?
    DefinitelyTyped has mechanisms for simultaneously maintaining type declarations
    for different versions of the same library, something that might be hard for you
    to do in your own project.
  prefs: []
  type: TYPE_NORMAL
- en: Fourth, how committed to accepting patches for type declarations are you? Remember
    the versions of `react` and `@types/react` from the start of this item. There
    were three times more patch updates to the type declarations than the library
    itself. DefinitelyTyped is community-maintained and is able to handle this volume.
    In particular, if a library maintainer doesn’t look at a patch within five days,
    a global maintainer will. Can you commit to a similar turnaround time for your
    library?
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing dependencies in TypeScript can be challenging, but it does come with
    rewards: well-written type declarations can help you learn how to use libraries
    correctly and can greatly improve your productivity with them. As you run into
    issues with dependency management, keep the three versions in mind.'
  prefs: []
  type: TYPE_NORMAL
- en: If you are publishing packages, weigh the pros and cons of bundling type declarations
    versus publishing them on DefinitelyTyped. The official recommendation is to bundle
    type declarations only if the library is written in TypeScript. This works well
    in practice since `tsc` can automatically generate type declarations for you (using
    the `declaration` compiler option). For JavaScript libraries, handcrafted type
    declarations are more likely to contain errors, and they’ll require more updates.
    If you publish your type declarations on DefinitelyTyped, the community will help
    you support and maintain them.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three versions involved in an `@types` dependency: the library version,
    the `@types` version, and the TypeScript version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you update a library, make sure you update the corresponding `@types`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the pros and cons of bundling types versus publishing them on DefinitelyTyped.
    Prefer bundling types if your library is written in TypeScript and DefinitelyTyped
    if it is not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 47: Export All Types That Appear in Public APIs'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use TypeScript long enough and you’ll eventually find yourself wanting to use
    a `type` or `interface` from a third-party module only to find that it isn’t exported.
    Fortunately TypeScript’s tools for mapping between types are rich enough that,
    as a library user, you can almost always find a way to reference the type you
    want. As a library author, this means that you ought to just export your types
    to begin with. If a type ever appears in a function declaration, it is effectively
    exported. So you may as well make things explicit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to create some secret, unexported types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As a user of your module, I cannot directly import `SecretName` or `SecretSanta`,
    only `getGift`. But this is no barrier: because those types appear in an exported
    function signature, I can extract them. One way is to use the `Parameters` and
    `ReturnType` generic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If your goal in not exporting these types was to preserve flexibility, then
    the jig is up! You’ve already committed to them by putting them in a public API.
    Do your users a favor and export them.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Export types that appear in any form in any public method. Your users will be
    able to extract them anyway, so you may as well make it easy for them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 48: Use TSDoc for API Comments'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s a TypeScript function to generate a greeting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The author was kind enough to leave a comment describing what this function
    does. But for documentation intended to be read by users of your functions, it’s
    better to use JSDoc-style comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The reason is that there is a nearly universal convention in editors to surface
    JSDoc-style comments when the function is called (see [Figure 6-1](#efts-06in01)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 06in01](assets/efts_06in01.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. JSDoc-style comments are typically surfaced in tooltips in your
    editor.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Whereas the inline comment gets no such treatment (see [Figure 6-2](#efts-06in02)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 06in02](assets/efts_06in02.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Inline comments are typically not shown in tooltips.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The TypeScript language service supports this convention, and you should take
    advantage of it. If a comment describes a public API, it should be JSDoc. In the
    context of TypeScript, these comments are sometimes called TSDoc. You can use
    many of the usual conventions like `@param` and `@returns`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This lets editors show the relevant documentation for each parameter as you’re
    writing out a function call (as shown in [Figure 6-3](#efts-06in03)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 06in03](assets/efts_06in03.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. An @param annotation lets your editor show documentation for the
    current parameter as you type it.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can also use TSDoc with type definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you inspect individual fields in a `Measurement` object, you’ll get contextual
    documentation (see [Figure 6-4](#efts-06in04)).
  prefs: []
  type: TYPE_NORMAL
- en: '![efts 06in04](assets/efts_06in04.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. TSDoc for a field is shown when you mouse over that field in your
    editor.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'TSDoc comments are formatted using Markdown, so if you want to use bold, italic,
    or bulleted lists, you can (see [Figure 6-5](#efts_06in05)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![efts 06in05](assets/efts_06in05.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. TSDoc comments
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Try to avoid writing essays in your documentation, though: the best comments
    are short and to the point.'
  prefs: []
  type: TYPE_NORMAL
- en: JSDoc includes some conventions for specifying type information (`@param {string}
    name ...`), but you should avoid these in favor of TypeScript types ([Item 30](ch04.html#jsdoc-repeat)).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use JSDoc-/TSDoc-formatted comments to document exported functions, classes,
    and types. This helps editors surface information for your users when it’s most
    relevant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `@param`, `@returns`, and Markdown for formatting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid including type information in documentation (see [Item 30](ch04.html#jsdoc-repeat)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 49: Provide a Type for this in Callbacks'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript’s `this` keyword is one of the most notoriously confusing parts
    of the language. Unlike variables declared with `let` or `const`, which are lexically
    scoped, `this` is dynamically scoped: its value depends not on the way in which
    it was *defined* but on the way in which it was *called*.'
  prefs: []
  type: TYPE_NORMAL
- en: '`this` is most often used in classes, where it typically references the current
    instance of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now look what happens if you try to put `logSquares` in a variable and call
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This version throws an error at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that `c.logSquares()` actually does two things: it calls `C.prototype.logSquares`
    *and* it binds the value of `this` in that function to `c`. By pulling out a reference
    to `logSquares`, you’ve separated these, and `this` gets set to `undefined`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript gives you complete control over `this` binding. You can use `call`
    to explicitly set `this` and fix the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s no reason that `this` had to be bound to an instance of `C`. It could
    have been bound to anything. So libraries can, and do, make the value of `this`
    part of their APIs. Even the DOM makes use of this. In an event handler, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`this` binding often comes up in the context of callbacks like this one. If
    you want to define an `onClick` handler in a class, for example, you might try
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'When `Button` calls `onClick`, it will alert “Reset undefined.” Oops! As usual,
    the culprit is `this` binding. A common solution is to create a bound version
    of the method in the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `onClick() { ... }` definition defines a property on `ResetButton.prototype`.
    This is shared by all instances of `ResetButton`. When you bind `this.onClick
    = ...` in the constructor, it creates a property called `onClick` on the instance
    of `ResetButton` with `this` bound to that instance. The `onClick` instance property
    comes before the `onClick` prototype property in the lookup sequence, so `this.onClick`
    refers to the bound function in the `render()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a shorthand for binding that can sometimes be convenient:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we’ve replaced `onClick` with an arrow function. This will define a new
    function every time a `ResetButton` is constructed with `this` set to the appropriate
    value. It’s instructive to look at the JavaScript that this generates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: So what does this all have to do with TypeScript? Because `this` binding is
    part of JavaScript, TypeScript models it. This means that if you’re writing (or
    typing) a library that sets the value of `this` on callbacks, then you should
    model this, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do this by adding a `this` parameter to your callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `this` parameter is special: it’s not just another positional argument.
    You can see this if you try to call it with two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, TypeScript will enforce that you call the function with the correct
    `this` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'As a user of this function, you can reference `this` in the callback and get
    full type safety:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if you use an arrow function here, you’ll override the value of
    `this`. TypeScript will catch the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Don’t forget about `this`! If you set the value of `this` in your callbacks,
    then it’s part of your API, and you should include it in your type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Understand how `this` binding works.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a type for `this` in callbacks when it’s part of your API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 50: Prefer Conditional Types to Overloaded Declarations'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would you write a type declaration for this JavaScript function?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`double` can be passed either a `string` or a `number`. So you might use a
    union type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: (These examples all make use of TypeScript’s concept of function overloading.
    For a refresher, see [Item 3](ch01.html#independent).)
  prefs: []
  type: TYPE_NORMAL
- en: 'While this declaration is accurate, it’s a bit imprecise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: When `double` is passed a `number`, it returns a `number`. And when it’s passed
    a `string`, it returns a `string`. This declaration misses that nuance and will
    produce types that are hard to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might try to capture this relationship using a generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, in our zeal for precision we’ve overshot. The types are now
    a little *too* precise. When passed a `string` type, this `double` declaration
    will result in a `string` type, which is correct. But when passed a string *literal*
    type, the return type is the same string literal type. This is wrong: doubling
    `''x''` results in `''xx''`, not `''x''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to provide multiple type declarations. While TypeScript only
    allows you to write one implementation of a function, it allows you to write any
    number of type declarations. You can use this to improve the type of `double`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This is progress! But is this declaration correct? Unfortunately there’s still
    a subtle bug. This type declaration will work with values that are either a `string`
    or a `number`, but not with values that could be either:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This call to `double` is safe and should return `string|number`. When you overload
    type declarations, TypeScript processes them one by one until it finds a match.
    The error you’re seeing is a result of the last overload (the `string` version)
    failing, because `string|number` is not assignable to `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'While you could patch this issue by adding a third `string|number` overload,
    the best solution is to use a *conditional type*. Conditional types are like if
    statements (conditionals) in type space. They’re perfect for situations like this
    one where there are a few possibilities that you need to cover:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is similar to the first attempt to type `double` using a generic, but
    with a more elaborate return type. You read the conditional type like you’d read
    a ternary (`?:`) operator in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: If `T` is a subset of `string` (e.g., `string` or a string literal or a union
    of string literals), then the return type is `string`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise return `number`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this declaration, all of our examples work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `number|string` example works because conditional types distribute over
    unions. When `T` is `number|string`, TypeScript resolves the conditional type
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: While the type declaration using overloading was simpler to write, the version
    using conditional types is more correct because it generalizes to the union of
    the individual cases. This is often the case for overloads. Whereas overloads
    are treated independently, the type checker can analyze conditional types as a
    single expression, distributing them over unions. If you find yourself writing
    an overloaded type declarations, consider whether it might be better expressed
    using a conditional type.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prefer conditional types to overloaded type declarations. By distributing over
    unions, conditional types allow your declarations to support union types without
    additional overloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 51: Mirror Types to Sever Dependencies'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Suppose you’ve written a library for parsing CSV files. Its API is simple:
    you pass in the contents of the CSV file and get back a list of objects mapping
    column names to values. As a convenience for your NodeJS users, you allow the
    contents to be either a `string` or a NodeJS `Buffer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The type definition for `Buffer` comes from the NodeJS type declarations, which
    you must install:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When you publish your CSV parsing library, you include the type declarations
    with it. Since your type declarations depend on the NodeJS types, you include
    these as a `devDependency` ([Item 45](#dev-dependencies)). If you do this, you’re
    liable to get complaints from two groups of users:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript developers who wonder what these `@types` modules are that they’re
    depending on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript web developers who wonder why they’re depending on NodeJS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These complaints are reasonable. The `Buffer` behavior isn’t essential and is
    only relevant for users who are using NodeJS already. And the declaration in `@types/node`
    is only relevant to NodeJS users who are also using TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript’s structural typing ([Item 4](ch01.html#structural)) can help you
    out of the jam. Rather than using the declaration of `Buffer` from `@types/node`,
    you can write your own with just the methods and properties you need. In this
    case that’s just a `toString` method that accepts an encoding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This interface is dramatically shorter than the complete one, but it does capture
    our (simple) needs from a `Buffer`. In a NodeJS project, calling `parseCSV` with
    a real `Buffer` is still OK because the types are compatible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If your library only depends on the types for another library, rather than its
    implementation, consider mirroring just the declarations you need into your own
    code. This will result in a similar experience for your TypeScript users and an
    improved experience for everyone else.
  prefs: []
  type: TYPE_NORMAL
- en: If you depend on the implementation of a library, you may still be able to apply
    the same trick to avoid depending on its typings. But this becomes increasingly
    difficult as the dependence grows larger and more essential. If you’re copying
    a large portion of the type declarations for another library, you may want to
    formalize the relationship by making the `@types` dependency explicit.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is also helpful for severing dependencies between your unit tests
    and production systems. See the `getAuthors` example in [Item 4](ch01.html#structural).
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use structural typing to sever dependencies that are nonessential.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t force JavaScript users to depend on `@types`. Don’t force web developers
    to depend on NodeJS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Item 52: Be Aware of the Pitfalls of Testing Types'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You wouldn’t publish code without writing tests for it (I hope!), and you shouldn’t
    publish type declarations without writing tests for them, either. But how do you
    test types? If you’re authoring type declarations, testing is an essential but
    surprisingly fraught undertaking. It’s tempting to make assertions about types
    inside the type system using the tools that TypeScript provides. But there are
    several pitfalls with this approach. Ultimately it’s safer and more straightforward
    to use `dtslint` or a similar tool that inspects types from outside of the type
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you’ve written a type declaration for a `map` function provided by
    a utility library (the popular Lodash and Underscore libraries both provide such
    a function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'How can you check that this type declaration results in the expected types?
    (Presumably there are separate tests for the implementation.) One common technique
    is to write a test file that calls the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This will do some blunt error checking: if your declaration of `map` only listed
    a single parameter, this would catch the mistake. But does it feel like something
    is missing here?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent of this style of test for runtime behavior might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Sure, this tests that the `square` function doesn’t throw an error. But it’s
    missing any checks on the return value, so there’s no real test of the behavior.
    An incorrect implementation of `square` would still pass this test.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is common in testing type declaration files because it’s simple
    to copy over existing unit tests for a library. And while it does provide some
    value, it would be much better to actually check some types!
  prefs: []
  type: TYPE_NORMAL
- en: 'One way is to assign the result to a variable with a specific type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is exactly the sort of superfluous type declaration that [Item 19](ch03.html#avoid-inferable)
    would encourage you to remove. But here it plays an essential role: it provides
    some confidence that the `map` declaration is at least doing something sensible
    with the types. And indeed you can find many type declarations in DefinitelyTyped
    that use exactly this approach for testing. But, as we’ll see, there are a few
    fundamental problems with using assignment for testing.'
  prefs: []
  type: TYPE_NORMAL
- en: One is that you have to create a named variable that is likely to be unused.
    This adds boilerplate, but also means that you’ll have to disable some forms of
    linting.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common workaround is to define a helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This eliminates the unused variable issue, but there are still surprises.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second issue is that we’re checking *assignability* of the two types rather
    than equality. Often this works as you’d expect. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: If you inspect the `n` symbol, you’ll see that its type is actually `12`, a
    numeric literal type. This is a subtype of `number` and so the assignability check
    passes, just as you’d expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far so good. But things get murkier when you start checking the types of
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `map` call returns an array of `{name: string, inYellowSubmarine: boolean}`
    objects. This is assignable to `{name: string}[]`, sure, but shouldn’t we be forced
    to acknowledge the yellow submarine? Depending on the context you may or may not
    really want to check for type equality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If your function returns another function, you may be surprised at what’s considered
    assignable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Are you surprised that the second assertion succeeds? The reason is that a
    function in TypeScript is assignable to a function type, which takes fewer parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'This reflects the fact that it’s perfectly fine to call a JavaScript function
    with more parameters than it’s declared to take. TypeScript chooses to model this
    behavior rather than bar it, largely because it is pervasive in callbacks. The
    callback in the Lodash `map` function, for example, takes up to three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: While all three are available, it’s very common to use only one or sometimes
    two, as we have so far in this item. In fact, it’s quite rare to use all three.
    By disallowing this assignment, TypeScript would report errors in an enormous
    amount of JavaScript code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So what can you do? You could break apart the function type and test its pieces
    using the generic `Parameters` and `ReturnType` types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'But if “this” isn’t complicated enough, there’s another issue: `map` sets the
    value of `this` for its callback. TypeScript can model this behavior (see [Item
    49](#this-in-callbacks)), so your type declaration should do so. And you should
    test it. How can we do that?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our tests of `map` so far have been a bit black box in style: we’ve run an
    array and function through `map` and tested the type of the result, but we haven’t
    tested the details of the intermediate steps. We can do so by filling out the
    callback function and verifying the types of its parameters and `this` directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This surfaced a few issues with our declaration of `map`. Note the use of a
    non-arrow function so that we could test the type of `this`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a declaration that passes the checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'There remains a final issue, however, and it is a major one. Here’s a complete
    type declaration file for our module that will pass even the most stringent tests
    for `map` but is worse than useless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This assigns an `any` type to the *entire module*. Your tests will all pass,
    but you won’t have any type safety. What’s worse, every call to a function in
    this module will quietly produce an `any` type, contagiously destroying type safety
    throughout your code. Even with `noImplicitAny`, you can still get `any` types
    through type declarations.
  prefs: []
  type: TYPE_NORMAL
- en: Barring some advanced trickery, it’s quite difficult to detect an `any` type
    from within the type system. This is why the preferred method for testing type
    declarations is to use a tool that operates *outside* the type checker.
  prefs: []
  type: TYPE_NORMAL
- en: 'For type declarations in the DefinitelyTyped repository, this tool is `dtslint`.
    It operates through specially formatted comments. Here’s how you might write the
    last test for the `map` function using `dtslint`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than checking assignability, `dtslint` inspects the type of each symbol
    and does a textual comparison. This matches how you’d manually test the type declarations
    in your editor: `dtslint` essentially automates this process. This approach does
    have some drawbacks: `number|string` and `string|number` are textually different
    but the same type. But so are `string` and `any`, despite being assignable to
    each other, which is really the point.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing type declarations is tricky business. You *should* test them. But be
    aware of the pitfalls of some of the common techniques and consider using a tool
    like `dtslint` to avoid them.
  prefs: []
  type: TYPE_NORMAL
- en: Things to Remember
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When testing types, be aware of the difference between equality and assignability,
    particularly for function types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For functions that use callbacks, test the inferred types of the callback parameters.
    Don’t forget to test the type of `this` if it’s part of your API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be wary of `any` in tests involving types. Consider using a tool like `dtslint`
    for stricter, less error-prone checking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
