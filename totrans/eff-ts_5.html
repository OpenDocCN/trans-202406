<html><head></head><body><section data-pdf-bookmark="Chapter 5. Working with any" data-type="chapter" epub:type="chapter" class="praise"><div class="praise" id="ch-any">
<h1 class="calibre14"><span class="calibre">Chapter 5. </span>Working with any</h1>


<p class="author1">Type systems<a data-primary="type system" data-secondary="as optional and gradual" data-secondary-sortas="optional and gradual" data-type="indexterm" id="idm45331653064104" class="calibre9"/> were traditionally binary affairs: either a language had a fully static type system or a fully dynamic one. TypeScript blurs the line, because its type system is <em class="calibre3">optional</em> and <em class="calibre3">gradual</em>. You can add types to parts of your program but not others.</p>

<p class="author1">This is essential for migrating existing JavaScript codebases to TypeScript bit by bit (<a data-type="xref" href="ch08.html#ch-migrate" class="calibre9">Chapter 8</a>). Key to this is the <code class="calibre18">any</code> type,  which effectively disables type checking for parts of your code. It is both powerful and prone to abuse. Learning to use <code class="calibre18">any</code> wisely is essential for writing effective TypeScript. This chapter walks you through how to limit the downsides of <code class="calibre18">any</code> while still retaining its benefits.</p>






<section data-pdf-bookmark="Item 38: Use the Narrowest Possible Scope for any Types" data-type="sect1" class="praise"><div class="praise" id="narrowest-any">
<h1 class="calibre16">Item 38: Use the Narrowest Possible Scope for any Types</h1>

<p class="author1">Consider<a data-primary="any types" data-secondary="using narrow scope for" data-type="indexterm" id="ATnarrow05" class="calibre9"/><a data-primary="functions" data-secondary="avoid returning any types from" data-type="indexterm" id="Favoid05" class="calibre9"/><a data-primary="type safety" data-secondary="avoid returning any types from functions" data-type="indexterm" id="TSavoid05" class="calibre9"/> this code:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">processBar</code><code class="p">(</code><code class="nx">b</code>: <code class="nx">Bar</code><code class="p">)</code> <code class="p">{</code> <code class="c">/* ... */</code> <code class="p">}</code>

<code class="kd">function</code> <code class="nx">f() {</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
  <code class="c">//         ~ Argument of type 'Foo' is not assignable to</code>
  <code class="c">//           parameter of type 'Bar'</code>
<code class="p">}</code></pre>

<p class="author1">If you somehow know from context that <code class="calibre18">x</code> is assignable to <code class="calibre18">Bar</code> in addition to <code class="calibre18">Foo</code>, you can force TypeScript to accept this code in two ways:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f1() {</code>
  <code class="kd">const</code> <code class="nx">x</code>: <code class="nx">any</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>  <code class="c">// Don't do this</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">f2() {</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">);</code>  <code class="c">// Prefer this</code>
<code class="p">}</code></pre>

<p class="author1">Of these, the second form is vastly preferable. Why? Because the <code class="calibre18">any</code> type is scoped to a single expression in a function argument. It has no effect outside this argument or this line. If code after the <code class="calibre18">processBar</code> call references <code class="calibre18">x</code>, its type will still be <code class="calibre18">Foo</code>, and it will still be able to trigger type errors, whereas in the first example its type is <code class="calibre18">any</code> until it goes out of scope at the end of the function.</p>

<p class="author1">The stakes become significantly higher if you <em class="calibre3">return</em> <code class="calibre18">x</code> from this function. Look what happens:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f1() {</code>
  <code class="kd">const</code> <code class="nx">x</code>: <code class="nx">any</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">g() {</code>
  <code class="kd">const</code> <code class="nx">foo</code> <code class="o">=</code> <code class="nx">f1</code><code class="p">();</code>  <code class="c">// Type is any</code>
  <code class="nx">foo</code><code class="p">.</code><code class="nx">fooMethod</code><code class="p">();</code>  <code class="c">// This call is unchecked!</code>
<code class="p">}</code></pre>

<p class="author1">An <code class="calibre18">any</code> return type is “contagious” in that it can spread throughout a codebase. As a result of our changes to <code class="calibre18">f</code>, an <code class="calibre18">any</code> type has quietly appeared in <code class="calibre18">g</code>. This would not have happened with the more narrowly scoped <code class="calibre18">any</code> in <code class="calibre18">f2</code>.</p>

<p class="author1">(This<a data-primary="type annotations" data-secondary="using explicit with any types" data-type="indexterm" id="idm45331652853512" class="calibre9"/> is a good reason to consider including explicit return type annotations, even when the return type can be inferred. It prevents an <code class="calibre18">any</code> type from “escaping.” See discussion in <a href="ch03.html#avoid-inferable" class="calibre9">Item 19</a>.)</p>

<p class="author1">We<a data-primary="@ts-ignore" data-type="indexterm" id="idm45331652850792" class="calibre9"/> used <code class="calibre18">any</code> here to silence an error that we believed to be incorrect. Another way to do this is with <code class="calibre18">@ts-ignore</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">f1() {</code>
  <code class="kd">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">expressionReturningFoo</code><code class="p">();</code>
  <code class="c">// @ts-ignore</code>
  <code class="nx">processBar</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
  <code class="kd">return</code> <code class="nx">x</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This silences an error on the next line, leaving the type of <code class="calibre18">x</code> unchanged. Try not to lean too heavily on <code class="calibre18">@ts-ignore</code>: the type checker usually has a good reason to complain. It also means that if the error on the next line changes to something more problematic, you won’t know.</p>

<p class="author1">You may also run into situations where you get a type error for just one property in a larger object:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">config</code>: <code class="nx">Config</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">a</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">b</code>: <code class="nx">2</code><code class="p">,</code>
  <code class="nx">c</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">value</code>
 <code class="c">// ~~~ Property ... missing in type 'Bar' but required in type 'Foo'</code>
  <code class="p">}</code>
<code class="p">};</code></pre>

<p class="author1">You can silence errors like this by throwing an <code class="calibre18">as any</code> around the whole <code class="calibre18">config</code> object:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">config</code>: <code class="nx">Config</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">a</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">b</code>: <code class="nx">2</code><code class="p">,</code>
  <code class="nx">c</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">value</code>
  <code class="p">}</code>
<code class="p">}</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// Don't do this!</code></pre>

<p class="author1">But this has the side effect of disabling type checking for the other properties (<code class="calibre18">a</code> and <code class="calibre18">b</code>) as well. Using a more narrowly scoped <code class="calibre18">any</code> limits the damage:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">config</code>: <code class="nx">Config</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">a</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">b</code>: <code class="nx">2</code><code class="p">,</code>  <code class="c">// These properties are still checked</code>
  <code class="nx">c</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">key</code>: <code class="nx">value</code> <code class="kd">as</code> <code class="nx">any</code>
  <code class="p">}</code>
<code class="p">};</code></pre>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331652700104">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Make your uses of <code class="calibre18">any</code> as narrowly scoped as possible to avoid undesired loss of type safety elsewhere in your code.</p>
</li>
<li class="calibre12">
<p class="author1">Never return an <code class="calibre18">any</code> type from a function. This will silently lead to the loss of type safety for any client calling the function.</p>
</li>
<li class="calibre12">
<p class="author1">Consider <code class="calibre18">@ts-ignore</code> as an alternative to <code class="calibre18">any</code> if you need to silence one error.<a data-primary="" data-startref="ATnarrow05" data-type="indexterm" id="idm45331652655592" class="calibre9"/><a data-primary="" data-startref="TSavoid05" data-type="indexterm" id="idm45331652654616" class="calibre9"/><a data-primary="" data-startref="Favoid05" data-type="indexterm" id="idm45331652653672" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 39: Prefer More Precise Variants of any to Plain any" data-type="sect1" class="praise"><div class="praise" id="specific-any">
<h1 class="calibre16">Item 39: Prefer More Precise Variants of any to Plain any</h1>

<p class="author1">The<a data-primary="any types" data-secondary="plain any versus more precise variants" data-type="indexterm" id="ATplain05" class="calibre9"/><a data-primary="any[ ] types" data-type="indexterm" id="any05" class="calibre9"/><a data-primary="() =&gt; any" data-type="indexterm" id="fatany05" class="calibre9"/><a data-primary="{[id: string]: any}" data-type="indexterm" id="idstring05" class="calibre9"/> <code class="calibre18">any</code> type encompasses all values that can be expressed in JavaScript. This is a vast set! It includes not just all numbers and strings, but all arrays, objects, regular expressions, functions, classes, and DOM elements, not to mention <code class="calibre18">null</code> and <code class="calibre18">undefined</code>. When you use an <code class="calibre18">any</code> type, ask whether you really had something more specific in mind. Would it be OK to pass in a regular expression or a function?</p>

<p class="author1">Often the answer is “no,” in which case you might be able to retain some type safety by using a more specific type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getLengthBad</code><code class="p">(</code><code class="nx">array</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code>  <code class="c">// Don't do this!</code>
  <code class="kd">return</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">getLength</code><code class="p">(</code><code class="nx">array</code>: <code class="nx">any</code><code class="p">[])</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">The latter version, which uses <code class="calibre18">any[]</code> instead of <code class="calibre18">any</code>, is better in three ways:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">The reference to <code class="calibre18">array.length</code> in the function body is type checked.</p>
</li>
<li class="calibre12">
<p class="author1">The function’s return type is inferred as <code class="calibre18">number</code> instead of <code class="calibre18">any</code>.</p>
</li>
<li class="calibre12">
<p class="author1">Calls to <code class="calibre18">getLength</code> will be checked to ensure that the parameter is an array:</p>
</li>
</ul>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nx">getLengthBad</code><code class="p">(</code><code class="sr">/123/</code><code class="p">);</code>  <code class="c">// No error, returns undefined</code>
<code class="nx">getLength</code><code class="p">(</code><code class="sr">/123/</code><code class="p">);</code>
       <code class="c">// ~~~~~ Argument of type 'RegExp' is not assignable</code>
       <code class="c">//       to parameter of type 'any[]'</code></pre>

<p class="author1">If<a data-primary="{[key: string]: any} type" data-type="indexterm" id="idm45331652586696" class="calibre9"/> you expect a parameter to be an array of arrays but don’t care about the type, you can use <code class="calibre18">any[][]</code>. If you expect some sort of object but don’t know what the values will be, you can use <code class="calibre18">{[key: string]: any}</code>:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">hasTwelveLetterKey</code><code class="p">(</code><code class="nx">o</code><code class="o">:</code> <code class="p">{[</code><code class="nx">key</code>: <code class="kd">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">any</code><code class="p">})</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">key</code> <code class="kd">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">key</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">12</code><code class="p">)</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">You could also use the <code class="calibre18">object</code> type in this situation, which includes all non-primitive types. This is slightly different in that, while you can still enumerate keys, you can’t access the values of any of them:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">hasTwelveLetterKey</code><code class="p">(</code><code class="nx">o</code>: <code class="nx">object</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="nx">key</code> <code class="kd">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="nx">key</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">12</code><code class="p">)</code> <code class="p">{</code>
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">o</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
                   <code class="c">//  ~~~~~~ Element implicitly has an 'any' type</code>
                   <code class="c">//         because type '{}' has no index signature</code>
      <code class="kd">return</code> <code class="kd">true</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">If this sort of type fits your needs, you might also be interested in the <code class="calibre18">unknown</code> type. See <a href="#never-unknown" class="calibre9">Item 42</a>.</p>

<p class="author1">Avoid using <code class="calibre18">any</code> if you expect a function type. You have several options here depending on how specific you want to get:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">type</code> <code class="nx">Fn0</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// any function callable with no params</code>
<code class="kd">type</code> <code class="nx">Fn1</code> <code class="o">=</code> <code class="p">(</code><code class="nx">arg</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// With one param</code>
<code class="kd">type</code> <code class="nx">FnN</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">;</code>  <code class="c">// With any number of params</code>
                                     <code class="c">// same as "Function" type</code></pre>

<p class="author1">All of these are more precise than <code class="calibre18">any</code> and hence preferable to it. Note the use of <code class="calibre18">any[]</code> as the type for the rest parameter in the last example. <code class="calibre18">any</code> would also work here but would be less precise:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">numArgsBad</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c">// Returns any</code>
<code class="kd">const</code> <code class="nx">numArgsGood</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>  <code class="c">// Returns number</code></pre>

<p class="author1">This is perhaps the most common use of the <code class="calibre18">any[]</code> type.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331652297464">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">When you use <code class="calibre18">any</code>, think about whether any JavaScript value is truly permissible.</p>
</li>
<li class="calibre12">
<p class="author1">Prefer more precise forms of <code class="calibre18">any</code> such as <code class="calibre18">any[]</code> or <code class="calibre18">{[id: string]: any}</code> or <code class="calibre18">() =&gt; any</code> if they more accurately model your data.<a data-primary="" data-startref="idstring05" data-type="indexterm" id="idm45331652292024" class="calibre9"/><a data-primary="" data-type="indexterm" id="idm45331652291048" class="calibre9"/><a data-primary="" data-startref="fatany05" data-type="indexterm" id="idm45331652270984" class="calibre9"/><a data-primary="" data-startref="ATplain05" data-type="indexterm" id="idm45331652270040" class="calibre9"/><a data-startref="any05" data-type="indexterm" id="idm45331652269096" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 40: Hide Unsafe Type Assertions in Well-Typed Functions" data-type="sect1" class="praise"><div class="praise" id="hide-unsafe-casts">
<h1 class="calibre16">Item 40: Hide Unsafe Type Assertions in Well-Typed Functions</h1>

<p class="author1">There<a data-primary="any types" data-secondary="hiding unsafe type assertions" data-type="indexterm" id="idm45331652266232" class="calibre9"/><a data-primary="type safety" data-secondary="hiding unsafe type assertions" data-type="indexterm" id="idm45331652265256" class="calibre9"/><a data-primary="unsafe casts" data-type="indexterm" id="idm45331652264344" class="calibre9"/><a data-primary="type assertion" data-secondary="hiding unsafe type assertions" data-type="indexterm" id="idm45331652263672" class="calibre9"/><a data-primary="functions" data-secondary="hiding unsafe type assertions in" data-type="indexterm" id="idm45331652262760" class="calibre9"/> are many functions whose type signatures are easy to write but whose implementations are quite difficult to write in type-safe code. And while writing type-safe implementations is a noble goal, it may not be worth the difficulty to deal with edge cases that you know don’t come up in your code. If a reasonable attempt at a type-safe implementation doesn’t work, use an unsafe type assertion hidden inside a function with the right type signature. Unsafe assertions hidden inside well-typed functions are much better than unsafe assertions scattered throughout your code.</p>

<p class="author1">Suppose<a data-primary="React library" data-secondary="useMemo hook" data-type="indexterm" id="idm45331652260696" class="calibre9"/> you want to make a function cache its last call. This is a common technique for eliminating expensive function calls with frameworks like React.<sup class="calibre44"><a data-type="noteref" href="ch05.html#idm45331652259400" id="idm45331652259400-marker" class="calibre45">1</a></sup> It would be nice to write a general <code class="calibre18">cacheLast</code> wrapper that adds this behavior to any function. Its declaration is easy to write:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">cacheLast</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">fn</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code></pre>

<p class="author1">Here’s an attempt at an implementation:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">cacheLast</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">fn</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">lastArgs</code>: <code class="nx">any</code><code class="p">[]</code><code class="o">|</code><code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>
  <code class="kd">let</code> <code class="nx">lastResult</code>: <code class="nx">any</code><code class="p">;</code>
  <code class="kd">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="p">{</code>
      <code class="c">// ~~~~~~~~~~~~~~~~~~~~~~~~~~</code>
      <code class="c">//          Type '(...args: any[]) =&gt; any' is not assignable to type 'T'</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">lastArgs</code> <code class="o">||</code> <code class="o">!</code><code class="nx">shallowEqual</code><code class="p">(</code><code class="nx">lastArgs</code><code class="p">,</code> <code class="nx">args</code><code class="p">))</code> <code class="p">{</code>
      <code class="nx">lastResult</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
      <code class="nx">lastArgs</code> <code class="o">=</code> <code class="nx">args</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="kd">return</code> <code class="nx">lastResult</code><code class="p">;</code>
  <code class="p">};</code>
<code class="p">}</code></pre>

<p class="author1">The error makes sense: TypeScript has no reason to believe that this very loose function has any relation to <code class="calibre18">T</code>. But you know that the type system will enforce that it’s called with the right parameters and that its return value is given the correct type. So you shouldn’t expect too many problems if you add a type assertion here:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">cacheLast</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nb">Function</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">fn</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">let</code> <code class="nx">lastArgs</code>: <code class="nx">any</code><code class="p">[]</code><code class="o">|</code><code class="nx">null</code><code class="o"> = </code><code class="kd">null</code><code class="p">;</code>
  <code class="kd">let</code> <code class="nx">lastResult</code>: <code class="nx">any</code><code class="p">;</code>
  <code class="kd">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code>: <code class="nx">any</code><code class="p">[])</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">lastArgs</code> <code class="o">||</code> <code class="o">!</code><code class="nx">shallowEqual</code><code class="p">(</code><code class="nx">lastArgs</code><code class="p">,</code> <code class="nx">args</code><code class="p">))</code> <code class="p">{</code>
      <code class="nx">lastResult</code> <code class="o">=</code> <code class="nx">fn</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>
      <code class="nx">lastArgs</code> <code class="o">=</code> <code class="nx">args</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="kd">return</code> <code class="nx">lastResult</code><code class="p">;</code>
  <code class="p">}</code> <code class="kd">as</code> <code class="nx">unknown</code> <code class="kd">as</code> <code class="nx">T</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">And indeed this will work great for any simple function you pass it. There are quite a few <code class="calibre18">any</code> types hidden in this implementation, but you’ve kept them out of the type signature, so the code that calls <code class="calibre18">cacheLast</code> will be none the wiser.</p>

<p class="author1">(Is this actually safe? There are a few real problems with this implementation: it doesn’t check that the values of <code class="calibre18">this</code> for successive calls are the same. And if the original function had properties defined on it, then the wrapped function would not have these, so it wouldn’t have the same type. But if you know that these situations don’t come up in your code, this implementation is just fine. This function <em class="calibre3">can</em> be written in a type-safe way, but it is a more complex exercise that is left to the reader.)</p>

<p class="author1">The <code class="calibre18">shallowEqual</code> function from the previous example operated on two arrays and is easy to type and implement. But the object variation is more interesting. As with <code class="calibre18">cacheLast</code>, it’s easy to write its type signature:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">function</code> <code class="nx">shallowObjectEqual</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code><code class="p">;</code></pre>

<p class="author1">The<a data-primary="Object.keys" data-type="indexterm" id="idm45331651991880" class="calibre9"/> implementation requires some care since there’s no guarantee that <code class="calibre18">a</code> and <code class="calibre18">b</code> have the same keys (see <a href="ch07.html#iterate-objects" class="calibre9">Item 54</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">shallowObjectEqual</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">aVal</code><code class="p">]</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">a</code><code class="p">))</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">b</code><code class="p">)</code> <code class="o">||</code> <code class="nx">aVal</code> <code class="o">!==</code> <code class="nx">b</code><code class="p">[</code><code class="nx">k</code><code class="p">])</code> <code class="p">{</code>
                           <code class="c">// ~~~~ Element implicitly has an 'any' type</code>
                           <code class="c">//      because type '{}' has no index signature</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">a</code><code class="p">).</code><code class="nx">length</code> <code class="o">===</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">b</code><code class="p">).</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">It’s a bit surprising that TypeScript complains about the <code class="calibre18">b[k]</code> access despite your having just checked that <code class="calibre18">k in b</code> is true. But it does, so you have no choice but to cast:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">shallowObjectEqual</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kd">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">a</code>: <code class="nx">T</code><code class="p">,</code> <code class="nx">b</code>: <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="kd">boolean</code> <code class="p">{</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">const</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">aVal</code><code class="p">]</code> <code class="nx">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">a</code><code class="p">))</code> <code class="p">{</code>
    <code class="kd">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">k</code> <code class="kd">in</code> <code class="nx">b</code><code class="p">)</code> <code class="o">||</code> <code class="nx">aVal</code> <code class="o">!==</code> <code class="p">(</code><code class="nx">b</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">)[</code><code class="nx">k</code><code class="p">])</code> <code class="p">{</code>
      <code class="kd">return</code> <code class="kd">false</code><code class="p">;</code>
    <code class="p">}</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">a</code><code class="p">).</code><code class="nx">length</code> <code class="o">===</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">b</code><code class="p">).</code><code class="nx">length</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">This type assertion is harmless (since you’ve checked <code class="calibre18">k in b</code>), and you’re left with a correct function with a clear type signature. This is much preferable to scattering iteration and assertions to check for object equality throughout your code!</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331651848984">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Sometimes unsafe type assertions are necessary or expedient. When you need to use one, hide it inside a function with a correct signature.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 41: Understand Evolving any" data-type="sect1" class="praise"><div class="praise" id="evolving-any">
<h1 class="calibre16">Item 41: Understand Evolving any</h1>

<p class="author1">In<a data-primary="evolving any" data-type="indexterm" id="evolany05" class="calibre9"/><a data-primary="any[ ] types" data-type="indexterm" id="anysquare05" class="calibre9"/><a data-primary="any types" data-secondary="evolving" data-type="indexterm" id="ATevolv05" class="calibre9"/><a data-primary="type annotations" data-secondary="using explicit with any types" data-type="indexterm" id="TAexplicitany05" class="calibre9"/> TypeScript a variable’s type is generally determined when it is declared. After this, it can be <em class="calibre3">refined</em> (by checking if it is <code class="calibre18">null</code>, for instance), but it cannot expand to include new values. There is one notable exception to this, however, involving <code class="calibre18">any</code> types.</p>

<p class="author1">In JavaScript, you might write a function to generate a range of numbers like this:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">limit</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">limit</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">When you convert this to TypeScript, it works exactly as you’d expect:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">start</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">limit</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">limit</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>  <code class="c">// Return type inferred as number[]</code>
<code class="p">}</code></pre>

<p class="author1">Upon closer inspection, however, it’s surprising that this works! How does TypeScript know that the type of <code class="calibre18">out</code> is <code class="calibre18">number[]</code> when it’s initialized as <code class="calibre18">[]</code>, which could be an array of any type?</p>

<p class="author1">Inspecting each of the three occurrences of <code class="calibre18">out</code> to reveal its inferred type starts to tell the story:</p>

<pre data-code-language="ts" data-type="programlisting" id="type-safe-range" class="calibre17"><code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">start</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">limit</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>  <code class="c">// Type is any[]</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">limit</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>  <code class="c">// Type of out is any[]</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>  <code class="c">// Type is number[]</code>
<code class="p">}</code></pre>

<p class="author1">The type of <code class="calibre18">out</code> starts as <code class="calibre18">any[]</code>, an undifferentiated array. But as we push <code class="calibre18">number</code> values onto it, its type “evolves” to become <code class="calibre18">number[]</code>.</p>

<p class="author1">This is distinct from narrowing (<a href="ch03.html#narrowing" class="calibre9">Item 22</a>). An array’s type can expand by pushing different elements onto it:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">[];</code>  <code class="c">// Type is any[]</code>
<code class="nx">result</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s">'a'</code><code class="p">);</code>
<code class="nx">result</code>  <code class="c">// Type is string[]</code>
<code class="nx">result</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>
<code class="nx">result</code>  <code class="c">// Type is (string | number)[]</code></pre>

<p class="author1">With conditionals, the type can even vary across branches. Here we show the same behavior with a simple value, rather than an array:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">val</code><code class="p">;</code>  <code class="c">// Type is any</code>
<code class="kd">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="sr">/hello/</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is RegExp</code>
<code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is number</code>
<code class="p">}</code>
<code class="nx">val</code>  <code class="c">// Type is number | RegExp</code></pre>

<p class="author1">A final case that triggers this “evolving any” behavior is if a variable is initially <code class="calibre18">null</code>. This often comes up when you set a value in a <code class="calibre18">try</code>/<code class="calibre18">catch</code> block:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">val</code> <code class="o">=</code> <code class="kd">null</code><code class="p">;</code>  <code class="c">// Type is any</code>
<code class="kd">try</code> <code class="p">{</code>
  <code class="nx">somethingDangerous</code><code class="p">();</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is number</code>
<code class="p">}</code> <code class="kd">catch</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">warn</code><code class="p">(</code><code class="s">'alas!'</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">val</code>  <code class="c">// Type is number | null</code></pre>

<p class="author1">Interestingly, this behavior only happens when a variable’s type is implicitly <code class="calibre18">any</code> with <code class="calibre18">noImplicitAny</code> set! Adding an <em class="calibre3">explicit</em> <code class="calibre18">any</code> keeps the type constant:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">let</code> <code class="nx">val</code>: <code class="nx">any</code><code class="p">;</code>  <code class="c">// Type is any</code>
<code class="kd">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mi">0.5</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="sr">/hello/</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is any</code>
<code class="p">}</code> <code class="kd">else</code> <code class="p">{</code>
  <code class="nx">val</code> <code class="o">=</code> <code class="mi">12</code><code class="p">;</code>
  <code class="nx">val</code>  <code class="c">// Type is any</code>
<code class="p">}</code>
<code class="nx">val</code>  <code class="c">// Type is any</code></pre>
<div data-type="note" epub:type="note" class="calibre24"><h6 class="calibre25">Note</h6>
<p class="author1">This behavior can be confusing to follow in your editor since the type is only “evolved” <em class="calibre3">after</em> you assign or push an element. Inspecting the type on the line with the assignment will still show <code class="calibre18">any</code> or <code class="calibre18">any[]</code>.</p>
</div>

<p class="author1">If you use a value before any assignment to it, you’ll get an implicit any error:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">start</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">limit</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>
  <code class="c">//    ~~~ Variable 'out' implicitly has type 'any[]' in some</code>
  <code class="c">//        locations where its type cannot be determined</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">start</code> <code class="o">===</code> <code class="nx">limit</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>
    <code class="c">//     ~~~ Variable 'out' implicitly has an 'any[]' type</code>
  <code class="p">}</code>
  <code class="kd">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">limit</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
  <code class="p">}</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">Put another way, “evolving” <code class="calibre18">any</code> types are only <code class="calibre18">any</code> when you <em class="calibre3">write</em> to them. If you try to <em class="calibre3">read</em> from them while they’re still <code class="calibre18">any</code>, you’ll get an error.</p>

<p class="author1">Implicit <code class="calibre18">any</code> types do not evolve through function calls. The arrow function here trips up inference:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">makeSquares</code><code class="p">(</code><code class="nx">start</code>: <code class="nx">number</code><code class="p">,</code> <code class="nx">limit</code>: <code class="nx">number</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">const</code> <code class="nx">out</code> <code class="o">=</code> <code class="p">[];</code>
     <code class="c">// ~~~ Variable 'out' implicitly has type 'any[]' in some locations</code>
  <code class="nx">range</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">limit</code><code class="p">).</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">i</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="nx">out</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">i</code> <code class="o">*</code> <code class="nx">i</code><code class="p">);</code>
  <code class="p">});</code>
  <code class="kd">return</code> <code class="nx">out</code><code class="p">;</code>
      <code class="c">// ~~~ Variable 'out' implicitly has an 'any[]' type</code>
<code class="p">}</code></pre>

<p class="author1">In cases like this, you may want to consider using an array’s <code class="calibre18">map</code> and <code class="calibre18">filter</code> methods to build arrays in a single statement and avoid iteration and evolving <code class="calibre18">any</code> entirely. See Items <a href="ch03.html#all-at-once" class="calibre9">23</a> and <a href="ch03.html#well-typed-libs" class="calibre9">27</a>.</p>

<p class="author1">Evolving <code class="calibre18">any</code> comes with all the usual caveats about type inference. Is the correct type for your array really <code class="calibre18">(string|number)[]</code>? Or should it be <code class="calibre18">number[]</code> and you incorrectly pushed a <code class="calibre18">string</code>? You may still want to provide an explicit type annotation to get better error checking instead of using evolving <code class="calibre18">any</code>.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331651069640">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">While TypeScript types typically only <em class="calibre3">refine</em>, implicit <code class="calibre18">any</code> and <code class="calibre18">any[]</code> types are allowed to <em class="calibre3">evolve</em>. You should be able to recognize and understand this construct where it occurs.</p>
</li>
<li class="calibre12">
<p class="author1">For better error checking, consider providing an explicit type annotation instead of using evolving <code class="calibre18">any</code>.<a data-primary="" data-startref="TAexplicitany05" data-type="indexterm" id="idm45331651064216" class="calibre9"/><a data-primary="" data-startref="ATevolv05" data-type="indexterm" id="idm45331651063208" class="calibre9"/><a data-primary="" data-startref="anysquare05" data-type="indexterm" id="idm45331651062264" class="calibre9"/><a data-primary="" data-startref="evolany05" data-type="indexterm" id="idm45331651061320" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 42: Use unknown Instead of any for Values with an Unknown Type" data-type="sect1" class="praise"><div class="praise" id="never-unknown">
<h1 class="calibre16">Item 42: Use unknown Instead of any for Values with an Unknown Type</h1>

<p class="author1">Suppose<a data-primary="any types" data-secondary="unknown versus any types" data-type="indexterm" id="ATunknow05" class="calibre9"/><a data-primary="unknown types" data-secondary="unknown versus any types" data-type="indexterm" id="UTunknown05" class="calibre9"/><a data-primary="{ } type" data-type="indexterm" id="curlytype05" class="calibre9"/><a data-primary="object type" data-type="indexterm" id="obj05" class="calibre9"/><a data-primary="values" data-secondary="with unknown types" data-secondary-sortas="unknown types" data-type="indexterm" id="Vunk05" class="calibre9"/> you want to write a<a data-primary="YAML" data-type="indexterm" id="idm45331651051848" class="calibre9"/> YAML parser (YAML can represent the same set of values as<a data-primary="JSON" data-type="indexterm" id="idm45331651051016" class="calibre9"/> JSON but allows a superset of JSON’s syntax). What should the return type of your <code class="calibre18">parseYAML</code> method be? It’s tempting to make it <code class="calibre18">any</code> (like <code class="calibre18">JSON.parse</code>):</p>

<pre data-code-language="ts" data-type="programlisting" id="parse-yaml-definition" class="calibre17"><code class="kd">function</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="nx">yaml</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">any</code> <code class="p">{</code>
  <code class="c">// ...</code>
<code class="p">}</code></pre>

<p class="author1">But this flies in the face of <a href="#narrowest-any" class="calibre9">Item 38</a>’s advice to avoid “contagious” <code class="calibre18">any</code> types, specifically by not returning them from functions.</p>

<p class="author1">Ideally you’d like your users to immediately assign the result to another type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Book</code> <code class="p">{</code>
  <code class="nx">name</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="nx">author</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">book</code>: <code class="nx">Book</code> <code class="o">=</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="s">`</code>
<code class="s">  name: Wuthering Heights</code>
<code class="s">  author: Emily Brontë</code>
<code class="s">`</code><code class="p">);</code></pre>

<p class="author1">Without the type declarations, though, the <code class="calibre18">book</code> variable would quietly get an <code class="calibre18">any</code> type, thwarting type checking wherever it’s used:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">book</code> <code class="o">=</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="s">`</code>
<code class="s">  name: Jane Eyre</code>
<code class="s">  author: Charlotte Brontë</code>
<code class="s">`</code><code class="p">);</code>
<code class="nx">alert</code><code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>  <code class="c">// No error, alerts "undefined" at runtime</code>
<code class="nx">book</code><code class="p">(</code><code class="s">'read'</code><code class="p">);</code>  <code class="c">// No error, throws "TypeError: book is not a</code>
               <code class="c">// function" at runtime</code></pre>

<p class="author1">A safer alternative would be to have <code class="calibre18">parseYAML</code> return an <code class="calibre18">unknown</code> type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">safeParseYAML</code><code class="p">(</code><code class="nx">yaml</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">unknown</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="nx">yaml</code><code class="p">);</code>
<code class="p">}</code>
<code class="kd">const</code> <code class="nx">book</code> <code class="o">=</code> <code class="nx">safeParseYAML</code><code class="p">(</code><code class="s">`</code>
<code class="s">  name: The Tenant of Wildfell Hall</code>
<code class="s">  author: Anne Brontë</code>
<code class="s">`</code><code class="p">);</code>
<code class="nx">alert</code><code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>
   <code class="c">// ~~~~ Object is of type 'unknown'</code>
<code class="nx">book</code><code class="p">(</code><code class="s">"read"</code><code class="p">);</code>
<code class="c">// ~~~~~~~~~~ Object is of type 'unknown'</code></pre>

<p class="author1">To understand the <code class="calibre18">unknown</code> type, it helps to think about <code class="calibre18">any</code> in terms of assignability. The power and danger of <code class="calibre18">any</code> come from two properties:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">Any type is assignable to the <code class="calibre18">any</code> type.</p>
</li>
<li class="calibre12">
<p class="author1">The <code class="calibre18">any</code> type is assignable to any other type.<sup class="calibre44"><a data-type="noteref" href="ch05.html#idm45331650850072" id="idm45331650850072-marker" class="calibre45">2</a></sup></p>
</li>
</ul>

<p class="author1">In the context of “thinking of types as sets of values” (<a href="ch02_split_000.html#types-as-sets" class="calibre9">Item 7</a>), <code class="calibre18">any</code> clearly doesn’t fit into the type system, since a set can’t simultaneously be both a subset and a superset of all other sets. This is the source of <code class="calibre18">any</code>’s power but also the reason it’s problematic. Since the type checker is set-based, the use of <code class="calibre18">any</code> effectively disables it.</p>

<p class="author1">The <code class="calibre18">unknown</code> type is an alternative to <code class="calibre18">any</code> that <em class="calibre3">does</em> fit into the type system. It has the first property (any type is assignable to <code class="calibre18">unknown</code>) but not the second (<code class="calibre18">unknown</code> is only assignable to <code class="calibre18">unknown</code> and, of course, <code class="calibre18">any</code>). The<a data-primary="never type" data-type="indexterm" id="idm45331650842216" class="calibre9"/> <code class="calibre18">never</code> type is the opposite: it has the second property (can be assigned to any other type) but not the first (nothing can be assigned to <code class="calibre18">never</code>).</p>

<p class="author1">Attempting to access a property on a value with the <code class="calibre18">unknown</code> type is an error. So is attempting to call it or do arithmetic with it. You can’t do much with <code class="calibre18">unknown</code>, which is exactly the point. The errors about an <code class="calibre18">unknown</code> type will encourage you to add an appropriate type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">book</code> <code class="o">=</code> <code class="nx">safeParseYAML</code><code class="p">(</code><code class="s">`</code>
<code class="s">  name: Villette</code>
<code class="s">  author: Charlotte Brontë</code>
<code class="s">`</code><code class="p">)</code> <code class="kd">as</code> <code class="nx">Book</code><code class="p">;</code>
<code class="nx">alert</code><code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">title</code><code class="p">);</code>
        <code class="c">// ~~~~~ Property 'title' does not exist on type 'Book'</code>
<code class="nx">book</code><code class="p">(</code><code class="s">'read'</code><code class="p">);</code>
<code class="c">// ~~~~~~~~~ this expression is not callable</code></pre>

<p class="author1">These errors are more sensible. Since <code class="calibre18">unknown</code> is not assignable to other types, a type assertion is required. But it is also appropriate: we really do know more about the type of the resulting object than TypeScript does.</p>

<p class="author1"><code class="calibre18">unknown</code> is appropriate whenever you know that there will be a value but you don’t know its type. The result of <code class="calibre18">parseYAML</code> is one example, but there are others. In<a data-primary="GeoJSON" data-type="indexterm" id="idm45331650817992" class="calibre9"/> the GeoJSON spec, for example, the <code class="calibre18">properties</code> property of a Feature is a grab-bag of anything<a data-primary="JSON" data-type="indexterm" id="idm45331650781544" class="calibre9"/><a data-primary="Geometry" data-type="indexterm" id="idm45331650780840" class="calibre9"/> JSON serializable. So <code class="calibre18">unknown</code> makes sense:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Feature</code> <code class="p">{</code>
  <code class="nx">id?</code>: <code class="kd">string</code> <code class="o">|</code> <code class="kt">number</code><code class="p">;</code>
  <code class="nx">geometry</code>: <code class="nx">Geometry</code><code class="p">;</code>
  <code class="nx">properties</code>: <code class="nx">unknown</code><code class="p">;</code>
<code class="p">}</code></pre>

<p class="author1">A type assertion isn’t the only way to recover a type from an <code class="calibre18">unknown</code> object. An <code class="calibre18">instanceof</code> check will do:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">processValue</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">val</code> <code class="kd">instanceof</code> <code class="nb">Date</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">val</code>  <code class="c">// Type is Date</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">You can also use a user-defined type guard:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">isBook</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">unknown</code><code class="p">)</code><code class="o">:</code> <code class="nx">val</code> <code class="nx">is</code> <code class="nx">Book</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="p">(</code>
      <code class="kd">typeof</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="o">===</code> <code class="s">'object'</code> <code class="o">&amp;&amp;</code> <code class="nx">val</code> <code class="o">!==</code> <code class="kd">null</code> <code class="o">&amp;&amp;</code>
      <code class="s">'name'</code> <code class="kd">in</code> <code class="nx">val</code> <code class="o">&amp;&amp;</code> <code class="s">'author'</code> <code class="kd">in</code> <code class="nx">val</code>
  <code class="p">);</code>
<code class="p">}</code>
<code class="kd">function</code> <code class="nx">processValue</code><code class="p">(</code><code class="nx">val</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
  <code class="kd">if</code> <code class="p">(</code><code class="nx">isBook</code><code class="p">(</code><code class="nx">val</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">val</code><code class="p">;</code>  <code class="c">// Type is Book</code>
  <code class="p">}</code>
<code class="p">}</code></pre>

<p class="author1">TypeScript requires quite a bit of proof to narrow an <code class="calibre18">unknown</code> type: in order to avoid errors on the <code class="calibre18">in</code> checks, you first have to demonstrate that <code class="calibre18">val</code> is an object type and that it is non-<code class="calibre18">null</code> (since <code class="calibre18">typeof null === 'object'</code>).</p>

<p class="author1">You’ll sometimes see a generic parameter used instead of <code class="calibre18">unknown</code>. You could have declared the <code class="calibre18">safeParseYAML</code> function this way:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">safeParseYAML</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">yaml</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">parseYAML</code><code class="p">(</code><code class="nx">yaml</code><code class="p">);</code>
<code class="p">}</code></pre>

<p class="author1">This is generally considered bad style in TypeScript, however. It looks different than a type assertion, but is functionally the same. Better to just return <code class="calibre18">unknown</code> and force your users to use an assertion or narrow to the type they want.</p>

<p class="author1"><code class="calibre18">unknown</code> can<a data-primary="double assertion" data-type="indexterm" id="idm45331650587176" class="calibre9"/> also be used instead of <code class="calibre18">any</code> in “double assertions”:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="kd">const</code> <code class="nx">foo</code>: <code class="nx">Foo</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">barAny</code> <code class="o">=</code> <code class="nx">foo</code> <code class="kd">as</code> <code class="nx">any</code> <code class="kd">as</code> <code class="nx">Bar</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">barUnk</code> <code class="o">=</code> <code class="nx">foo</code> <code class="kd">as</code> <code class="nx">unknown</code> <code class="kd">as</code> <code class="nx">Bar</code><code class="p">;</code></pre>

<p class="author1">These are functionally equivalent, but the <code class="calibre18">unknown</code> form has less risk if you do a refactor and break up the two assertions. In that case the <code class="calibre18">any</code> could escape and spread. If the <code class="calibre18">unknown</code> type escapes, it will probably just produce an error.</p>

<p class="author1">As a final note, you may see code that uses <code class="calibre18">object</code> or <code class="calibre18">{}</code> in a similar way to how <code class="calibre18">unknown</code> has been described in this item. They are also broad types but are slightly narrower than <code class="calibre18">unknown</code>:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">The <code class="calibre18">{}</code> type consists of all values except <code class="calibre18">null</code> and <code class="calibre18">undefined</code>.</p>
</li>
<li class="calibre12">
<p class="author1">The <code class="calibre18">object</code> type consists of all non-primitive types. This doesn’t include <code class="calibre18">true</code> or <code class="calibre18">12</code> or <code class="calibre18">"foo"</code> but does include objects and arrays.</p>
</li>
</ul>

<p class="author1">The use of <code class="calibre18">{}</code> was more common before the <code class="calibre18">unknown</code> type was introduced. Uses today are somewhat rare: only use <code class="calibre18">{}</code> instead of <code class="calibre18">unknown</code> if you really do know that <code class="calibre18">null</code> and <code class="calibre18">undefined</code> aren’t possibilities.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331650499176">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">The <code class="calibre18">unknown</code> type is a type-safe alternative to <code class="calibre18">any</code>. Use it when you know you have a value but do not know what its type is.</p>
</li>
<li class="calibre12">
<p class="author1">Use <code class="calibre18">unknown</code> to force your users to use a type assertion or do type checking.</p>
</li>
<li class="calibre12">
<p class="author1">Understand the difference between <code class="calibre18">{}</code>, <code class="calibre18">object</code>, and <code class="calibre18">unknown</code>.<a data-primary="" data-startref="Vunk05" data-type="indexterm" id="idm45331650492360" class="calibre9"/><a data-primary="" data-startref="obj05" data-type="indexterm" id="idm45331650491352" class="calibre9"/><a data-primary="" data-startref="curlytype05" data-type="indexterm" id="idm45331650490408" class="calibre9"/><a data-primary="" data-startref="UTunknown05" data-type="indexterm" id="idm45331650489464" class="calibre9"/><a data-primary="" data-startref="ATunknow05" data-type="indexterm" id="idm45331650488520" class="calibre9"/></p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 43: Prefer Type-Safe Approaches to Monkey Patching" data-type="sect1" class="praise"><div class="praise" id="type-safe-monkey">
<h1 class="calibre16">Item 43: Prefer Type-Safe Approaches to Monkey Patching</h1>

<p class="author1">One<a data-primary="any types" data-secondary="type-safe approaches versus monkey-patching" data-type="indexterm" id="idm45331650455416" class="calibre9"/><a data-primary="global variables" data-type="indexterm" id="idm45331650454440" class="calibre9"/><a data-primary="built-in types, storing data on" data-type="indexterm" id="idm45331650453736" class="calibre9"/><a data-primary="augmentation" data-type="indexterm" id="idm45331650453096" class="calibre9"/><a data-primary="declaration merging" data-type="indexterm" id="idm45331650452424" class="calibre9"/><a data-primary="JavaScript" data-secondary="open classes in" data-type="indexterm" id="idm45331650451752" class="calibre9"/><a data-primary="type safety" data-secondary="type-safe approaches versus monkey-patching" data-type="indexterm" id="idm45331650450808" class="calibre9"/><a data-primary="properties" data-secondary="attaching to built-in types" data-type="indexterm" id="idm45331650449832" class="calibre9"/> of the most famous features of JavaScript is that its objects and classes are “open” in the sense that you can add arbitrary properties to them. This is occasionally used to create global variables on web pages by assigning to <code class="calibre18">window</code> or <code class="calibre18">document</code>:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="nb">window</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Howler'</code><code class="p">;</code></pre>

<p class="author1">or to attach data to DOM elements:</p>

<pre data-code-language="js" data-type="programlisting" class="calibre17"><code class="kd">const</code> <code class="nx">el</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s">'colobus'</code><code class="p">);</code>
<code class="nx">el</code><code class="p">.</code><code class="nx">home</code> <code class="o">=</code> <code class="s">'tree'</code><code class="p">;</code></pre>

<p class="author1">This<a data-primary="jQuery" data-secondary="type-safe approaches versus monkey-patching" data-type="indexterm" id="idm45331650422184" class="calibre9"/> style is particularly common with code that uses jQuery.</p>

<p class="author1">You can even attach properties to the prototypes of built-ins, with sometimes surprising results:</p>
<pre data-code-language="javascript" data-type="programlisting" class="calibre17"><code class="o">&gt;</code><code class="calibre18"> </code><strong class="calibre32"><code class="calibre22"> </code><code class="nb1">RegExp</code><code class="p1">.</code><code class="nx1">prototype</code><code class="p1">.</code><code class="nx1">monkey</code><code class="calibre22"> </code><code class="o1">=</code><code class="calibre22"> </code><code class="s1">'Capuchin'</code></strong><code class="calibre18">
</code><code class="s">"Capuchin"</code><code class="calibre18">
</code><code class="o">&gt;</code><code class="calibre18"> </code><strong class="calibre32"><code class="sr1">/123/</code><code class="p1">.</code><code class="nx1">monkey</code></strong><code class="calibre18">
</code><code class="s">"Capuchin"</code></pre>

<p class="author1">These approaches are generally not good designs. When you attach data to <code class="calibre18">window</code> or a DOM node, you are essentially turning it into a global variable. This makes it easy to inadvertently introduce dependencies between far-flung parts of your program and means that you have to think about side effects whenever you call a function.</p>

<p class="author1">Adding TypeScript introduces another problem: while the type checker knows about built-in properties of <code class="calibre18">Document</code> and <code class="calibre18">HTMLElement</code>, it certainly doesn’t know about the ones you’ve added:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="nb">document</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>
      <code class="c">// ~~~~~~ Property 'monkey' does not exist on type 'Document'</code></pre>

<p class="author1">The most straightforward way to fix this error is with an <code class="calibre18">any</code> assertion:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="p">(</code><code class="nb">document</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">).</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">This satisfies the type checker, but, as should be no surprise by now, it has some downsides. As with any use of <code class="calibre18">any</code>, you lose type safety and language services:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="p">(</code><code class="nb">document</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">).</code><code class="nx">monky</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>  <code class="c">// Also OK, misspelled</code>
<code class="p">(</code><code class="nb">document</code> <code class="kd">as</code> <code class="nx">any</code><code class="p">).</code><code class="nx">monkey</code> <code class="o">=</code> <code class="sr">/Tamarin/</code><code class="p">;</code>  <code class="c">// Also OK, wrong type</code></pre>

<p class="author1">The best solution is to move your data out of <code class="calibre18">document</code> or the DOM. But if you can’t (perhaps you’re using a library that requires it or are in the process of migrating a JavaScript application), then you have a few next-best options available.</p>

<p class="author1">One is to use an augmentation, one of the special abilities of <code class="calibre18">interface</code> (<a href="ch02_split_001.html#type-vs-interface" class="calibre9">Item 13</a>):</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">Document</code> <code class="p">{</code>
  <code class="c">/** Genus or species of monkey patch */</code>
  <code class="nx">monkey</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="nb">document</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">This is an improvement over using <code class="calibre18">any</code> in a few ways:</p>

<ul class="printings">
<li class="calibre12">
<p class="author1">You get type safety. The type checker will flag misspellings or assignments of the wrong type.</p>
</li>
<li class="calibre12">
<p class="author1">You can attach documentation to the property (<a href="ch06.html#use-tsdoc" class="calibre9">Item 48</a>).</p>
</li>
<li class="calibre12">
<p class="author1">You get autocomplete on the property.</p>
</li>
<li class="calibre12">
<p class="author1">There is a record of precisely what the monkey patch is.</p>
</li>
</ul>

<p class="author1">In a module context (i.e., a TypeScript file that uses <code class="calibre18">import</code> / <code class="calibre18">export</code>), you’ll need to add a <code class="calibre18">declare global</code> to make this work:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">export</code> <code class="p">{};</code>
<code class="kd">declare</code> <code class="nx">global</code> <code class="p">{</code>
  <code class="kd">interface</code> <code class="nx">Document</code> <code class="p">{</code>
    <code class="c">/** Genus or species of monkey patch */</code>
    <code class="nx">monkey</code>: <code class="kd">string</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">}</code>
<code class="nb">document</code><code class="p">.</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Tamarin'</code><code class="p">;</code>  <code class="c">// OK</code></pre>

<p class="author1">The main issues with using an augmentation have to do with scope. First, the augmentation applies globally. You can’t hide it from other parts of your code or from libraries. And second, if you assign the property while your application is running, there’s no way to introduce the augmentation only after this has happened. This is particularly problematic when you patch HTML Elements, where some elements on the page will have the property and some will not. For this reason, you might want to declare the property to be <code class="calibre18">string|undefined</code>. This is more accurate, but will make the type less convenient to work with.</p>

<p class="author1">Another approach is to use a more precise type assertion:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">interface</code> <code class="nx">MonkeyDocument</code> <code class="kd">extends</code> <code class="nx">Document</code> <code class="p">{</code>
  <code class="c">/** Genus or species of monkey patch */</code>
  <code class="nx">monkey</code>: <code class="kd">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="p">(</code><code class="nb">document</code> <code class="kd">as</code> <code class="nx">MonkeyDocument</code><code class="p">).</code><code class="nx">monkey</code> <code class="o">=</code> <code class="s">'Macaque'</code><code class="p">;</code></pre>

<p class="author1">TypeScript is OK with the type assertion because <code class="calibre18">Document</code> and <code class="calibre18">MonkeyDocument</code> share properties (<a href="ch02_split_000.html#prefer-declarations-to-assertions" class="calibre9">Item 9</a>). And you get type safety in the assignment. The scope issues are also more manageable: there’s no global modification of the <code class="calibre18">Document</code> type, just the introduction of a new type (which is only in scope if you import it). You have to write an assertion (or introduce a new variable) whenever you reference the monkey-patched property. But you can take that as encouragement to refactor into something more structured. Monkey patching shouldn’t be <em class="calibre3">too</em> easy!</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331650096872">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Prefer structured code to storing data in globals or on the DOM.</p>
</li>
<li class="calibre12">
<p class="author1">If you must store data on built-in types, use one of the type-safe approaches (augmentation or asserting a custom interface).</p>
</li>
<li class="calibre12">
<p class="author1">Understand the scoping issues of augmentations.</p>
</li>
</ul>
</div></section>





</div></section>













<section data-pdf-bookmark="Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety" data-type="sect1" class="praise"><div class="praise" id="type-percentage">
<h1 class="calibre16">Item 44: Track Your Type Coverage to Prevent Regressions in Type Safety</h1>

<p class="author1">Are<a data-primary="any types" data-secondary="preventing regressions in type safety" data-type="indexterm" id="idm45331650090072" class="calibre9"/><a data-primary="type safety" data-secondary="preventing regressions in" data-type="indexterm" id="idm45331650089096" class="calibre9"/><a data-primary="noImplicitAny" data-type="indexterm" id="idm45331650088184" class="calibre9"/><a data-primary="@types (type dependencies)" data-secondary="preventing regressions in type safety" data-type="indexterm" id="idm45331650087512" class="calibre9"/><a data-primary="third-party type declarations" data-type="indexterm" id="idm45331650086632" class="calibre9"/><a data-primary="type declaration" data-secondary="third-party" data-type="indexterm" id="idm45331650085992" class="calibre9"/><a data-primary="any[ ] types" data-type="indexterm" id="idm45331650085048" class="calibre9"/><a data-primary="{[key: string]: any} type" data-type="indexterm" id="idm45331650084376" class="calibre9"/> you safe from the problems associated with any types once you’ve added type annotations for values with implicit <code class="calibre18">any</code> types and enabled <code class="calibre18">noImplicitAny</code>? The answer is “no”; <code class="calibre18">any</code> types can still enter your program in two main ways:</p>
<dl class="praise">
<dt class="calibre19"><em class="calibre3">Explicit</em> <code class="calibre18">any</code> types</dt>
<dd class="calibre20">
<p class="author1">Even if you follow the advice of Items <a href="#narrowest-any" class="calibre9">38</a> and <a href="#specific-any" class="calibre9">39</a>, making your <code class="calibre18">any</code> types both narrow and specific, they remain <code class="calibre18">any</code> types. In particular, types like <code class="calibre18">any[]</code> and <code class="calibre18">{[key: string]: any}</code> become plain <code class="calibre18">any</code>s once you index into them, and the resulting <code class="calibre18">any</code> types can flow through your code.</p>
</dd>
<dt class="calibre19">From third-party type declarations</dt>
<dd class="calibre20">
<p class="author1">This is particularly insidious since <code class="calibre18">any</code> types from an <code class="calibre18">@types</code> declaration file enter silently: even though you have <code class="calibre18">noImplicitAny</code> enabled and you never typed <code class="calibre18">any</code>, you still have <code class="calibre18">any</code> types flowing through your code.</p>
</dd>
</dl>

<p class="author1">Because of the negative effects <code class="calibre18">any</code> types can have on type safety and developer experience (<a href="ch01.html#any" class="calibre9">Item 5</a>), it’s a good idea to keep track of the number of them in your codebase. There are many ways to do this, including the <code class="calibre18">type-coverage</code> package on npm:</p>

<pre data-type="programlisting" class="calibre17">$ npx type-coverage
9985 / 10117 98.69%</pre>

<p class="author1">This means that, of the 10,117 symbols in this project, 9,985 (98.69%) had a type other than <code class="calibre18">any</code> or an alias to <code class="calibre18">any</code>. If a change inadvertently introduces an <code class="calibre18">any</code> type and it flows through your code, you’ll see a corresponding drop in this percentage.</p>

<p class="author1">In some ways this percentage is a way of keeping score on how well you’ve followed the advice of the other items in this chapter. Using narrowly scoped <code class="calibre18">any</code> will reduce the number of symbols with <code class="calibre18">any</code> types, and so will using more specific forms like <code class="calibre18">any[]</code>. Tracking this numerically helps you make sure things only get better over time.</p>

<p class="author1">Even collecting type coverage information once can be informative. Running <code class="calibre18">type-coverage</code> with the <code class="calibre18">--detail</code> flag will print where every <code class="calibre18">any</code> type occurs in your code:</p>

<pre data-type="programlisting" class="calibre17">$ npx type-coverage --detail
path/to/code.ts:1:10 getColumnInfo
path/to/module.ts:7:1 pt2
...</pre>

<p class="author1">These are worth investigating because they’re likely to turn up sources of <code class="calibre18">any</code>s that you hadn’t considered. Let’s look at a few examples.</p>

<p class="author1">Explicit <code class="calibre18">any</code> types are often the result of choices you made for expediency earlier on. Perhaps you were getting a type error that you didn’t want to take the time to sort out. Or maybe the type was one that you hadn’t written out yet. Or you might have just been in a rush.</p>

<p class="author1">Type assertions with <code class="calibre18">any</code> can prevent types from flowing where they otherwise would. Perhaps you’ve built an application that works with tabular data and needed a single-parameter function that built up some kind of column description:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">function</code> <code class="nx">getColumnInfo</code><code class="p">(</code><code class="nx">name</code>: <code class="kd">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">any</code> <code class="p">{</code>
  <code class="kd">return</code> <code class="nx">utils</code><code class="p">.</code><code class="nx">buildColumnInfo</code><code class="p">(</code><code class="nx">appState</code><code class="p">.</code><code class="nx">dataSchema</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>  <code class="c">// Returns any</code>
<code class="p">}</code></pre>

<p class="author1">The <code class="calibre18">utils.buildColumnInfo</code> function returned <code class="calibre18">any</code> at some point. As a reminder, you added a comment and an explicit “: any” annotation to the function.</p>

<p class="author1">However, in the intervening months you’ve also added a type for <code class="calibre18">ColumnInfo</code>, and <code class="calibre18">utils.buildColumnInfo</code> no longer returns <code class="calibre18">any</code>. The <code class="calibre18">any</code> annotation is now throwing away valuable type information. Get rid of it!</p>

<p class="author1">Third-party <code class="calibre18">any</code> types can come in a few forms, but the most extreme is when you give an entire module an <code class="calibre18">any</code> type:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">declare</code> <code class="nx">module</code> <code class="s">'my-module'</code><code class="p">;</code></pre>

<p class="author1">Now you can import anything from <code class="calibre18">my-module</code> without error. These symbols all have <code class="calibre18">any</code> types and will lead to more <code class="calibre18">any</code> types if you pass values through them:</p>

<pre data-code-language="ts" data-type="programlisting" class="calibre17"><code class="kd">import</code> <code class="p">{</code><code class="nx">someMethod</code><code class="p">,</code> <code class="nx">someSymbol</code><code class="p">}</code> <code class="nx">from</code> <code class="s">'my-module'</code><code class="p">;</code>  <code class="c">// OK</code>

<code class="kd">const</code> <code class="nx">pt1</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">x</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">y</code>: <code class="nx">2</code><code class="p">,</code>
<code class="p">};</code>  <code class="c">// type is {x: number, y: number}</code>
<code class="kd">const</code> <code class="nx">pt2</code> <code class="o">=</code> <code class="nx">someMethod</code><code class="p">(</code><code class="nx">pt1</code><code class="p">,</code> <code class="nx">someSymbol</code><code class="p">);</code>  <code class="c">// OK, pt2's type is any</code></pre>

<p class="author1">Since the usage looks identical to a well-typed module, it’s easy to forget that you stubbed out the module. Or maybe a coworker did it and you never knew in the first place. It’s worth revisiting these from time to time. Maybe there are official type declarations for the module. Or perhaps you’ve gained enough understanding of the module to write types yourself and contribute them back to the community.</p>

<p class="author1">Another common source of <code class="calibre18">any</code>s with third-party declarations is when there’s a bug in the types. Maybe the declarations didn’t follow the advice of <a href="ch04.html#loose-accept-strict-produce" class="calibre9">Item 29</a> and declared a function to return a union type when in fact it returns something much more specific. When you first used the function this didn’t seem worth fixing so you used an <code class="calibre18">any</code> assertion. But maybe the declarations have been fixed since then. Or maybe it’s time to fix them yourself!</p>

<p class="author1">The considerations that led you to use an <code class="calibre18">any</code> type might not apply any more. Maybe there’s a type you can plug in now where previously you used <code class="calibre18">any</code>. Maybe an unsafe type assertion is no longer necessary. Maybe the bug in the type declarations you were working around has been fixed. Tracking your type coverage highlights these choices and encourages you to keep revisiting them.</p>








<section class="praise" data-pdf-bookmark="Things to Remember" data-type="sect2"><div class="praise" id="idm45331649905240">
<h2 class="calibre31">Things to Remember</h2>

<ul class="printings">
<li class="calibre12">
<p class="author1">Even with <code class="calibre18">noImplicitAny</code> set, <code class="calibre18">any</code> types can make their way into your code either through explicit <code class="calibre18">any</code>s or third-party type declarations (<code class="calibre18">@types</code>).</p>
</li>
<li class="calibre12">
<p class="author1">Consider tracking how well-typed your program is. This will encourage you to revisit decisions about using <code class="calibre18">any</code> and increase type safety over time.</p>
</li>
</ul>
</div></section>





</div></section>







<div data-type="footnotes" class="calibre46"><p data-type="footnote" id="idm45331652259400" class="calibre47"><sup class="calibre48"><a href="ch05.html#idm45331652259400-marker" class="calibre45">1</a></sup> If you are using React, you should use the built-in <code class="calibre18">useMemo</code> hook, rather than rolling your own.</p><p data-type="footnote" id="idm45331650850072" class="calibre47"><sup class="calibre48"><a href="ch05.html#idm45331650850072-marker" class="calibre45">2</a></sup> With the exception of <code class="calibre18">never</code>.</p></div></div></section></body></html>