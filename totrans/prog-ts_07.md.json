["```\nfunction ask() {\n  return prompt('When is your birthday?')\n}\n\nfunction parse(birthday: string): Date {\n  return new Date(birthday)\n}\n\nlet date = parse(ask())\nconsole.info('Date is', date.toISOString())\n```", "```\n*`// ...`*\nfunction parse(birthday: string): Date `|` `null` {\n  `let` `date` `=` `new` `Date``(``birthday``)`\n  `if` `(``!``isValid``(``date``)``)` `{`\n    `return` `null`\n  `}`\n  return `date`\n}\n\n// *`Checks if the given date is valid`*\n`function` `isValid``(``date``:` `Date``)` `{`\n  `return` `Object``.``prototype``.``toString``.``call``(``date``)` `===` `'[object Date]'`\n      `&&` `!``Number``.``isNaN``(``date``.``getTime``(``)``)`\n`}`\n\n```", "```\n// ... let date = parse(ask())\n`if` `(``date``)` `{`\n  console.info('Date is', date.toISOString())\n`}` `else` `{`\n  `console``.``error``(``'Error parsing date for some reason'``)`\n`}`\n\n```", "```\n*`// ...`*\nfunction parse(birthday: string): `Date` {\n  let date = new Date(birthday)\n  if (!isValid(date)) {\n    `throw` `new` `RangeError``(``'Enter a date in the form YYYY/MM/DD'``)`\n  }\n  return date\n}\n\n```", "```\n*`// ...`*\n`try` `{`\n  let date = parse(ask())\n  console.info('Date is', date.toISOString())\n`}` `catch` `(``e``)` `{`\n  `console``.``error``(``e``.``message``)`\n`}`\n\n```", "```\n*`// ...`*\ntry {\n  let date = parse(ask())\n  console.info('Date is', date.toISOString())\n} catch (e) {\n  `if` `(``e` `instanceof` `RangeError``)` `{`\n    console.error(e.message)\n  `}` `else` `{`\n    `throw` `e`\n  `}`\n}\n\n```", "```\n*`// ...`*\n\n*`// Custom error types`* `class` `InvalidDateFormatError` `extends` `RangeError` `{``}`\n`class` `DateIsInTheFutureError` `extends` `RangeError` `{``}`\n\nfunction parse(birthday: string): Date {\n  let date = new Date(birthday)\n  if (!isValid(date)) {\n    throw `new` `InvalidDateFormatError`('Enter a date in the form YYYY/MM/DD')\n  }\n  `if` `(``date``.``getTime``(``)` `>` `Date``.``now``(``)``)` `{`\n    `throw` `new` `DateIsInTheFutureError``(``'Are you a timelord?'``)`\n  `}`\n  return date\n}\n\ntry {\n  let date = parse(ask())\n  console.info('Date is', date.toISOString())\n} catch (e) {\n  if (e instanceof `InvalidDateFormatError`) {\n    console.error(e.message)\n  } `else` `if` `(``e` `instanceof` `DateIsInTheFutureError``)` `{`\n    `console``.``info``(``e``.``message``)`\n  } else {\n    throw e\n  }\n}\n\n```", "```\n`/**  * @throws {InvalidDateFormatError} The user entered their birthday incorrectly.  * @throws {DateIsInTheFutureError} The user entered a birthday in the future.  */`\nfunction parse(birthday: string): Date {\n  *`// ...`*\n\n```", "```\n// ... function parse(\n  birthday: string\n): Date `|` `InvalidDateFormatError` `|` `DateIsInTheFutureError` {\n  let date = new Date(birthday)\n  if (!isValid(date)) {\n    `return` new InvalidDateFormatError('Enter a date in the form YYYY/MM/DD')\n  }\n  if (date.getTime() > Date.now()) {\n    `return` new DateIsInTheFutureError('Are you a timelord?')\n  }\n  return date\n}\n\n```", "```\n// ...\nlet result = parse(ask()) // Either a date or an error\nif (result instanceof InvalidDateFormatError) {\n  console.error(result.message)\n} else if (result instanceof DateIsInTheFutureError) {\n  console.info(result.message)\n} else {\n  console.info('Date is', result.toISOString())\n}\n```", "```\n*`// ...`*\nlet result = parse(ask()) // Either a date or an error if (result instanceof `Error`) {\n  console.error(result.message)\n} else {\n  console.info('Date is', result.toISOString())\n}\n\n```", "```\n    function x(): T | Error1 {\n      // ...\n    }\n    function y(): U | Error1 | Error2 {\n      let a = x()\n      if (a instanceof Error) {\n        return a\n      }\n      // Do something with a\n    }\n    function z(): U | Error1 | Error2 | Error3 {\n      let a = y()\n      if (a instanceof Error) {\n        return a\n      }\n      // Do something with a\n    }\n    ```", "```\n*`// ...`*\nfunction parse(birthday: string): `Date``[``]` {\n  let date = new Date(birthday)\n  if (!isValid(date)) {\n    `return` `[``]`\n  }\n  `return` `[``date``]`\n}\n\nlet date = parse(ask())\n`date`\n  `.``map``(``_` `=``>` `_``.``toISOString``(``)``)`\n  `.``forEach``(``_` `=``>` `console``.``info``(``'Date is'``,` `_``)``)`\n\n```", "```\nfunction ask() {\n  `let` `result` `=` prompt('When is your birthday?')\n  `if` `(``result` `===` `null``)` `{`\n    `return` `[``]`\n  `}`\n  `return` `[``result``]`\n}\n*`// ...`*\n`ask``(``)`\n  `.``map``(``parse``)`\n  .map(date => date.toISOString())\n    *`// Error TS2339: Property 'toISOString' does not exist on type 'Date[]'.`*\n  .forEach(date => console.info('Date is', date))\n\n```", "```\n`flatten``(`ask()\n  .map(parse)`)`\n  .map(date => date.toISOString())\n  .forEach(date => console.info('Date is', date))\n\n*`// Flattens an array of arrays into an array`*\n`function` `flatten``<``T``>``(``array``:` `T``[``]``[``]``)``:` `T``[``]` `{`\n  `return` `Array``.``prototype``.``concat``.``apply``(``[``]``,` `array``)`\n`}`\n\n```", "```\nask()\n  .flatMap(parse)\n  .flatMap(date => new Some(date.toISOString()))\n  .flatMap(date => new Some('Date is ' + date))\n  .getOrElse('Error parsing date for some reason')\n```", "```\ninterface Option<T> {} ![1](assets/1.png)\nclass Some<T> implements Option<T> { ![2](assets/2.png)\n  constructor(private value: T) {}\n}\nclass None implements Option<never> {} ![3](assets/3.png)\n```", "```\ninterface Option<T> {\n  `flatMap``<``U``>``(``f``:` `(``value``:` `T``)` `=``>` `Option``<``U``>``)``:` `Option``<``U``>`\n  `getOrElse``(``value``:` `T``)``:` `T`\n}\nclass Some<T> extends Option<T> {\n  constructor(private value: T) {}\n}\nclass None extends Option<never> {}\n\n```", "```\ninterface Option<T> {\n  flatMap<U>(f: (value: T) => Option<U>): Option<U>\n  getOrElse(value: T): T\n}\nclass Some<T> implements Option<T> {\n  constructor(private value: T) {}\n  `flatMap``<``U``>``(``f``:` `(``value``:` `T``)` `=``>` `Option``<``U``>``)``:` `Option``<``U``>` `{` ![](assets/1.png)\n    `return` `f``(``this``.``value``)`\n  `}`\n  `getOrElse``(``)``:` `T` `{` ![](assets/2.png)\n    `return` `this``.``value`\n  `}`\n}\nclass None implements Option<never> {\n  `flatMap``<``U``>``(``)``:` `Option``<``U``>` `{` ![](assets/3.png)\n    `return` `this`\n  `}`\n  `getOrElse``<``U``>``(``value``:` `U``)``:` `U` `{` ![](assets/4.png)\n    `return` `value`\n  `}`\n}\n\n```", "```\ninterface Option<T> {\n  `flatMap``<``U``>``(``f``:` `(``value``:` `T``)` `=``>` `None``)``:` `None`\n  flatMap<U>(f: (value: T) => Option<U>): Option<U>\n  getOrElse(value: T): T\n}\nclass Some<T> implements Option<T> {\n  constructor(private value: T) {}\n  `flatMap``<``U``>``(``f``:` `(``value``:` `T``)` `=``>` `None``)``:` `None`\n  `flatMap``<``U``>``(``f``:` `(``value``:` `T``)` `=``>` `Some``<``U``>``)``:` `Some``<``U``>`\n  flatMap<U>(f: (value: T) => Option<U>): Option<U> {\n    return f(this.value)\n  }\n  getOrElse(): T {\n    return this.value\n  }\n}\nclass None implements Option<never> {\n  `flatMap``(``)``:` `None` {\n    return this\n  }\n  getOrElse<U>(value: U): U {\n    return value\n  }\n}\n\n```", "```\nfunction Option<T>(value: null | undefined): None ![1](assets/1.png)\nfunction Option<T>(value: T): Some<T> ![2](assets/2.png)\nfunction Option<T>(value: T): Option<T> { ![3](assets/3.png)\n  if (value == null) {\n    return new None\n  }\n  return new Some(value)\n}\n```", "```\nlet result = Option(6)          // Some<number>\n  .flatMap(n => Option(n * 3))  // Some<number>\n  .flatMap(n => new None)       // None\n  .getOrElse(7)                 // 7\n```", "```\nask()                                              // Option<string>\n  .flatMap(parse)                                  // Option<Date>\n  .flatMap(date => new Some(date.toISOString()))   // Option<string>\n  .flatMap(date => new Some('Date is ' + date))    // Option<string>\n  .getOrElse('Error parsing date for some reason') // string\n```", "```\n    class API {\n      getLoggedInUserID(): UserID\n      getFriendIDs(userID: UserID): UserID[]\n      getUserName(userID: UserID): string\n    }\n    ```"]