<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Threat Defense and Intrusion Detection"><div class="chapter" id="threat_defense_and_intrusion_detection">
    <h1><span class="label">Chapter 11. </span>Threat Defense and Intrusion Detection</h1>
    <p>In this chapter we will explore how you can implement threat defense<a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="about" id="idm45326825169856"/> for your Kubernetes
        cluster. We have covered the stages of your Kubernetes deployment (build, deploy, runtime) in earlier chapters.
        This chapter focuses on threat defense, which is security for the runtime stage. We will cover the following
        concepts to help you understand threat defense in a Kubernetes cluster and why you need it.</p>
    <ul>
        <li>
            <p>Threat defense for a Kubernetes cluster, including why you need it and how it differs from traditional
                security</p>
        </li>
        <li>
            <p>Intrusion detection for Kubernetes</p>
        </li>
        <li>
            <p>Advanced threat defense techniques</p>
        </li>
    </ul>
    <p>Let’s explore each of these in detail. We start with threat defense and why it is <span class="keep-together">important.</span></p>
    <section data-type="sect1" data-pdf-bookmark="Threat Defense for Kubernetes (Stages of an Attack)"><div class="sect1" id="threat_defense_for_kubernetes_left_pare">
        <h1>Threat Defense for Kubernetes (Stages of an Attack)</h1>
        <p>To understand threat defense, a great place to start is to review<a contenteditable="false" data-type="indexterm" data-primary="cybersecurity kill chain" id="ch11-kill"/><a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="stages of attack" id="ch11-kill2"/><a contenteditable="false" data-type="indexterm" data-primary="kill chains of cyber attacks" id="ch11-kill3"/> the
            cybersecurity kill chain, which breaks down an attack into several stages. This is then used to build a
            strategy to defend against the attack. The cyber kill chain has the following stages:</p>
        <dl>
<dt>Reconnaissance</dt>
<dd>Adversaries probe the target and gather information.</dd>
<dt>Weaponization</dt> 
<dd>The adversary creates a method to attack, which could be a new vulnerability, <span class="keep-together">a variant</span> of an existing vulnerability, or a simple exploit of an insecure <span class="keep-together">configuration.</span></dd>
<dt>Delivery</dt> 
<dd>The adversary creates a method to deliver the vulnerability or exploit to the target or a location that can be used to attack the target.</dd>
<dt>Exploitation</dt> 
<dd>The adversary implements methods to trigger the attack.</dd>
<dt>Installation</dt> 
<dd>The adversary installs the malware and typically software to create a backdoor to communicate with the malware.</dd>
<dt>Command and Control</dt> 
<dd>The adversary establishes a communication channel with the malicious software to control the software.</dd>
<dt>Actions on Objective</dt> 
<dd>The adversary achieves the intended outcome of the attack (e.g., stealing data, encryption of data, etc.).</dd>
        </dl>
        <p>Several organizations have adapted this framework to incorporate real-world attacks and more use cases. <a contenteditable="false" data-type="indexterm" data-primary="cybersecurity kill chain" data-secondary="framework online" id="idm45326825147536"/><a contenteditable="false" data-type="indexterm" data-primary="kill chains of cyber attacks" data-secondary="framework online" id="idm45326825146192"/><a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="stages of attack" data-tertiary="framework online" id="idm45326825144848"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="cyberattack framework" id="idm45326825143200"/>Microsoft has adapted it for Kubernetes as described in
            its blog post <a href="https://oreil.ly/gebGs">“blog"Secure Containerized Environments with Updated Threat Matrix for Kubernetes”</a>.
            Let’s review the kill-chain stages (threat matrix) that are specific to Kubernetes:</p>
            <dl>
<dt>Initial access</dt> 
<dd>The adversary uses various exposed interfaces in your Kubernetes deployments (for example, Kubeflow) via stolen credentials, compromised images, or other application vulnerabilities.</dd>
<dt>Execution</dt> 
<dd>The adversary executes a malicious command or software in your cluster.<a contenteditable="false" data-type="indexterm" data-primary="execution of malicious code" id="idm45326825138208"/> There are several ways this can happen; some known techniques are creating a new container in your cluster, running an additional container in any pod as a sidecar, and using a known application vulnerability to execute malicious commands.</dd>
 <dt>Persistence</dt>
 <dd>The adversary will try to persist the malicious software<a contenteditable="false" data-type="indexterm" data-primary="persistence of malicious code" id="idm45326825135712"/> in the Kubernetes cluster so it can be accessed at a later time. This is typically achieved by creating a writage storage path on the host, leveraging Kubernetes scheduled jobs (known as cron jobs) to periodically run malicious software, or in some cases, compromising the Kubernetes admission controller so requests to the API server can be tampered with to carry out an attack. <a contenteditable="false" data-type="indexterm" data-primary="command-and-control server (C&amp;C server)" id="idm45326825133984"/>In
                    this stage adversaries will also try to establish a backdoor communication channel to their control
                    server so they can control the malicious software. This is known as a command-and-control server
                    (C&amp;C server).</dd>
<dt>Privilege escalation</dt> 
<dd>The adversary gains privileged access by<a contenteditable="false" data-type="indexterm" data-primary="privilege escalation" data-secondary="threat defense stages of attack" id="idm45326825131520"/> leveraging a resource in your
                    cluster that has privileged access. For example, they might run malicious software in a container
                    with privileged access by exploiting a vulnerability in the privileged container.</dd>
            <dt>Defense evasion</dt> 
            <dd>The adversary works to keep the attack undetected<a contenteditable="false" data-type="indexterm" data-primary="defense evasion in attack" id="idm45326825128800"/><a contenteditable="false" data-type="indexterm" data-primary="logs" data-secondary="defense evasion in attack" id="idm45326825127680"/> by using techniques like clearing logs or
                    deleting events, so detection systems using logs and events do not detect the presence of malicious
                    activity. Another technique that is used is to exploit a vulnerability in only one pod of a
                    Kubernetes deployment backed by many pods, and use that to further the attack.</dd>
            <dt>Credential access</dt>
            <dd>The adversary works to get access to credentials<a contenteditable="false" data-type="indexterm" data-primary="credential access in attack" id="idm45326825124848"/><a contenteditable="false" data-type="indexterm" data-primary="secrets" data-secondary="credential access in attack" id="idm45326825123728"/><a contenteditable="false" data-type="indexterm" data-primary="managed Kubernetes services" data-secondary="credential access in attack" id="idm45326825122336"/><a contenteditable="false" data-type="indexterm" data-primary="cloud environments" data-secondary="credential access in attack" id="idm45326825120928"/> (Kubernetes secrets) in your cluster. In
                    case you are using managed services, the cloud provider offers a token to access cloud resources,
                    and this token is accessible to certain privileged pods and service accounts. The adversary will use
                    impersonation or privilege escalation to gain access to the credentials and then use access to cloud
                    resources to further the attack.</dd>
            <dt>Discovery</dt> 
            <dd>The adversary will work to do a reconnaissance of the cluster network to understand what
                    is running in your cluster. <a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="network mapping tool" id="idm45326825117920"/><a contenteditable="false" data-type="indexterm" data-primary="network mapping tool" id="idm45326825116544"/><a contenteditable="false" data-type="indexterm" data-primary="Nmap network mapping tool" id="idm45326825115440"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="Nmap network mapping tool" id="idm45326825114320"/>This can be achieved by using tools for
                    network mapping like <a href="https://nmap.org">Nmap</a> on Linux systems, or access to the
                    Kubenetes dashboard. This stage is the precursor to an important stage of the attack where
                    adversaries can move around in your cluster to find what they are seeking.</dd>
            <dt>Lateral movement</dt> 
            <dd>By the time the attack reaches this stage,<a contenteditable="false" data-type="indexterm" data-primary="lateral movement in stages of attack" id="idm45326825110832"/><a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="lateral movement in stages of attack" id="idm45326825109712"/> the attack is fairly advanced,
                    and the adversary has an established presence; they now will use the installed malicious software to
                    access other pods and resources in the network. A couple of common techniques are to spoof IP
                    addresses or domain names of other pods and impersonate other pods to get past segmentation rules
                    inside the cluster. The adversaries also look for other applications running inside the cluster, as
                    they now have access to them. <a contenteditable="false" data-type="indexterm" data-primary="command-and-control server (C&amp;C server)" id="idm45326825107616"/>During this stage the
                    malicious software is communicating with the command-and-control server to get instructions to
                    further the attack. In this stage adversaries rely on overloading well-known protocols like DNS or
                    HTTP to send command-and-control requests as a part of these protocols, which allows them to bypass
                    perimeter security–based controls as the traffic looks like a normal DNS or HTTP request.</dd>
            <dt>Impact</dt> 
            <dd>This is the final stage of the attack, where the outcome is usually the <a contenteditable="false" data-type="indexterm" data-primary="data exfiltration" id="idm45326825105008"/>stealing of sensitive data. This is achieved by a
                    technique called data exfiltration, encryption of data for ransomware, or even using resources for
                    cryptomining.</dd>
        </dl>
        <p>Threat defense comprises a set of techniques that help you defend against<a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="thwarting attacks" id="idm45326825103200"/> each
            of these stages and enable you to defend against attacks. It can be overwhelming to think about all these
            stages and techniques adversaries can use. We want to mention that while adversaries need to succeed in most
            (if not all) of these stages to carry out a successful attack, you only need to block them in any one stage
            to thwart the attack. So the odds are in your favor. Understanding these stages and how they apply to
            Kubernetes is a first step in building an effective defense mechanism. Adversaries are always innovating,
            and therefore you should focus on all the stages and use tools and techniques relevant to each stage to give
            yourself the greatest chance to successfully thwart attacks.</p>
        <p>In <a data-type="xref" href="ch02.xhtml#infrastructure_security">Chapter 2</a>, we covered
            infrastructure security, showing you how to create secure infrastructure for running your workloads. In <a data-type="xref" href="ch03.xhtml#workload_deployment_controls">Chapter 3</a>, we covered best
            practices and techniques you can use to securely deploy workloads. <a data-type="xref" href="ch04.xhtml#workload_runtime_security">Chapter 4</a> covers security policies you can apply
            to your workloads to secure the workload runtime environment, and <a data-type="xref" href="ch06.xhtml#observability_and_security">Chapter 6</a> covers how you can apply network
            policy to implement network access control for your workloads. We recommend you review these chapters in the
            context of the kill-chain stages described here. You will find that these techniques are very effective with
            the initial access, privilege escalation, credential access, persistence, and execution stages.</p>
        <p>We will now describe tools and techniques you can use to secure the other stages of the kill chain. It is
            important to note that Kubernetes is a distributed system and its cluster network is crucial to its
            operation; therefore, securing the network is a very effective technique. For example, a successful
            privilege escalation or a successful exploit of an application vulnerability is rendered ineffective if the
            adversary cannot further the attack due to an inability to use the cluster network for discovery, command
            and control, lateral movement, or data exfiltration. It is not enough to have network segmentation based on
            IP addresses/ports, as adversaries will find ways to further an attack even with techniques like network
            segmentation protecting your cluster. For example, you need to allow HTTP traffic to your service and pods
            backing the service, so the attack can be a part of the HTTP header that triggers a privilege escalation.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-kill" id="idm45326825094224"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-kill2" id="idm45326825092832"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-kill3" id="idm45326825091456"/></p>
        <p>Now that we have covered concepts for threat defense, let’s explore intrusion <span class="keep-together">detection.</span></p>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Intrusion Detection"><div class="sect1" id="intrusion_detection">
        <h1>Intrusion Detection</h1>
        <p>In this section we will cover intrusion detection and how it applies to Kubernetes clusters. To understand
            this, we will review the various methods of intrusion and the role of an intrusion detection system.</p>
        <section data-type="sect2" data-pdf-bookmark="Intrusion Detection Systems"><div class="sect2" id="intrusion_detection_systems">
            <h2>Intrusion Detection Systems</h2>
            <p>An intrusion detection system (IDS), as the name suggests, is a system<a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" id="idm45326825085120"/><a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="intrusion detection" data-tertiary="intrusion detection systems" id="idm45326825083872"/> that
                monitors network activity, detects anomalous patterns, and reports suspicious behavior. These systems
                also monitor violations to existing controls (like network policy, host hardening) and report these
                violations. The response actions for an IDS are the following:<a contenteditable="false" data-type="indexterm" data-primary="alerting" data-secondary="intrusion detection systems" id="idm45326825081744"/><a contenteditable="false" data-type="indexterm" data-primary="security, information, and event management (SIEM)" data-secondary="alerts exported to" data-tertiary="intrusion detection systems" id="idm45326825080352"/></p>
            <dl>
                <dt>Alerting</dt>
                <dd>Generate an alert and send it to a SIEM for further analysis and action.</dd>
                <dt>Intrusion prevention</dt>
                <dd>The system takes action to prevent the intrusion by leveraging<a contenteditable="false" data-type="indexterm" data-primary="canary resources" id="idm45326825076448"/><a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="canary resources" id="idm45326825075168"/> existing
                    controls (e.g., network policies, Kubernetes pod security policies, host hardening policies) and
                    redirecting the attack to canary resources especially set up to analyze these types of attack. <a contenteditable="false" data-type="indexterm" data-primary="intrusion prevention systems (IPS)" id="idm45326825073408"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="intrusion prevention systems" id="idm45326825072288"/>When an IDS is also able to prevent the
                    intrusion, it is called an intrusion prevention system (IPS).</dd>
            </dl>
            <p>A good intrusion detection system should be able to associate a set of <a contenteditable="false" data-type="indexterm" data-primary="anomaly detection via machine learning" data-secondary="intrusion detection systems" id="idm45326825069840"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="anomaly detection" id="idm45326825068400"/><a contenteditable="false" data-type="indexterm" data-primary="user and entity behavior analytics (UEBA)" data-secondary="intrusion detection" id="idm45326825067008"/><a contenteditable="false" data-type="indexterm" data-primary="anomaly detection via machine learning" data-secondary="user and entity behavior analytics" data-tertiary="intrusion detection" id="idm45326825065600"/><a contenteditable="false" data-type="indexterm" data-primary="machine learning (ML)" data-secondary="anomaly detection" data-tertiary="user and entity behavior analytics" id="idm45326825063920"/><a contenteditable="false" data-type="indexterm" data-primary="observability" data-secondary="analytics" data-tertiary="user and entity behavior analytics" id="idm45326825062256"/><a contenteditable="false" data-type="indexterm" data-primary="Azure cloud (Microsoft)" data-secondary="user and entity behavior analytics" data-tertiary="resource online" id="idm45326825060592"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="user and entity behavior analytics" id="idm45326825058928"/><a contenteditable="false" data-type="indexterm" data-primary="alerting" data-secondary="intrusion detection systems" data-tertiary="user and entity behavior analytics" id="idm45326825057536"/>related anomalies by tracking the
                behavior of a system. We recommend you review user and entity behavior analytics (UEBA) and how it
                applies to security. <a href="https://oreil.ly/LqYWk">Microsoft
                    Azure UEBA</a> is an excellent resource for you to review. Please note that for Kubernetes, entity
                behavioral analytics is applicable. The details of how to implement it are outside the scope of this
                book, but UEBA helps in reducing the number of alerts and generating high-fidelity alerts. Please note
                that more alerts is not necessarily good; they cause downstream systems (e.g., SIEMs) to be immune to
                alerts. Later we will review how to leverage machine learning systems to generate high-fidelity alerts.
            </p>
            <p>We will now review intrusion detection methods and how they apply to Kubernetes clusters.</p>
        </div></section>
        
<section data-type="sect2" data-pdf-bookmark="IP Address and Domain Name Threat Feeds"><div class="sect2" id="ip_address_and_domain_name_threat_feeds">
<h2>IP Address and Domain Name Threat Feeds</h2>
<p>As explained in the cybersecurity kill chain, adversaries will often use<a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="IP address and domain name threat feeds" id="ch110ipad"/><a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="intrusion detection" data-tertiary="IP address and domain name threat feeds" id="ch110ipad2"/><a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="threat feeds" id="ch110ipad3"/><a contenteditable="false" data-type="indexterm" data-primary="domain name threat feeds" id="ch110ipad4"/><a contenteditable="false" data-type="indexterm" data-primary="command-and-control server (C&amp;C server)" data-secondary="threat feeds" id="ch110ipad5"/> malicious software to contact a server that is controlled by them. These servers are used to remotely control the malicious software, get information about the system, download more software, and further the attack. Security research teams around the world review attacks and identify known C&amp;C servers by IP address/domains. These are published as threat feeds and as a part of the indicators of compromise and are regularly updated. <a contenteditable="false" data-type="indexterm" data-primary="STIX describing threat intelligence" id="idm45326825042800"/><a contenteditable="false" data-type="indexterm" data-primary="TAXII delivering intelligence" id="idm45326825041680"/>There are several well-known threat feeds both open source and commercial. <a href="https://oreil.ly/6mw8s">STIX</a> is a well-known standard to describe threat intelligence, and <a href="https://oreil.ly/w9DSn">TAXII</a> is the standard to deliver the intelligence. You can find several open source engines that parse the STIX and TAXII feeds and provide intelligence (e.g., AlienVault). <a href="https://oreil.ly/c0ccW">Feodo tracker</a> and <a href="https://oreil.ly/1isJX">Snort</a> are examples of open source feeds that provide IP address block lists.<a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="block lists" id="idm45326825037376"/><a contenteditable="false" data-type="indexterm" data-primary="block lists" id="idm45326825035920"/></p>

<p>Sometimes adversaries will use VPNs (virtual private networks), <a contenteditable="false" data-type="indexterm" data-primary="networking" data-secondary="virtual private networks" id="idm45326825034560"/><a contenteditable="false" data-type="indexterm" data-primary="VPNs (virtual private networks)" id="idm45326825033008"/><a contenteditable="false" data-type="indexterm" data-primary="Tor overlay network" id="idm45326825031888"/>which are overlay networks that run over physical networks and are useful to conceal a user’s location. Tor is another well-known overlay network that is used for this purpose. Similar to threat feeds for C&amp;C servers, feeds are available for known <a href="https://oreil.ly/RGtxT">VPNs</a> and <a href="https://oreil.ly/VHGkZ">IPs from the Tor network</a>.</p>
            
<p>We will now cover how you can use these feeds in your Kubernetes cluster<a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="intrusion prevention systems" data-tertiary="implementing" id="idm45326825028560"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion prevention systems (IPS)" data-secondary="implementing" id="idm45326825026736"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="implementing" id="idm45326825025344"/> to implement IDS/IPS. <a data-type="xref" href="#implementing_idssolidusips_using_threat">Figure 11-1</a> shows a sample implementation of applying suspicious IP addresses and domains in your Kubernetes cluster.</p>
            <figure><div id="implementing_idssolidusips_using_threat" class="figure">
                <img src="Images/ksao_1101.png" alt="" width="972" height="667"/>
                <h6><span class="label">Figure 11-1. </span>Implementing IDS/IPS using threat feeds</h6>
            </div></figure>
            <p><a data-type="xref" href="#implementing_idssolidusips_using_threat">Figure 11-1</a> shows
                what you need to implement support for threat feeds in your cluster and also describes the high-level
                workflow to achieve IDS/IPS capabilities. The figure shows the following components as a part of your
                Kubernetes cluster.</p>
            <section data-type="sect3" data-pdf-bookmark="Threat feed controller"><div class="sect3" id="threat_feed_controller">
                <h3>Threat feed controller</h3>
                <p>This component is responsible for retrieving threat feeds from a configured source<a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="implementing" data-tertiary="threat feed controller" id="idm45326825017152"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="IP address and domain name threat feeds" data-tertiary="threat feed controller" id="idm45326825015344"/><a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="threat feeds" data-tertiary="threat feed controller" id="idm45326825013664"/><a contenteditable="false" data-type="indexterm" data-primary="domain name threat feeds" data-secondary="threat feed controller" id="idm45326825012016"/> (typically a URL). This can be implemented in
                    many ways. For the purposes of this discussion, we assume that is a pod that watches a configuration
                    resource (example in a moment) and reaches out to the specified URL and stores the threat feed data
                    in the Kubernetes datastore for other components. The following is an example of configuration for
                    the threat feed controller:</p>
                <pre data-code-language="yaml" class="pagebreak-before"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">projectcalico.org/v3</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">GlobalThreatFeed</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">sample-global-threat-feed</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">content</code><code class="p">:</code> <code class="l-Scalar-Plain">IPSet</code>
  <code class="nt">pull</code><code class="p">:</code>
    <code class="nt">http</code><code class="p">:</code>
      <code class="nt">url</code><code class="p">:</code> <code class="l-Scalar-Plain">https://an.example.threat.feed/blacklist</code>
  <code class="nt">globalNetworkSet</code><code class="p">:</code>
    <code class="nt">labels</code><code class="p">:</code>
      <code class="nt">security-action</code><code class="p">:</code> <code class="l-Scalar-Plain">block</code></pre>
                <p>In this example, the threat feed controller is configured to pull the threat feed from the specified
                    URL and then stores the list of IP addresses as a custom Kubernetes resource named globalnetworkset.
                    This is then used by the network policy implementation to enforce policies based on this resource.
                    The following is an example of a policy that can be defined using the globalnetworkset resource:</p>
                <pre data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">projectcalico.org/v3</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">GlobalNetworkPolicy</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">default.blockthreats</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">tier</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>
  <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">all()</code>
  <code class="nt">types</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">Ingress</code>
  <code class="nt">ingress</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">action</code><code class="p">:</code> <code class="l-Scalar-Plain">Deny</code>
    <code class="nt">source</code><code class="p">:</code>
      <code class="nt">selector</code><code class="p">:</code> <code class="l-Scalar-Plain">security-action == 'block'</code></pre>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Network policy engine"><div class="sect3" id="network_policy_engine">
                <h3>Network policy engine</h3>
                <p>This is the component that implements network policies in your cluster<a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="implementing" data-tertiary="network policy engine" id="idm45326824920896"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="IP address and domain name threat feeds" data-tertiary="network policy engine" id="idm45326824882832"/><a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="threat feeds" data-tertiary="network policy engine" id="idm45326824881184"/><a contenteditable="false" data-type="indexterm" data-primary="domain name threat feeds" data-secondary="network policy engine" id="idm45326824879536"/><a contenteditable="false" data-type="indexterm" data-primary="network policies" data-secondary="intrusion detection systems" id="idm45326824878144"/> and is used to define policies to block
                    traffic to and from IP addresses that are a part of threat feeds. Please note that an IP address
                    list can contain a large number of IP addresses and can change periodically. Therefore, the network
                    policy implementation you choose should scale based on this requirement. As a hint, we recommend you
                    pick an engine that supports the ipsets extension in an iptables-based dataplane, where matching
                    sets of IP addresses is optimized. If you are using an eBPF-based dataplane, please ensure the
                    implementation has support for eBPF maps to implement functionality equivalent to ipsets.</p>
            </div></section>
            <section data-type="sect3" class="pagebreak-before" data-pdf-bookmark="Log processing engine"><div class="sect3" id="log_processing_engine">
                <h3 class="less_space">Log processing engine</h3>
                <p>This component is responsible for reporting flow logs from your cluster<a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="implementing" data-tertiary="log processing engine" id="idm45326824873296"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="IP address and domain name threat feeds" data-tertiary="log processing engine" id="idm45326824871632"/><a contenteditable="false" data-type="indexterm" data-primary="IP addresses" data-secondary="threat feeds" data-tertiary="log processing engine" id="idm45326824869952"/><a contenteditable="false" data-type="indexterm" data-primary="domain name threat feeds" data-secondary="log processing engine" id="idm45326824868304"/><a contenteditable="false" data-type="indexterm" data-primary="logs" data-secondary="intrusion detection systems" id="idm45326824866912"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="logs" id="idm45326824865520"/> that contain IP addresses that match any IP addresses that are
                    part of the threat feed and generate an alert. Please note this can be a resource-intensive
                    operation, given the large amount of flow data. One way to address this is to have the network
                    policy engine add an annotation to the flow log to name the feed that contained the IP address in
                    the flow log when the dataplane detects a match. It is very efficient to do this operation inline
                    instead of doing a match after data is collected.</p>
                <p>Now that we understand the various components of the IDS, let’s review the step-by-step operation:<a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" id="idm45326824862864"/></p>
                <ol>
                    <li>
                        <p>The threat feed controller polls the threat feed periodically.</p>
                    </li>
                    <li>
                        <p>The threat feed controller processes the feed and creates the globalnetworkset resource in
                            the Kubernetes datastore for the threat feed.</p>
                    </li>
                    <li>
                        <p>The network policy engine and the log processing engine read the threat feed.</p>
                    </li>
                    <li>
                        <p>If a network policy is defined, the network policy engine implements the network policy for
                            the threat feed.</p>
                    </li>
                    <li>
                        <p>The log engine processes flow logs from the flow log datastore and generates alerts for flows
                            matching IP addresses in the threat feed.</p>
                    </li>
                </ol>
                <p>In step 4, we are able to prevent an intrusion, and step 5 is where we can detect an intrusion.</p>
            </div></section>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="Special Considerations for Domain Name Feeds"><div class="sect2" id="special_considerations_for_domain_name">
            <h2>Special Considerations for Domain Name Feeds</h2>
            <p>As mentioned before, threat feeds can be a list of IP addresses<a contenteditable="false" data-type="indexterm" data-primary="domain name threat feeds" data-secondary="special considerations" id="ch11-sc"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="IP address and domain name threat feeds" data-tertiary="domain name special considerations" id="ch11-sc2"/><a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="intrusion detection" data-tertiary="domain name special considerations" id="ch11-sc3"/> or domain names. In case of domain names, the network policy engine must
                support domain name–based policies, and the log processing engine must support capturing domain names in
                flow logs and matching domain names from feeds in a flow log.</p>
            <p>Note that the technique described detects and enables controls to protect against malicious activity, so
                it makes the implementation an intrusion prevention system.</p>
            <section data-type="sect3" data-pdf-bookmark="Deep packet inspection"><div class="sect3" id="deep_packet_inspection">
                <h3>Deep packet inspection</h3>
                <p>Deep packet inspection (DPI) is an intrusion detection technique<a contenteditable="false" data-type="indexterm" data-primary="deep packet inspection (DPI)" id="ch11-dpi"/><a contenteditable="false" data-type="indexterm" data-primary="domain name threat feeds" data-secondary="deep packet inspection" id="ch11-dpi2"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="IP address and domain name threat feeds" data-tertiary="deep packet inspection" id="ch11-dpi3"/> where network traffic is inspected and matched against known malicious
                    network traffic patterns. This requires inspection of the packet beyond Layer 3/Layer 4 and
                    understanding of application protocols (e.g., HTTP, MySQL, etc.). <a contenteditable="false" data-type="indexterm" data-primary="domain name threat feeds" data-secondary="deep packet inspection" data-tertiary="signatures for well-known risks" id="idm45326824839904"/><a contenteditable="false" data-type="indexterm" data-primary="deep packet inspection (DPI)" data-secondary="signatures for well-known risks" id="idm45326824838224"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="IP address and domain name threat feeds" data-tertiary="signatures for well-known risks" id="idm45326824836816"/><a contenteditable="false" data-type="indexterm" data-primary="resources online" data-secondary="deep packet inspection signatures" id="idm45326824835120"/><a contenteditable="false" data-type="indexterm" data-primary="OWASP Top 10 link" id="idm45326824833728"/><a contenteditable="false" data-type="indexterm" data-primary="SANs Top 25 link" id="idm45326824832624"/>Similar to threat feeds for IP
                    and domains, signatures-based feeds are also available. <a href="https://oreil.ly/270Fw">OWASP Top 10</a> and <a href="https://oreil.ly/OmO85">SANs Top 25</a> are signatures for well-known
                    application software risks and software vulnerabilities that can be used to detect <span class="keep-together">malicious</span> traffic
                    in network and application layers of the packet. When you think about implementing DPI in your
                    cluster, you need to consider a few factors.</p>
                <p>First, where should you implement DPI? One option is to implement it at the ingress, which is the
                    point where traffic enters/exits the cluster. Ingress is a resource in Kubernetes that allows users
                    to expose services to clients outside the cluster. This topic is covered in depth in <a data-type="xref" href="ch08.xhtml#managing_trust_across_teams">Chapter 8</a>. For this
                    discussion we assume that the services are exposed as URLs. So in this case you would implement DPI
                    at the ingress (e.g., load balancers or on nodes for traffic going through node ports). This is a
                    good option, but in this scenario the limitation is that you can detect a malicious network flow,
                    but the information is not complete, as the detection is early in the cycle. You will not have
                    visibility into which pod the malicious flow was destined to, and will have to review all possible
                    destination pods and then co-relate the activity of each pod backing the service to understand the
                    attack. Also, if the attack uses another mechanism to trigger the exploit (e.g., an API server, a
                    kube-proxy vulnerability, or a node OS image vulnerability), the malicious flow originates inside
                    the cluster and will not be detected at the ingress. Therefore, it is better to implement DPI for
                    the service inside the cluster.</p>
                <p>So if you choose the option to implement DPI inside the cluster for each service, you need to
                    consider that the amount of traffic inside the cluster is very large due to the distributed nature
                    of Kubernetes. This presents a challenge as DPI involves packet parsing and can potentially impact
                    latency for applications as well as increase the resource utilization. In order to address the
                    application latency challenge, we recommend you consider DPI as a mechanism to detect malicious
                    activity and not prevent the attack. This means the DPI engine does not need to be inline and can
                    work with a copy of each packet in the flow; the original packet flow is not impacted by this, and
                    hence there is no impact to latency-sensitive applications. There is still the concern about
                    resource utilization due to packet parsing. In order to address this, we recommend you use context
                    in the Kubernetes cluster to select traffic for services that need DPI. This could be as simple as
                    labeling services that are critical and have compliance requirements and enabling DPI using
                    label-based selectors, or you can use DPI as a response action to anomalous traffic that is
                    identified by a SIEM or your logging and alerting engine.</p>
                <p>Another important consideration is that the DPI engine needs traffic to be unencrypted, so if you are
                    using encryption for traffic inside the cluster (e.g., HTTPS), you need to implement decryption
                    along with your DPI engine or choose an encryption technology like WireGuard, where you can
                    implement DPI prior to encryption for egress traffic and after decryption for ingress traffic. You
                    should consider a proxy like Envoy that allows traffic to be redirected to it, decrypted, inspected,
                    encrypted, and sent to its destination.</p>
                <p>Now that we have established that DPI needs to be implemented inside the cluster as an IDS mechanism
                    and needs to be selectively enabled to limit resource consumption, let’s explore a sample reference
                    architecture for a DPI implementation for your Kubernetes cluster. <a data-type="xref" href="#implementation_of_dpi_using_envoy">Figure 11-2</a> shows a
                    reference implementation. <a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="engines available" id="idm45326824821456"/><a contenteditable="false" data-type="indexterm" data-primary="Snort intrusion detection engine" id="idm45326824820064"/><a contenteditable="false" data-type="indexterm" data-primary="Suricata intrusion detection engine" id="idm45326824818944"/>Before we
                    review the reference implementation, we want to introduce some well-known IDS engines that are
                    available for you to integrate in your cluster. <a href="https://oreil.ly/yDteh">Snort</a> and <a href="https://oreil.ly/1Ka1q">Suricata</a> are a couple
                    of open source IDS engines that are available; however, you can choose any IDS engine that is
                    suitable for your use case, including implementing your own IDS engine.</p>
                <figure><div id="implementation_of_dpi_using_envoy" class="figure">
                    <img src="Images/ksao_1102.png" alt="" width="1449" height="998"/>
                    <h6><span class="label">Figure 11-2. </span>Implementation of DPI using Envoy</h6>
                </div></figure>
                <p><a data-type="xref" href="#implementation_of_dpi_using_envoy">Figure 11-2</a>
                    shows a Kubernetes cluster <a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="implementing" data-tertiary="Envoy for" id="idm45326824812656"/><a contenteditable="false" data-type="indexterm" data-primary="Envoy proxy" data-secondary="intrusion detection implementation" id="idm45326824810976"/>namespace that has a few
                    microservices that are part of an application. The figure shows Envoy is deployed as a daemonset on
                    every node. Envoy is a well-known proxy that is used in Kubernetes clusters to proxy traffic for
                    analysis and for additional controls. We recommend you use Envoy as a transparent proxy, where it
                    terminates connections destined to a pod backing a service and after analysis sends the traffic to
                    the pod backing a service. In this case for the second microservice, the DPI engine is implemented
                    as an integration to Envoy, and Envoy is configured to redirect traffic destined for pods backing
                    the service to itself. DPI is then performed, and Envoy takes care of completing the connection. The
                    transparent mode for Envoy means that the application sees no difference in the packet (e.g., TCP/IP
                    header). As discussed before, if a malicious flow is detected by the DPI engine, the resulting alert
                    will show the pod that received the flow, and it is then trivial to examine activity by that pod and
                    co-relate it to the malicious flow. In <a data-type="xref" href="#implementation_of_dpi_using_envoy">Figure 11-2</a>, DPI is enabled
                    for traffic destined to one service as an example. DPI can be enabled for any service or a
                    combination of pods; the approach is similar, but the difference is in how Envoy is configured for
                    traffic redirection.</p>
                <p>We recommend that you use Envoy with your DPI engine, but there are other ways to integrate a DPI
                    engine in your Kubernetes cluster. For example, if you have a cluster running an eBPF dataplane, you
                    can get copies of the packet in the BPF program and send them to the IDS engine for analysis.
                    Likewise, if you are using <a href="https://fd.io">VPP</a> as the dataplane, it is also possible to
                    integrate a DPI engine to inspect traffic.</p>
                <p>You can choose the option that works for you, but it is important that you consider integration of a
                    DPI engine in your Kubernetes cluster for signature-based malware detection. Next, let’s examine
                    logging and visibility and its role in the threat defense strategy.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-dpi" id="idm45326824804544"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-dpi2" id="idm45326824803168"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-dpi3" id="idm45326824801792"/></p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Logging and visibility"><div class="sect3" id="logging_and_visibility">
                <h3>Logging and visibility</h3>
                <p>A very important part of security is visibility of the activity in your cluster<a contenteditable="false" data-type="indexterm" data-primary="logs" data-secondary="intrusion detection systems" id="idm45326824798704"/><a contenteditable="false" data-type="indexterm" data-primary="domain name threat feeds" data-secondary="logging and visibility" id="idm45326824797168"/><a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="logs" id="idm45326824795776"/> (e.g., pod creation, Kubernetes resource access/changes,
                    application activity, network activity). This is achieved by enabling logging in your cluster. We
                    cover log collection and metrics collection in detail in <a data-type="xref" href="ch05.xhtml#observability-id000002">Chapter 5</a>. For this section we want to
                    reiterate the following as key aspects of logging and visibility:</p>
                <ul>
                    <li>
                        <p>Traditional logging for network flows with the five-tuple is insufficient. You need to use a
                            tool that supports Kubernetes context-rich logging where network flows between pods,
                            deployments, replica sets, and services are part of the log collected.</p>
                    </li>
                    <li>
                        <p>Logs at collection time need to be annotated with Kubernetes metadata like labels, policies
                            in use, node information, and even process information (processes running in the container).
                            This is important due to the ephemeral nature of Kubernetes; all of these change, and it is
                            difficult to associate a malicious network flow with Kubernetes metadata when the network
                            flows and the Kubernetes metadata are collected independent of each other.</p>
                    </li>
                    <li>
                        <p>DNS activity logs are critical and must also be annotated with <a contenteditable="false" data-type="indexterm" data-primary="DNS activity logs" id="idm45326824789040"/>Kubernetes metadata as
                            described earlier for network flow logs.</p>
                    </li>
                    <li>
                        <p>Application protocol–based flow logs (e.g., HTTP header, MySQL) are also critical and again
                            must be collected with Kubernetes metadata.</p>
                    </li>
                    <li>
                        <p>Finally, Kubernetes audit logs (activity logs) are very important<a contenteditable="false" data-type="indexterm" data-primary="Kubernetes" data-secondary="activity logs" id="idm45326824785584"/><a contenteditable="false" data-type="indexterm" data-primary="logs" data-secondary="Kubernetes activity logs" id="idm45326824784128"/><a contenteditable="false" data-type="indexterm" data-primary="audit logs" data-secondary="Kubernetes activity logs" id="idm45326824782688"/> and must be collected, as these
                            will help detect abnormal activity by malicious users (e.g., repeated denied access to a
                            resource, creation of a service account, etc.).</p>
                    </li>
                </ul>
                <p>There are several tools and mechanisms available to you to implement log collection.<a contenteditable="false" data-type="indexterm" data-primary="intrusion detection systems (IDS)" data-secondary="logs" data-tertiary="tools for log collection" id="idm45326824780416"/><a contenteditable="false" data-type="indexterm" data-primary="logs" data-secondary="tools for collection" id="idm45326824778752"/><a contenteditable="false" data-type="indexterm" data-primary="cloud environments" data-secondary="managed Kubernetes services" data-tertiary="tools for logging" id="idm45326824777376"/><a contenteditable="false" data-type="indexterm" data-primary="Calico Enterprise" data-secondary="logging tool" id="idm45326824775712"/><a contenteditable="false" data-type="indexterm" data-primary="Datadog" data-secondary="logging tool" id="idm45326824774336"/> The cloud providers have logging capabilities (e.g.,
                    Stackdriver in Google, CloudWatch in AWS); you can also choose to implement logging using tools like
                    Sysdig, Datadog, and Calico Enterprise, which offer logging capabilities with Kubernetes context. In
                    addition to the log collection described earlier, the tool you choose must support the following
                    simple capabilities that are critical to your IDS strategy:</p>
                <ul>
                    <li>
                        <p>The tool must support an alerting capability that allows you to query logs and set up alerts
                            for rule-based anomalies (e.g., excessive NXDOMAIN requests, imbalance in network throughput
                            for a given protocol like HTTP or DNS between inbound and outbound traffic, unexpected
                            connections to certain pods from certain namespaces, excessive network policy denied logs).
                        </p>
                    </li>
                    <li>
                        <p>The tools must support the baselining of various metrics (e.g., number of connections to a
                            service, HTTP requests from a rare user-agent in the header) using basic machine learning
                            techniques and report anomalies as alerts.</p>
                    </li>
                    <li>
                        <p>The tools must support forwarding logs and alerts to an external SIEM (like Splunk, QRadar,
                            Sumo Logic) or the cloud provider’s security center (Azure Security Center).</p>
                    </li>
                </ul>
                <p>The previous sections covered the collection and analysis of logs. While logging is available in most
                    Kubernetes environments, you need to ensure that the tool you choose to implement logging is
                    effective for your IDS strategy.<a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch110ipad" id="idm45326824767488"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch110ipad2" id="idm45326824766112"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch110ipad3" id="idm45326824764736"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch110ipad4" id="idm45326824763360"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch110ipad5" id="idm45326824761984"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-sc" id="idm45326824760608"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-sc2" id="idm45326824759232"/><a contenteditable="false" data-type="indexterm" data-primary="" data-startref="ch11-sc3" id="idm45326824757856"/></p>
            </div></section>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Advanced Threat Defense Techniques"><div class="sect1" id="advanced_threat_defense_techniques">
        <h1>Advanced Threat Defense Techniques</h1>
        <p>In this section we will cover some advanced threat defense techniques you can use in your cluster. These are
            techniques that are designed to be effective in a Kubernetes environment, especially for detecting the
            lateral movement and exfiltration stages of the attack life cycle.</p>
        <section data-type="sect2" data-pdf-bookmark="Canary Pods/Resources"><div class="sect2" id="canary_podssolidusresources">
            <h2>Canary Pods/Resources</h2>
            <p>The use of honeypots is a well-known technique to detect bad actors<a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="advanced techniques" data-tertiary="canary pods/resources" id="idm45326824752384"/><a contenteditable="false" data-type="indexterm" data-primary="canary resources" id="idm45326824750656"/><a contenteditable="false" data-type="indexterm" data-primary="pods" data-secondary="canary resources" id="idm45326824749552"/> within your cluster and gain
                insight on what they are doing by exposing simulated or intentionally vulnerable applications in your
                cluster and monitoring access to these applications. These applications act as a canary to notify the
                blue team of the intrusion and stall the attacker’s progress from reaching actual sensitive applications
                and data. Once the blue team is aware of the situation, the attack can be traced back to the initial
                vector. The attack can then be contained and even removed from the cluster.</p>
            <p>Applying this technique in a Kubernetes environment works exceedingly well due to the declarative nature
                of applying manifests to deploy workloads. Whether the cluster is standalone or part of a complex
                pipeline, workload communications are defined by the application’s code. Any communication that’s not
                defined can be deemed suspicious at a minimum, and the source resource may have been compromised. By
                introducing fake workloads and services around production workloads, when a workload gets compromised,
                the attacker cannot differentiate between other real and fake workloads. The asymmetric knowledge
                between the attacker and the cluster operator makes it easy to detect lateral movement from compromised
                workloads.</p>
            <p><a data-type="xref" href="#sample_implementation_of_honeypots_in_a">Figure 11-3</a> shows
                an example of how this is achieved in a Kubernetes cluster.</p>
            <figure><div id="sample_implementation_of_honeypots_in_a" class="figure">
                <img src="Images/ksao_1103.png" alt="" width="1221" height="538"/>
                <h6><span class="label">Figure 11-3. </span>Sample implementation of honeypots in a Kubernetes cluster</h6>
            </div></figure>
            <p>Calico Enterprise has a honeypots feature that provides a supplementary<a contenteditable="false" data-type="indexterm" data-primary="Calico Enterprise" data-secondary="honeypots" id="idm45326824742384"/><a contenteditable="false" data-type="indexterm" data-primary="honeypots" id="idm45326824740928"/><a contenteditable="false" data-type="indexterm" data-primary="canary resources" data-secondary="honeypots" id="idm45326824739824"/> detection method when strict network policies or monitoring is
                not feasible. Calico Enterprise honeypots work by deploying canary workloads and services in sensitive
                namespaces and monitoring for access. By leveraging Calico Enterprise’s monitoring and alerting
                capabilities, any connections made to these canary workloads will generate an alert and can be traced
                back to the source. Canary traffic should be inspected using a DPI engine to provide signature-based
                detection to provide high-fidelity alerts and significantly reduce false positives.</p>
        </div></section>
        <section data-type="sect2" data-pdf-bookmark="DNS-Based Attacks and Defense"><div class="sect2" id="dns_based_attacks_and_defense">
            <h2>DNS-Based Attacks and Defense</h2>
            <p>When you look at activity in a Kubernetes cluster, DNS is critical<a contenteditable="false" data-type="indexterm" data-primary="threat defense" data-secondary="advanced techniques" data-tertiary="DNS-based attacks and defense" id="idm45326824735840"/><a contenteditable="false" data-type="indexterm" data-primary="DNS activity logs" data-secondary="DNS-based attacks and defense" id="idm45326824734048"/> to your applications that are running.
                Kubernetes supports DNS as an infrastructure, and DNS support is available for using DNS names for pods
                and services. <a contenteditable="false" data-type="indexterm" data-primary="CoreDNS server" id="idm45326824732320"/><a contenteditable="false" data-type="indexterm" data-primary="DNS server CoreDNS" id="idm45326824731216"/>CoreDNS is the recommended DNS server for your
                Kubernetes cluster. Since DNS is critical to cluster operation, DNS traffic needs to be allowed inside
                the cluster and even for external lookups. This makes DNS an attractive option for adversaries to
                target. <a contenteditable="false" data-type="indexterm" data-primary="domain generation algorithm attacks" id="idm45326824729664"/>In this section we will cover domain
                generation algorithm (DGA) attacks that are used by adversaries to establish a connection to their
                command-and-control center and then for exfiltration of data.</p>
            <p class="pagebreak-before"><a data-type="xref" href="#dga_based_attack">Figure 11-4</a> shows how a domain generation attack
                works. The adversary first downloads an exploit inside the cluster that uses a known seed and an
                algorithm to generate domain names. The exploit then queries the algorithm-generated domain names. The
                same algorithm is run to spin up a DNS server that responds to DNS queries, and this cycle repeats till
                the client and the server domains match. Upon a successful match, the cluster has established a
                successful connection to the command-and-control server for the malware.</p>
            <figure><div id="dga_based_attack" class="figure">
                <img src="Images/ksao_1104.png" alt="" width="905" height="351"/>
                <h6><span class="label">Figure 11-4. </span>DGA-based attack</h6>
            </div></figure>
            <p>Since domain names are generated randomly using an algorithm and the queries are legitimate DNS queries,
                it is not possible to detect these types of attacks using DNS threat feeds or at the perimeter using
                DPI. Also, the fact that there is a relatively large amount of DNS activity in the cluster means it is
                easy for the malware to hide its activity inside the cluster. The way to detect these types of attacks
                is to use a machine learning technique that can predict a malicious domain just by analyzing the domain
                name. Another mechanism that can be effective is to use machine learning to baseline the number of DNS
                responses that do not resolve to a valid server and report an anomaly if there is an increase in such
                failed DNS queries.</p>
            <p>You can implement a DGA detection mechanism by having the security research team collaborate with the
                data science team to build this mechanism. Calico Enterprise provides a DGA implementation integrated
                with its alerting engine.</p>
        </div></section>
    </div></section>
    <section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000016">
        <h1>Conclusion</h1>
        <p>In this chapter, we covered how you can implement threat defense in your Kubernetes cluster. The following
            are the key takeaways from the chapter:</p>
        <ul>
            <li>
                <p>The techniques presented are based on our current research, and this area is constantly evolving,
                    with adversaries using newer techniques and security teams working on solutions to counter these
                    threats. We recommend your security team focus on threats seen, analyze them to evaluate if they are
                    applicable to Kubernetes, and work on mitigation techniques.</p>
            </li>
            <li>
                <p>Kubernetes is a new technology, and we are starting to see it become a focus area for adversaries, so
                    an effective threat defense strategy is required.</p>
            </li>
            <li>
                <p>It’s very important to understand the cybersecurity kill chain and how it applies to Kubernetes in
                    order to build an effective threat defense strategy.</p>
            </li>
            <li>
                <p>It is important for you to apply threat feeds and DPI-based techniques to traffic inside your cluster
                    to detect attacks that originate inside the cluster. It is not adequate to rely on these techniques
                    being applied only at the perimeter, as traffic originating inside the cluster may not traverse
                    through devices at the perimeter.</p>
            </li>
            <li>
                <p>Honeypots and DGA-based attacks are examples of advanced threat defense techniques for your
                    Kubernetes cluster that you should implement to thwart sophisticated attacks.</p>
            </li>
        </ul>
    </div></section>
</div></section></div></body></html>