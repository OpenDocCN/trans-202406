<html><head></head><body><section data-pdf-bookmark="Chapter 11. Interoperating with JavaScript" data-type="chapter" epub:type="chapter"><div class="chapter" id="javascript">&#13;
<h1><span class="label">Chapter 11. </span>Interoperating with JavaScript</h1>&#13;
&#13;
&#13;
<p>We don’t live in a perfect world.<a data-primary="JavaScript" data-secondary="interoperating with" data-type="indexterm" id="ix_JSinter"/> Your coffee can be too hot and burn your mouth a little when you drink it, your parents might call and leave you voicemails a little too often, that pothole by your driveway is still there no matter how many times you call the city, and your code might not be completely covered with static types.</p>&#13;
&#13;
<p>Most of us are in this boat: though once in a while you’ll have the leeway to start a greenfield project in TypeScript, most of the time it will start as a little island of safety, embedded in a larger, less safe codebase. Maybe you have a well-isolated component that you want to try TypeScript on even though your company uses regular ES6 JavaScript everywhere else, or maybe you’re fed up with getting paged at 6 A.M. because you refactored some code and forgot to update a call site (it’s now 7 A.M., and you’re ninja-merging TSC into your codebase before your coworkers wake up). Either way, you will probably start with an island of TypeScript in a type-less sea.</p>&#13;
&#13;
<p>So far in this book I’ve been teaching you to write TypeScript the right way. This chapter is about writing TypeScript the practical way, in real codebases that are in the process of migrating away from untyped languages, that use third-party JavaScript libraries, that at times sacrifice type safety for a quick hot patch to unbreak prod. This chapter is dedicated to working with JavaScript. We’ll explore:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Using type declarations</p>&#13;
</li>&#13;
<li>&#13;
<p>Gradually migrating from JavaScript to TypeScript</p>&#13;
</li>&#13;
<li>&#13;
<p>Using third-party JavaScript and TypeScript</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type Declarations" data-type="sect1"><div class="sect1" id="type-declarations">&#13;
<h1>Type Declarations</h1>&#13;
&#13;
<p>A <em>type declaration</em> is a file with the extension <em>.d.ts</em>. Along with JSDoc annotations (see <a data-type="xref" href="#step-2b-jsdoc">“Step 2b: Add JSDoc Annotations (Optional)”</a>), it’s a way to attach TypeScript types to JavaScript code that would otherwise be untyped.<a data-primary=".d.ts file extension (type declarations)" data-primary-sortas="d.ts" data-type="indexterm" id="idm46304951863608"/><a data-primary="JavaScript" data-secondary="interoperating with" data-tertiary="using type declarations" data-type="indexterm" id="ix_JSintertypdec"/><a data-primary="type declarations" data-type="indexterm" id="ix_typdec"/></p>&#13;
&#13;
<p>Type declarations have a similar syntax to regular TypeScript, with a few differences:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Type declarations can only contain types, and can’t contain values. That means no function, class, object, or variable implementations, and no default values for parameters.<a data-primary="type declarations" data-secondary="differences from regular TypeScript syntax" data-type="indexterm" id="idm46304951858472"/><a data-primary="values" data-secondary="type declarations and" data-type="indexterm" id="idm46304951857464"/></p>&#13;
</li>&#13;
<li>&#13;
<p>While type declarations can’t define values, they can declare that there <em>exists</em> a value defined somewhere in your JavaScript. We use the special <code>declare</code> keyword for this.<a data-primary="declare keyword" data-type="indexterm" id="idm46304951854776"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Type declarations only declare types for things that are visible to consumers. We don’t include things like types that aren’t exported, or types for local variables inside of function bodies.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s jump into an example, and take a look at a piece of TypeScript (<em>.ts</em>) code and its equivalent type declaration (<em>.d.ts</em>). <a data-primary="type declarations" data-secondary="example with equivalent TypeScript code" data-type="indexterm" id="idm46304951851496"/>This example is a fairly involved piece of code from the popular RxJS library; feel free to gloss over the details of what it’s doing, and instead pay attention to which language features it’s using (imports, classes, interfaces, class fields, function overloads, and so on):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code><code class="nx">Subscriber</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'./Subscriber'</code>&#13;
<code class="kr">import</code> <code class="p">{</code><code class="nx">Subscription</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'./Subscription'</code>&#13;
<code class="kr">import</code> <code class="p">{</code><code class="nx">PartialObserver</code><code class="p">,</code> <code class="nx">Subscribable</code><code class="p">,</code> <code class="nx">TeardownLogic</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'./types'</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">Observable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">implements</code> <code class="nx">Subscribable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">public</code> <code class="nx">_isScalar</code>: <code class="kt">boolean</code> <code class="o">=</code> <code class="kc">false</code>&#13;
  <code class="kr">constructor</code><code class="p">(</code>&#13;
    <code class="nx">subscribe</code><code class="o">?:</code> <code class="p">(</code>&#13;
      <code class="k">this</code><code class="o">:</code> <code class="nx">Observable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code>&#13;
      <code class="nx">subscriber</code>: <code class="kt">Subscriber</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code>&#13;
    <code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">TeardownLogic</code>&#13;
  <code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">subscribe</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">this</code><code class="p">.</code><code class="nx">_subscribe</code> <code class="o">=</code> <code class="nx">subscribe</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="kr">static</code> <code class="nx">create</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">subscribe</code><code class="o">?:</code> <code class="p">(</code><code class="nx">subscriber</code>: <code class="kt">Subscriber</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">TeardownLogic</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Observable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">subscribe</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">subscribe</code><code class="p">(</code><code class="nx">observer?</code>: <code class="kt">PartialObserver</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="nx">Subscription</code>&#13;
  <code class="nx">subscribe</code><code class="p">(</code>&#13;
    <code class="nx">next</code><code class="o">?:</code> <code class="p">(</code><code class="nx">value</code>: <code class="kt">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">,</code>&#13;
    <code class="nx">error</code><code class="o">?:</code> <code class="p">(</code><code class="nx">error</code>: <code class="kt">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">,</code>&#13;
    <code class="nx">complete</code><code class="o">?:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="nx">Subscription</code>&#13;
  <code class="nx">subscribe</code><code class="p">(</code>&#13;
    <code class="nx">observerOrNext?</code>: <code class="kt">PartialObserver</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">|</code> <code class="p">((</code><code class="nx">value</code>: <code class="kt">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">),</code>&#13;
    <code class="nx">error</code><code class="o">?:</code> <code class="p">(</code><code class="nx">error</code>: <code class="kt">any</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">,</code>&#13;
    <code class="nx">complete</code><code class="o">?:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="nx">Subscription</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Running this code through <a data-primary="TSC compiler" data-secondary="declarations flag" data-type="indexterm" id="idm46304951848008"/>TSC with the <code>declarations</code> flag enabled (<code>tsc -d Observable.ts</code>) yields the following <em>Observable.d.ts</em> type declaration:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code><code> </code><code class="p">{</code><code class="nx">Subscriber</code><code class="p">}</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'./Subscriber'</code><code>&#13;
</code><code class="kr">import</code><code> </code><code class="p">{</code><code class="nx">Subscription</code><code class="p">}</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'./Subscription'</code><code>&#13;
</code><code class="kr">import</code><code> </code><code class="p">{</code><code class="nx">PartialObserver</code><code class="p">,</code><code> </code><code class="nx">Subscribable</code><code class="p">,</code><code> </code><code class="nx">TeardownLogic</code><code class="p">}</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'./types'</code><code>&#13;
&#13;
</code><code class="kr">export</code><code> </code><code class="kr">declare</code><code> </code><code class="kr">class</code><code> </code><code class="nx">Observable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="kr">implements</code><code> </code><code class="nx">Subscribable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_interoperating_with_javascript_CO1-1" id="co_interoperating_with_javascript_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">_isScalar</code><code>: </code><code class="kt">boolean</code><code>&#13;
  </code><code class="kr">constructor</code><code class="p">(</code><code>&#13;
    </code><code class="nx">subscribe</code><code class="o">?</code><code class="o">:</code><code> </code><code class="p">(</code><code>&#13;
      </code><code class="k">this</code><code class="o">:</code><code> </code><code class="nx">Observable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code><code>&#13;
      </code><code class="nx">subscriber</code><code>: </code><code class="kt">Subscriber</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code>&#13;
    </code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">TeardownLogic</code><code>&#13;
  </code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="kr">static</code><code> </code><code class="nx">create</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code>&#13;
    </code><code class="nx">subscribe</code><code class="o">?</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">subscriber</code><code>: </code><code class="kt">Subscriber</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">TeardownLogic</code><code>&#13;
  </code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Observable</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code>&#13;
  </code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">observer?</code><code>: </code><code class="kt">PartialObserver</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Subscription</code><code>&#13;
  </code><code class="nx">subscribe</code><code class="p">(</code><code>&#13;
    </code><code class="nx">next</code><code class="o">?</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code class="p">,</code><code>&#13;
    </code><code class="nx">error</code><code class="o">?</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">error</code><code>: </code><code class="kt">any</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code class="p">,</code><code>&#13;
    </code><code class="nx">complete</code><code class="o">?</code><code class="o">:</code><code> </code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code>&#13;
  </code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Subscription</code><code> </code><a class="co" href="#callout_interoperating_with_javascript_CO1-2" id="co_interoperating_with_javascript_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_interoperating_with_javascript_CO1-1" id="callout_interoperating_with_javascript_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Notice the <code>declare</code> keyword before <code>class</code>. <a data-primary="declare keyword" data-type="indexterm" id="idm46304951538968"/>We can’t actually define a class in a type declaration, but we can <em>declare</em> that we defined a class in the <em>.d.ts</em> file’s corresponding JavaScript file.<a data-primary="classes" data-secondary="declaring, type declarations and" data-type="indexterm" id="idm46304951537304"/> Think of <code>declare</code> like an affirmation: “I swear that my JavaScript exports a class of this type.”</p></dd>&#13;
<dt><a class="co" href="#co_interoperating_with_javascript_CO1-2" id="callout_interoperating_with_javascript_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Because type declarations don’t contain implementations, we only keep the two overloads for <code>subscribe</code>, and not the signature for its implementation.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Notice how <em>Observable.d.ts</em> is just <em>Observable.ts</em>, minus the implementations. In other words, it’s just the types from <em>Observable.ts</em>.</p>&#13;
&#13;
<p>This type declaration isn’t useful to other files in the RxJS library that use <em>Observable.ts</em>, since they have access to the <em>Observable.ts</em> source TypeScript file itself and can use it directly. It is useful, however, if you consume RxJS in your TypeScript <span class="keep-together">application</span>.</p>&#13;
&#13;
<p>Think about it: if the authors of RxJS wanted to package in typing information on NPM for their TypeScript-wielding users (RxJS can be used in both TypeScript and JavaScript applications), they would have two options: package <em>both</em> source TypeScript files (for TypeScript users) and compiled JavaScript files (for JavaScript users), or ship compiled JavaScript files along with type declarations for TypeScript users. The latter reduces the file size, and makes it unambiguous what the correct import to use is. It also helps keep compile times for your application fast, since your TSC instance doesn’t have to recompile RxJS every time you compile your own app (in fact, it’s the reason the optimization strategy we introduce in <a data-type="xref" href="ch12.html#improving-compile-times">“Project References”</a> works!).</p>&#13;
&#13;
<p>Type declaration files have a few uses:</p>&#13;
<ol>&#13;
<li>&#13;
<p>When someone else uses your compiled TypeScript from their TypeScript application, their TSC instance will look for <em>.d.ts</em> files corresponding to your generated JavaScript files. <a data-primary="type declarations" data-secondary="uses of type declaration files" data-type="indexterm" id="idm46304951267304"/>This tells TypeScript what the types are for your project.</p>&#13;
</li>&#13;
<li>&#13;
<p>Code editors with TypeScript support (like VSCode) will read these <em>.d.ts</em> files to give your users helpful type hints as they type, even if they don’t use TypeScript.</p>&#13;
</li>&#13;
<li>&#13;
<p>They speed up compile times significantly by avoiding unnecessarily re-compiling your TypeScript code.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>A type declaration is a way to tell TypeScript, “There exists this thing that’s defined in JavaScript, and I’m going to describe it to you.” When we talk about type declarations, we often call them <em>ambient</em> in order to differentiate them from regular declarations that contain values; for example,<a data-primary="variables" data-secondary="ambient versus regular declarations" data-type="indexterm" id="idm46304951262152"/> an <em>ambient variable declaration</em> uses the <code>declare</code> keyword to declare that a variable is defined somewhere in JavaScript, while a regular nonambient variable declaration is a normal <code>let</code> or <code>const</code> declaration that declares a variable without using the <code>declare</code> keyword.</p>&#13;
&#13;
<p>You can use type declarations for a few things:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>To tell TypeScript about a global variable that’s defined in JavaScript somewhere. For example, if you polyfilled the <code>Promise</code> global or defined <code>process.env</code> in a browser environment, you might use an <em>ambient variable declaration</em> to give TypeScript a heads-up.</p>&#13;
</li>&#13;
<li>&#13;
<p>To define a type that’s globally available everywhere in your project, so to use it you don’t have to import it first (we call this an ambient type declaration).</p>&#13;
</li>&#13;
<li>&#13;
<p>To tell TypeScript about a third-party module that you installed with NPM (an <em>ambient module declaration</em>).<a data-primary="modules" data-secondary="telling TypeScript about a third-party module installed with NPM" data-type="indexterm" id="idm46304951440568"/></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>A type declaration, regardless of what you’re using it for, has to live in a script-mode <em>.ts</em> or <em>.d.ts</em> file (recall our earlier discussion of script mode in <a data-type="xref" href="ch10.html#module-mode">“Module Mode Versus Script Mode”</a>). <a data-primary="script mode versus module mode" data-secondary="script mode for type declarations" data-type="indexterm" id="idm46304951436952"/>By convention, we give our file a <em>.d.ts</em> extension if it has a corresponding <em>.js</em> file; otherwise, we use a <em>.ts</em> extension. It doesn’t matter what you call the file—for example, I like to stick to a single top-level <em>types.ts</em> until it gets unwieldy—and a single type declaration file can contain as many type declarations as you want.</p>&#13;
&#13;
<p>Finally, while top-level values in a type declaration file need the <code>declare</code> keyword (<code>declare let</code>, <code>declare function</code>, <code>declare class</code>, and so on), top-level types and interfaces do not.<a data-primary="types" data-secondary="top-level, in type declaration files" data-type="indexterm" id="idm46304951611208"/><a data-primary="interfaces" data-secondary="top-level, in type declaration files" data-type="indexterm" id="idm46304951610264"/><a data-primary="values" data-secondary="top-level, in type declaration files" data-type="indexterm" id="idm46304951609304"/></p>&#13;
&#13;
<p>With those ground rules out of the way, let’s briefly look at some examples of each kind of type declaration.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ambient Variable Declarations" data-type="sect2"><div class="sect2" id="idm46304951607960">&#13;
<h2>Ambient Variable Declarations</h2>&#13;
&#13;
<p>An ambient variable declaration is a way to tell TypeScript about a global variable that can be used in any <em>.ts</em> or <em>.d.ts</em> file in your project without explicitly importing it first.<a data-primary="variables" data-secondary="ambient variable declarations" data-type="indexterm" id="idm46304951605272"/><a data-primary="ambient variable declarations" data-type="indexterm" id="idm46304951604232"/><a data-primary="type declarations" data-secondary="ambient variable declarations" data-type="indexterm" id="idm46304951603544"/></p>&#13;
&#13;
<p>Let’s say you’re running a NodeJS program in your browser, and the program checks <code>process.env.NODE_ENV</code> (which is either <code>"development"</code> or <code>"production"</code>) at some point. When you run the program, you get an ugly runtime error:</p>&#13;
&#13;
<pre data-type="programlisting">Uncaught ReferenceError: process is not defined.</pre>&#13;
&#13;
<p>You sleuth around Stack Overflow a bit, and realize that the quickest hack to get your program running is to polyfill <code>process.env.NODE_ENV</code> yourself and hardcode it. <a data-primary="polyfills" data-secondary="for process.env.NODE_ENV" data-type="indexterm" id="idm46304951599240"/>So you create a new file, <em>polyfills.ts</em>, and define a global <code>process.env</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">process</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">env</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">NODE_ENV</code><code class="o">:</code> <code class="s1">'production'</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Of course, TypeScript then comes to the rescue, throwing a red squiggly at you to try to save you from t<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2304" data-type="indexterm" id="idm46304951411112"/>he mistake you’re clearly making by augmenting the <code>window</code> global:</p>&#13;
&#13;
<pre data-type="programlisting">Error TS2304: Cannot find name 'process'.</pre>&#13;
&#13;
<p>But in this case, TypeScript is being overprotective. You really do want to augment <code>window</code>, and you want to do it safely.</p>&#13;
&#13;
<p class="pagebreak-before">So what do you do? You pop open <em>polyfills.ts</em> in Vim (you see where this is going) and type:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<strong><code class="kr">declare</code><code> </code><code class="kd">let</code><code> </code><code class="nx">process</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">env</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">NODE_ENV</code><code class="o">:</code><code> </code><code class="s1">'development'</code><code> </code><code class="o">|</code><code> </code><code class="s1">'production'</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></strong><code>&#13;
&#13;
</code><code class="nx">process</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">env</code><code class="o">:</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">NODE_ENV</code><code class="o">:</code><code> </code><code class="s1">'production'</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>You’re declaring to TypeScript that there’s a global object <code>process</code> that has a single property <code>env</code>, that has a property <code>NODE_ENV</code>. Once you tell TypeScript about that, the red squiggly disappears and you can safely define your <code>process</code> global.</p>&#13;
<div data-type="tip"><h1>TSC Setting: lib</h1>&#13;
<p>TypeScript comes with a set of type declarations for describing the JavaScript standard library that includes<a data-primary="lib setting (TSC)" data-type="indexterm" id="idm46304951353416"/><a data-primary="TSC compiler" data-secondary="lib setting" data-type="indexterm" id="idm46304951352712"/> built-in JavaScript types, like <code>Array</code> and <code>Promise</code>, and methods on built-in types, like <code>''.toUpperCase</code>. It also includes global objects like <code>window</code> and <code>document</code> (in a browser environment), and <code>onmessage</code> (in a Web Worker environment).</p>&#13;
&#13;
<p>You can pull in TypeScript’s built-in type declarations using your <em>tsconfig.json</em>’s <code>lib</code> field. Jump ahead to <a data-type="xref" href="ch12.html#lib">“lib”</a> for a deep dive into how to dial in your project’s <code>lib</code> setting.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ambient Type Declarations" data-type="sect2"><div class="sect2" id="ambient-type-declarations">&#13;
<h2>Ambient Type Declarations</h2>&#13;
&#13;
<p>Ambient type declarations follow the same rules as ambient variable declarations: the declaration has to live in a script-mode <em>.ts</em> or <em>.d.ts</em> file, and it’ll be available globally to the other files in your project without an explicit import.<a data-primary="ambient type declarations" data-type="indexterm" id="idm46304951223400"/><a data-primary="type declarations" data-secondary="ambient type declarations" data-type="indexterm" id="idm46304951222792"/> For example, let’s declare a global utility type <code>ToArray&lt;T&gt;</code> that lifts <code>T</code> to an array, if it isn’t an array already. We can define this type in any script-mode file in our project—for this example, let’s define it in a top-level <em>types.ts</em> file:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">ToArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="nx">unknown</code><code class="p">[]</code> <code class="o">?</code> <code class="nx">T</code> : <code class="kt">T</code><code class="p">[]</code></pre>&#13;
&#13;
<p>We can now use this type from any project file, without an explicit import:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">toArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">ToArray</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Consider using ambient type declarations to model data types that are used throughout your application. For example, you might use them to make the <code>UserID</code> type we developed in <a data-type="xref" href="ch06.html#nominal-types">“Simulating Nominal Types”</a> globally available:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">UserID</code> <code class="o">=</code> <code class="kt">string</code> <code class="o">&amp;</code> <code class="p">{</code><code class="nx">readonly</code> <code class="nx">brand</code>: <code class="kt">unique</code> <code class="nx">symbol</code><code class="p">}</code></pre>&#13;
&#13;
<p>Now, you can use <code>UserID</code> anywhere in your application without having to explicitly import it first.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Ambient Module Declarations" data-type="sect2"><div class="sect2" id="idm46304951154168">&#13;
<h2>Ambient Module Declarations</h2>&#13;
&#13;
<p>When you consume a JavaScript module and want <a data-primary="ambient module declarations" data-type="indexterm" id="idm46304951152536"/><a data-primary="type declarations" data-secondary="ambient module declarations" data-type="indexterm" id="idm46304951151864"/><a data-primary="modules" data-secondary="ambient module declarations" data-type="indexterm" id="idm46304951150952"/>to quickly declare some types for it so you can use it safely—without having to contribute the type declarations back to the JavaScript module’s GitHub repository or DefinitelyTyped first—ambient module declarations are the tool to use.</p>&#13;
&#13;
<p>An ambient module declaration is a regular type declaration,<a data-primary="declare module syntax" data-type="indexterm" id="idm46304951119048"/> surrounded by a special <code>declare module</code> syntax:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'module-name'</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="nx">type</code> <code class="nx">MyType</code> <code class="o">=</code> <code class="kt">number</code>&#13;
  <code class="kr">export</code> <code class="nx">type</code> <code class="nx">MyDefaultType</code> <code class="o">=</code> <code class="p">{</code><code class="nx">a</code>: <code class="kt">string</code><code class="p">}</code>&#13;
  <code class="kr">export</code> <code class="kd">let</code> <code class="nx">myExport</code>: <code class="kt">MyType</code>&#13;
  <code class="kd">let</code> <code class="nx">myDefaultExport</code>: <code class="kt">MyDefaultType</code>&#13;
  <code class="kr">export</code> <code class="k">default</code> <code class="nx">myDefaultExport</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>A module name (<code>'module-name'</code> in this example) corresponds to an exact <code>import</code> path.<a data-primary="imports" data-secondary="module name for exact import path" data-type="indexterm" id="idm46304951069496"/> When you import that path, your ambient module declaration tells TypeScript what’s available:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="nx">ModuleName</code> <code class="nx">from</code> <code class="s1">'module-name'</code>&#13;
<code class="nx">ModuleName</code><code class="p">.</code><code class="nx">a</code>  <code class="c1">// string</code></pre>&#13;
&#13;
<p>If you have a nested module, make sure you include the whole <code>import</code> path in its declaration:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'@most/core'</code> <code class="p">{</code>&#13;
  <code class="c1">// Type declaration</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you just want to quickly tell TypeScript “I’m importing this module—I’ll type it later, just assume it’s an <code>any</code> for now,” keep the header but omit the actual declaration:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Declare a module that can be imported, where each of its imports are any</code>&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'unsafe-module-name'</code></pre>&#13;
&#13;
<p>Now if you consume this module, it’s less safe:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code><code class="nx">x</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'unsafe-module-name'</code>&#13;
<code class="nx">x</code>  <code class="c1">// any</code></pre>&#13;
&#13;
<p>Module declarations support wildcard imports,<a data-primary="ambient module declarations" data-secondary="wildcard" data-type="indexterm" id="idm46304950959368"/> so you can give a type to any <code>import</code> path that matches the given pattern. Use a wildcard (<code>*</code>) to match an <code>import</code> path:<sup><a data-type="noteref" href="ch11.html#idm46304950957208" id="idm46304950957208-marker">1</a></sup></p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Type JSON files imported with Webpack's json-loader</code>&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'json!*'</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">value</code>: <code class="kt">object</code>&#13;
  <code class="kr">export</code> <code class="k">default</code> <code class="nx">value</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Type CSS files imported with Webpack's style-loader</code>&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'*.css'</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">css</code>: <code class="kt">CSSRuleList</code>&#13;
  <code class="kr">export</code> <code class="k">default</code> <code class="nx">css</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, you can load JSON and CSS files:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="nx">a</code> <code class="nx">from</code> <code class="s1">'json!myFile'</code>&#13;
<code class="nx">a</code>  <code class="c1">// object</code>&#13;
&#13;
<code class="kr">import</code> <code class="nx">b</code> <code class="nx">from</code> <code class="s1">'./widget.css'</code>&#13;
<code class="nx">b</code>  <code class="c1">// CSSRuleList</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For the last two examples to work, you’ll need to configure your build system to load <em>.json</em> and <em>.css</em> files.<a data-primary="JSON (JavaScript Object Notation)" data-secondary="loading .json files" data-type="indexterm" id="idm46304950843816"/><a data-primary="CSS files, loading" data-type="indexterm" id="idm46304950842840"/> You can declare to TypeScript that these path patterns are safe to import, but TypeScript won’t be able to build them by itself.</p>&#13;
</div>&#13;
&#13;
<p>Jump ahead to <a data-type="xref" href="#writing-3rd-party-typings">“JavaScript That Doesn’t Have Type Declarations on DefinitelyTyped”</a> for an example of how to use ambient module declarations to declare types for untyped third-party JavaScript.<a data-primary="type declarations" data-startref="ix_typdec" data-type="indexterm" id="idm46304950840424"/><a data-primary="JavaScript" data-secondary="interoperating with" data-startref="ix_JSintertypdec" data-tertiary="using type declarations" data-type="indexterm" id="idm46304950839480"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Gradually Migrating from JavaScript to TypeScript" data-type="sect1"><div class="sect1" id="migrating-to-typescript">&#13;
<h1>Gradually Migrating from JavaScript to TypeScript</h1>&#13;
&#13;
<p>TypeScript was designed with JavaScript interoperability in mind, not as an afterthought.<a data-primary="TypeScript" data-secondary="gradually migrating JavaScript code to" data-type="indexterm" id="ix_TSmigJS"/><a data-primary="JavaScript" data-secondary="interoperating with" data-tertiary="gradually migrating code to TypeScript" data-type="indexterm" id="ix_JSintermig"/> So while it’s not painless, migrating to TypeScript is a good experience, letting you convert your codebase over a file at a time, opting into stricter levels of safety as you migrate, showing your boss and your coworkers just how impactful statically typing your code can be, one commit at a time.</p>&#13;
&#13;
<p>At a high level, here’s where you want to end up: your codebase should be completely written in TypeScript with strict type coverage, and third-party JavaScript libraries you depend on should come with high-quality, strict types of their own. Any bugs that could be caught at compile time are, and TypeScript’s rich autocompletion halves the time it takes to write each line of code. You might have to take a few baby steps to get there:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Add TSC to your project.</p>&#13;
</li>&#13;
<li>&#13;
<p>Start typechecking your existing JavaScript code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Migrate your JavaScript code to TypeScript, a file at a time.</p>&#13;
</li>&#13;
<li>&#13;
<p>Install type declarations for your dependencies, either stubbing out types for dependencies that don’t have types or writing type declarations for untyped dependencies and contributing them back to DefinitelyTyped.<sup><a data-type="noteref" href="ch11.html#idm46304950868968" id="idm46304950868968-marker">2</a></sup></p>&#13;
</li>&#13;
<li>&#13;
<p>Flip on <code>strict</code> mode for your codebase.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This process can take a while, but you will see safety and productivity gains right away, and uncover more gains as you keep going. Let’s walk through the steps one at a time.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 1: Add TSC" data-type="sect2"><div class="sect2" id="idm46304950866152">&#13;
<h2>Step 1: Add TSC</h2>&#13;
&#13;
<p>When working on a codebase that combines TypeScript and JavaScript, start by letting TSC compile JavaScript files alongside your TypeScript.<a data-primary="allowJs TSC flag" data-type="indexterm" id="idm46304950864424"/><a data-primary="TypeScript" data-secondary="gradually migrating JavaScript code to" data-tertiary="adding TSC to JavaScript projects" data-type="indexterm" id="idm46304950863720"/><a data-primary="TSC compiler" data-secondary="compiling JavaScript code" data-type="indexterm" id="idm46304950813528"/> In your <em>tsconfig.json</em>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
  <code class="nt">"allowJs"</code><code class="p">:</code> <code class="kc">true</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>With this one change, you can now use TSC to compile your JavaScript. Just add TSC to your build process, and either run every existing JavaScript file through TSC,<sup><a data-type="noteref" href="ch11.html#idm46304950805784" id="idm46304950805784-marker">3</a></sup> or continue running legacy JavaScript files through your existing build process and run new TypeScript files through TSC.</p>&#13;
&#13;
<p>With <code>allowJs</code> set to <code>true</code>, TypeScript won’t typecheck your existing JavaScript code, but it will transpile it (to ES3, ES5, or whatever <code>target</code> is set to in your <em>tsconfig.json</em>) using the module system you asked for (in your <em>tsconfig.json</em>’s <code>module</code> field). <a data-primary="modules" data-secondary="module field in tsconfig.json" data-type="indexterm" id="idm46304950800808"/>First step, done. Commit it, and give yourself a pat on the back—your codebase now uses TypeScript!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 2a: Enable Typechecking for JavaScript (Optional)" data-type="sect2"><div class="sect2" id="idm46304950796376">&#13;
<h2>Step 2a: Enable Typechecking for JavaScript (Optional)</h2>&#13;
&#13;
<p>Now that TSC is processing your JavaScript, why not typecheck it too?<a data-primary="typechecking" data-secondary="JavaScript code" data-type="indexterm" id="idm46304950794712"/><a data-primary="TypeScript" data-secondary="gradually migrating JavaScript code to" data-tertiary="enabling typechecking for JavaScript" data-type="indexterm" id="idm46304950793736"/><a data-primary="TSC compiler" data-secondary="checkJs flag" data-type="indexterm" id="idm46304950792584"/><a data-primary="checkJs TSC flag" data-type="indexterm" id="idm46304950791640"/> While you might not have explicit type annotations in your JavaScript, remember how great TypeScript is at inferring types for you; it can infer types in your JavaScript the same way it does in your TypeScript code. Enable this in your <em>tsconfig.json</em>:</p>&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
  <code class="nt">"allowJs"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nt">"checkJs"</code><code class="p">:</code> <code class="kc">true</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>Now, whenever TypeScript compiles a JavaScript file it’ll do its best to infer types and typecheck as it goes, like it does for regular TypeScript code.</p>&#13;
&#13;
<p>If your codebase is big and flipping on <code>checkJs</code> reports too many type errors at once, turn it off, and instead enable checking for a JavaScript file at a time by adding the <code>// @ts-check</code> directive (a regular comment at the top of the file).<a data-primary="@ts-check comment" data-type="indexterm" id="idm46304950757560"/> Or, if a few big files are throwing the bulk of your errors and you don’t want to fix them just yet, keep <code>checkJs</code> on and add the <code>// @ts-nocheck</code> directive to just those files.<a data-primary="@ts-nocheck comment" data-type="indexterm" id="idm46304950753176"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Because TypeScript can’t <a data-primary="type inference" data-secondary="types in JavaScript code" data-type="indexterm" id="idm46304950751400"/>infer everything (e.g., function parameter types), it will infer a lot of types in your JavaScript code as <code>any</code>.<a data-primary="any type" data-secondary="JavaScript types inferred as" data-type="indexterm" id="idm46304950749816"/><a data-primary="noImplicitAny flag in tsconfig.sh" data-type="indexterm" id="idm46304950748840"/><a data-primary="TSC compiler" data-secondary="enabling noImplicitAny flag" data-type="indexterm" id="idm46304950748152"/><a data-primary="strict mode (TSC)" data-type="indexterm" id="idm46304950747192"/> If you have <code>strict</code> mode enabled in your <em>tsconfig.json</em> (you should!), you may want to temporarily allow implicit <code>any</code>s while you migrate. In your <em>tsconfig.json</em>, add:</p>&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
  <code class="nt">"allowJs"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nt">"checkJs"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nt">"noImplicitAny"</code><code class="p">:</code> <code class="kc">false</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>Don’t forget to turn <code>noImplicitAny</code> on again when you’ve migrated a critical mass of code to TypeScript! It will probably reveal a bunch of real errors that you missed (unless, of course, you’re Xenithar, disciple of Bathmorda the JavaScript witch, able to typecheck in your mind’s eye with the help of nothing but a cauldronful of mugwort).</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">When TypeScript runs over JavaScript code, it uses a more lenient inference algorithm than it does for TypeScript code.<a data-primary="parameters" data-secondary="optional function parameters in type inference on JavaScript" data-type="indexterm" id="idm46304950701912"/><a data-primary="properties" data-secondary="type inference on JavaScript code" data-type="indexterm" id="idm46304950701000"/> Specifically:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>All function parameters are optional.</p>&#13;
</li>&#13;
<li>&#13;
<p>The types of properties on functions and classes are inferred from usage (rather than having to be declared up front):</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"> <code class="kr">class</code> <code class="nx">A</code> <code class="p">{</code>&#13;
   <code class="nx">x</code> <code class="o">=</code> <code class="mi">0</code> <code class="c1">// number | string | string[], inferred from usage</code>&#13;
   <code class="nx">method() {</code>&#13;
     <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="s1">'foo'</code>&#13;
   <code class="p">}</code>&#13;
   <code class="nx">otherMethod() {</code>&#13;
     <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="p">[</code><code class="s1">'array'</code><code class="p">,</code> <code class="s1">'of'</code><code class="p">,</code> <code class="s1">'strings'</code><code class="p">]</code>&#13;
   <code class="p">}</code>&#13;
 <code class="p">}</code></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>After declaring an object, class, or function, you can assign extra properties to it. Under the hood, TypeScript does this by generating a corresponding namespace for each class and function declaration, and automatically adding an index signature to every object literal.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 2b: Add JSDoc Annotations (Optional)" data-type="sect2"><div class="sect2" id="step-2b-jsdoc">&#13;
<h2>Step 2b: Add JSDoc Annotations (Optional)</h2>&#13;
&#13;
<p>Maybe you’re in a hurry, and just need to add a single type annotation for a new function you added to an old JavaScript file.<a data-primary="TypeScript" data-secondary="gradually migrating JavaScript code to" data-tertiary="adding JSDoc annotations" data-type="indexterm" id="idm46304950642248"/><a data-primary="JSDoc annotations" data-type="indexterm" id="idm46304950641064"/> Until you get a chance to convert that file to TypeScript, you can use a JSDoc annotation to type your new function.</p>&#13;
&#13;
<p>You’ve probably seen JSDoc before; it’s those funny-looking comments above some JavaScript and TypeScript code with <code>@</code>-annotations like <code>@param</code>, <code>@returns</code>, and so on. TypeScript understands JSDoc, and uses it as input to its typechecker the same way that it uses explicit type annotations in TypeScript code.</p>&#13;
&#13;
<p>Let’s say you have a 3,000-line utilities file (yes, I know your “friend” wrote it). You add a new utility function to it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">export</code> <code class="kd">function</code> <code class="nx">toPascalCase</code><code class="p">(</code><code class="nx">word</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">word</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code>&#13;
    <code class="sr">/\w+/g</code><code class="p">,</code>&#13;
    <code class="p">([</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">b</code><code class="p">])</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code> <code class="o">+</code> <code class="nx">b</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">''</code><code class="p">).</code><code class="nx">toLowerCase</code><code class="p">()</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Without converting <em>utils.js</em> to TypeScript full sail—which would probably catch a bunch of bugs you’d then have to fix—you can annotate just your <code>toPascalCase</code> function, carving out a little island of safety in a sea of untyped JavaScript:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<em><code class="cm">/**&#13;
 * @param word {string} An input string to convert&#13;
 * @returns {string} The string in PascalCase&#13;
 */</code></em><code>&#13;
</code><code class="kr">export</code><code> </code><code class="kd">function</code><code> </code><code class="nx">toPascalCase</code><code class="p">(</code><code class="nx">word</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">word</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code>&#13;
    </code><code class="sr">/\w+/g</code><code class="p">,</code><code>&#13;
    </code><code class="p">(</code><code class="p">[</code><code class="nx">a</code><code class="p">,</code><code> </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">b</code><code class="p">]</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">a</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">+</code><code> </code><code class="nx">b</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s1">''</code><code class="p">)</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">(</code><code class="p">)</code><code>&#13;
  </code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Without that JSDoc annotation, TypeScript would have inferred <code>toPascalCase</code>’s type as <code>(word: any) =&gt; string</code>. Now, when TypeScript compiles your code it knows <code>toPascalCase</code>’s type is <code>(word: string) =&gt; string</code>. And you got some nice documentation out of it!</p>&#13;
&#13;
<p>Head over to the <a href="http://bit.ly/2YCTWBf">TypeScript Wiki</a> to learn more about supported JSDoc annotations.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 3: Rename Your Files to .ts" data-type="sect2"><div class="sect2" id="idm46304950643896">&#13;
<h2>Step 3: Rename Your Files to .ts</h2>&#13;
&#13;
<p>Once you’ve added TSC to your build process, and optionally started typechecking and annotating JavaScript where possible, it’s time to start switching over to TypeScript.<a data-primary="TypeScript" data-secondary="gradually migrating JavaScript code to" data-tertiary="renaming files to .ts" data-type="indexterm" id="idm46304950478264"/></p>&#13;
&#13;
<p>One file at a time, update your files’ extensions from <em>.js</em> (or <em>.coffee</em>, <em>.es6</em>, etc.) to <em>.ts</em>. As soon as you rename a file in your code editor, you’ll see your friends the red squigglies appear (the TypeError, not the kids’ TV show), uncovering type errors, missed cases, forgotten <code>null</code> checks, and misspelled variable names. There are two strategies for fixing these errors:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Do it right. Take your time to type shapes, fields, and functions correctly, so you can catch errors in all the files that consume them. If you have <code>checkJs</code> enabled, turn on <code>noImplicitAny</code> in your <em>tsconfig.json</em> to uncover <code>any</code>s and type them, then turn it back off to make the output of typechecking your remaining JavaScript files less noisy.</p>&#13;
</li>&#13;
<li>&#13;
<p>Do it fast. Mass-rename your JavaScript files to the <em>.ts</em> extension, and keep your <em>tsconfig.json</em> settings lax (meaning <code>strict</code> set to <code>false</code>) to throw as few type errors as possible after renaming. Type complex types as <code>any</code> to appease the typechecker. Fix whatever type errors remain, and commit. Once this is done, flip on the <code>strict</code> mode flags (<code>noImplicitAny</code>, <code>noImplicitThis</code>, <code>strictNullChecks</code>, and so on) one by one, and fix the errors that pop up. (See <a data-type="xref" href="app06.html#compiler-flags">Appendix F</a> for a full list of these flags.)</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you choose to go the quick-and-dirty route, a useful trick is to define an ambient type declaration <code>TODO</code> as a type alias for <code>any</code>, and use that instead of <code>any</code> so that you can more easily find and track missing types.<a data-primary="ambient type declarations" data-secondary="defining TODO as type alias for any" data-type="indexterm" id="idm46304950446904"/><a data-primary="any type" data-secondary="TODO ambient type declaration as type alias for" data-type="indexterm" id="idm46304950446056"/> You can also call it something more specific, so it’s easier to find in a project-wide code search:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// globals.ts</code>&#13;
<code class="nx">type</code> <code class="nx">TODO_FROM_JS_TO_TS_MIGRATION</code> <code class="o">=</code> <code class="nx">any</code>&#13;
&#13;
<code class="c1">// MyMigratedUtil.ts</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">mergeWidgets</code><code class="p">(</code>&#13;
  <code class="nx">widget1</code>: <code class="kt">TODO_FROM_JS_TO_TS_MIGRATION</code><code class="p">,</code>&#13;
  <code class="nx">widget2</code>: <code class="kt">TODO_FROM_JS_TO_TS_MIGRATION</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
</div>&#13;
&#13;
<p>Both ways of doing it are fair game, and it’s up to you which you want to go with. Because TypeScript is a gradually typed language, it’s built from the ground up to interoperate with untyped JavaScript code as safely as possible. Regardless of whether you’re interoperating strictly typed TypeScript with untyped JavaScript or strictly typed TypeScript with loosely typed TypeScript, TypeScript will do its best to make sure that you’re doing it as  safely as possible, and that on the strictly typed island that you’ve so carefully built, everything is as safe as it can be.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step 4: Make It strict" data-type="sect2"><div class="sect2" id="idm46304950427352">&#13;
<h2>Step 4: Make It strict</h2>&#13;
&#13;
<p>Once you’ve migrated a critical mass of your JavaScript over to TypeScript, you’ll want to make your code as safe as possible by opting into TSC’s more stringent flags<a data-primary="TSC compiler" data-secondary="using more stringent flags on migrated JavaScript code" data-type="indexterm" id="idm46304950425752"/><a data-primary="TypeScript" data-secondary="gradually migrating JavaScript code to" data-tertiary="using strict TSC flags" data-type="indexterm" id="idm46304950423416"/> one by one (see <a data-type="xref" href="app06.html#compiler-flags">Appendix F</a> for a full list of flags).</p>&#13;
&#13;
<p>Finally, you can disable TSC’s JavaScript interoperability flags, enforcing that all of your code is written in strictly typed TypeScript:</p>&#13;
<pre data-code-language="json" data-type="programlisting">&#13;
<code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
  <code class="nt">"allowJs"</code><code class="p">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="nt">"checkJs"</code><code class="p">:</code> <code class="kc">false</code>&#13;
<code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>This will surface the final rounds of type-related errors. Fix these, and you’re left with a pristine, safe codebase that the most hardcore OCaml engineer would give you a pat on the back for (were you to ask nicely).</p>&#13;
&#13;
<p>Following these steps will get you far when adding types to JavaScript you control, but what about JavaScript you don’t control, like code you installed from NPM? To get there, we’re first going to have to take a small detour…<a data-primary="JavaScript" data-secondary="interoperating with" data-startref="ix_JSintermig" data-tertiary="gradually migrating code to TypeScript" data-type="indexterm" id="idm46304950408440"/><a data-primary="TypeScript" data-secondary="gradually migrating JavaScript code to" data-startref="ix_TSmigJS" data-type="indexterm" id="idm46304950406888"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type Lookup for JavaScript" data-type="sect1"><div class="sect1" id="type-lookup">&#13;
<h1>Type Lookup for JavaScript</h1>&#13;
&#13;
<p>When you import a JavaScript file from a TypeScript file, TypeScript follows an algorithm that looks like this to look up type declarations<a data-primary="types" data-secondary="type lookup for JavaScript" data-type="indexterm" id="ix_typelkJS"/><a data-primary="JavaScript" data-secondary="interoperating with" data-tertiary="type lookup for JavaScript" data-type="indexterm" id="ix_JSintertyplk"/><a data-primary="modules" data-secondary="imported from JavaScript, type lookup for" data-type="indexterm" id="ix_modimpJS"/> for your JavaScript code (remember that “file” and “module” are interchangeable when we talk about TypeScript):<sup><a data-type="noteref" href="ch11.html#idm46304950368856" id="idm46304950368856-marker">4</a></sup></p>&#13;
<ol>&#13;
<li>&#13;
<p>Look for a sibling <em>.d.ts</em> file with the same name as your <em>.js</em> file. If it exists, use it as the type declaration for the <em>.js</em> file.</p>&#13;
&#13;
<p>For example, say you have the following folder structure:</p>&#13;
&#13;
<pre data-type="programlisting">my-app/&#13;
├──src/&#13;
│ ├──index.ts&#13;
│ └──legacy/&#13;
│   ├──old-file.js&#13;
│   └──old-file.d.ts</pre>&#13;
&#13;
<p>You then import <em>old-file</em> from <em>index.ts</em>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// index.ts</code>&#13;
<code class="kr">import</code> <code class="s1">'./legacy/old-file'</code></pre>&#13;
&#13;
<p>TypeScript will use <em>src/legacy/old-file.d.ts</em> as the source of type declarations for <em><span class="keep-together">./legacy/old-file</span></em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Otherwise, if <code>allowJs</code> and <code>checkJs</code> are true, infer the <em>.js</em> file’s types (informed by any JSDoc annotations in the <em>.js</em> file).</p>&#13;
</li>&#13;
<li>&#13;
<p>Otherwise, treat the whole module as an <code>any</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>When importing a third-party JavaScript module—that is, an NPM package that you installed to <em>node modules</em>—TypeScript uses a slightly different algorithm:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Look for a local type declaration for the module. If it exists, use it.</p>&#13;
&#13;
<p>For example, say your app’s folder structure looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">my-app/&#13;
├──node_modules/&#13;
│ └──foo/&#13;
├──src/&#13;
│ ├──index.ts&#13;
│ └──types.d.ts</pre>&#13;
&#13;
<p>And <em>types.d.ts</em> looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// types.d.ts</code>&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'foo'</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">bar</code><code class="o">:</code> <code class="p">{}</code>&#13;
  <code class="kr">export</code> <code class="k">default</code> <code class="nx">bar</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you then import <code>foo</code>, TypeScript will use the ambient module declaration in <em>types.d.ts</em> as the source of types for <code>foo</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// index.ts</code>&#13;
<code class="kr">import</code> <code class="nx">bar</code> <code class="nx">from</code> <code class="s1">'foo'</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>Otherwise, look at the module’s <em>package.json</em>. If it defines a field called <code>types</code> or <code>typings</code>, use the <em>.d.ts</em> file that field points to as the source of type declarations for the module.</p>&#13;
</li>&#13;
<li>&#13;
<p>Otherwise, traverse out a directory at a time, and look for a <em>node modules/@types</em> directory that has type declarations for the module.</p>&#13;
&#13;
<p>For example, say you installed React:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">npm install react --save&#13;
npm install @types/react --save-dev</pre>&#13;
&#13;
<pre data-type="programlisting">my-app/&#13;
├──node_modules/&#13;
│ ├──@types/&#13;
│ │ └──react/&#13;
│ └──react/&#13;
├──src/&#13;
│ └──index.ts</pre>&#13;
&#13;
<p>When you import React, TypeScript will find the <em>@types/react</em> folder and use that as the source of type declarations for React:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// index.ts</code>&#13;
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s1">'react'</code></pre>&#13;
</li>&#13;
<li>&#13;
<p>Otherwise, proceed to steps 1–3 of the local type lookup algorithm.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>That was a lot of steps, but it’s remarkably intuitive once you get the hang of it.</p>&#13;
<div data-type="tip"><h1>TSC Settings: types and typeRoots</h1>&#13;
<p>By default, TypeScript looks in <em>node modules/@types</em> in your project’s folder and containing folders (<em>../node modules/@types</em> and so on) for third-party type declarations.<a data-primary="types and typeRoots settings (TSC)" data-type="indexterm" id="idm46304950214840"/><a data-primary="TSC compiler" data-secondary="types and typeRoots settings" data-type="indexterm" id="idm46304950214168"/> Most of the time, you want to leave this behavior as is.</p>&#13;
&#13;
<p>To override this default behavior for global type declarations, configure <code>typeRoots</code> in your <em>tsconfig.json</em> with an array of folders to look in for type declarations. For example, you can tell TypeScript to look for type declarations in the <em>typings</em> folder as well as <em>node modules/@types</em>:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"typeRoots"</code> <code class="p">:</code> <code class="p">[</code><code class="s2">"./typings"</code><code class="p">,</code> <code class="s2">"./node modules/@types"</code><code class="p">]</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>For even more granular control, use the <code>types</code> option in your <em>tsconfig.json</em> to specify which packages you want TypeScript to look up types for. For example, the following config ignores all third-party type declarations except the ones for React:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"compilerOptions"</code><code class="p">:</code> <code class="p">{</code>&#13;
    <code class="nt">"types"</code> <code class="p">:</code> <code class="p">[</code><code class="s2">"react"</code><code class="p">]</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Third-Party JavaScript" data-type="sect1"><div class="sect1" id="using-3rd-party-js">&#13;
<h1>Using Third-Party JavaScript</h1>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>I’ll assume you’re using a package manager like NPM or Yarn to install third-party JavaScript. <a data-primary="modules" data-secondary="imported from JavaScript, type lookup for" data-startref="ix_modimpJS" data-type="indexterm" id="idm46304950155016"/><a data-primary="types" data-secondary="type lookup for JavaScript" data-startref="ix_typelkJS" data-type="indexterm" id="idm46304950153800"/><a data-primary="JavaScript" data-secondary="interoperating with" data-startref="ix_JSintertyplk" data-tertiary="type lookup for JavaScript" data-type="indexterm" id="idm46304950152616"/>And if you’re one of those people that prefers to copy and paste code manually instead—shame on you.<a data-primary="third-party JavaScript, using" data-type="indexterm" id="ix_thirdJS"/><a data-primary="JavaScript" data-secondary="interoperating with" data-tertiary="using third-party JavaScript" data-type="indexterm" id="ix_JSinter3rd"/></p>&#13;
</div>&#13;
&#13;
<p>When you <code>npm install</code> third-party JavaScript<a data-primary="NPM package manager" data-secondary="installing third-party JavaScript" data-type="indexterm" id="idm46304950147576"/> code into your project, there are three possible scenarios:</p>&#13;
<ol>&#13;
<li>&#13;
<p>The code you installed comes with type declarations out of the box.</p>&#13;
</li>&#13;
<li>&#13;
<p>The code you installed doesn’t come with type declarations, but declarations are available on DefinitelyTyped.</p>&#13;
</li>&#13;
<li>&#13;
<p>The code you installed doesn’t come with type declarations, and declarations are not available on DefinitelyTyped.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Let’s dig into each of these.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JavaScript That Comes with Type Declarations" data-type="sect2"><div class="sect2" id="idm46304950115544">&#13;
<h2>JavaScript That Comes with Type Declarations</h2>&#13;
&#13;
<p>You know that a package comes with type declarations out of the box if you <code>import</code> it with <code>{"noImplicitAny": true}</code> and TypeScript doesn’t throw a red squiggly at you.</p>&#13;
&#13;
<p>If the code you’re installing is compiled from TypeScript, or its authors were kind enough to include type declarations in its NPM package, then you’re in luck. Just install the code and start using it with full type support.</p>&#13;
&#13;
<p>Some examples of NPM packages that come with built-in type declarations are:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">npm install rxjs&#13;
npm install ava&#13;
npm install @angular/cli</pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Unless the code you’re installing was actually compiled from TypeScript, you always run the risk that the type declarations it comes with don’t match up to the code those declarations describe. When type declarations come packaged with source code the risk of this happening is pretty low (especially for popular packages), but it’s something to be aware of.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JavaScript That Has Type Declarations on DefinitelyTyped" data-type="sect2"><div class="sect2" id="third-party-js-with-dt-typings">&#13;
<h2>JavaScript That Has Type Declarations on DefinitelyTyped</h2>&#13;
&#13;
<p>Even if the third-party code you’re importing doesn’t come with type declarations, declarations for it are probably available on <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a>, TypeScript’s community-maintained, centralized repository for ambient module declarations for open source projects.<a data-primary="DefinitelyTyped" data-secondary="JavaScript with type declarations on" data-type="indexterm" id="idm46304950107976"/><a data-primary="type declarations" data-secondary="in JavaScript on DefinitelyTyped" data-type="indexterm" id="idm46304950084776"/></p>&#13;
&#13;
<p>To check if the package you installed has type declarations available on DefinitelyTyped, either search on <a href="https://microsoft.github.io/TypeSearch/">TypeSearch</a> or just try <a data-primary="TypeSearch" data-type="indexterm" id="idm46304950082696"/>installing the declarations. All DefinitelyTyped type declarations are published to NPM under the <code>@types</code> scope, so you can just <code>npm install</code> from that scope:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">npm install lodash --save            <code class="c"># Install Lodash</code>&#13;
npm install @types/lodash --save-dev <code class="c"># Install type declarations for Lodash</code></pre>&#13;
&#13;
<p>Most of the time, you’ll want to use <code>npm install</code>’s <code>--save-dev</code> flag to add your installed type declarations to your <em>package.json</em>’s <code>devDependencies</code> field.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Since type declarations on DefinitelyTyped are community-maintained, they run the risk of being incomplete, inaccurate, or stale. While most popular packages have well-maintained type declarations, if you find that the declarations you’re using can be improved, take the time to improve them and <a href="http://bit.ly/2U7QYWP">contribute them back to DefinitelyTyped</a> so other TypeScript users can take advantage of your hard work.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JavaScript That Doesn’t Have Type Declarations on DefinitelyTyped" data-type="sect2"><div class="sect2" id="writing-3rd-party-typings">&#13;
<h2>JavaScript That Doesn’t Have Type Declarations on DefinitelyTyped</h2>&#13;
&#13;
<p>This is the least common case of the three.<a data-primary="DefinitelyTyped" data-secondary="JavaScript without type declarations on" data-type="indexterm" id="idm46304950073320"/><a data-primary="type declarations" data-secondary="JavaScript code without on DefinitelyTyped" data-type="indexterm" id="idm46304950072328"/><a data-primary="modules" data-secondary="untyped, importing from third-party JavaScript" data-type="indexterm" id="idm46304950071416"/> You have several options here, from the cheapest and least safe to the most time-intensive and safest:</p>&#13;
<ol>&#13;
<li>&#13;
<p><em>Whitelist the specific import</em> by adding a <code>// @ts-ignore</code> directive above your untyped import.<a data-primary="imports" data-secondary="whitelisting an untyped import" data-type="indexterm" id="idm46304950068424"/><a data-primary="@ts-ignore comment" data-type="indexterm" id="idm46304950067384"/> TypeScript will let you use the untyped module, but the module and all of its contents will be typed as <code>any</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// @ts-ignore</code>&#13;
<code class="kr">import</code> <code class="nx">Unsafe</code> <code class="nx">from</code> <code class="s1">'untyped-module'</code>&#13;
&#13;
<code class="nx">Unsafe</code>  <code class="c1">// any</code></pre>&#13;
</li>&#13;
<li>&#13;
<p><em>Whitelist all usages of this module</em> by creating an empty type declaration file and stubbing out the module. For example, if you installed the rarely used package <code>nearby-ferret-alerter</code>, you could make a new type declaration (e.g., <em>types.d.ts</em>) and add to it the ambient type declaration:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// types.d.ts</code>&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'nearby-ferret-alerter'</code></pre>&#13;
&#13;
<p>This tells TypeScript that there exists a module that you can import (<code>import alert from 'nearby-ferret-alerter'</code>), but it doesn’t tell TypeScript anything about the types contained in that module. This approach is a slightly better alternative to the first, in that now there’s a central <em>types.d.ts</em> file that enumerates all the untyped modules in your application, but it’s equally unsafe because <code>nearby-ferret-alerter</code> and all of its exports will still be typed as <code>any</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Create an ambient module declaration</em>. Like <a data-primary="ambient module declarations" data-secondary="creating for third-party JavaScript" data-type="indexterm" id="idm46304950040472"/>in the previous approach, create a file called <em>types.d.ts</em> and add an empty declaration (<code>declare module 'nearby-ferret-alerter'</code>). Now, fill in the type declaration. For example, the result might look like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// types.d.ts</code>&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'nearby-ferret-alerter'</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="k">default</code> <code class="kd">function</code> <code class="nx">alert</code><code class="p">(</code><code class="nx">loudness</code><code class="o">:</code> <code class="s1">'soft'</code> <code class="o">|</code> <code class="s1">'loud'</code><code class="p">)</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="k">void</code><code class="o">&gt;</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">getFerretCount</code><code class="p">()</code><code class="o">:</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now when you <code>import alert from 'nearby-ferret-alerter'</code>, TypeScript will know exactly what <code>alert</code>’s type is. It’s no longer an <code>any</code>, but <code>(loudness: 'quiet' | 'loud') =&gt; Promise&lt;void&gt;</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p><em>Create a type declaration and contribute it back to NPM</em>. If you got as far as the third option and now have a local type declaration <a data-primary="NPM package manager" data-secondary="sending type declaration to" data-type="indexterm" id="idm46304949925032"/><a data-primary="type declarations" data-secondary="creating for third-party JavaScript and sending to NPM" data-type="indexterm" id="idm46304949924232"/>for your module, consider contributing it back to NPM so the next person that needs type declarations for the awesome <code>nearby-ferret-alerter</code> package can use it too. To do this you can either submit a pull request to the <code>nearby-ferret-alerter</code> Git repository and contribute the type declarations directly, or, if the maintainers of that repository don’t want to be on the hook for maintaining TypeScript type declarations, contribute your declarations to DefinitelyTyped instead.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Writing type declarations for third-party JavaScript is straightforward, but how it’s done depends on the type of module you’re typing. There are a few common patterns that come up when typing different kinds of JavaScript modules (from NodeJS modules to jQuery augmentations and Lodash mixins to React and Angular components). Head over to <a data-type="xref" href="app04.html#module-typing-recipes">Appendix D</a> for a list of recipes for typing third-party JavaScript modules.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Automatically generating type declarations for untyped JavaScript is an active area of research. Check out <a href="https://www.npmjs.com/package/dts-gen"><code>dts-gen</code></a>  for a way to automatically generate type declaration scaffolding for any third-party JavaScript <span class="keep-together">modul</span>e.<a data-primary="third-party JavaScript, using" data-startref="ix_thirdJS" data-type="indexterm" id="idm46304949917320"/><a data-primary="JavaScript" data-secondary="interoperating with" data-startref="ix_JSinter3rd" data-tertiary="using third-party JavaScript" data-type="indexterm" id="idm46304949916296"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304949914536">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>There are a few ways to use JavaScript<a data-primary="JavaScript" data-secondary="interoperating with" data-tertiary="ways to use JavaScript from TypeScript" data-type="indexterm" id="idm46304949913240"/> from TypeScript. <a data-type="xref" href="#javascript-ts-table">Table 11-1</a> summarizes the options.</p>&#13;
<table id="javascript-ts-table">&#13;
<caption><span class="label">Table 11-1. </span>Ways to use JavaScript from TypeScript</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Approach</th>&#13;
<th>tsconfig.json flags</th>&#13;
<th>Type safety</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>Import untyped JavaScript</p></td>&#13;
<td><p><code>{"allowJs": true}</code></p></td>&#13;
<td><p>Poor</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Import and check JavaScript</p></td>&#13;
<td><p><code>{"allowJs": true, "checkJs": true}</code></p></td>&#13;
<td><p>OK</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Import and check JSDoc-annotated JavaScript</p></td>&#13;
<td><p><code>{"allowJs": true, "checkJs": true, "strict": true}</code></p></td>&#13;
<td><p>Excellent</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Import JavaScript with type declarations</p></td>&#13;
<td><p><code>{"allowJs": false, "strict": true}</code></p></td>&#13;
<td><p>Excellent</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Import TypeScript</p></td>&#13;
<td><p><code>{"allowJs": false, "strict": true}</code></p></td>&#13;
<td><p>Excellent</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>In this chapter we covered various aspects of using JavaScript and TypeScript together, from the different kinds of type declarations and how to use them, to migrating your existing JavaScript project to TypeScript piece by piece, to using third-party JavaScript safely (and unsafely). Interoperating with JavaScript can be one of the trickiest aspects of TypeScript; with all the tools at your disposal, you’re now equipped to do it in your own project.<a data-primary="JavaScript" data-secondary="interoperating with" data-startref="ix_JSinter" data-type="indexterm" id="idm46304949894552"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304950957208"><sup><a href="ch11.html#idm46304950957208-marker">1</a></sup> Wildcard matching with <code>*</code> follows the same rules as regular <a href="https://en.wikipedia.org/wiki/Glob_(programming)">glob pattern matching.</a></p><p data-type="footnote" id="idm46304950868968"><sup><a href="ch11.html#idm46304950868968-marker">2</a></sup> DefinitelyTyped is the open source repository for JavaScript type declarations. Read on to learn more.</p><p data-type="footnote" id="idm46304950805784"><sup><a href="ch11.html#idm46304950805784-marker">3</a></sup> For really big projects it can be slow to run every single file through TSC. For a way to improve performance for large projects, see <a data-type="xref" href="ch12.html#improving-compile-times">“Project References”</a>.</p><p data-type="footnote" id="idm46304950368856"><sup><a href="ch11.html#idm46304950368856-marker">4</a></sup> Strictly speaking, this is true for module-mode, but not script-mode, files. Read more in <a data-type="xref" href="ch10.html#module-mode">“Module Mode Versus Script Mode”</a>.</p></div></div></section></body></html>