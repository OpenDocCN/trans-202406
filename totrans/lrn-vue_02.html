<html><head></head><body><section data-pdf-bookmark="Chapter 2. How Vue Works: The Basics" data-type="chapter" epub:type="chapter"><div class="chapter" id="unique_chapter_id_02">&#13;
<h1><span class="label">Chapter 2. </span>How Vue Works: The Basics</h1>&#13;
&#13;
&#13;
<p>In the previous chapter, you learned the essential tools for building a Vue application and also created your first Vue application, preparing you for the next step: learning how Vue works by writing Vue code.</p>&#13;
&#13;
<p>This chapter introduces you to the concepts of Virtual Document Object Model (Virtual DOM) and the fundamentals of writing a Vue component with Vue Options API. It also explores further Vue directives and the Vue reactivity mechanism. By the end of the chapter, you will understand how Vue works and be able to write and register a Vue component for use in your application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Virtual DOM Under the Hood" data-type="sect1"><div class="sect1" id="id9">&#13;
<h1>Virtual DOM Under the Hood</h1>&#13;
&#13;
<p>Vue doesn’t work directly with the Document Object Model (DOM). Instead, it implements its Virtual DOM to optimize the application’s performance on run-time<a data-primary="DOM (Document Object Model)" data-secondary="understanding" data-type="indexterm" id="ix-welcome-VueBasics1"/><a data-primary="Virtual Document Object Model (DOM)" data-secondary="understanding" data-type="indexterm" id="ix-welcome-VueBasics2"/>.</p>&#13;
&#13;
<p>To build a solid understanding of how Virtual DOM works, we start with the concept of the DOM.</p>&#13;
&#13;
<p>The DOM represents the HTML (or XML) document content on the web, in the form of an in-memory tree-like data structure (as shown in <a data-type="xref" href="#figure_01">Figure 2-1</a>). It acts as a programming interface that connects the web page and the actual programming code (such as JavaScript). Tags, such as <code>&lt;div&gt;</code> or <code>&lt;section&gt;</code>, in the HTML document are represented as programmatic nodes and objects<a data-primary="DOM (Document Object Model)" data-secondary="data structure" data-type="indexterm" id="id494"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_01">&#13;
<img alt="An image illustrated different HTML elements connected, distributing by nesting levels" src="assets/lvue_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Example of a DOM tree</h6>&#13;
</div></figure>&#13;
&#13;
<p>After the browser parses the HTML document, the DOM will be available for interaction immediately. Upon any layout changes, the browser then paints and repaints the DOM constantly in the background. We call the process parsing, and painting the DOM screen rasterization or the <em>pixel-to-screen</em> pipeline. <a data-type="xref" href="#figure_02">Figure 2-2</a> demonstrates how rasterization works<a data-primary="rasterization" data-type="indexterm" id="id495"/><a data-primary="pixel-to-screen pipeline" data-type="indexterm" id="id496"/>:</p>&#13;
&#13;
<figure><div class="figure" id="figure_02">&#13;
<img alt="An image illustrated a flow diagram consisting of five major steps, including parsing HTML and CSS code, calculating the CSS styles for elements, planning for screen layout, then painting the visual elements, and finally applying the composition layer on them on the browsers. It also highlights where repaint and reflow happens whenever layout changes happen." src="assets/lvue_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>Browser rasterization process</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Layout Update Problem" data-type="sect2"><div class="sect2" id="id10">&#13;
<h2>The Layout Update Problem</h2>&#13;
&#13;
<p>Each paint is costly to the browser’s performance. Since the DOM may consist of many nodes, querying and updating single or multiple nodes can be extremely &#13;
<span class="keep-together">expensive</span><a data-primary="performance" data-secondary="layout update problem" data-type="indexterm" id="id497"/>.</p>&#13;
&#13;
<p>Here is a simple example of a list of <code>li</code> elements in the DOM:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">ul</code> <code class="na">class</code><code class="o">=</code><code class="s">"list"</code> <code class="na">id</code><code class="o">=</code><code class="s">"todo-list"</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">li</code> <code class="na">class</code><code class="o">=</code><code class="s">"list-item"</code><code class="p">&gt;</code>To do item 1<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">li</code> <code class="na">class</code><code class="o">=</code><code class="s">"list-item"</code><code class="p">&gt;</code>To do item 2<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
  <code class="cm">&lt;!--so on…--&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Adding/removing a <code>li</code> element or modifying its content requires querying the DOM for that item using <code>document.getElementById</code> (or <code>document.getElementsByClassName</code>). Then you need to perform the desired updates using the appropriate DOM APIs.</p>&#13;
&#13;
<p>For instance, if you want to add a new item to the previous example, you need to do the following steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Query the containing list element by its <code>id</code> attribute’s value—<code>"todo-list"</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Add the new <code>li</code> element using <code>document.createElement()</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Set the <code>textContent</code> and the relevant attributes to match other element’s standard using <code>setAttribute()</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Append that element to the list element found in step 1 as its child using <code>appendChild()</code>:</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">list</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="s1">'todo-list'</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">newItem</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s1">'li'</code><code class="p">);</code>&#13;
<code class="nx">newItem</code><code class="p">.</code><code class="nx">setAttribute</code><code class="p">(</code><code class="s1">'class'</code><code class="p">,</code> <code class="s1">'list-item'</code><code class="p">);</code>&#13;
<code class="nx">newItem</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s1">'To do item 3'</code><code class="p">;</code>&#13;
<code class="nx">list</code><code class="p">.</code><code class="nx">appendChild</code><code class="p">(</code><code class="nx">newItem</code><code class="p">);</code></pre>&#13;
&#13;
<p>Similarly, suppose you want to change the text content of the 2nd <code>li</code> item to <code>"buy groceries"</code>. In that case, you perform step 1 to get the containing list element, then query the target element using <code>getElementsByClassName()</code>, and finally change its <code>textContent</code> to the new content:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">secondItem</code> <code class="o">=</code> <code class="nx">list</code><code class="p">.</code><code class="nx">getElementsByClassName</code><code class="p">(</code><code class="s1">'list-item'</code><code class="p">)[</code><code class="mi">1</code><code class="p">];</code>&#13;
<code class="nx">secondItem</code><code class="p">.</code><code class="nx">textContent</code> <code class="o">=</code> <code class="s1">'Buy groceries'</code></pre>&#13;
&#13;
<p>Querying and updating the DOM on a small scale usually do not enormously impact performance. However, these actions can slow the page if performed more repetitively (within a few seconds) and on a more complex web page. The performance impact is significant when there are consecutive minor updates. Many frameworks, such as Angular 1.x, fail to acknowledge and address this performance issue as the codebase grows. The Virtual DOM is designed to solve the layout update problem<a data-primary="" data-startref="ix-welcome-VueBasics1" data-type="indexterm" id="id498"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Is Virtual DOM?" data-type="sect2"><div class="sect2" id="id142">&#13;
<h2>What Is Virtual DOM?</h2>&#13;
&#13;
<p>Virtual DOM is the <em>in-memory virtual copy version</em> of the actual DOM in the browser, but it is lighter weight and has extra functionalities. It mimics the real DOM structure, with a different data structure (usually <code>Object</code>) (see <a data-type="xref" href="#figure_03">Figure 2-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_03">&#13;
<img alt="The left side of the image is a sample DOM structure with three nesting levels. The first level is a single div element. The second level contains two div and single h2 elements. The third level contains a ul and button elements nested in the first div of the second level, a text element nested in the second div of the second level, and a paragraph element nested in the h2 element. The right side of the image is the virtual DOM tree structure, with the same levels and relationships of the DOM on the left side, and all the elements changed to JSON objects with one property named tag for each. The tag property contains the name of the actual component, representing the related DOM element that appeared in the DOM tree on the left side." src="assets/lvue_0203.png"/>&#13;
<h6><span class="label">Figure 2-3. </span>The browser DOM vs. the Virtual DOM</h6>&#13;
</div></figure>&#13;
&#13;
<p>Behind the scenes, the Virtual DOM still uses the DOM API to construct and render updated elements in the browser. Thus, it still causes the browser’s repainting process, but more efficiently<a data-primary="Virtual Document Object Model (DOM)" data-secondary="data structure" data-type="indexterm" id="id499"/>.</p>&#13;
&#13;
<p>In short, Virtual DOM is an abstract pattern aiming to free the DOM from all the actions that can lead to performance inefficiencies, such as manipulating attributes, handling events, and manually updating DOM elements<a data-primary="performance" data-secondary="Virtual DOM and" data-type="indexterm" id="ix-welcome-VueBasics3"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Virtual DOM Works in Vue" data-type="sect2"><div class="sect2" id="id11">&#13;
<h2>How Virtual DOM Works in Vue</h2>&#13;
&#13;
<p>The Virtual DOM sits between the real DOM and the Vue application code. The following is an example of what a node in the Virtual DOM looks like:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">node</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">tag</code><code class="o">:</code> <code class="s1">'div'</code><code class="p">,</code>&#13;
 <code class="nx">attributes</code><code class="o">:</code> <code class="p">[{</code> <code class="nx">id</code><code class="o">:</code> <code class="s1">'list-container'</code><code class="p">,</code> <code class="kr">class</code><code class="o">:</code> <code class="s1">'list-container'</code> <code class="p">}],</code>&#13;
 <code class="nx">children</code><code class="o">:</code> <code class="p">[</code> <code class="cm">/* an array of nodes */</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s call this node VNode. VNode is a <em>virtual node</em> that resides within the Virtual DOM and represents the actual DOM element in the real DOM<a data-primary="VNode" data-secondary="understanding Virtual DOM" data-type="indexterm" id="id500"/>.</p>&#13;
&#13;
<p>Through UI interactions, the user tells Vue what state they wish the element to be in; Vue then triggers the Virtual DOM to update that element’s represented object (<code>node</code>) to the desired shape while keeping track of those changes. Finally, it communicates with the actual DOM and performs accurate updates on the changed nodes &#13;
<span class="keep-together">accordingly</span>.</p>&#13;
&#13;
<p>Since the Virtual DOM is a tree of custom JavaScript objects, updating a component equals updating a custom JavaScript object. This process doesn’t take long. Because we don’t call any DOM API, this update action doesn’t cause a DOM repainting.</p>&#13;
&#13;
<p>Once the Virtual DOM finishes updating itself, it syncs in batch with the actual DOM, leading the changes to be reflected on the browser.</p>&#13;
&#13;
<p><a data-type="xref" href="#figure_04">Figure 2-4</a> illustrates how updates from the Virtual DOM to the actual DOM work when adding a new list item and changing the list item’s text.</p>&#13;
&#13;
<figure><div class="figure" id="figure_04">&#13;
<img alt="A diagram demonstrates how an update happens in actual DOM by comparing the differences between actual DOM and virtual DOM and performing a patch update to actual DOM." src="assets/lvue_0204.png"/>&#13;
<h6><span class="label">Figure 2-4. </span>Updating from Virtual DOM to actual DOM adding a new element and updating the text of an existing element in the list</h6>&#13;
</div></figure>&#13;
&#13;
<p>Since the Virtual DOM is a tree of objects, we can easily track the specific updates that need to be synced with the actual DOM when modifying the Virtual DOM. Instead of querying and updating directly on the actual DOM, we can now schedule and call the updated APIs with a single render function in one update cycle to maintain performance efficiency.</p>&#13;
&#13;
<p>Now that we understand how Virtual DOM works, we will explore the Vue instance and the Vue Options API<a data-primary="" data-startref="ix-welcome-VueBasics1" data-type="indexterm" id="id501"/><a data-primary="" data-startref="ix-welcome-VueBasics3" data-type="indexterm" id="id502"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Vue App Instance and Options API" data-type="sect1"><div class="sect1" id="id12">&#13;
<h1>The Vue App Instance and Options API</h1>&#13;
&#13;
<p>Every Vue application starts with a single Vue component instance as the application root. Any other Vue component created in the same application needs to be nested inside this root component<a data-primary="root component" data-type="indexterm" id="id503"/><a data-primary="components" data-secondary="configuring and Options API" data-type="indexterm" id="ix-welcome-VueBasics4"/><a data-primary="configuring" data-secondary="components, Options API" data-type="indexterm" id="ix-welcome-VueBasics5"/><a data-primary="Options API" data-secondary="understanding" data-type="indexterm" id="ix-welcome-VueBasics6"/><a data-primary="DOM (Document Object Model)" data-seealso="Virtual Document Object Model (DOM)" data-type="indexterm" id="id504"/><a data-primary="Options API" data-seealso="setup hook" data-type="indexterm" id="id505"/>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You can find the initialization code example in <code>main.ts</code> of our Vue project. Vite automatically generates the code as part of its scaffolding process.</p>&#13;
&#13;
<p>You will also find the example code of this chapter within this file.</p>&#13;
</div>&#13;
&#13;
<p>In Vue 2, Vue exposes a <code>Vue</code> class (or JavaScript function) for you to create a Vue component instance based on a set of configuration options, using the following &#13;
<span class="keep-together">syntax</span>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">//component's options</code>&#13;
<code class="p">}</code>&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Vue</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code></pre>&#13;
&#13;
<p><code>Vue</code> receives a component, or the component’s configuration to be more precise. A component’s configuration is an <code>Object</code> containing all the component’s initial configuration options. We call the structure of this argument <em>Options API</em>, which is another of Vue’s core APIs.</p>&#13;
&#13;
<p>Beginning with Vue 3, you can no longer call <code>new Vue()</code> directly. Instead, you create the application instance using the <code>createApp()</code> method from the <code>vue</code> package. This change in functionality enhances the isolation of each Vue instance created both on dependencies and shared components (if any) and the code readability<a data-primary="applications" data-secondary="creating" data-type="indexterm" id="id506"/><a data-primary="createApp()" data-type="indexterm" id="id507"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">//component's options</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code></pre>&#13;
&#13;
<p><code>createApp()</code> also accepts an <code>Object</code> of the component’s configurations. Based on these configurations, Vue creates a Vue component instance as its application root <code>app</code>. Then you need to mount the root component <code>app</code> to the desired HTML element using the <code>app.mount()</code> method, as follows:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p><code>#app</code> is the unique id selector for the application’s root element. The Vue engine queries for the element using this id, mounts the app instance to it, then renders the application in the browser<a data-primary="app root component, mounting" data-type="indexterm" id="id508"/><a data-primary="mounting" data-secondary="root component" data-type="indexterm" id="id509"/><a data-primary="mount() method" data-secondary="root component" data-type="indexterm" id="id510"/><a data-primary="root component" data-type="indexterm" id="id511"/>.</p>&#13;
&#13;
<p>The next step is to provide the configurations for Vue to build a component instance according to Options API.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>From this point on, we write code according to Vue 3 API standards.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exploring the Options API" data-type="sect1"><div class="sect1" id="ch02_exploring_options">&#13;
<h1>Exploring the Options API</h1>&#13;
&#13;
<p>Options API is Vue’s core API for initializing a Vue component. It contains the component’s configurations structured in an Object format<a data-primary="Options API" data-secondary="properties" data-type="indexterm" id="ix-welcome-VueBasics8"/>.</p>&#13;
&#13;
<p>We divide its essential properties into four main categories:</p>&#13;
<dl>&#13;
<dt>State handling</dt>&#13;
<dd>&#13;
<p>Including <code>data()</code>, which returns the local data state for the component, <code>computed</code>, <code>methods</code>, and <code>watch</code> for enabling observation on specific local data, and <code>props</code> for the incoming data<a data-primary="state" data-secondary="Options API role in handling" data-type="indexterm" id="id512"/><a data-primary="data(), creating local data state with" data-type="indexterm" id="id513"/><a data-primary="data" data-secondary="state handling and Options API" data-type="indexterm" id="ix-welcome-VueBasics11"/><a data-primary="Options API" data-secondary="state handling" data-type="indexterm" id="ix-welcome-VueBasics11a"/><a data-primary="rendering" data-seealso="animations; server-side rendering; transitions" data-type="indexterm" id="id514"/>.</p>&#13;
</dd>&#13;
<dt>Rendering</dt>&#13;
<dd>&#13;
<p><code>template</code> for the HTML view template and <code>render()</code> as the rendering logic for the component<a data-primary="rendering" data-secondary="Options API role in" data-type="indexterm" id="id515"/><a data-primary="render()" data-secondary="using" data-type="indexterm" id="ix-welcome-VueBasics7"/><a data-primary="rendering" data-secondary="with render()" data-secondary-sortas="render" data-type="indexterm" id="ix-welcome-VueBasics7a"/><a data-primary="Options API" data-secondary="template property" data-type="indexterm" id="ix-welcome-VueBasics10"/><a data-primary="rendering" data-secondary="with template" data-secondary-sortas="template" data-type="indexterm" id="ix-welcome-VueBasics10a"/><a data-primary="template property" data-type="indexterm" id="ix-welcome-VueBasics10b"/><a data-primary="templates" data-secondary="Options API role in" data-type="indexterm" id="ix-welcome-VueBasics10c"/>.</p>&#13;
</dd>&#13;
<dt>Lifecycle hooks</dt>&#13;
<dd>&#13;
<p>Such as <code>beforeCreate()</code>, <code>created()</code>, <code>mounted()</code>, etc., for handling different stages of a component’s lifecycle<a data-primary="lifecycle hooks" data-secondary="Options API and" data-type="indexterm" id="id516"/>.</p>&#13;
</dd>&#13;
<dt>Others</dt>&#13;
<dd>&#13;
<p>Such as <code>provide()</code>, <code>inject()</code> for handling different customization and communication between components. And <code>components</code>, a collection of nested component templates to use within the component<a data-primary="components" data-secondary="provide/inject pattern" data-type="indexterm" id="id517"/><a data-primary="provide() hook" data-type="indexterm" id="id518"/><a data-primary="provide/inject pattern" data-type="indexterm" id="id519"/><a data-primary="inject/provide pattern" data-type="indexterm" id="id520"/><a data-primary="inject() hook" data-type="indexterm" id="id521"/><a data-primary="hooks" data-secondary="provide/inject pattern" data-type="indexterm" id="id522"/><a data-primary="hooks" data-secondary="Options API role in" data-type="indexterm" id="id523"/><a data-primary="hooks" data-seealso="composables; lifecycle hooks" data-type="indexterm" id="id524"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p class="pagebreak-before">The following is an example structure of our root <code>App</code> component based on Options API:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="s2">"This is the app's entrance"</code><code class="p">,</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>In the previous code, an HTML template displays regular text. We can also define a local <code>data</code> state using <code>data()</code> function, which we will discuss further in <a data-type="xref" href="#local_state">“Creating Local State with Data Properties”</a>.</p>&#13;
&#13;
<p>You can also rewrite the previous code to use the <code>render()</code> function<a data-primary="data property" data-secondary="creating local state with data()" data-type="indexterm" id="id525"/><a data-primary="state" data-secondary="creating local state with data()" data-type="indexterm" id="id526"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">render</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="s2">"This is the app's entrance"</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Both codes will generate the same result (<a data-type="xref" href="#figure_05">Figure 2-5</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_05">&#13;
<img alt="An image displays a text saying this is the app's entrance." src="assets/lvue_0205.png"/>&#13;
<h6><span class="label">Figure 2-5. </span>Sample output of writing a root component using Options API</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you open the Elements tab in the browser’s Developer Tools, you will see the actual DOM now contains a div with <code>id="app"</code> and a text content <code><em>This is the app’s entrance</em></code> (<a data-type="xref" href="#figure_06">Figure 2-6</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_06">&#13;
<img alt="An image displays the actual DOM with the rendered HTML code." src="assets/lvue_0206.png"/>&#13;
<h6><span class="label">Figure 2-6. </span>The DOM tree in the browser has a div containing the app’s text content</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can also create a new component, <code>Description</code>, which renders a static text and passes it to <code>components</code> of the <code>App</code>. Then you can use it as a nested component in the <code>template</code>, like in <a data-type="xref" href="#nest_components">Example 2-1</a><a data-primary="Description component" data-type="indexterm" id="id527"/>.</p>&#13;
<div data-type="example" id="nest_components">&#13;
<h5><span class="label">Example 2-1. </span>Declare an internal component template to use in the <code>App</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">Description</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="s2">"This is the app's entrance"</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">components</code><code class="o">:</code> <code class="p">{</code> <code class="nx">Description</code> <code class="p">},</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="s1">'&lt;Description /&gt;'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>The output stays the same as in <a data-type="xref" href="#figure_06">Figure 2-6</a>.</p>&#13;
&#13;
<p>Note here you must declare either <code>template</code> or <code>render()</code> function (see <a data-type="xref" href="ch07.html#render_function">“The Render Function and JSX”</a>) for the component. However, you don’t need these properties in case you are writing the component in Single File Component (SFC) standard. We will discuss this component standard in <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a><a data-primary="render()" data-secondary="using" data-type="indexterm" id="id528"/>.</p>&#13;
&#13;
<p>Next, let’s look at the <code>template</code> property syntax<a data-primary="" data-startref="ix-welcome-VueBasics4" data-type="indexterm" id="id529"/><a data-primary="" data-startref="ix-welcome-VueBasics5" data-type="indexterm" id="id530"/><a data-primary="" data-startref="ix-welcome-VueBasics6" data-type="indexterm" id="id531"/><a data-primary="" data-startref=" ix-welcome-VueBasics7" data-type="indexterm" id="id532"/><a data-primary="" data-startref=" ix-welcome-VueBasics7a" data-type="indexterm" id="id533"/><a data-primary="" data-startref="ix-welcome-VueBasics8a" data-type="indexterm" id="id534"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Template Syntax" data-type="sect1"><div class="sect1" id="template_syntax">&#13;
<h1>The Template Syntax</h1>&#13;
&#13;
<p>In Options API, <code>template</code> accepts a single string that contains valid HTML-based code and represents the component’s UI layout. The Vue engine parses this value and compiles it into optimized JavaScript code, then accordingly renders the relevant DOM elements<a data-primary="DOM (Document Object Model)" data-secondary="template command syntax" data-type="indexterm" id="id535"/>.</p>&#13;
&#13;
<p>The following code demonstrates our root component <code>App</code>, whose layout is a single <code>div</code> displaying text—<code>This is the app’s entrance</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="s2">"&lt;div&gt;This is the app's entrance&lt;/div&gt;"</code><code class="p">,</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>For multi-level HTML template code, we can use backtick characters (JavaScript template literals), denoted by <code>`</code> symbol, and maintain the readability. We can rewrite <code>App</code>’s template in the previous example to include other <code>h1</code> and <code>h2</code> elements, as in the &#13;
<span class="keep-together">following</span><a data-primary="backtick (`) for multi-level HTML code" data-type="indexterm" id="id536"/><a data-primary="` (backtick) for multi-level HTML code" data-type="indexterm" id="id537"/>:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb"> &lt;h1&gt;This is the app's entrance&lt;/h1&gt;</code>&#13;
<code class="sb"> &lt;h2&gt;We are exploring template syntax&lt;/h2&gt;</code>&#13;
<code class="sb">`</code><code class="p">,</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>The Vue engine will render to the DOM with two headings (<a data-type="xref" href="#figure_10">Figure 2-7</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_10">&#13;
<img alt="The image displays two headings, one says This is the app's entrance in large bold font, the other says We are exploring template syntax in smaller bold font" src="assets/lvue_0207.png"/>&#13;
<h6><span class="label">Figure 2-7. </span>Output of a multi-level template for a component</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>template</code> property syntax is essential for creating the binding between a specific DOM element and the component’s local data using directives and a dedicated syntax. We will explore how to define the data we want to display in the UI next<a data-primary="" data-startref="ix-welcome-VueBasics10" data-type="indexterm" id="id538"/><a data-primary="" data-startref="ix-welcome-VueBasics10a" data-type="indexterm" id="id539"/><a data-primary="" data-startref="ix-welcome-VueBasics10b" data-type="indexterm" id="id540"/><a data-primary="" data-startref="ix-welcome-VueBasics10c" data-type="indexterm" id="id541"/><a data-primary="bindings" data-secondary="template command syntax" data-type="indexterm" id="id542"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating Local State with Data Properties" data-type="sect1"><div class="sect1" id="local_state">&#13;
<h1>Creating Local State with Data Properties</h1>&#13;
&#13;
<p>Most components keep their local state (or local data) or receive data from an external source. In Vue, we store the component’s local state using the Options API <code>data()</code> function property<a data-primary="data(), creating local data state with" data-type="indexterm" id="ix-welcome-VueBasics12"/><a data-primary="data property" data-secondary="creating local state with data()" data-type="indexterm" id="ix-welcome-VueBasics12a"/><a data-primary="Options API" data-secondary="data()" data-type="indexterm" id="ix-welcome-VueBasics12b"/><a data-primary="Options API" data-secondary="storing state" data-type="indexterm" id="ix-welcome-VueBasics12c"/><a data-primary="state" data-secondary="creating local state with data()" data-type="indexterm" id="ix-welcome-VueBasics12d"/>.</p>&#13;
&#13;
<p><code>data()</code> is an anonymous function that returns an object representing the local data state of a component. We call that returned object the <em>data object</em>. When initializing the component instance, the Vue engine will add each property of this data object to its reactivity system for tracking its changes and triggering the re-rendering of the UI template accordingly.</p>&#13;
&#13;
<p>In short, the data object is the reactive state of a component<a data-primary="mustache syntax {{}}, injecting data property with" data-type="indexterm" id="id543"/><a data-primary="{} (curly braces)" data-secondary="{{}} (mustache syntax)" data-type="indexterm" id="id544"/><a data-primary="curly braces ({})" data-secondary="mustache syntax {{}}" data-type="indexterm" id="id545"/>.</p>&#13;
&#13;
<p>To inject the data property in the template, we use the <em>mustache</em> syntax, denoted by double curly braces <code>{{}}</code>. Within the HTML template, we wrap the data property with the curly braces where we need to inject its value, as seen in <a data-type="xref" href="#mustache">Example 2-2</a>.</p>&#13;
<div data-type="example" id="mustache">&#13;
<h5><span class="label">Example 2-2. </span>Inject title to display in the HTML template</h5>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Data</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">title</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div&gt;{{ title }}&lt;/div&gt;</code>&#13;
<code class="sb">`</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code><code class="o">:</code> <code class="nx">Data</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">title</code><code class="o">:</code> <code class="s1">'My first Vue component'</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>In the previous code, we declare the local data property <code>title</code> and inject its value in the template of <code>App</code> by using the <code>{{ title }}</code> expression. The output in the DOM equals the following code:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>My first Vue component<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>You can also combine an inline static text with double curly braces within the same element tag:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div&gt;Title: {{ title }}&lt;/div&gt;</code>&#13;
<code class="sb">`</code><code class="p">,</code>&#13;
 <code class="cm">/**... */</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Vue automatically preserves the static text and replaces only the expression with the correct value. The result equals the following<a data-primary="this" data-secondary="data object property and" data-type="indexterm" id="id546"/><a data-primary="this" data-secondary="lifecycle hooks and" data-type="indexterm" id="id547"/><a data-primary="lifecycle hooks" data-secondary="accessing this with" data-type="indexterm" id="id548"/><a data-primary="created() hook" data-secondary="using" data-type="indexterm" id="id549"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>Title: My first Vue component<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>All data object properties are available for access directly and internally through the component instance <code>this</code>. And <code>this</code> is accessible in any component’s local methods, computed properties, and lifecycle hooks. For example, we can print out <code>title</code> to the console after creating a component with the hook <code>created()</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="kr">type</code> <code class="nx">ComponentOptions</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="cm">/**... */</code>&#13;
 <code class="nx">created</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">((</code><code class="k">this</code> <code class="kr">as</code> <code class="nx">ComponentOptions</code><code class="o">&lt;</code><code class="nx">Data</code><code class="o">&gt;</code><code class="p">).</code><code class="nx">title</code><code class="p">)</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We cast <code>this</code> as a <code>ComponentOptions&lt;Data&gt;</code> type. We will enable full TypeScript support for the Vue component in Vue 3 using <code>defineComponent</code>, which we will discuss further in <a data-type="xref" href="ch03.html#define_component">“Using defineComponent() for TypeScript Support”</a><a data-primary="data property" data-secondary="editing" data-type="indexterm" id="id550"/><a data-primary="data property" data-secondary="reactivity of" data-type="indexterm" id="id551"/><a data-primary="reactivity" data-secondary="editing data properties" data-type="indexterm" id="id552"/><a data-primary="Vue Devtools" data-secondary="editing data properties" data-type="indexterm" id="id553"/>.</p>&#13;
</div>&#13;
&#13;
<p>You can debug the reactivity of a data property by using the Vue Devtools. On the main page of our application, open the browser’s Developer Tools, head to the Vue tab, and select the <code>Root</code> component displayed in the Inspector panel. Once this is selected, a right-side panel will appear, showing the component data object’s properties. When you hover on the <code>title</code> property, a pen icon will appear, allowing you to edit the property value (<a data-type="xref" href="#figure_18">Figure 2-8</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_18">&#13;
<img alt="A screenshot displays the Vue Devtool, with title property is highlighted and a pen icon appeared on the right of the row next to the property value." src="assets/lvue_0208.png"/>&#13;
<h6><span class="label">Figure 2-8. </span>How to debug and edit a data property using Vue Devtools</h6>&#13;
</div></figure>&#13;
&#13;
<p>Click on that edit icon button, modify the <code>title</code> value, and hit Enter; the application UI instantly reflects the new value.</p>&#13;
&#13;
<p>You have learned how to use <code>data()</code> and double curly braces <code>{{}}</code> to inject the local data to the UI template. This is a type of one-way data binding<a data-primary="bindings" data-secondary="one-way" data-type="indexterm" id="id554"/><a data-primary="data" data-secondary="binding, one-way" data-type="indexterm" id="id555"/><a data-primary="one-way binding" data-type="indexterm" id="id556"/>.</p>&#13;
&#13;
<p>Before we explore the two-way binding and other directives in Vue, let’s look at reactivity in Vue<a data-primary="" data-startref="ix-welcome-VueBasics11" data-type="indexterm" id="id557"/><a data-primary="" data-startref="ix-welcome-VueBasics11a" data-type="indexterm" id="id558"/><a data-primary="" data-startref="ix-welcome-VueBasics12" data-type="indexterm" id="id559"/><a data-primary="" data-startref="ix-welcome-VueBasics12a" data-type="indexterm" id="id560"/><a data-primary="" data-startref="ix-welcome-VueBasics12b" data-type="indexterm" id="id561"/><a data-primary="" data-startref="ix-welcome-VueBasics12c" data-type="indexterm" id="id562"/><a data-primary="" data-startref="ix-welcome-VueBasics12d" data-type="indexterm" id="id563"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Reactivity in Vue Works" data-type="sect1"><div class="sect1" id="reactivity">&#13;
<h1>How Reactivity in Vue Works</h1>&#13;
&#13;
<p>To understand how reactivity works, let’s take a quick look at how the Virtual DOM processes all the received information, creates, and keeps track of created VNodes before yielding to the actual DOM (<a data-type="xref" href="#figure_05_01">Figure 2-9</a>)<a data-primary="DOM (Document Object Model)" data-secondary="reactivity and" data-type="indexterm" id="ix-welcome-VueBasics13"/><a data-primary="reactivity" data-secondary="understanding" data-type="indexterm" id="ix-welcome-VueBasics13a"/><a data-primary="Virtual Document Object Model (DOM)" data-secondary="reactivity and" data-type="indexterm" id="ix-welcome-VueBasics13b"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_05_01">&#13;
<img alt="A diagram demonstrates how a render happens from Virtual DOM to actual DOM when a component data changes, in five different flow states." src="assets/lvue_0209.png"/>&#13;
<h6><span class="label">Figure 2-9. </span>The flow of Virtual DOM’s rendering process</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can describe the previous process diagram as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Once you define the local data, in Vue.js 2.0, the internal Vue engine uses JavaScript’s built-in <code>Object.defineProperty()</code> to establish the <em>getters and setters</em> for each related piece of data and enables relevant data reactivity. In Vue.js 3.0, however, the Vue engine uses the ES5 Proxy-based mechanism<sup><a data-type="noteref" href="ch02.html#id564" id="id564-marker">1</a></sup> for performance enhancement, doubling run-time performance and reducing the memory needed by half. We will explain more about this reactivity mechanism in <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a><a data-primary="defineProperty()" data-type="indexterm" id="id565"/><a data-primary="getters" data-secondary="object reactivity and" data-type="indexterm" id="id566"/><a data-primary="performance" data-secondary="object reactivity" data-type="indexterm" id="id567"/><a data-primary="setters, object reactivity and" data-type="indexterm" id="id568"/>.</p>&#13;
</li>&#13;
<li>&#13;
<p>After setting up the reactivity mechanism, the Vue engine uses <em>watcher</em> objects to keep track of any data update triggered by the setters. Watchers help the Vue engine detect changes and update the Virtual DOM and the actual DOM through a <em>Queue</em> system<a data-primary="queues, object reactivity and" data-type="indexterm" id="id569"/>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Vue uses the Queue system to avoid inefficient multiple updates of the DOM within a short time. A watcher adds itself to the Queue upon a related component’s data change. The Vue engine sorts it by a specific order for consumption. Until the Vue engine finishes consuming and flushing that watcher from the Queue, only one watcher of the same component exists within the Queue, regardless of the number of data changes. This consumption process is done by <code>nextTick()</code> API, which is a Vue function<a data-primary="nextTick()" data-type="indexterm" id="id570"/>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finally, after the Vue engine consumes and flushes all the watchers, it triggers the <code>run()</code> function of each watcher to update the component’s real DOM and Virtual DOM automatically,  and the application renders<a data-primary="timers" data-type="indexterm" id="id571"/><a data-primary="setInterval()" data-type="indexterm" id="id572"/><a data-primary="created() hook" data-secondary="using" data-type="indexterm" id="id573"/>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Let’s perform another example. This time we use <code>data()</code> and the help of <code>created()</code> to demonstrate reactivity in the application. <code>created()</code> is the lifecycle hook that the Vue engine triggers after creating the component instance and before mounting it to the DOM element. At this point, we won’t discuss this hook further but use this hook to perform a timer update on a data property <code>counter</code> with <code>setInterval</code>:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="typescript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="kr">type</code> <code class="nx">ComponentOptions</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Data</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">counter</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div&gt;Counter: {{ counter }}&lt;/div&gt;</code>&#13;
<code class="sb">`</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code><code class="o">:</code> <code class="nx">Data</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">counter</code><code class="o">:</code> <code class="mi">0</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">},</code>&#13;
 <code class="nx">created</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">interval</code> <code class="o">=</code> <code class="nx">setInterval</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
   <code class="p">(</code><code class="k">this</code> <code class="kr">as</code> <code class="nx">ComponentOptions</code><code class="o">&lt;</code><code class="nx">Data</code><code class="o">&gt;</code><code class="p">).</code><code class="nx">counter</code><code class="o">++</code>&#13;
  <code class="p">},</code> <code class="mi">1000</code><code class="p">);</code>&#13;
&#13;
  <code class="nx">setTimeout</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
   <code class="nx">clearInterval</code><code class="p">(</code><code class="nx">interval</code><code class="p">)</code>&#13;
  <code class="p">},</code> <code class="mi">5000</code><code class="p">)</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>This code increments the <code>counter</code> every one second.<sup><a data-type="noteref" href="ch02.html#id574" id="id574-marker">2</a></sup> We also use <code>setTimeout()</code> to clear the interval after 5 seconds. On the browser, you can see the displayed value changing from 0 to 5 every second. The final output will equal the string<a data-primary="setTimeout()" data-type="indexterm" id="id575"/>:</p>&#13;
&#13;
<pre data-type="programlisting">Counter: 5</pre>&#13;
&#13;
<p>After understanding the concept of reactivity and rendering in Vue, we are ready to explore how to perform two-way data binding<a data-primary="" data-startref="ix-welcome-VueBasics13" data-type="indexterm" id="id576"/><a data-primary="" data-startref="ix-welcome-VueBasics13a" data-type="indexterm" id="id577"/><a data-primary="" data-startref="ix-welcome-VueBasics13b" data-type="indexterm" id="id578"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Two-Way Binding with v-model" data-type="sect1"><div class="sect1" id="two_way">&#13;
<h1>Two-Way Binding with v-model</h1>&#13;
&#13;
<p>Two-way binding refers to how we sync data between a component’s logic and its view template. When a component’s data field changes programmatically, the new value reflects on its UI view. And vice versa, when a user makes changes to the data field on the UI view, the component automatically gets and saves the updated value, keeping both the internal logic and the UI synchronized. A good example of two-way binding is the form input field<a data-primary="bindings" data-secondary="two-way" data-type="indexterm" id="ix-welcome-VueBasics14"/><a data-primary="bindings" data-secondary="with v-model" data-secondary-sortas="v-model" data-type="indexterm" id="ix-welcome-VueBasics14a"/><a data-primary="data" data-secondary="binding, two-way" data-type="indexterm" id="ix-welcome-VueBasics14b"/><a data-primary="data" data-secondary="binding with v-model" data-type="indexterm" id="ix-welcome-VueBasics14c"/><a data-primary="forms, two-way binding with v-model" data-type="indexterm" id="ix-welcome-VueBasics14d"/><a data-primary="two-way binding with v-model" data-type="indexterm" id="ix-welcome-VueBasics14e"/><a data-primary="v-model" data-type="indexterm" id="ix-welcome-VueBasics14f"/><a data-primary="Options API" data-secondary="directive basics" data-type="indexterm" id="ix-welcome-VueBasics15"/><a data-primary="Vue" data-secondary="directive basics" data-type="indexterm" id="ix-welcome-VueBasics15a"/>.</p>&#13;
&#13;
<p class="pagebreak-before">Two-way data binding is a complex yet beneficial use case for application development. One common scenario for two-way binding is form input synchronization. Proper implementation saves developing time and reduces complexity to maintain data consistency between the actual DOM and component data. But implementing two-way binding is a challenge.</p>&#13;
&#13;
<p>Fortunately, Vue makes two-way binding much simpler with the <code>v-model</code> directive. Binding the <code>v-model</code> directive to a component’s data model will automatically trigger updating the template when the data model changes, and vice versa.</p>&#13;
&#13;
<p>The syntax is straightforward; the value passing to <code>v-model</code> is the name alias declared in the <code>data</code> return object.</p>&#13;
&#13;
<p>Assume we have a <code>NameInput</code> component that receives text input from the user, with the following <code>template</code> code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">NameInput</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb"> &lt;label for="name"&gt;</code>&#13;
<code class="sb">  &lt;input placeholder="Enter your name" id="name"&gt;</code>&#13;
<code class="sb"> &lt;/label&gt;`</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We want to sync the the input value received with a local data model, naming <code>name</code>. To do so, we add <code>v-model="name"</code> to the <code>input</code> element and declare the data model in <code>data()</code> accordingly:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">NameInput</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb"> &lt;label for="name"&gt;</code>&#13;
<code class="sb">  Write your name:</code>&#13;
<code class="sb">  &lt;input</code>&#13;
<code class="sb">   v-model="name"</code>&#13;
<code class="sb">   placeholder="Enter your name"</code>&#13;
<code class="sb">   id="name"</code>&#13;
<code class="sb">  &gt;</code>&#13;
<code class="sb"> &lt;/label&gt;`</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">name</code><code class="o">:</code> <code class="s1">''</code><code class="p">,</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The value of <code>name</code> will change whenever the user changes the <code>input</code> field on run-time.</p>&#13;
&#13;
<p class="pagebreak-before">To have this component render in the browser, we add <code>NameInput</code> as one of the components for the application:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">NameInput</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="cm">/**... */</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">({</code>&#13;
 <code class="nx">components</code><code class="o">:</code> <code class="p">{</code> <code class="nx">NameInput</code> <code class="p">},</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`&lt;NameInput /&gt;`</code><code class="p">,</code>&#13;
<code class="p">})</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>You can track this data change by opening the Vue tab in the browser’s Developer Tools. Within the Inspector tab, find and select the <code>NameInput</code> element under the <code>Root</code> element, and you will see the component’s data displayed on the right panel of the Vue tab (<a data-type="xref" href="#figure_15">Figure 2-10</a>)<a data-primary="Vue Devtools" data-secondary="viewing changes in" data-type="indexterm" id="id579"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_15">&#13;
<img alt="A screenshot of developer tools opened at the bottom of the browser, with Vue is the active tab and displays the component's information on the right panel." src="assets/lvue_0210.png"/>&#13;
<h6><span class="label">Figure 2-10. </span>Debug the input component using the Vue tab in Developer Tools</h6>&#13;
</div></figure>&#13;
&#13;
<p>When you change the input field, the <code>name</code> property under <code>data</code> displayed on the right side of the Vue tab also will get the updated value (<a data-type="xref" href="#figure_16">Figure 2-11</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_16">&#13;
<img alt="A screenshot displays how the input field with new value typed will also reflect on the 'name' data property seen in Vue tab." src="assets/lvue_0211.png"/>&#13;
<h6><span class="label">Figure 2-11. </span>Input value changes sync with the relevant component’s data model</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can use the same approach for building a checklist with multiple options. In this scenario, you need to declare the data model as an <code>Array</code> and add the <code>v-model</code> binding on each checkbox input field. <a data-type="xref" href="#course_checklist">Example 2-3</a> demonstrates how it looks for a &#13;
<span class="keep-together"><code>Course</code></span><code>Checklist</code><a data-primary="arrays" data-secondary="two-way binding with v-model" data-type="indexterm" id="id580"/>.</p>&#13;
<div data-type="example" id="course_checklist">&#13;
<h5><span class="label">Example 2-3. </span>Create a course checklist using <code>v-model</code> and checkbox input</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">CourseChecklist</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb"> &lt;div&gt;The course checklist: {{list.join(', ')}}&lt;/div&gt;</code>&#13;
<code class="sb"> &lt;div&gt;</code>&#13;
<code class="sb"> &lt;label for="chapter1"&gt;</code>&#13;
<code class="sb">  &lt;input</code>&#13;
<code class="sb">   v-model="list"</code>&#13;
<code class="sb">   type="checkbox"</code>&#13;
<code class="sb">   value="chapter01"</code>&#13;
<code class="sb">   id="chapter1"</code>&#13;
<code class="sb">  &gt;</code>&#13;
<code class="sb">  Chapter 1</code>&#13;
<code class="sb"> &lt;/label&gt;</code>&#13;
<code class="sb"> &lt;label for="chapter2"&gt;</code>&#13;
<code class="sb">  &lt;input</code>&#13;
<code class="sb">   v-model="list"</code>&#13;
<code class="sb">   type="checkbox"</code>&#13;
<code class="sb">   value="chapter02"</code>&#13;
<code class="sb">   id="chapter2"</code>&#13;
<code class="sb">  &gt;</code>&#13;
<code class="sb">  Chapter 2</code>&#13;
<code class="sb"> &lt;/label&gt;</code>&#13;
<code class="sb"> &lt;label for="chapter3"&gt;</code>&#13;
<code class="sb">  &lt;input</code>&#13;
<code class="sb">   v-model="list"</code>&#13;
<code class="sb">   type="checkbox"</code>&#13;
<code class="sb">   value="chapter03"</code>&#13;
<code class="sb">   id="chapter3"</code>&#13;
<code class="sb">  &gt;</code>&#13;
<code class="sb">  Chapter 3</code>&#13;
<code class="sb"> &lt;/label&gt;</code>&#13;
<code class="sb"> &lt;/div&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">list</code><code class="o">:</code> <code class="p">[],</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">({</code>&#13;
 <code class="nx">components</code><code class="o">:</code> <code class="p">{</code> <code class="nx">CourseChecklist</code> <code class="p">},</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`&lt;CourseChecklist /&gt;`</code><code class="p">,</code>&#13;
<code class="p">})</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>Vue automatically adds or removes an input value to the <code>list</code> array according to the user’s interaction (<a data-type="xref" href="#figure_17">Figure 2-12</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_17">&#13;
<img alt="A screenshot displays a course checklist, with three options presented as checkbox for selecting." src="assets/lvue_0212.png"/>&#13;
<h6><span class="label">Figure 2-12. </span>Screenshot of the list value after the user makes a selection</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using v-model.lazy Modifier" data-type="sect1"><div class="sect1" id="id18">&#13;
<h1>Using v-model.lazy Modifier</h1>&#13;
&#13;
<p>Updating a data value on every user keystroke can be too much, especially when displaying that input value in other places. Remember Vue re-renders the template UI according to the data changes. By enabling two-way syncing on every input key received, you expose your application to potential unnecessary re-rendering. To reduce this overhead, you can use the <code>v-model.lazy</code> modifier instead of the regular <code>v-model</code> to bind with the data model<a data-primary="bindings" data-secondary="with v-model with lazy modifier" data-secondary-sortas="v-model with lazy modifier" data-type="indexterm" id="id581"/><a data-primary="data" data-secondary="binding with lazy modifier" data-type="indexterm" id="id582"/><a data-primary="lazy two-way binding" data-type="indexterm" id="id583"/><a data-primary="v-model.lazy" data-type="indexterm" id="id584"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">NameInput</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb"> &lt;label for="name"&gt;</code>&#13;
<code class="sb">  Write your name:</code>&#13;
<code class="sb">  &lt;input</code>&#13;
<code class="sb">   v-model.lazy="name"</code>&#13;
<code class="sb">   placeholder="Enter your name"</code>&#13;
<code class="sb">   id="name"</code>&#13;
<code class="sb">  &gt;</code>&#13;
<code class="sb"> &lt;/label&gt;`</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">name</code><code class="o">:</code> <code class="s1">''</code><code class="p">,</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This modifier ensures the <code>v-model</code> will only track changes triggered by the <code>onChange</code> event of that input element.</p>&#13;
<div data-type="tip"><h1>Using <code>v-model.number</code> and <code>v-model.trim</code> Modifiers</h1>&#13;
<p>If the data model you are binding to <code>v-model</code> should be a number type, you can use the modifier <code>v-model.number</code> to convert the input value to a number<a data-primary="numbers, two-way binding with v-model" data-type="indexterm" id="id585"/><a data-primary="v-model.number" data-type="indexterm" id="id586"/>.</p>&#13;
&#13;
<p>Similarly, if you want to ensure the string data model free from trailing whitespaces, you can use <code>v-model.trim</code> instead<a data-primary="v-model.trim" data-type="indexterm" id="id587"/><a data-primary="whitespaces, two-way binding with v-model" data-type="indexterm" id="id588"/>.</p>&#13;
</div>&#13;
&#13;
<p>That’s all for two-way binding. Next we’ll examine the more common directive &#13;
<span class="keep-together"><code>v-bind</code></span> for one-way binding<a data-primary="" data-startref="ix-welcome-VueBasics14" data-type="indexterm" id="id589"/><a data-primary="" data-startref="ix-welcome-VueBasics14a" data-type="indexterm" id="id590"/><a data-primary="" data-startref="ix-welcome-VueBasics14b" data-type="indexterm" id="id591"/><a data-primary="" data-startref="ix-welcome-VueBasics14c" data-type="indexterm" id="id592"/><a data-primary="" data-startref="ix-welcome-VueBasics14d" data-type="indexterm" id="id593"/><a data-primary="" data-startref="ix-welcome-VueBasics14e" data-type="indexterm" id="id594"/><a data-primary="" data-startref="ix-welcome-VueBasics14f" data-type="indexterm" id="id595"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Binding Reactive Data and Passing Props Data with v-bind" data-type="sect1"><div class="sect1" id="id19">&#13;
<h1>Binding Reactive Data and Passing Props Data with v-bind</h1>&#13;
&#13;
<p>Previously we learned to use <code>v-model</code> for two-way binding and double curly braces <code>{{}}</code> for one-way data injection. But to perform one-way binding of data to another element as an attribute’s values or other Vue components as props, we use <code>v-bind</code><a data-primary="bindings" data-secondary="one-way" data-type="indexterm" id="id596"/><a data-primary="bindings" data-secondary="props" data-type="indexterm" id="id597"/><a data-primary="bindings" data-secondary="with v-bind" data-secondary-sortas="v-bind" data-type="indexterm" id="id598"/><a data-primary="data" data-secondary="binding, one-way" data-type="indexterm" id="id599"/><a data-primary="props" data-secondary="binding reactive data and passing props with v-bind" data-type="indexterm" id="id600"/><a data-primary="v-bind" data-secondary="binding reactive data and passing props" data-type="indexterm" id="id601"/>.</p>&#13;
&#13;
<p><code>v-bind</code>, denoted by <code>:</code>, is the most used Vue directive in any application. We can bind an element’s attribute (or component’s props) or more to JavaScript expressions, following this syntax<a data-primary="colon (:), for v-bind" data-type="indexterm" id="id602"/><a data-primary=": (colon), for v-bind" data-type="indexterm" id="id603"/><a data-primary="v-bind" data-secondary="syntax" data-type="indexterm" id="id604"/>:</p>&#13;
&#13;
<pre data-type="programlisting">v-bind:&lt;attribute&gt;="&lt;expression&gt;"</pre>&#13;
&#13;
<p>Or, for short, with <code>:</code> syntax:</p>&#13;
&#13;
<pre data-type="programlisting">:&lt;attribute&gt;="&lt;expression&gt;"</pre>&#13;
&#13;
<p>For example, we have <code>imageSrc</code> data, an image URL. To display the image using <code>&lt;img&gt;</code> tag, we perform the following binding to its <code>src</code> attribute:</p>&#13;
<div data-type="example" id="v_bind_01">&#13;
<h5><span class="label">Example 2-4. </span>Binding a source to an image</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;img :src="imageSrc" /&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">imageSrc</code><code class="o">:</code> <code class="s2">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>Vue takes the value of <code>imageSrc</code> and binds it to the <code>src</code> attribute, resulting in the following code on the DOM:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">img</code> <code class="na">src</code><code class="o">=</code><code class="s">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code> <code class="p">&gt;</code></pre>&#13;
&#13;
<p>Vue updates the <code>src</code> whenever <code>imageSrc</code>’s value changes.</p>&#13;
&#13;
<p>Also, you can add <code>v-bind</code> on an element as a standalone attribute. <code>v-bind</code> accepts an object containing all the attributes to bind as properties and the expressions as their values. <a data-type="xref" href="#v_bind_02">Example 2-5</a> rewrites <a data-type="xref" href="#v_bind_01">Example 2-4</a> to demonstrate this use case:</p>&#13;
<div data-type="example" id="v_bind_02">&#13;
<h5><span class="label">Example 2-5. </span>Binding source and alt text to an image using an object</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;img v-bind="image" /&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">image</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">src</code><code class="o">:</code> <code class="s2">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code><code class="p">,</code>&#13;
    <code class="nx">alt</code><code class="o">:</code> <code class="s2">"A random cute cate image"</code>&#13;
   <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>In <a data-type="xref" href="#v_bind_02">Example 2-5</a>, we bind an object <code>image</code> with two properties, <code>src</code> for the image URL and <code>alt</code> for its alt text to the element <code>&lt;img&gt;</code>. The Vue engine will automatically parse <code>image</code> into relevant attributes by its properties’ names, and then generate the following HTML code in the DOM:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">img</code>&#13;
 <code class="na">src</code><code class="o">=</code><code class="s">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code>&#13;
 <code class="na">alt</code><code class="o">=</code><code class="s">"A random cute cate image"</code>&#13;
<code class="p">&gt;</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Binding to Class and Style Attributes" data-type="sect1"><div class="sect1" id="id20">&#13;
<h1>Binding to Class and Style Attributes</h1>&#13;
&#13;
<p>When binding to <code>class</code> or <code>style</code> attributes, you can pass expressions in array or object type. The Vue engine knows how to parse and unite them into the proper styling or class name string<a data-primary="bindings" data-secondary="classes" data-type="indexterm" id="id605"/><a data-primary="classes" data-secondary="binding" data-type="indexterm" id="id606"/><a data-primary="attributes" data-secondary="binding style attributes" data-type="indexterm" id="ix-welcome-VueBasics16"/><a data-primary="bindings" data-secondary="style attributes" data-type="indexterm" id="ix-welcome-VueBasics16a"/><a data-primary="style" data-secondary="binding attributes" data-type="indexterm" id="ix-welcome-VueBasics16b"/><a data-primary="style attribute, binding to" data-type="indexterm" id="ix-welcome-VueBasics16c"/>.</p>&#13;
&#13;
<p>For example, let’s add some classes to our <code>img</code> in <a data-type="xref" href="#v_bind_02">Example 2-5</a>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;img v-bind="image" /&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">image</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">src</code><code class="o">:</code> <code class="s2">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code><code class="p">,</code>&#13;
    <code class="nx">alt</code><code class="o">:</code> <code class="s2">"A random cute cate image"</code><code class="p">,</code>&#13;
    <code class="kr">class</code><code class="o">:</code> <code class="p">[</code><code class="s2">"cat"</code><code class="p">,</code> <code class="s2">"image"</code><code class="p">]</code>&#13;
   <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>This code generates an <code>&lt;img&gt;</code> element with the class as a single string <code>"cat image"</code>, as in the following:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">img</code>&#13;
 <code class="na">src</code><code class="o">=</code><code class="s">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code>&#13;
 <code class="na">alt</code><code class="o">=</code><code class="s">"A random cute cate image"</code>&#13;
 <code class="na">class</code><code class="o">=</code><code class="s">"cat image"</code>&#13;
<code class="p">&gt;</code></pre>&#13;
&#13;
<p>You can also perform dynamic class names by binding the <code>class</code> attribute to an object whose properties’ values are according to the Boolean <code>isVisible</code> data value<a data-primary="classes" data-secondary="names" data-type="indexterm" id="id607"/><a data-primary="dynamic class names" data-type="indexterm" id="id608"/><a data-primary="names" data-secondary="classes" data-type="indexterm" id="id609"/><a data-primary="isVisible()" data-secondary="dynamic class names and" data-type="indexterm" id="id610"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">isVisible</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;img v-bind="image" /&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">image</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">src</code><code class="o">:</code> <code class="s2">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code><code class="p">,</code>&#13;
    <code class="nx">alt</code><code class="o">:</code> <code class="s2">"A random cute cate image"</code><code class="p">,</code>&#13;
    <code class="kr">class</code><code class="o">:</code> <code class="p">{</code>&#13;
     <code class="nx">cat</code><code class="o">:</code> <code class="nx">isVisible</code><code class="p">,</code>&#13;
     <code class="nx">image</code><code class="o">:</code> <code class="o">!</code><code class="nx">isVisible</code>&#13;
     <code class="p">}</code>&#13;
   <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Here we define the <code>img</code> element to have <code>cat</code> class when <code>isVisible</code> is <code>true</code>, and <code>image</code> otherwise. The generated DOM element for when <code>isVisible</code> is <code>true</code> now becomes:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">img</code>&#13;
 <code class="na">src</code><code class="o">=</code><code class="s">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code>&#13;
 <code class="na">alt</code><code class="o">=</code><code class="s">"A random cute cate image"</code>&#13;
 <code class="na">class</code><code class="o">=</code><code class="s">"cat"</code> <code class="p">&gt;</code></pre>&#13;
&#13;
<p>Output is similar when <code>isVisible</code> is <code>false</code>, with <code>image</code> instead of <code>cat</code> for the class name.</p>&#13;
&#13;
<p>You can use the same approach with the <code>style</code> attribute or pass an object containing CSS rules in CamelCase format. For example, let’s add some margins to our image in <a data-type="xref" href="#v_bind_02">Example 2-5</a>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;img v-bind="image" /&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">image</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">src</code><code class="o">:</code> <code class="s2">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code><code class="p">,</code>&#13;
    <code class="nx">alt</code><code class="o">:</code> <code class="s2">"A random cute cate image"</code><code class="p">,</code>&#13;
    <code class="nx">style</code><code class="o">:</code> <code class="p">{</code>&#13;
     <code class="nx">marginBlock</code><code class="o">:</code> <code class="s1">'10px'</code><code class="p">,</code>&#13;
     <code class="nx">marginInline</code><code class="o">:</code> <code class="s1">'15px'</code>&#13;
    <code class="p">}</code>&#13;
   <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>This code generates inline stylings for the <code>img</code> element with <code>margin-block: 10px</code> and <code>margin-inline: 15px</code> applied.</p>&#13;
&#13;
<p>You can also combine several style objects into a single <code>style</code> array. Vue knows how to unite them into a single style rule string, as follows<a data-primary="arrays" data-secondary="style arrays" data-type="indexterm" id="id611"/><a data-primary="style" data-secondary="style arrays" data-type="indexterm" id="id612"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;img v-bind="image" /&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">image</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">src</code><code class="o">:</code> <code class="s2">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code><code class="p">,</code>&#13;
    <code class="nx">alt</code><code class="o">:</code> <code class="s2">"A random cute cate image"</code><code class="p">,</code>&#13;
    <code class="nx">style</code><code class="o">:</code> <code class="p">[{</code>&#13;
     <code class="nx">marginBlock</code><code class="o">:</code> <code class="s2">"10px"</code><code class="p">,</code>&#13;
     <code class="nx">marginInline</code><code class="o">:</code> <code class="s2">"15px"</code>&#13;
    <code class="p">},</code> <code class="p">{</code>&#13;
     <code class="nx">padding</code><code class="o">:</code> <code class="s2">"10px"</code>&#13;
    <code class="p">}]</code>&#13;
   <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>The output DOM element will be:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">img</code>&#13;
 <code class="na">src</code><code class="o">=</code><code class="s">"https://res.cloudinary.com/mayashavin/image/upload/TheCute%20Cat"</code>&#13;
 <code class="na">alt</code><code class="o">=</code><code class="s">"A random cute cate image"</code>&#13;
 <code class="na">style</code><code class="o">=</code><code class="s">"margin-block: 10px; margin-inline: 15px; padding: 10px"</code> <code class="p">&gt;</code></pre>&#13;
<div data-type="tip"><h1>Using v-bind for Style</h1>&#13;
<p>In general, inline style is not a good practice. Hence I don’t recommend using <code>v-bind</code> for organizing component stylings. We will discuss the proper way of working with styling in Vue in <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a>.</p>&#13;
</div>&#13;
&#13;
<p>Next, let’s iterate over a data collection in a Vue component<a data-primary="" data-startref="ix-welcome-VueBasics16" data-type="indexterm" id="id613"/><a data-primary="" data-startref="ix-welcome-VueBasics16a" data-type="indexterm" id="id614"/><a data-primary="" data-startref="ix-welcome-VueBasics16b" data-type="indexterm" id="id615"/><a data-primary="" data-startref="ix-welcome-VueBasics16c" data-type="indexterm" id="id616"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterating over Data Collection Using v-for" data-type="sect1"><div class="sect1" id="id21">&#13;
<h1>Iterating over Data Collection Using v-for</h1>&#13;
&#13;
<p>Dynamic list rendering is essential to reduce repetitive code, increase code reusability, and maintain the format consistency between a group of similar element types. Some examples are a list of articles, active users, and TikTok accounts you follow. The data is dynamic in these examples, while the type of content and the UI layout remain similar<a data-primary="data" data-secondary="iterating with v-for" data-type="indexterm" id="ix-welcome-VueBasics17"/><a data-primary="arrays" data-secondary="iterating over with v-for" data-type="indexterm" id="ix-welcome-VueBasics17a"/><a data-primary="iterating" data-secondary="with v-for" data-secondary-sortas="v-for" data-type="indexterm" id="ix-welcome-VueBasics17b"/><a data-primary="lists, iterating over with v-for" data-type="indexterm" id="ix-welcome-VueBasics17c"/><a data-primary="v-for" data-secondary="using" data-type="indexterm" id="ix-welcome-VueBasics17d"/>.</p>&#13;
&#13;
<p>Vue provides a <code>v-for</code> directive to accomplish the goal of iterating through an iterative data collection, such as an array or object. We use this directive directly on an element, following this syntax:</p>&#13;
&#13;
<pre data-type="programlisting">v-for = "elem in list"</pre>&#13;
&#13;
<p><code>elem</code> is just an alias for each element in the data source <code>list</code><a data-primary="elem as alias for elements" data-type="indexterm" id="id617"/><a data-primary="elements" data-secondary="elem alias" data-type="indexterm" id="id618"/>.</p>&#13;
&#13;
<p>For example, if we want to iterate through an array of numbers <code>[1, 2, 3, 4, 5]</code> and print out the element value, we use the following code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">List</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;ul&gt;</code>&#13;
<code class="sb">   &lt;li v-for="number in numbers" :key="number"&gt;{{number}}&lt;/li&gt;</code>&#13;
<code class="sb">  &lt;/ul&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">numbers</code><code class="o">:</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">]</code>&#13;
  <code class="p">};</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">({</code>&#13;
 <code class="nx">components</code><code class="o">:</code> <code class="p">{</code> <code class="nx">List</code> <code class="p">},</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`&lt;List /&gt;`</code>&#13;
<code class="p">})</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>This code equals writing the following native HTML code:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>1<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>2<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>3<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>4<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>5<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>One significant advantage of using <code>v-for</code> is to keep the template consistent and map the data content dynamically to the relevant element, regardless of how the data source may change over time.</p>&#13;
&#13;
<p>Each block generated by the <code>v-for</code> iteration has access to other components’ data and the specific list item. Take <a data-type="xref" href="#tasks">Example 2-6</a>, for instance.</p>&#13;
<div data-type="example" id="tasks">&#13;
<h5><span class="label">Example 2-6. </span>Writing a task list component using <code>v-for</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">List</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb"> &lt;ul&gt;</code>&#13;
<code class="sb">  &lt;li v-for="task in tasks" :key="task.id"&gt;</code>&#13;
<code class="sb">   {{title}}: {{task.description}}</code>&#13;
<code class="sb">  &lt;/li&gt;</code>&#13;
<code class="sb"> &lt;/ul&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">tasks</code><code class="o">:</code> <code class="p">[{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'task01'</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code> <code class="s1">'Buy groceries'</code><code class="p">,</code>&#13;
   <code class="p">},</code> <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'task02'</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code> <code class="s1">'Do laundry'</code><code class="p">,</code>&#13;
   <code class="p">},</code> <code class="p">{</code>&#13;
    <code class="nx">id</code><code class="o">:</code> <code class="s1">'task03'</code><code class="p">,</code>&#13;
    <code class="nx">description</code><code class="o">:</code> <code class="s1">'Watch Moonknight'</code><code class="p">,</code>&#13;
   <code class="p">}],</code>&#13;
   <code class="nx">title</code><code class="o">:</code> <code class="s1">'Task'</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">({</code>&#13;
 <code class="nx">components</code><code class="o">:</code> <code class="p">{</code> <code class="nx">List</code> <code class="p">},</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`&lt;List /&gt;`</code>&#13;
<code class="p">})</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p><a data-type="xref" href="#figure_11">Figure 2-13</a> displays the output:</p>&#13;
&#13;
<figure><div class="figure" id="figure_11">&#13;
<img alt="Output is a list with each row display description of a task" src="assets/lvue_0213.png"/>&#13;
<h6><span class="label">Figure 2-13. </span>Output of tasks list with the default title for each row</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h1>Keeping the Uniqueness with the Key Attribute</h1>&#13;
<p>Here we <em>must</em> define a unique <code>key</code> attribute for each iterated element. Vue uses this attribute to keep track of each element rendered for a later update. See <a data-type="xref" href="#key_attribute">“Make the Element Binding Unique with Key Attribute”</a> for discussion on its &#13;
<span class="keep-together">importance</span><a data-primary="key attribute" data-secondary="uniqueness of" data-type="indexterm" id="id619"/><a data-primary="key attribute" data-secondary="iteration with v-for and" data-type="indexterm" id="ix-welcome-VueBasics18"/>.</p>&#13;
</div>&#13;
&#13;
<p>Also, <code>v-for</code> supports an optional second argument, <code>index</code>, the current element’s appearance index in the iterating collection. We can rewrite <a data-type="xref" href="#tasks">Example 2-6</a> as follows<a data-primary="index argument and v-for" data-type="indexterm" id="id620"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">List</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb"> &lt;ul&gt;</code>&#13;
<code class="sb">  &lt;li v-for="(task, index) in tasks" :key="task.id"&gt;</code>&#13;
<code class="sb">   {{title}} {{index}}: {{task.description}}</code>&#13;
<code class="sb">  &lt;/li&gt;</code>&#13;
<code class="sb"> &lt;/ul&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="c1">//...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">//...</code></pre>&#13;
&#13;
<p>This code block generates the following output (<a data-type="xref" href="#figure_12">Figure 2-14</a>):</p>&#13;
&#13;
<figure><div class="figure" id="figure_12">&#13;
<img alt="Output is the list of 3 rows, with a prefix of the index for each row, from 0 to 2" src="assets/lvue_0214.png"/>&#13;
<h6><span class="label">Figure 2-14. </span>Output of the task list with each task’s index</h6>&#13;
</div></figure>&#13;
&#13;
<p>So far, we have covered iteration with array collection. Let’s look at how we iterate through the properties of an object.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterating Through Object Properties" data-type="sect2"><div class="sect2" id="id22">&#13;
<h2>Iterating Through Object Properties</h2>&#13;
&#13;
<p>In JavaScript, an <code>Object</code> is a type of <em>key-value map table</em>, with each object’s property being the <em>unique key</em> of the table. To iterate through the properties of an object, we use similar syntax with array iteration<a data-primary="iterating" data-secondary="object properties" data-type="indexterm" id="ix-welcome-VueBasics19"/><a data-primary="properties" data-secondary="iterating over object properties with v-for" data-type="indexterm" id="ix-welcome-VueBasics19a"/><a data-primary="object properties, iterating with v-for" data-type="indexterm" id="ix-welcome-VueBasics19b"/>:</p>&#13;
&#13;
<pre data-type="programlisting">v-for = "(value, name) in collection"</pre>&#13;
&#13;
<p>Here <code>value</code> stands for the value of a property and <code>name</code> for that property’s key.</p>&#13;
&#13;
<p>The following shows how we iterate through properties of an object collection and print out each property’s <code>name</code> and <code>value</code> according to the format <code>&lt;name&gt;: &lt;value&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code><code> </code><code class="p">{</code><code> </code><code class="nx">createApp</code><code> </code><code class="p">}</code><code> </code><code class="nx">from</code><code> </code><code class="s1">'vue'</code><code>&#13;
&#13;
</code><code class="kr">const</code><code> </code><code class="nx">Collection</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
 </code><code class="nx">data</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="p">{</code><code>&#13;
   </code><code class="nx">collection</code><code class="o">:</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_how_vue_works__the_basics_CO1-1" id="co_how_vue_works__the_basics_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
    </code><code class="nx">title</code><code class="o">:</code><code> </code><code class="s1">'Watch Moonknight'</code><code class="p">,</code><code>&#13;
    </code><code class="nx">description</code><code class="o">:</code><code> </code><code class="s1">'Log in to Disney+ and watch all the chapters'</code><code class="p">,</code><code>&#13;
    </code><code class="nx">priority</code><code class="o">:</code><code> </code><code class="s1">'5'</code><code>&#13;
   </code><code class="p">}</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
 </code><code class="p">}</code><code class="p">,</code><code>&#13;
 </code><code class="nx">template</code><code class="o">:</code><code> </code><code class="sb">`</code><code class="sb">&#13;
 &lt;ul&gt;&#13;
  &lt;li v-for="(value, name) in collection" :key="name"&gt; </code><a class="co" href="#callout_how_vue_works__the_basics_CO1-2" id="co_how_vue_works__the_basics_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="sb">&#13;
   {{name}}: {{value}}&#13;
  &lt;/li&gt;&#13;
 &lt;/ul&gt;&#13;
 </code><code class="sb">`</code><code class="p">,</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kr">const</code><code> </code><code class="nx">app</code><code> </code><code class="o">=</code><code> </code><code class="nx">createApp</code><code class="p">(</code><code class="p">{</code><code>&#13;
 </code><code class="nx">components</code><code class="o">:</code><code> </code><code class="p">{</code><code> </code><code class="nx">Collection</code><code> </code><code class="p">}</code><code class="p">,</code><code>&#13;
 </code><code class="nx">template</code><code class="o">:</code><code> </code><code class="sb">`</code><code class="sb">&lt;Collection /&gt;</code><code class="sb">`</code><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code>&#13;
&#13;
</code><code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_vue_works__the_basics_CO1-1" id="callout_how_vue_works__the_basics_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Define a <code>collection</code> object with three properties: <code>title</code>, <code>description</code>, and &#13;
<span class="keep-together"><code>priority</code></span></p></dd>&#13;
<dt><a class="co" href="#co_how_vue_works__the_basics_CO1-2" id="callout_how_vue_works__the_basics_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Iterate through the properties of <code>collection</code></p></dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#figure_13">Figure 2-15</a> shows the output.</p>&#13;
&#13;
<figure><div class="figure" id="figure_13">&#13;
<img alt="Output is a list with each row display the title, description, and priority of a collection object" src="assets/lvue_0215.png"/>&#13;
<h6><span class="label">Figure 2-15. </span>Output of collection object with default title</h6>&#13;
</div></figure>&#13;
&#13;
<p>We still have access to the index appearance of the present pair as the third argument, as in the following syntax:</p>&#13;
&#13;
<pre data-type="programlisting">v-for = “(value, name, index) in collection”</pre>&#13;
&#13;
<p>As noted earlier, we always have to define a <code>key</code> attribute value for each iterating element. This attribute is significant in making the element update binding unique. We will explore the <code>key</code> attribute next<a data-primary="" data-startref="ix-welcome-VueBasics17" data-type="indexterm" id="id621"/><a data-primary="" data-startref="ix-welcome-VueBasics17a" data-type="indexterm" id="id622"/><a data-primary="" data-startref="ix-welcome-VueBasics17b" data-type="indexterm" id="id623"/><a data-primary="" data-startref="ix-welcome-VueBasics17c" data-type="indexterm" id="id624"/><a data-primary="" data-startref="ix-welcome-VueBasics17d" data-type="indexterm" id="id625"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Make the Element Binding Unique with Key Attribute" data-type="sect2"><div class="sect2" id="key_attribute">&#13;
<h2>Make the Element Binding Unique with Key Attribute</h2>&#13;
&#13;
<p>The Vue engine tracks and updates the elements rendered with <code>v-for</code> by a simple in-place patch strategy. However, in various scenarios, we need to take complete control over list reordering or prevent unwanted behavior when the list element relies on its child component’s state.</p>&#13;
&#13;
<p>Vue provides an additional attribute: a <code>key</code>, as a <em>unique identity for each node element</em>, binds to a specific iterated list item. The Vue engine uses it as a hint to track, reuse, and reorder the rendered nodes and their nested elements instead of in-place &#13;
<span class="keep-together">patching</span><a data-primary="bindings" data-secondary="key attribute and" data-type="indexterm" id="id626"/><a data-primary="elements" data-secondary="element binding and key attribute" data-type="indexterm" id="id627"/><a data-primary="key attribute" data-secondary="binding with" data-type="indexterm" id="id628"/>.</p>&#13;
&#13;
<p class="pagebreak-before">The syntax usage of a <code>key</code> attribute is straightforward. We use <code>v-bind:key</code> (<code>:key</code> for short) and bind a <em>unique</em> value to that list element<a data-primary="key attribute" data-secondary="syntax" data-type="indexterm" id="id629"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code> <code class="na">v-for</code><code class="o">=</code><code class="s">"(value, name, index) in collection"</code> <code class="na">:key</code><code class="o">=</code><code class="s">"index"</code><code class="p">&gt;</code></pre>&#13;
<div data-type="tip"><h1>Keeping the Key’s Uniqueness</h1>&#13;
<p>The <code>key</code> should be the item’s <em>distinct identifier</em> (id) or its <em>appearance index</em> in the list.</p>&#13;
</div>&#13;
&#13;
<p>As a good practice, you must always provide the <code>key</code> attribute when using <code>v-for</code>.</p>&#13;
&#13;
<p>Nevertheless, Vue will throw a warning on the browser console if no <code>key</code> is presented. Also, if you enable ESLint in your application, it throws an error and instantly warns you about the missing <code>key</code> attribute, as shown in <a data-type="xref" href="#figure_14">Figure 2-16</a><a data-primary="linters" data-type="indexterm" id="id630"/><a data-primary="ESLint" data-type="indexterm" id="id631"/>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_14">&#13;
<img alt="ESLint tool highlights and displays warning when we try to iterate a list with item key presented" src="assets/lvue_0216.png"/>&#13;
<h6><span class="label">Figure 2-16. </span>ESLint warning when no key is presented</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h1>Valid Values for the Key Attribute</h1>&#13;
<p>A key should be a string or numeric value. An object or array is <em>not</em> a valid key to use<a data-primary="key attribute" data-secondary="valid values for" data-type="indexterm" id="id632"/>.</p>&#13;
</div>&#13;
&#13;
<p>The <code>key</code> attribute is helpful, even beyond the scope of <code>v-for</code>. Without a <code>key</code> attribute, applying the built-in list transition and animation effect is impossible. We’ll discuss more about the benefits of <code>key</code> in <a data-type="xref" href="ch08.html#unique_chapter_id_07">Chapter 8</a><a data-primary="" data-startref="ix-welcome-VueBasics18" data-type="indexterm" id="id633"/><a data-primary="" data-startref="ix-welcome-VueBasics19" data-type="indexterm" id="id634"/><a data-primary="" data-startref="ix-welcome-VueBasics19a" data-type="indexterm" id="id635"/><a data-primary="" data-startref="ix-welcome-VueBasics19b" data-type="indexterm" id="id636"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding Event Listener to Elements with v-on" data-type="sect1"><div class="sect1" id="v_on">&#13;
<h1>Adding Event Listener to Elements with v-on</h1>&#13;
&#13;
<p>To bind a DOM event to a listener, Vue exposes the built-in directive <code>v-on</code> (for short <code>@</code>) for element tags. The <code>v-on</code> directive accepts the following value types<a data-primary="bindings" data-secondary="event listeners with v-on" data-type="indexterm" id="ix-welcome-VueBasics20"/><a data-primary="event listeners" data-secondary="binding with v-on" data-type="indexterm" id="ix-welcome-VueBasics20a"/><a data-primary="events" data-secondary="binding event listeners with v-on" data-type="indexterm" id="ix-welcome-VueBasics20b"/><a data-primary="v-on" data-type="indexterm" id="ix-welcome-VueBasics20c"/>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Some inline JavaScript statements in the form of a string</p>&#13;
</li>&#13;
<li>&#13;
<p>Name of the component method declared in the component options under &#13;
<span class="keep-together"><code>methods</code></span> property</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p class="pagebreak-before">We use <code>v-on</code> with the following format:</p>&#13;
&#13;
<pre data-type="programlisting">v-on:&lt;event&gt;= “&lt;inline JavaScript code / name of method&gt;”</pre>&#13;
&#13;
<p>Or with the shorter version using <code>@</code><a data-primary="at symbol (@) for v-on" data-type="indexterm" id="id637"/><a data-primary="@ (at symbol) for v-on" data-type="indexterm" id="id638"/>:</p>&#13;
&#13;
<pre data-type="programlisting">@&lt;event&gt;=”&lt;inline JavaScript code / name of method&gt;”</pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>From this point on, we will use <code>@</code> to denote <code>v-on</code>.</p>&#13;
</div>&#13;
&#13;
<p>Then add this directive directly on any element as an attribute:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">button</code> <code class="err">@</code><code class="na">click</code><code class="o">=</code> <code class="s">"printMsg='Button is clicked!'"</code><code class="p">&gt;</code>&#13;
Click me&#13;
<code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>For code readability, especially in a complex codebase, I recommend keeping the JavaScript expression inside a component’s method and exposing the use through its name on the directive, as in <a data-type="xref" href="#click_print">Example 2-7</a>.</p>&#13;
<div data-type="example" id="click_print">&#13;
<h5><span class="label">Example 2-7. </span>Change <code>printMsg</code>’s value on button click using <code>v-on</code> directive</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code><code class="p">,</code> <code class="nx">type</code> <code class="nx">ComponentOptions</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">Data</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">printMsg</code><code class="o">:</code> <code class="nx">string</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;button @click="printMessage"&gt;Click me&lt;/button&gt;</code>&#13;
<code class="sb">  &lt;div&gt;{{ printMsg }}&lt;/div&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">methods</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">printMessage</code><code class="p">()</code> <code class="p">{</code>&#13;
   <code class="p">(</code><code class="k">this</code> <code class="nx">as</code> <code class="nx">ComponentOptions</code><code class="o">&lt;</code><code class="nx">Data</code><code class="o">&gt;</code><code class="p">).</code><code class="nx">printMsg</code> <code class="o">=</code> <code class="s2">"Button is clicked!"</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">},</code>&#13;
 <code class="nx">data</code><code class="p">()</code><code class="o">:</code> <code class="nx">Data</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">printMsg</code><code class="o">:</code> <code class="s2">"Nothing to print yet!"</code><code class="p">,</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s2">"#app"</code><code class="p">);</code></pre></div>&#13;
&#13;
<p>If the user hasn’t clicked the button, the display message below the button will be “Nothing to print yet” (<a data-type="xref" href="#figure_22">Figure 2-17</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_22">&#13;
<img alt="A screenshot shows a message 'Nothing to print yet!'" src="assets/lvue_0217.png"/>&#13;
<h6><span class="label">Figure 2-17. </span>“Nothing to print yet” message appears as default</h6>&#13;
</div></figure>&#13;
&#13;
<p>Otherwise, the message will change to “Button is clicked!” (<a data-type="xref" href="#figure_23">Figure 2-18</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_23">&#13;
<img alt="A text showing 'Button is clicked!' appears after the Click me button " src="assets/lvue_0218.png"/>&#13;
<h6><span class="label">Figure 2-18. </span>“Button is clicked!” message appears after user clicks the button</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Handling Events with v-on Event Modifiers" data-type="sect2"><div class="sect2" id="id25">&#13;
<h2>Handling Events with v-on Event Modifiers</h2>&#13;
&#13;
<p>Before the browser dispatches an event on a target element, it constructs that event’s propagation path list using the current DOM tree structure. The last node in this path is the target itself, and the other preceding nodes are its ancestors, respectively, in order. Once dispatched, the event travels through one or all three main event phases (<a data-type="xref" href="#figure_24">Figure 2-19</a>)<a data-primary="event listeners" data-secondary="event modifiers" data-type="indexterm" id="ix-welcome-VueBasics21"/><a data-primary="events" data-secondary="event modifiers" data-type="indexterm" id="ix-welcome-VueBasics21a"/><a data-primary="DOM (Document Object Model)" data-secondary="event phases and" data-type="indexterm" id="id639"/><a data-primary="events" data-secondary="phases of" data-type="indexterm" id="id640"/>:</p>&#13;
<dl>&#13;
<dt>Capturing (or capture phase)</dt>&#13;
<dd>&#13;
<p>The event travels (or propagates) from the top ancestor down to the target &#13;
<span class="keep-together">element</span><a data-primary="capture phase and events" data-type="indexterm" id="id641"/>.</p>&#13;
</dd>&#13;
<dt>Target</dt>&#13;
<dd>&#13;
<p>The event is at the target element<a data-primary="target" data-secondary="phase and events" data-type="indexterm" id="id642"/>.</p>&#13;
</dd>&#13;
<dt>Bubbling</dt>&#13;
<dd>&#13;
<p>The event travels (or bubbles) from the target element up to its ancestor<a data-primary="bubbling and events" data-type="indexterm" id="id643"/>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>We usually interfere with this event propagation flow programmatically within the listener logic. With <code>v-on</code>’s modifiers, we can interfere directly on the directive level.</p>&#13;
&#13;
<p>Use <code>v-on</code> modifiers following this format:</p>&#13;
&#13;
<pre data-type="programlisting">v-on:&lt;event&gt;.&lt;modifier&gt;</pre>&#13;
&#13;
<figure><div class="figure" id="figure_24">&#13;
<img alt="A diagram shows the levels of propagation phases, from bottom up and top down." src="assets/lvue_0219.png"/>&#13;
<h6><span class="label">Figure 2-19. </span>Flow of propagation for a click event</h6>&#13;
</div></figure>&#13;
&#13;
<p>One advantage of modifiers is that they keep the listener as generic and reusable as possible. We do not need to worry internally about event-specific details, such as &#13;
<span class="keep-together"><code>preventDefault</code></span> or <code>stopPropagation</code>.</p>&#13;
&#13;
<p>Take <a data-type="xref" href="#event_propagation">Example 2-8</a>, for instance.</p>&#13;
<div data-type="example" id="event_propagation">&#13;
<h5><span class="label">Example 2-8. </span>Manually stop the propagation using <code>stopPropagation()</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;button @click="printMessage"&gt;Click me&lt;/button&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">methods</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">printMessage</code><code class="p">(</code><code class="nx">e</code><code class="o">:</code> <code class="nx">Event</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="k">if</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">e</code><code class="p">.</code><code class="nx">stopPropagation</code><code class="p">()</code>&#13;
   <code class="p">}</code>&#13;
&#13;
   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Button is clicked!"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">},</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>Here we have to stop the propagation ourselves with <code>e.stopPropagation</code>, adding another validation layer to make sure <code>e</code> exists. <a data-type="xref" href="#v_on_stop">Example 2-9</a> shows how we can rewrite <a data-type="xref" href="#event_propagation">Example 2-8</a> using the <code>@click.stop</code> modifier.</p>&#13;
<div data-type="example" id="v_on_stop">&#13;
<h5><span class="label">Example 2-9. </span>Stop propagation using <code>@click.stop</code> modifier</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;button @click.stop="printMessage"&gt;Click me&lt;/button&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">methods</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">printMessage</code><code class="p">()</code> <code class="p">{</code>&#13;
   <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Button is clicked!"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">},</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p><a data-type="xref" href="#on_modifiers_table">Table 2-1</a> shows the complete list of event modifiers available, briefly explaining the equivalent event functionalities or behavior<a data-primary=".capture event modifier" data-primary-sortas="capture event modifier" data-type="indexterm" id="id644"/><a data-primary=".once event modifier" data-primary-sortas="once event modifier" data-type="indexterm" id="id645"/><a data-primary=".prevent event modifier" data-primary-sortas="prevent event modifier" data-type="indexterm" id="id646"/><a data-primary=".self event modifier" data-primary-sortas="self event modifier" data-type="indexterm" id="id647"/><a data-primary=".stop event modifier" data-primary-sortas="stop event modifier" data-type="indexterm" id="id648"/><a data-primary=".passive event modifier" data-primary-sortas="passive event modifier" data-type="indexterm" id="id649"/>.</p>&#13;
<table id="on_modifiers_table">&#13;
<caption><span class="label">Table 2-1. </span>Event modifiers for <code>v-on</code> directive</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Modifier</th>&#13;
<th>Description</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>.stop</code></p></td>&#13;
<td><p>Instead of calling <code>event.stopPropagation()</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>.prevent</code></p></td>&#13;
<td><p>Instead of calling <code>event.preventDefault()</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>.self</code></p></td>&#13;
<td><p>Trigger the event listener <em>only if</em> the event’s target is the element where we attach the listener.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>.once</code></p></td>&#13;
<td><p>Trigger the event listener <em>at most once</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>.capture</code></p></td>&#13;
<td><p>Instead of passing <code>{ capture: true }</code> as the third parameter for <code>addEventListener()</code>, or <code>capture="true"</code> in the element. This modifier triggers the listener in the <em>capturing phase</em> order, instead of regular bubbling phase order.</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>.passive</code></p></td>&#13;
<td><p>Mainly to opt-in for <em>better scroll performance</em> and prevent triggering <code>event.preventDefault()</code>. We use it instead of passing <code>{ passive: true }</code> as the third parameter for <code>addEventListener()</code> or adding <code>passive="true"</code> to the element.</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
<div data-type="tip"><h1>Chaining Modifiers</h1>&#13;
<p>Event modifiers support chaining. This means you can write expressions such as <code>@click.stop.prevent=" printMessage"&gt;</code> on the element tag. This expression equals calling both <code>event.stop</code>&#13;
<span class="keep-together"><code>Propagation()</code></span> and <code>event.preventDefault()</code> inside the event handler, in the order in which they appear<a data-primary="" data-startref="ix-welcome-VueBasics21" data-type="indexterm" id="id650"/><a data-primary="" data-startref="ix-welcome-VueBasics21a" data-type="indexterm" id="id651"/><a data-primary="event listeners" data-secondary="event modifiers, chaining" data-type="indexterm" id="id652"/><a data-primary="events" data-secondary="event modifiers, chaining" data-type="indexterm" id="id653"/>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Detecting Keyboard Events with Key Code Modifiers" data-type="sect2"><div class="sect2" id="id26">&#13;
<h2>Detecting Keyboard Events with Key Code Modifiers</h2>&#13;
&#13;
<p>While event modifiers are for interfering with the event propagation flow, <em>key modifiers</em> help detect special keys of keyboard events such as <code>keyup</code>, <code>keydown</code>, and <code>keypress</code><a data-primary="events" data-secondary="keyboard events and key code modifiers" data-type="indexterm" id="id654"/><a data-primary="keyboard events and key code modifiers" data-type="indexterm" id="id655"/><a data-primary="key code modifiers" data-type="indexterm" id="id656"/>.</p>&#13;
&#13;
<p>Usually, to detect a specific key, we need to perform two steps<a data-primary=".enter key modifier" data-primary-sortas="enter key modifier" data-type="indexterm" id="id657"/>:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Identify the key code, <code>key</code>, or the <code>code</code> represented by that key. For instance, the <code>keyCode</code> for <code>Enter</code> is 13, its <code>key</code> is “Enter”, and its <code>code</code> is “Enter.”</p>&#13;
</li>&#13;
<li>&#13;
<p>When firing the event handler, within the handler, we need to check manually that <code>event.keyCode</code> (or <code>event.code</code> or <code>event.key</code>) matches the target key code.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This approach is not efficient for maintaining reusable and clean code in a large codebase. <code>v-on</code> comes with built-in key modifiers as a better alternative. If we want to detect if the user types the <em>Enter</em> key, we add the modifier <code>.enter</code> to the related <code>keydown</code> event, following the same syntax when using event modifiers.</p>&#13;
&#13;
<p>Let’s assume we have an input element, and we log a message to the console whenever a user presses <em>Enter</em>, as seen in <a data-type="xref" href="#enter_key_check">Example 2-10</a>.</p>&#13;
<div data-type="example" id="enter_key_check">&#13;
<h5><span class="label">Example 2-10. </span>Manual check if <code>keyCode</code> is 13 stands for Enter key</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`&lt;input @keydown="onEnter" &gt;`</code><code class="p">,</code>&#13;
 <code class="nx">methods</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">onEnter</code><code class="p">(</code><code class="nx">e</code><code class="o">:</code> <code class="nx">KeyboardEvent</code><code class="p">)</code> <code class="p">{</code>&#13;
   <code class="k">if</code> <code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">keyCode</code> <code class="o">===</code> <code class="s1">'13'</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'User pressed Enter!'</code><code class="p">)</code>&#13;
   <code class="p">}</code>&#13;
&#13;
   <code class="cm">/*...*/</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>We now can rewrite it using <code>@keydown.enter</code>.</p>&#13;
<div data-type="example" id="keydown_enter">&#13;
<h5><span class="label">Example 2-11. </span>Checking for Enter key pressed by <code>@keydown.enter</code> modifier</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`&lt;input @keydown.enter="onEnter" &gt;`</code><code class="p">,</code>&#13;
 <code class="nx">methods</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="nx">onEnter</code><code class="p">(</code><code class="nx">e</code><code class="o">:</code> <code class="nx">KeyboardEvent</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s1">'User pressed Enter!'</code><code class="p">)</code>&#13;
   <code class="cm">/*...*/</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>The app behaves the same in both cases<a data-primary=".alt key modifier" data-primary-sortas="alt key modifier" data-type="indexterm" id="id658"/><a data-primary=".ctrl key modifier" data-primary-sortas="ctrl key modifier" data-type="indexterm" id="id659"/><a data-primary=".delete key modifier" data-primary-sortas="delete key modifier" data-type="indexterm" id="id660"/><a data-primary=".esc key modifier" data-primary-sortas="esc key modifier" data-type="indexterm" id="id661"/><a data-primary=".meta key modifier" data-primary-sortas="meta key modifier" data-type="indexterm" id="id662"/><a data-primary=".shift key modifier" data-primary-sortas="shift key modifier" data-type="indexterm" id="id663"/><a data-primary=".space key modifier" data-primary-sortas="space key modifier" data-type="indexterm" id="id664"/><a data-primary=".system key modifier" data-primary-sortas="system key modifier" data-type="indexterm" id="id665"/><a data-primary=".tab key modifier" data-primary-sortas="tab key modifier" data-type="indexterm" id="id666"/>.</p>&#13;
&#13;
<p>A few other commonly used key modifiers are <code>.tab</code>, <code>.delete</code>, <code>.esc</code>, and <code>.space</code>.</p>&#13;
&#13;
<p>Another popular use case is to capture a special keys combination, such as <em>Ctrl &amp; Enter</em> (<em>CMD &amp; Enter</em> for MacOS) or <em>Shift + S</em>. In these scenarios, we chain the <em>system</em> key modifiers (<code>.shift</code>, <code>.ctrl</code>, <code>.alt</code> and <code>.meta</code> for <em>CMD</em> key in MacOS) with <em>key code</em> modifiers, as in the following example:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cm">&lt;!-- Ctrl + Enter --&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">input</code> <code class="err">@</code><code class="na">keyup</code><code class="err">.</code><code class="na">ctrl</code><code class="err">.</code><code class="na">13</code><code class="o">=</code><code class="s">”onCtrlEnter”</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Or chaining the shift modifier and key code modifier for <code>S</code> key (<code>keyCode</code> is <code>83</code>):</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cm">&lt;!-- Shift + S --&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">input</code> <code class="err">@</code><code class="na">keyup</code><code class="err">.</code><code class="na">shift</code><code class="err">.</code><code class="na">83</code><code class="o">=</code><code class="s">”onSave”</code><code class="p">&gt;</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h1>Chaining System Modifiers and Key Code Modifiers</h1>&#13;
<p>You <em>must</em> use key code modifiers instead of standard key modifiers, meaning <code>.13</code> in place of <code>.enter</code> for this type of chaining.</p>&#13;
</div>&#13;
&#13;
<p>Also, to capture the exact key combinations for triggering an event, we use the <code>.exact</code> modifier<a data-primary=".exact key modifier" data-primary-sortas="exact key modifier" data-type="indexterm" id="id667"/>:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">button</code> <code class="err">@</code><code class="na">click</code><code class="err">.</code><code class="na">shift</code><code class="err">.</code><code class="na">exact</code><code class="o">=</code><code class="s">”onShiftEnter”</code> <code class="p">/&gt;</code></pre>&#13;
&#13;
<p>Combining <code>.shift</code> and <code>.exact</code> makes sure the click event fires when the user presses <em>only</em> the Shift key while clicking the button<a data-primary="" data-startref="ix-welcome-VueBasics20" data-type="indexterm" id="id668"/><a data-primary="" data-startref="ix-welcome-VueBasics20a" data-type="indexterm" id="id669"/><a data-primary="" data-startref="ix-welcome-VueBasics20b" data-type="indexterm" id="id670"/><a data-primary="" data-startref="ix-welcome-VueBasics20c" data-type="indexterm" id="id671"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conditional Rendering Elements with v-if, v-else, &#10;and v-else-if" data-type="sect1"><div class="sect1" id="id27">&#13;
<h1>Conditional Rendering Elements with v-if, v-else, &#13;
<span class="keep-together">and v-else-if</span></h1>&#13;
&#13;
<p>We also can generate or remove an element from the DOM, a scenario called <em>conditional rendering</em><a data-primary="DOM (Document Object Model)" data-secondary="conditional rendering with v-if, v-else, and v-else-if" data-type="indexterm" id="ix-welcome-VueBasics22"/><a data-primary="rendering" data-secondary="conditional rendering with v-if, v-else, and v-else-if" data-type="indexterm" id="ix-welcome-VueBasics22a"/><a data-primary="v-else" data-type="indexterm" id="ix-welcome-VueBasics22b"/><a data-primary="v-else-if" data-type="indexterm" id="ix-welcome-VueBasics22c"/><a data-primary="v-if" data-secondary="conditional rendering with" data-type="indexterm" id="ix-welcome-VueBasics22d"/>.</p>&#13;
&#13;
<p>Assume we have a Boolean data property <code>isVisible</code>, which decides if Vue should render a text element into the DOM and make it visible to the user. Binding directive <code>v-if</code> to <code>isVisible</code> by placing <code>v-if="isVisible"</code> on the text element enables reactively rendering the element only when <code>isVisible</code> is <code>true</code> (<a data-type="xref" href="#example_v_if">Example 2-12</a>)<a data-primary="bindings" data-secondary="v-if and" data-type="indexterm" id="id672"/><a data-primary="isVisible()" data-secondary="v-if and" data-type="indexterm" id="id673"/>.</p>&#13;
<div data-type="example" id="example_v_if">&#13;
<h5><span class="label">Example 2-12. </span>Example usage for <code>v-if</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div&gt;</code>&#13;
<code class="sb">   &lt;div v-if="isVisible"&gt;I'm the text in toggle&lt;/div&gt;</code>&#13;
<code class="sb">   &lt;div&gt;Visibility: {{isVisible}}&lt;/div&gt;</code>&#13;
<code class="sb">  &lt;/div&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">isVisible</code><code class="o">:</code> <code class="kc">false</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>When setting <code>isVisible</code> to <code>false</code>, the generated DOM elements will look like this:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
 <code class="cm">&lt;!--v-if--&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>Visibility: false<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Otherwise, the text element will be visible in the DOM:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>I'm the text in toggle<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>Visibility: true<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>If we want to render a different component for the opposite condition (<code>isVisible</code> is <code>false</code>), <code>v-else</code> is the right choice. Unlike <code>v-if</code>, you use <code>v-else</code> without binding to any data property. It takes the correct condition value based on the immediate preceding <code>v-if</code> usage in the same context level.</p>&#13;
<div data-type="warning" epub:type="warning"><h1>Using v-else</h1>&#13;
<p><code>v-else</code> works only when <code>v-if</code> exists, and it must always present last in a chaining conditional rendering<a data-primary="rendering" data-secondary="chaining conditional" data-type="indexterm" id="id674"/>.</p>&#13;
</div>&#13;
&#13;
<p>For example, as <a data-type="xref" href="#v_if_simple">Example 2-13</a> shows, we can create a component with the following code block with both <code>v-if</code> and <code>v-else</code>.</p>&#13;
<div data-type="example" id="v_if_simple">&#13;
<h5><span class="label">Example 2-13. </span>Conditional display of different texts using <code>v-if</code> and <code>v-else</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div&gt;</code>&#13;
<code class="sb">   &lt;div v-if="isVisible"&gt;I'm the visible text&lt;/div&gt;</code>&#13;
<code class="sb">   &lt;div v-else&gt;I'm the replacement text&lt;/div&gt;</code>&#13;
<code class="sb">  &lt;/div&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">isVisible</code><code class="o">:</code> <code class="kc">false</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>In short, you can translate the previous conditions into similar logical expressions as:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cm">&lt;!--if isVisible is true, then render --&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>I'm the visible text<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="cm">&lt;!-- else render --&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>I'm the replacement text<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>As in any <code>if…else</code> logic expression, we can always extend the condition check with an <code>else if</code> condition block. This condition block equals a <code>v-else-if</code> directive and also requires a JavaScript condition statement. <a data-type="xref" href="#v_else_if">Example 2-14</a> shows how to display a text, <code>I’m the subtitle text</code>, when <code>isVisible</code> is <code>false</code> and <code>showSubtitle</code> is <code>true</code>.</p>&#13;
<div data-type="example" id="v_else_if">&#13;
<h5><span class="label">Example 2-14. </span>Condition chaining with <code>v-if</code>, <code>v-else-if</code>, and <code>v-else</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div v-if="isVisible"&gt;I'm the visible text&lt;/div&gt;</code>&#13;
<code class="sb">  &lt;div v-else-if="showSubtitle"&gt;I'm the subtitle text&lt;/div&gt;</code>&#13;
<code class="sb">  &lt;div v-else&gt;I'm the replacement text&lt;/div&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">isVisible</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
   <code class="nx">showSubtitle</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
<div data-type="warning" epub:type="warning"><h1>Order of v-else-if</h1>&#13;
<p>If we use <code>v-else-if</code>, we <em>must</em> present it on elements appearing after the element with assigned <code>v-if</code> attribute.</p>&#13;
</div>&#13;
&#13;
<p>While using <code>v-if</code> means to render an element conditionally, there are situations where it won’t be efficient to mount/unmount an element from the DOM so &#13;
<span class="keep-together">frequently</span>.</p>&#13;
&#13;
<p>In such cases, it’s better to use <code>v-show</code><a data-primary="" data-startref="ix-welcome-VueBasics22" data-type="indexterm" id="id675"/><a data-primary="" data-startref="ix-welcome-VueBasics22a" data-type="indexterm" id="id676"/><a data-primary="" data-startref="ix-welcome-VueBasics22b" data-type="indexterm" id="id677"/><a data-primary="" data-startref="ix-welcome-VueBasics22c" data-type="indexterm" id="id678"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conditional Displaying Elements with v-show" data-type="sect1"><div class="sect1" id="id28">&#13;
<h1>Conditional Displaying Elements with v-show</h1>&#13;
&#13;
<p>Unlike <code>v-if</code>, <code>v-show</code> only toggles the visibility of the target element. Vue still renders the target element regardless of the status of the condition check. Once rendered, Vue controls the visibility using the CSS <code>display</code> rule to hide/show the element &#13;
<span class="keep-together">conditionally</span><a data-primary="CSS" data-secondary="display rule" data-type="indexterm" id="id679"/><a data-primary="display property and conditional display of elements with v-show" data-type="indexterm" id="id680"/><a data-primary="elements" data-secondary="conditional display of with v-show" data-type="indexterm" id="id681"/><a data-primary="rendering" data-secondary="conditional display of elements with v-show" data-type="indexterm" id="id682"/><a data-primary="style" data-secondary="conditional display of elements with v-show" data-type="indexterm" id="id683"/><a data-primary="v-show" data-secondary="conditional display of elements with" data-type="indexterm" id="id684"/>.</p>&#13;
&#13;
<p>Let’s take <a data-type="xref" href="#example_v_if">Example 2-12</a> and change the directive from <code>v-if</code> to <code>v-show</code>, as in <a data-type="xref" href="#event_propagation_2">Example 2-15</a>.</p>&#13;
<div data-type="example" id="event_propagation_2">&#13;
<h5><span class="label">Example 2-15. </span>Hide/show the element using <code>v-show</code></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div&gt;</code>&#13;
<code class="sb">   &lt;div v-show="isVisible"&gt;I'm the text in toggle&lt;/div&gt;</code>&#13;
<code class="sb">   &lt;div&gt;Visibility: {{isVisible}}&lt;/div&gt;</code>&#13;
<code class="sb">  &lt;/div&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">isVisible</code><code class="o">:</code> <code class="kc">false</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>The UI output is the same as when we use <code>v-if</code>. However, in the browser DOM (<em>you can debug in the Elements tab of the Developer Tools</em>), the text element exists in the DOM but is not visible to the user:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">div</code> <code class="na">style</code><code class="o">=</code><code class="s">"display: none;"</code><code class="p">&gt;</code>I'm the text in toggle<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>Visibility: false<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>The target element has an inline <code>style</code> with <code>display:none</code> applied. When toggling <code>isVisible</code> to <code>true</code>, Vue will remove this inline style.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>v-show</code> is more efficient if the toggling frequency is high at runtime, while <code>v-if</code> is an ultimate choice if the condition is not likely to change<a data-primary="v-if" data-secondary="vs. v-show" data-type="indexterm" id="id685"/><a data-primary="v-show" data-secondary="vs. v-if" data-type="indexterm" id="id686"/>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dynamically Displaying HTML Code with v-html" data-type="sect1"><div class="sect1" id="id29">&#13;
<h1>Dynamically Displaying HTML Code with v-html</h1>&#13;
&#13;
<p>We use <code>v-html</code> to inject plain HTML code into the DOM dynamically, in the form of a string, as in <a data-type="xref" href="#v_html_code">Example 2-16</a><a data-primary="rendering" data-secondary="dynamically displaying HTML code with v-html" data-type="indexterm" id="id687"/><a data-primary="strings" data-secondary="injecting plain HTML code for dynamic display with v-html" data-type="indexterm" id="id688"/><a data-primary="v-html" data-type="indexterm" id="id689"/>.</p>&#13;
<div data-type="example" id="v_html_code">&#13;
<h5><span class="label">Example 2-16. </span>Using v-html to render inner HTML content</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div v-html="innerContent" /&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">innerContent</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">    &lt;div&gt;Hello&lt;/div&gt;</code>&#13;
<code class="sb">   `</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>The Vue engine will parse the directive value as <em>static HTML code</em> and place it into the <code>innerHTML</code> property of the <code>div</code> element. The result should look like:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
 <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>Hello<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h1>Security Concern with v-html</h1>&#13;
<p>You should use <code>v-html</code> to render only trusted content or perform server-side rendering<a data-primary="script tag and security" data-type="indexterm" id="id690"/><a data-primary="security" data-secondary="script tag and" data-type="indexterm" id="id691"/><a data-primary="security" data-secondary="v-html and" data-type="indexterm" id="id692"/>.</p>&#13;
&#13;
<p>Also, a valid HTML string can contain a <code>script</code> tag and the browser will trigger the code within this <code>script</code> tag, leading to a potential security threat. Thus, using this directive on client-side rendering is not recommended.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Displaying Text Content with v-text" data-type="sect1"><div class="sect1" id="id30">&#13;
<h1>Displaying Text Content with v-text</h1>&#13;
&#13;
<p><code>v-text</code> is an alternative way of injecting data as the element’s content besides the double curly braces <code>{{}}</code>. However, unlike <code>{{}}</code>, Vue won’t update the text rendered if there are any changes<a data-primary="rendering" data-secondary="displaying text with v-text" data-type="indexterm" id="id693"/><a data-primary="text" data-secondary="displaying text with v-text" data-type="indexterm" id="id694"/><a data-primary="v-text" data-type="indexterm" id="id695"/>.</p>&#13;
&#13;
<p>This directive is beneficial when you need to predefine a placeholder text, then override the text only once after a component finishes loading<a data-primary="placeholder text" data-type="indexterm" id="id696"/><a data-primary="text" data-secondary="placeholder" data-type="indexterm" id="id697"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div v-text="text"&gt;Placeholder text&lt;/div&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">text</code><code class="o">:</code> <code class="sb">`Hello World`</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Here Vue will render the application displaying <em>placeholder text</em> and will eventually replace it with “Hello World” received from <code>text</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optimizing Renders with v-once and v-memo" data-type="sect1"><div class="sect1" id="id31">&#13;
<h1>Optimizing Renders with v-once and v-memo</h1>&#13;
&#13;
<p><code>v-once</code> helps render static content and preserves performance from the re-rendering static element. Vue renders elements with this directive presented <em>only once</em> and will not update it regardless of any re-rendering<a data-primary="rendering" data-secondary="once only with v-once" data-type="indexterm" id="id698"/><a data-primary="v-once" data-type="indexterm" id="id699"/><a data-primary="memoizing and rendering with v-memo" data-type="indexterm" id="ix-welcome-VueBasics23"/><a data-primary="performance" data-secondary="optimizing rendering with v-once and v-memo" data-type="indexterm" id="ix-welcome-VueBasics23a"/><a data-primary="rendering" data-secondary="optimizing with v-once and v-memo" data-type="indexterm" id="ix-welcome-VueBasics23b"/><a data-primary="v-memo" data-type="indexterm" id="ix-welcome-VueBasics23c"/>.</p>&#13;
&#13;
<p>To use <code>v-once</code>, place the directive as is on the element tag:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code> <code class="nx">createVue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="sb">`</code>&#13;
<code class="sb">  &lt;div&gt;</code>&#13;
<code class="sb">   &lt;input v-model="name" placeholder="Enter your name" &gt;</code>&#13;
<code class="sb">  &lt;/div&gt;</code>&#13;
<code class="sb">  &lt;div v-once&gt;{{name}}&lt;/div&gt;</code>&#13;
<code class="sb"> `</code><code class="p">,</code>&#13;
 <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="p">{</code>&#13;
   <code class="nx">name</code><code class="o">:</code> <code class="s1">'Maya'</code>&#13;
  <code class="p">}</code>&#13;
 <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre>&#13;
&#13;
<p>In the previous example, Vue renders <code>name</code> once for the <code>div</code> tag, and regardless of what value <code>name</code> receives from the user through <code>input</code> field and by <code>v-model</code>, the content of this <code>div</code> won’t be updated (<a data-type="xref" href="#figure_25">Figure 2-20</a>).</p>&#13;
&#13;
<figure><div class="figure" id="figure_25">&#13;
<img alt="Input field display new value as Maya Shavin, while the below text is still Maya." src="assets/lvue_0220.png"/>&#13;
<h6><span class="label">Figure 2-20. </span>Text remains the same though the input value has changed</h6>&#13;
</div></figure>&#13;
&#13;
<p>While <code>v-once</code> is excellent for defining a block of elements as static content, we use &#13;
<span class="keep-together"><code>v-memo</code></span> to memorize a block of parts (or components) within a template &#13;
<span class="keep-together">conditionally</span>.</p>&#13;
&#13;
<p><code>v-memo</code> accepts an array of JavaScript expressions as its value. We place it on the top element where we want to control its and its children’s re-rendering. Vue then validates these JavaScript conditional expressions and only triggers the re-rendering on the target block of elements when fulfilling those condition(s).</p>&#13;
&#13;
<p>Take rendering a gallery of image cards, for instance. Assume we have an array of images. Each image is an object with a <code>title</code>, <code>url</code>, and <code>id</code>. Users can select an image card by clicking on the card, and the selected card will have a blue border.</p>&#13;
&#13;
<p>First, let’s define the <code>images</code> data array and <code>selected</code> image card id in the component data object:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">data</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code>&#13;
    <code class="nx">selected</code><code class="o">:</code> <code class="kc">null</code><code class="p">,</code>&#13;
    <code class="nx">images</code><code class="o">:</code> <code class="p">[{</code>&#13;
      <code class="nx">id</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>&#13;
      <code class="nx">title</code><code class="o">:</code> <code class="s1">'Cute cat'</code><code class="p">,</code>&#13;
      <code class="nx">url</code><code class="o">:</code>&#13;
<code class="s1">'https://res.cloudinary.com/mayashavin/image/upload/w_100,h_100,c_thumb/TheCute%20Cat'</code><code class="p">,</code>&#13;
    <code class="p">},</code> <code class="p">{</code>&#13;
      <code class="nx">id</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>&#13;
      <code class="nx">title</code><code class="o">:</code> <code class="s1">'Cute cat no 2'</code><code class="p">,</code>&#13;
      <code class="nx">url</code><code class="o">:</code>&#13;
<code class="s1">'https://res.cloudinary.com/mayashavin/image/upload/w_100,h_100,c_thumb/cute_cat'</code><code class="p">,</code>&#13;
    <code class="p">},</code> <code class="p">{</code>&#13;
      <code class="nx">id</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>&#13;
      <code class="nx">title</code><code class="o">:</code> <code class="s1">'Cute cat no 3'</code><code class="p">,</code>&#13;
      <code class="nx">url</code><code class="o">:</code>&#13;
<code class="s1">'https://res.cloudinary.com/mayashavin/image/upload/w_100,h_100,c_thumb/cat_me'</code><code class="p">,</code>&#13;
    <code class="p">},</code> <code class="p">{</code>&#13;
      <code class="nx">id</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code>&#13;
      <code class="nx">title</code><code class="o">:</code> <code class="s1">'Just a cat'</code><code class="p">,</code>&#13;
      <code class="nx">url</code><code class="o">:</code>&#13;
<code class="s1">'https://res.cloudinary.com/mayashavin/image/upload/w_100,h_100,c_thumb/cat_1'</code><code class="p">,</code>&#13;
    <code class="p">}]</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Then we define the layout for the list rendering to the <code>template</code>, adding a conditional memorization <code>v-memo</code> for the list item to re-render only if the image item is no longer selected, or vice versa:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code><code> </code><code class="nx">App</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
 </code><code class="nx">template</code><code class="o">:</code><code> </code><code class="sb">`</code><code class="sb">&#13;
 &lt;ul&gt;&#13;
  &lt;li&#13;
   v-for="image in images"&#13;
   :key="image.id"&#13;
   :style=" selected === image.id ? { border: '1px solid blue' } : {}"&#13;
   @click="selected = image.id"&#13;
   v-memo="[selected === image.id]" </code><a class="co" href="#callout_how_vue_works__the_basics_CO2-1" id="co_how_vue_works__the_basics_CO2-1"><img alt="1" src="assets/1.png"/></a><code class="sb">&#13;
  &gt;&#13;
   &lt;img :src="image.url"&gt;&#13;
   &lt;div&gt;{{image.title}}&lt;/h2&gt;&#13;
  &lt;/li&gt;&#13;
 &lt;/ul&gt;&#13;
 </code><code class="sb">`</code><code class="p">,</code><code>&#13;
 </code><code class="nx">data</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="cm">/*..*/</code><code>&#13;
 </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_how_vue_works__the_basics_CO2-1" id="callout_how_vue_works__the_basics_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We set the re-rendering to only if the condition check <code>selected === image.id</code> results differently from the previous check.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The output will look like <a data-type="xref" href="#figure_26">Figure 2-21</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure_26">&#13;
<img alt="A screenshot displays a gallery of cat images, each image with a title text at the bottom." src="assets/lvue_0221.png"/>&#13;
<h6><span class="label">Figure 2-21. </span>Images gallery output</h6>&#13;
</div></figure>&#13;
&#13;
<p>Every time you select an image by clicking on the image card, Vue will only re-render two items: the previously selected item and the currently selected one. For optimizing large list rendering, this directive can be very powerful.</p>&#13;
<div data-type="warning" epub:type="warning"><h1><code>v-memo</code> Availability</h1>&#13;
<p><code>v-memo</code> is available only in Vue 3.2 and above.</p>&#13;
</div>&#13;
&#13;
<p>We have learned how to write a component using the <code>template</code> syntax and some common Vue directives, except <code>v-slot</code>. We will resume discussing the power of &#13;
<span class="keep-together"><code>v-slot</code></span> in <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a>.</p>&#13;
&#13;
<p>Next, we will learn how to register a component globally, making it available for use in other components of the same application without explicitly importing them<a data-primary="" data-startref="ix-welcome-VueBasics15" data-type="indexterm" id="id700"/><a data-primary="" data-startref="ix-welcome-VueBasics15a" data-type="indexterm" id="id701"/><a data-primary="" data-startref="ix-welcome-VueBasics23" data-type="indexterm" id="id702"/><a data-primary="" data-startref="ix-welcome-VueBasics23a" data-type="indexterm" id="id703"/><a data-primary="" data-startref="ix-welcome-VueBasics23b" data-type="indexterm" id="id704"/><a data-primary="" data-startref="ix-welcome-VueBasics23c" data-type="indexterm" id="id705"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Registering a Component Globally" data-type="sect1"><div class="sect1" id="id32">&#13;
<h1>Registering a Component Globally</h1>&#13;
&#13;
<p>Using the <code>components</code> property of Options API to register a component only enables its availability explicitly within the current component. Any of the present component’s nested elements won’t have access to use the registered one<a data-primary="components" data-secondary="registering components globally" data-type="indexterm" id="id706"/><a data-primary="component()" data-type="indexterm" id="id707"/>.</p>&#13;
&#13;
<p>Vue exposes the instance method <code>Vue.component()</code>, which receives two input parameters as arguments:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A string stands for the component’s registered name (alias).</p>&#13;
</li>&#13;
<li>&#13;
<p>A component instance, either an SFC imported as a module or an object containing the component’s configurations, following Options API<a data-primary="Options API" data-secondary="registering components globally" data-type="indexterm" id="id708"/>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To register a component globally, we trigger <code>component()</code> on the created <code>app</code> instance, as seen in <a data-type="xref" href="#global_component">Example 2-17</a>.</p>&#13;
<div data-type="example" id="global_component">&#13;
<h5><span class="label">Example 2-17. </span>Register <code>MyComponent</code> as global component and use it in the <code>App</code> template</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/* main.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
&#13;
<code class="c1">//1. Create the app instance</code>&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">({</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="s1">'&lt;MyComponent /&gt;'</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">//2. Define the component</code>&#13;
<code class="kr">const</code> <code class="nx">MyComponent</code> <code class="o">=</code> <code class="p">{</code>&#13;
 <code class="nx">template</code><code class="o">:</code> <code class="s1">'This is my global component'</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">//3. Register a component globally</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">component</code><code class="p">(</code><code class="s1">'MyComponent'</code><code class="p">,</code> <code class="nx">MyComponent</code><code class="p">)</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">mount</code><code class="p">(</code><code class="s1">'#app'</code><code class="p">)</code></pre></div>&#13;
&#13;
<p>If you have a <code>MyComponent</code> as an SFC file (see <a data-type="xref" href="ch03.html#unique_chapter_id_03">Chapter 3</a>), you can rewrite <a data-type="xref" href="#global_component">Example 2-17</a> to the &#13;
<span class="keep-together">following</span>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="cm">/* main.ts */</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">createApp</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'vue'</code>&#13;
<code class="kr">import</code> <code class="nx">App</code> <code class="nx">from</code> <code class="s1">'./App.vue'</code>&#13;
<code class="kr">import</code> <code class="nx">MyComponent</code> <code class="nx">from</code> <code class="s1">'./components/MyComponent.vue'</code>&#13;
&#13;
<code class="c1">//1. Create the app instance</code>&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">createApp</code><code class="p">(</code><code class="nx">App</code><code class="p">);</code>&#13;
&#13;
<code class="c1">//2. Register a component globally</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">component</code><code class="p">(</code><code class="s1">'MyComponent'</code><code class="p">,</code> <code class="nx">MyComponent</code><code class="p">);</code></pre>&#13;
&#13;
<p>And <code>MyComponent</code> will always be available for reuse in any component nested within the <code>app</code> instance.</p>&#13;
&#13;
<p>Importing the same component again in every component file can be repetitive and inconvenient. In reality, sometimes you need to reuse a component multiple times across an application. In this scenario, registering components as global components is an excellent practice.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id355">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>This chapter explored Virtual DOM and how Vue uses it to achieve its performance goal. We learned how to control the component rendering with JSX and functional components, handle built-in Vue directives, and use them to process the component’s local data for displaying on the UI template reactively. We also learned about the reactivity fundamentals and how to create and register the Vue component using Options API with the template syntax. These are the basics for going further into the Vue component mechanism in the next chapter.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="id564"><sup><a href="ch02.html#id564-marker">1</a></sup> Visit the <a href="https://oreil.ly/SRqbn">JavaScript Proxy documentation</a>.</p><p data-type="footnote" id="id574"><sup><a href="ch02.html#id574-marker">2</a></sup> 1 second = 1000 milliseconds</p></div></div></section></body></html>