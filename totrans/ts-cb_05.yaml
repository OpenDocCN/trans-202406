- en: Chapter 4\. Generics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, our main goal was to take the inherent flexibility of JavaScript
    and find a way to formalize it through the type system. We added static types
    for a dynamically typed language, to communicate intent, get tooling, and catch
    bugs before they happen.
  prefs: []
  type: TYPE_NORMAL
- en: Some parts in JavaScript don’t really care about static types, though. For example,
    an `isKeyAvailableInObject` function should only check if a key is available in
    an object; it doesn’t need to know about the concrete types. To properly formalize
    a function like this we can use TypeScript’s structural type system and describe
    either a very wide type for the price of information or a very strict type for
    the price of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: But we don’t want to pay any price. We want both flexibility and information.
    Generics in TypeScript are just the silver bullet we need. We can describe complex
    relationships and formalize structure for data that has not been defined yet.
  prefs: []
  type: TYPE_NORMAL
- en: Generics, along with its gang of mapped types, type maps, type modifiers, and
    helper types, open the door to metatyping, where we can create new types based
    on old ones and keep relationships between types intact while the newly generated
    types challenge our original code for possible bugs.
  prefs: []
  type: TYPE_NORMAL
- en: This is the entrance to advanced TypeScript concepts. But fear not, *there shan’t
    be dragons*, unless we define them.
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Generalizing Function Signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have two functions that work the same, but on different and largely incompatible
    types.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generalize their behavior using generics.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You are writing an application that stores several language files (for example,
    subtitles) in an object. The keys are the language codes, and the values are URLs.
    You load language files by selecting them via a language code, which comes from
    some API or user interface as `string`. To make sure the language code is correct
    and valid, you add an `isLanguageAvailable` function that does an `in` check and
    sets the correct type using a type predicate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Same application, different scenario, entirely different file. You load media
    data into an HTML element: either audio, video, or a combination with certain
    animations in a `canvas` element. All elements exist in the application already,
    but you need to select the right one based on input from an API. Again, the selection
    comes as `string`, and you write an `isElementAllowed` function to ensure that
    the input is actually a valid key of your `AllowedElements` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You don’t need to look too closely to see that both scenarios are very similar.
    The type guard functions especially catch our eye. If we strip away all the type
    information and align the names, they are identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The two of them exist because of the type information we get. Not because of
    the input parameters, but because of the type predicates. In both scenarios we
    can tell more about the input parameters by asserting a specific `keyof` type.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that both input types for the collection are entirely different
    and have no overlap. Except for the empty object, for which we don’t get that
    much valuable information if we create a `keyof` type. `keyof {}` is actually
    `never`.
  prefs: []
  type: TYPE_NORMAL
- en: But there is some type information here that we can generalize. We know the
    first input parameter is an object. And the second one is a property key. If this
    check evaluates to `true`, we know that the first parameter is a key of the second
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To generalize this function, we can add a *generic type parameter* to `isAvailable`
    called `Obj`, put in angle brackets. This is a placeholder for an actual type
    that will be substituted once `isAvailable` is used. We can use this *generic
    type parameter* like we would use `AllowedElements` or `Languages` and can add
    a type predicate. Since `Obj` can be substituted for *every* type, `key` needs
    to include all possible property keys—`string`, `symbol`, and `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And there you have it: one function that works in both scenarios, no matter
    which types we substitute `Obj` for. Just like JavaScript works! We still get
    the same functionality, and we get the right type information. Index access becomes
    safe, without sacrificing flexibility.'
  prefs: []
  type: TYPE_NORMAL
- en: The best part? We can use `isAvailable` just like we would use an untyped JavaScript
    equivalent. This is because TypeScript infers types for generic type parameters
    through usage. And this comes with some neat side effects. You can read more about
    that in [Recipe 4.3](#ch04_no_any).
  prefs: []
  type: TYPE_NORMAL
- en: 4.2 Creating Related Function Arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You write functions where the second parameter is dependent on the first one.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotate each parameter with a generic type and create a relationship between
    them through generic constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similar to [Recipe 4.1](#ch04_generalizing), our application stores a list
    of subtitles in an object of type `Languages`. `Languages` has a set of keys describing
    the language code and a URL as the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are several lists like this in our application, and we can abstract them
    in a type called `URLList`, whose index signatures allow for any `string` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`URLList` is a supertype of `Languages`: every value of type `Languages` is
    a `URLList`, but not every `URLList` is `Languages`. Still, we can use `URLList`
    to write a function called `fetchFile`, where we load a specific entry from this
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that type `string` for `key` allows for way too many entries.
    For example, no Italian subtitles are defined, but `fetchFile` doesn’t keep us
    from loading `"it"` as a language code anyway. When we load items from a specific
    `URLList`, it would be great to also know which keys we can access.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can solve this by substituting the broader type for a generic and setting
    a *generic constraint* to make sure we pass a subtype of `URLList`. This way,
    the function signature behaves very similarly to before, but we can work with
    the subtituted types much better. We define a *generic type parameter* `List`
    which is a subtype of `URLList` and set `key` to `keyof List`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The moment we call `fetchFile`, `List` will be substituted for an actual type,
    and we know that `"it"` is not part of the keys of `Languages`. TypeScript will
    show us when we made a typo or selected elements that aren’t part of our data
    types.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also works if we are loading many keys. The same constraints, the same
    effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We store the results in a tuple with the language key as first element and the
    data as the second element. However, when we get the result, it’s an array of
    `Promise`s that resolve to an `any[]`. This is understandable, as `fetch` does
    not tell us anything about the data loaded, and with `data` being of type `any`
    and thus having the broadest type, it just swallows `el`, which is `keyof List`.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we know more at this stage. We know, for example, that `[el, data]` is
    not an array but a tuple. There is a subtle but important difference, as shown
    in [Recipe 2.4](ch02.html#ch02_item_tuple_types). If we annotate the result with
    a tuple type, we get more information from our return values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`fetchFiles` now returns an array of `Promise`s of `[keyof List, any]`. So
    the moment we substitute `List` for `Languages`, we know that the only possible
    keys can be language codes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there’s still one caveat. As the preceding code sample shows, the
    only languages available in `de_and_fr` are German and French, but the compiler
    doesn’t warn us that we check for English later on. The compiler should be able
    to do that, because this condition will always return false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that we are dealing again with a type that is way too broad.
    Yes, `keyof List` is already a lot narrower than `string`, but we can substitute
    all keys for a smaller set as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to repeat the same process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new generic type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the broader type as a constraint of the newly created generic type parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the parameter in the function signature to be substituted for an actual
    type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'And just like that, we can also substitute `keyof List` with a subtype: `"de"
    | "fr"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s nice about this is that we can set relationships between generic type
    parameters. The second type parameter can be constrained by something from the
    first generic type parameter. This allows us to narrow very specifically, until
    we substitute with real values. The effect? We know about possible values of our
    types anywhere in our code. So we won’t check for English language if we can already
    say that we never requested to load English:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: One check that we didn’t get rid of is to see which language is at position
    0.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that we didn’t take into account is *generic instantiation*. We let
    type parameters be substituted for real values through usage, just like type inference.
    But we also could substitute them explicitly through annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here the types tell us there might be Japanese subtitles as well, even though
    we can see from usage that we load only German ones. Let this be a reminder, and
    get more insights in [Recipe 4.4](#ch04_understanding_generic_instantiation).
  prefs: []
  type: TYPE_NORMAL
- en: 4.3 Getting Rid of any and unknown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generic type parameters, `any`, and `unknown` all seem to describe very wide
    sets of values. When should you use what?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use generic type parameters when you get to the actual type eventually; refer
    to [Recipe 2.2](ch02.html#ch02_item_any) on the decision between `any` and `unknown`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we are using generics, they might seem like a substitute for `any` and
    `unknown`. Take an `identity` function—its only job is to return the value passed
    as input parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes values of every type, and the return type of it can also be anything.
    We can write the same function using `unknown` if we want to safely access properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can even mix and match `any` and `unknown`, but the result is always the
    same: Type information is lost. The type of the return value is what we define
    it to be.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s write the same function with generics instead of `any` or `unknown`.
    Its type annotations say that the generic type is also the return type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use this function to pass in any value and see which type TypeScript
    infers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Assigning to a binding with `const` instead of `let` gives slightly different
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: For primitive types, TypeScript substitutes the generic type parameter with
    the actual type. We can make great use of this in more advanced scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'With TypeScript’s generics, it’s also possible to *annotate* the generic type
    parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If this behavior reminds you of annotation and inference described in [Recipe
    3.4](ch03.html#ch03_item_const_context), you are absolutely right. It’s very similar
    but with generic type parameters in functions.
  prefs: []
  type: TYPE_NORMAL
- en: When using generics without constraints, we can write functions that work with
    values of any type. Inside, they behave like `unknown`, which means we can do
    type guards to narrow the type. The biggest difference is that once we use the
    function, we substitute our generics with real types, not losing any information
    on typing at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows us to be a bit clearer with our types than just allowing everything.
    This `pairs` function takes two arguments and creates a tuple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With generic type parameters, we get a nice tuple type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the same generic type parameter, we can make sure we get tuples only
    where each element is of the same type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, should you use generics everywhere? Not necessarily. This chapter includes
    many solutions that rely on getting the right type information at the right time.
    When you are happy with a wider set of values and can rely on subtypes being compatible,
    you don’t need to use generics at all. If you have `any` and `unknown` in your
    code, think whether you need the actual type at some point. Adding a generic type
    parameter instead might help.
  prefs: []
  type: TYPE_NORMAL
- en: 4.4 Understanding Generic Instantiation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You understand how generics are substituted for real types, but sometimes errors
    like “`Foo` is assignable to the constraint of type `Bar`, but could be instantiated
    with a different subtype of constraint `Baz`” confuse you.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember that values of a generic type can be—explicitly and implicitly—substituted
    with a variety of subtypes. Write subtype-friendly code.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You create a filter logic for your application. You have different filter rules
    that you can combine using `"and" | "or"` combinators. You can also chain regular
    filter rules with the outcome of *combinatorial filters*. You create your types
    based on this behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you want to write a `reset` function that, based on an already provided
    filter, resets all rules. You use type guards to distinguish between `CombinatorialFilter`
    and `ChainedFilter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior is what you are after, but the return type of `reset` is too wide.
    When we pass a `CombinatorialFilter`, we should be sure that the reset filter
    is also a `Co⁠mb⁠in⁠ato⁠rial​Fil⁠ter`. Here it’s the union type, just like our
    function signature indicates. But you want to make sure that if you pass a filter
    of a certain type, you also get the same return type. So you replace the broad
    union type with a generic type parameter that is constrained to `Filter`. The
    return type works as intended, but the implementation of your function throws
    errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: While you want to differentiate between two parts of a union, TypeScript thinks
    more broadly. It knows that you might pass in an object that is *structurally
    compatible* with `Filter`, but it has more properties and is therefore a subtype.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means you can call `reset` with `F` instantiated to a subtype, and your
    program would happily override all excess properties. This is wrong, and TypeScript
    tells you that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Overcome this by writing subtype-friendly code. Clone the input object (still
    type `F`), set the properties that need to be changed accordingly, and return
    something that is still of type `F`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Generic types can be one of many in a union, but they can be much, much more.
    TypeScript’s structural type system allows you to work on a variety of subtypes,
    and your code needs to reflect that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a different scenario but with a similar outcome. You want to create
    a tree data structure and write a recursive type that stores all tree items. This
    type can be subtyped, so you write a `createRootItem` function with a generic
    type parameter since you want to instantiate it with the correct subtype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a similar error as before, since we can’t possibly say that the return
    value will be compatible with all the subtypes. To solve this problem, get rid
    of the generic! We know how the return type will look—it’s a `TreeItem`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The simplest solutions are often the better ones. But now you want to extend
    your software by being able to attach children of type or subtype `TreeItem` to
    a newly created root. We don’t add any generics yet and are somewhat dissatisfied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '`root` is of type `TreeItem`, but we lose any information about the subtyped
    children. Even if we add a generic type parameter just for the children, constrained
    to `Tr⁠ee​It⁠em`, we don’t retain this information on the go:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When we start adding a generic type as a return type, we run into the same problems
    as before. To solve this issue, we need to split the root item type from the children
    item type, by opening up `TreeItem` to be a generic, where we can set `Children`
    to be a subtype of `TreeItem`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we want to avoid any circular references, we need to set `Children` to
    a default `BaseTreeItem`, so we can use `TreeItem` both as a constraint for `Children`
    and for `attachToRoot`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Again, we write subtype friendly and treat our input parameters as their own,
    instead of making assumptions.
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Generating New Object Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a type in your application that is related to your model. Every time
    the model changes, you need to change your types as well.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use generic mapped types to create new object types based on the original type.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s go back to the toy shop from [Recipe 3.1](ch03.html#ch03_item_modelling_data).
    Thanks to union types, intersection types, and discriminated union types, we were
    able to model our data quite nicely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Somewhere in our code, we need to group all toys from our model in a data structure
    that can be described by a type called `GroupedToys`. `GroupedToys` has a property
    for each category (or `"kind"`) and a `Toy` array as value. A `groupToys` function
    takes an unsorted list of toys and groups them by kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are already some niceties in this code. First, we use an explicit type
    annotation when declaring `groups`. This ensures we are not forgetting any category.
    Also, since the keys of `GroupedToys` are the same as the union of `"kind"` types
    in `Toy`, we can easily index access `groups` by `toy.kind`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Months and sprints pass, and we need to touch our model again. The toy shop
    is now selling original or maybe alternate vendors of interlocking toy bricks.
    We wire the new type `Bricks` up to our `Toy` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `groupToys` needs to deal with `Bricks`, too, we get a nice error because
    `GroupedToys` has no clue about a `"bricks"` kind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This is desired behavior in TypeScript: knowing when types don’t match anymore.
    This should draw our attention. Let’s give `GroupedToys` and `groupToys` an update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'There is one bothersome thing: the task of grouping toys is always the same.
    No matter how much our model changes, we will always select by kind and push into
    an array. We would need to maintain `groups` with every change, but if we change
    how we think about groups, we can optimize for change. First, we change the type
    `Gr⁠oup⁠ed​To⁠ys` to feature optional properties. Second, we initialize each group
    with an empty array if there hasn’t been any initialization yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We don’t need to maintain `groupToys` anymore. The only thing that needs maintenance
    is the type `GroupedToys`. If we look closely at `GroupedToys`, we see that there
    is an implicit relation to `Toy`. Each property key is part of `Toy["kind"]`.
    Let’s make this relation *explicit*. With a *mapped type*, we create a new object
    type based on each type in `Toy["kind"]`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Toy["kind"]` is a union of string literals: `"boardgame" | "puzzle" | "doll"
    | "bricks"`. Since we have a very reduced set of strings, each element of this
    union will be used as its own property key. Let that sink in for a moment: we
    can use a *type* to be a *property key* of a newly generated type. Each property
    has an optional type modifier and points to a `Toy[]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! Every time we change `Toy`, we immediately change `Toy[]`. Our code
    needs no change at all; we can still group by kind as we did before.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a pattern we have the potential to generalize. Let’s create a `Group`
    type that takes a collection and groups it by a specific selector. We want to
    create a generic type with two type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Collection` can be anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Selector`, a key of `Collection`, so it can create the respective properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our first attempt would be to take what we had in `GroupedToys` and replace
    the concrete types with type parameters. This creates what we need but also causes
    an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript warns us that `Collection[string] | Collection[number] | Collection[symbol]`
    could result in anything, not just things that can be used as a key. That’s true,
    and we need to prepare for that. We have two options.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, use a type constraint on `Collection` that points to `Record<string,
    any>`. `Record` is a utility type that generates a new object where the first
    parameter gives you all keys and the second parameter gives you the types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This elevates `Collection` to a wildcard object, effectively disabling the
    type-check from `Groups`. This is OK because if something would be an unusable
    type for a property key, TypeScript will throw it away anyway. So the final `Group`
    has two constrained type parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The second option is to do a check for each key to see if it is a valid string
    key. We can use a *conditional type* to see if `Collection[Selector]` is in fact
    a valid type for a key. Otherwise, we would remove this type by choosing `never`.
    Conditional types are their own beast, and we tackle this in [Recipe 5.4](ch05.html#ch05_removing_object_properties)
    extensively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we did remove the optional type modifier. We do this because making
    keys optional is not the task of grouping. We have another type for that: `Partial<T>`,
    another mapped type that makes every property in an object type optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'No matter which `Group` helper you create, you can now create a `GroupedToys`
    object by telling TypeScript that you want a `Partial` (changing everything to
    optional properties) of a `Group` of `Toys` by `"kind"`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Now that reads nicely.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Modifying Objects with Assertion Signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After a certain function execution in your code, you know the type of a value
    has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use assertion signatures to change types independently of `if` and `switch`
    statements.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JavaScript is a very flexible language. Its dynamic typing features allow you
    to change objects at runtime, adding new properties on the fly. And developers
    use this. There are situations where you, for example, run over a collection of
    elements and need to assert certain properties. You then store a `checked` property
    and set it to `true`, just so you know that you passed a certain mark:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You want to mirror this behavior in the type system; otherwise, you would need
    to constantly do extra checks if certain properties are in an object, even though
    you can be sure that they exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to assert that certain properties exist are, well, type assertions.
    We say that at a certain point in time, this property has a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Good, but you would need to do this type assertion over and over again, as
    they don’t change the original type of `person`. Another way to assert that certain
    properties are available is to create type predicates, like those shown in [Recipe
    3.5](ch03.html#ch03_item_type_predicates):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'This situation is a bit different, though, which makes the `check` function
    feel clumsy: you need to do an extra condition and return `true` in the predicate
    function. This doesn’t feel right.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, TypeScript has another technique we can leverage in situations
    like this: assertion signatures. Assertion signatures can change the type of a
    value in control flow, without the need for conditionals. They have been modeled
    for the Node.js `assert` function, which takes a condition, and it throws an error
    if it isn’t true. This means that, after calling `assert`, you might have more
    information than before. For example, if you call `assert` and check if a value
    has a type of `string`, you know that after this `assert` function the value should
    be `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the function short-circuits if the condition is false. It throws
    an error, the `never` case. If this function passes, you can really assert the
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'While assertion signatures have been modeled for the Node.js assert function,
    you can assert any type you like. For example, you can have a function that takes
    any value for an addition, but you assert that the values need to be `number`
    to continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'All the examples you find on assertion signatures are based after assertions
    and short-circuit with errors. But we can take the same technique to tell TypeScript
    that more properties are available. We write a function that is very similar to
    `check` in the predicate function before, but this time we don’t need to return
    `true`. We set the property, and since objects are passed by value in JavaScript,
    we can assert that after calling this function whatever we pass has a property
    `checked`, which is `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: And with that, we can modify a value’s type on the fly. It’s a little-known
    technique that can help you a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 4.7 Mapping Types with Type Maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You write a factory function that creates an object of a specific subtype based
    on a string identifier, and there are a lot of possible subtypes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Store all subtypes in a type map, widen with index access, and use mapped types
    like `Partial<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Factory functions are great if you want to create variants of complex objects
    based on some basic information. One scenario that you might know from browser
    JavaScript is the creation of elements. The `document.createElement` function
    accepts an element’s tag name, and you get an object where you can modify all
    necessary properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'You want to spice up this creation with a neat factory function you call `cr⁠ea⁠te​El⁠eme⁠nt`.
    Not only does it take the element’s tag name, but it also makes a list of properties
    so you don’t need to set each property individually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'You want to create good types for this, so you need to take care of two things:'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you create only valid HTML elements.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide a type that accepts a subset of an HTML element’s properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take care of the valid HTML elements first. There are around 140 possible
    HTML elements, which is a lot. Each of those elements has a tag name, which can
    be represented as a string, and a respective prototype object in the DOM. Using
    the *dom* lib in your *tsconfig.json*, TypeScript has information on those prototype
    objects in the form of types. And you can figure out all 140 element names.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good way to provide a mapping between element tag names and prototype objects
    is to use a *type map*. A type map is a technique where you take a type alias
    or interface and let keys point to the respective type variants. You can then
    get the correct type variant using index access of a string literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like accessing a JavaScript object’s properties using index access,
    but remember that we’re still working on a type level. This means index access
    can be broad:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use this map to type the `createElement` function. We use a generic type
    parameter constrained to all keys of `AllElements`, which allows us to pass only
    valid HTML elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Use generics here to pin a string literal to a literal type, which we can use
    to index the right HTML element variant from the type map. Also note that using
    `do⁠cum⁠ent.​cre⁠ate⁠Ele⁠me⁠nt` requires two type assertions. One makes the set
    wider (`T` to `string`), and one makes the set narrower (`HTMLElement` to `AllElements[T]`).
    Both assertions indicate that we have to deal with an API outside our control,
    as established in [Recipe 3.9](ch03.html#ch03_item_assertions). We will deal with
    the assertions later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to provide the option to pass extra properties for said HTML elements,
    to set an `href` to an `HTMLAnchorElement`, and so forth. All properties are already
    in the respective `HTMLElement` variants, but they’re required, not optional.
    We can make all properties optional with the built-in type `Partial<T>`. It’s
    a mapped type that takes all properties of a certain type and adds a type modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We extend our function with an optional argument `props` that is a `Partial`
    of the indexed element from `AllElements`. This way, we know that if we pass an
    `"a"`, we can only set properties that are available in `HTMLAnchorElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Fantastic! Now it’s up to you to figure out all 140 HTML elements. Or not.
    Somebody already did the work and put `HTMLElementTagNameMap` into *lib.dom.ts*.
    So let’s use this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is also the interface used by `document.createElement`, so there is no
    friction between your factory function and the built-in one. No extra assertions
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: There is only one caveat. You are restricted to the 140 elements provided by
    `HT⁠ML​Ele⁠men⁠tTa⁠gNa⁠me⁠Map`. What if you want to create SVG elements, or web
    components that can have fully customized element names? Your factory function
    suddenly is too constrained.
  prefs: []
  type: TYPE_NORMAL
- en: 'To allow for more—as `document.createElement` does—we would need to add all
    possible strings to the mix again. `HTMLElementTagNameMap` is an interface. So
    we can use *declaration merging* to extend the interface with an *indexed signature*,
    where we map all remaining strings to `HTMLUnknownElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have everything we want:'
  prefs: []
  type: TYPE_NORMAL
- en: A great factory function to create typed HTML elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The possibility to set element properties with just one configuration object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The flexibility to create more elements than defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The last is great, but what if you only want to allow for web components? Web
    components have a convention; they need to have a *dash* in their tag name. We
    can model this using a mapped type on a *string template literal type*. You will
    learn all about string template literal types in [Chapter 6](ch06.html#ch06).
  prefs: []
  type: TYPE_NORMAL
- en: For now, the only thing you need to know is that we create a set of strings
    where the pattern is *any string* followed by a *dash* followed by *any string*.
    This is enough to ensure we only pass correct element names.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mapped types* work only with type aliases, not interface declarations, so
    we need to define an `AllElements` type again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Fantastic. With the `AllElements` type we also get type assertions back, which
    we don’t like that much. In that case, instead of asserting, we can also use a
    function overload, defining two declarations: one for our users, and one for us
    to implement the function. You can learn more about this function overload technique
    in Recipes [2.6](ch02.html#ch02_item_function_overloads) and [12.7](ch12.html#ch12_overloads_vs_conditionals):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We are all set. We defined a *type map* with *mapped types* and *index signatures*,
    using *generic type parameters* to be very explicit about our intentions. A great
    combination of multiple tools in our TypeScript tool belt.
  prefs: []
  type: TYPE_NORMAL
- en: 4.8 Using ThisType to Define this in Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your app requires complex configuration objects with methods, where `this` has
    a different context depending on usage.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the built-in generic `ThisType<T>` to define the correct `this`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Frameworks like [VueJS](https://vuejs.org) rely a lot on factory functions,
    where you pass a comprehensive configuration object to define initial data, computed
    properties, and methods for each instance. You want to create a similar behavior
    for components of your app. The idea is to provide a configuration object with
    three properties:'
  prefs: []
  type: TYPE_NORMAL
- en: A `data` function
  prefs: []
  type: TYPE_NORMAL
- en: The return value is the initial data for the instance. You should not have access
    to any other properties from the configuration object in this function.
  prefs: []
  type: TYPE_NORMAL
- en: A `computed` property
  prefs: []
  type: TYPE_NORMAL
- en: This is for computed properties, which are based on the initial data. Computed
    properties are declared using functions. They can access initial data just like
    normal properties.
  prefs: []
  type: TYPE_NORMAL
- en: A `methods` property
  prefs: []
  type: TYPE_NORMAL
- en: 'Methods can be called and can access computed properties as well as the initial
    data. When methods access computed properties, they access it like they would
    access normal properties: no need to call the function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Looking at the configuration object in use, there are three different ways
    to interpret `this`. In `data`, `this` doesn’t have any properties at all. In
    `computed`, each function can access the return value of `data` via `this` just
    like it would be part of their object. In `methods`, each method can access computed
    properties and `data` via `this` in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is special but not uncommon. And with a behavior like that, we
    definitely want to rely on good types.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this lesson we will focus only on the types, not on the actual implementation,
    as that would exceed this chapter’s scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create types for each property. We define a type `Options`, which we
    are going to refine step by step. First is the `data` function. `data` can be
    user defined, so we want to specify `data` using a generic type parameter. The
    data we are looking for is specified by the return type of the `data` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: So once we specify an actual return value in the `data` function, the `Data`
    placeholder gets substituted with the real object’s type. Note that we also define
    `this` to point to the empty object, which means that we don’t get access to any
    other property from the configuration object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define `computed`. `computed` is an object of functions. We add another
    generic type parameter called `Computed` and let the value of `Computed` be typed
    through usage. Here, `this` changes to all the properties of `Data`. Since we
    can’t set `this` like we do in the `data` function, we can use the built-in helper
    type `ThisType` and set it to the generic type parameter `Data`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to access, for example, `this.firstName`, like in the previous
    example. Last but not least, we want to specify `methods`. `methods` is again
    special, as you are getting access not only to `Data` via `this` but also to all
    methods and to all computed properties as properties.
  prefs: []
  type: TYPE_NORMAL
- en: '`Computed` holds all computed properties as functions. We would need their
    value, though—more specifically, their return value. If we access `fullName` via
    property access, we expect it to be a `string`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For that, we create a helper type called `MapFnToProp`. It takes a type that
    is an object of functions and maps it to the return values’ types. The built-in
    `ReturnType` helper type is perfect for this scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use `MapFnToProp` to set `ThisType` for a newly added generic type parameter
    called `Methods`. We also add `Data` and `Methods` to the mix. To pass the `Computed`
    generic type parameter to `MapFnToProp`, it needs to be constrained to `FnObj`,
    the same constraint of the first parameter `FunctionObj` in `MapFnToProp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s the type! We take all generic type properties and add them to the
    `create` factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Through usage, all generic type parameters will be substituted. And the way
    `Options` is typed, we get all the autocomplete necessary to ensure we don’t run
    into troubles, as seen in [Figure 4-1](#img-autocomplete-thistype).
  prefs: []
  type: TYPE_NORMAL
- en: This example shows wonderfully how TypeScript can be used to type elaborate
    APIs where a lot of object manipulation is happening underneath.^([1](ch04.html#id652))
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0401](assets/tscb_0401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. The methods configuration in the factory function having all the
    access to the correct properties
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 4.9 Adding Const Context to Generic Type Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you pass complex, literal values to a function, TypeScript widens the type
    to something more general. While this is desired behavior in a lot of cases, in
    some you want to work on the literal types rather than the widened type.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Add a `const` modifier in front of your generic type parameter to keep the passed
    values in *const context*.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Single-page application (SPA) frameworks tend to reimplement a lot of browser
    functionality in JavaScript. For example, features like the [History API](https://oreil.ly/KMBgj)
    made it possible to override the regular navigation behavior, which SPA frameworks
    use to switch between pages without a real page reload, by swapping the content
    of the page and changing the URL in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine working on a minimalistic SPA framework that uses a so-called router
    to navigate between pages. Pages are defined as *components*, and a `ComponentConstructor`
    interface knows how to instantiate and render new elements on your website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'The *router* should take a list of components and associated paths, stored
    as `string`. When creating a router through the `router` function, it should return
    an object that lets you `navigate` the desired path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: How the actual navigation is implemented is of no concern to us right now; instead,
    we want to focus on the typings of the function interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The router works as intended; it takes an array of `Route` objects and returns
    an object with a `navigate` function, which allows us to trigger the navigation
    from one URL to the other and renders the new component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: What you immediately see is that the types are way too broad. If we allow navigating
    to every `string` available, nothing keeps us from using bogus routes that lead
    nowhere. We would need to implement some sort of error handling for information
    that is already ready and available. So why not use it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first idea would be to replace the concrete type with a generic type parameter.
    The way TypeScript deals with generic substitution is that if we have a literal
    type, TypeScript will subtype accordingly. Introducing `T` for `Route` and using
    `T["path"]` instead of `string` comes close to what we want to achieve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'In theory, this should work. If we remind ourselves what TypeScript does with
    literal, primitives types in that case, we would expect the value to be narrowed
    to the literal type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: You can read more on that in [Recipe 4.3](#ch04_no_any). One important detail
    is that `path` in the previous example is in a *const context*, because the returned
    value is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only problem is that we are working with objects and arrays, and TypeScript
    tends to widen types in objects and arrays to something more general to allow
    for the mutability of values. If we look at a similar example, but with a nested
    object, we see that TypeScript takes the broader type instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: For objects, the *const context* for `paths` is only for the binding of the
    variable, not for its contents. This eventually leads to losing some of the information
    we need to correctly type `navigate`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A way to work around this limitation is to manually apply *const context*,
    which needs us to redefine the input parameter to be `readonly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: This works but also requires that we not forget a very important detail when
    coding. And actively remembering workarounds is always a recipe for disaster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, TypeScript allows us to request *const context* from generic type
    parameters. Instead of applying it to the value, we substitute the generic type
    parameter for a concrete value *but* in *const context* by adding the `const`
    modifier to the generic type parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use our router just as we are accustomed to and even get autocomplete
    for possible paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better, we get proper errors when we pass in something bogus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The beautiful thing: it’s all hidden in the function’s API. What we expect
    becomes clearer, the interface tells us the constraints, and we don’t have to
    do anything extra when using `router` to ensure type safety.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch04.html#id652-marker)) Special thanks to the creators of [Type Challenges](https://oreil.ly/pHc9j)
    for this beautiful example.
  prefs: []
  type: TYPE_NORMAL
