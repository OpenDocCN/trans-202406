<html><head></head><body><section data-pdf-bookmark="Chapter 4. Concurrency in Android" data-type="chapter" epub:type="chapter"><div class="chapter" id="memory_and_threading_fundamentals_id">&#13;
<h1><span class="label">Chapter 4. </span>Concurrency in Android</h1>&#13;
&#13;
&#13;
<p><a data-primary="concurrent programming" data-type="indexterm" id="ix_ch04-asciidoc0"/>This chapter does not focus specifically on Kotlin. Instead,&#13;
it will introduce some of the issues that surround&#13;
<em>concurrent programming</em> and that the rest of the book&#13;
addresses. It will also introduce a few tools, already&#13;
available to Android developers, for managing concurrent&#13;
tasks.</p>&#13;
&#13;
<p>Concurrent programming has a reputation as kind of a dark&#13;
art: something that is done by self-proclaimed wizards and that&#13;
novices touch at their peril. Certainly, writing correct&#13;
concurrent programs can be quite challenging. This is&#13;
particularly true because errors in concurrent programs&#13;
don’t always show up right away. It is nearly impossible to&#13;
test for concurrency bugs and they can be extremely difficult&#13;
to reproduce, even when they are known to exist.</p>&#13;
&#13;
<p>A developer concerned about the hazards of concurrent&#13;
programming would do well to remember these three things:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Nearly everything you do, every day, <em>except</em>&#13;
programming, is concurrent. You get along quite nicely in a&#13;
concurrent environment. It is programming, where things&#13;
happen in order, that is odd.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you are trying to understand the issues that&#13;
concurrent programming presents, you are on the right path.&#13;
Even an incomplete understanding of concurrency is better&#13;
than copying sample code and crossing your fingers.</p>&#13;
</li>&#13;
<li>&#13;
<p>Concurrent programming is just how Android works. Anything&#13;
other than the most trivial Android application will require&#13;
concurrent execution. Might as well get on with it and&#13;
figure out what it’s all about!</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Before getting into specifics, let’s define some terms.</p>&#13;
&#13;
<p>The first term is <em>process</em>. A process is&#13;
memory that an application can use, and one or more threads of&#13;
execution. The memory space belongs to the process—no other&#13;
processes can affect it.<sup><a data-type="noteref" href="ch04.html#idm46669754182608" id="idm46669754182608-marker">1</a></sup> An application usually runs&#13;
as a single process.</p>&#13;
&#13;
<p>That, of course, introduces the second term:<a data-primary="thread, defined" data-type="indexterm" id="idm46669754181280"/> <em>thread</em>. A thread is a sequence of instructions,&#13;
executed one at a time, in order.</p>&#13;
&#13;
<p>And this leads us to the term that, to some extent,&#13;
drives the rest of this book:<a data-primary="thread safety" data-secondary="defined" data-type="indexterm" id="idm46669754179616"/> <em>thread safe</em>. A set of&#13;
instructions is thread-safe if, when multiple threads&#13;
execute it, no possible ordering of the instructions&#13;
executed by the threads can produce a result that could not&#13;
be obtained if each of the threads executed the code&#13;
completely, in some order, one at a time. That’s a little&#13;
hard to parse, but it just says that the code produces the&#13;
same results whether the multiple threads execute it all at&#13;
the same time or, serially, one at a time.  It means that&#13;
running the program produces predictable results.</p>&#13;
&#13;
<p>So how does one make a program thread-safe? There are lots&#13;
and lots of ideas about this. We would like to propose one&#13;
that is clear, relatively easy to follow, and always&#13;
correct. Just follow one, fairly clear, fairly simple rule.&#13;
We’ll state the rule in a few pages. First, though, let’s discuss in more detail what thread safety means.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Thread Safety" data-type="sect1"><div class="sect1" id="idm46669754176672">&#13;
<h1>Thread Safety</h1>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="thread safety" data-type="indexterm" id="ix_ch04-asciidoc1"/><a data-primary="thread safety" data-type="indexterm" id="ix_ch04-asciidoc2"/>We’ve already said that thread-safe code cannot produce a result, when executed by multiple threads&#13;
at the same time, that could not have been produced by some&#13;
ordering of the threads executing one at a time.&#13;
That definition, though, is not very useful in practice:&#13;
no one is going to test all possible execution orders.</p>&#13;
&#13;
<p>Perhaps we can get a handle on the problem by looking at&#13;
some common ways that code can be <em>thread-unsafe</em>.</p>&#13;
&#13;
<p>Thread-safety failures can be divided into a few categories.&#13;
Two of the most important are <em>atomicity</em> and <em>visibility</em>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Atomicity" data-type="sect2"><div class="sect2" id="idm46669754170176">&#13;
<h2>Atomicity</h2>&#13;
&#13;
<p><a data-primary="atomicity" data-type="indexterm" id="idm46669754168768"/><a data-primary="concurrent programming" data-secondary="atomicity" data-type="indexterm" id="idm46669754168064"/><a data-primary="thread safety" data-secondary="atomicity" data-type="indexterm" id="idm46669754167120"/>Nearly all developers understand problems of atomicity.&#13;
This code is not thread-safe:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">unsafe</code><code class="p">()</code> <code class="p">{</code> <code class="n">globalVar</code><code class="p">++</code> <code class="p">}</code></pre>&#13;
&#13;
<p>Multiple threads&#13;
executing this code can interfere with each other. Each&#13;
thread executing this code might read the same value for&#13;
<code>globalVar</code>—say, 3. Each might increment that value to get&#13;
4, and then each might update <code>globalVar</code> to have the value&#13;
4. Even if 724 threads executed the code, <code>globalVar</code> might,&#13;
when all were through executing, have the value 4.</p>&#13;
&#13;
<p>There is no possible way that each of those 724 threads could&#13;
execute that code serially and have <code>globalVar</code> end up as 4.&#13;
Because the result of executing the code concurrently can be&#13;
different from any possible result generated by serial&#13;
execution, this code is not thread-safe, according to our&#13;
definition.</p>&#13;
&#13;
<p>To make the code thread-safe, we need to make the read,&#13;
increment, and write operations on the variable <code>globalVar</code>,&#13;
together, <em>atomic</em>. An atomic operation is one that cannot&#13;
be interrupted by another thread. If the read, increment,&#13;
and write operations are atomic, then no two threads can see&#13;
the same value of <code>globalVar</code>, and the program is guaranteed&#13;
to behave as expected.</p>&#13;
&#13;
<p>Atomicity is easy to understand.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Visibility" data-type="sect2"><div class="sect2" id="idm46669754156816">&#13;
<h2>Visibility</h2>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="visibility" data-type="indexterm" id="idm46669754155216"/><a data-primary="thread safety" data-secondary="visibility" data-type="indexterm" id="idm46669754154240"/><a data-primary="visibility" data-type="indexterm" id="idm46669754153296"/>Our second category of thread-safety errors, visibility, is&#13;
much more difficult to apprehend. This code is also not&#13;
thread-safe:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">var</code> <code class="py">shouldStop</code> <code class="p">=</code> <code class="k">false</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">runner</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">while</code> <code class="p">(!</code><code class="n">shouldStop</code><code class="p">)</code> <code class="p">{</code> <code class="n">doSomething</code><code class="p">()</code> <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">stopper</code><code class="p">()</code> <code class="p">{</code> <code class="n">shouldStop</code> <code class="p">=</code> <code class="k">true</code> <code class="p">}</code></pre>&#13;
&#13;
<p>A thread running the function <code>runner</code> may never stop, even&#13;
though another thread runs <code>stopper</code>. The thread running&#13;
<code>runner</code> may never notice that the value of&#13;
&#13;
<span class="keep-together"><code>shouldStop</code></span> has changed to <code>true</code>.</p>&#13;
&#13;
<p>The reason for this is optimization. Both the hardware&#13;
(using registers, multilayer caches, etc.) and the compiler&#13;
(using hoisting, reordering, etc.) do their very best to&#13;
make your code run fast. In order to do this, the&#13;
instructions that the hardware actually executes may not&#13;
look much like the Kotlin source at all. In particular,&#13;
while you think that <code>shouldStop</code> is a single variable, the&#13;
hardware probably has at least two representations for it:&#13;
one in a register and one in main memory.</p>&#13;
&#13;
<p>You definitely want that! You would not want the loops in&#13;
your code to depend on access to main memory instead of&#13;
using caches and registers. Fast memory optimizes your code&#13;
because it has access times that are several orders of&#13;
magnitude faster than main memory.</p>&#13;
&#13;
<p>To make the example code work, though, you have to&#13;
explain to the compiler that it cannot keep the value of&#13;
<code>shouldStop</code> in local memory (a register or cache). If, as&#13;
proposed, there are multiple representations of <code>shouldStop</code>&#13;
in different kinds of hardware memory, the compiler must be&#13;
sure that the value kept in the fast, local representation&#13;
of <code>shouldStop</code> is pushed to memory that is visible to all threads.&#13;
This is called <em>publishing</em> the value.</p>&#13;
&#13;
<p><code>@Synchronized</code> is the way to do that. <a data-primary="synchronization" data-type="indexterm" id="idm46669754066512"/>Synchronization&#13;
tells the compiler that it must make sure that any side&#13;
effects of the code executed within the synchronized block&#13;
are visible to all other threads, before the executing&#13;
thread leaves the block.</p>&#13;
&#13;
<p>Synchronization, then, is not so much about hardware, or&#13;
tricky and complicated criteria for what must be protected&#13;
and what need not be. Synchronization is a contract between&#13;
the developer and the compiler. If you don’t synchronize&#13;
code, the compiler is free to make any optimization that it&#13;
can prove safe, based on serial execution. If there is other&#13;
code somewhere, running on a different thread, that makes&#13;
the compiler’s proof invalid, you must synchronize the code.</p>&#13;
&#13;
<p>So, here’s the rule. If you want to write code that is&#13;
thread-safe, you just have to follow this one short, clear&#13;
rule. Paraphrasing from Java’s bible of parallel programming,&#13;
<a href="https://oreil.ly/4zx8L"><em>Java Concurrency in Practice</em></a>:<sup><a data-type="noteref" href="ch04.html#idm46669754063120" id="idm46669754063120-marker">2</a></sup> Whenever more than one thread accesses a given state variable, and one of them might write to it, they all must coordinate their access to it using synchronization.</p>&#13;
&#13;
<p>Note, by the way, that that quote does not distinguish&#13;
between read access and write access for synchronization.&#13;
Unless it is guaranteed that <em>nobody</em> will mutate the&#13;
shared state, all access, read or write, must be synchronized.<a data-startref="ix_ch04-asciidoc2" data-type="indexterm" id="idm46669754060816"/><a data-startref="ix_ch04-asciidoc1" data-type="indexterm" id="idm46669754060112"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Android Threading Model" data-type="sect1"><div class="sect1" id="idm46669754156192">&#13;
<h1>The Android Threading Model</h1>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="threading model" data-type="indexterm" id="idm46669754058192"/><a data-primary="threading model" data-secondary="basics" data-type="indexterm" id="idm46669754057216"/>As noted in <a data-type="xref" href="ch03.html#android_fundamentals">Chapter 3</a>, one of the implications of an MVC&#13;
architecture is a single-threaded UI (the View and Controller).&#13;
Although a multithreaded UI seems very tempting (surely&#13;
a thread for the View and a thread for the Controller would&#13;
work…), attempts to build them were abandoned back in the&#13;
1970s, when it became clear that they, inevitably, ended&#13;
in a snarl of deadlocks.</p>&#13;
&#13;
<p>Since the general adoption of MVC, the standard UI design is&#13;
a queue serviced by a single thread (in Android, the <em>Main-</em>,&#13;
or <em>UI-thread</em>). As illustrated in <a data-type="xref" href="#ui_thread">Figure 4-1</a>, &#13;
<span class="keep-together">events—both</span>&#13;
those that originate with a user (clicks, taps, typing, etc.)&#13;
and those that originate in the model (animation, requests to&#13;
redraw/update the screen, etc.)—are enqueued and eventually&#13;
processed in order by the single UI thread.</p>&#13;
&#13;
<figure><div class="figure" id="ui_thread">&#13;
<img alt="pawk 0401" src="assets/pawk_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>UI thread.</h6>&#13;
</div></figure>&#13;
&#13;
<p>This is exactly how Android’s UI works.  An application’s&#13;
main thread (the application process’s original thread) becomes its UI&#13;
thread. As part of initialization, the thread enters a tight&#13;
loop. For the rest of the life of the application, it&#13;
removes tasks from the canonical UI queue one by one and executes them.  Because UI methods are always run on a&#13;
single thread, UI components make no attempt to be thread-safe.</p>&#13;
&#13;
<p>That sounds great, right? A single-threaded UI and no&#13;
worries about thread safety. There’s a problem, though. To&#13;
understand it, we’ll have to switch out of our developer&#13;
hats and talk a bit about the experience of the end users of&#13;
Android devices.  In particular, we’ll need to look into&#13;
some details of video display.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Threads are said to<a data-primary="deadlock" data-type="indexterm" id="idm46669754047152"/> <em>deadlock</em> when each holds a resource&#13;
that the other requires: neither can make forward progress.&#13;
For instance, one thread might hold the widget that displays&#13;
a value and require the container that holds the value to&#13;
be displayed.  At the same time, another thread might hold&#13;
the container and require the widget.&#13;
Deadlocks can be avoided if all threads always seize resources&#13;
in the same order.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dropped Frames" data-type="sect1"><div class="sect1" id="_dropped_frames">&#13;
<h1>Dropped Frames</h1>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="dropped frames" data-type="indexterm" id="ix_ch04-asciidoc3"/><a data-primary="dropped frames" data-type="indexterm" id="ix_ch04-asciidoc4"/>We know, from long experience with motion pictures and TV,&#13;
that the human brain can be tricked into perceiving motion&#13;
as continuous, even when it is not.  A series of still&#13;
images shown rapidly, one after the other, can appear to the&#13;
observer to be smooth, uninterrupted motion. The rate at&#13;
which the images are displayed is known as the <em>frame rate</em>.&#13;
It is measured in <em>frames per second</em> (fps).</p>&#13;
&#13;
<p>The standard frame rate for movies is 24 fps. That has worked&#13;
quite well for the entire Golden Age of Hollywood. Older&#13;
televisions used a frame rate of 30 fps. As you might&#13;
imagine, faster frame rates do an even better job&#13;
of tricking the brain than slow ones. Even if you&#13;
can’t exactly put your finger on what you are sensing, if&#13;
you watch a high frame rate video next to one with a lower&#13;
frame rate, you will likely notice a difference. The&#13;
faster one will feel “smoother.”</p>&#13;
&#13;
<p>Many Android devices use a frame rate of 60 fps. This&#13;
translates to redrawing the screen once approximately every&#13;
16 milliseconds (ms). That means that the UI thread, the single thread&#13;
handling UI tasks, must have a new image available, ready to&#13;
be drawn on the screen every 16 ms. If producing the image&#13;
takes longer than that, and the new image is not ready when&#13;
the screen is redrawn, we say that the frame has been&#13;
dropped.</p>&#13;
&#13;
<p>It will be another 16 ms before the screen is redrawn again&#13;
and a new frame becomes visible. Instead of 60 fps, a dropped frame lowers the frame rate to 30 fps, close to the threshold at which the human brain notices it. Just&#13;
a few dropped frames can give a UI a choppy feeling that is&#13;
sometimes called “jank.”</p>&#13;
&#13;
<p>Consider the queue of tasks shown in <a data-type="xref" href="#dropped_frame_1">Figure 4-2</a>, at Android’s standard render&#13;
rate of 60 fps.</p>&#13;
&#13;
<figure><div class="figure" id="dropped_frame_1">&#13;
<img alt="pawk 0402" src="assets/pawk_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Tasks queued for the UI thread.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first task, handling character input from the user, takes&#13;
8 ms to execute. The next task, updating the view, is part&#13;
of an animation. In order to look smooth, the animation&#13;
needs to be updated at least 24 times per second. The third&#13;
task, though, handling a user click, takes 22 ms. The last&#13;
task in the diagram is the next frame of the animation. <a data-type="xref" href="#dropped_frame_2">Figure 4-3</a> shows&#13;
what the UI thread sees.</p>&#13;
&#13;
<figure><div class="figure" id="dropped_frame_2">&#13;
<img alt="pawk 0403" src="assets/pawk_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>A dropped frame.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The first task completes in 8 ms. The animation draws a&#13;
frame to the display buffer in 4 ms. The UI thread then&#13;
starts to handle the click. A couple of milliseconds into&#13;
handling the click, the hardware redraw takes place and the&#13;
animation’s frame is now visible on the screen.</p>&#13;
&#13;
<p>Unfortunately, 16 ms later, the task to handle the click is still&#13;
not complete. The task to draw the next frame of the&#13;
animation, which is queued behind it, has not been processed.&#13;
When the redraw happens, the contents of the display buffer&#13;
are exactly as they were during the previous redraw.  The&#13;
animation frame has been dropped.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Computer displays are usually managed using one or more<a data-primary="display buffers" data-type="indexterm" id="idm46669754028160"/>&#13;
display buffers. A <em>display buffer</em> is an area of memory in&#13;
which user code “draws” the things that will be visible on&#13;
the screen. Occasionally, at the <em>refresh interval</em>&#13;
(approximately 16 ms for a 60 fps display), user code is&#13;
briefly locked out of the buffer. The system uses the&#13;
contents of the buffer to render the screen and then&#13;
releases it back to the user code for further updates.</p>&#13;
</div>&#13;
&#13;
<p>A few milliseconds later, when the click handling task is&#13;
complete, the animation task gets its chance to update the&#13;
display buffer. Even though the display buffer now contains&#13;
the next frame of the animation, the screen will not be&#13;
redrawn for several milliseconds. The frame rate for the&#13;
animation has been cut in half, to 30 fps, dangerously close&#13;
to visible flicker.</p>&#13;
&#13;
<p>Some newer devices, like Google’s Pixel 4, have the ability&#13;
to refresh the screen at much higher frame rates. With a&#13;
frame rate that is, for instance, twice as high (120 fps), even if the&#13;
UI thread misses two frames in a row, it still only has to&#13;
wait an extra 8 ms for the next redraw. The interval between&#13;
the two renderings in this case is only around 24 ms; much&#13;
better than the 32 ms cost of dropping a frame at 60 fps.</p>&#13;
&#13;
<p>Though increased frame rate may help, an Android developer&#13;
must be vigilant and make sure that an application drops as&#13;
few frames as possible. If an app is in the middle of an&#13;
expensive computation and that computation takes longer than&#13;
expected to complete, it will miss the redraw time slot and&#13;
drop the frame, and the application will feel janky.</p>&#13;
&#13;
<p>This scenario is the reason why it is absolutely necessary&#13;
to deal with concurrency in Android applications. Put&#13;
simply, the UI is single-threaded and the UI thread must&#13;
never be occupied for more than a few milliseconds</p>&#13;
&#13;
<p>The only possible solution for a nontrivial application is&#13;
to pass time-consuming work—database storage and&#13;
retrieval, network interactions, and long-running &#13;
<span class="keep-together">computations—to</span> some other thread.<a data-startref="ix_ch04-asciidoc4" data-type="indexterm" id="idm46669754021600"/><a data-startref="ix_ch04-asciidoc3" data-type="indexterm" id="idm46669754020864"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Memory Leaks" data-type="sect1"><div class="sect1" id="idm46669754044624">&#13;
<h1>Memory Leaks</h1>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="memory leaks" data-type="indexterm" id="ix_ch04-asciidoc5"/><a data-primary="memory leaks" data-type="indexterm" id="ix_ch04-asciidoc6"/>We’ve already dealt with one complexity introduced by&#13;
concurrency: thread safety.  Android’s component-based&#13;
architecture adds a second, equally dangerous complexity:&#13;
<em>memory leaks</em>.</p>&#13;
&#13;
<p>A memory leak occurs when the object can’t be freed&#13;
(garbage-collected) even though it’s no longer useful. At&#13;
worst, memory leaks could result in an &#13;
<span class="keep-together"><code>OutOfMemoryError</code>,</span> and&#13;
an application crash. Even if things don’t get that bad,&#13;
though, running short on memory can force more frequent&#13;
garbage collections that again cause “jank.”</p>&#13;
&#13;
<p>As discussed in <a data-type="xref" href="ch03.html#android_fundamentals">Chapter 3</a>, Android applications are&#13;
particularly susceptible to memory leaks because the&#13;
lifecycles of some of the most frequently used components—<code>Activity</code>s, <code>Fragment</code>s, <code>Service</code>s, and so on—are not under the&#13;
control of the application.  Instances of those components&#13;
can all too easily turn into dead weight.</p>&#13;
&#13;
<p>This is particularly true in a multithreaded environment.&#13;
Consider offloading a task to a worker thread like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">override</code> <code class="k">fun</code> <code class="nf">onViewCreated</code><code class="p">(</code>&#13;
    <code class="n">view</code><code class="p">:</code> <code class="n">View</code><code class="p">,</code>&#13;
    <code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// DO NOT DO THIS!</code>&#13;
    <code class="n">myButton</code><code class="p">.</code><code class="n">setOnClickListener</code> <code class="p">{</code>&#13;
        <code class="n">Thread</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">status</code> <code class="p">=</code> <code class="n">doTimeConsumingThing</code><code class="p">()</code>&#13;
            <code class="n">view</code><code class="p">.</code><code class="n">findViewById</code><code class="p">&lt;</code><code class="n">TextView</code><code class="p">&gt;(</code><code class="n">R</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="n">textview_second</code><code class="p">)</code>&#13;
                <code class="p">.</code><code class="n">setText</code><code class="p">(</code><code class="n">status</code><code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
            <code class="p">.</code><code class="n">start</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The idea of moving the time-consuming work off the UI thread&#13;
is a noble one. Unfortunately, the preceding code has several&#13;
flaws. Can you spot them?</p>&#13;
&#13;
<p>First, as mentioned earlier in this chapter, Android UI&#13;
components are not thread-safe and cannot be accessed or&#13;
modified from outside the UI thread. The call to <code>setText</code>&#13;
in this code, from a thread other than the UI thread, is incorrect.  Many Android UI components detect&#13;
unsafe uses like this, and throw exceptions if they occur.</p>&#13;
&#13;
<p>One way to address this problem is to return results to the&#13;
UI thread using one of the Android toolkit methods for safe&#13;
thread dispatch, as shown here.  Note that this code <em>still</em> has&#13;
flaws!</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting" id="post"><code class="k">override</code> <code class="k">fun</code> <code class="nf">onViewCreated</code><code class="p">(</code>&#13;
    <code class="n">view</code><code class="p">:</code> <code class="n">View</code><code class="p">,</code>&#13;
    <code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// DO NOT DO THIS EITHER!</code>&#13;
    <code class="n">myButton</code><code class="p">.</code><code class="n">setOnClickListener</code> <code class="p">{</code>&#13;
        <code class="n">Thread</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">status</code> <code class="p">=</code> <code class="n">doTimeConsumingThing</code><code class="p">()</code>&#13;
            <code class="n">view</code><code class="p">.</code><code class="n">post</code> <code class="p">{</code>&#13;
                <code class="n">view</code><code class="p">.</code><code class="n">findViewById</code><code class="p">&lt;</code><code class="n">TextView</code><code class="p">&gt;(</code><code class="n">R</code><code class="p">.</code><code class="n">id</code><code class="p">.</code><code class="n">textview_second</code><code class="p">)</code>&#13;
                    <code class="p">.</code><code class="n">setText</code><code class="p">(</code><code class="n">status</code><code class="p">)</code>&#13;
            <code class="p">}</code>&#13;
        <code class="p">}</code>&#13;
            <code class="p">.</code><code class="n">start</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That fixes the first issue (the UI method, <code>setText</code>, is now called&#13;
from the Main thread) but the code is still not correct.&#13;
Though the vagaries of the language make it hard to see the&#13;
problem, it is that the thread, newly created in the&#13;
<code>ClickListener</code>, holds an implicit reference to an Android-managed object. Since <code>doTimeConsumingThing</code> is a&#13;
method on an <code>Activity</code> (or <code>Fragment</code>), the thread, newly&#13;
created in the click listener, holds an <em>implicit</em> reference&#13;
to that <code>Activity</code>, as shown in <a data-type="xref" href="#a_leaked_activity">Figure 4-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="a_leaked_activity">&#13;
<img alt="pawk 0404" src="assets/pawk_0404.png"/>&#13;
<h6><span class="label">Figure 4-4. </span>A leaked activity.</h6>&#13;
</div></figure>&#13;
&#13;
<p>It might be more obvious if the call to&#13;
<code>doTimeConsumingThing</code> were written as&#13;
<code>this.doTimeConsumingThing</code>. If you think about it, though,&#13;
it is clear that there is no way to call the method&#13;
<code>doTimeConsumingThing</code> on some object (in this case, an&#13;
instance of an <code>Activity</code>) without holding a reference to that&#13;
object. Now the &#13;
<span class="keep-together"><code>Activity</code></span> instance cannot be garbage-collected as long as the <code>Runnable</code> running on the worker&#13;
thread holds a reference to it. If the thread runs for any&#13;
significant amount of time, <code>Activity</code> memory has leaked.</p>&#13;
&#13;
<p>This issue is considerably more difficult to address than the last. One&#13;
approach assumes that tasks that are guaranteed to hold such&#13;
an implicit reference for only a very short period of time&#13;
(less than a second) may not cause a problem. The Android&#13;
OS itself occasionally creates such short-lived tasks.</p>&#13;
&#13;
<p class="pagebreak-before"><a data-primary="ViewModel" data-type="indexterm" id="idm46669753823424"/><code>ViewModel</code>s and<a data-primary="LiveData" data-type="indexterm" id="idm46669753822336"/> <code>LiveData</code> ensure that your UI always renders the freshest data, and does it safely. Combined with Jetpack’s <code>viewModelScope</code> and coroutines—both to be introduced shortly—all these&#13;
things make it easier to control cancellation of background tasks that are no longer relevant, and ensure memory integrity and thread safety.  Without the libraries, we’d have to correctly address all of these concerns &#13;
<span class="keep-together">ourselves.</span></p>&#13;
<div class="jetpack" data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Careful design using Jetpacks’ lifecycle-aware,&#13;
observable <code>LiveData</code> containers, as described in&#13;
<a data-type="xref" href="ch03.html#android_fundamentals">Chapter 3</a>, can help to eliminate both memory leaks and the&#13;
danger of using an Android component that has completed its&#13;
lifecycle.<a data-startref="ix_ch04-asciidoc6" data-type="indexterm" id="idm46669753817120"/><a data-startref="ix_ch04-asciidoc5" data-type="indexterm" id="idm46669753816448"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tools for Managing Threads" data-type="sect1"><div class="sect1" id="idm46669754019600">&#13;
<h1>Tools for Managing Threads</h1>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="thread managing tools" data-type="indexterm" id="ix_ch04-asciidoc7"/><a data-primary="thread managing tools" data-type="indexterm" id="ix_ch04-asciidoc8"/>There is, actually, a third flaw in the code we just discussed; a deep design flaw.</p>&#13;
&#13;
<p>Threads are very expensive objects.  They are large, they&#13;
affect garbage collection, and switching context among them&#13;
is far from free. Creating and destroying threads, as&#13;
the code in the example does, is quite&#13;
wasteful, ill-advised, and likely to affect application&#13;
performance.</p>&#13;
&#13;
<p>Spawning more threads in no way makes an application able to&#13;
accomplish more work: a CPU has only so much power. Threads&#13;
that are not executing are simply an expensive way of&#13;
representing work that is not yet complete.</p>&#13;
&#13;
<p>Consider, for instance, what would happen if a user mashed&#13;
<code>myButton</code>, from the previous example. Even if the operations&#13;
that each of the generated threads performed were fast and thread-safe,&#13;
creating and destroying those threads would slow the app to&#13;
a crawl.</p>&#13;
&#13;
<p>A best practice for applications is a thread policy: an&#13;
application-wide strategy based on the number of threads&#13;
that is actually useful, that controls how many threads are&#13;
running at any given time.  A smart application maintains&#13;
one or more pools of threads, each with a particular&#13;
purpose, and each fronted by a queue.  Client code, with&#13;
work to be done, enqueues tasks to be executed by the pool&#13;
threads and, if necessary, recovers the task results.</p>&#13;
&#13;
<p>The next two sections introduce two threading primitives&#13;
available to Android developers, the <code>Looper</code>/<code>Handler</code> and&#13;
the <code>Executor</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Looper/Handler" data-type="sect2"><div class="sect2" id="idm46669753806832">&#13;
<h2>Looper/Handler</h2>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="Looper/Handler" data-type="indexterm" id="ix_ch04-asciidoc9"/><a data-primary="Looper/Handler" data-type="indexterm" id="ix_ch04-asciidoc10"/><a data-primary="thread managing tools" data-secondary="Looper/Handler" data-type="indexterm" id="ix_ch04-asciidoc11"/>The <code>Looper</code>/<code>Handler</code> is a framework of cooperating classes: a&#13;
<code>Looper</code>, a <code>MessageQueue</code> and the <code>Message</code>s enqueued on&#13;
it, and one or more <code>Handler</code>s.</p>&#13;
&#13;
<p>A <code>Looper</code> is simply a Java <code>Thread</code> that is initialized&#13;
by calling the methods <a data-primary="Looper.prepare()" data-type="indexterm" id="idm46669753797056"/>&#13;
<span class="keep-together"><code>Looper.prepare()</code></span> and&#13;
<a data-primary="Looper.start()" data-type="indexterm" id="idm46669753795376"/><code>Looper.start()</code> from its <code>run</code> method, like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">var</code> <code class="py">looper</code> <code class="p">=</code> <code class="n">Thread</code> <code class="p">{</code>&#13;
    <code class="n">Looper</code><code class="p">.</code><code class="n">prepare</code><code class="p">()</code>&#13;
    <code class="n">Looper</code><code class="p">.</code><code class="n">loop</code><code class="p">()</code>&#13;
<code class="p">}</code>&#13;
<code class="n">looper</code><code class="p">.</code><code class="n">start</code><code class="p">()</code></pre>&#13;
&#13;
<p>The second method, <code>Looper.loop()</code>, causes the thread to&#13;
enter a tight loop in which it checks its <code>MessageQueue</code> for&#13;
tasks, removes them one by one, and executes them.  If there&#13;
are no tasks to be executed, the thread sleeps until a new&#13;
task is enqueued.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you find yourself thinking that this sounds vaguely&#13;
familiar, you are right.  Android’s UI thread is simply a&#13;
<code>Looper</code> created from the application process’s main thread.</p>&#13;
</div>&#13;
&#13;
<p>A <code>Handler</code> is the mechanism used to enqueue tasks on a&#13;
<code>Looper</code>’s queue, for processing.  You create a <code>Handler</code>&#13;
like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">var</code> <code class="py">handler</code> <code class="p">=</code> <code class="n">new</code> <code class="n">Handler</code><code class="p">(</code><code class="n">someLooper</code><code class="p">);</code></pre>&#13;
&#13;
<p>The main thread’s <code>Looper</code> is always accessible using the&#13;
method <code>Looper.getMainLooper</code>.   Creating a <code>Handler</code> that&#13;
posts tasks to the UI thread, then, is as simple as this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">var</code> <code class="py">handler</code> <code class="p">=</code> <code class="n">new</code> <code class="n">Handler</code><code class="p">(</code><code class="n">Looper</code><code class="p">.</code><code class="n">getMainLooper</code><code class="p">);</code></pre>&#13;
&#13;
<p>In fact, this is exactly how the <code>post()</code> method, shown in the preceding example,  works.</p>&#13;
&#13;
<p><code>Handler</code>s are interesting because they handle both ends of&#13;
the <code>Looper</code>’s queue.  In order to see how this works,&#13;
let’s follow a single task through the <code>Looper</code>/<code>Handler</code>&#13;
framework.</p>&#13;
&#13;
<p class="pagebreak-before">There are several <code>Handler</code> methods for enqueuing a task.&#13;
Here are two of them:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>post(task: Runnable)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>send(task: Message)</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These two methods define two slightly different ways of&#13;
enqueuing a task: sending messages and posting <code>Runnable</code>s.&#13;
Actually, the <code>Handler</code> always enqueues a <code>Message</code>. For&#13;
convenience, though, the <code>post...()</code> group of methods attach a&#13;
<code>Runnable</code> to the <code>Message</code> for special handling.</p>&#13;
&#13;
<p>In this example we use the method <code>Handler.post(task:&#13;
Runnable)</code> to enqueue our task. The <code>Handler</code> obtains a&#13;
<code>Message</code> object from a pool, attaches the <code>Runnable</code>, and&#13;
adds the <code>Message</code> to the end of the <code>Looper</code>’s&#13;
<code>MessageQueue</code>.</p>&#13;
&#13;
<p>Our task is now awaiting execution. When it reaches the head&#13;
of the queue, the <code>Looper</code> picks it up and, interestingly,&#13;
hands it right back to the exact same <code>Handler</code> that&#13;
enqueued it.  The same <code>Handler</code> instance that enqueues a&#13;
task is always the instance that runs it.</p>&#13;
&#13;
<p>This can seem a bit perplexing until you realize that the&#13;
<code>Handler</code> code that submitted the task might be running on&#13;
any application thread.  The <code>Handler</code> code that processes&#13;
the task, however, is <em>always</em> running on the <code>Looper</code>,&#13;
as shown in <a data-type="xref" href="#looper_handler">Figure 4-5</a>.</p>&#13;
&#13;
<figure><div class="figure" id="looper_handler">&#13;
<img alt="pawk 0405" src="assets/pawk_0405.png"/>&#13;
<h6><span class="label">Figure 4-5. </span><code>Looper</code>/<code>Handler</code>.</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>Handler</code> method called by the <code>Looper</code> to handle a&#13;
task first checks to see if the <code>Message</code> contains a&#13;
<code>Runnable</code>.  If it does—and because we used one of the&#13;
<code>post...()</code> methods, our task does—the <code>Handler</code>&#13;
executes the <code>Runnable</code>.</p>&#13;
&#13;
<p>If we’d used one of the<a data-primary="send…()" data-type="indexterm" id="idm46669753660240"/> <code>send...()</code> methods, the <code>Handler</code> would have passed the <code>Message</code> to its own overridable method, &#13;
<span class="keep-together"><code>Handler.handleMessage(msg: Message)</code>.</span>&#13;
A subclass of <code>Handler</code> would, in that method, use the&#13;
<code>Message</code> attribute <code>what</code> to decide which particular task&#13;
it should perform, and the attributes <code>arg1</code>, <code>arg2</code>, and&#13;
<code>obj</code> as task parameters.</p>&#13;
&#13;
<p>The <code>MessageQueue</code> is, actually, a sorted queue.  Each&#13;
<code>Message</code> includes, as one of its attributes, the earliest time at&#13;
which it may be executed. In the preceding two methods, <code>post</code>&#13;
and <code>send</code>, simply use the current time (the message will be&#13;
processed “now,” immediately).</p>&#13;
&#13;
<p>Two other methods, though, allow tasks to be enqueued to be&#13;
run at some time in the future:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>postDelayed(runnable, delayMillis)</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>sendMessageDelayed(message, delayMillis)</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Tasks created using these&#13;
methods will be sorted into the <code>MessageQueue</code> to be&#13;
executed at the indicated time.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As noted, a <code>Looper</code> can only make a best effort at&#13;
running a task at the requested time. While it will never&#13;
run a delayed task before its time, if another task hogs&#13;
the thread the task may run late.</p>&#13;
</div>&#13;
&#13;
<p><code>Looper</code>/<code>Handler</code>s are a fantastically versatile and efficient&#13;
tool.  The Android system makes extensive use of them,&#13;
particularly the <code>send...()</code> calls, which do not do any&#13;
memory allocation.</p>&#13;
&#13;
<p>Note that a <code>Looper</code> can submit tasks to itself.  Tasks&#13;
that execute and then reschedule themselves after a given interval&#13;
(using one of the <code>...Delayed()</code> methods) are one of&#13;
the ways that Android creates animations.</p>&#13;
&#13;
<p>Also note that because a <code>Looper</code> is single-threaded, a task that is&#13;
only run on one particular <code>Looper</code> need not be thread-safe.&#13;
There is no need for synchronization or ordering when a task, even&#13;
a task that is run asynchronously, is run only on a single thread.&#13;
As mentioned earlier, the entire Android UI framework,&#13;
which runs only on the UI Looper, depends on this assumption.<a data-startref="ix_ch04-asciidoc11" data-type="indexterm" id="idm46669753641312"/><a data-startref="ix_ch04-asciidoc10" data-type="indexterm" id="idm46669753640608"/><a data-startref="ix_ch04-asciidoc9" data-type="indexterm" id="idm46669753639936"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Executors and ExecutorServices" data-type="sect2"><div class="sect2" id="_threadpool">&#13;
<h2>Executors and ExecutorServices</h2>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="Executors and ExecutorServices" data-type="indexterm" id="ix_ch04-asciidoc12"/><a data-primary="Executors" data-type="indexterm" id="ix_ch04-asciidoc13"/><a data-primary="ExecutorServices" data-type="indexterm" id="ix_ch04-asciidoc14"/><a data-primary="thread managing tools" data-secondary="Executors and ExecutorServices" data-type="indexterm" id="ix_ch04-asciidoc15"/>Java introduced <code>Executor</code>s and <code>ExecutorService</code>s in Java&#13;
5, as part of a new Concurrency Framework. The new framework&#13;
provided several higher-level concurrency  abstractions that&#13;
allowed developers to leave behind many of the details of&#13;
threads, locks, and synchronization.</p>&#13;
&#13;
<p>An <code>Executor</code> is, as its name suggests, a utility that executes&#13;
tasks submitted to it.  Its contract is the single method&#13;
<code>execute(Runnable)</code>.</p>&#13;
&#13;
<p>Java provides several implementations of the interface, each&#13;
with a different execution strategy and purpose.  The&#13;
simplest of these is available using the method&#13;
&#13;
<span class="keep-together"><code>Executors.newSingleThreadExecutor</code>.</span></p>&#13;
&#13;
<p>A single-threaded executor is very similar to the&#13;
<code>Looper</code>/<code>Handler</code> examined in the previous section: it is an&#13;
unbounded queue in front of a single thread.  New tasks are&#13;
enqueued onto the queue and then removed and executed in&#13;
order on the single thread that services the queue.</p>&#13;
&#13;
<p><code>Looper</code>/<code>Handler</code>s and single-threaded <code>Executor</code>s each have their&#13;
own advantages. For instance, a <code>Looper</code>/<code>Handler</code> is heavily&#13;
optimized, to avoid object allocation.  On the other hand, a single-threaded&#13;
<code>Executor</code> will replace its thread if that thread is&#13;
aborted by a failing task.</p>&#13;
&#13;
<p>A generalization of the single-threaded <code>Executor</code> is the&#13;
<code>FixedThreadPoolExecutor</code>: instead of a single thread, its&#13;
unbounded queue is serviced by a fixed number of threads.&#13;
Like the single-threaded <code>Executor</code>, a <code>FixedThreadPoolExecutor</code> will replace threads when tasks kill them.  A&#13;
<code>FixedThreadPoolExecutor</code> does not guarantee task order,&#13;
though, and will execute tasks simultaneously, hardware&#13;
permitting.</p>&#13;
&#13;
<p>The single-threaded scheduled <code>Executor</code> is Java’s equivalent of the <code>Looper</code>/<code>Handler</code>. It’s similar to a&#13;
single-threaded <code>Executor</code> except that, like the&#13;
<code>Looper</code>/<code>Handler</code>, its queue is sorted by execution time.&#13;
Tasks are executed in time order, not submission order. As&#13;
with the <code>Looper</code>/<code>Handler</code>, of course, long-running tasks can&#13;
prevent subsequent tasks from being executed on time.</p>&#13;
&#13;
<p>If none of these standard execution utilities meets your&#13;
needs, you can create a custom instance of&#13;
<a data-primary="ThreadPoolExecutor" data-type="indexterm" id="idm46669753617104"/><code>ThreadPoolExecutor</code>, specifying details like the size and&#13;
ordering of its queue, number of threads in its thread pool&#13;
and how they are created, and what happens when the pool’s&#13;
queue is full.</p>&#13;
&#13;
<p>There is one more type of <code>Executor</code> that deserves special&#13;
attention—the<a data-primary="ForkJoinPool" data-type="indexterm" id="idm46669753614912"/> &#13;
<span class="keep-together"><code>ForkJoinPool</code>.</span> Fork-join pools exist because&#13;
of the observation that sometimes a single problem can be&#13;
broken down into multiple subproblems which can be executed&#13;
concurrently.</p>&#13;
&#13;
<p>A common example of this kind of problem is adding two&#13;
same-size arrays together.  The synchronous solution is to&#13;
iterate, <code>i = 0 .. n - 1</code>, where <code>n</code> is the size of the&#13;
array, and at each <code>i</code> to compute <code>s[i] = a1[i] + a2[i]</code>.</p>&#13;
&#13;
<p>There is a clever optimization that is possible, though, if&#13;
the task is divided into pieces.  In this case, the task can&#13;
be subdivided into <code>n`</code> subtasks, each of which computes <code>s[i]&#13;
= a1[i] + a2[i]</code> for some <code>i</code>.</p>&#13;
&#13;
<p>Note that an execution service creating subtasks&#13;
it expects to process <em>itself</em> can enqueue the&#13;
subtasks on a thread-local queue.  Since the local queue is&#13;
used predominantly by the single thread, there is almost&#13;
never contention for the queue locks. Most of the time, the&#13;
queue belongs to the thread—it alone puts things on and&#13;
takes them off. This can be quite an optimization.</p>&#13;
&#13;
<p>Consider a pool of these threads, each with its own&#13;
fast, local queue.  Suppose that one of the threads finishes all&#13;
of its work and is about to idle itself, while at the same&#13;
time another pool thread has a queue of 200 subtasks to&#13;
execute.  The idle thread steals the work.  It grabs the&#13;
lock for the busy thread’s queue, grabs half of the&#13;
subtasks, puts them in its own queue, and goes to work on&#13;
them.</p>&#13;
&#13;
<p>The work-stealing trick is most useful when concurrent tasks&#13;
spawn their own subtasks. As we will see, it turns out that&#13;
Kotlin coroutines are exactly such tasks<a data-startref="ix_ch04-asciidoc15" data-type="indexterm" id="idm46669753605872"/><a data-startref="ix_ch04-asciidoc14" data-type="indexterm" id="idm46669753605168"/><a data-startref="ix_ch04-asciidoc13" data-type="indexterm" id="idm46669753604496"/><a data-startref="ix_ch04-asciidoc12" data-type="indexterm" id="idm46669753603824"/>.<a data-startref="ix_ch04-asciidoc8" data-type="indexterm" id="idm46669753603024"/><a data-startref="ix_ch04-asciidoc7" data-type="indexterm" id="idm46669753602320"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tools for Managing Jobs" data-type="sect1"><div class="sect1" id="idm46669753639008">&#13;
<h1>Tools for Managing Jobs</h1>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="job managing tools" data-type="indexterm" id="ix_ch04-asciidoc16"/><a data-primary="job managing tools" data-type="indexterm" id="ix_ch04-asciidoc17"/>Just as there can be economies of scale in the production of,&#13;
say, cars, there are important optimizations that require&#13;
the large-scale view of a system. Consider the use of the&#13;
radio on a mobile phone.</p>&#13;
&#13;
<p>When an application needs to interact with a remote service,&#13;
the phone, normally in battery-saving mode, must power up&#13;
its radio, connect to a nearby tower, negotiate a connection,&#13;
and then transmit its message.  Because connection&#13;
negotiation is overhead, the phone holds the connection open&#13;
for a while. The assumption is that, when one network&#13;
interaction takes place, it is likely that others will&#13;
 follow.  When more than a minute or so goes by&#13;
without any use of the network, though, the phone goes back&#13;
to its quiescent, battery-saving state.</p>&#13;
&#13;
<p>Given this behavior, imagine what happens when several&#13;
applications phone home, each at a different time. When the&#13;
first app sends its ping, the phone powers its radio up,&#13;
negotiates the connection, transmits a message for the app,&#13;
waits a bit, and then goes back to sleep. Just as it goes&#13;
back to sleep, though, the next application tries to use the&#13;
network.  The phone has to power back up, renegotiate a&#13;
connection, and so on.  If there are more than a handful of&#13;
applications doing this, the phone radio is at full power&#13;
essentially all the time.  It is also spending a lot of that&#13;
time renegotiating a network connection that it dropped&#13;
just a few seconds ago.</p>&#13;
&#13;
<p>No single application can prevent this kind of problem. It&#13;
requires a system-wide view of battery and network use to&#13;
coordinate multiple apps (each with its own requirements)&#13;
and to optimize battery life.</p>&#13;
&#13;
<p>Android 8.0 (API 26+) introduced limits on application&#13;
resource consumption. Included in these limitations are the&#13;
following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An application is in the foreground only when it has a&#13;
visible activity or is running a foreground service. Bound&#13;
and started <code>Service</code>s no longer prevent an application&#13;
from being killed.</p>&#13;
</li>&#13;
<li>&#13;
<p>Applications cannot use their manifest to register for&#13;
implicit broadcasts. There are also limitations on&#13;
sending broadcasts.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These constraints can make it difficult for an application&#13;
to perform “background” tasks: synching with a remote,&#13;
recording location, and so on. In most cases, the&#13;
constraints can be mitigated using the <code>JobScheduler</code> or&#13;
Jetpack’s <code>WorkManager</code>.</p>&#13;
&#13;
<p>Whenever medium to large tasks have to be scheduled more&#13;
than a few minutes in the future, it is a best practice to use one of these tools.  Size matters: refreshing an animation every few milliseconds, or scheduling another location check&#13;
in a couple of seconds, is probably a fine thing to do&#13;
with a thread-level scheduler. Refreshing a database from its&#13;
upstream every 10 minutes is definitely something that&#13;
should be done using the <code>JobScheduler</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="JobScheduler" data-type="sect2"><div class="sect2" id="idm46669753588400">&#13;
<h2>JobScheduler</h2>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="JobScheduler" data-type="indexterm" id="ix_ch04-asciidoc18"/><a data-primary="job managing tools" data-secondary="JobScheduler" data-type="indexterm" id="ix_ch04-asciidoc19"/><a data-primary="JobScheduler" data-type="indexterm" id="ix_ch04-asciidoc20"/>The <code>JobScheduler</code> is Android’s tool for scheduling tasks—possibly repeating tasks—in the future.  It is quite&#13;
adaptable and, in addition to optimizing battery life,&#13;
provides access to details of system state that applications&#13;
used to have to infer from heuristics.</p>&#13;
&#13;
<p>A <code>JobScheduler</code> job is, actually, a bound service.&#13;
An application declares a special service in its manifest to&#13;
make it visible to the Android system.  It then schedules&#13;
tasks for the service using<a data-primary="JobInfo" data-type="indexterm" id="idm46669753581552"/> <code>JobInfo</code>.</p>&#13;
&#13;
<p>When the <code>JobInfo</code>’s conditions are met, Android binds the&#13;
task service, much as we described in <a data-type="xref" href="ch03.html#bound_services">“Bound Services”</a>. Once the task has been bound,&#13;
Android instructs the service to run and passes any relevant parameters.</p>&#13;
&#13;
<p>The first step in creating a <code>JobScheduler</code> task is registering&#13;
it in the application manifest.  That is done as shown here:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;service</code>&#13;
    <code class="na">android:name=</code><code class="s">".RecurringTask"</code>&#13;
    <code class="na">android:permission=</code><code class="s">"android.permission.BIND_JOB_SERVICE"</code><code class="nt">/&gt;</code></pre>&#13;
&#13;
<p>The important thing in this declaration is the permission.&#13;
Unless the service is declared with <em>exactly</em> the&#13;
<code>android.permission.BIND_JOB_SERVICE</code> permission, the&#13;
<code>JobScheduler</code> will not be able to find it.</p>&#13;
&#13;
<p>Note that the task service is not visible to other&#13;
applications.  This is not a problem.  The <code>JobScheduler</code> is&#13;
part of the Android system and can see things that normal&#13;
applications cannot.</p>&#13;
&#13;
<p>The next step in setting up a <code>JobScheduler</code> task is&#13;
scheduling it, as shown here, in the method <code>schedulePeriodically</code>:</p>&#13;
&#13;
<pre class="less_space pagebreak-before" data-code-language="kotlin" data-type="programlisting"><code class="n">const</code> <code class="k">val</code> <code class="py">TASK_ID</code> <code class="p">=</code> <code class="m">8954</code>&#13;
<code class="n">const</code> <code class="k">val</code> <code class="py">SYNC_INTERVAL</code> <code class="p">=</code> <code class="m">30L</code>&#13;
<code class="n">const</code> <code class="k">val</code> <code class="py">PARAM_TASK_TYPE</code> <code class="p">=</code> <code class="s">"task"</code>&#13;
<code class="n">const</code> <code class="k">val</code> <code class="py">SAMPLE_TASK</code> <code class="p">=</code> <code class="m">22158</code>&#13;
&#13;
<code class="k">class</code> <code class="nc">RecurringTask</code><code class="p">()</code> <code class="p">:</code> <code class="n">JobService</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
        <code class="k">fun</code> <code class="nf">schedulePeriodically</code><code class="p">(</code><code class="n">context</code><code class="p">:</code> <code class="n">Context</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="k">val</code> <code class="py">extras</code> <code class="p">=</code> <code class="n">PersistableBundle</code><code class="p">()</code>&#13;
            <code class="n">extras</code><code class="p">.</code><code class="n">putInt</code><code class="p">(</code><code class="n">PARAM_TASK_TYPE</code><code class="p">,</code> <code class="n">SAMPLE_TASK</code><code class="p">)</code>&#13;
&#13;
            <code class="p">(</code><code class="n">context</code><code class="p">.</code><code class="n">getSystemService</code><code class="p">(</code><code class="n">Context</code><code class="p">.</code><code class="n">JOB_SCHEDULER_SERVICE</code><code class="p">)</code>&#13;
                <code class="k">as</code> <code class="n">JobScheduler</code><code class="p">)</code>&#13;
                <code class="p">.</code><code class="n">schedule</code><code class="p">(</code>&#13;
                    <code class="n">JobInfo</code><code class="p">.</code><code class="n">Builder</code><code class="p">(</code>&#13;
                        <code class="n">TASK_ID</code><code class="p">,</code>&#13;
                        <code class="n">ComponentName</code><code class="p">(</code>&#13;
                            <code class="n">context</code><code class="p">,</code>&#13;
                            <code class="n">RecurringTask</code><code class="o">::</code><code class="k">class</code><code class="p">.</code><code class="n">java</code>&#13;
                        <code class="p">)</code>&#13;
                    <code class="p">)</code>&#13;
                        <code class="p">.</code><code class="n">setPeriodic</code><code class="p">(</code><code class="n">SYNC_INTERVAL</code><code class="p">)</code>&#13;
                        <code class="p">.</code><code class="n">setRequiresStorageNotLow</code><code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
                        <code class="p">.</code><code class="n">setRequiresCharging</code><code class="p">(</code><code class="k">true</code><code class="p">)</code>&#13;
                        <code class="p">.</code><code class="n">setExtras</code><code class="p">(</code><code class="n">extras</code><code class="p">)</code>&#13;
                        <code class="p">.</code><code class="n">build</code><code class="p">()</code>&#13;
                <code class="p">)</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">onStartJob</code><code class="p">(</code><code class="n">params</code><code class="p">:</code> <code class="n">JobParameters</code><code class="p">?):</code> <code class="n">Boolean</code> <code class="p">{</code>&#13;
        <code class="c1">// do stuff</code>&#13;
        <code class="k">return</code> <code class="k">true</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="k">override</code> <code class="k">fun</code> <code class="nf">onStopJob</code><code class="p">(</code><code class="n">params</code><code class="p">:</code> <code class="n">JobParameters</code><code class="p">?):</code> <code class="n">Boolean</code> <code class="p">{</code>&#13;
        <code class="c1">// stop doing stuff</code>&#13;
        <code class="k">return</code> <code class="k">true</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This particular task will be run every <code>SYNC_INTERVAL</code> seconds&#13;
but only if there is sufficient space on the device and if&#13;
it is currently attached to an external power source. These&#13;
are only two of the wide variety of attributes available for&#13;
scheduling a task. The granularity and flexibility of&#13;
scheduling is, perhaps, the <code>JobScheduler</code>’s most appealing&#13;
quality.</p>&#13;
&#13;
<p>Note that <code>JobInfo</code> identifies the task class to be run in&#13;
much the same way that we identified the target for an&#13;
<code>Intent</code> back in <a data-type="xref" href="ch03.html#android_fundamentals">Chapter 3</a>.</p>&#13;
&#13;
<p>The system will call the  task’s <code>onStartJob</code> method based&#13;
on the criteria set in the <code>JobInfo</code> when the task is&#13;
eligible to run.  This is why the <code>JobScheduler</code> exists.&#13;
Because it knows the schedules and requirements for all&#13;
scheduled tasks, it can optimize scheduling, globally, to&#13;
minimize the impact, especially on the battery.</p>&#13;
&#13;
<p>Beware! The <code>onStartJob</code> method is run on the main (UI)&#13;
thread. If, as is very likely, the scheduled task is&#13;
something that will take more than a few milliseconds, it&#13;
must be scheduled on a background thread, using one of the&#13;
techniques described &#13;
<span class="keep-together">previously.</span></p>&#13;
&#13;
<p>If<a data-primary="onStartJob" data-type="indexterm" id="idm46669753333920"/> <code>onStartJob</code> returns <code>true</code>, the system will allow the&#13;
application to run until either it calls <code>jobFinished</code> or&#13;
the conditions described in the <code>JobInfo</code> are no longer&#13;
satisfied. If, for instance, the phone running the&#13;
<code>RecurringTask</code> in the previous example was unplugged from its&#13;
power source, the system would immediately call the running&#13;
task’s <code>onStopJob()</code> method to notify it that it should&#13;
stop.</p>&#13;
&#13;
<p>When a <code>JobScheduler</code> task receives a call to <code>onStopJob()</code>&#13;
it must stop. The documentation suggests that the task has a&#13;
little bit of time to tidy up and terminate cleanly.&#13;
Unfortunately, it is quite vague about exactly how much time&#13;
is a “little bit.”  It is quite dire, though, in its warning&#13;
that “You are solely responsible for the behavior of your&#13;
application upon receipt of this message; your app will&#13;
likely start to misbehave if you ignore it.”</p>&#13;
&#13;
<p>If <code>onStopJob()</code> returns <code>false</code>, the task will not be scheduled&#13;
again, even if the criteria in its <code>JobInfo</code> are met: the&#13;
job has been cancelled.  A recurring task should always return&#13;
<code>true</code>.<a data-startref="ix_ch04-asciidoc20" data-type="indexterm" id="idm46669753326592"/><a data-startref="ix_ch04-asciidoc19" data-type="indexterm" id="idm46669753325856"/><a data-startref="ix_ch04-asciidoc18" data-type="indexterm" id="idm46669753325184"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="WorkManager" data-type="sect2"><div class="sect2" id="idm46669753587744">&#13;
<h2>WorkManager</h2>&#13;
&#13;
<p><a data-primary="concurrent programming" data-secondary="WorkManager" data-type="indexterm" id="idm46669753323392"/><a data-primary="job managing tools" data-secondary="WorkManager" data-type="indexterm" id="idm46669753322384"/><a data-primary="WorkManager" data-type="indexterm" id="idm46669753321440"/>The <code>WorkManager</code> is an Android Jetpack library that wraps the&#13;
<code>JobScheduler</code>. It allows a single codebase to make optimal&#13;
use of modern versions of Android—those that support the&#13;
<code>JobScheduler</code>—and still work on legacy versions of&#13;
Android that do not.</p>&#13;
&#13;
<p>While the services provided by the <code>WorkManager</code>, as well as&#13;
its API, are similar to those provided by the <code>JobScheduler</code>&#13;
that it wraps, they are one more step away from the details&#13;
of implementation, and one abstraction more concise.</p>&#13;
&#13;
<p>Where the <code>JobScheduler</code> encodes the difference between a task&#13;
that repeats periodically and one that runs once&#13;
in the <code>Boolean</code> return from the <code>onStopJob</code> method, the&#13;
<code>WorkManager</code> makes it explicit; there are two types of&#13;
tasks: a <code>OneTimeWorkRequest</code> and a <code>PeriodicWorkRequest</code>.</p>&#13;
&#13;
<p>Enqueuing a work request always returns a token, a <code>WorkRequest</code>&#13;
that can be used to cancel the task, when it is no longer&#13;
necessary.</p>&#13;
&#13;
<p>The <code>WorkManager</code> also supports the construction of complex&#13;
task chains: “run this and that in parallel, and run the other&#13;
when both are done.” These task chains might even&#13;
remind you of the chains we used to transform collections in <a data-type="xref" href="ch02.html#the_kotlin_collections_framework">Chapter 2</a>.</p>&#13;
&#13;
<p>The <code>WorkManager</code> is the most fluent and concise way to both&#13;
guarantee that the necessary tasks are run (even when your&#13;
application is not visible on the device screen) and to do so&#13;
in a way that optimizes battery use.<a data-startref="ix_ch04-asciidoc17" data-type="indexterm" id="idm46669753310352"/><a data-startref="ix_ch04-asciidoc16" data-type="indexterm" id="idm46669753309648"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669753601056">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we introduced Android’s threading&#13;
model, and some concepts and tools to help you use it effectively. To summarize:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A thread-safe program is one that behaves, no matter how concurrent&#13;
threads execute it, in a way that could be reproduced if the same&#13;
threads executed it &#13;
<span class="keep-together">serially.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>In the Android threading model, the UI thread is responsible for the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Drawing the view</p>&#13;
</li>&#13;
<li>&#13;
<p>Dispatching events resulting from user interaction with the UI</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Android programs use multiple threads in order to ensure that&#13;
the UI thread is free to redraw the screen without dropping frames.</p>&#13;
</li>&#13;
<li>&#13;
<p>Java and Android provide several language-level threading primitives:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A <code>Looper</code>/<code>Handler</code> is a queue of tasks serviced by a single, dedicated thread.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>Executor</code>s and <code>ExecutionService</code>s are Java constructs for implementing an application-wide thread-management policy.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Android offers the architectural components <code>JobScheduler</code> and <code>WorkManager</code> to schedule tasks efficiently.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The following chapters will turn to more complex topics in&#13;
Android and concurrency. In them we will explore how Kotlin&#13;
makes managing concurrent processes clearer and easier and&#13;
less error-prone.<a data-startref="ix_ch04-asciidoc0" data-type="indexterm" id="idm46669753293600"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669754182608"><sup><a href="ch04.html#idm46669754182608-marker">1</a></sup> It is possible for processes to share some memory (as with Binder), but they do so in very controlled ways.</p><p data-type="footnote" id="idm46669754063120"><sup><a href="ch04.html#idm46669754063120-marker">2</a></sup> Goetz et al., 2006. <em>Java Concurrency in Practice.</em> Boston: Addison-Wesley.</p></div></div></section></body></html>