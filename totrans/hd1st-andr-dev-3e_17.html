<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Room Databases: Room with a View"><div class="chapter" id="room_databasescolon_room_with_a_view">
<h1><span class="label">Chapter 14. </span>Room Databases: <em>Room with a View</em></h1>
<figure class="informal"><div class="figure">
<img src="Images/f0569-01.png" alt="image" width="600" height="469"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="Android Jetpack" data-secondary="Room" data-see="Room persistence library" id="idm46053736098768"/><a data-type="indexterm" data-primary="database" data-see="Room persistence library" id="idm46053736097168"/><a data-type="indexterm" data-primary="libraries" data-seealso="Room persistence library" id="idm46053736096096"/><a data-type="indexterm" data-primary="Room persistence library" id="idm46053736095024"/><strong>Most apps need data that persists.</strong></p>
<p>But if you don’t take steps to store this data somewhere, <strong>it will be lost forever</strong> as soon as the app is closed down. You usually keep data safe in Androidville by <strong><em>s</em>toring it in a database</strong>, so in this chapter, we’ll introduce you to the <strong>Room persistence library</strong>. You’ll learn how to <strong>build databases</strong>, <strong>create tables,</strong> and <strong>define data access methods</strong> using annotated classes and interfaces. You’ll find out how to <strong>use coroutines</strong> to run database code in the background. And along the way, you’ll discover how to <strong>transform your live data as soon as it changes</strong> with a little help from <strong><em>Transformations.map()</em></strong>.</p>
<section data-type="sect1" data-pdf-bookmark="Most apps need to store data"><div class="sect1" id="most_apps_need_to_store_data">
<h1>Most apps need to store data</h1>
<p><a data-type="indexterm" data-primary="Tasks app" id="idm46053736087040"/>Nearly all of the apps that you’ve written so far have used a small amount of static data in order to function. The Guessing Game app we built in <a data-type="xref" href="ch11.xhtml#view_modelscolon_model_behavior">Chapter 11</a> to <a data-type="xref" href="ch13.xhtml#data_bindingcolon_building_smart_layouts">Chapter 13</a>, for example, holds an array of <code>String</code>s in its view model so that the game can select one at random for you to guess.</p>
<p>In the real world, however, most apps require more than just static data; they need to be able to save data that can change so that it doesn’t get lost when the user shuts down the app. A music app might need to store playlists, for example, and a game might need to record the user’s progress so that they can go back to where they left off.</p>
<section data-type="sect2" data-pdf-bookmark="Apps can persist data using a database"><div class="sect2" id="apps_can_persist_data_using_a_database">
<h2>Apps can persist data using a database</h2>
<p>In most cases, the best way of persisting the user’s data is to use a database, so in this chapter, you’re going to learn how to use one by building a Tasks app. This app will let the user add tasks to a database, and display a list of all the tasks they have already entered.</p>
<p>Here’s what the app will look like:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0570-01.png" alt="image" width="600" height="436"/>
<h6/>
</div></figure>
<p>Before we start building the app, let’s run through how it will be structured.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="How the app will be structured"><div class="sect1" id="how_the_app_will_be_structured-id00216">
<h1>How the app will be structured</h1>
<p><a data-type="indexterm" data-primary="data binding" data-secondary="TasksFragment" id="idm46053736079664"/><a data-type="indexterm" data-primary="Tasks app" data-secondary="structure" id="idm46053736074000"/><a data-type="indexterm" data-primary="TasksFragment" id="idm46053736072896"/><a data-type="indexterm" data-primary="TasksViewModel" id="idm46053736072064"/>The app will contain a single activity (named <code>MainActivity</code>), which will be used to display a fragment named <code>TasksFragment</code>.</p>
<p><code>TasksFragment</code> is the app’s main screen. Its layout file (<em>fragment_tasks.xml</em>) will include an edit text and a button, which let the user enter a task name and insert it into the database. It will also feature a text view, which will display all of the tasks that have been entered into the database:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0571-01.png" alt="image" width="600" height="455"/>
<h6/>
</div></figure>
<p>We’ll also add a view model (named <code>TasksViewModel</code>) to the app, which <code>TasksFragment</code> will use for its business logic. It will include properties and methods that the fragment will use to interact with the app’s database. We’ll also enable data binding so that <code>TasksFragment</code>’s layout has direct access to the view model.</p>
<p>Here’s how these components will interact:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0571-02.png" alt="image" width="600" height="222"/>
<h6/>
</div></figure>
<p>To create the database, we’re going to use an Android library called <strong><em>Room</em></strong>. So what’s Room?</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Room is a database library that sits on top of SQLite"><div class="sect1" id="room_is_a_database_library_that_sits_on">
<h1>Room is a database library that sits on top of SQLite</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0572-01.png" alt="image" width="337" height="118"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) architecture" id="idm46053736057104"/><a data-type="indexterm" data-primary="Room persistence library" data-secondary="SQLite" id="idm46053736056016"/><a data-type="indexterm" data-primary="SQLite database" id="idm46053736054944"/>Behind the scenes, most Android databases use SQLite. SQLite is lightweight, stable, fast, and optimized for a single user, and these features make it a good choice for Android apps. Writing the code to create, manage, and interact with SQLite databases, however, can be tricky.</p>
<p>To make things easier, Android Jetpack includes a persistence library named <strong><em>Room</em></strong> that sits on top of SQLite. With Room, you get all the benefits of using SQLite, but using simpler code. It provides you with convenient annotations, for example, that let you quickly write database code in a way that’s less repetitive and less error-prone.</p>
<blockquote>
<p><strong><strong><u>MVVM</u></strong> is an architectural design pattern that’s used to structure apps. It stands for <u>M</u>odel-<u>V</u>iew-<u>V</u>iew<u>M</u>odel.</strong></p>
</blockquote>
<section data-type="sect2" data-pdf-bookmark="Room apps are usually structured using MVVM"><div class="sect2" id="room_apps_are_usually_structured_using_m">
<h2>Room apps are usually structured using <u>MVVM</u></h2>
<p>Apps that use Room—including the Tasks app—are usually structured using an architectural design pattern called <strong><em>MVVM</em></strong>, which stands for Model-View-ViewModel. The structure looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0572-02.png" alt="image" width="600" height="302"/>
<h6/>
</div></figure>
<p>This structure is similar to the one we used for the Guessing Game app we built, except that there’s an extra Model layer for the database. It means that the activity and fragment’s UI code is cleanly separated from the business logic that’s held in the view model, and the view model is separated from any code that underpins the database.</p>
<p>You’ll learn more about how to use the MVVM structure as we build the Tasks app.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Here’s what we’re going to do"><div class="sect1" id="hereapostrophes_what_weapostroph-id00217">
<h1>Here’s what we’re going to do</h1>
<p><a data-type="indexterm" data-primary="Room persistence library" data-secondary="app setup" id="idm46053736040960"/><a data-type="indexterm" data-primary="Tasks app" data-secondary="setup" id="idm46053736039680"/>Here are the steps that we’ll go through to build the Tasks app:</p>
<ol>
<li><p><strong>Set up the basic app.</strong></p>
<p>We’ll create the app, update its <em>build.gradle</em> files so that it uses the libraries we need, and create the basic activity, fragment, and layout code.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0573-01.png" alt="image" width="228" height="146"/>
<h6/>
</div></figure></li>
<li><p><strong>Write the database code.</strong></p>
<p>In this step, we’ll add the code to create a database with a table, along with the data access methods needed to interact with the table’s data.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0573-02.png" alt="image" width="600" height="61"/>
<h6/>
</div></figure></li>
<li><p><strong>Insert task records.</strong></p>
<p>We’ll create a view model and update the app’s fragment so that we can use the app to insert records.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0573-03.png" alt="image" width="600" height="184"/>
<h6/>
</div></figure></li>
<li><p><strong>Display a list of task records.</strong></p>
<p>Finally, we’ll update the view model and fragment code so that the app displays a list of all the task records held in the database.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0573-04.png" alt="image" width="360" height="259"/>
<h6/>
</div></figure></li>
</ol>
<section data-type="sect2" data-pdf-bookmark="Create the Tasks project"><div class="sect2" id="create_the_tasks_project">
<h2>Create the Tasks project</h2>
<p>We’re going to use a new project for the Tasks app, so create one now using the same steps you used in the previous chapters. Choose the Empty Activity option, enter a name of “Tasks” and a package name of “com.hfad.tasks”, and accept the default save location. Make sure the language is set to Kotlin and the minimum SDK is API 21 so it will run on most Android devices.</p>
<p>Next, we’ll update the project’s <em>build.gradle</em> files so that they include all the features and dependencies that are needed for the app.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Add a variable to the project build.gradle file…"><div class="sect1" id="add_a_variable_to_the_project_builddotgr">
<h1>Add a variable to the <u>project</u> build.gradle file…</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0574-01.png" alt="image" width="211" height="115"/>
<h6/>
</div></figure>
<p>We’re going to use two Room libraries in this chapter, so we’ll add a new variable to the project’s <em>build.gradle</em> file to specify which version we’ll be using, and to keep things consistent. To do this, open the file <em>Tasks/build.gradle</em>, and add the following lines (in bold) to the <code>buildscript</code> section:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0574-02.png" alt="image" width="600" height="94"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="…and update the app build.gradle file, too"><div class="sect2" id="hellipand_update_the_app_builddo-id00218">
<h2>…and update the <u>app</u> build.gradle file, too</h2>
<p>In the app’s <em>build.gradle</em> file, we need to enable data binding, and add dependencies for the view model, live data, and Room libraries.</p>
<p>Open the file <em>Tasks/app/build.gradle</em>, and add the following lines (in bold) to the appropriate sections:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0574-03.png" alt="image" width="600" height="353"/>
<h6/>
</div></figure>
<p>Then click on the Sync Now option to sync the changes you’ve made with the rest of the project.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Create TasksFragment"><div class="sect1" id="create_tasksfragment">
<h1>Create TasksFragment</h1>
<p><a data-type="indexterm" data-primary="TasksFragment" data-secondary="creating" id="idm46053736011216"/>The app will include a single fragment named <code>TasksFragment</code>, which we’ll use to display a list of all the tasks in the database, and to insert new ones.</p>
<p>To create <code>TasksFragment</code>, highlight the <em>com.hfad.tasks</em> package in the <em>app/src/main/java</em> folder, then go to File→New→Fragment→Fragment (Blank). Name the fragment “TasksFragment”, name its layout “fragment_tasks”, and make sure the language is set to Kotlin.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0575-02.png" alt="image" width="388" height="302"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Update TasksFragment.kt"><div class="sect2" id="update_tasksfragmentdotkt">
<h2>Update TasksFragment.kt</h2>
<p>Once you’ve added <code>TasksFragment</code> to the project, make sure that <em>TasksFragment.kt</em> matches the code shown here:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0575-03.png" alt="image" width="600" height="481"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="relax-id00219">
<h5><span class="inlineimage"><img src="Images/cup.png" alt="Images" width="124" height="107"/></span> Relax</h5>
<p><strong>Don’t worry if the compiler doesn’t recognize the FragmentTasksBinding class.</strong></p>
<p>It’s because we haven’t yet added a <code>&lt;layout&gt;</code> element to the fragment’s layout, which it needs to generate the binding class.</p>
</div></aside>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Update fragment_tasks.xml"><div class="sect1" id="update_fragmentunderscoretasksdotxml">
<h1>Update fragment_tasks.xml</h1>
<p><a data-type="indexterm" data-primary="TasksFragment" data-secondary="data binding" id="idm46053735992448"/>We also need to update <code>TasksFragment</code>’s layout so that it uses data binding, and includes views to let us enter new tasks and display a list of existing ones.</p>
<p>Open the file <em>fragment_tasks.xml</em>, and update it so that it matches the code shown here:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0576-02.png" alt="image" width="600" height="499"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Display TasksFragment in MainActivity’s layout…"><div class="sect1" id="display_tasksfragment_in_mainactivityapo">
<h1>Display TasksFragment in MainActivity’s layout…</h1>
<p><a data-type="indexterm" data-primary="TasksFragment" data-secondary="activities" id="idm46053735983328"/>In order to use <code>TasksFragment</code>, we need to add it to <code>MainActivity</code>’s layout in a <code>FragmentContainerView</code>.</p>
<p>Update the file <em>activity_main.xml</em> so that it matches the code shown here:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0577-02.png" alt="image" width="600" height="249"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="…and check the MainActivity.kt code"><div class="sect2" id="hellipand_check_the_mainactivitydotkt_co">
<h2>…and check the MainActivity.kt code</h2>
<p>Once you’ve updated the layout, open <em>MainActivity.kt</em> and make sure its code looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0577-03.png" alt="image" width="600" height="225"/>
<h6/>
</div></figure>
<p>Now that we’ve updated the fragment and activity code, let’s get to work on the Room database.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="How Room databases are created"><div class="sect1" id="how_room_databases_are_created">
<h1>How Room databases are created</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0578-01.png" alt="image" width="212" height="115"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="Room persistence library" data-secondary="database" id="idm46053735970208"/><a data-type="indexterm" data-primary="SQLite database" id="idm46053735968864"/><a data-type="indexterm" data-primary="Tasks app" data-secondary="database for" id="idm46053735968032"/>Room uses a set of annotated classes and interfaces to create and configure a SQLite database for your app. It requires three main things:</p>
<section data-type="sect2" data-pdf-bookmark="1. A database class"><div class="sect2" id="onedot_a_database_class">
<h2>1. A database class</h2>
<p>This defines the database, including its name and version number. It’s used to get an instance of the database.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0578-02.png" alt="image" width="205" height="164"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect2" data-pdf-bookmark="2. Data classes for the tables"><div class="sect2" id="twodot_data_classes_for_the_tables">
<h2>2. Data classes for the tables</h2>
<p>All of the data in a database is stored in tables. You define each table using a data class, which includes annotations to specify the table’s name and columns.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">A Kotlin data class lets you create objects whose main purpose is to hold data.</span></p>
</div>
<figure class="informal"><div class="figure">
<img src="Images/f0578-03.png" alt="image" width="511" height="175"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect2" data-pdf-bookmark="3. Interfaces for data access"><div class="sect2" id="threedot_interfaces_for_data_access">
<h2>3. Interfaces for data access</h2>
<p>You interact with each table using an interface, which specifies the data access methods your app needs. If you need to insert records, for example, you can add an <code>insert()</code> method to the interface, and to get all records, you can add a <code>getAll()</code> method.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0578-04.png" alt="image" width="197" height="311"/>
<h6/>
</div></figure>
<p>Room uses these three things to generate all the code your app needs to create the SQLite database, its tables, and any data access methods.</p>
<p>Over the next few pages, we’re going to show you how to write the code for these three components by defining a database for the Tasks app. We’ll begin by defining its table.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="We’ll store tasks data in a table"><div class="sect1" id="weapostrophell_store_tasks_data_in_a_tab">
<h1>We’ll store tasks data in a table</h1>
<p><a data-type="indexterm" data-primary="SQLite database" data-secondary="tables" id="idm46053735951776"/><a data-type="indexterm" data-primary="Task data class" id="idm46053735947744"/>As we said before, all of a database’s data is stored in one or more tables. Each table is made up of rows and columns, where each row is a record, and each column holds a single piece of data, like a number or piece of text.</p>
<p>You create a separate table for each type of data you want to hold. A calendar app, for example, might have a table to record events, and a weather app might include a table for its locations.</p>
<p>We want to store task records in the Tasks app, so we’re going to create a table named “task_table”. The table will look something like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0579-02.png" alt="image" width="600" height="103"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="You define tables with an annotated data class"><div class="sect2" id="you_define_tables_with_an_annotated_data">
<h2>You define tables with an annotated data class</h2>
<p>You specify any tables you want the database to include by defining a data class for each table. The data class needs to include a property for each of the table’s columns, and you use annotations to tell Room how the table should be configured.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0579-03.png" alt="image" width="336" height="166"/>
<h6/>
</div></figure>
<p>To see how this works, we’re going to define a data class named <code>Task</code>, which we’ll use to create a table in the Tasks app’s database.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Create the Task data class"><div class="sect2" id="create_the_task_data_class">
<h2>Create the Task data class</h2>
<p>We’ll begin by creating the data class. Highlight the <em>com.hfad.tasks</em> package in the <em>app/src/main/java</em> folder, then go to File→New→Kotlin Class/File. Name the file “Task” and choose the Class option.</p>
<p>When you’ve created the file, update its code so that it looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0579-04.png" alt="image" width="600" height="216"/>
<h6/>
</div></figure>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Specify a table name with @Entity"><div class="sect1" id="specify_a_table_name_with_commercial_ate">
<h1>Specify a table name with @Entity</h1>
<p><a data-type="indexterm" data-primary="@ColumnInfo annotation" id="idm46053735935408"/><a data-type="indexterm" data-primary="@Entity annotation, data class" id="idm46053735930672"/><a data-type="indexterm" data-primary="@PrimaryKey annotation, database table" id="idm46053735929872"/><a data-type="indexterm" data-primary="table name property" id="idm46053735929072"/><a data-type="indexterm" data-primary="taskDone property, database column" id="idm46053735928240"/><a data-type="indexterm" data-primary="taskId property, as primary key" id="idm46053735927440"/><a data-type="indexterm" data-primary="taskName property, database column" id="idm46053735926640"/>Now that we’ve created the <code>Task</code> data class, we need to add annotations to tell Room how to configure the table. We’ll begin with the table name.</p>
<p>You name a table by adding an <code><strong>@Entity</strong></code> annotation to the data class, specifying the table name. We want to give the table in the Tasks app a name of “task_table”, and the code to do so looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0580-02.png" alt="image" width="597" height="109"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Specify the primary key with @PrimaryKey"><div class="sect2" id="specify_the_primary_key_with_commercial">
<h2>Specify the primary key with @PrimaryKey</h2>
<p>Next, we’ll specify the table’s primary key. This is used to uniquely identify a single record, and can’t contain any duplicate values.</p>
<p>In the Tasks app, we’ll use the <code>taskId</code> property for <code>task_table</code>’s primary key, and we’ll get the table to autogenerate its values so that they’re unique. This is done using a <code><strong>@PrimaryKey</strong></code> annotation like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0580-04.png" alt="image" width="600" height="185"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Specify column names with @ColumnInfo"><div class="sect2" id="specify_column_names_with_commercial_atc">
<h2>Specify column names with @ColumnInfo</h2>
<p>The final thing we’ll do is specify column names for the <code>taskName</code> and <code>taskDone</code> properties. This is done using the <code><strong>@ColumnInfo</strong></code> annotation like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0580-05.png" alt="image" width="590" height="190"/>
<h6/>
</div></figure>
<p>Note that the <code>@ColumnInfo</code> annotation is <em>only needed if you want the column name to be different to the property name</em>. If you omit the annotation, Room will give the column the same name as the property.</p>
<p>That’s everything that we need to know to complete the <code>Task</code> data class. We’ll show you the full code on the next page.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full code for Task.kt"><div class="sect1" id="the_full_code_for_taskdotkt">
<h1>The full code for Task.kt</h1>
<p>Here’s the full code for the <code>Task</code> data class; update the code for <em>Task.kt</em> so that it includes the changes shown (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0581-02.png" alt="image" width="600" height="371"/>
<h6/>
</div></figure>
<p>Room uses this file to create a table named <code>task_table</code> with an autogenerated primary key named <code>taskId</code>, and two extra columns named <code>task_name</code> and <code>task_done</code>. Here’s what the table looks like:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0581-03.png" alt="image" width="408" height="99"/>
<h6/>
</div></figure>
<p>You’ll find out how Room adds this table to the database when we write the database class a few pages ahead. First, we’ll define some database access methods so that the app can insert, read, update, and delete the table’s data.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00220">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: If I leave out the <code><strong>@ColumnInfo</strong></code> annotation, will Room still create a column for that data class property?</strong></p>
<p><strong>A:</strong> Yes. It will create a column with the same name as the property. The <code>@ColumnInfo</code> annotation simply lets you rename the column.</p>
<p><strong>Q: Can I stop Room from creating a column for one of the data class properties?</strong></p>
<p><strong>A:</strong> Yes. If you don’t want to persist the data for one of the properties in the data class, you can annotate it with <code>@Ignore</code>. When you do so, Room won’t create a column in the table for this property.</p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Use an interface to specify data operations"><div class="sect1" id="use_an_interface_to_specify_data_operati">
<h1>Use an interface to specify data operations</h1>
<p><a data-type="indexterm" data-primary="@Dao annotation, database access" id="idm46053735889680"/><a data-type="indexterm" data-primary="DAO (Data Access Object)" id="idm46053735888688"/><a data-type="indexterm" data-primary="SQLite database" data-secondary="annotated interface" id="idm46053735887888"/><a data-type="indexterm" data-primary="TaskDao interface" id="idm46053735886784"/>You specify how the app will access the table’s data by creating an annotated interface. This interface defines a DAO—or <em>Data Access Object</em>—which includes all the methods the app needs to insert, read, update, and delete the data.</p>
<p>To see how this works, we’ll create a new interface named <code>TaskDao</code>, which the Tasks app will use to interact with <code>task_table</code>’s data.</p>
<section data-type="sect2" data-pdf-bookmark="Create the TaskDao interface"><div class="sect2" id="create_the_taskdao_interface">
<h2>Create the TaskDao interface</h2>
<p>We’ll begin by creating the interface. Highlight the <em>com.hfad.tasks</em> package in the <em>app/src/main/java</em> folder, then go to File→New→Kotlin Class/File. Name the file “TaskDao” and choose the Interface option.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0582-02.png" alt="image" width="332" height="391"/>
<h6/>
</div></figure>
<p>When you’ve created the file, make sure that its code looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0582-03.png" alt="image" width="418" height="139"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Use @Dao to mark the interface for data access"><div class="sect2" id="use_commercial_atdao_to_mark_the_interfa">
<h2>Use @Dao to mark the interface for data access</h2>
<p>Next, we need to tell Room that the <code>TaskDao</code> interface defines data access methods. This is done by marking the interface with an <code><strong>@Dao</strong></code> annotation like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0582-04.png" alt="image" width="600" height="215"/>
<h6/>
</div></figure>
<p>Once you’ve annotated the interface with <code>@Dao</code>, you add annotated methods that the app will use to interact with the data. If you want the app to insert records, for example, you need to add a method for this to the interface, and if you want it to get records, you need to add this method too.</p>
<p>The great news is that Room provides four annotations—<code>@Insert</code>, <code>@Update</code>, <code>@Delete</code>, and <code>@Query</code>—that make adding these methods a breeze. Let’s find out how these are used by adding some data access methods to <code>TaskDao</code>.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Use @Insert to insert a record"><div class="sect1" id="use_commercial_atinsert_to_insert_a_reco">
<h1>Use @Insert to insert a record</h1>
<p><a data-type="indexterm" data-primary="@Insert annotation, database access" id="idm46053735866544"/><a data-type="indexterm" data-primary="insert() method, tasks into database" id="idm46053735865632"/><a data-type="indexterm" data-primary="@Update annotation, database access" id="idm46053735864832"/><a data-type="indexterm" data-primary="update() method, database access" id="idm46053735864032"/>The first data access method we’ll define is an <code>insert()</code> method, which the app will use to insert a task into <code>task_table</code>. The method will have one parameter—a <code>Task</code>—for the task we want to insert. We’ll also mark the method with an <code><strong>@Insert</strong></code> annotation, which tells Room that the method is used to insert records.</p>
<p>Here’s the full code for the <code>insert()</code> method:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0583-02.png" alt="image" width="600" height="169"/>
<h6/>
</div></figure>
<p>When Room sees an <code>@Insert</code> annotation, it automatically generates all the code the app needs to insert a record into the table so that you don’t have to write it yourself. For the <code>insert()</code> method above, for example, it generates all the code needed to insert a <code>Task</code> object’s data into <code>task_table</code> like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0583-03.png" alt="image" width="600" height="103"/>
<h6/>
</div></figure>
<p>Any methods marked with <code>@Insert</code> can accept one or more entity objects for their arguments—objects whose type is marked with <code>@Entity</code>. <code>@Insert</code> methods can also accept collections of entity objects. The following method, for example, will insert all the tasks that are included in the <code>List&lt;Task&gt;</code> argument:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0583-04.png" alt="image" width="600" height="49"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Use @Update to update a record"><div class="sect2" id="use_commercial_atupdate_to_update_a_reco">
<h2>Use @Update to update a record</h2>
<p>Room can also generate all the code that’s needed to update one or more existing records in the table. This is done by adding a method to the DAO interface that’s marked with <code><strong>@Update</strong></code>. The following <code>update()</code> method, for example, generates all the code that’s needed to update an existing task record:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0583-05.png" alt="image" width="600" height="63"/>
<h6/>
</div></figure>
<p>When called, this method updates the record with a matching <code>taskId</code> so that its data matches the <code>Task</code> object’s property values.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Use @Delete to delete a record"><div class="sect1" id="use_commercial_atdelete_to_delete_a_reco">
<h1>Use @Delete to delete a record</h1>
<p><a data-type="indexterm" data-primary="Beighley, Lynn" id="idm46053735841680"/><a data-type="indexterm" data-primary="Beighley, Lynn" data-secondary="Head First SQL (O’Reilly)" id="idm46053735840352"/><a data-type="indexterm" data-primary="@Delete annotation, database access" id="idm46053735839280"/><a data-type="indexterm" data-primary="delete() method, database access" id="idm46053735838480"/><a data-type="indexterm" data-primary="Head First SQL (O’Reilly)" id="idm46053735837680"/><a data-type="indexterm" data-primary="@Query annotation, database access" id="idm46053735836880"/>There’s also a <code><strong>@Delete</strong></code> annotation that’s used to mark any methods that need to delete specific records from the table. To delete a single task record, for example, you could use a method defined like so:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0584-02.png" alt="image" width="600" height="65"/>
<h6/>
</div></figure>
<p>The code that Room generates for this method will delete the record with a matching <code>taskId</code>:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0584-03.png" alt="image" width="600" height="109"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Use @Query for everything else"><div class="sect2" id="use_commercial_atquery_for_everything_el">
<h2>Use @Query for everything else</h2>
<p>Any other data access methods are marked with <code>@Query</code>. This annotation lets you define a SQL statement (using <code>SELECT</code>, <code>INSERT</code>, <code>UPDATE</code>, or <code>DELETE</code>) that will be run when the method is called.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">We’re not going to teach you how to use SQL in this book, but if you want to learn more, we suggest reading Head First SQL by Lynn Beighley.</span></p>
</div>
<p>In the Tasks app, for example, we can use the following code to define a method named <code>get()</code> to return a live data <code>Task</code> for the record with a matching <code>taskId</code>:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0584-05.png" alt="image" width="600" height="35"/>
<h6/>
</div></figure>
<p>We can also define a <code>getAll()</code> method, which will return a live data <code>List</code> of all the records held in the table:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0584-06.png" alt="image" width="600" height="224"/>
<h6/>
</div></figure>
<p>As these methods return live data objects, the app can use them to be notified when the data changes. We’ll use this feature later in the chapter to keep the list of task records displayed in <code>TasksFragment</code> up-to-date.</p>
<p>You now know everything that’s needed to complete the code for <code>TaskDao</code>. We’ll show you the full code on the next page.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full code for TaskDao.kt"><div class="sect1" id="the_full_code_for_taskdaodotkt">
<h1>The full code for TaskDao.kt</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0585-01.png" alt="image" width="211" height="115"/>
<h6/>
</div></figure>
<p>Here’s the full code for the <code>TaskDao</code> interface; update the code for <em>TaskDao.kt</em> so that it includes the changes shown (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0585-02.png" alt="image" width="600" height="464"/>
<h6/>
</div></figure>
<p>We’ve now written the code for the <code>Task</code> data class (which defines a table) and the <code>TaskDao</code> interface (which specifies the data access methods). Next, we’ll learn how to define the actual database.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Create a TaskDatabase abstract class"><div class="sect1" id="create_a_taskdatabase_abstract_class">
<h1>Create a TaskDatabase abstract class</h1>
<p><a data-type="indexterm" data-primary="abstract class, for database" id="idm46053735806176"/><a data-type="indexterm" data-primary="@Database annotation, TaskDatabase class" id="idm46053735804256"/><a data-type="indexterm" data-primary="entities attribute, @Database annotation" id="idm46053735803392"/><a data-type="indexterm" data-primary="exportSchema attribute, @Database annotation" id="idm46053735802528"/><a data-type="indexterm" data-primary="RoomDatabase class" id="idm46053735801664"/><a data-type="indexterm" data-primary="SQLite database" data-secondary="TaskDatabase abstract class" id="idm46053735800832"/><a data-type="indexterm" data-primary="TaskDatabase abstract class" id="idm46053735799760"/><a data-type="indexterm" data-primary="version attribute, @Database annotation" id="idm46053735798960"/>You define the app’s database by creating an abstract class. The abstract class specifies the database name and version number, and any classes or interfaces that define the tables and data access methods.</p>
<p>In the Tasks app, we’re going to define the database using an abstract class named <code>TaskDatabase</code>. Highlight the <em>com.hfad.tasks</em> package in the <em>app/src/main/java</em> folder, then go to File→New→Kotlin Class/File. Name the file “TaskDatabase” and choose the Class option.</p>
<p>The <code>TaskDatabase</code> class needs to extend <code>RoomDatabase</code>, so update the code for <em>TaskDatabase.kt</em> so that it looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0586-02.png" alt="image" width="600" height="116"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Annotate the class with @Database"><div class="sect2" id="annotate_the_class_with_commercial_atdat">
<h2>Annotate the class with @Database</h2>
<p>Next, we need to mark the class with <code><strong>@Database</strong></code>, which tells Room that it defines a database. Here’s the code to do this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0586-03.png" alt="image" width="600" height="269"/>
<h6/>
</div></figure>
<p>As you can see, the <code><strong>@Database</strong></code> annotation includes three attributes: <code><strong>entities</strong></code>, <code><strong>version</strong></code>, and <code><strong>exportSchema</strong></code>.</p>
<p><code>entities</code> specifies any classes—marked with <code>@Entity</code>—that define the tables you want Room to add to the database. For the Tasks app, this is the <code>Task</code> data class.</p>
<p><code>version</code> is an <code>Int</code> that specifies the database version. In this case, it’s 1, as this is the first version of the database.</p>
<p>Finally, <code>exportSchema</code> tells Room whether to export the database schema into a folder so that you can record its version history. Here, we’re setting it to <em>false</em>.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="watch_itexclamation_mark-id00221">
<h5><span class="inlineimage"><img src="Images/watch.png" alt="Images" width="89" height="84"/></span> Watch it!</h5>
<p><strong>If you modify the database entity files, you need to update the version number.</strong></p>
<p>If you change the schema without updating the version number, the app will crash when you try to run it.</p>
</div></aside>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Add properties for any DAO interfaces"><div class="sect1" id="add_properties_for_any_dao_interfaces">
<h1>Add properties for any DAO interfaces</h1>
<p><a data-type="indexterm" data-primary="@Dao annotation, database access" id="idm46053735776128"/><a data-type="indexterm" data-primary="getInstance() method, database instance" id="idm46053735773872"/><a data-type="indexterm" data-primary="TaskDao interface" data-secondary="taskDao property" id="idm46053735773072"/><a data-type="indexterm" data-primary="taskDao property, TaskDatabase" id="idm46053735771968"/>Next, we need to specify any interfaces (marked with <code>@Dao</code>) that will be used for data access. This is done by adding a property for each interface.</p>
<p>In the Tasks app, for example, we’ve defined a single DAO interface named <code>TaskDao</code>, so we need to add a new <code>taskDao</code> property to the <code>TaskDatabase</code> code like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0587-02.png" alt="image" width="600" height="98"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Create and return an instance of the database"><div class="sect2" id="create_and_return_an_instance_of_the_dat">
<h2>Create and return an instance of the database</h2>
<p>The final thing we need is a <code>getInstance()</code> method that will create the database and return an instance of it. The code looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0587-03.png" alt="image" width="600" height="411"/>
<h6/>
</div></figure>
<p>That’s everything that we need for the <code>TaskDatabase</code> class. We’ll show you the full code on the next page.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full code for TaskDatabase.kt"><div class="sect1" id="the_full_code_for_taskdatabasedotkt">
<h1>The full code for TaskDatabase.kt</h1>
<p>Here’s the full code for the <code>TaskDatabase</code> abstract class; update the code for <em>TaskDatabase.kt</em> so that it includes the changes shown (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0588-02.png" alt="image" width="600" height="616"/>
<h6/>
</div></figure>
<p>We’ve now written all the database code needed by the Tasks app. Before we build the rest of the app, try the following exercise.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil-id00222">
<h5><span class="inlineimage"><img src="Images/pencil.png" alt="Images" width="149" height="65"/></span> Sharpen your pencil</h5>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Sharpen your pencil" id="idm46053735752960"/><a data-type="indexterm" data-primary="SQLite database" data-secondary="tables" id="idm46053735751760"/>A table named <code>recipe_table</code> needs to have the following columns:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0589-01.png" alt="image" width="600" height="126"/>
<h6/>
</div></figure>
<p>See if you can annotate the <code>Recipe</code> data class and <code>RecipeDao</code> interface below so that Room creates the specified table, along with methods to insert, update, and delete its data.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0589-02.png" alt="image" width="600" height="547"/>
<h6/>
</div></figure>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil_solution-id00223">
<h5><span class="inlineimage"><img src="Images/pencil.png" alt="Images" width="149" height="65"/></span> Sharpen your pencil Solution</h5>
<p>A table named <code>recipe_table</code> needs to have the following columns:</p>
<table class="border">
<tbody>
<tr>
<td><strong>recipeId</strong></td>
<td><strong>name</strong></td>
<td><strong>ingredients</strong></td>
<td><strong>method</strong></td>
</tr>
<tr>
<td> </td>
<td> </td>
<td> </td>
<td> </td>
</tr>
</tbody>
</table>
<p>See if you can annotate the <code>Recipe</code> data class and <code>RecipeDao</code> interface below so that Room creates the specified table, along with methods to insert, update, and delete its data.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0590-02.png" alt="image" width="600" height="570"/>
<h6/>
</div></figure>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="MVVM revisited"><div class="sect1" id="mvvm_revisited">
<h1>MVVM revisited</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0591-01.png" alt="image" width="212" height="115"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="Room persistence library" data-secondary="inserting records" id="idm46053735728592"/><a data-type="indexterm" data-primary="SQLite database" data-secondary="inserting records" id="idm46053735727152"/><a data-type="indexterm" data-primary="TaskDao interface" data-secondary="TasksViewModel" id="idm46053735726048"/><a data-type="indexterm" data-primary="Tasks app" data-secondary="inserting records" id="idm46053735724944"/><a data-type="indexterm" data-primary="TasksViewModel" id="idm46053735723840"/><a data-type="indexterm" data-primary="view models" data-secondary="TasksViewModel" id="idm46053735723008"/>Earlier in the chapter, we said we were going to structure the Tasks app using the MVVM (or Model-View-ViewModel) architecture pattern. Here’s a reminder of what this kind of structure looks like:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0591-02.png" alt="image" width="600" height="393"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="We’ve completed all the Model code…"><div class="sect2" id="weapostropheve_completed_all_the_model_c">
<h2>We’ve completed all the Model code…</h2>
<p>So far, we’ve written all the database code that the app needs by creating its entity, DAO, and database definition files (<code>Task</code>, <code>TaskDao</code>, and <code>TaskDatabase</code>). Writing all the database code means that we’ve now completed the Model part of the app’s architecture.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="…so let’s move on to the ViewModel"><div class="sect2" id="hellipso_letapostrophes_move_on_to_the_v">
<h2>…so let’s move on to the ViewModel</h2>
<p>The next thing we’ll work on is the ViewModel part. To do this, we’ll create a view model—named <code>TasksViewModel</code>—which will hold <code>TasksFragment</code>’s business logic. The view model will include methods that will use <code>TaskDao</code> to insert records into the database.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">We want to display a list of the tasks held in the database as well, but for now, we’re going to focus on inserting records.</span></p>
</div>
<p>Let’s go ahead and create <code>TasksViewModel</code>.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Create TasksViewModel"><div class="sect1" id="create_tasksviewmodel">
<h1>Create TasksViewModel</h1>
<p><a data-type="indexterm" data-primary="addTask() method" data-secondary="TasksFragment" id="idm46053735707936"/><a data-type="indexterm" data-primary="insert() method, tasks into database" id="idm46053735706880"/><a data-type="indexterm" data-primary="TasksFragment" data-secondary="TasksViewModel" id="idm46053735706080"/><a data-type="indexterm" data-primary="TasksViewModel" data-secondary="creating" id="idm46053735704976"/>To create <code>TasksViewModel</code>, highlight the <em>com.hfad.tasks</em> package in the <em>app/src/main/java</em> folder, then go to File→New→Kotlin Class/File. Name the file “TasksViewModel” and choose the Class option.</p>
<p>We’re going to update the view model code so that <code>TasksFragment</code> can use it to insert new task records. To do this, the code needs three things:</p>
<ol>
<li><p><strong>A reference to a TaskDao object</strong></p>
<p><code>TasksViewModel</code> will use this object to interact with the database, so we’ll pass it to the view model in its constructor.</p></li>
<li><p><strong>A String property that holds the name of the new task</strong></p>
<p>When the user enters a new task name, <code>TasksFragment</code> will update this property with its value.</p></li>
<li><p><strong>An addTask() method, which TasksFragment will call</strong></p>
<p>This method will create a new <code>Task</code> object, set its name, and insert it into the database by calling <code>TaskDao</code>’s <code>insert()</code> method.</p></li>
</ol>
<p>The basic view model code for these three things looks like this; update the code for <em>TasksViewModel.kt</em> so that it matches the code below:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0592-02.png" alt="image" width="600" height="275"/>
<h6/>
</div></figure>
<p>Before <code>TasksFragment</code> can call the <code>addTask()</code> method, however, there’s one more change we need to make.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Database operations can run in slooooow-moooo"><div class="sect1" id="database_operations_can_run_in_slooooow-">
<h1>Database operations can run in slooooow-moooo</h1>
<p><a data-type="indexterm" data-primary="coroutines, for data access in background" id="idm46053735688384"/><a data-type="indexterm" data-primary="live data" data-secondary="versus coroutines" id="idm46053735687232"/>Some tasks in Androidville, such as inserting records into a database, are potentially quite time-consuming. For this reason, the Room persistence library insists that <strong><em>any data access operations must be performed on a background thread</em></strong> so they don’t block Android’s main thread and hold up the UI.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">Technically, there’s a setting you can use to override this, but it’s way better to run tasks such as this on a background thread so they don’t hold up the rest of the app.</span></p>
</div>
<p>As we’re developing Android apps using Kotlin, we’re going to use <strong><em>coroutines</em></strong> to make sure all of <code>TaskDao</code>’s data access methods run in the background.</p>
<section data-type="sect2" data-pdf-bookmark="We’ll use coroutines to run data access code in the background"><div class="sect2" id="weapostrophell_use_coroutines_to_run_dat">
<h2>We’ll use <u>coroutines</u> to run data access code in the background</h2>
<p>As you may already know, a coroutine is like a lightweight thread that lets you run multiple pieces of code asynchronously. Using coroutines means that you can launch a background job—such as inserting records into a database—without the rest of the code having to wait around for it to complete. This gives your user a more fluid experience, so it’s not like trying to watch YouTube on Thanksgiving.</p>
<p>Changing your data access code to use coroutines is pretty straightforward. You simply have to make these two changes:</p>
<blockquote>
<p><strong>A coroutine is a piece of suspendable code that can be run in the background.</strong></p>
</blockquote>
<ol>
<li><p><strong>Mark each of the DAO’s data access methods with suspend.</strong></p>
<p>This turns each method into a coroutine that’s run in the background and can be suspended, for example:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0593-03.png" alt="image" width="511" height="71"/>
<h6/>
</div></figure></li>
<li><p><strong>Launch the DAO’s coroutines in the background.</strong></p>
<p>To call <code>TaskDao</code>’s <code>insert()</code> method from <code>TasksViewModel</code>, for example, you’d use the code:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0593-04.png" alt="image" width="435" height="121"/>
<h6/>
</div></figure></li>
</ol>
<p><strong><em>These changes are needed for all data access methods except for ones that return live data.</em></strong> Room already uses a background thread for methods that return live data objects, which means you don’t need to make any extra changes to your code.</p>
<p>Let’s update the code for <code>TaskDao</code> and <code>TasksViewModel</code> so they use coroutines.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="relax-id00224">
<h5><span class="inlineimage"><img src="Images/cup.png" alt="Images" width="124" height="107"/></span> Relax</h5>
<p><strong>Don’t worry if you don’t feel confident using coroutines.</strong></p>
<p>The information we’ve given here is everything you need to know to run data access methods in the background.</p>
</div></aside>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="1. Mark TaskDao’s methods with suspend"><div class="sect1" id="onedot_mark_taskdaoapostrophes_methods_w">
<h1>1. Mark TaskDao’s methods with suspend</h1>
<p><a data-type="indexterm" data-primary="suspend, marking TaskDao’s data access methods with" id="idm46053735661104"/><a data-type="indexterm" data-primary="TaskDao interface" data-secondary="code for" id="idm46053735660272"/>The first thing we need to do is mark all of <code>TaskDao</code>’s data access methods that don’t use live data with <code>suspend</code>. This means that we need to apply this change to all of its methods except for <code>get()</code> and <code>getAll()</code>.</p>
<p>Here’s the full code for <em>TaskDao.kt</em>; update the code so that it includes the changes shown here (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0594-02.png" alt="image" width="303" height="466"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0594-03.png" alt="image" width="600" height="650"/>
<h6/>
</div></figure>
<blockquote>
<p><strong>Marking methods with suspend turns each one into a suspendable coroutine.</strong></p>
</blockquote>
<p>That’s all the code that we need to turn <code>TaskDao</code>’s methods into coroutines that can run in the background.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="2. Launch the insert() method in the background"><div class="sect1" id="twodot_launch_the_insertleft_parenthesis">
<h1>2. Launch the insert() method in the background</h1>
<p><a data-type="indexterm" data-primary="addTask() method" id="idm46053735648512"/><a data-type="indexterm" data-primary="addTask() method" data-secondary="TaskDao" id="idm46053735647520"/><a data-type="indexterm" data-primary="TasksViewModel" data-secondary="launching TaskDao insert() as coroutine" id="idm46053735646384"/>We next need to update <code>TasksViewModel</code>’s <code>addTask()</code> method so that it launches <code>TaskDao</code>’s <code>insert()</code> method as a coroutine. The code to do this is shown below, so update <em>TasksViewModel.kt</em> to include the changes (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0595-02.png" alt="image" width="600" height="389"/>
<h6/>
</div></figure>
<p>This change means that each time the <code>addTask()</code> method gets called, it will use <code>TaskDao</code>’s <code>insert()</code> method (a coroutine) to insert records in the background.</p>
<p>We’ve now written all the code we need for the Task app’s view model. Next, we’ll add a <code>TasksViewModel</code> object to <code>TasksFragment</code> so that it can access the view model’s properties and methods, and let the user insert task records.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="brain_power-id00225">
<h5><span class="inlineimage"><img src="Images/brain.png" alt="Images" width="113" height="131"/></span> Brain Power</h5>
<p>Look at the code for <code>TasksViewModel</code>. What do you think we need to do next in order to add an instance of it to <code>TasksFragment</code>?</p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="TasksViewModel needs a view model factory"><div class="sect1" id="tasksviewmodel_needs_a_view_model_factor">
<h1>TasksViewModel needs a view model factory</h1>
<p><a data-type="indexterm" data-primary="TasksFragment" data-secondary="TasksViewModel" id="idm46053735632096"/><a data-type="indexterm" data-primary="TasksViewModel" data-secondary="creating" id="idm46053735630864"/><a data-type="indexterm" data-primary="TasksViewModelFactory class" id="idm46053735629696"/><a data-type="indexterm" data-primary="view model factory" id="idm46053735628896"/>As you learned in <a data-type="xref" href="ch11.xhtml#view_modelscolon_model_behavior">Chapter 11</a>, you add a view model to fragment code by asking the view model provider to provide one. The view model provider will return the fragment’s current view model object if one exists, or create a new one if it doesn’t.</p>
<p>If the view model includes a no-argument constructor, the view model provider can create an instance of it with no extra help. But if the constructor has arguments, it needs the assistance of a view model factory.</p>
<p>In the Tasks app, we need the view model provider to get a <code>TasksViewModel</code> object. Since <code>TasksViewModel</code>’s constructor requires a <code>TaskDao</code> argument, we must first define a <code>TasksViewModelFactory</code> class.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0596-02.png" alt="image" width="404" height="418"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Create TasksViewModelFactory"><div class="sect2" id="create_tasksviewmodelfactory">
<h2>Create TasksViewModelFactory</h2>
<p>To create the factory, highlight the <em>com.hfad.tasks</em> package in the <em>app/src/main/java</em> folder, then go to File→New→Kotlin Class/File. Name the file “TasksViewModelFactory” and choose the Class option.</p>
<p>The <code>TasksViewModelFactory</code> code is almost identical to the view model factory code you wrote in <a data-type="xref" href="ch11.xhtml#view_modelscolon_model_behavior">Chapter 11</a>, so update <em>TasksViewModelFactory.kt</em> so that it looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0596-03.png" alt="image" width="600" height="326"/>
<h6/>
</div></figure>
<p>Now that we’ve written the view model factory, let’s use it to add a <code>TasksViewModel</code> object to <code>TasksFragment</code>.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="TasksViewModelFactory needs a TaskDao"><div class="sect1" id="tasksviewmodelfactory_needs_a_taskdao">
<h1>TasksViewModelFactory needs a TaskDao</h1>
<p><a data-type="indexterm" data-primary="getInstance() method, database instance" id="idm46053735612672"/><a data-type="indexterm" data-primary="TaskDao interface" data-secondary="TasksViewModelFactory" id="idm46053735611392"/><a data-type="indexterm" data-primary="taskDao property, TaskDatabase" id="idm46053735610288"/>To add a <code>TasksViewModel</code> to <code>TasksFragment</code>, we need to create a <code>TasksViewModelFactory</code> object and pass it to the view model provider. The provider will then use the factory to create the view model.</p>
<p>But there’s a problem: <code>TasksViewModelFactory</code>’s constructor requires a <code>TaskDao</code> argument, so we need to get one of these before we can create the <code>TasksViewModelFactory</code> object. <code>TaskDao</code>, however, is an interface, not a concrete class, so how can we get a <code>TaskDao</code> object?</p>
<section data-type="sect2" data-pdf-bookmark="The TaskDatabase code has a TaskDao property"><div class="sect2" id="the_taskdatabase_code_has_a_taskdao_prop">
<h2>The TaskDatabase code has a TaskDao property</h2>
<p>When we wrote the code for <code>TaskDatabase</code>, we included two key things: a <code>TaskDao</code> property named <code>taskDao</code>, and a <code>getInstance()</code> method to return an instance of the database. Here’s a reminder of what that code looks like:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0597-02.png" alt="image" width="600" height="229"/>
<h6/>
</div></figure>
<p>To get a reference to a <code>TaskDao</code> object in the <code>TasksFragment</code> code, we can therefore call <code>TaskDatabase</code>’s <code>getInstance()</code> method, and access its <code>taskDao</code> property. The code to do so looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0597-03.png" alt="image" width="600" height="198"/>
<h6/>
</div></figure>
<p>The above code gets a reference to the current application, builds the database if it doesn’t already exist, and returns an instance of it. It then assigns its <code>TaskDao</code> object to a local variable named <code>dao</code>.</p>
<p>Now that we know how to get a reference to a <code>TaskDao</code> object, we can update the <code>TasksFragment</code> code to create a <code>TasksViewModelFactory</code> object, which we’ll use to get a <code>TasksViewModel</code>. Let’s see what the code looks like.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The updated code for TasksFragment.kt"><div class="sect1" id="the_updated_code_for_tasksfragmentdotkt">
<h1>The updated code for TasksFragment.kt</h1>
<p>The updated <code>TasksViewModel</code> code is shown below. As you can see, it now includes code to get a <code>TaskDao</code> object and create a <code>TasksViewModelFactory</code>. The code then passes the factory to the view model provider, which uses it to get an instance of <code>TasksViewModel</code>.</p>
<p>Update the code in <em>TasksFragment.kt</em> so that it includes these changes (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0598-02.png" alt="image" width="600" height="588"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="TasksFragment can use data binding"><div class="sect1" id="tasksfragment_can_use_data_binding">
<h1>TasksFragment can use data binding</h1>
<p><a data-type="indexterm" data-primary="data binding" data-secondary="TasksFragment" id="idm46053735587616"/><a data-type="indexterm" data-primary="data binding variable, setting" data-secondary="viewModel" id="idm46053735581136"/><a data-type="indexterm" data-primary="TasksFragment" data-secondary="data binding" id="idm46053735580064"/><a data-type="indexterm" data-primary="viewModel property" id="idm46053735578960"/>Now that we’ve added a <code>TasksViewModel</code> object to <code>TasksFragment</code>, we can make the fragment use its properties and methods to insert a record into the database. We’ll do this using data binding, which will give the layout direct access to the view model’s properties and methods.</p>
<p>To set up data binding, we first need to add a data binding variable to the fragment’s layout, so we’ll add the code shown here (in bold) to the <code>&lt;data&gt;</code> section of <em>fragment_tasks.xml</em>:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0599-02.png" alt="image" width="600" height="213"/>
<h6/>
</div></figure>
<p>We’ll then assign the fragment’s <code>viewModel</code> property to the data binding variable by adding the line shown below (in bold) to <code>TasksFragment</code>’s <code>onCreateView()</code> method:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0599-03.png" alt="image" width="600" height="311"/>
<h6/>
</div></figure>
<p>We’ll show you the full code for both files a few pages ahead. First, let’s update <em>fragment_tasks.xml</em> so that it uses its <code>viewModel</code> variable to insert records into the database.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="We’ll use data binding to insert a record"><div class="sect1" id="weapostrophell_use_data_binding_to_inser">
<h1>We’ll use data binding to insert a record</h1>
<p><a data-type="indexterm" data-primary="addTask() method" data-secondary="TasksViewModel" id="idm46053735565392"/><a data-type="indexterm" data-primary="newTaskName property, TasksViewModel" id="idm46053735564096"/><a data-type="indexterm" data-primary="TasksViewModel" data-secondary="inserting records" id="idm46053735563296"/>To insert a new task record into the database, we need to do two things: set <code>TasksViewModel</code>’s <code>newTaskName</code> property to the name of the new task, and call its <code>addTask()</code> method. We can do both of these in <code>TasksFragment</code>’s layout with data binding.</p>
<section data-type="sect2" data-pdf-bookmark="Set TasksViewModel’s newTaskName property"><div class="sect2" id="set_tasksviewmodelapostrophes_newtasknam">
<h2>Set TasksViewModel’s newTaskName property</h2>
<p>To set the view model’s <code>newTaskName</code> property, we’ll bind it to the <code>task_name</code> edit text in the fragment’s layout. The code to do so looks like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0600-02.png" alt="image" width="600" height="294"/>
<h6/>
</div></figure>
<p>Notice that we’re using <code><strong>@=</strong></code> to bind the property to the edit text instead of <code>@</code>. The <code>@=</code> means that the edit text can update the property it’s bound to: in this case <code>newTaskName</code>.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Call TasksViewModel’s addTask() method"><div class="sect2" id="call_tasksviewmodelapostrophes_addtaskle">
<h2>Call TasksViewModel’s addTask() method</h2>
<p>To insert the task, we’ll use data binding to make the layout’s Save Task button call the view model’s <code>addTask()</code> method when clicked. You’re already familiar with how to do this, so here’s the code:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0600-03.png" alt="image" width="600" height="177"/>
<h6/>
</div></figure>
<p>Those are all the code changes we need to make to <em>fragment_tasks.xml</em> for it to insert a record into the database. Let’s see what the full code looks like.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full fragment_tasks.xml code"><div class="sect1" id="the_full_fragmentunderscoretasksdotxml_c">
<h1>The full fragment_tasks.xml code</h1>
<p><a data-type="indexterm" data-primary="TasksFragment" data-secondary="code for" id="idm46053735548080"/>Here’s the full code for <code>TasksFragment</code>’s layout; make sure that the code in <em>fragment_tasks.xml</em> includes the changes shown (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0601-02.png" alt="image" width="600" height="718"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full TasksFragment.kt code"><div class="sect1" id="the_full_tasksfragmentdotkt_code">
<h1>The full TasksFragment.kt code</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0602-01.png" alt="image" width="211" height="115"/>
<h6/>
</div></figure>
<p>Before running the app, we also need to make sure that <code>TasksFragment</code> includes all the code that’s needed to set the layout’s data binding variable. Here’s the full code; update <em>TasksFragment.kt</em> (if you haven’t already done so) to include the changes below (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0602-02.png" alt="image" width="600" height="605"/>
<h6/>
</div></figure>
<p>Let’s go through what happens when the code runs.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="What happens when the code runs"><div class="sect1" id="what_happens_when_the_code_runs">
<h1>What happens when the code runs</h1>
<p>The following things happen when the app runs:</p>
<ol>
<li><p><strong>TasksFragment calls TaskDatabase.getInstance(), which builds the database if it doesn’t already exist.</strong></p>
<p>It names the database <code>tasks_database</code>, and uses the <code>Task</code> data class to create a table named <code>task_table</code>. It then returns an instance of the database.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0603-01.png" alt="image" width="600" height="85"/>
<h6/>
</div></figure></li>
<li><p><strong>TasksFragment gets the database instance’s TaskDao object, and uses it to create a TasksViewModelFactory.</strong></p>
<p>The view model provider uses the newly created <code>TasksViewModelFactory</code> object to create a <code>TasksViewModel</code>.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0603-02.png" alt="image" width="587" height="311"/>
<h6/>
</div></figure></li>
<li><p><strong>TasksFragment sets the layout’s viewModel data binding variable to the TasksViewModel object.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0603-03.png" alt="image" width="600" height="156"/>
<h6/>
</div></figure></li>
<li><p><strong>The user enters a task name in the layout’s edit text view.</strong></p>
<p>The layout uses data binding to set the view model’s <code>newTaskName</code> property to this value.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0604-02.png" alt="image" width="600" height="121"/>
<h6/>
</div></figure></li>
<li><p><strong>The user clicks on the Save Task button.</strong></p>
<p>This uses data binding to call the <code>TaskViewModel</code> object’s <code>addTask()</code> method.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0604-03.png" alt="image" width="600" height="121"/>
<h6/>
</div></figure></li>
<li><p><strong>The addTask() method creates a new Task object, and sets its taskName property to the value of newTaskName.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0604-04.png" alt="image" width="597" height="126"/>
<h6/>
</div></figure></li>
<li><p><strong>The addTask() method calls TaskDao’s insert() method.</strong></p>
<p>This inserts a record for the <code>Task</code> object’s data into the database table. The table autogenerates a value for the <code>taskId</code> primary key.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0604-05.png" alt="image" width="600" height="81"/>
<h6/>
</div></figure></li>
</ol>
<p>Let’s take the app for a test drive.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark=" Test Drive"><div class="sect1" id="test_drive-id00226">
<h1><span class="inlineimage"><img src="Images/car.png" alt="Images" width="119" height="58"/></span> Test Drive</h1>
<p>When we run the app, <code>TasksFragment</code> is displayed in <code>MainActivity</code>. When we try entering two new tasks, nothing seems to happen when we click on the Save Task button.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0605-02.png" alt="image" width="600" height="280"/>
<h6/>
</div></figure>
<p>Clicking on the button has added the new task records to the database, but we can’t yet see them. To see these records in the app, we need to make further changes.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00227">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: When I tried to enter a task, the app crashed. Any idea why?</strong></p>
<p><strong>A:</strong> This can happen if you update the database schema (the entities that the database contains) without updating the database version number. Room keeps track of the schema for each version of the database. If it spots any discrepancies, it adds an error message to the app’s logcat, and the app crashes.</p>
<p><strong>Q: I see. How do I fix this problem?</strong></p>
<p><strong>A:</strong> The simplest fix is to update the database version number in the file that defines the database (in this case <em>TaskDatabase.kt</em>).</p>
<p><strong>Q: How do I see the app’s logcat?</strong></p>
<p><strong>A:</strong> You should see an option for it in Android Studio. Any error messages get logged here, so it’s a good place to look if you encounter any errors.</p>
<p><strong>Q: Are there any tools I can use to inspect the database and see what records and tables it contains?</strong></p>
<p><strong>A:</strong> Android Studio includes a helpful Database Inspector you can use for this purpose. You can find out more here:</p>
<p><em><a href="https://developer.android.com/studio/inspect/database">https://developer.android.com/studio/inspect/database</a></em></p>
<p><strong>Q: What other database features can I use with Room?</strong></p>
<p><strong>A:</strong> You can define relationships between tables, create views, migrate data when you want to upgrade the database, and more. You can find more details of these features here:</p>
<p><em><a href="https://developer.android.com/training/data-storage/room">https://developer.android.com/training/data-storage/room</a></em></p>
<p><strong>Q: In your layout code, you used <code>"@="</code> to bind the edit text to the view model’s property instead of <code>"@"</code>. Why?</strong></p>
<p><strong>A:</strong> Because we wanted the edit text to update the property’s value, and not just read its value. Using <code>@=</code> instead of <code>@</code> enables this.</p>
</div></aside>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Who am I?" id="idm46053735485216"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) architecture" id="idm46053735483664"/>A bunch of components, in full costume, are playing a party game, “Who am I?” They’ll give you a clue—you try to guess who they are based on what they say. Assume they always tell the truth about themselves. Fill in the blanks to the right to identify the attendees. Also, for each attendee, write down whether the component is part of the Model, View, or ViewModel layer of the app’s architecture.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0606-01.png" alt="image" width="201" height="199"/>
<h6/>
</div></figure>
<p><strong>Tonight’s attendees:</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0606-02.png" alt="image" width="420" height="45"/>
<h6/>
</div></figure>
<table class="border">
<tbody>
<tr>
<td> </td>
<td><strong>Name</strong></td>
<td><strong>Model, View, or ViewModel?</strong></td>
</tr>
<tr>
<td>I take care of what the app’s screens look like.</td>
<td>______________</td>
<td>______________</td>
</tr>
<tr>
<td>I persist data after the app’s shut down.</td>
<td>______________</td>
<td>______________</td>
</tr>
<tr>
<td>I have a lifecycle, but I can’t exist on my own.</td>
<td>______________</td>
<td>______________</td>
</tr>
<tr>
<td>I’m used for business logic.</td>
<td>______________</td>
<td>______________</td>
</tr>
<tr>
<td>Room uses me to create a table.</td>
<td>______________</td>
<td>______________</td>
</tr>
<tr>
<td>I have a lifecycle, and I’m a type of context.</td>
<td>______________</td>
<td>______________</td>
</tr>
<tr>
<td>I help you interact with the data in the database.</td>
<td>______________</td>
<td>______________</td>
</tr>
</tbody>
</table>
<p><span class="inlineimage"><img src="Images/arr.png" alt="Images" width="101" height="9"/></span> <strong>Answers in <a data-type="xref" href="#mixed_messages_solution">“<span class="inlineimage"><img src="Images/common05.png" alt="Images" width="161" height="100"/></span> Mixed Messages Solution”</a>.</strong></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="TasksFragment needs to display records"><div class="sect1" id="tasksfragment_needs_to_display_records">
<h1>TasksFragment needs to display records</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0607-01.png" alt="image" width="212" height="115"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="getAll() method, TaskDao" id="idm46053735455680"/><a data-type="indexterm" data-primary="Room persistence library" data-secondary="getting records" id="idm46053735454608"/><a data-type="indexterm" data-primary="TaskDao interface" data-secondary="getAll() method" id="idm46053735453536"/><a data-type="indexterm" data-primary="Tasks app" data-secondary="getting records" id="idm46053735452432"/><a data-type="indexterm" data-primary="TasksFragment" data-secondary="displaying records" id="idm46053735451328"/>You’ve now learned how to build an app that inserts records into a Room database. The next thing we’ll do is update the app so that <code>TasksFragment</code> displays a list of all the records that have been inserted.</p>
<p>Here’s what the new version of <code>TasksFragment</code> will look like:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0607-02.png" alt="image" width="600" height="720"/>
<h6/>
</div></figure>
<p>To do this, we’ll use <code>TaskDao</code>’s <code>getAll()</code> method to get all of the task records from the database. We’ll then display them in <code>TasksFragment</code>’s text view by formatting them as a single <code>String</code>.</p>
<p>Let’s get started.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Use getAll() to get all tasks from the database"><div class="sect1" id="use_getallleft_parenthesisright_parenthe">
<h1>Use getAll() to get all tasks from the database</h1>
<p><a data-type="indexterm" data-primary="LiveData&lt;List&lt;Task&gt;&gt; object" id="idm46053735440976"/><a data-type="indexterm" data-primary="tasks property, TasksViewModel" id="idm46053735440048"/><a data-type="indexterm" data-primary="TasksViewModel" data-secondary="getting tasks" id="idm46053735439248"/>We’ll begin by adding a property named <code>tasks</code> to <code>TasksViewModel</code>, which will hold a list of all the tasks in the database. We’ll add the tasks to the property by setting it to <code>TaskDao</code>’s <code>getAll()</code> method like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0608-02.png" alt="image" width="600" height="182"/>
<h6/>
</div></figure>
<p>As you may remember, we defined the <code>getAll()</code> method in <em>TaskDao.kt</em> using the following code:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0608-04.png" alt="image" width="600" height="157"/>
<h6/>
</div></figure>
<p>As you can see, the method returns a <code>LiveData&lt;List&lt;Task&gt;&gt;</code> object: a live data list of <code>Task</code> objects. This means that <code>TasksViewModel</code>’s <code>tasks</code> property also has a type of <code>LiveData&lt;List&lt;Task&gt;&gt;</code>:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0608-05.png" alt="image" width="600" height="104"/>
<h6/>
</div></figure>
<p>As the <code>tasks</code> property uses live data, it always includes the user’s latest changes. If a new task is added to <code>task_table</code>, for example, the <code>tasks</code> property’s value is automatically updated to include the new record.</p>
<p>Using live data in this way is good news for the Tasks app because we can use it to display a list of tasks in <code>TasksFragment</code> that’s always up-to-date. Before we can do this, however, there’s one more thing we need to learn about.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="A LiveData&lt;List&lt;Task&gt;&gt; is a more complex type"><div class="sect1" id="a_livedataless_thanlistless_thantaskgrea">
<h1>A LiveData&lt;List&lt;Task&gt;&gt; is a more complex type</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0609-01.png" alt="image" width="212" height="115"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="formatTasks() method" id="idm46053735419632"/><a data-type="indexterm" data-primary="LiveData&lt;String&gt; version of tasks property" id="idm46053735418512"/><a data-type="indexterm" data-primary="tasksString property" id="idm46053735417712"/><a data-type="indexterm" data-primary="Transformations.map() method" id="idm46053735416880"/>When we introduced you to data binding, we showed you how to bind a view to a <code>String</code> or number, including live data values. We were able to do this because <code>String</code>s and numbers are simple objects that can easily be displayed in a text view.</p>
<p>This time, however, the situation is different. The <code>tasks</code> property’s type is <code>LiveData&lt;List&lt;Task&gt;&gt;</code>, which is much more complex than, say, <code>LiveData&lt;String&gt;</code>. Because of this, we can’t simply bind the layout’s text view to the <code>tasks</code> property directly because the text view wouldn’t know how to display it.</p>
<p>So what’s the solution?</p>
<figure class="informal"><div class="figure">
<img src="Images/f0609-02.png" alt="image" width="379" height="151"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Use Transformations.map() to transform live data objects"><div class="sect2" id="use_transformationsdotmapleft_parenthesi">
<h2>Use Transformations.map() to transform live data objects</h2>
<p>Before we can use data binding to display the user’s tasks, we first need to transform the <code>LiveData&lt;List&lt;Task&gt;&gt;</code> into something simpler that the text view knows how to display. To do this, we’ll create a new property named <code>tasksString</code>, which will hold a <code>LiveData&lt;String&gt;</code> version of the <code>tasks</code> property.</p>
<p>We’ll create the <code>LiveData&lt;String&gt;</code> using the <code><strong>Transformations.map()</strong></code> method. This method accepts a <code>LiveData</code> argument, and a lambda that specifies how the live data object should be transformed. It then returns a new <code>LiveData</code> object.</p>
<p>To transform the <code>tasks</code> property into a <code>LiveData&lt;String&gt;</code>, for example, we could use the code:</p>
<blockquote>
<p><strong>Transformations.map() observes a LiveData object and transforms it into another type of LiveData object.</strong></p>
</blockquote>
<pre data-type="programlisting"><strong>val tasksString = Transformations.map(tasks) {</strong>
    <strong>tasks -&gt; formatTasks(tasks)</strong>
<strong>}</strong></pre>
<p>where <code>formatTasks()</code> is a method (which we need to write) that formats the <code>tasks</code> property’s list of tasks as a <code>String</code>. The <code>Transformations.map()</code> method then wraps this <code>String</code> in a <code>LiveData</code> object, so that it returns a <code>LiveData&lt;String&gt;</code>.</p>
<p>The <code>Transformations.map()</code> method observes the <code>LiveData</code> object that’s passed to it, and executes the lambda each time it’s notified of changes. This means that in the above code, <code>tasksString</code> will <strong><em>automatically include any new task records the user enters</em></strong>.</p>
<p>Over the next few pages, we’re going to add the <code>tasksString</code> property to <code>TasksViewModel</code>, and then use data binding to display its value in <code>TasksFragment</code>’s layout. This approach means that we’ll be able to display all of the user’s tasks in a text view that always stays up-to-date.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0609-03.png" alt="image" width="437" height="405"/>
<h6/>
</div></figure>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Let’s update the TasksViewModel code"><div class="sect1" id="letapostrophes_update_the_tasksviewmodel">
<h1>Let’s update the TasksViewModel code</h1>
<p><a data-type="indexterm" data-primary="TasksViewModel" data-secondary="tasks and tasksString property additions" id="idm46053735388384"/>We’ll begin by updating the <code>TasksViewModel</code> code so that it includes the new <code>tasks</code> and <code>tasksString</code> properties. We’ll also add two methods—<code>formatTasks()</code> and <code>formatTask()</code>—to help us transform the <code>LiveData&lt;List&lt;Task&gt;&gt;</code> into a <code>LiveData&lt;String&gt;</code>.</p>
<p>Here’s the full code for <code>TasksViewModel</code>, so update <em>TasksViewModel.kt</em> so that it includes the changes below (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0610-02.png" alt="image" width="600" height="631"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="We’ll bind the tasksString property to the layout’s text view"><div class="sect1" id="weapostrophell_bind_the_tasksstring_prop">
<h1>We’ll bind the tasksString property to the layout’s text view</h1>
<p><a data-type="indexterm" data-primary="data binding" data-secondary="TasksFragment" id="idm46053735377728"/><a data-type="indexterm" data-primary="TasksFragment" data-secondary="tasksString property" id="idm46053735376336"/>Next, we’ll use data binding to bind the <code>tasks</code> text view in <code>TasksFragment</code>’s layout to the <code>tasksString</code> property in <code>TasksViewModel</code>. Here’s the code to do this; update <em>fragment_tasks.xml</em> to include this change (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0611-02.png" alt="image" width="600" height="678"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0612-02.png" alt="image" width="600" height="196"/>
<h6/>
</div></figure>
<p>That’s the only change we need to make to <em>fragment_tasks.xml</em> in order for it to display a <code>String</code> of the user’s tasks. Before we take the app for a test drive, however, there’s just one more tweak we need to make.</p>
<section data-type="sect2" data-pdf-bookmark="We need to make the layout respond to live data updates"><div class="sect2" id="we_need_to_make_the_layout_respond_to_li">
<h2>We need to make the layout respond to live data updates</h2>
<p>As you already know, the <code>tasksString</code> property is a <code>LiveData&lt;String&gt;</code>, which means that it automatically includes any updates that are made to the records held in the database. If the user inserts a new record, for example, its data gets added to <code>tasksString</code>’s value.</p>
<p>As we’re using data binding to display the value of the <code>tasksString</code> property in the <code>tasks</code> text view, we need to make sure that the layout gets notified whenever the <code>tasksString</code> property’s value gets updated. Doing so means that the text view will display any new records as soon as they’re inserted.</p>
<p>You’ve already learned how to make a layout respond to live data updates: by setting the layout’s lifecycle owner in the fragment code like this:</p>
<pre data-type="programlisting">binding.lifecycleOwner = viewLifecycleOwner</pre>
<p>We therefore need to update the code for <code>TasksFragment</code> so that it includes this line. We’ll show you the full code on the next page, and then go through what happens when the app runs.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00228">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: What other uses does the <code>Transformations.map()</code> method have?</strong></p>
<p><strong>A:</strong> As <code>Transformations.map()</code> gets reevaluated each time it receives new data, it’s also useful for things like calculations.</p>
<p>Suppose you have a live data <code>rate</code> property, and a calculation that uses it. You could, say, perform the calculation inside a call to <code>Transformations.map()</code> so that it’s automatically recalculated each time the <code>rate</code> property changes.</p>
<p><strong>Q: Do you always display lists as formatted <code>String</code>s?</strong></p>
<p><strong>A:</strong> No. We did so here because it’s a relatively simple way of displaying a bunch of records. You’ll learn about a better approach in the next chapter.</p>
</div></aside>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full TasksFragment.kt code"><div class="sect1" id="the_full_tasksfragmentdotkt_code-id00229">
<h1>The full TasksFragment.kt code</h1>
<p><a data-type="indexterm" data-primary="TasksFragment" data-secondary="code for" id="idm46053735352000"/>Here’s the full code for TasksFragment; update <em>TasksFragment.kt</em>: to include the extra line (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0613-02.png" alt="image" width="600" height="658"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="What happens when the code runs"><div class="sect1" id="what_happens_when_the_code_runs-id00230">
<h1>What happens when the code runs</h1>
<p>The following things happen when the app runs:</p>
<ol>
<li><p><strong>TasksFragment creates a TasksViewModelFactory object, which the view model provider uses to create a TasksViewModel.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0614-02.png" alt="image" width="578" height="315"/>
<h6/>
</div></figure></li>
<li><p><strong>The TasksViewModel’s tasks property is set to TaskDao’s getAll() method, which returns a LiveData&lt;List&lt;Task&gt;&gt;.</strong></p>
<p>It holds a live data list of all the task records from the database.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0614-03.png" alt="image" width="600" height="119"/>
<h6/>
</div></figure></li>
<li><p><strong>TasksViewModel’s tasksString property uses the Transformations.map() method to transform the tasks property’s value into a LiveData&lt;String&gt;.</strong></p>
<p>It returns the <code>tasks</code> property’s records formatted as a single <code>String</code>.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0614-04.png" alt="image" width="600" height="112"/>
<h6/>
</div></figure></li>
<li><p><strong>The layout’s text view uses data binding to display tasksString’s value.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0615-01.png" alt="image" width="600" height="145"/>
<h6/>
</div></figure></li>
<li><p><strong>The user enters a new task record into the database.</strong></p>
<p>The <code>TasksViewModel</code>’s <code>tasks</code> property is automatically updated (using live data) to include the new record.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0615-02.png" alt="image" width="600" height="180"/>
<h6/>
</div></figure></li>
<li><p><strong>The tasksString property responds to the tasks property’s update.</strong></p>
<p>As it uses live data, it automatically includes the new record in its <code>String</code>.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0615-03.png" alt="image" width="600" height="117"/>
<h6/>
</div></figure></li>
<li><p><strong>The layout responds to the tasksString property’s update.</strong></p>
<p>The record the user just entered is included in the text view.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0615-04.png" alt="image" width="600" height="167"/>
<h6/>
</div></figure></li>
</ol>
</div></section>
<section data-type="sect1" data-pdf-bookmark=" Test Drive"><div class="sect1" id="test_drive-id00231">
<h1><span class="inlineimage"><img src="Images/car.png" alt="Images" width="119" height="58"/></span> Test Drive</h1>
<p>When we run the app, <code>TasksFragment</code> is displayed as before, but this time, it shows us the tasks we entered earlier.</p>
<p>When we enter a new task, it gets added to the list of tasks as soon as we click on the Save Task button.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0616-02.png" alt="image" width="600" height="541"/>
<h6/>
</div></figure>
<p>Congratulations! You’ve now learned how to build an app that uses the MVVM pattern to interact with a Room database. The user’s records get saved to the database so that they persist when the app gets closed, and the app displays any new records as soon as they’re inserted.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark=" Mixed Messages"><div class="sect1" id="mixed_messages">
<h1><span class="inlineimage"><img src="Images/common05.png" alt="Images" width="161" height="100"/></span> Mixed Messages</h1>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Mixed Messages" id="idm46053735313648"/>Some view model code is listed below, but the <code>refresh()</code> method’s code is missing. Your challenge is to match each candidate block of code (on the left) with the <code>result</code> property’s final value if the candidate code were added to the <code>refresh()</code> method, and the method was called once. Not all the values will be used, and some values may be used more than once.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0617-01.png" alt="image" width="600" height="363"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0617-02.png" alt="image" width="600" height="382"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark=" Mixed Messages Solution"><div class="sect1" id="mixed_messages_solution">
<h1><span class="inlineimage"><img src="Images/common05.png" alt="Images" width="161" height="100"/></span> Mixed Messages Solution</h1>
<p>Some view model code is listed below, but the <code>refresh()</code> method’s code is missing. Your challenge is to match each candidate block of code (on the left), with the <code>result</code> property’s final value if the candidate code were added to the <code>refresh()</code> method, and the method was called once. Not all the values will be used, and some values may be used more than once.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0618-01.png" alt="image" width="600" height="363"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0618-02.png" alt="image" width="600" height="312"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Who am I?" id="idm46053735296944"/><a data-type="indexterm" data-primary="MVVM (Model-View-ViewModel) architecture" id="idm46053735295664"/>A bunch of components, in full costume, are playing a party game, “Who am I?” They’ll give you a clue—you try to guess who they are based on what they say. Assume they always tell the truth about themselves. Fill in the blanks to the right to identify the attendees. Also, for each attendee, write down whether the component is part of the Model, View, or ViewModel layer of the app’s architecture.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0619-01.png" alt="image" width="201" height="199"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0619-02.png" alt="image" width="600" height="541"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Your Android Toolbox"><div class="sect1" id="your_android_toolbox-id00232">
<h1>Your Android Toolbox</h1>
<figure class="informal"><div class="figure">
<img src="Images/tools.png" alt="image" width="182" height="129"/>
<h6/>
</div></figure>
<p><strong>You’ve got <a data-type="xref" href="#room_databasescolon_room_with_a_view">Chapter 14</a> under your belt and now you’ve added the Room persistence library to your toolbox.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0620-01.png" alt="image" width="234" height="211"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-id00233">
<h5>Bullet Points</h5>
<ul>
<li><p>Room is a persistence library that sits on top of SQLite.</p></li>
<li><p>Room apps are usually structured using the MVVM architectural design pattern. MVVM stands for Model-View-ViewModel.</p></li>
<li><p>Define any database tables using an annotated data class. Use <code>@Entity</code> to tell Room to use the class to create a table. Use <code>@PrimaryKey</code> to define the primary key column. Use <code>@ColumnInfo</code> to specify column names.</p></li>
<li><p>Define any data access methods in an annotated interface. Use <code>@Dao</code> to tell Room to use its methods for data access. Use <code>@Insert</code>, <code>@Update</code>, <code>@Delete</code>, and <code>@Query</code> to define the required data access.</p></li>
<li><p>Define the database in an abstract class marked with <code>@Database</code>.</p></li>
<li><p>If you update the database schema, you need to increment the database version number.</p></li>
<li><p>Data access code needs to be run in the background. You can do this by turning any data access methods that don’t return live data into coroutines.</p></li>
<li><p>You can use the method <code>Transformations.map()</code> to transform live data objects. The method observes a live data object, executes a lambda when the object’s value changes, and returns another live data object.</p></li>
</ul>
</div></aside>
</div></section>
</div></section></div></body></html>