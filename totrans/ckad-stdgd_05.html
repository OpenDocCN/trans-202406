<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Pods and Namespaces" class="praise"><div class="dedication" id="pods_namespaces">
<h1 class="calibre14"><span class="keep-together">Chapter 5. </span>Pods and Namespaces</h1>


<p class="author1">The most important primitive in the Kubernetes API is the Pod. A Pod lets you run a containerized application. In practice, you’ll often encounter a one-to-one mapping between a Pod and a container; however, the use cases discussed in <a data-type="xref" href="ch08.xhtml#multi_container_pods" class="calibre10">Chapter 8</a> benefit from declaring more than one container in a single Pod.</p>

<p class="author1">In addition to running a container, a Pod can consume other services like storage, configuration data, and much more. Therefore, think of a Pod as a wrapper for running containers while at the same time being able to mix in cross-cutting and specialized Kubernetes features.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id472">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">The curriculum doesn’t explicitly mention coverage of Pods and namespaces. However, you will definitely need to understand those primitives as they are essential for running workload in Kubernetes.</p>
</div></aside>






<section data-type="sect1" data-pdf-bookmark="Working with Pods" class="praise"><div class="dedication" id="working_with_pods">
<h1 class="calibre17">Working with Pods</h1>

<p class="author1">In this chapter, we will look at working with a Pod running only a single container. We’ll discuss all important <code class="calibre15">kubectl</code> commands for creating, modifying, interacting, and deleting using imperative and declarative approaches.</p>








<section data-type="sect2" data-pdf-bookmark="Creating Pods" class="praise"><div class="dedication" id="id175">
<h2 class="calibre33">Creating Pods</h2>

<p class="author1">The Pod definition needs to state an image for every container. Upon creating the Pod object, imperatively or declaratively, the scheduler will assign the Pod to a node, and the container runtime engine will check if the container image already exists on that node. If the image doesn’t exist yet, the engine will download it from a container image registry. By default the registry is Docker Hub. As soon as the image exists on the node, the container is instantiated and will run. <a data-type="xref" href="Images/#kubelet_container_images" class="calibre10">Figure 5-1</a> demonstrates the execution flow.</p>

<figure class="calibre35"><div id="kubelet_container_images" class="figure">
<img src="Images/ckd2_0501.png" alt="ckd2 0501" class="calibre57"/>
<h6 class="calibre32"><span class="keep-together">Figure 5-1. </span>Container Runtime Interface interaction with container images</h6>
</div></figure>

<p class="author1">The <code class="calibre15">run</code> command is the central entry point for creating Pods imperatively. Let’s talk about its usage and the most important command line options you should memorize and practice. Say you wanted to run a <a href="https://hazelcast.com" class="calibre10">Hazelcast instance</a> inside of a Pod. The container should use the latest <a href="https://oreil.ly/ChxPI" class="calibre10">Hazelcast image</a>, expose port 5701, and define an environment variable. In addition, we’ll also want to assign two labels to the Pod. The following imperative command combines this information and does not require any further editing of the live object:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run hazelcast --image=hazelcast/hazelcast:5.1.7 \
  --port=5701 --env="DNS_DOMAIN=cluster" --labels="app=hazelcast,env=prod"</strong>
</pre>

<p class="author1">The <code class="calibre15">run</code> command offers a wealth of command line options. Execute the <code class="calibre15">kubectl run --help</code> or refer to the Kubernetes documentation for a broad overview. For the exam, you’ll not need to understand every command. <a data-type="xref" href="#important_kubectl_run_command_line_options" class="calibre10">Table 5-1</a> lists the most commonly used options.</p>
<table id="important_kubectl_run_command_line_options" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 5-1. </span>Important <code class="calibre60">kubectl</code> run command line options</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Option</th>
<th class="calibre63">Example value</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">--image</code></p></td>
<td class="calibre65"><p class="author1">nginx:1.25.1</p></td>
<td class="calibre65"><p class="author1">The image for the container to run.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">--port</code></p></td>
<td class="calibre65"><p class="author1">8080</p></td>
<td class="calibre65"><p class="author1">The port that this container exposes.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">--rm</code></p></td>
<td class="calibre65"><p class="author1">N/A</p></td>
<td class="calibre65"><p class="author1">Deletes the Pod after command in the container finishes. See <a data-type="xref" href="#temporary_pod" class="calibre10">“Creating a Temporary Pod”</a> for more information.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">--env</code></p></td>
<td class="calibre65"><p class="author1">PROFILE=dev</p></td>
<td class="calibre65"><p class="author1">The environment variables to set in the container.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">--labels</code></p></td>
<td class="calibre65"><p class="author1">app=frontend</p></td>
<td class="calibre65"><p class="author1">A comma-separated list of labels to apply to the Pod. <a data-type="xref" href="ch09.xhtml#labels_annotations" class="calibre10">Chapter 9</a> explains labels in more detail.</p></td>
</tr>
</tbody>
</table>

<p class="author1">Some developers are more used to creating Pods from a YAML manifest. Probably you’re already accustomed to the declarative approach because you’re using it at work. You can express the same configuration for the Hazelcast Pod by opening the editor, copying a Pod YAML code snippet from the Kubernetes online documentation, and modifying it to your needs. <a data-type="xref" href="#pod_yaml_manifest" class="calibre10">Example 5-1</a> shows the Pod manifest saved in the file <code class="calibre15">pod.yaml</code>:</p>
<div id="pod_yaml_manifest" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 5-1. </span>Pod YAML manifest</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">hazelcast</code><code class="w">                      </code><a class="calibre10" id="co_pods_and_namespaces_CO1-1" href="#callout_pods_and_namespaces_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w">                              </code><a class="calibre10" id="co_pods_and_namespaces_CO1-2" href="#callout_pods_and_namespaces_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="calibre15">hazelcast</code><code class="w">
</code><code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"> </code><code class="calibre15">prod</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">hazelcast</code><code class="w">
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">hazelcast/hazelcast:5.1.7</code><code class="w">   </code><a class="calibre10" id="co_pods_and_namespaces_CO1-3" href="#callout_pods_and_namespaces_CO1-3"><img src="Images/3.png" alt="3" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w">                               </code><a class="calibre10" id="co_pods_and_namespaces_CO1-4" href="#callout_pods_and_namespaces_CO1-4"><img src="Images/4.png" alt="4" class="calibre51"/></a><code class="w">
</code><code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">DNS_DOMAIN</code><code class="w">
</code><code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="calibre15">cluster</code><code class="w">
</code><code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">5701</code><code class="w">              </code><a class="calibre10" id="co_pods_and_namespaces_CO1-5" href="#callout_pods_and_namespaces_CO1-5"><img src="Images/5.png" alt="5" class="calibre51"/></a></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_pods_and_namespaces_CO1-1" href="#co_pods_and_namespaces_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Assigns the name of <code class="calibre15">hazelcast</code> to the Pod.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_pods_and_namespaces_CO1-2" href="#co_pods_and_namespaces_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Specifies labels to the Pod.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_pods_and_namespaces_CO1-3" href="#co_pods_and_namespaces_CO1-3"><img src="Images/3.png" alt="3" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Declares the container image to be executed in the container of the Pod.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_pods_and_namespaces_CO1-4" href="#co_pods_and_namespaces_CO1-4"><img src="Images/4.png" alt="4" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Injects one or many environment variables to the container.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_pods_and_namespaces_CO1-5" href="#co_pods_and_namespaces_CO1-5"><img src="Images/5.png" alt="5" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Number of port to expose on the Pod’s IP address.</p></dd>
</dl>

<p class="author1">Creating the Pod from the manifest is straightforward. Simply use the <code class="calibre15">create</code> or <code class="calibre15">apply</code> command, as shown here and explained in <a data-type="xref" href="ch03.xhtml#managing_objects" class="calibre10">“Managing Objects”</a>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f pod.yaml</strong>
pod/hazelcast created
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Listing Pods" class="praise"><div class="dedication" id="id176">
<h2 class="calibre33">Listing Pods</h2>

<p class="author1">Now that you have created a Pod, you can further inspect its runtime information. The <code class="calibre15">kubectl</code> command offers a command for listing all Pods running in the cluster: <code class="calibre15">get pods</code>. The following command renders the Pod named <code class="calibre15">hazelcast</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pods</strong>
NAME        READY   STATUS    RESTARTS   AGE
hazelcast   1/1     Running   0          17s
</pre>

<p class="author1">Real-world Kubernetes clusters can run hundreds of Pods at the same time. If you know the name of the Pod of interest, it’s often easier to query by name. You would still see only a single Pod:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pods hazelcast</strong>
NAME        READY   STATUS    RESTARTS   AGE
hazelcast   1/1     Running   0          17s
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Pod Life Cycle Phases" class="praise"><div class="dedication" id="id177">
<h2 class="calibre33">Pod Life Cycle Phases</h2>

<p class="author1">Because Kubernetes is a state engine with asynchronous control loops, it’s possible that the status of the Pod doesn’t show a <code class="calibre15">Running</code> status right away when listing the Pods. It usually takes a couple of seconds to retrieve the image and start the container. Upon Pod creation, the object goes through several <a href="https://oreil.ly/Qk5Ob" class="calibre10">life cycle phases</a>, as shown in <a data-type="xref" href="#pod_lifecycle_phases" class="calibre10">Figure 5-2</a>.</p>

<figure class="calibre35"><div id="pod_lifecycle_phases" class="figure">
<img src="Images/ckd2_0502.png" alt="ckd2 0502" class="calibre67"/>
<h6 class="calibre32"><span class="keep-together">Figure 5-2. </span>Pod life cycle phases</h6>
</div></figure>

<p class="author1">Understanding the implications of each phase is important as it gives you an idea about the operational status of a Pod. For example, during the exam you may be asked to identify a Pod with an issue and further debug the object. <a data-type="xref" href="#pod_lifecycle_phases_table" class="calibre10">Table 5-2</a> describes all Pod life cycle phases.</p>
<table id="pod_lifecycle_phases_table" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 5-2. </span>Pod life cycle phases</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Option</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">Pending</code></p></td>
<td class="calibre65"><p class="author1">The Pod has been accepted by the Kubernetes system, but one or more of the container images has not been created.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">Running</code></p></td>
<td class="calibre65"><p class="author1">At least one container is still running or is in the process of starting or restarting.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">Succeeded</code></p></td>
<td class="calibre65"><p class="author1">All containers in the Pod terminated successfully.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">Failed</code></p></td>
<td class="calibre65"><p class="author1">Containers in the Pod terminated,; at least one failed with an error.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">Unknown</code></p></td>
<td class="calibre65"><p class="author1">The state of Pod could not be obtained.</p></td>
</tr>
</tbody>
</table>

<p class="author1">The Pod life cycle phases should not be confused with container states within a Pod. Containers can have one of the three possible states: <code class="calibre15">Waiting</code>, <code class="calibre15">Running</code>, and <code class="calibre15">Terminated</code>. You can read more about container states in the <a href="https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#container-states" class="calibre10">Kubernetes documentation</a>.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Rendering Pod Details" class="praise"><div class="dedication" id="id178">
<h2 class="calibre33">Rendering Pod Details</h2>

<p class="author1">The rendered table produced by the <code class="calibre15">get</code> command provides high-level information about a Pod. But what if you needed a deeper look at the details? The <code class="calibre15">describe</code> command can help:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl describe pods hazelcast</strong>
Name:               hazelcast
Namespace:          default
Priority:           0
PriorityClassName:  &lt;none&gt;
Node:               docker-desktop/192.168.65.3
Start Time:         Wed, 20 May 2020 19:35:47 -0600
Labels:             app=hazelcast
                    env=prod
Annotations:        &lt;none&gt;
Status:             Running
IP:                 10.1.0.41
Containers:
  ...
Events:
  ...
</pre>

<p class="author1">The terminal output contains the metadata information of a Pod, the containers it runs, and the event log, such as failures when the Pod was scheduled. The example output has been condensed to show just the metadata section. You can expect the output to be very lengthy.</p>

<p class="author1">There’s a way to be more specific about the information you want to render. You can combine the <code class="calibre15">describe</code> command with a Unix <code class="calibre15">grep</code> command if you want to identify the image for running in the container:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl describe pods hazelcast | grep Image:</strong>
    Image:          hazelcast/hazelcast:5.1.7
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Accessing Logs of a Pod" class="praise"><div class="dedication" id="id2">
<h2 class="calibre33">Accessing Logs of a Pod</h2>

<p class="author1">As application developers, we know very well what to expect in the log files produced by the application we implemented. Runtime failures may occur when operating 
<span class="keep-together">an application</span> in a container. The <code class="calibre15">logs</code> command downloads the log output of a 
<span class="keep-together">container.</span> The following output indicates that the Hazelcast server started up 
<span class="keep-together">successfully:</span></p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl logs hazelcast</strong>
...
May 25, 2020 3:36:26 PM com.hazelcast.core.LifecycleService
INFO: [10.1.0.46]:5701 [dev] [4.0.1] [10.1.0.46]:5701 is STARTED
</pre>

<p class="author1">It’s<a data-type="indexterm" data-primary="-f option" data-primary-sortas="f option" id="id473" class="calibre10"></a> very likely that more log entries will be produced as soon as the container receives traffic from end users. You can stream the logs with the command line option <code class="calibre15">-f</code>. This option is helpful if you want to see logs in real time.</p>

<p class="author1">Kubernetes tries to restart a container under certain conditions, such as if the image cannot be resolved on the first try. Upon a container restart, you won’t have access to the logs of the previous container; the <code class="calibre15">logs</code> command renders the logs only for the current container. However, you can still get back to the logs of the previous container by adding the <code class="calibre15">-p</code> command line option. You may want to use the option to identify the root cause that triggered a container restart.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Executing a Command in Container" class="praise"><div class="dedication" id="id179">
<h2 class="calibre33">Executing a Command in Container</h2>

<p class="author1">Some situations require you to get the shell to a running container and explore the filesystem. Maybe you want to inspect the configuration of your application or debug its current state. You can use the <code class="calibre15">exec</code> command to open a shell in the container to explore it interactively, as follows:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl exec -it hazelcast -- /bin/sh</strong>
# ...
</pre>

<p class="author1">Notice that you do not have to provide the resource type. This command only works for a Pod. The two dashes (<code class="calibre15">--</code>) separate the <code class="calibre15">exec</code> command and its options from the command you want to run inside of the container.</p>

<p class="author1">It’s also possible to execute a single command inside of a container. Say you wanted to render the environment variables available to containers without having to be logged in. Just remove the interactive flag <code class="calibre15">-it</code> and provide the relevant command after the two dashes:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl exec hazelcast -- env</strong>
...
DNS_DOMAIN=cluster
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating a Temporary Pod" class="praise"><div class="dedication" id="temporary_pod">
<h2 class="calibre33">Creating a Temporary Pod</h2>

<p class="author1">The command executed inside of a Pod—usually an application implementing business logic—is meant to run infinitely. Once the Pod has been created, it will stick around. Under certain conditions, you want to execute a command in a Pod just for troubleshooting. This use case doesn’t require a Pod object to run beyond the execution of the command. That’s where temporary Pods come into play.</p>

<p class="author1">The <code class="calibre15">run</code> command provides the flag <code class="calibre15">--rm</code>, which will automatically delete the Pod after the command running inside of it finishes. Say you want to render all environment variables using <code class="calibre15">env</code> to see what’s available inside of the container. The following command achieves exactly that:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run busybox --image=busybox:1.36.1 --rm -it --restart=Never -- env</strong>
...
HOSTNAME=busybox
pod "busybox" deleted
</pre>

<p class="author1">The last message rendered in the output clearly states that the Pod was deleted after command execution.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Using a Pod’s IP Address for Network Communication" class="praise"><div class="dedication" id="pod_network_communication">
<h2 class="calibre33">Using a Pod’s IP Address for Network Communication</h2>

<p class="author1">Every Pod is assigned an IP address upon creation. You can inspect a Pod’s IP address by using the <code class="calibre15">-o wide</code> command-line option for the <code class="calibre15">get pod</code> command or by describing the Pod. The IP address of the Pod in the following console output is <code class="calibre15">10.244.0.5</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run nginx --image=nginx:1.25.1 --port=80</strong>
pod/nginx created
<strong class="calibre38">$ kubectl get pod nginx -o wide</strong>
NAME    READY   STATUS    RESTARTS   AGE   IP           NODE       \
NOMINATED NODE   READINESS GATES
nginx   1/1     Running   0          37s   10.244.0.5   minikube   \
&lt;none&gt;           &lt;none&gt;
<strong class="calibre38">$ kubectl get pod nginx -o yaml</strong>
...
status:
  podIP: 10.244.0.5
...
</pre>

<p class="author1">The IP address assigned to a Pod is unique across all nodes and namespaces. This is achieved by assigning a dedicated subnet to each node when registering it. When creating a new Pod on a node, the IP address is leased from the assigned subnet. This is handled by the networking life cycle manager kube-proxy along with the Domain Name Service (DNS) and the Container Network Interface (CNI).</p>

<p class="author1">You can easily verify the behavior by creating a temporary Pod that calls the IP address of another Pod using the command-line tool <code class="calibre15">curl</code> or <code class="calibre15">wget</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run busybox --image=busybox:1.36.1 --rm -it --restart=Never \
  -- wget 172.17.0.4:80</strong>
Connecting to 172.17.0.4:80 (172.17.0.4:80)
saving to 'index.html'
index.html           100% |********************************|   615  0:00:00 ETA
'index.html' saved
pod "busybox" deleted
</pre>

<p class="author1">It’s important to understand that the IP address is not considered stable over time. A Pod restart leases a new IP address. Therefore, this IP address is often referred to as <em class="calibre3">virtual</em> IP address. Building a microservices architecture—where each of the applications runs in its own Pod with the need to communicate between each other with a stable network interface—requires a different concept: the Service. Refer to <a data-type="xref" href="ch21.xhtml#services" class="calibre10">Chapter 21</a> for more information.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Configuring Pods" class="praise"><div class="dedication" id="configuring_pods">
<h2 class="calibre33">Configuring Pods</h2>

<p class="author1">The curriculum expects you to feel comfortable with editing YAML manifests either as files or as live object representations. This section shows you some typical configuration scenarios you may face during the exam. Later chapters will deepen your knowledge by touching on other configuration aspects.</p>










<section data-type="sect3" data-pdf-bookmark="Declaring environment variables" class="praise"><div class="dedication" id="id183">
<h3 class="calibre44">Declaring environment variables</h3>

<p class="author1">Applications need to expose a way to make their runtime behavior configurable. For example, you may want to inject the URL to an external web service or declare the username for a database connection. Environment variables are a common option to provide this runtime configuration.</p>
<div data-type="warning" epub:type="warning" class="calibre28"><h1 class="calibre68">Avoid creating container images per environment</h1>
<p class="author1">It might be tempting to say, “Hey, let’s create a container image for any target deployment environment we need, including its configuration.” That’s a bad idea. One of the practices of <a href="https://oreil.ly/w4_2g" class="calibre10">continuous delivery</a> and the <a href="https://12factor.net" class="calibre10">Twelve-Factor App principles</a> is to build a deployable artifact for a commit just once. In this case, the artifact is the container image. Deviating configuration runtime behavior should be controllable by injecting runtime information when instantiating the container. You can use environment variables to control the behavior as needed.</p>
</div>

<p class="author1">Defining environment variables in a Pod YAML manifest is relatively easy. Add or enhance the section <code class="calibre15">env</code> of a container. Every environment variable consists of a key-value pair, represented by the attributes <code class="calibre15">name</code> and <code class="calibre15">value</code>. Kubernetes does not enforce or sanitize typical naming conventions for environment variable keys, though it is recommended to follow the standard of using upper-case letters and the underscore character (<code class="calibre15">_</code>) to separate words.</p>

<p class="author1">To illustrate a set of environment variables, look at <a data-type="xref" href="#yaml_manifest_for_a_pod_defining_environment_variables" class="calibre10">Example 5-2</a>. The code snippet describes a Pod that runs a Java-based application using the Spring Boot framework.</p>
<div id="yaml_manifest_for_a_pod_defining_environment_variables" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 5-2. </span>YAML manifest for a Pod defining environment variables</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">spring-boot-app</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">spring-boot-app</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/spring-boot-app:1.5.3</code><code class="w"></code>
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">SPRING_PROFILES_ACTIVE</code><code class="w"></code>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="calibre15">prod</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">VERSION</code><code class="w"></code>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">'1.5.3'</code><code class="w"></code></pre></div>

<p class="author1">The first environment variable named <code class="calibre15">SPRING_PROFILES_ACTIVE</code> defines a pointer to a so-called profile. A profile contains environment-specific properties. Here, we are pointing to the profile that configures the production environment. The environment variable <code class="calibre15">VERSION</code> specifies the application version. Its value corresponds to the tag of the image and can be exposed by the running application to display the value in the user interface.</p>
</div></section>










<section data-type="sect3" data-pdf-bookmark="Defining a command with arguments" class="praise"><div class="dedication" id="id184">
<h3 class="calibre44">Defining a command with arguments</h3>

<p class="author1">Many container images already define an <code class="calibre15">ENTRYPOINT</code> or <code class="calibre15">CMD</code> instruction. The command assigned to the instruction is automatically executed as part of the container startup. For example, the Hazelcast image we used earlier defines the instruction <code class="calibre15">CMD ["/opt/hazelcast/start-hazelcast.sh"]</code>.</p>

<p class="author1">In a Pod definition, you can either redefine the image <code class="calibre15">ENTRYPOINT</code> and <code class="calibre15">CMD</code> instructions or assign a command to execute for the container if it hasn’t been specified by the image. You can provide this information with the help of the <code class="calibre15">command</code> and <code class="calibre15">args</code> attributes for a container. The <code class="calibre15">command</code> attribute overrides the image’s <code class="calibre15">ENTRYPOINT</code> instruction. The <code class="calibre15">args</code> attribute replaces the <code class="calibre15">CMD</code> instruction of an image.</p>

<p class="author1">Imagine you wanted to provide a command to an image that doesn’t provide one yet. As usual, there are two different approaches: imperative and declarative. We’ll generate the YAML manifest with the help of the <code class="calibre15">run</code> command. The Pod should use the <code class="calibre15">busybox:1.36.1</code> image and execute a shell command that renders the current date every 10 seconds in an infinite loop:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run mypod --image=busybox:1.36.1 -o yaml --dry-run=client \
  &gt; pod.yaml -- /bin/sh -c "while true; do date; sleep 10; done"</strong>
</pre>

<p class="author1">You can see in the generated but condensed <code class="calibre15">pod.yaml</code> file shown in <a data-type="xref" href="#a_yaml_manifest_containing_a_args_attribute" class="calibre10">Example 5-3</a> that the command has been turned into an <code class="calibre15">args</code> attribute. Kubernetes specifies each argument on a single line.</p>
<div id="a_yaml_manifest_containing_a_args_attribute" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 5-3. </span>A YAML manifest containing an args attribute</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">mypod</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">mypod</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">busybox:1.36.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">/bin/sh</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">-c</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">while true; do date; sleep 10; done</code><code class="w"></code></pre></div>

<p class="author1">You could have achieved the same by a combination of the <code class="calibre15">command</code> and <code class="calibre15">args</code> attributes if you were to handcraft the YAML manifest. <a data-type="xref" href="#a_yaml_file_containing_a_command_and_args_attribute" class="calibre10">Example 5-4</a> shows a different approach.</p>
<div id="a_yaml_file_containing_a_command_and_args_attribute" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 5-4. </span>A YAML manifest containing command and args attributes</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">mypod</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">mypod</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">busybox:1.36.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="calibre15">[</code><code class="s">"/bin/sh"</code><code class="calibre15">]</code><code class="w"></code>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="calibre15">[</code><code class="s">"-c"</code><code class="calibre15">,</code><code class="w"> </code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">date;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">10;</code><code class="nv"> </code><code class="s">done"</code><code class="calibre15">]</code><code class="w"></code></pre></div>

<p class="author1">You can quickly verify if the declared command actually does its job. First, create the Pod instance, then tail the logs:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f pod.yaml</strong>
pod/mypod created
<strong class="calibre38">$ kubectl logs mypod -f</strong>
Fri May 29 00:49:06 UTC 2020
Fri May 29 00:49:16 UTC 2020
Fri May 29 00:49:26 UTC 2020
...
</pre>
</div></section>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Deleting a Pod" class="praise"><div class="dedication" id="id185">
<h2 class="calibre33">Deleting a Pod</h2>

<p class="author1">Sooner or later you’ll want to delete a Pod. During the exam, you may be asked to remove a Pod. Or possibly, you made a configuration mistake and want to start the question from scratch:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl delete pod hazelcast</strong>
pod "hazelcast" deleted
</pre>

<p class="author1">Keep in mind that Kubernetes tries to delete a Pod <em class="calibre3">gracefully</em>. This means that the Pod will try to finish active requests to the Pod to avoid unnecessary disruption to the end user. A graceful deletion operation can take anywhere from 5 to 30 seconds, time you don’t want to waste during the exam. See <a data-type="xref" href="ch01.xhtml#exam-details-and-resources" class="calibre10">Chapter 1</a> for more information on how to speed up the process.</p>

<p class="author1">An alternative way to delete a Pod is to point the <code class="calibre15">delete</code> command to the YAML manifest you used to create it. The behavior is the same:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl delete -f pod.yaml</strong>
pod "hazelcast" deleted
</pre>

<p class="author1">To save time during the exam, you can circumvent the grace period by adding the <code class="calibre15">--now</code> option to the <code class="calibre15">delete</code> command. Avoid using the <code class="calibre15">--now</code> flag in production Kubernetes environments.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Working with Namespaces" class="praise"><div class="dedication" id="working_with_namespaces">
<h1 class="calibre17">Working with Namespaces</h1>

<p class="author1">Namespaces are an API construct to avoid naming collisions, and they represent a scope for object names. A good use case for namespaces is to isolate the objects by team or responsibility.</p>
<div data-type="tip" class="calibre26"><h1 class="calibre34">Namespaces for objects</h1>
<p class="author1">The content in this chapter demonstrates the use of namespaces for Pod objects. Namespaces are not a concept applicable only to Pods though. Most object types can be grouped by a namespace.</p>
</div>

<p class="author1">Most questions in the exam will ask you to execute the command in a specific namespace that has been set up for you. The following sections briefly touch on the basic operations needed to deal with a namespace.</p>








<section data-type="sect2" data-pdf-bookmark="Listing Namespaces" class="praise"><div class="dedication" id="id187">
<h2 class="calibre33">Listing Namespaces</h2>

<p class="author1">A Kubernetes cluster starts out with a couple of initial namespaces. You can list them with the following command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get namespaces</strong>
NAME              STATUS   AGE
default           Active   157d
kube-node-lease   Active   157d
kube-public       Active   157d
kube-system       Active   157d
</pre>

<p class="author1">The <code class="calibre15">default</code> namespace hosts objects that haven’t been assigned to an explicit namespace. Namespaces starting with the prefix <code class="calibre15">kube-</code> are not considered end user-namespaces. They have been created by the Kubernetes system. You will not have to interact with them as an application developer.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Creating and Using a Namespace" class="praise"><div class="dedication" id="id188">
<h2 class="calibre33">Creating and Using a Namespace</h2>

<p class="author1">To create a new namespace, use the <code class="calibre15">create namespace</code> command. The following command uses the name <code class="calibre15">code-red</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create namespace code-red</strong>
namespace/code-red created
<strong class="calibre38">$ kubectl get namespace code-red</strong>
NAME       STATUS   AGE
code-red   Active   16s
</pre>

<p class="author1"><a data-type="xref" href="#namespace_yaml_manifest" class="calibre10">Example 5-5</a> shows the corresponding representation as a YAML manifest.</p>
<div id="namespace_yaml_manifest" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 5-5. </span>Namespace YAML manifest</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Namespace</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">code-red</code><code class="w"></code></pre></div>

<p class="author1">Once the namespace is in place, you can create objects within it. You can do so with the command line option <code class="calibre15">--namespace</code> or its short-form <code class="calibre15">-n</code>. The following commands create a new Pod in the namespace <code class="calibre15">code-red</code> and then list the available Pods in the namespace:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl run pod --image=nginx:1.25.1 -n code-red</strong>
pod/pod created
<strong class="calibre38">$ kubectl get pods -n code-red</strong>
NAME   READY   STATUS    RESTARTS   AGE
pod    1/1     Running   0          13s
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Setting a Namespace Preference" class="praise"><div class="dedication" id="id189">
<h2 class="calibre33">Setting a Namespace Preference</h2>

<p class="author1">Providing the <code class="calibre15">--namespace</code> or <code class="calibre15">-n</code> command line option for every command is tedious and error-prone. You can set a permanent namespace preference if you know that you need to interact with a specific namespace you are responsible for. The first command shown sets the permanent namespace <code class="calibre15">code-red</code>. The second command renders the currently set permanent namespace:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl config set-context --current --namespace=code-red</strong>
Context "minikube" modified.
<strong class="calibre38">$ kubectl config view --minify | grep namespace:</strong>
    namespace: hello
</pre>

<p class="author1">Subsequent <code class="calibre15">kubectl</code> executions do not have to spell out the namespace <code class="calibre15">code-red</code>:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl get pods</strong>
NAME   READY   STATUS    RESTARTS   AGE
pod    1/1     Running   0          13s
</pre>

<p class="author1">You can always switch back to the <code class="calibre15">default</code> namespace or another custom namespace using the <code class="calibre15">config set-context</code> command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl config set-context --current --namespace=default</strong>
Context "minikube" modified.
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Deleting a Namespace" class="praise"><div class="dedication" id="id190">
<h2 class="calibre33">Deleting a Namespace</h2>

<p class="author1">Deleting a namespace has a cascading effect on the object existing in it. Deleting a namespace will automatically delete its objects:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl delete namespace code-red</strong>
namespace "code-red" deleted
<strong class="calibre38">$ kubectl get pods -n code-red</strong>
No resources found in code-red namespace.
</pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id191">
<h1 class="calibre17">Summary</h1>

<p class="author1">The exam puts a strong emphasis on the concept of a Pod, a Kubernetes primitive responsible for running an application in a container. A Pod can define one or many containers that use a container image. Upon its creation, the container image is resolved and used to bootstrap the application. Every Pod can be further customized with the relevant YAML configuration.</p>
</div></section>






<section data-type="sect1" class="praise" data-pdf-bookmark="Exam Essentials"><div class="dedication" id="id192">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Know how to interact with Pods</dt>
<dd class="calibre20">
<p class="calibre21">A Pod runs an application inside of a container. You can check on the status and the configuration of the Pod by inspecting the object with the <code class="calibre15">kubectl get</code> or <code class="calibre15">kubectl describe</code> commands. Get familiar with the life cycle phases of a Pod to be able to quickly diagnose errors. The command <code class="calibre15">kubectl logs</code> can be used to download the container log information without having to shell into the container. Use the command <code class="calibre15">kubectl exec</code> to further explore the container environment, e.g., to check on processes or to examine files.</p>
</dd>
<dt class="calibre19">Understand advanced Pod configuration options</dt>
<dd class="calibre20">
<p class="calibre21">Sometimes you have to start with the YAML manifest of a Pod and then create the Pod declaratively. This could be the case if you wanted to provide environment variables to the container or declare a custom command. Practice different configuration options by copy-pasting relevant code snippets from the Kubernetes documentation.</p>
</dd>
<dt class="calibre19">Practice using a custom namespace</dt>
<dd class="calibre20">
<p class="calibre21">Most questions in the exam will ask you to work within a given namespace. You need to understand how to interact with that namespace from <code class="calibre15">kubectl</code> using the options <code class="calibre15">--namespace</code> and <code class="calibre15">-n</code>. To avoid accidentally working on the wrong namespace, know how to permanently set a namespace.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id193">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_001.xhtml#appendix_a_pods_namespaces" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Create a new Pod named <code class="calibre15">nginx</code> running the image <code class="calibre15">nginx:1.17.10</code>. Expose the container port 80. The Pod should live in the namespace named <code class="calibre15">ckad</code>.</p>

<p class="author1">Get the details of the Pod including its IP address.</p>

<p class="author1">Create a temporary Pod that uses the <code class="calibre15">busybox:1.36.1</code> image to execute a <code class="calibre15">wget</code> command inside of the container. The <code class="calibre15">wget</code> command should access the endpoint exposed by the <code class="calibre15">nginx</code> container. You should see the HTML response body rendered in the terminal.</p>

<p class="author1">Get the logs of the <code class="calibre15">nginx</code> container.</p>

<p class="author1">Add the environment variables <code class="calibre15">DB_URL=postgresql://mydb:5432</code> and <code class="calibre15">DB_USERNAME=admin</code> to the container of the <code class="calibre15">nginx</code> Pod.</p>

<p class="author1">Open a shell for the <code class="calibre15">nginx</code> container and inspect the contents of the current directory <code class="calibre15">ls -l</code>. Exit out of the container.</p>
</li>
<li class="calibre56">
<p class="author1">Create a YAML manifest for a Pod named <code class="calibre15">loop</code> that runs the <code class="calibre15">busybox:1.36.1</code> image in a container. The container should run the following command: <code class="calibre15">for i in {1..10}; do echo "Welcome $i times"; done</code>. Create the Pod from the YAML manifest. What’s the status of the Pod?</p>

<p class="author1">Edit the Pod named <code class="calibre15">loop</code>. Change the command to run in an endless loop. Each iteration should <code class="calibre15">echo</code> the current date.</p>

<p class="author1">Inspect the events and the status of the Pod <code class="calibre15">loop</code>.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>