<html><head></head><body><section data-pdf-bookmark="Chapter 6. Deployments" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_deployments">&#13;
<h1><span class="label">Chapter 6. </span>Deployments</h1>&#13;
&#13;
&#13;
<p>A <em>deployment</em>, in the <a data-primary="deployments" data-type="indexterm" id="idm46291185286920"/>simplest sense, is the movement of code from one location to another. With some platforms this is as simple as copying a bunch of files. For example, plenty of applications can be deployed by copying raw source code files like PHP, Python, and Perl scripts, and subsequent HTTP requests to a web server execute the updated files automatically. Static sites are typically deployed in the same manner. More complicated applications that run persistently require an additional step to stop and start a process. Examples of this include shipping Node.js source files, a compiled Go binary, or a Python script.<sup><a data-type="noteref" href="ch06.html#idm46291185298648" id="idm46291185298648-marker">1</a></sup></p>&#13;
&#13;
<p>Modern applications <em>should</em> make themselves consumable by listening on a port (see <a href="https://12factor.net/port-binding"><em class="hyperlink">https://12factor.net/port-binding</em></a> for details). This is true whether an <a data-primary="applications" data-secondary="consumable" data-type="indexterm" id="idm46291185295784"/>application is written in a platform that is traditionally invoked by a web server (like PHP, where you might include Apache and PHP inside of a Docker container) or if the application is written in Node.js (where the process listens for requests directly, hopefully with an external reverse proxy still involved). Sure, Node.js processes can be restarted when a source code file has been changed. Packages like <code>nodemon</code> and <code>forever</code> provide <a data-primary="nodemon package" data-type="indexterm" id="idm46291185293480"/><a data-primary="forever package" data-type="indexterm" id="idm46291185292744"/><a data-primary="packages" data-secondary="nodemon" data-type="indexterm" id="idm46291185292072"/><a data-primary="packages" data-secondary="forever" data-type="indexterm" id="idm46291185291128"/>such functionality for making local development easier.<sup><a data-type="noteref" href="ch06.html#idm46291185269544" id="idm46291185269544-marker">2</a></sup></p>&#13;
&#13;
<p>In practice, a deployment is a much more formal process than “just copying some files.” The deployment process is usually made up of many stages, with the copying of application code being one of the final stages. Other things need to happen as well, such as checking out source code from version control, installing dependencies, building/compiling, running automated tests, etc. The collection of stages required to <a data-primary="deployments" data-secondary="build pipeline" data-type="indexterm" id="idm46291185267848"/><a data-primary="build pipeline" data-type="indexterm" id="idm46291185267000"/>deploy an application is referred to as a <em>build pipeline</em>.</p>&#13;
&#13;
<p>Generally one piece of software becomes the most integral component for managing the build pipeline. A popular <a data-primary="CI (Continuous Integration)" data-type="indexterm" id="idm46291185265272"/>class of software to achieve this is the <em>Continuous Integration</em> (CI) service. Continuous integration is a software development practice where self-contained changes made to an application are constantly being tested, merged into a mainline branch, and deployed. A CI server is in charge of managing the build pipeline to make such a process feasible.</p>&#13;
&#13;
<p>Regardless of the tool used for managing a build pipeline, there are some concepts that are almost universally used:</p>&#13;
<dl>&#13;
<dt>Build</dt>&#13;
<dd>&#13;
<p>A build is when a <a data-primary="deployments" data-secondary="build pipeline" data-tertiary="builds" data-type="indexterm" id="idm46291185261400"/><a data-primary="build pipeline" data-secondary="builds" data-type="indexterm" id="idm46291185260120"/>snapshot (such as a particular Git commit) of an application’s codebase is converted into an executable form. This could involve transpiling code with Babel, installing dependencies from npm, and even generating a Docker image.</p>&#13;
</dd>&#13;
<dt>Release</dt>&#13;
<dd>&#13;
<p>A release is a combination <a data-primary="deployments" data-secondary="build pipeline" data-tertiary="releases" data-type="indexterm" id="idm46291185257528"/><a data-primary="build pipeline" data-secondary="releases" data-type="indexterm" id="idm46291185256280"/><a data-primary="releases, build pipeline" data-type="indexterm" id="idm46291185255336"/>of a particular build with configuration settings. For example, one build might be released to both the staging and production environments where it will have two different configurations applied.</p>&#13;
</dd>&#13;
<dt>Artifact</dt>&#13;
<dd>&#13;
<p>An artifact is a file or <a data-primary="deployments" data-secondary="build pipeline" data-tertiary="artifacts" data-type="indexterm" id="idm46291185253032"/><a data-primary="build pipeline" data-secondary="artifacts" data-type="indexterm" id="idm46291185251784"/><a data-primary="artifacts, build pipeline" data-type="indexterm" id="idm46291185250840"/>directory produced at some point during the build pipeline. This can be something that is used between multiple stages, like a Docker image, or a side effect of the build, like a code coverage report generated by the <code>nyc</code> package.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Each new release should have its own name. This name should be a value that increments, such as an integer or a timestamp. When an updated application is being deployed to a server, it means that the new files representing a release are copied to the server, the application is executed, and the previous release is torn down.</p>&#13;
&#13;
<p>When doing this, it’s important to keep several previous releases available in some manner. If a new release is found to be faulty, then an engineer should be able to revert to a previous release, an action called a <em>rollback</em>. Retaining previous releases can be as straightforward as keeping old Docker images in a Docker repository.</p>&#13;
&#13;
<p>Now that you’re familiar with some of the concepts around continuous integration and build pipelines, it’s time to get familiar with a particular CI service.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Build Pipeline with Travis CI" data-type="sect1"><div class="sect1" id="idm46291185246520">&#13;
<h1>Build Pipeline with Travis CI</h1>&#13;
&#13;
<p>This book mostly considers <a data-primary="build pipeline" data-secondary="Travis CI" data-type="indexterm" id="idm46291185245048"/><a data-primary="Travis CI" data-secondary="build pipeline" data-type="indexterm" id="idm46291185244072"/><a data-primary="CI (Continuous Integration)" data-secondary="Travis CI" data-type="indexterm" id="idm46291185243128"/><a data-primary="deployments" data-secondary="build pipeline" data-tertiary="Travis CI" data-type="indexterm" id="dep_Trav"/>open source tools, especially those that you can run yourself. However, due to the nature of deploying to a remote service, the next few sections will make use of free tiers of Platform as a Service (PaaS) tools. This is mostly so that you aren’t required to spend <a data-primary="PaaS (Platform-as-a-Service), Travis CI" data-type="indexterm" id="idm46291185240216"/>money on things like server hosting or domain registration, as well as to get you up and running as quickly as possible.</p>&#13;
&#13;
<p>For this section you need to set up two accounts. The first one is with <a class="orm:hideurl" href="https://github.com">GitHub</a>. You probably <a data-primary="GitHub" data-type="indexterm" id="idm46291185237912"/>already have a GitHub account and may even use it every day. GitHub is the world’s most popular service for hosting projects using Git version control. Most <a data-primary="npm packages" data-secondary="GitHub" data-type="indexterm" id="idm46291185236872"/>npm packages, and even the Node.js runtime itself, are hosted on GitHub. The second account you’ll need is with <a class="orm:hideurl" href="https://travis-ci.com">Travis CI</a> which, as part of sign-up, will require that it be associated with your GitHub account. Travis is a popular continuous integration build pipeline service. It, too, is used by Node.js and many popular npm packages.</p>&#13;
&#13;
<p>Now that your accounts are squared <a data-primary="GitHub" data-secondary="repository, creating" data-type="indexterm" id="idm46291185233880"/>away, it’s time to create a new repository on GitHub. Visit the GitHub website and click the plus sign in the navigational bar. This will take you to the <a class="orm:hideurl" href="https://github.com/new">Create a new repository</a> screen. On this screen, name the repository <em>distnode-deploy</em>. Set the visibility to public. Set the description to <em>Distributed Node.js Sample Project</em>. Elect to initialize the repository with a default <em>README.md</em> document. Also, use the drop-down menus to choose a default <em>.gitignore</em> file for Node.js, and add the <em>MIT License</em>. Once those options <a data-primary="GitHub" data-secondary="Create Repository button" data-type="indexterm" id="idm46291185229384"/>have been selected, click the <em>Create repository</em> button.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a Basic Project" data-type="sect2"><div class="sect2" id="idm46291185227800">&#13;
<h2>Creating a Basic Project</h2>&#13;
&#13;
<p>Once your repository is ready, <a data-primary="build pipeline" data-secondary="Travis CI" data-tertiary="project creation" data-type="indexterm" id="trav_projcreate"/><a data-primary="Travis CI" data-secondary="build pipeline" data-tertiary="project creation" data-type="indexterm" id="trav_projcreate1"/>navigate to your <em>distributed-node/</em> directory using a terminal. Then, check out the git repository that you just created on GitHub. You can do this by running the following command and replacing <code>&lt;USERNAME&gt;</code> with your &#13;
<span class="keep-together">GitHub</span> username:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>git clone git@github.com:&lt;USERNAME&gt;/distnode-deploy.git&#13;
<code class="nv">$ </code><code class="nb">cd </code>distnode-deploy</pre>&#13;
&#13;
<p>Now that you’re inside of the repository you created, initialize a new npm project and install a web server package for the project. You can do that by running the following commands:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>npm init -y&#13;
<code class="nv">$ </code>npm install fastify@3.2</pre>&#13;
&#13;
<p>Next, create a new <em>distnode-deploy/server.js</em> file. This will be a fairly simple service following similar patterns that you’ve worked with before. Modify the file so that its contents contain the code in <a data-type="xref" href="#ex_deploy_server">Example 6-1</a>.</p>&#13;
<div data-type="example" id="ex_deploy_server">&#13;
<h5><span class="label">Example 6-1. </span><em>distnode-deploy/server.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node</code>&#13;
&#13;
<code class="c1">// npm install fastify@3.2</code>&#13;
<code class="kr">const</code> <code class="nx">server</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fastify'</code><code class="p">)();</code>&#13;
<code class="kr">const</code> <code class="nx">HOST</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">HOST</code> <code class="o">||</code> <code class="s1">'127.0.0.1'</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">PORT</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">.</code><code class="nx">PORT</code> <code class="o">||</code> <code class="mi">8000</code><code class="p">;</code>&#13;
<code class="kr">const</code> <code class="nx">Recipe</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./recipe.js'</code><code class="p">);</code>&#13;
&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">reply</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="s2">"Hello from Distributed Node.js!"</code><code class="p">;</code>&#13;
<code class="p">});</code>&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/recipes/:id'</code><code class="p">,</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">reply</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">recipe</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Recipe</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">id</code><code class="p">);</code>&#13;
  <code class="nx">await</code> <code class="nx">recipe</code><code class="p">.</code><code class="nx">hydrate</code><code class="p">();</code>&#13;
  <code class="k">return</code> <code class="nx">recipe</code><code class="p">;</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">server</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">PORT</code><code class="p">,</code> <code class="nx">HOST</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">host</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Server running at </code><code class="si">${</code><code class="nx">host</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
<code class="p">});</code></pre></div>&#13;
&#13;
<p>Also, create another file named <em>distnode-deploy/recipe.js</em>. This file represents a model used by the application. Modify the file so that it contains the code in <a data-type="xref" href="#ex_deploy_model">Example 6-2</a>.</p>&#13;
<div data-type="example" id="ex_deploy_model">&#13;
<h5><span class="label">Example 6-2. </span><em>distnode-deploy/recipe.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="kr">class</code> <code class="nx">Recipe</code> <code class="p">{</code>&#13;
  <code class="nx">constructor</code><code class="p">(</code><code class="nx">id</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">id</code><code class="p">);</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">async</code> <code class="nx">hydrate</code><code class="p">()</code> <code class="p">{</code> <code class="c1">// Pretend DB Lookup</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="sb">`Recipe: #</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">id</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">toJSON</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="p">};</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">};</code></pre></div>&#13;
&#13;
<p>While you’re at it, modify the <em>distnode-deploy/package.json</em> file so that whenever the <code>npm test</code> command is <a data-primary="npm test command" data-type="indexterm" id="idm46291185020584"/><a data-primary="commands" data-secondary="npm test" data-type="indexterm" id="idm46291184909912"/>run, it will pass. You can do this by modifying the file and overwriting the <code>test</code> field in the <code>scripts</code> section to look like this:</p>&#13;
&#13;
<pre data-type="programlisting">"scripts": {&#13;
  "test": "echo \"Fake Tests\" &amp;&amp; exit 0"&#13;
},</pre>&#13;
&#13;
<p>Finally, create a <em>distnode-deploy/.travis.yml</em> file. This is what will be used to control Travis CI when it interacts with the repository. Add the content from <a data-type="xref" href="#ex_deploy_travisyml">Example 6-3</a> to this file.</p>&#13;
<div data-type="example" id="ex_deploy_travisyml">&#13;
<h5><span class="label">Example 6-3. </span><em>distnode-deploy/.travis.yml</em></h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">language</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">node_js</code><code>&#13;
</code><code class="nt">node_js</code><code class="p">:</code><code> </code><a class="co" href="#callout_deployments_CO1-1" id="co_deployments_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="s">"</code><code class="s">14</code><code class="s">"</code><code>&#13;
</code><code class="nt">install</code><code class="p">:</code><code> </code><a class="co" href="#callout_deployments_CO1-2" id="co_deployments_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">npm</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">install</code><code>&#13;
</code><code class="nt">script</code><code class="p">:</code><code> </code><a class="co" href="#callout_deployments_CO1-3" id="co_deployments_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="l-Scalar-Plain">PORT=0</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">npm</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">test</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_deployments_CO1-1" id="callout_deployments_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>This project will use Node.js v14.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO1-2" id="callout_deployments_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The command to run at install time.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO1-3" id="callout_deployments_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The command to run at test time.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>These files represent an early version of the application. Over time you’ll make various changes to them. Once you’ve <a data-primary="GitHub" data-secondary="files, pushing to master" data-type="indexterm" id="idm46291184861512"/>created the files, add them to git and push them to <em>master</em> by running the following commands:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>git add .&#13;
<code class="nv">$ </code>git commit -m <code class="s2">"Application files"</code>&#13;
<code class="nv">$ </code>git push</pre>&#13;
&#13;
<p>You’ve now pushed the application changes to GitHub. Switch back to your browser where you have the GitHub project page open and refresh. At this point you should see an updated listing of the files that <a data-primary="build pipeline" data-secondary="Travis CI" data-startref="trav_projcreate" data-tertiary="project creation" data-type="indexterm" id="idm46291184814824"/><a data-primary="Travis CI" data-secondary="build pipeline" data-startref="trav_projcreate1" data-tertiary="project creation" data-type="indexterm" id="idm46291184813432"/>you’ve modified.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring Travis CI" data-type="sect2"><div class="sect2" id="idm46291185227176">&#13;
<h2>Configuring Travis CI</h2>&#13;
&#13;
<p>Now that your GitHub <a data-primary="Travis CI" data-secondary="configuring" data-type="indexterm" id="trav_config"/><a data-primary="build pipeline" data-secondary="Travis CI" data-tertiary="configuring" data-type="indexterm" id="idm46291184808168"/>repository has some content in it, you’re ready to configure Travis to integrate with it. Open the <a href="https://travis-ci.com"><em class="hyperlink">https://travis-ci.com</em></a> website in your browser. Next, click your avatar icon in the upper-right corner of the navigation bar and select the settings option. This will take you to the <a class="orm:hideurl" href="https://oreil.ly/OR86K">repositories settings page</a>.</p>&#13;
&#13;
<p>On this page you should see a button to activate the GitHub Apps Integration. &#13;
<span class="keep-together">Click the</span> Activate button to start the process to authorize Travis to work with your &#13;
<span class="keep-together">repository.</span></p>&#13;
&#13;
<p>You’ll then be taken to the GitHub website <a data-primary="Travis CI" data-secondary="GitHub repositories" data-type="indexterm" id="idm46291184800968"/>where you can choose which repositories to enable. By default, the All repositories option is selected. Feel free to keep this option if you’d like to use Travis with other repositories. Otherwise, click the Only select repositories option. Once you select this option, you’ll be able to search for a repository. Find and select the <em>distnode-deploy</em> repository. Next, click the Approve &amp; Install button on the bottom of the screen.</p>&#13;
&#13;
<p>You will then be taken back to the repositories settings page in the Travis interface. This time you should see a list of GitHub-hosted repositories that Travis has access to. In particular, you should now see the <em>distnode-deploy</em> repository listed. Click the Settings button next to the repository name.</p>&#13;
&#13;
<p>This should take you to the settings page for your <em>distnode-deploy</em> project. By default it is configured to both Build pushed branches and to Build pushed pull requests. These default settings <a data-primary="Travis CI" data-secondary="configuring" data-startref="trav_config" data-type="indexterm" id="idm46291184797096"/>are fine.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing a Pull Request" data-type="sect2"><div class="sect2" id="idm46291184795592">&#13;
<h2>Testing a Pull Request</h2>&#13;
&#13;
<p>With your repository now <a data-primary="Travis CI" data-secondary="pull requests" data-type="indexterm" id="idm46291184793992"/><a data-primary="pull requests" data-type="indexterm" id="idm46291184793016"/><a data-primary="GitHub" data-secondary="pull requests" data-type="indexterm" id="idm46291184771832"/>configured to run commands against pull requests, it’s now time to give it a try. Currently, when you run <code>npm test</code>, the result is that the tests will pass. So, you’ll now simulate a pull request that will cause the test to fail. Ideally, the pull request will be prevented from being merged in this situation.</p>&#13;
&#13;
<p>Switch back to your project files and modify the <em>package.json</em> file. This time, modify the test line to look like the following:</p>&#13;
&#13;
<pre data-type="programlisting">"scripts": {&#13;
  "test": "echo \"Fake Tests\" &amp;&amp; exit 1"&#13;
},</pre>&#13;
&#13;
<p>Once you’ve modified the file, create a new branch, add the file, commit the change, and push it to GitHub. You can do that by running the following commands:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>git checkout -b feature-1&#13;
<code class="nv">$ </code>git add .&#13;
<code class="nv">$ </code>git commit -m <code class="s2">"Causing a failure"</code>&#13;
<code class="nv">$ </code>git push --set-upstream origin feature-1</pre>&#13;
&#13;
<p>Now switch back to the GitHub <a data-primary="distnode-deploy repository" data-type="indexterm" id="idm46291184764312"/><a data-primary="GitHub" data-secondary="distnode-deploy repository" data-type="indexterm" id="idm46291184763704"/>project page for your <em>distnode-deploy</em> repository. GitHub has detected that you’ve pushed a branch and displays a banner to create a pull request, assuming you’re on either the Code or Pull requests tabs. Note that you might need to refresh the page if the banner isn’t present. Click the Compare &amp; pull request button in the banner to create a pull request based on the branch you pushed.</p>&#13;
&#13;
<p>This will take you to the screen to create a pull request. The branch merge options should show that you’re attempting to merge a branch named <em>feature-1</em> into a branch named <em>master</em>. The default settings on this screen are fine. Click the Create pull request button to officially create a pull request.</p>&#13;
&#13;
<p>This will take you to the pull request screen for your first pull request. Depending on how quickly you’ve created the pull request, and how busy the Travis CI build servers are, you will see either zero, one, or two failures. Recall that in the Travis settings screen for the project, the option to build branches was enabled. Because of this, Travis was able to start testing the code as soon as the branch was pushed, even before the pull request was created. On my screen, the pull request checks look like <a data-type="xref" href="#fig_github_pr_travis_checks">Figure 6-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig_github_pr_travis_checks">&#13;
<img alt="Travis CI - Branch and Travis CI - Pull Request have both failed a GitHub pull request" src="assets/dsnj_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>GitHub pull request failure</h6>&#13;
</div></figure>&#13;
&#13;
<p>The messages displayed <a data-primary="build pipeline" data-secondary="Travis CI" data-tertiary="failed build" data-type="indexterm" id="idm46291184758872"/><a data-primary="Travis CI" data-secondary="build pipeline" data-tertiary="failed build" data-type="indexterm" id="idm46291184757592"/>so far in the pull request aren’t all that useful. It does show that something has failed, but it doesn’t say exactly why the failure has occurred. Travis does provide more detailed output, but it will take a few clicks to find it. Next to each of the failed checks is a link titled Details. Click the Details link next to the Travis CI-Pull Request check.</p>&#13;
&#13;
<p>You should now be on a GitHub screen with more details about the failing pull request check. This screen provides a little more information about the failed pull request test, but it’s still pretty high level, displaying information about individual jobs that have run as part of the check. One important button on this screen is the Re-run checks button. This will allow you to repeat the checks multiple times while retaining the same build settings. This is useful when testing flaky tests. However, clicking that button won’t fix this particular test as it’s hardcoded to fail.</p>&#13;
&#13;
<p>In the check failure panel, there’s a section titled Build Failed. Right below this is some text stating “The build failed,” where the text “The build” is a link; click it.</p>&#13;
&#13;
<p>This time, you’ve been taken to the <a data-primary="Travis CI" data-secondary="subchecks" data-type="indexterm" id="idm46291184748184"/>Travis CI website. On this screen you should see a list of all of the subchecks. This screen is useful for displaying permutations of tests. For example, you can configure the tests to run an application using different &#13;
<span class="keep-together">versions</span> of Node.js, environment variables, architectures, and even different operating systems (though some of these features require a paid account). Click the first &#13;
<span class="keep-together">failure row.</span></p>&#13;
&#13;
<p>You’re now viewing details about a specific “Job,” which is the term that Travis uses to refer to a particular context where your code has been executed. In this case, the application was executed using Node.js v14 on the AMD64 platform. Below the job overview section is the exciting stuff. The terminal output from all the commands that Travis has run is displayed. Looking at this output, you can see everything from the steps Travis took to set up the environment to the output of <a data-primary="npm install commands" data-type="indexterm" id="idm46291184744296"/><a data-primary="commands" data-secondary="npm install" data-type="indexterm" id="idm46291184743592"/>the <code>npm install</code> command. More importantly, you can see the output of <a data-primary="npm test command" data-type="indexterm" id="idm46291184742040"/><a data-primary="commands" data-secondary="npm test" data-type="indexterm" id="idm46291184741336"/>the <code>npm test</code> command. In my case, I see the following output:</p>&#13;
&#13;
<pre data-type="programlisting">$ npm test&#13;
&gt; distnode-deploy@1.0.0 test /home/travis/build/tlhunter/distnode-deploy&#13;
&gt; echo "Fake Tests" &amp;&amp; exit 1&#13;
Fake Tests&#13;
npm ERR! Test failed.  See above for more details.&#13;
The command "npm test" exited with 1.</pre>&#13;
&#13;
<p>Congratulations! You’ve now got a very simple build pipeline enabled for your project. Of course, it’s not that useful just yet since it only runs a fake test so far. In the next section you’ll create some useful tests, re-creating some of the quality controls that a larger organization might impose. Leave your failing pull request unmerged for now; you’ll fix it up soon enough.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46291184717960">&#13;
<h5>Alternatives to Travis CI</h5>&#13;
<p>One of the closest alternatives <a data-primary="Travis CI" data-secondary="alternatives" data-type="indexterm" id="idm46291184716728"/>to Travis CI is <a class="orm:hideurl" href="https://circleci.com">Circle CI</a>. Both are PaaS tools, offer similar functionality, are configured via YAML file, have a free tier for open source projects, and even have on-prem support for enterprise users. I would recommend trying both and comparing pricing before choosing one or the other.</p>&#13;
&#13;
<p>GitHub offers <a data-primary="GitHub" data-secondary="built-in CI features" data-type="indexterm" id="idm46291184713976"/>built-in CI features as part of their <a class="orm:hideurl" href="https://github.com/features/actions">GitHub Actions</a> product. Bitbucket, a competing PaaS product for hosting Git repositories, has their own <a class="orm:hideurl" href="https://bitbucket.org/product/features/pipelines">Bitbucket Pipelines</a> product that is similar.</p>&#13;
&#13;
<p>When it comes to self-hosting a CI service, <a data-primary="CI (Continuous Integration)" data-secondary="self-hosting" data-type="indexterm" id="idm46291184710216"/>the open source <a class="orm:hideurl" href="https://jenkins.io">Jenkins</a> is the most popular choice. It requires a lot of configuration and plug-ins, which an application developer usually wouldn’t perform, and also needs to be publicly accessible so that tools like GitHub can call it <a data-primary="deployments" data-secondary="Travis CI" data-startref="dep_Trav" data-type="indexterm" id="idm46291184707848"/>via webhook.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Automated Testing" data-type="sect1"><div class="sect1" id="ch_deployments_sec_testing">&#13;
<h1>Automated Testing</h1>&#13;
&#13;
<p>Modern application consumers <a data-primary="deployments" data-secondary="testing, automated" data-type="indexterm" id="dep_testauto"/><a data-primary="testing" data-type="indexterm" id="idm46291184703224"/>expect a continuous stream of new features and bug fixes. In order to provide them with such an experience, the applications you work on require continuous integration. Application changes require ample testing to give development teams—and the overall organization—the confidence required to support such a system. The practice of quarterly releases with vigorous QA schedules only applies to the most antiquated of industries. Instead, testing needs to be done in an automated manner and be applied to every change.</p>&#13;
&#13;
<p>There are numerous approaches for testing code before it’s merged into the mainline branch. This section covers a few of these approaches and, in particular, how they are applied to Node.js applications. But before any of these approaches can be used in your application, you’ll first need to set up a testing framework.</p>&#13;
&#13;
<p>There are many testing frameworks <a data-primary="npm testing frameworks" data-type="indexterm" id="idm46291184700744"/><a data-primary="Tape" data-type="indexterm" id="idm46291184700040"/><a data-primary="testing" data-secondary="Tape" data-type="indexterm" id="idm46291184699368"/>available on npm. Some of them are very powerful, injecting global variables into test files and requiring a special executable to run. Others are simpler but may require more manual tweaking to get them to suit your needs. For the examples in this section, you’re going to use <em>Tape</em>, a popular yet simple testing framework, to spruce up your <em>distnode-deploy</em> pull request.</p>&#13;
&#13;
<p>First off, you need a directory <a data-primary="testing" data-secondary="JavaScript files and" data-type="indexterm" id="idm46291184696696"/>to contain your test files. The most common pattern is to create a <em>test/</em> directory and add JavaScript files containing tests to this directory. You’ll also need to install Tape. Run the following commands to do just that:</p>&#13;
&#13;
<pre data-type="programlisting">$ mkdir test&#13;
$ npm install --save-dev tape@5</pre>&#13;
&#13;
<p>Notice the <code>--save-dev</code> argument with the <a data-primary="npm install commands" data-type="indexterm" id="idm46291184693432"/><a data-primary="commands" data-secondary="install" data-type="indexterm" id="idm46291184692696"/><a data-primary="tape package" data-type="indexterm" id="idm46291184691752"/><a data-primary="packages" data-secondary="tape" data-type="indexterm" id="idm46291184691080"/>install command. This ensures that the <code>tape</code> package is installed as a development dependency. This is because the production version of the application shouldn’t have a testing framework deployed with it.</p>&#13;
&#13;
<p>When it comes to creating tests, you’ll create individual JavaScript files and put them within the <em>test/</em> directory. You’ll end up with only two separate test files in this section, and in theory, you could hardcode the paths to those files and run them. But with more complex test suites like the ones used in real production applications, maintaining such a list would be difficult and error-prone. Instead, use a glob pattern to run any JavaScript files within the <em>test/</em> directory. Modify the <em>package.json</em> file so that the test command looks like the following:</p>&#13;
&#13;
<pre data-type="programlisting">"scripts": {&#13;
  "test": "tape ./test/**/*.js"&#13;
},</pre>&#13;
&#13;
<p>This configures the <code>npm test</code> command to <a data-primary="npm test command" data-type="indexterm" id="idm46291184685208"/><a data-primary="commands" data-secondary="npm test" data-type="indexterm" id="idm46291184684472"/>run the <code>tape</code> executable provided by the <code>tape</code> package. When npm packages declare that they provide an executable, npm will make them available in the <em>node_modules/.bin/</em> directory. Later, when you execute an npm run script, npm will automatically check that directory for an executable. This is why the <code>npm test</code> command <a data-primary="tape command" data-type="indexterm" id="idm46291184681464"/><a data-primary="commands" data-secondary="tape" data-type="indexterm" id="idm46291184680728"/>will be able to run the <code>tape</code> command, even though trying to run <code>tape</code> directly in your shell should result in a Command Not Found error.</p>&#13;
&#13;
<p>The <code>./test/**/*.js</code> argument is a glob pattern, which means that any file ending in <em>.js</em> within the <em>test/</em> directory, no matter how deeply nested, will be used as an argument. Tape doesn’t inject any magical globals, and test files can be executed directly, but the <code>tape</code> binary provides some other niceties that your pull request will depend on. For example, if any of the individual test files fail, then the overall test run &#13;
<span class="keep-together">will fail.</span></p>&#13;
&#13;
<p>With the groundwork now in place, you’re ready to create your first test.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Unit Tests" data-type="sect2"><div class="sect2" id="idm46291184675448">&#13;
<h2>Unit Tests</h2>&#13;
&#13;
<p><em>Unit testing</em> is a pattern <a data-primary="testing" data-secondary="unit testing" data-type="indexterm" id="unittest"/><a data-primary="unit testing" data-type="indexterm" id="unittest1"/>where individual <em>units</em> of code, usually correlating to a function, are tested. These tests are applicable to all forms of code, everything from npm packages to complete applications. Unit tests should test every nook and cranny of a codebase. These tests should cover each branch of logic within a function, passing in various anticipated arguments, and even testing failure conditions.</p>&#13;
&#13;
<p>A logical branch refers to things like if/else statements, switch statements, loop bodies, etc. Basically, anywhere an application can choose to run one set of code or another is considered a branch. When creating tests for real applications, be sure to create unit tests for each scenario.</p>&#13;
&#13;
<p>There are a few approaches for laying <a data-primary="test/ directory" data-type="indexterm" id="idm46291184668984"/>out the files within an application’s <em>test/</em> directory. For larger applications it’s pretty common to have the <em>test/</em> directory structure mimic the application’s directory structure. For example, if an application had a <em>src/models/account.js</em> file, then it might also have a <em>test/models/account.js</em> file to test it. However, for this example project, you only need a single unit test file. Create a file named <em>unit.js</em> within your <em>test/</em> directory. Within this file, add the content from <a data-type="xref" href="#ex_unit_test">Example 6-4</a>.</p>&#13;
<div data-type="example" id="ex_unit_test">&#13;
<h5><span class="label">Example 6-4. </span><em>distnode-deploy/test/unit.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node&#13;
</code><code>&#13;
</code><code class="c1">// npm install -D tape@5&#13;
</code><code class="kr">const</code><code> </code><code class="nx">test</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'tape'</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">Recipe</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'../recipe.js'</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_deployments_CO2-1" id="co_deployments_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="nx">test</code><code class="p">(</code><code class="s1">'Recipe#hydrate()'</code><code class="p">,</code><code> </code><code class="nx">async</code><code> </code><code class="p">(</code><code class="nx">t</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_deployments_CO2-2" id="co_deployments_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">r</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">Recipe</code><code class="p">(</code><code class="mi">42</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">await</code><code> </code><code class="nx">r</code><code class="p">.</code><code class="nx">hydrate</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">t</code><code class="p">.</code><code class="nx">equal</code><code class="p">(</code><code class="nx">r</code><code class="p">.</code><code class="nx">name</code><code class="p">,</code><code> </code><code class="s1">'Recipe: #42'</code><code class="p">,</code><code> </code><code class="s1">'name equality'</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_deployments_CO2-3" id="co_deployments_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="nx">test</code><code class="p">(</code><code class="s1">'Recipe#serialize()'</code><code class="p">,</code><code> </code><code class="p">(</code><code class="nx">t</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">r</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nx">Recipe</code><code class="p">(</code><code class="mi">17</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">t</code><code class="p">.</code><code class="nx">deepLooseEqual</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code><code> </code><code class="p">{</code><code> </code><code class="nx">id</code><code class="o">:</code><code> </code><code class="mi">17</code><code class="p">,</code><code> </code><code class="nx">name</code><code class="o">:</code><code> </code><code class="kc">null</code><code> </code><code class="p">}</code><code class="p">,</code><code> </code><code class="s1">'serializes properly'</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">t</code><code class="p">.</code><code class="nx">end</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_deployments_CO2-4" id="co_deployments_CO2-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_deployments_CO2-1" id="callout_deployments_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Application code is loaded for testing.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO2-2" id="callout_deployments_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Every test has a name and a function.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO2-3" id="callout_deployments_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>An assertion that two values are equal.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO2-4" id="callout_deployments_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Tape needs to know when a callback-based test has finished.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This unit test file has two test <a data-primary="unit testing" data-secondary="Recipe#hydrate() test" data-type="indexterm" id="idm46291184510680"/><a data-primary="unit testing" data-secondary="Recipe#serialize() test" data-type="indexterm" id="idm46291184509736"/>cases in it. The first one is titled <em>Recipe#hydrate()</em>, and the second is titled <em>Recipe#serialize()</em>. These tests are named so that their output in a console tells you what they’re testing. Tests that use async functions will finish when the returned promise resolves; however, callback tests require a manual call to <code>t.end()</code> to signal the end of the test assertions.</p>&#13;
&#13;
<p>Each test case can contain multiple assertions within it, though in this case each case only contains a single assertion. The function argument for the Tape test cases provides a single argument, named <code>t</code> in these examples, that contains a few assertion methods. The first test case uses <code>t.equal()</code>, which asserts that the two arguments are loosely equal to each other. If they aren’t, the test case will log a failure, and the process will exit with a nonzero exit status.</p>&#13;
&#13;
<p>The second test case uses <code>t.deepLooseEqual()</code>, which <a data-primary="Tape" data-secondary="t.deepLooseEqual() assertion method" data-type="indexterm" id="idm46291184469784"/><a data-primary="Tape" data-secondary="t.deepEqual() assertion method" data-type="indexterm" id="idm46291184468936"/>asserts that the two arguments are “deeply loosely equal.” The concept of two things being deeply equal is used in many different JavaScript testing tools. Basically, it’s a way to recursively compare two objects for <code>==</code> equality, without requiring that the two objects are the exact same object instance. Another method, <code>t.deepEqual()</code>, is available but fails the test because the actual value is a class instance and the expected value is a POJO.</p>&#13;
&#13;
<p>Tape has other assertion <a data-primary="Tape" data-secondary="t.ok() assertion method" data-type="indexterm" id="idm46291184466104"/><a data-primary="Tape" data-secondary="t.notOk() assertion method" data-type="indexterm" id="idm46291184465256"/><a data-primary="Tape" data-secondary="t.throws() method" data-type="indexterm" id="idm46291184464408"/><a data-primary="Tape" data-secondary="t.doesNotThrow() method" data-type="indexterm" id="idm46291184463560"/>methods. For example, you can use <code>t.ok()</code> to assert an argument is truthy, <code>t.notOk()</code> to assert it’s falsey, <code>t.throws()</code> to wrap a function that should throw, <code>t.doesNotThrow()</code> to do the opposite, and several others. Each of these assertions accepts an optional argument for labeling the assertion.</p>&#13;
&#13;
<p>Now that the file is complete, you’re ready to run your first test. Execute the following command to run the current iteration of the test suite:</p>&#13;
&#13;
<pre data-type="programlisting">$ npm test ; echo "STATUS: $?"</pre>&#13;
&#13;
<p>When I run this command, I get the following output:</p>&#13;
&#13;
<pre data-type="programlisting">TAP version 13&#13;
# Recipe#hydrate()&#13;
ok 1 name equality&#13;
# Recipe#serialize()&#13;
ok 2 serializes properly&#13;
&#13;
1..2&#13;
# tests 2&#13;
# pass  2&#13;
&#13;
# ok&#13;
&#13;
STATUS: 0</pre>&#13;
&#13;
<p>The output isn’t the most attractive—it’s actually designed for machine parsing—but it gets the job done. The <a class="orm:hideurl" href="https://www.npmjs.com/package/tape#pretty-reporters">Tape npm page</a> provides a list of formatters that can make the output more palatable. This can be done by installing an additional development dependency and piping the output of the <code>tape</code> command through it.</p>&#13;
&#13;
<p>The STATUS line isn’t part of the Tape command but is instead a shell command that’s printing the exit status from the <code>tape</code> command. This value is what will ultimately be used by the Travis CI server to determine if the test suite passed or not. A value of zero means the tests passed, and any other value represents failure.</p>&#13;
&#13;
<p>My favorite unit test idiom goes a little like this: “If it touches the network, it’s not a unit test.” Don’t worry, the unit test you’ve written so far definitely doesn’t touch the network. Tests that involve the network, filesystem access, or really any I/O, tend to <a data-primary="testing" data-secondary="unit testing" data-startref="unittest" data-type="indexterm" id="idm46291184454920"/><a data-primary="unit testing" data-startref="unittest1" data-type="indexterm" id="idm46291184453832"/>be slower and flakier.<sup><a data-type="noteref" href="ch06.html#idm46291184452856" id="idm46291184452856-marker">3</a></sup></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Integration Tests" data-type="sect2"><div class="sect2" id="idm46291184674824">&#13;
<h2>Integration Tests</h2>&#13;
&#13;
<p><em>Integration testing</em> covers <a data-primary="testing" data-secondary="integration testing" data-type="indexterm" id="inttest"/><a data-primary="integration testing" data-type="indexterm" id="inttest1"/>an application at a layer logically higher than that covered by unit testing. Integration tests check how different parts of an application work together. Consider the unit tests created in the previous section. They test individual methods of the recipe model class. However, the request handler code should probably be tested as well.</p>&#13;
&#13;
<p>There are different ways to write tests <a data-primary="testing" data-secondary="route handlers" data-type="indexterm" id="idm46291184447016"/><a data-primary="integration testing" data-secondary="route handlers" data-type="indexterm" id="idm46291184446168"/><a data-primary="route handlers, testing" data-type="indexterm" id="idm46291184445320"/>for route handlers. You could, for example, create a file that exports the handler functions. This same file could then be imported by a test file, passing in mocked <code>request</code> and <code>reply</code> objects. This would allow you to test the route handling code via unit tests. One way to do this is by using a package like <em>sinon</em> to create <em>Stubs</em> and <em>Spies</em>, which are special functions that keep track of how they’re called and interacted with.</p>&#13;
&#13;
<p>Personally, the approach I like to take is to run the web service, have it listen on a port for requests, and send it real HTTP requests from an external client. This is the safest way to guarantee that an application actually listens for requests and serves them properly.</p>&#13;
&#13;
<p>Integration tests are mostly beneficial for applications, though some npm packages will benefit from them as well. Unit tests usually run pretty quickly, and integration tests often run much slower. This is because more code is loaded and there are more moving parts. For example, unit tests might not ever instantiate the underlying web framework or other third-party npm packages, while integration tests will.</p>&#13;
&#13;
<p>For the integration tests you’re about to write, you’ll need to install a package to help make HTTP requests. Run the following command to install the familiar <code>node-fetch</code> package <a data-primary="integration testing" data-secondary="node-fetch package and" data-type="indexterm" id="idm46291184439928"/><a data-primary="node-fetch package, testing and" data-type="indexterm" id="idm46291184439080"/><a data-primary="packages" data-secondary="node-fetch" data-type="indexterm" id="idm46291184438472"/>as a development dependency:</p>&#13;
&#13;
<pre data-type="programlisting">$ npm install --save-dev node-fetch@2.6</pre>&#13;
&#13;
<p>Next, create a file in the <em>test/</em> directory called <em>integration.js</em>. With a more complex application, you might have a directory dedicated to integration tests. Each file within this directory could contain an individual test file for each application feature. This could mean test files like <em>user-account.js</em> and <em>gallery-upload.js</em>. But for this simple app, you’re just going to make a single test file. Add the content from <a data-type="xref" href="#ex_integration_test">Example 6-5</a> to &#13;
<span class="keep-together">this file.</span></p>&#13;
<div data-type="example" id="ex_integration_test">&#13;
<h5><span class="label">Example 6-5. </span><em>distnode-deploy/test/integration.js</em> (first version)</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c-Hashbang">#!/usr/bin/env node&#13;
</code><code>&#13;
</code><code class="c1">// npm install --save-dev tape@5 node-fetch@2.6&#13;
</code><code class="kr">const</code><code> </code><code class="p">{</code><code> </code><code class="nx">spawn</code><code> </code><code class="p">}</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'child_process'</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">test</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'tape'</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="kr">const</code><code> </code><code class="nx">fetch</code><code> </code><code class="o">=</code><code> </code><code class="nx">require</code><code class="p">(</code><code class="s1">'node-fetch'</code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="kr">const</code><code> </code><code class="nx">serverStart</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="k">new</code><code> </code><code class="nb">Promise</code><code class="p">(</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code><code> </code><code class="nx">_reject</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">server</code><code> </code><code class="o">=</code><code> </code><code class="nx">spawn</code><code class="p">(</code><code class="s1">'node'</code><code class="p">,</code><code> </code><code class="p">[</code><code class="s1">'../server.js'</code><code class="p">]</code><code class="p">,</code><code> </code><a class="co" href="#callout_deployments_CO3-1" id="co_deployments_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
    </code><code class="p">{</code><code> </code><code class="nx">env</code><code class="o">:</code><code> </code><code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="p">{</code><code class="p">}</code><code class="p">,</code><code> </code><code class="nx">process</code><code class="p">.</code><code class="nx">env</code><code class="p">,</code><code> </code><code class="p">{</code><code> </code><code class="nx">PORT</code><code class="o">:</code><code> </code><code class="mi">0</code><code> </code><code class="p">}</code><code class="p">)</code><code class="p">,</code><code>&#13;
      </code><code class="nx">cwd</code><code class="o">:</code><code> </code><code class="nx">__dirname</code><code> </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">server</code><code class="p">.</code><code class="nx">stdout</code><code class="p">.</code><code class="nx">once</code><code class="p">(</code><code class="s1">'data'</code><code class="p">,</code><code> </code><code class="nx">async</code><code> </code><code class="p">(</code><code class="nx">data</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="kr">const</code><code> </code><code class="nx">message</code><code> </code><code class="o">=</code><code> </code><code class="nx">data</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="nx">trim</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>&#13;
    </code><code class="kr">const</code><code> </code><code class="nx">url</code><code> </code><code class="o">=</code><code> </code><code class="sr">/Server running at (.+)$/</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code><code class="p">;</code><code>&#13;
    </code><code class="nx">resolve</code><code class="p">(</code><code class="p">{</code><code> </code><code class="nx">server</code><code class="p">,</code><code> </code><code class="nx">url</code><code> </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_deployments_CO3-2" id="co_deployments_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code><code>&#13;
&#13;
</code><code class="nx">test</code><code class="p">(</code><code class="s1">'GET /recipes/42'</code><code class="p">,</code><code> </code><code class="nx">async</code><code> </code><code class="p">(</code><code class="nx">t</code><code class="p">)</code><code> </code><code class="o">=&gt;</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="p">{</code><code> </code><code class="nx">server</code><code class="p">,</code><code> </code><code class="nx">url</code><code> </code><code class="p">}</code><code> </code><code class="o">=</code><code> </code><code class="nx">await</code><code> </code><code class="nx">serverStart</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">result</code><code> </code><code class="o">=</code><code> </code><code class="nx">await</code><code> </code><code class="nx">fetch</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">url</code><code class="si">}</code><code class="sb">/recipes/42</code><code class="sb">`</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="kr">const</code><code> </code><code class="nx">body</code><code> </code><code class="o">=</code><code> </code><code class="nx">await</code><code> </code><code class="nx">result</code><code class="p">.</code><code class="nx">json</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">t</code><code class="p">.</code><code class="nx">equal</code><code class="p">(</code><code class="nx">body</code><code class="p">.</code><code class="nx">id</code><code class="p">,</code><code> </code><code class="mi">42</code><code class="p">)</code><code class="p">;</code><code>&#13;
  </code><code class="nx">server</code><code class="p">.</code><code class="nx">kill</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" href="#callout_deployments_CO3-3" id="co_deployments_CO3-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">}</code><code class="p">)</code><code class="p">;</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_deployments_CO3-1" id="callout_deployments_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Spawn an instance of <em>server.js</em>.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO3-2" id="callout_deployments_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Extract the URL of the server.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO3-3" id="callout_deployments_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Kill the <em>server.js</em> instance once the test is complete.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>The <code>serverStart()</code> method is an async <a data-primary="serverStart() function" data-type="indexterm" id="idm46291184359880"/><a data-primary="functions" data-secondary="serverStart()" data-type="indexterm" id="idm46291184359256"/>function that spawns a new instance of <em>server.js</em>, tells it to listen on a random high port, waits for the first message to be printed to <em>stdout</em>, then extracts the URL from the message being logged. This allows the test to find the random port that <em>server.js</em> ends up using. Choosing a hardcoded port within the <em>integration.js</em> file could cause a headache in the future if two instances of the test were to ever run at the same time on the same machine.</p>&#13;
&#13;
<p>The test suite then sends an HTTP request to the server after the server has been started. Once the response is received, the JSON payload is parsed and the response body is compared to the expected value. Finally, once the test case has passed, the <em>server.js</em> instance is killed and the test is finished.</p>&#13;
&#13;
<p>Now that you have your integration test in place, it’s time to run your newly created tests. Run the following command to execute both your unit test and integration test:</p>&#13;
&#13;
<pre data-type="programlisting">$ npm test ; echo "STATUS: $?"</pre>&#13;
&#13;
<p>The tests will now take a lot longer to run. Previously, just your unit test file, the <code>tape</code> package, and the recipe model were loaded. This ends up being a very fast process. This time, an entire web framework is loaded and network requests are made before the tests complete. On my machine this goes from taking tens of milliseconds to just over one second.</p>&#13;
&#13;
<p>Here’s what the output on my machine looks like. Notice the additional entry for the integration test:</p>&#13;
&#13;
<pre data-type="programlisting">TAP version 13&#13;
# GET /recipes/42&#13;
ok 1 should be equal&#13;
# Recipe#hydrate()&#13;
ok 2 name equality&#13;
# Recipe#serialize()&#13;
ok 3 serializes properly</pre>&#13;
&#13;
<p>Notice how the integration test is now running first, and the unit tests are run afterwards. This is probably because the files are sorted alphabetically.</p>&#13;
&#13;
<p>And there you have it: a very simple integration test is running where real HTTP requests are being made and a real server is responding.</p>&#13;
&#13;
<p>I’ve worked with many different Node.js application codebases and have seen many patterns form. A few times I’ve seen the pattern where no real HTTP requests are made and, instead, pseudo request objects are provided. For example, consider the following contrived test code:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Application code: foo-router.js</code>&#13;
<code class="c1">// GET http://host/resource?foo[bar]=1</code>&#13;
<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code><code class="p">.</code><code class="nx">fooHandler</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">_reply</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">foobar</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">bar</code><code class="p">;</code>&#13;
  <code class="k">return</code> <code class="nx">foobar</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="c1">// Test code: test.js</code>&#13;
<code class="kr">const</code> <code class="nx">router</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'foo-router.js'</code><code class="p">);</code>&#13;
<code class="nx">test</code><code class="p">(</code><code class="s1">'#fooHandler()'</code><code class="p">,</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">t</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="nx">foobar</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">router</code><code class="p">.</code><code class="nx">fooHandler</code><code class="p">({</code>&#13;
    <code class="nx">foo</code><code class="o">:</code> <code class="p">{</code> <code class="nx">bar</code><code class="o">:</code> <code class="mi">1</code> <code class="p">}</code>&#13;
  <code class="p">});</code>&#13;
  <code class="nx">t</code><code class="p">.</code><code class="nx">strictEqual</code><code class="p">(</code><code class="nx">foobar</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Can you think of any issues with this example code? Well, one issue is that query parameters are usually represented as strings. So, that <code>bar: 1</code> value in the example should really be <code>bar: "1"</code>. The request object being passed in therefore represents an impossible manifestation of the request object. In this case, the code assumes the <code>foo.bar</code> value will be a number and the tests pass, but once this handler is invoked by the real web server, it’ll get a string and a logic error.</p>&#13;
&#13;
<p>Here’s another issue that can happen and that did cause an outage for an API at a company I once worked for. An engineer switched query string parsing packages from an outdated and opinionated package to a well-maintained and highly configurable package.</p>&#13;
&#13;
<p>One thing the engineer forgot to do was configure the package to treat square brackets as array identifiers. This is a syntax that allows a query string like <code>a[]=1&amp;a[]=2</code> to be converted into an array containing the values 1 and 2, resulting in this: <code>{"a": [1, 2]}</code>. Instead, the new package ignored the square brackets and overwrote repeated keys, resulting in this: <code>{"a": 2}</code>. The API would then call an array method on a number and crash. The tests passed in hardcoded objects representing what the request was assumed to resemble, not the real output from the query string library, and when the tests passed, the broken application was deployed to production.</p>&#13;
&#13;
<p>There’s always going to be some unanticipated edge case with how an application runs and how it is tested. For that reason, I encourage you to create integration tests that interact with your application the same way a client would in production.</p>&#13;
&#13;
<p>Unit tests and integration tests are both powerful ways to test an application’s functionality. But how do you ensure that engineers are creating enough tests for their <a data-primary="testing" data-secondary="integration testing" data-startref="inttest" data-type="indexterm" id="idm46291184006536"/><a data-primary="integration testing" data-startref="inttest1" data-type="indexterm" id="idm46291184005288"/>features?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Coverage Enforcement" data-type="sect2"><div class="sect2" id="idm46291184451336">&#13;
<h2>Code Coverage Enforcement</h2>&#13;
&#13;
<p><em>Code coverage</em> is a way to <a data-primary="code coverage enforcement" data-type="indexterm" id="code_cover"/><a data-primary="testing" data-secondary="code coverage enforcement" data-type="indexterm" id="code_cover1"/>measure how much of an application’s code is being executed when a test suite runs. This value can be measured using different criteria, and the tool you’re going to use in this section measures coverage in four areas: statements, branches, functions, and lines. Measuring code coverage is beneficial for all types of codebases, including both npm packages and complete applications.</p>&#13;
&#13;
<p>Code coverage is an attempt to require engineers to test every feature that they add to a codebase. Not only can it be measured, but it can also be used as pull request criteria, failing if a threshold isn’t met.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Code coverage measurements should not be the only consideration for the quality of a proposed code change. It’s unfortunately easy to write tests that run each line of code but don’t actually test the underlying feature. At the end of the day, it takes a second engineer to determine if code is properly tested.</p>&#13;
</div>&#13;
&#13;
<p>One of the most popular packages for testing code <a data-primary="nyc package" data-type="indexterm" id="idm46291183996168"/><a data-primary="packages" data-secondary="nyc" data-type="indexterm" id="nyc"/>coverage is <em>nyc</em>. Install the package by running the following command:</p>&#13;
&#13;
<pre data-type="programlisting">$ npm install --save-dev nyc@15</pre>&#13;
&#13;
<p>This will make a new executable available for use in your npm scripts. It can be activated by preceding the test command you would normally execute with <code>nyc</code>. For your application, modify the <em>package.json</em> file to introduce this new command. Your test script should now look like the following:</p>&#13;
&#13;
<pre data-type="programlisting">"scripts": {&#13;
  "test": "nyc tape ./test/*.js"&#13;
},</pre>&#13;
&#13;
<p>The <code>nyc</code> executable can be <a data-primary="nyc package" data-secondary="executable" data-type="indexterm" id="idm46291183989880"/>configured by providing command line arguments. But it’s generally cleaner to configure it by writing configuration to a file. One way to do this is to create a file named <em>.nycrc</em> in the root of a project directory. Create a file with this name and add the content from <a data-type="xref" href="#ex_nycrc">Example 6-6</a> to it.</p>&#13;
<div data-type="example" id="ex_nycrc">&#13;
<h5><span class="label">Example 6-6. </span><em>distnode-deploy/.nycrc</em></h5>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nt">"reporter"</code><code class="p">:</code> <code class="p">[</code><code class="s2">"lcov"</code><code class="p">,</code> <code class="s2">"text-summary"</code><code class="p">],</code>&#13;
  <code class="nt">"all"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nt">"check-coverage"</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nt">"branches"</code><code class="p">:</code> <code class="mi">100</code><code class="p">,</code>&#13;
  <code class="nt">"lines"</code><code class="p">:</code> <code class="mi">100</code><code class="p">,</code>&#13;
  <code class="nt">"functions"</code><code class="p">:</code> <code class="mi">100</code><code class="p">,</code>&#13;
  <code class="nt">"statements"</code><code class="p">:</code> <code class="mi">100</code>&#13;
<code class="p">}</code></pre></div>&#13;
&#13;
<p>This configuration file contains several <a data-primary="nyc package" data-secondary="reporter" data-type="indexterm" id="idm46291183984328"/>notable entries. The first one, <code>reporter</code>, describes how the reporting of the code coverage check should happen. The first entry, <code>lcov</code>, tells nyc to write an HTML summary to disk. This will allow you to visually see which parts of the application source code are covered and which are not. The second entry, <code>text-summary</code>, means that a summary of coverage is provided via <em>stdout</em>. This allows you to see a summary both when running coverage locally, and later when checking CI logs.</p>&#13;
&#13;
<p>The next entry, <code>all</code>, tells nyc to <a data-primary="nyc package" data-secondary="all" data-type="indexterm" id="idm46291183947720"/>consider coverage for all JavaScript files, not just the ones that are required when the tests run. Without this set to true, a developer might forget to test newly added files.</p>&#13;
&#13;
<p>The <code>check-coverage</code> entry instructs nyc to fail—by returning <a data-primary="nyc package" data-secondary="check-coverage" data-type="indexterm" id="idm46291183945272"/>a nonzero exit code—when code coverage thresholds aren’t met. The final four entries, <code>branches</code>, <code>lines</code>, <code>functions</code>, and <code>statements</code>, are the code coverage thresholds measured in percent. As a rule of thumb, there are only two numbers available here: 100 and everything else. Setting this value to less than 100% is a nice way to introduce testing to an existing codebase, but for new projects, you should strive to hit 100%.</p>&#13;
&#13;
<p>Now that you’ve enforced code coverage, run the following command to run the test suite again:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm <code class="nb">test</code> <code class="p">;</code> <code class="nb">echo</code> <code class="s2">"STATUS: </code><code class="nv">$?</code><code class="s2">"</code></pre>&#13;
&#13;
<p>This time, you should have some additional information about the test suite printed after the normal test results. On my machine I get the following output:</p>&#13;
&#13;
<pre data-type="programlisting">ERROR: Coverage for lines (94.12%) ...&#13;
ERROR: Coverage for functions (83.33%) ...&#13;
ERROR: Coverage for branches (75%) ...&#13;
ERROR: Coverage for statements (94.12%) ...&#13;
=========== Coverage summary ===========&#13;
Statements   : 94.12% ( 16/17 )&#13;
Branches     : 75% ( 3/4 )&#13;
Functions    : 83.33% ( 5/6 )&#13;
Lines        : 94.12% ( 16/17 )&#13;
========================================&#13;
STATUS: 1</pre>&#13;
&#13;
<p>This is a nice overview, but it doesn’t state exactly why the code coverage enforcement has failed. You might be able to guess why by digging through the test cases and application code. For example, there’s the <code>GET /</code> route that isn’t being requested, but is there anything else?</p>&#13;
&#13;
<p>Since one of the reporters was set to <code>lcov</code> in the <em>.nycrc</em> file, a report containing information about the code coverage has been written to disk. This is added to a newly created directory called <em>coverage/</em>. This is such a commonly used directory for writing code coverage output that the default <em>.gitignore</em> file created by GitHub already ignores that directory.</p>&#13;
&#13;
<p>Open the file located at <em>coverage/lcov-report/index.html</em> in a web browser to view the coverage report. <a data-type="xref" href="#fig_nyc_listing">Figure 6-2</a> is what the coverage report looks like on my computer.</p>&#13;
&#13;
<p>This file contains an overall summary at the top of the screen and a listing of each file below it. In this case, the <em>recipe.js</em> file is completely covered, but the <em>server.js</em> file is still missing a few things. Click the <em>server.js</em> link to view coverage details for this specific file. <a data-type="xref" href="#fig_nyc_file">Figure 6-3</a> is what this screen looks like on my computer.</p>&#13;
&#13;
<figure><div class="figure" id="fig_nyc_listing">&#13;
<img alt="nyc listing for code coverage of recipe.js and server.js" src="assets/dsnj_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>nyc listing for recipe.js and server.js</h6>&#13;
</div></figure>&#13;
&#13;
<figure><div class="figure" id="fig_nyc_file">&#13;
<img alt="nyc code coverage of for server.js" src="assets/dsnj_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>nyc code coverage for server.js</h6>&#13;
</div></figure>&#13;
&#13;
<p>The left margin displays a counter for how many times each line in the file has been executed. Everything that has been executed has only been executed a single time. Lines that only contain whitespace, comments, or the shebang don’t have an execution count since they’re never technically executed.</p>&#13;
&#13;
<p>The handler function for the <code>GET /</code> route is highlighted in red. This means that the code has not been covered. Hover your mouse cursor over the <code>return</code> keyword highlighted in red. The tooltip displays the message “statement not covered.” Next, hover your mouse cursor over the highlighted <code>async</code> keyword. The tooltip this time says “function not covered.” This will require a second HTTP request to the server to fix this issue.</p>&#13;
&#13;
<p>This can be fixed by making a second request from the integration test. Open up the <em>integration.js</em> file again and add the content from <a data-type="xref" href="#ex_integration_test_two">Example 6-7</a> to the end of the file.</p>&#13;
<div data-type="example" id="ex_integration_test_two">&#13;
<h5><span class="label">Example 6-7. </span><em>distnode-deploy/test/integration.js</em> (second test)</h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">test</code><code class="p">(</code><code class="s1">'GET /'</code><code class="p">,</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">t</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">server</code><code class="p">,</code> <code class="nx">url</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">serverStart</code><code class="p">();</code>&#13;
  <code class="kr">const</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">url</code><code class="si">}</code><code class="sb">/`</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">body</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">result</code><code class="p">.</code><code class="nx">text</code><code class="p">();</code>&#13;
  <code class="nx">t</code><code class="p">.</code><code class="nx">equal</code><code class="p">(</code><code class="nx">body</code><code class="p">,</code> <code class="s1">'Hello from Distributed Node.js!'</code><code class="p">);</code>&#13;
  <code class="nx">server</code><code class="p">.</code><code class="nx">kill</code><code class="p">();</code>&#13;
<code class="p">});</code></pre></div>&#13;
&#13;
<p>Now switch back to the web browser where you were viewing the coverage report. Something else in this file is still wrong. Near the top of the file, the default port fallback value of 8000 is highlighted in yellow. Hover your mouse cursor over the value, and the tooltip will say “branch not covered.” This means that the right operand for the <em>or</em> operator has never been executed. This is because the file is always executed with an environment variable pair of <code>PORT=0</code>. The zero is passed in as the string <code>"0"</code>, which is a truthy value.</p>&#13;
&#13;
<p>The easiest way to fix this problem is to instruct nyc to ignore the offending line. Add the following line to <em>server.js</em> just above the <code>PORT</code> assignment line:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">/* istanbul ignore next */</pre>&#13;
&#13;
<p>This comment instructs the code coverage checker to ignore the following line. There used to be two separate npm packages, one called <code>istanbul</code>, and one called <code>nyc</code>. The two projects were eventually merged. The CLI utility kept the name of <em>nyc</em>, while the comments used to configure the utility from within code kept the prefix of <em>istanbul</em>.</p>&#13;
&#13;
<p>Another way to get past this situation would be to reduce the required code coverage value. Since the application is so small, the values would actually have to be changed significantly, dropping the branches threshold from 100% to 75%. For a larger project, this drop would be much smaller, say from 100% to 99%. As tempting as that may be, it is actually a very annoying situation in practice. In the situation with sub-100% coverage, if an engineer removes a bunch of code from the repository, the code coverage percent will actually drop. Then the engineer will need to also reduce the code coverage threshold in <em>.nycrc</em> as well, despite not adding any untested code.</p>&#13;
&#13;
<p>Is it okay to not test the default port assignment line? In this case, it depends on how the application is intended to be launched in production. If the default port is only used to make local development easier, and in production a port is always assigned, then go ahead and ignore that line guilt-free.</p>&#13;
&#13;
<p>Now that you’ve added the new integration test and have added the ignore statement, run the test suite again. Run the following command to both run the tests and generate a new report:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm <code class="nb">test</code> <code class="p">;</code> <code class="nb">echo</code> <code class="s2">"STATUS: </code><code class="nv">$?</code><code class="s2">"</code></pre>&#13;
&#13;
<p>This time, the coverage summary will show that all four code coverage measurements have hit their 100% code coverage requirements! Now you’re ready to commit the changes and push them to your branch. Run the following commands to do just that:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>git add .&#13;
<code class="nv">$ </code>git commit -m <code class="s2">"Adding a test suite and code coverage"</code>&#13;
<code class="nv">$ </code>git push</pre>&#13;
&#13;
<p>Now that you’ve done that, switch back to your GitHub pull request and reload the page. The once-failing checks are now passing and your PR is now ready to be merged! Click the green “Merge pull request” button on the pull request screen to finish the process. You’ve now got a project happily testing pull requests.</p>&#13;
&#13;
<p>Switch back to your terminal and run the following commands to get your local &#13;
<span class="keep-together"><em>master</em></span> branch caught up with the remote:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>git checkout master&#13;
<code class="nv">$ </code>git pull</pre>&#13;
&#13;
<p>There are other types of tests that are commonly used to enforce code quality standards as well. One class that is very popular, used by projects from open source npm packages to closed source enterprise applications, is a code format test. By using packages like <code>eslint</code> or <code>standard</code>, a pull request can fail if the newly added code doesn’t follow the required format.</p>&#13;
&#13;
<p>Now that your repository is configured to test code quality before merging changes, it’s time to configure the project to actually do something with the code once it’s been merged. In the next section, you’ll configure your project to automatically deploy merged code to <a data-primary="deployments" data-secondary="testing, automated" data-startref="dep_testauto" data-type="indexterm" id="idm46291183707080"/><a data-primary="code coverage enforcement" data-startref="code_cover" data-type="indexterm" id="idm46291183705864"/><a data-primary="testing" data-secondary="code coverage enforcement" data-startref="code_cover1" data-type="indexterm" id="idm46291183781144"/><a data-primary="packages" data-secondary="nyc" data-startref="nyc" data-type="indexterm" id="idm46291183779960"/>production.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46291183778488">&#13;
<h5>Alternatives to Tape</h5>&#13;
<p>Mocha is the most common Node.js testing <a data-primary="Tape" data-secondary="alternatives" data-type="indexterm" id="idm46291183659592"/>framework that I’ve encountered across both open source npm packages and private enterprise applications. It has many &#13;
<span class="keep-together">features</span> that Tape doesn’t have, such as hierarchical tests, promise support, setup and teardown functions, and the ability to skip tests or only run a specific test.</p>&#13;
&#13;
<p>Tape comes with some built-in assertions, like the <code>t.equal()</code> method <a data-primary="Tape" data-secondary="t.equal() assertion method" data-type="indexterm" id="idm46291183656680"/>used in the example test files. Chai is a popular assertion library with an expressive syntax and also comes with many more granular assertions. A combination of Chai and Mocha is often used, especially with more complex codebases.</p>&#13;
&#13;
<p>Creating hand-rolled test files that only rely on the built-in <code>assert</code> module is also a perfectly valid approach to building a test suite. Node.js itself is tested in this manner.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploying to Heroku" data-type="sect1"><div class="sect1" id="ch_deployments_sec_deploy">&#13;
<h1>Deploying to Heroku</h1>&#13;
&#13;
<p>A chapter about deployments <a data-primary="deployments" data-secondary="Heroku" data-type="indexterm" id="dep_hero"/><a data-primary="Heroku" data-type="indexterm" id="idm46291183685208"/>wouldn’t be very exciting if you didn’t actually end up deploying something. Prepare yourself, for now is your chance. In this section you’ll configure Travis CI to execute the commands necessary to deploy your application to a production server.</p>&#13;
&#13;
<p>For this section, you’ll make use of another SaaS tool, <em>Heroku</em>. Heroku is a cloud platform that makes it very easy to deploy applications, configure databases, and scale out running application instances. It comes with many third-party integrations to make deployments easy and can be configured to automatically deploy your Node.js application code once a branch is merged in GitHub. This is so easy to configure that this section could have been written in a few paragraphs.</p>&#13;
&#13;
<p>But that would be too <a data-primary="Travis CI" data-secondary="Heroku" data-type="indexterm" id="idm46291183682488"/><a data-primary="Heroku" data-secondary="Travis CI and" data-type="indexterm" id="idm46291183681480"/>easy. Instead, you’ll get your hands a bit more dirty by configuring Travis CI to execute a deployment script. This script will run commands that will interact with Heroku. This is a universal approach that can be modified to deploy the application to other platforms.</p>&#13;
&#13;
<p>In the previous section, you configured Travis to build and test your pull requests. In this section, Travis will build and test code once it’s merged into the <em>master</em> branch, and once that passes, it’ll deploy that code to production. It might sound redundant to test code both when it’s in a pull request and again once it’s merged to <em>master</em>. However, it’s possible to do things like rebase or squash or other operations where GitHub will otherwise modify the code before it’s merged to <em>master</em>. It’s also possible to push directly to <em>master</em> in your GitHub repository. For those reasons, it’s better to test the code again before deploying to ensure only (seemingly) valid code is shipped to production.</p>&#13;
&#13;
<p>What does it mean to deploy? Well, as you saw in <a data-type="xref" href="ch05.html#ch_containers_subsec_registry">“Internal Docker Registry”</a>, there is a Docker Registry service that is used for storing Docker images and their layers, providing an API to interact with. When you deploy a Docker-based application, you trigger two basic steps. The first step is to upload a copy of the image to the Docker Registry, and the second step is to run a container based on the image. <a data-type="xref" href="#fig_github_travis_heroku">Figure 6-4</a> visually explains this process and how you’ll configure it with Travis and Heroku.</p>&#13;
&#13;
<figure><div class="figure" id="fig_github_travis_heroku">&#13;
<img alt="GitHub notifies Travis CI when changes happen, Travis builds changes, Docker image is pushed to Heroku registry, and Heroku runs an instance of the image" src="assets/dsnj_0604.png"/>&#13;
<h6><span class="label">Figure 6-4. </span>GitHub, Travis CI, and Heroku</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this case, changes to your application’s code living in the <em>master</em> branch on GitHub trigger a call to Travis. Travis sees the updated code and triggers a build. The build will generate a Docker image that gets uploaded to a Docker Registry. In this case, the image is sent to the Docker Registry hosted by Heroku at <a href="https://registry.docker.com"><em class="hyperlink">https://registry.docker.com</em></a>. Once that’s done, Travis tells Heroku to deploy the most recent version of your application’s image. Heroku then works its magic, downloading the image to a server somewhere, before finally running the container.</p>&#13;
&#13;
<p>But before you can build all that, you first need to create a Heroku account and make your first Heroku application.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create a Heroku App" data-type="sect2"><div class="sect2" id="idm46291183631688">&#13;
<h2>Create a Heroku App</h2>&#13;
&#13;
<p>Visit the <a class="orm:hideurl" href="https://heroku.com">Heroku</a> website <a data-primary="Heroku" data-secondary="applications" data-tertiary="creating" data-type="indexterm" id="heroappcreate"/>and create an account. For the purpose of this section, the free account tier is enough to deploy and run your application.</p>&#13;
&#13;
<p>Once you’re logged in to the Heroku site, you should be taken to the <a class="orm:hideurl" href="https://dashboard.heroku.com/apps">dashboard</a> screen. The dashboard will normally list your applications, but at this point you should have none. Click the drop-down menu titled New in the upper-right corner of the screen, then click Create New App.</p>&#13;
&#13;
<p>Now that you’re on the Create New App screen, you’re free to describe your application. Use the information in <a data-type="xref" href="#table_heroku_new_app">Table 6-1</a> to describe your application.</p>&#13;
<table id="table_heroku_new_app">&#13;
<caption><span class="label">Table 6-1. </span>Create a new Docker app</caption>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>App name</p></td>&#13;
<td><p><code>&lt;USERNAME&gt;-distnode</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Region</p></td>&#13;
<td><p>US</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>Pipeline</p></td>&#13;
<td><p>empty</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Heroku gives your application a URL based <a data-primary="Heroku" data-secondary="applications" data-tertiary="URL" data-type="indexterm" id="idm46291183617144"/>on the application name you choose. This URL isn’t namespaced by your account, so if you were to just call the application something like <code>distnode</code>, you would be competing with other readers of this book. This is why you need to add your own namespace using something like your username. Keep track of the name you choose, because you’ll refer to it elsewhere. Your application’s URL will end up looking like this:</p>&#13;
&#13;
<pre data-type="programlisting">https://&lt;USERNAME&gt;-distnode.herokuapp.com/</pre>&#13;
&#13;
<p>Once you’ve described your application, click the Create app button to finish creating your application.</p>&#13;
&#13;
<p>You’ll need another piece of information to interact with Heroku, specifically a string called the Heroku API Key. This string is formatted like a UUID and is useful for authenticating with Heroku from within a script.</p>&#13;
&#13;
<p>To get your Heroku API Key, first <a data-primary="Heroku" data-secondary="API key" data-type="indexterm" id="idm46291183612520"/>click your avatar in the top right corner of the Heroku website. In the drop-down menu that appears, click the Account settings link. Within the <a class="orm:hideurl" href="https://dashboard.heroku.com/account">account settings</a> screen, scroll down to the section titled API Key. By default, the content in this field is hidden. Click the Reveal button to view it. Copy the key for now; you’ll need it soon enough. This key is an important value that you should keep secret. You should never check it into a git repository directly, though you will end up checking in an encrypted version of the <a data-primary="Heroku" data-secondary="applications" data-startref="heroappcreate" data-tertiary="creating" data-type="indexterm" id="idm46291183609880"/>key.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configure Travis CI" data-type="sect2"><div class="sect2" id="idm46291183631096">&#13;
<h2>Configure Travis CI</h2>&#13;
&#13;
<p>Now that you’ve created your <a data-primary="Travis CI" data-secondary="Heroku" data-tertiary="configuring" data-type="indexterm" id="trav_config2"/>Heroku application using the web interface, it’s time to get back into the console. Open up a terminal window and navigate back to your <em>distnode-deploy/</em> directory.</p>&#13;
&#13;
<p>This time, you’re going to work directly in the <em>master</em> branch, pushing changes without creating a pull request. Make sure you’re in the right branch by running the following:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>git checkout master</pre>&#13;
&#13;
<p>The first thing you’re going to do is <a data-primary="Heroku" data-secondary="API key" data-tertiary="encrypting" data-type="indexterm" id="idm46291183580600"/>to encrypt the Heroku API Key that you obtained in the previous section. By encrypting the value, you’ll be able to check it into the repository without the fear of someone stealing it and using it to wreak havoc on your application (or your credit card).</p>&#13;
&#13;
<p>In order to encrypt the value, you’ll need to use the official <code>travis</code> executable. This executable is obtained differently depending on the operating system you’re using. The following commands should help you out. For macOS users, there’s a <code>brew</code> one-liner. For Linux, you might need to first install a dev package like I did before being able to install the <code>travis</code> gem package. Try these commands to get the executable installed:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="c">### macOS</code>&#13;
<code class="nv">$ </code>brew install travis&#13;
&#13;
<code class="c">### Debian / Ubuntu Linux</code>&#13;
<code class="nv">$ </code>ruby --version <code class="c"># `sudo apt install ruby` if you don't have Ruby</code>&#13;
<code class="nv">$ </code>sudo apt-get install ruby2.7-dev <code class="c"># depending on Ruby version</code>&#13;
<code class="nv">$ </code>sudo gem install travis</pre>&#13;
&#13;
<p>Documentation on how to install the Travis executable is <a class="orm:hideurl" href="https://github.com/travis-ci/travis.rb">readily available online</a> if these commands don’t work out. Once you have the tool installed, you’re now ready to encrypt the Heroku API Key that you obtained earlier for use as an environment variable within the Travis deployment script. Run the following commands to first log in to your Travis account using your GitHub <a data-primary="environment variables" data-secondary="encrypted" data-type="indexterm" id="idm46291183590024"/><a data-primary="encrypted environment variables" data-type="indexterm" id="idm46291183589176"/>credentials and then to generate the encrypted environment variable:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>travis login --pro --auto-token&#13;
<code class="nv">$ </code>travis encrypt --pro <code class="nv">HEROKU_API_KEY</code><code class="o">=</code>&lt;YOUR_HEROKU_API_KEY&gt;</pre>&#13;
&#13;
<p>The <code>--pro</code> arguments tell the Travis executable that you’re using a <em>travis-ci.com</em> account, as opposed to a self-hosted version.</p>&#13;
&#13;
<p>Keep track of the output <a data-primary="Travis CI" data-secondary="travis encrypt command" data-type="indexterm" id="idm46291183543800"/><a data-primary="commands" data-secondary="travis encrypt" data-type="indexterm" id="idm46291183561176"/>from the <code>travis encrypt</code> command. You’ll need to add it soon. The output string specifically locks the key and value together. By looking at the encrypted value, you can’t even tell that the environment variable name is <span class="keep-together"><code>HEROKU_API_KEY</code></span>.</p>&#13;
&#13;
<p>Now that you’ve got the encrypted environment variable, you’re ready to make some additional changes to the <em>.travis.yml</em> that you created previously. Open the file and append the content in <a data-type="xref" href="#ex_heroku_travisyml">Example 6-8</a> to the end of the file.</p>&#13;
<div data-type="example" id="ex_heroku_travisyml">&#13;
<h5><span class="label">Example 6-8. </span><em>distnode-deploy/.travis.yml</em> (amended)</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">deploy</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">provider</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">script</code><code>&#13;
</code><code>  </code><code class="nt">script</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">bash</code><code class="l-Scalar-Plain"> </code><code class="l-Scalar-Plain">deploy-heroku.sh</code><code> </code><a class="co" href="#callout_deployments_CO4-1" id="co_deployments_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>  </code><code class="nt">on</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">branch</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">master</code><code> </code><a class="co" href="#callout_deployments_CO4-2" id="co_deployments_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="nt">env</code><code class="p">:</code><code> </code><a class="co" href="#callout_deployments_CO4-3" id="co_deployments_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>  </code><code class="nt">global</code><code class="p">:</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_deployments_CO4-1" id="callout_deployments_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The docker image will be built.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO4-2" id="callout_deployments_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <em>master</em> branch will run <em>deploy-heroku.sh</em>.</p></dd>&#13;
<dt><a class="co" href="#co_deployments_CO4-3" id="callout_deployments_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>The encrypted environment variable will go here.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>This configures the <code>deploy</code> section of the file. Travis CI offers several different <em>provider</em> options, which are integrations with third-party services. In this case, you’re using the <em>script</em> provider, which allows you to manually run shell commands. All together, this configuration tells Travis to run the <em>deploy-heroku.sh</em> script when changes are made to the <em>master</em> branch.</p>&#13;
&#13;
<p>The other section being configured here is the <code>env</code> section, though technically you haven’t yet added an entry. Take the output from the <code>travis encrypt</code> command and add it to <em>.travis.yml</em>. It should be on a line of its own, starting with four spaces, &#13;
<span class="keep-together">followed</span> by a hyphen, another space, and then the word “<code>secure:</code>” and the long encrypted string surrounded in quotes. The <em>env</em> section in your file should now resemble the following:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">env</code><code class="p">:</code>&#13;
  <code class="nt">global</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="nt">secure</code><code class="p">:</code> <code class="s">"LONG</code><code class="nv"> </code><code class="s">STRING</code><code class="nv"> </code><code class="s">HERE"</code></pre>&#13;
&#13;
<p>You also need to create a Dockerfile. For this <a data-primary="Docker" data-secondary="Dockerfile" data-tertiary="Heroku and" data-type="indexterm" id="idm46291183430504"/><a data-primary="Heroku" data-secondary="Dockerfile" data-type="indexterm" id="idm46291183429416"/>example, you can just use a variation of the basic Dockerfile you created in previous sections. One thing that makes it different is that this Dockerfile sets a default <code>HOST</code> environment variable to <code>0.0.0.0</code>. Add the content from <a data-type="xref" href="#ex_docker_dockerfile">Example 6-9</a> to get your application ready to run.</p>&#13;
<div data-type="example" id="ex_docker_dockerfile">&#13;
<h5><span class="label">Example 6-9. </span><em>distnode-deploy/Dockerfile</em></h5>&#13;
&#13;
<pre data-type="programlisting">FROM node:14.8.0-alpine3.12&#13;
WORKDIR /srv&#13;
COPY package*.json ./&#13;
RUN npm ci --only=production&#13;
COPY . .&#13;
ENV HOST=0.0.0.0&#13;
CMD [ "node", "server.js" ]</pre></div>&#13;
&#13;
<p>Now that your <em>.travis.yml</em> file is configured and your Dockerfile is finished, you’re ready to work on deploying your application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploy Your Application" data-type="sect2"><div class="sect2" id="idm46291183607640">&#13;
<h2>Deploy Your Application</h2>&#13;
&#13;
<p>In the previous section, you added a reference to a shell script named <em>deploy-heroku.sh</em> to your <em>.travis.yml</em> file. Now you’re ready to add the content for this file. Create the file and add the content from <a data-type="xref" href="#ex_docker_push_script">Example 6-10</a> to it. Note that you’ll need to change the two <code>--app &lt;USERNAME&gt;-distnode</code> flags to use the name of your Heroku application that you chose previously.</p>&#13;
<div data-type="example" id="ex_docker_push_script">&#13;
<h5><span class="label">Example 6-10. </span><em>distnode-deploy/deploy-heroku.sh</em></h5>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="c">#!/bin/bash</code>&#13;
wget -qO- https://toolbelt.heroku.com/install-ubuntu.sh <code class="p">|</code> sh&#13;
heroku plugins:install @heroku-cli/plugin-container-registry&#13;
heroku container:login&#13;
heroku container:push web --app &lt;USERNAME&gt;-distnode&#13;
heroku container:release web --app &lt;USERNAME&gt;-distnode</pre></div>&#13;
&#13;
<p>This file uses another CLI utility called <code>heroku</code>. This utility <a data-primary="Heroku" data-secondary="CLI utility" data-type="indexterm" id="idm46291183408264"/>allows you to configure your Heroku applications from the command line. It’s available for install on your local development machine, but in this case, it’s being run in an automated fashion on a Travis CI build server. The command doesn’t already exist on Travis, so the first <code>wget</code> command installs it. The second command installs an additional plug-in that allows <code>heroku</code> to manage Docker containers.</p>&#13;
&#13;
<p>The <code>heroku container:login</code> subcommand instructs <code>heroku</code> to log in to the Docker Registry hosted by Heroku. This command will look for an environment variable named <code>HEROKU_API_KEY</code> in order to log in (otherwise, it will prompt for login credentials). That value is provided by the encrypted environment variable you configured previously.</p>&#13;
&#13;
<p>The <code>heroku container:push</code> command does two things. First, it builds a Docker image based on the Dockerfile in the current directory. Next, it pushes that image to the Docker Registry.</p>&#13;
&#13;
<p>Finally, the <code>heroku container:release</code> command is what tells the Heroku service to perform an actual release. This results in the server pulling the image from the Docker Registry, running a new container, switching traffic to your URL from the old container to the new container, and then destroying the old container. These few short commands result in a lot of work being run behind the scenes.</p>&#13;
&#13;
<p>Now that you’ve finished making the necessary file changes, you’re ready to trigger a deployment. Add the files you’ve changed to git, commit them, and then push. You can do this by running the following commands:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>git add .&#13;
<code class="nv">$ </code>git commit -m <code class="s2">"Enabling Heroku deployment"</code>&#13;
<code class="nv">$ </code>git push</pre>&#13;
&#13;
<p>At this point, you’ve triggered the build pipeline. This can take a minute or two to deploy. Since it’s not immediate, you can attempt to view the process while it’s &#13;
<span class="keep-together">happening.</span></p>&#13;
&#13;
<p>First, return to the <a class="orm:hideurl" href="https://travis-ci.com/dashboard">Travis CI dashboard</a> screen, where you will see a list of your repositories. Then, click the entry for your project’s repository.</p>&#13;
&#13;
<p>The repository screen has a few tabs, with the default tab you’re currently looking at called Current. Click the second tab, titled Branches, to view a list of branches. This list of branches shows the various branches that Travis has seen and has built. You should see two branches listed, the first being the <em>master</em> branch that’s now being built and the second being the <em>feature-1</em> branch that previously represented the pull request you made. <a data-type="xref" href="#fig_travis_branches">Figure 6-5</a> is what my branch list looks like for my project. Yours should look a little simpler because I’ve run more than one build for my <em>master</em> branch.</p>&#13;
&#13;
<figure><div class="figure" id="fig_travis_branches">&#13;
<img alt="A list of branches in the Travis project" src="assets/dsnj_0605.png"/>&#13;
<h6><span class="label">Figure 6-5. </span>Travis branch list</h6>&#13;
</div></figure>&#13;
&#13;
<p>Click on the build number link next to the <em>master</em> branch. In my case, the link is titled “# 25 received”; you should see a different number, and depending on how quickly you clicked, you might see different text like “# 5 passed.” This will take you to the build details screen.</p>&#13;
&#13;
<p>On this screen, you should again see an overview of the build process. The screen will look a little different from when you previously looked at the pull request builds on Travis. For example, this screen lists the new environment variable that you created. In this case, it should list <code>HEROKU_API_KEY=[secure]</code>, signaling that the value is present and has been encrypted. <a data-type="xref" href="#fig_travis_master">Figure 6-6</a> is what I see on my screen.</p>&#13;
&#13;
<figure><div class="figure" id="fig_travis_master">&#13;
<img alt="Travis build status of the master branch" src="assets/dsnj_0606.png"/>&#13;
<h6><span class="label">Figure 6-6. </span>Travis branch list</h6>&#13;
</div></figure>&#13;
&#13;
<p>At this point, the job log should be displaying updates as the build process writes content to the console. In this output is a new section titled Deploying application. If you expand this section, you should see the output from the various Docker commands being executed on Travis by the <code>heroku</code> executable. Eventually you should see the following message displayed:</p>&#13;
&#13;
<pre data-type="programlisting">Releasing images web to &lt;USERNAME&gt;-distnode... done</pre>&#13;
&#13;
<p>Note that the Travis CI interface expands and collapses sections as the build stage changes, so you might need to go back to expand the section, or even wait until the section is available if you opened the page too early in the build process.</p>&#13;
&#13;
<p>Once that message has been displayed, your application is now ready and running in production. Open a new tab in your browser and navigate to the following URL, adapting it to match your Heroku application name:</p>&#13;
&#13;
<pre data-type="programlisting">https://&lt;USERNAME&gt;-distnode.herokuapp.com/</pre>&#13;
&#13;
<p>If all goes to plan, you should see the <a data-primary="Travis CI" data-secondary="Heroku" data-startref="trav_config2" data-tertiary="configuring" data-type="indexterm" id="idm46291183341240"/>message “Hello from Distributed Node.js!” displayed in your browser window.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46291183339464">&#13;
<h5>Alternatives to Heroku</h5>&#13;
<p>If your organization runs on AWS, you might consider using AWS Elastic Container Service (ECS). Or, if you’re using Google Cloud, take a look at using Google Compute Engine. Both of these are cloud services for running Docker containers.</p>&#13;
&#13;
<p>For a more bare-bones approach, the <em>deploy-heroku.sh</em> file could have run an SSH command to tell a remote <a data-primary="deployments" data-secondary="Heroku" data-startref="dep_hero" data-type="indexterm" id="idm46291183337016"/>server with the Docker daemon running to pull and restart a running container.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Modules, Packages, and SemVer" data-type="sect1"><div class="sect1" id="ch_deployments_sec_guts">&#13;
<h1>Modules, Packages, and SemVer</h1>&#13;
&#13;
<p>Node.js applications can get complex. While it’s technically possible to run everything in a single massive file, and goodness knows some of my earliest projects were built this way, an application must be broken up into smaller files to avoid driving developers insane. Developers are able to better focus on a smaller part of a complex codebase if code is properly isolated to individual files. Smaller files also help avoid collisions when multiple developers are making changes to a project in version control. This is what modules are for.</p>&#13;
&#13;
<p>Code will sometimes need to be reused between multiple applications. When this happens, the code is converted into a package. Such code reuse typically falls into two categories. In the first category, a package is so generic that it is beneficial to other organizations. In the second category, the package may contain trade secrets or is otherwise only beneficial to the organization that wrote it, but it may still be beneficial to multiple applications within the organization. Either way, these packages will need to be versioned and published.</p>&#13;
&#13;
<p>But before diving into the complexities of packaging, it’s time to get a solid understanding of modules as they’re implemented in Node.js.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Node.js Modules" data-type="sect2"><div class="sect2" id="ch_deployments_sec_guts_subsec_modules">&#13;
<h2>Node.js Modules</h2>&#13;
&#13;
<p>Node.js supports two different <a data-primary="modules" data-type="indexterm" id="mods"/><a data-primary="modules" data-secondary="CommonJS" data-type="indexterm" id="idm46291183308408"/><a data-primary="CommonJS module" data-type="indexterm" id="idm46291183307464"/><a data-primary="modules" data-secondary="ECMAScript" data-type="indexterm" id="idm46291183306792"/><a data-primary="ECMAScript module" data-type="indexterm" id="idm46291183305848"/>module formats. The first format is the <a class="orm:hideurl" href="https://nodejs.org/api/modules.html"><em>CommonJS module</em></a> and is the format that Node.js has adopted since its beginning. The second format is the <a class="orm:hideurl" href="https://nodejs.org/api/esm.html"><em>ECMAScript module</em></a> (ESM), a format that has been under heavy development in recent years and should eventually bridge the gap between JavaScript that runs in the browser and JavaScript that runs in Node.js. It is very likely that one day most application code will be written using ESM, but as of Node.js v14.8, ECMAScript modules are still marked as experimental—a designation meaning backward-breaking changes can still be made. For this reason, this section—and this book—focuses on CommonJS modules.</p>&#13;
&#13;
<p>A Node.js module is a <a data-primary="modules" data-secondary="versus JavaScript files" data-type="indexterm" id="idm46291183301912"/>JavaScript file that has either been directly executed or otherwise required by a Node.js process. JavaScript files being run in this manner differ from vanilla JavaScript files being run in a web browser. This is mostly due to Node.js adhering to CommonJS. With CommonJS, functionality is exported by the use of an object named <code>exports</code>, and functionality is imported using a function named <code>require</code>. Neither of these features are a core part of the JavaScript language<sup><a data-type="noteref" href="ch06.html#idm46291183299560" id="idm46291183299560-marker">4</a></sup> and are instead introduced by the Node.js runtime.</p>&#13;
&#13;
<p>Another thing that makes Node.js modules different from browser JavaScript is that if you declare a variable first thing in a JavaScript file, such as <code>var foo = <em>bar</em></code>, that value won’t become a global variable. Instead, it will only be accessible in the current file. The reason Node.js modules work this way is because Node.js automatically wraps each JavaScript file in the following function declaration:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">exports</code><code class="p">,</code> <code class="nx">require</code><code class="p">,</code> <code class="nx">module</code><code class="p">,</code> <code class="nx">__filename</code><code class="p">,</code> <code class="nx">__dirname</code><code class="p">)</code> <code class="p">{</code>&#13;
<code class="c1">// File contents go here</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>This <a class="orm:hideurl" href="https://nodejs.org/api/modules.html#modules_the_module_wrapper">wrapper</a> makes a few things convenient for application developers. Most importantly, it provides <code>exports</code> and <code>require</code>, which are required by the CommonJS standard. Both <code>__filename</code> and <code>__dirname</code> are strings that make it convenient to know where your file is located. Both of them are absolute paths. The <code>require</code> function is also an object with several properties attached to it. Note that Node.js also removes the shebang line, if present, before wrapping the file.</p>&#13;
&#13;
<p>The <code>module</code> object contains <a data-primary="module object" data-type="indexterm" id="idm46291183274792"/><a data-primary="objects" data-secondary="module" data-type="indexterm" id="idm46291183274056"/>several properties as well and is used to describe the current Node.js module. The <code>exports</code> function wrapper argument is a reference to the <code>module.exports</code> property. The <code>__filename</code> variable is a convenient reference to <span class="keep-together"><code>module.filename</code></span>, while <code>__dirname</code> is a convenience for <code>path.dirname(__filename)</code>.</p>&#13;
&#13;
<p>With this information, you can check to see if the current module happens to be the application entry point with <code>require.main === module</code>. I’ve seen this used when testing a <em>server.js</em> file; if the module is the entry point, then start the server. If it is not the entry point, export the server instance so that tests can interact with it.</p>&#13;
&#13;
<p>It is possible, though almost universally frowned-upon, to set globals within Node.js. The V8 engine provides two references to the global object: the newer <code>globalThis</code> and the older <code>global</code>. Browsers have two references to their global object: the newer <code>globalThis</code> and the older <code>window</code>. Of course, Node.js applications don’t really have a concept of a “window,” so <code>global</code> is used. Due to the popularity of sharing JavaScript files between server and browser, <code>globalThis</code> was created to bridge the gap.</p>&#13;
&#13;
<p>The <code>require()</code> function is <a data-primary="require() function" data-type="indexterm" id="req_func"/><a data-primary="functions" data-secondary="require()" data-type="indexterm" id="req_func1"/>something that you’ve likely used many times by now. But sometimes it might not behave quite the way you would expect it to. It turns out there’s quite a bit of complexity involved when Node.js attempts to load a module when you call this function, a process using the <a class="orm:hideurl" href="https://nodejs.org/api/modules.html#modules_all_together">module resolution algorithm</a>. There’s a lot to it, but here are a few examples of what happens when you call <code>require(mod)</code>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If <em>mod</em> is the name of a core Node.js module (like <code>fs</code>), then load it.</p>&#13;
</li>&#13;
<li>&#13;
<p>If <em>mod</em> starts with “<code>/</code>”, “<code>./</code>”, or “<code>../</code>”, load the resolved path to the file or directory.</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If a directory is loaded, look for a <em>package.json</em> file with a <code>main</code> field and load that file.</p>&#13;
</li>&#13;
<li>&#13;
<p>If a directory doesn’t contain a <em>package.json</em>, try to load <em>index.js</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If loading a file, try to load the exact filename, then fall back to adding file extensions <em>.js</em>, <em>.json</em>, and <em>.node</em> (native module).</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
<li>&#13;
<p>Look for a directory in <em>./node_modules</em> matching the <em>mod</em> string.</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Look for a <em>node_modules</em> directory in each<a data-primary="node_modules/ directory" data-type="indexterm" id="idm46291183223624"/> parent directory until the root directory is encountered.</p>&#13;
</li>&#13;
</ul>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>As I mentioned, it’s a bit complex. <a data-type="xref" href="#table_example_module_resolution">Table 6-2</a> shows some examples of <code>require()</code> calls and where the Node.js runtime will look for matching files. This assumes the <code>require()</code> is happening within a file at <em>/srv/server.js</em>.</p>&#13;
<table id="table_example_module_resolution">&#13;
<caption><span class="label">Table 6-2. </span>Module resolution within <em>/srv/server.js</em></caption>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>require('url')</code></p></td>&#13;
<td><p>Core <em>url</em> module</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>require('./module.js')</code></p></td>&#13;
<td><p><em>/srv/module.js</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>require('left-pad')</code></p></td>&#13;
<td><p><em>/srv/node_modules/left-pad/</em>, <em>/node_modules/left-pad/</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>require('foo.js')</code></p></td>&#13;
<td><p><em>/srv/node_modules/foo.js/</em>, <em>/node_modules/foo.js/</em></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>require('./foo')</code></p></td>&#13;
<td><p><em>/srv/foo.js</em>, <em>/srv/foo.json</em>, <em>/srv/foo.node</em>, <em>/srv/foo/index.js</em></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>One thing that’s tricky about the examples is the <code>require('foo.js')</code> call. It appears to be a reference to a JavaScript file, but it actually ends up looking for a directory named <em>foo.js/</em> within <em>node_modules</em> directories.</p>&#13;
&#13;
<p>When it comes to requiring files, it’s generally better to be explicit and provide the file extension than to omit it. This can actually cause bugs that might be hard to catch. For example, if a directory contains a <em>contacts.js</em> file <a data-primary="JSON" data-secondary="contacts.json file" data-type="indexterm" id="idm46291183202520"/>and a <em>contacts.json</em> file, a <code>require('./contacts')</code> call will correctly load the <em>contact.js</em> file. But when a refactor happens and the <em>contacts.js</em> file is removed, the <em>contacts.json</em> file will then be loaded. This may then cause a bug at runtime.</p>&#13;
&#13;
<p>When modules are loaded within a running Node.js process, they get added to something called the <em>require cache</em>. The <a data-primary="modules" data-secondary="require cache" data-type="indexterm" id="idm46291183198056"/><a data-primary="require cache" data-type="indexterm" id="idm46291183197048"/><a data-primary="node_modules/ directory" data-type="indexterm" id="idm46291183196376"/>cache is located at <code>require.cache</code> and is available to every module. The cache is an object where the keys are the absolute path to a file and the values are a “Module” object. The <code>module</code> variable is also a Module object. Among other things, these Module objects contain a property called <code>exports</code>, which is a reference to the module’s exported functionality.</p>&#13;
&#13;
<p>This module cache is important. When a call to <code>require()</code> is made and the path to the file to be loaded has been resolved, Node.js will first consult with the require cache. If a matching entry is encountered, that entry will be used. Otherwise, if the file is being loaded for the first time, the file will be read from disk and evaluated. This is how Node.js prevents a dependency that was loaded multiple times from being <a data-primary="require() function" data-startref="req_func" data-type="indexterm" id="idm46291183192824"/><a data-primary="functions" data-secondary="require()" data-startref="req_func1" data-type="indexterm" id="idm46291183191848"/>executed multiple times.</p>&#13;
&#13;
<p>Now that you know a bit more about Node.js modules, you’re just about ready to learn about npm packages. But before you do that, take a look at something called SemVer. This is a very important <a data-primary="modules" data-startref="mods" data-type="indexterm" id="idm46291183189912"/>concept when it comes to working with npm &#13;
<span class="keep-together">packages.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SemVer (Semantic Versioning)" data-type="sect2"><div class="sect2" id="ch_deployments_sec_guts_subsec_semver">&#13;
<h2>SemVer (Semantic Versioning)</h2>&#13;
&#13;
<p><em>SemVer</em> is short for <a class="orm:hideurl" href="https://semver.org">Semantic Versioning</a>. It’s a philosophy used for <a data-primary="deployments" data-secondary="SemVer" data-type="indexterm" id="dep_semver"/><a data-primary="SemVer (Semantic Versioning)" data-type="indexterm" id="idm46291183183288"/><a data-primary="versioning" data-seealso="SemVer" data-type="indexterm" id="idm46291183182648"/>deciding the version number to attach to dependencies as they are updated and released. SemVer &#13;
<span class="keep-together">is used</span> by many different package management platforms and is relied on heavily &#13;
<span class="keep-together">by npm.</span></p>&#13;
&#13;
<p>A SemVer version is primarily made up of three separate numbers, such as 1.2.3. The first number is called the major version, the second number is the minor version, and the third number is the patch version. Additional information about pre-releases can be described by appending a hyphen and an additional string after the version string. However, production applications don’t usually use such pre-releases, so it won’t be covered here.</p>&#13;
&#13;
<p>Each component of the overall <a data-primary="SemVer (Semantic Versioning)" data-secondary="version numbers" data-type="indexterm" id="idm46291183179080"/>version number has a special meaning. When a package makes a change that breaks backwards compatibility, the major version should be incremented. When a package adds a new feature but backwards compatibility is maintained, the minor version should be incremented. If a change only results in a bug fix and nothing else, then the patch version should be incremented. Whenever a version is incremented, the lower versions reset at zero. For example, if a major change is introduced to a package at version 1.2.3, it should become 2.0.0 (not 2.2.3). If a release of a package introduces multiple changes, then the effects of the most significant change determine the new version number.</p>&#13;
&#13;
<p>What does it mean to make a backwards-breaking change or add a new feature? Well, every package needs to not only provide functionality, but it also needs to document its functionality. This documented functionality is a contract made between the package author and anyone who chooses to use the package. Violations of this contract will result in pull requests, angry GitHub issues, and forks that outlive the original package. It’s the responsibility of every engineer who publishes a package to adhere to SemVer and to uphold their documented feature list.</p>&#13;
&#13;
<p>A special case for SemVer is when the most significant digits of a version number begin with zero. In these cases, the first nonzero digit is essentially considered the major version, the next digit is the minor, etc. What this means is that if a breaking change is introduced to a package at version 0.1.2, it becomes version 0.2.0. If a package has the version of 0.0.1, then any breaking changes can result in a version of 0.0.2.</p>&#13;
&#13;
<p>A package author is <a data-primary="packages" data-secondary="version numbers" data-type="indexterm" id="idm46291183175016"/>free to arbitrarily increment any of the version numbers at any point in time. For example, if a package is on version 0.0.7 and a significant milestone is reached, the author may increment it to 0.1.0. Generally, once an author has determined that a package is ready for production, the package will graduate to a version of 1.0.0.</p>&#13;
&#13;
<p>The real power of SemVer is that an application making use of a package should be free to blindly accept all minor or patch updates of a package without any fears that their application might break. In practice, authors of npm packages aren’t always so disciplined, which is why any updates to an application’s dependencies will require that a test suite pass is run. In many cases, the application author may need to interact with the application to make sure it continues to work as intended.</p>&#13;
&#13;
<p>Dependencies are specified <a data-primary="dependencies" data-secondary="SemVer and" data-type="indexterm" id="idm46291183171992"/><a data-primary="SemVer (Semantic Versioning)" data-secondary="dependencies" data-type="indexterm" id="idm46291183171016"/>for a Node.js project using the <code>dependencies</code> section of the <em>package.json</em> file. When running <code>npm install</code> or <code>yarn</code>, this list of dependencies is consulted when determining which packages to copy from the npm registry to the local filesystem. Package versions can be specified directly, or they can make use of a prefix. They can even make use of more complex syntax such as verbose version ranges and asterisks, but that won’t be covered here. The following is an example of some dependency strings:</p>&#13;
&#13;
<pre data-code-language="json" data-type="programlisting"><code class="s2">"dependencies"</code><code class="err">:</code> <code class="p">{</code>&#13;
  <code class="nt">"fastify"</code><code class="p">:</code> <code class="s2">"^2.11.0"</code><code class="p">,</code>&#13;
  <code class="nt">"ioredis"</code><code class="p">:</code> <code class="s2">"~4.14.1"</code><code class="p">,</code>&#13;
  <code class="nt">"pg"</code><code class="p">:</code> <code class="s2">"7.17.1"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The first package loaded in this list, <code>fastify</code>, has a version prefix of <code>^</code> (caret). What this means is that any future version of the package that is compatible with the specified version will be installed. For example, at install time, if version 2.11.1 is the most recent, that will be used. Or if version 2.17.0 is the most recent, that will be used instead. If version 3.0.0 is available, it will not be used. The caret prefix is the default prefix given when running an <code>npm install</code> command. For this <a data-primary="npm install commands" data-secondary="caret prefix" data-type="indexterm" id="idm46291183146920"/>reason, it is vital that every package adheres with SemVer. Otherwise, many applications may break when sloppy updates are made to an npm package.</p>&#13;
&#13;
<p>The next package, <code>ioredis</code>, will only accept package updates that contain bug fixes (patch updates). It may be upgraded to 4.14.2 but never to 4.15.1. This is a more conservative way to install a package. The third package, <code>pg</code>, will only ever install the 7.17.1 version of the package. This is even more conservative.</p>&#13;
&#13;
<p>Now it’s time for a thought experiment. Pretend that you’re the author of a package that exposes a single class. This package is only used by teams within your organization. This version of your package, 1.0.0, only contains three methods, each of which are documented. The package looks like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="kr">class</code> <code class="nx">Widget</code> <code class="p">{</code>&#13;
  <code class="nx">getName</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">setName</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nx">name</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">nameLength</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>At some point, you discover that some users pass a number into the <code>setName()</code> method, which later causes a bug with the <code>nameLength()</code> method. What version number would you pick if you were to modify the <code>setName()</code> method in the following manner:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">setName</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">this</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="nb">String</code><code class="p">(</code><code class="nx">name</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>At some point, you decide to add a method to check if the name has been set. You do this by adding an additional method named <code>hasName()</code>. What version number would you pick if you did this by adding the following method:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">hasName</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="o">!!</code><code class="k">this</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Finally, you realize that the <code>nameLength()</code> method might be a bit unnecessary. You ask all of the teams within your organization that rely on your package if they are using the method, and everybody tells you no. So you decide to remove <span class="keep-together">the <code>nameLength()</code></span> method entirely. What version should you then choose for your &#13;
<span class="keep-together">package?</span></p>&#13;
&#13;
<p>In the first example, the modification to the <code>setName()</code> method is considered a bug fix. This should result in a patch change, and a new version of 1.0.1. In the second example, the addition of a <code>hasName()</code> method adds new functionality. The code is nearly 100% backwards compatible with the previous version. This means the change is a minor change and should have a version number of 1.1.0. Finally, the third example removes functionality. Sure, you spoke with every team that makes use of your package and determined that nobody is using the functionality. But this fact only signals that it is okay to make the change; it does not mean that the change still isn’t a big deal. For this reason, the change is major and the package version should be 2.0.0.</p>&#13;
&#13;
<p>These examples illustrate the most basic of situations you’ll have to deal with when making version updates to your packages. In practice, you’ll often have to deal with much harder problems. For example, say that you export a class that is an instance of a Node.js <code>EventEmitter</code>. This <a data-primary="EventEmitter class" data-type="indexterm" id="idm46291183040504"/>class represents a bucket that can have water added to it and emits several <a data-primary="ready event" data-type="indexterm" id="idm46291183039640"/><a data-primary="empty event" data-type="indexterm" id="idm46291183038968"/><a data-primary="full event" data-type="indexterm" id="idm46291183038296"/><a data-primary="events" data-secondary="ready" data-type="indexterm" id="idm46291183037624"/><a data-primary="events" data-secondary="empty" data-type="indexterm" id="idm46291182989848"/><a data-primary="events" data-secondary="full" data-type="indexterm" id="idm46291182988904"/>events, including <code>ready</code>, <code>empty</code>, and <code>full</code>. In version 1.0.0 of your package, the <code>empty</code> event is emitted immediately <em>before</em> the <code>ready</code> event. But you do some refactoring and pondering and change the package to emit <code>empty</code> <em>after</em> the <code>ready</code> event. What SemVer version change would you expect this to result in? Is it just a bug fix? Is it a new feature? Is it backwards breaking?</p>&#13;
&#13;
<p>In these situations, it’s often better to err on the side of a more significant version change. If you release this change as a patch change, it could cause production bugs and cause people to find their water buckets overflowing. However, if you release it as a major change, engineers will need to manually upgrade and should then consult your release notes. At this point, they can audit their application code to determine if any application code changes must accompany the dependency upgrade.</p>&#13;
&#13;
<p>Packages can also have <a data-primary="packages" data-secondary="dependencies" data-tertiary="packages as" data-type="indexterm" id="idm46291182982840"/><a data-primary="dependencies" data-secondary="packages as" data-type="indexterm" id="idm46291182981560"/>other packages as dependencies. These are often referred to as subdependencies. Sometimes, if a package upgrades a subdependency from one major version to another, it will require that the package itself receives an increment to its major version. This can happen if a subdependency updates its required Node.js version. For example, if package A @ 1.2.3 depends on B @ 5.0.0, and package B @ 6.0.0 drops support for Node.js v10, then package A would need to increment its version to 2.0.0. Otherwise, if a change to a subdependency doesn’t have any public side effects, less severe SemVer version bumps can be made.</p>&#13;
&#13;
<p>It may be tempting to assign SemVer versions to an application, but often this just doesn’t work out. For example, if you’re working on a web application and you change the background from red to pink, is this a minor change? Is it a patch change? Things like UX changes don’t easily translate to the SemVer paradigm. Deciding &#13;
<span class="keep-together">on API endpoint</span> versions is a completely different beast where SemVer is also not &#13;
<span class="keep-together">applicable.</span></p>&#13;
&#13;
<p>Now that you’re a little more familiar with the nuances of SemVer, it’s time to look at npm package <a data-primary="deployments" data-secondary="SemVer" data-startref="dep_semver" data-type="indexterm" id="idm46291182977320"/>development.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="npm Packages and the npm CLI" data-type="sect2"><div class="sect2" id="ch_deployments_sec_guts_subsec_npm">&#13;
<h2>npm Packages and the npm CLI</h2>&#13;
&#13;
<p>An npm package is a collection <a data-primary="npm packages" data-secondary="npm CLI and" data-type="indexterm" id="idm46291182956584"/><a data-primary="npm CLI" data-type="indexterm" id="idm46291182955736"/>of Node.js modules and other supporting files that have been combined into a single tarball file. This tarball file can be uploaded to a registry, such as the <a class="orm:hideurl" href="https://npmjs.com">public npm registry</a>, a private registry, or even distributed as a tarball for manual installation.<sup><a data-type="noteref" href="ch06.html#idm46291182953960" id="idm46291182953960-marker">5</a></sup> In any case, the <code>npm</code> CLI can install these packages into the <em>node_modules/</em> directory <a data-primary="node_modules/ directory" data-type="indexterm" id="idm46291182952456"/>of a particular project.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46291182951624">&#13;
<h5>A Note on Yarn</h5>&#13;
<p>CoffeeScript “succeeded” by inspiring ES6 and rendering itself mostly obsolete. Likewise, the <em>io.js</em> fork was merged back into Node.js core where it continued on as Node.js v4. Yarn began as a faster npm and led to speed improvements in npm v4 and v5. There’s a few features that Yarn still supports but that the npm CLI doesn’t, much like CoffeeScript still has some features missing in JavaScript. Time will tell which package manager will prevail, but with npm being more established, the examples in this section will use npm. Feel free to look up the equivalent commands if you prefer to use Yarn.</p>&#13;
</div></aside>&#13;
&#13;
<p>The Node.js runtime doesn’t technically know what an npm package is. In fact, the <code>dependencies</code> section of an application’s <em>package.json</em> file isn’t even consulted by the Node.js runtime. But Node.js does know how to require packages located within the <em>node_modules/</em> directory. It’s ultimately up to the npm CLI to perform the task of &#13;
<span class="keep-together">taking</span> an application’s list of dependencies and converting that into a filesystem &#13;
<span class="keep-together">hierarchy.</span></p>&#13;
&#13;
<p>Node.js has a tiny standard library, much smaller than many other languages. There’s no official “kitchen sink” package to provide the basic functionality required by many applications. The Node.js motto is to keep as many features out of the core platform as possible, instead deferring to the community to build such functionality and publish it as npm packages. For example, there is no built-in mechanism for generating UUID values, but there are dozens of implementations available on npm. Node.js only provides the core functionality that these packages depend on, such as <code>crypto.randomBytes()</code>.</p>&#13;
&#13;
<p>Because of the decision to keep core Node.js small, most security vulnerabilities for a given Node.js application will require an update to an npm package instead of an upgrade of the Node.js runtime. This usually results in quicker turn-around for security fixes. Another effect is that many JavaScript developers have published many packages. The npm registry is the world’s largest software package repository. A package exists for almost anything a developer needs, which has contributed to the popularity of Node.js.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Controlling package content" data-type="sect3"><div class="sect3" id="idm46291182943128">&#13;
<h3>Controlling package content</h3>&#13;
&#13;
<p>Now that you’re familiar with <a data-primary="npm packages" data-secondary="npm CI and" data-tertiary="package content" data-type="indexterm" id="idm46291182941096"/><a data-primary="npm CLI" data-secondary="package content and" data-type="indexterm" id="idm46291182939880"/>some of the theory behind npm packages, it’s time that you create one. Run the following commands to create a new directory for your package and to initialize a <em>package.json</em> file. When prompted, set the version to 0.1.0 but otherwise leave the default values:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting"><code class="nv">$ </code>mkdir leftish-padder <code class="o">&amp;&amp;</code> <code class="nb">cd </code>leftish-padder&#13;
<code class="nv">$ </code>npm init&#13;
<code class="c"># set version to: 0.1.0</code>&#13;
<code class="nv">$ </code>touch index.js README.md foo.js bar.js baz.js&#13;
<code class="nv">$ </code>mkdir <code class="nb">test</code> <code class="o">&amp;&amp;</code> touch <code class="nb">test</code>/index.js&#13;
<code class="nv">$ </code>npm install --save express@4.17.1&#13;
<code class="nv">$ </code>dd <code class="k">if</code><code class="o">=</code>/dev/urandom <code class="nv">bs</code><code class="o">=</code><code class="m">1048576</code> <code class="nv">count</code><code class="o">=</code><code class="m">1</code> <code class="nv">of</code><code class="o">=</code>screenshot.bin&#13;
<code class="nv">$ </code>dd <code class="k">if</code><code class="o">=</code>/dev/urandom <code class="nv">bs</code><code class="o">=</code><code class="m">1048576</code> <code class="nv">count</code><code class="o">=</code><code class="m">1</code> <code class="nv">of</code><code class="o">=</code>temp.bin</pre>&#13;
&#13;
<p>You now have a directory structure similar to many npm packages. <em>screenshot.bin</em> represents a file that should be uploaded to a version control repository (for example, to provide a screenshot in a GitHub repository’s <em>README.md</em> file), though it shouldn’t actually be made part of an npm package. <em>temp.bin</em> represents a side-effect file that shouldn’t be checked into version control or packaged at all. The remaining JavaScript files should be checked in and packaged.</p>&#13;
&#13;
<p>Run the <code><strong>ls -la</strong></code> command to view all the files you now have on disk. <a data-type="xref" href="#table_npm_package_file_listing">Table 6-3</a> is a list of the files present on my machine.</p>&#13;
<table id="table_npm_package_file_listing">&#13;
<caption><span class="label">Table 6-3. </span>File listing output</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>bar.js</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>baz.js</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>foo.js</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>index.js</p></td>&#13;
<td><p>4.0K</p></td>&#13;
<td><p>node_modules</p></td>&#13;
<td><p>260</p></td>&#13;
<td><p>package.json</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>14K</p></td>&#13;
<td><p>package-lock.json</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>README.md</p></td>&#13;
<td><p>1.0M</p></td>&#13;
<td><p>screenshot.bin</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>This doesn’t exactly represent the ideal package contents. The only files that are technically needed are the JavaScript files and the <em>package.json</em> file. It’s customary to ship the <em>README.md</em> document as well so that any engineer digging through their <em>node_modules/</em> directory to fix a bug will have some insight into what the package &#13;
<span class="keep-together">is for.</span></p>&#13;
&#13;
<p>The npm CLI tool does <a data-primary="npm CLI" data-secondary="ignoring files" data-type="indexterm" id="idm46291182876760"/><a data-primary="npm packages" data-secondary="npm CI and" data-tertiary="ignoring files" data-type="indexterm" id="idm46291182875752"/>come with some sane defaults for ignoring certain files that should never be included in an npm package. For example, the <em>package-lock.json</em> file is only useful for an application and is entirely meaningless when included in individual packages. The <em>node_modules/</em> directory also shouldn’t be included in the package. Instead, the npm CLI will examine all nested dependencies and figure out the best filesystem layout.</p>&#13;
&#13;
<p>It’s possible to see what the <a data-primary="npm packages" data-secondary="tarball" data-type="indexterm" id="idm46291182872744"/>contents of an npm package tarball will look like without actually having to generate and upload the package to the npm registry. Run the <code><strong>npm publish --dry-run</strong></code> command to simulate the generation of this package.<sup><a data-type="noteref" href="ch06.html#idm46291182870872" id="idm46291182870872-marker">6</a></sup> This command displays the file contents of the package and the sizes of the files. <a data-type="xref" href="#table_npm_package_dry_run">Table 6-4</a> is the listing that I get on my machine.</p>&#13;
<table id="table_npm_package_dry_run">&#13;
<caption><span class="label">Table 6-4. </span>npm package file listing</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>1.0MB</p></td>&#13;
<td><p>screenshot.bin</p></td>&#13;
<td><p>1.0MB</p></td>&#13;
<td><p>temp.bin</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>bar.js</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>baz.js</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>foo.js</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>index.js</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>test/index.js</p></td>&#13;
<td><p>260B</p></td>&#13;
<td><p>package.json</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>README.md</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>The default behavior of npm is convenient, but it isn’t completely aware of the requirements of this particular package. For example, it has no idea that <em>temp.bin</em> isn’t required for the package to work. For the remaining unwanted files you’ll have &#13;
<span class="keep-together">to manually</span> create rules to ignore them. The npm CLI honors the entries contained &#13;
<span class="keep-together">in a</span> <em>.gitignore</em> file, which you need to edit anyway since some files shouldn’t be &#13;
<span class="keep-together">checked in.</span></p>&#13;
&#13;
<p>Create a file named <em>.gitignore</em> and add the entries in <a data-type="xref" href="#ex_npm_package_gitignore">Example 6-11</a> to the file to prevent the unwanted files from getting added to version control.</p>&#13;
<div data-type="example" id="ex_npm_package_gitignore">&#13;
<h5><span class="label">Example 6-11. </span><em>leftish-padder/.gitignore</em></h5>&#13;
&#13;
<pre data-type="programlisting">node_modules&#13;
temp.bin&#13;
package-lock.json</pre></div>&#13;
&#13;
<p>The <em>node_modules/</em> directory should never <a data-primary="versioning" data-secondary="node_modules/ directory" data-type="indexterm" id="idm46291182817368"/><a data-primary="node_modules/ directory, versioning and" data-type="indexterm" id="idm46291182816392"/>be checked into version control. This is universal across all Node.js projects—whether package or application. The <em>temp.bin</em> file is specific to this package and shouldn’t be included. The <em>package-lock.json</em> file is a special situation. If you’re building an application, this file shouldn’t be ignored; it’s actually pretty important. But with an npm package, the contents are ignored at install time, so it’s presence will only end up confusing contributors.</p>&#13;
&#13;
<p>At this point, you’re free to see what the new package contents will look like. Run the <code><strong>npm publish --dry-run</strong></code> command again to see the new package contents. The listing should look the same except that the <em>temp.bin</em> file is now missing.</p>&#13;
&#13;
<p>Finally, create a new file called <em>.npmignore</em>. This file contains entries that should be omitted in the resulting npm package. Entries that are already ignored by npm, such as the <em>node_modules/</em> directory, customarily aren’t added because they would be redundant. If you only have a <em>.gitignore</em> file, it is honored by npm, but once you create a <em>.npmignore</em> file, npm will no longer consider <em>.gitignore</em>. For this reason, you need to repeat entries from <em>.gitignore</em> that npm doesn’t ignore by default. Add the content from <a data-type="xref" href="#ex_npm_package_npmignore">Example 6-12</a> to your new <em>.npmignore</em> file.</p>&#13;
<div data-type="example" id="ex_npm_package_npmignore">&#13;
<h5><span class="label">Example 6-12. </span><em>leftish-padder/.npmignore</em></h5>&#13;
&#13;
<pre data-type="programlisting">temp.bin&#13;
screenshot.bin&#13;
test</pre></div>&#13;
&#13;
<p>Now that you’ve made the final changes, run the <code><strong>npm publish --dry-run</strong></code> command one more time. <a data-type="xref" href="#table_npm_package_dry_run_2">Table 6-5</a> contains the list of files I get on my machine.</p>&#13;
<table id="table_npm_package_dry_run_2">&#13;
<caption><span class="label">Table 6-5. </span>npm package file listing with <em>.gitignore</em> and <em>.npmignore</em> files</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
<th>Size</th>&#13;
<th>Filename</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>bar.js</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>baz.js</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>foo.js</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p>0</p></td>&#13;
<td><p>index.js</p></td>&#13;
<td><p>260B</p></td>&#13;
<td><p>package.json</p></td>&#13;
<td><p>0</p></td>&#13;
<td><p>README.md</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>And there you go! You’ve now fine-tuned the contents of an npm package.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>If you were to log in to an <em>npmjs.com</em> account using the npm CLI and run the <code>npm publish</code> command, then you would create a new public package named <code>leftish-padder</code> (assuming another reader didn’t beat you to it). Often the code you’re working on represents something that you don’t want to get published. For example, if you’re working on a closed source package, or even a Node.js application, then running <code>npm publish</code> could copy proprietary code to a public location. One thing you can do to prevent this is to add a top-level entry to <em>package.json</em> containing <code>"private": true</code>. With this in place, the publish command should fail.</p>&#13;
</div>&#13;
&#13;
<p>When you publish a package, the <a data-primary="packages" data-secondary="publishing broken" data-type="indexterm" id="idm46291182784456"/><a data-primary="broken packages" data-type="indexterm" id="idm46291182783448"/>versions that are published are essentially immutable. The npm registry won’t let you change them. There is a grace period of 72 hours during which you can unpublish a package. This is in case you find yourself publishing something that shouldn’t have been published, such as private credentials. That said, there are plenty of services that constantly crawl the npm registry, so any &#13;
<span class="keep-together">published</span> credentials should be considered compromised no matter how fast you &#13;
<span class="keep-together">unpublish.</span></p>&#13;
&#13;
<p>If you ever publish a “broken” package, like a patch release that introduces a breaking change, the recommended way to fix this with SemVer is to immediately release a new version of the package that reverts the breaking change and release it as another patch release. As an example, if version 1.2.3 of a package is working fine and version 1.2.4 introduces the break, republish the code from 1.2.3 (or otherwise fix the breaking change) and publish it as 1.2.5. If you catch the problem early enough, you might be able to unpublish 1.2.4.</p>&#13;
&#13;
<p>The reason that npm doesn’t allow just any package version to be unpublished is that doing so can cause breaking changes to other people’s applications. The <em>left-pad</em> package&#13;
was <a class="" href="https://oreil.ly/xJGYx">famously unpublished</a>, leading&#13;
to broken application builds across the internet. The 72 hour limit theoretically minimizes the damage from an unpublish since the number of <em>package.json</em> files in the wild referring to the unpublished version should be small.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Dependency hierarchy and deduplication" data-type="sect3"><div class="sect3" id="idm46291182942184">&#13;
<h3>Dependency hierarchy and deduplication</h3>&#13;
&#13;
<p>A Node.js application will almost <a data-primary="dependencies" data-secondary="hierarchy" data-type="indexterm" id="dep_hier"/><a data-primary="deduplication" data-type="indexterm" id="dedup"/><a data-primary="packages" data-secondary="dependencies" data-tertiary="hierarchy" data-type="indexterm" id="dep_hier1"/><a data-primary="packages" data-secondary="deduplication" data-type="indexterm" id="dedup2"/>always depend on npm packages. Those packages will in turn depend on other packages. This leads to a tree structure of dependencies. Recall that when the <code>require()</code> function determines that the argument resembles a package, it will look inside the <em>node_modules/</em> directory within the same directory as the file calling <code>require()</code> and then in each parent directory. This means that a naive implementation of an <code>npm install</code> algorithm could simply place a copy of every package’s subdependencies into a <em>node_modules/</em> directory specific to that package and be done.</p>&#13;
&#13;
<p>As an example of this, consider a fictional situation in which an application’s <em>package.json</em> file depends on two packages, <code>foo@1.0.0</code> and <code>bar@2.0.0</code>. The <code>foo</code> package has no dependencies, but the <code>bar</code> package also depends on <code>foo@1.0.0</code>. In this situation, the naive dependency hierarchy looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">node_modules/&#13;
  foo/ (1.0.0)&#13;
  bar/ (2.0.0)&#13;
    node_modules/&#13;
      foo/ (1.0.0)</pre>&#13;
&#13;
<p>There are two issues with this approach. The first is that sometimes packages can end up with cyclical dependencies. This <a data-primary="packages" data-secondary="dependencies" data-tertiary="cyclical" data-type="indexterm" id="idm46291182763896"/><a data-primary="dependencies" data-secondary="cyclical" data-type="indexterm" id="idm46291182762648"/><a data-primary="cyclical dependencies" data-type="indexterm" id="idm46291182761704"/>would then result in an infinitely deep <em>node_modules/</em> directory. The second issue is that many dependency trees will end up with duplicate packages, increasing disk space requirements.</p>&#13;
&#13;
<p>To overcome those issues, the npm CLI will attempt to “dedupe” or “hoist” sub-dependencies higher up in the <em>node_modules/</em> directory. When that happens, a call to <code>require()</code> in a deeply nested package will ascend the filesystem until it finds the package. Following with the previous example, the <em>node_modules/</em> directory could instead look like this:</p>&#13;
&#13;
<pre data-type="programlisting">node_modules/&#13;
  foo/ (1.0.0)&#13;
  bar/ (2.0.0)</pre>&#13;
&#13;
<p>When the <code>bar</code> package goes looking for the <code>foo</code> package, it will fail to find a <em>node_modules/</em> directory in its own package but will find it one level higher.</p>&#13;
&#13;
<p>The algorithm employed by <a data-primary="npm CLI" data-secondary="dependency tree layout" data-type="indexterm" id="idm46291182754984"/>the npm CLI to determine the dependency tree layout ends up being rather complex. For example, consider that each package will specify in some way or another the version range of the packages it depends on. npm can then choose a common version to satisfy multiple version ranges. Also, consider that only a single version of a package can exist in a <em>node_modules/</em> directory at a time, since the directory is named after the package. If the <code>bar@2.0.0</code> package actually depended on <code>foo@2.0.0</code>, then the <code>foo</code> package could not have been deduped to the root <em>node_modules/</em> directory. In that case, the dependency tree would look more like this:</p>&#13;
&#13;
<pre data-type="programlisting">node_modules/&#13;
  foo/ (1.0.0)&#13;
  bar/ (2.0.0)&#13;
    node_modules/&#13;
      foo/ (2.0.0)</pre>&#13;
&#13;
<p>Over time, new packages are constantly being published to the npm registry. This means that newer versions of packages will be added that satisfy the version requirements of your application. This means that there is no guarantee that the dependency tree of an application will remain the same between subsequent <code>npm install</code> runs. Even though you can specify exact package versions in an application’s <em>package.json</em> file, subdependencies of those dependencies most likely aren’t using exact versions, leading to the seemingly nondeterministic dependency tree.</p>&#13;
&#13;
<p>Sometimes, small bugs or behavioral changes can make their way into an application when the dependency tree changes. The <em>package-lock.json</em> file (and its forgotten sibling <em>npm-shrinkwrap.json</em>) was created to lock in an entire representation of the dependency tree. As new package versions come and go, the dependency tree will stay the same with each subsequent <code>npm install</code> run. Then, when you’re ready to update or add a new a package, you can do so using the appropriate <code>npm install &lt;package&gt;</code> command. This will result in a change to both <em>package.json</em> and <em>package-lock.json</em>, which can be checked in as a single version control commit.</p>&#13;
&#13;
<p>To view a more complex example of this package “deduplication” process, switch back to the terminal where you made the <code>leftish-padder</code> package. Recall that you previously installed <code>express@4.17.1</code>. Now run the command <strong><code>ls node_modules</code></strong>. This will give you a list of all the packages that have been hoisted to the top level <em>node_modules/</em> directory. Even though you only installed the <code>express</code> package, you should actually see dozens of packages listed. On my machine I see a list of 49 packages, and here are the first dozen of them, though you may see different results:</p>&#13;
&#13;
<pre data-type="programlisting">accepts              array-flatten  body-parser  bytes&#13;
content-disposition  content-type   cookie       cookie-signature&#13;
debug                depd           destroy      ee-first</pre>&#13;
&#13;
<p>This gives the “physical” layout of packages on disk. To view the “logical” layout of the dependency tree, run the command <strong><code>npm ls</code></strong>. This will list the dependency tree. Here is a truncated version of the output that I see on my machine:</p>&#13;
&#13;
<pre data-type="programlisting">leftish-padder@0.1.0&#13;
└─┬ express@4.17.1&#13;
  ├─┬ accepts@1.3.7&#13;
  │ └─ ...TRUNCATED...&#13;
  ├─┬ body-parser@1.19.0&#13;
  │ ├── bytes@3.1.0&#13;
  │ ├── content-type@1.0.4 deduped&#13;
  ├ ... TRUNCATED ...&#13;
  ├── content-type@1.0.4</pre>&#13;
&#13;
<p>In this case, the only top-level dependency is <code>express@4.17.1</code>, which makes sense because it’s the only package defined in the root <em>package.json</em> file. The <code>express</code> package depends on many packages, including <code>body-parser</code>, and <code>body-parser</code> depends on many packages, including <code>content-type</code>. Notice that this last package has the string “deduped” next to it. This means that the npm CLI has hoisted the package up higher in the dependency tree. The final line shows that the <code>content-type</code> package is a direct child of <code>express</code>.</p>&#13;
&#13;
<p>Be sure to never <code>require()</code> a package <a data-primary="packages" data-secondary="require()" data-type="indexterm" id="idm46291182733448"/>that isn’t listed as a direct dependency of your project. If any module within the <code>leftish-padder</code> package were to attempt to use a hoisted package, like <code>require('content-type')</code>, the require would technically work. However, there’s no guarantee that the call will work in the future once the dependency tree shifts again.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Be careful when creating <em>singleton</em> instances <a data-primary="npm packages" data-secondary="singleton instances" data-type="indexterm" id="idm46291182729496"/>within an npm package. Consider a package that creates a singleton database connection when it is first instantiated. Depending on how this package has been deduped, it may result in multiple database connections being created in one application. Also, be wary of the <code>instanceof</code> operator when classes are defined <a data-primary="dependencies" data-secondary="hierarchy" data-startref="dep_hier" data-type="indexterm" id="idm46291182727688"/><a data-primary="deduplication" data-startref="dedup" data-type="indexterm" id="idm46291182726440"/><a data-primary="packages" data-secondary="dependencies" data-startref="dep_hier1" data-tertiary="hierarchy" data-type="indexterm" id="idm46291182725496"/><a data-primary="packages" data-secondary="deduplication" data-startref="dedup2" data-type="indexterm" id="idm46291182724008"/>within a package. An instance of <code>foo@1.0.0#MyClass</code> will not pass an <code>instanceof</code> check with an instance of <code>foo@1.0.1#MyClass</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Internal npm Registry" data-type="sect1"><div class="sect1" id="ch_deployments_sec_npmregistry">&#13;
<h1>Internal npm Registry</h1>&#13;
&#13;
<p>The public npmjs.com registry is <a data-primary="npm registry" data-type="indexterm" id="npmreg"/><a data-primary="internal npm registry" data-type="indexterm" id="idm46291182718792"/>the go-to source for npm packages. By default, the npm CLI utility is configured to download packages from, and publish packages to, this registry. That said, many organizations will find that they may need to run an internal npm registry. Just like any popular SaaS tool, there will always be reasons to host an internal version instead of relying on a public version. Here are some of the reasons why an organization may choose to run an internal npm registry:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The npmjs.com registry, like any SaaS tool, will occasionally suffer from an outage. This may prevent applications from building and deploying.</p>&#13;
</li>&#13;
<li>&#13;
<p>An organization may want to host private packages but not want to pay the <em>npmjs.com</em> fees.</p>&#13;
</li>&#13;
<li>&#13;
<p>An organization may want statistics on which packages are being installed by its disparate projects.</p>&#13;
</li>&#13;
<li>&#13;
<p>An organization may want to blocklist packages with known vulnerabilities.</p>&#13;
</li>&#13;
<li>&#13;
<p>An organization may consume too much bandwidth and either get throttled or blocklisted by npm.<sup><a data-type="noteref" href="ch06.html#idm46291182711784" id="idm46291182711784-marker">7</a></sup></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There are many different tools available for hosting an internal npm registry. A registry, much like many of the other tools you’ve used in this book, is a service that runs somewhere, listening on a port, and is probably associated with a hostname. The npm CLI can be configured to interact with this private registry. These registries usually come with a proxy feature. Instead of just hosting an organization’s private packages, some can download and cache packages available on the public registry. This way, an application with both public and private packages is able to get every package it needs by only communicating with the internal registry.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running Verdaccio" data-type="sect2"><div class="sect2" id="idm46291182709736">&#13;
<h2>Running Verdaccio</h2>&#13;
&#13;
<p>In this section, you’ll work <a data-primary="npm registry" data-secondary="Verdaccio" data-startref="npm_verd" data-type="indexterm" id="idm46291182708232"/><a data-primary="Verdaccio" data-type="indexterm" id="verd"/>with the <a class="orm:hideurl" href="https://verdaccio.org">Verdaccio</a> service. It’s an open source npm registry written in Node.js. It can be run by installing a global package obtained from npm, though you’ll work with it inside of a Docker container.</p>&#13;
&#13;
<p>Run the following command to get a copy of the Verdaccio npm registry running locally:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>docker run -it --rm <code class="se">\</code>&#13;
  --name verdaccio <code class="se">\</code>&#13;
  -p 4873:4873 <code class="se">\</code>&#13;
  verdaccio/verdaccio:4.8</pre>&#13;
&#13;
<p>Once you’ve executed that command, wait for the Docker image layers to be downloaded and for the image to run. Then, once your terminal settles down, open the following URL in your web browser to view the Verdaccio web interface:</p>&#13;
&#13;
<pre data-type="programlisting">http://localhost:4873/</pre>&#13;
&#13;
<p>At this point, there shouldn’t be any packages listed since you haven’t used it yet.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring npm to Use Verdaccio" data-type="sect2"><div class="sect2" id="idm46291182699128">&#13;
<h2>Configuring npm to Use Verdaccio</h2>&#13;
&#13;
<p>The menu in the upper-right <a data-primary="npm packages" data-secondary="Verdaccio" data-tertiary="configuring" data-type="indexterm" id="verd_config"/>corner of the Verdaccio web interface has a button labeled <em>LOGIN</em>. But in order to use it, you’ll first need to create an account. Switch back to a terminal and run the following commands:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm <code class="nb">set </code>registry http://localhost:4873&#13;
<code class="nv">$ </code>npm adduser --registry http://localhost:4873</pre>&#13;
&#13;
<p>The first command configures the npm CLI to make use of your local Verdaccio registry when using future commands. The second command creates a new user with the registry. In the second command, the <code>--registry</code> flag isn’t needed, but it shows how individual npm commands can be overridden to use a specific registry URL.</p>&#13;
&#13;
<p>When prompted, enter a username that you normally use, a password, and your email address. Once that’s done, and you’ve authenticated with the npm CLI, switch back to the Verdaccio web page and proceed to log in to the interface.</p>&#13;
&#13;
<p>The web interface still isn’t that interesting. For that to happen, you need to first publish a package. That <code>leftish-padder</code> package that you’ve been working on is a decent candidate.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Publishing to Verdaccio" data-type="sect2"><div class="sect2" id="idm46291182690728">&#13;
<h2>Publishing to Verdaccio</h2>&#13;
&#13;
<p>Switch back to a terminal, and <a data-primary="Verdaccio" data-secondary="publishing to" data-type="indexterm" id="idm46291182687272"/><a data-primary="npm packages" data-secondary="Verdaccio" data-tertiary="publishing to" data-type="indexterm" id="idm46291182686264"/>navigate to the directory where you created the sample package used in previous sections. Once you’re in that directory, run the following <code>npm publish</code> command to publish your package to your private npm registry:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code><code class="nb">cd </code>leftish-padder&#13;
<code class="nv">$ </code>npm publish --registry http://localhost:4873</pre>&#13;
&#13;
<p>Similar output should appear from when you previously ran the <code>publish</code> command with the <code>--dry-run</code> flag.<sup><a data-type="noteref" href="ch06.html#idm46291182617336" id="idm46291182617336-marker">8</a></sup> This time, you should see the following message printed after the package summary, conveying a successful publish:</p>&#13;
&#13;
<pre data-type="programlisting">+ leftish-padder@0.1.0</pre>&#13;
&#13;
<p>Now that you’ve published your first package, switch back to the Verdaccio web interface and refresh the page. You should now see a listing of packages, and in this case, you should only see your <code>leftish-padder</code> package installed. From this screen, click the <em>leftish-padder</em> entry in the listing to be taken to the <a class="orm:hideurl" href="http://localhost:4873/-/web/detail/leftish-padder">package details</a> screen.</p>&#13;
&#13;
<p>This screen has four tabs on it. The first tab is titled README and contains content from the <em>README.md</em> document (though in this case it’s empty, so the screen just displays the message “ERROR: No README data found!”). The next tab is titled DEPENDENCIES. Click it to see a list of dependencies for the most recent version of the package. In this case, you should only see one entry for <code>express@^4.17.1</code>. Click the third tab, titled VERSIONS, to be taken to a list of versions for this package. On this screen, you should see two entries. The first is named <em>latest</em> and is a pointer to the most recent version. The second is <em>0.1.0</em>, which is the only version that you’ve published so far.</p>&#13;
&#13;
<p>Unfortunately, there’s a bug with the current version of the package. The <em>index.js</em> file is empty, and the package does nothing! Switch back to the terminal and edit the <em>index.js</em> file for your <code>leftish-padder</code> package. Add the content from <a data-type="xref" href="#ex_package_content">Example 6-13</a> to this file.</p>&#13;
<div data-type="example" id="ex_package_content">&#13;
<h5><span class="label">Example 6-13. </span><em>leftish-padder/index.js</em></h5>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="p">(</code><code class="nx">s</code><code class="p">,</code> <code class="nx">p</code><code class="p">,</code> <code class="nx">c</code> <code class="o">=</code> <code class="s1">' '</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nb">String</code><code class="p">(</code><code class="nx">s</code><code class="p">).</code><code class="nx">padStart</code><code class="p">(</code><code class="nx">p</code><code class="p">,</code> <code class="nx">c</code><code class="p">);</code></pre></div>&#13;
&#13;
<p>Now that you’ve fixed the bugs with the package, you’re ready to publish a new version. The first thing you’ll need to do is increment the version of the package. Since you’re dealing with a bug fix, only the patch version needs to change. Run the following commands to increment the version number and perform a publish:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm verson patch&#13;
<code class="nv">$ </code>npm publish --registry http://localhost:4873</pre>&#13;
&#13;
<p>Now open the Verdaccio web page again and refresh the VERSIONS tab once more. You should now see a new entry for version 0.1.1 of your package.</p>&#13;
&#13;
<p>So far, Verdaccio has been functioning as a tool where you can upload private packages. Unfortunately, the name <em>leftish-padder</em> might be a bit too generic. As of this writing, no package exists with this name, but one might in the near future. If that were to happen, the npm CLI would get confused. If you perform an installation, what happens if a package name collision occurs? Should you get the private or public package?</p>&#13;
&#13;
<p>In order to avoid this issue, you could provide a long string at the beginning of a package name, like <code>widget-co-internal-*</code>. But this would be annoying to type, and theoretically someone else could still choose the same package name. Instead, you should namespace your packages using something called a <em>scope</em>. Scopes are the official npm mechanism for namespacing packages. Scope names can also be registered so that nobody else can come along and use the same scope.</p>&#13;
&#13;
<p>Open up the <em>package.json</em> file for your package and edit the <em>name</em> field. In this case, you can use a username to scope your package. My username is <em>tlhunter</em>, so my package name entry looks like this:</p>&#13;
&#13;
<pre data-type="programlisting">"name": "@tlhunter/leftish-padder",</pre>&#13;
&#13;
<p>Run the <code>publish</code> command that you’ve been using one more time. Once the publish is complete, switch back to your web browser and visit the <a class="orm:hideurl" href="http://localhost:4873">homepage</a> for your Verdaccio installation again and refresh the page. You should now see an additional entry for the scoped package.</p>&#13;
&#13;
<p>By using a scope with the same name as your npm organization, you can be sure that nobody else will publish a package with a competing name to the public npm repository. Organizations can then publish public packages to the public registry using their organization scope and publish private packages to their internal registry using the same scope.</p>&#13;
&#13;
<p>Finally, it’s time to confirm that you’re able to install the private package that you published. This can be done by creating a sample project, installing the scoped package, and creating a JavaScript file to require and run the package. Run the following commands to do just that, replacing <code>&lt;SCOPE&gt;</code> with the scope you chose:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>mkdir sample-app <code class="o">&amp;&amp;</code> <code class="nb">cd </code>sample-app&#13;
<code class="nv">$ </code>npm init -y&#13;
<code class="nv">$ </code>npm install @&lt;SCOPE&gt;/leftish-padder&#13;
<code class="nv">$ </code><code class="nb">echo</code> <code class="s2">"console.log(require('@&lt;SCOPE&gt;/leftish-padder')(10, 4, 0));"</code> <code class="se">\</code>&#13;
  &gt; app.js&#13;
<code class="nv">$ </code>node app.js</pre>&#13;
&#13;
<p>You should see the string <em>0010</em> printed in your console.</p>&#13;
&#13;
<p>There you have it! You’re now the proud new owner of a private npm registry. Before using this in production, you’ll need to read the Verdaccio Docker &#13;
<span class="keep-together">documentation</span> to configure it to persist changes to disk, give it a permanent hostname, and enable security features like TLS.</p>&#13;
&#13;
<p>Once you’re done experimenting with Verdaccio, you probably no longer want to use it as the registry for your npm CLI. Run the following command to set things back to normal:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nv">$ </code>npm config delete registry</pre>&#13;
&#13;
<p>Your npm CLI is now configured to use the <a data-primary="npm registry" data-secondary="Verdaccio" data-startref="npm_verd" data-type="indexterm" id="idm46291182466648"/><a data-primary="Verdaccio" data-startref="verd" data-type="indexterm" id="idm46291182465560"/>public <em>npmjs.com</em> repository again.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46291182561144">&#13;
<h5>Alternatives to Verdaccio</h5>&#13;
<p>When it comes to hosting private packages, an npm Pro account currently comes with unlimited private packages. This is the easiest way to host private packages.</p>&#13;
&#13;
<p>If you want to host an on-prem proxy of the public repository and some of the other enterprise features, you’re going to need something a little heavier. <a class="orm:hideurl" href="https://github.com/features/packages">GitHub Packages</a> is one way to do this and is supported by the company that owns npm. <a class="orm:hideurl" href="https://jfrog.com/artifactory/">JFrog Artifactory</a> is a generic tool for hosting many types of artifacts, including npm packages and Docker images, and is also worth considering.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46291185298648"><sup><a href="ch06.html#idm46291185298648-marker">1</a></sup> Python, and most other languages, can be executed by a separate web server on a request/response basis (perhaps with Django), or persistently run itself in memory (à la Twisted).</p><p data-type="footnote" id="idm46291185269544"><sup><a href="ch06.html#idm46291185269544-marker">2</a></sup> In theory, you could run <code>nodemon</code> on a production server and then just overwrite files with newer versions. But you should never do such a thing.</p><p data-type="footnote" id="idm46291184452856"><sup><a href="ch06.html#idm46291184452856-marker">3</a></sup> “Flaky” is a super-scientific engineering term meaning “something sometimes breaks.”</p><p data-type="footnote" id="idm46291183299560"><sup><a href="ch06.html#idm46291183299560-marker">4</a></sup> Tools like Browserify, Webpack, and Rollup make it possible to use CommonJS patterns in the browser.</p><p data-type="footnote" id="idm46291182953960"><sup><a href="ch06.html#idm46291182953960-marker">5</a></sup> When I worked for Intrinsic, we distributed our security product to customers in this manner.</p><p data-type="footnote" id="idm46291182870872"><sup><a href="ch06.html#idm46291182870872-marker">6</a></sup> You can also use <code>npm pack</code> to generate a tarball that you can manually inspect.</p><p data-type="footnote" id="idm46291182711784"><sup><a href="ch06.html#idm46291182711784-marker">7</a></sup> This may sound far-fetched, but it did happen to an employer of mine.</p><p data-type="footnote" id="idm46291182617336"><sup><a href="ch06.html#idm46291182617336-marker">8</a></sup> If you get a <em>EPUBLISHCONFLICT</em> error, then some poor reader has published their package to npm and you’ll need to change the package name.</p></div></div></section></body></html>