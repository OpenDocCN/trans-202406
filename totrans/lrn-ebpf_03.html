<html><head></head><body><section data-pdf-bookmark="Chapter 3. Anatomy of an eBPF Program" data-type="chapter" epub:type="chapter"><div class="chapter" id="anatomy_of_an_ebpf_program">&#13;
    <h1><span class="label">Chapter 3. </span>Anatomy of an eBPF Program</h1>&#13;
    <p><a contenteditable="false" data-primary="programs, eBPF" data-type="indexterm" id="ch03.html0"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="anatomy of" data-type="indexterm" id="ch03.html1"/>In the previous chapter you saw a simple eBPF “Hello World” program written using&#13;
        the BCC framework. In this chapter there’s an example version of a “Hello World” program written entirely in C&#13;
        so that you can see some of the details BCC took care of behind the scenes.</p>&#13;
    <p>This chapter also shows you the stages an eBPF program goes through on its journey from source code to execution,&#13;
        as illustrated in <a data-type="xref" href="#c_left_parenthesisor_rustright_parenthe">Figure 3-1</a>.</p>&#13;
    <figure><div class="figure" id="c_left_parenthesisor_rustright_parenthe">&#13;
        <img alt="C (or Rust) source code is compiled into eBPF bytecode, which is either JIT-compiled or interpreted into native machine code instructions" src="assets/lebp_0301.png"/>&#13;
        <h6><span class="label">Figure 3-1. </span>C (or Rust) source code is compiled into eBPF bytecode, which is either JIT-compiled or interpreted&#13;
            into native machine code instructions</h6>&#13;
    </div></figure>&#13;
    <p>An eBPF program is a set of eBPF bytecode instructions. It’s possible to write eBPF code directly in this&#13;
        bytecode, much as it’s possible to program in assembly language. Humans typically find a higher-level&#13;
        programming language easier to deal with, and at least at the time of this writing, I’d say the vast majority of&#13;
        eBPF code is written in C<sup><a data-type="noteref" href="ch03.html#ch03fn1" id="ch03fn1-marker">1</a></sup> and then compiled to&#13;
        eBPF bytecode.</p>&#13;
    <p>Conceptually, this bytecode runs in an eBPF virtual machine within the kernel.</p>&#13;
    <section data-pdf-bookmark="The eBPF Virtual Machine" data-type="sect1"><div class="sect1" id="the_ebpf_virtual_machine">&#13;
        <h1>The eBPF Virtual Machine</h1>&#13;
        <p><a contenteditable="false" data-primary="programs, eBPF" data-secondary="eBPF virtual machine" data-type="indexterm" id="ch03.html2"/><a contenteditable="false" data-primary="virtual machine, eBPF" data-type="indexterm" id="ch03.html3"/>The eBPF virtual&#13;
            machine, like any virtual machine, is a software implementation of a computer. It takes in a program in the&#13;
            form of eBPF bytecode instructions, and these have to be converted to native machine instructions that run&#13;
            on the CPU.</p>&#13;
        <p>In early implementations of eBPF, the bytecode instructions were interpreted within the kernel—that is, every&#13;
            time an eBPF program runs, the kernel examines the instructions and converts them into machine code, which&#13;
            it then executes. Interpreting has since been largely replaced by JIT (just-in-time) compilation for&#13;
            performance reasons and to avoid the possibility of some Spectre-related vulnerabilities in the eBPF&#13;
            interpreter. <a contenteditable="false" data-primary="compilation, defined" data-type="indexterm" id="idm46123201272256"/><em>Compilation</em> means the conversion to native machine instructions&#13;
            happens just once, when the program is loaded into the kernel.</p>&#13;
        <p>eBPF bytecode consists of a set of instructions, and those instructions act on (virtual) eBPF registers. The&#13;
            eBPF instruction set and register model were designed to map neatly to common CPU architectures so that the&#13;
            step of compiling or interpreting from bytecode to machine code is reasonably straightforward.</p>&#13;
        <section data-pdf-bookmark="eBPF Registers" data-type="sect2"><div class="sect2" id="ebpf_registers">&#13;
            <h2>eBPF Registers</h2>&#13;
            <p><a contenteditable="false" data-primary="registers, for eBPF virtual machine" data-type="indexterm" id="idm46123201268544"/><a contenteditable="false" data-primary="virtual machine, eBPF" data-secondary="registers" data-type="indexterm" id="idm46123201267472"/>The eBPF virtual machine uses 10&#13;
                general-purpose registers, numbered 0 to 9. Additionally, Register 10 is used as a stack frame pointer&#13;
                (and can only be read, but not written). As a BPF program is executed, values get stored in these&#13;
                registers to keep track of state.</p>&#13;
            <p>It’s important to understand that these eBPF registers in the eBPF virtual machine are implemented in&#13;
                software. You can see them enumerated from <code>BPF_REG_0</code> to <code>BPF_REG_10</code> in the <a href="https://oreil.ly/_ZhU2"><em>include/uapi/linux/bpf.h</em> header file</a> of the Linux&#13;
                kernel’s source code.</p>&#13;
            <p>The context argument to an eBPF program is loaded into Register 1 before its execution begins. The return&#13;
                value from the function is stored in Register 0.</p>&#13;
            <p>Before calling a function from eBPF code, the arguments to that function are placed in Register 1 through&#13;
                Register 5 (not all the registers are used if there are fewer than five arguments).</p>&#13;
        </div></section>&#13;
        <section data-pdf-bookmark="eBPF Instructions" data-type="sect2"><div class="sect2" id="ebpf_instructions">&#13;
            <h2>eBPF Instructions</h2>&#13;
            <p><a contenteditable="false" data-primary="instructions" data-secondary="for eBPF virtual machine" data-type="indexterm" id="ch03.html4"/><a contenteditable="false" data-primary="virtual machine, eBPF" data-secondary="instructions" data-type="indexterm" id="ch03.html5"/>The same <a href="https://oreil.ly/_ZhU2"><em>linux/bpf.h</em> header&#13;
                    file</a> defines a structure called <code>bpf_insn</code>, which represents a BPF instruction:</p>&#13;
            <pre class="pagebreak-before" data-code-language="c" data-type="programlisting"><code class="k">struct</code><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/bpf_insn"><code class="nc">bpf_insn</code></a><code class="w"> </code><code class="p">{</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u8"><code class="n">__u8</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/code"><code class="n">code</code></a><code class="p">;</code><code class="w">          </code><code class="cm">/* opcode */</code><code class="w">                      </code><a class="co" href="#list_id_3_1" id="code_id_3_1"><img alt="1" src="assets/1.png"/></a><code class="w"> </code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u8"><code class="n">__u8</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/dst_reg"><code class="n">dst_reg</code></a><code class="o">:</code><code class="mi">4</code><code class="p">;</code><code class="w">     </code><code class="cm">/* dest register */</code><code class="w">               </code><a class="co" href="#list_id_3_2" id="code_id_3_2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__u8"><code class="n">__u8</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/src_reg"><code class="n">src_reg</code></a><code class="o">:</code><code class="mi">4</code><code class="p">;</code><code class="w">     </code><code class="cm">/* source register */</code><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__s16"><code class="n">__s16</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/off"><code class="n">off</code></a><code class="p">;</code><code class="w">       </code><code class="cm">/* signed offset */</code><code class="w">                  </code><a class="co" href="#list_id_3_3" id="code_id_3_3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">    </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/__s32"><code class="n">__s32</code></a><code class="w"> </code><a class="orm:hideurl" href="https://elixir.bootlin.com/linux/latest/C/ident/imm"><code class="n">imm</code></a><code class="p">;</code><code class="w">       </code><code class="cm">/* signed immediate constant */</code><code class="w">&#13;
</code><code class="p">}</code><code class="p">;</code></pre>&#13;
            <dl class="calloutlist">&#13;
                <dt><a class="co" href="#code_id_3_1" id="list_id_3_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
                <dd>Each instruction has an opcode, which defines what operation the instruction is to perform: for&#13;
                    example, adding a value to the contents of a register, or jumping to a different instruction in the&#13;
                    program.<sup><a data-type="noteref" href="ch03.html#ch03fn2" id="ch03fn2-marker">2</a></sup> The Iovisor project’s <a href="https://oreil.ly/FXcPu">“Unofficial eBPF spec”</a> has a list of the valid instructions.&#13;
                </dd>&#13;
                <dt><a class="co" href="#code_id_3_2" id="list_id_3_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
                <dd>Different operations might involve up to two registers.</dd>&#13;
                <dt><a class="co" href="#code_id_3_3" id="list_id_3_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
                <dd>Depending on the operation, there might be an offset value and/or an “immediate” integer value.</dd>&#13;
            </dl>&#13;
            <p>This <code>bpf_insn</code> structure is 64 bits (or 8 bytes) long. However, sometimes an instruction&#13;
                might need to span more than 8 bytes. <a contenteditable="false" data-primary="wide instruction encoding" data-type="indexterm" id="idm46123201134048"/>If you want to set a&#13;
                register to a 64-bit value, you can’t somehow squeeze all 64 bits of that value into the structure,&#13;
                along with the opcode and register information. In these cases, the instruction uses <em>wide&#13;
                    instruction encoding</em> that is 16 bytes long in total. You’ll see an example of this in this&#13;
                chapter.</p>&#13;
            <p>When loaded into the kernel, the bytecode of an eBPF program is represented by a series of these&#13;
                <code>bpf_insn</code> structures. The verifier performs several checks on this information to ensure&#13;
                that the code is safe to run. You’ll learn more about the verification process in <a data-type="xref" href="ch06.html#the_ebpf_verifier">Chapter 6</a>.</p>&#13;
            <p>Most of the different opcodes fall into the following categories:</p>&#13;
            <ul>&#13;
                <li>&#13;
                    <p>Loading a value into a register (either an immediate value or a value read from memory or from&#13;
                        another register)</p>&#13;
                </li>&#13;
                <li>&#13;
                    <p>Storing a value from a register into memory</p>&#13;
                </li>&#13;
                <li>&#13;
                    <p>Performing arithmetic operations such as adding a value to the contents of a <span class="keep-together">register</span></p>&#13;
                </li>&#13;
                <li>&#13;
                    <p>Jumping to a different instruction if a particular condition is satisfied</p>&#13;
                </li>&#13;
            </ul>&#13;
            <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
                <p>For an overview of eBPF architecture, I recommend the <a href="https://oreil.ly/rvm1i">BPF and XDP&#13;
                        Reference Guide</a> that’s included as part of the Cilium project’s documentation. If you’d like&#13;
                    more details, the <a href="https://oreil.ly/_2XDT">kernel documentation</a> describes the eBPF&#13;
                    instructions and encoding quite clearly.</p>&#13;
            </div>&#13;
            <p>Let’s use another simple example of an eBPF program and follow its journey from C source code, through&#13;
                eBPF bytecode, to machine code instructions.</p>&#13;
            <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
                <p>If you want to build and run this code yourself, you’ll find the code along with instructions for&#13;
                    setting up an environment to do so at <a class="orm:hideurl" href="https://github.com/lizrice/learning-ebpf"><em>github.com/lizrice/learning-ebpf</em></a>.&#13;
                    The code for this chapter is in the <em>chapter3</em> directory.</p>&#13;
                <p>The examples in this chapter are written in C using a library called <em>libbpf</em>. You’ll learn&#13;
                    more about this library in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a><a contenteditable="false" data-primary="" data-startref="ch03.html5" data-type="indexterm" id="idm46123201118288"/><a contenteditable="false" data-primary="" data-startref="ch03.html4" data-type="indexterm" id="idm46123201116944"/>.<a contenteditable="false" data-primary="" data-startref="ch03.html3" data-type="indexterm" id="idm46123201115440"/><a contenteditable="false" data-primary="" data-startref="ch03.html2" data-type="indexterm" id="idm46123201114032"/></p>&#13;
            </div>&#13;
        </div></section>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="eBPF “Hello World” for a Network Interface" data-type="sect1"><div class="sect1" id="ebpf_quotation_markhello_worldquotation">&#13;
        <h1>eBPF “Hello World” for a Network Interface</h1>&#13;
        <p><a contenteditable="false" data-primary="network interface" data-secondary="&quot;Hello World&quot; program for" data-secondary-sortas="Hello World" data-type="indexterm" id="ch03.html7"/>The examples in the previous chapter emitted the trace&#13;
            “Hello World” triggered by a system call kprobe; this time I’m going to show an eBPF program that writes a&#13;
            line of trace when triggered by the arrival of a network packet.</p>&#13;
        <p><a contenteditable="false" data-primary="packet processing" data-type="indexterm" id="idm46123201108384"/>Packet processing&#13;
            is a very common application of eBPF. I’ll cover this in a lot more detail in <a data-type="xref" href="ch08.html#ebpf_for_networking">Chapter 8</a>, but for now it might be helpful to be aware of the&#13;
            basic idea of an eBPF program that is triggered for every packet of data that arrives on a network&#13;
            interface. The program can inspect and even modify the contents of that packet, and it makes a decision (or&#13;
            <em>verdict</em>) on what the kernel should do with that packet. The verdict could tell the kernel to carry&#13;
            on processing it as usual, drop it, or redirect it elsewhere.</p>&#13;
        <p>In the simple example I’m showing here, the program doesn’t do anything with the network packet; it simply&#13;
            writes out the words <em>Hello World</em> and a counter to the trace pipe every time a network packet is&#13;
            received.</p>&#13;
        <p>The example program is in <em>chapter3/hello.bpf.c</em>. It’s a fairly common convention to put eBPF programs&#13;
            into filenames ending with <em>bpf.c</em> to distinguish them from user space C code that might live in the&#13;
            same source code directory. Here’s the entire program:</p>&#13;
        <pre data-code-language="c" data-type="programlisting"><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;linux/bpf.h&gt;</code><code class="c1">                           </code><a class="co" href="#list_id_3_4" id="code_id_3_4"><img alt="1" src="assets/1.png"/></a><code class="cp">&#13;
</code><code class="cp">#</code><code class="cp">include</code><code class="w"> </code><code class="cpf">&lt;bpf/bpf_helpers.h&gt;</code><code class="cp">&#13;
</code><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="n">counter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w">                                 </code><a class="co" href="#list_id_3_5" id="code_id_3_5"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="n">SEC</code><code class="p">(</code><code class="s">"</code><code class="s">xdp</code><code class="s">"</code><code class="p">)</code><code class="w">                                       </code><a class="co" href="#list_id_3_6" id="code_id_3_6"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="kt">int</code><code class="w"> </code><code class="n">hello</code><code class="p">(</code><code class="kt">void</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w">                           </code><a class="co" href="#list_id_3_7" id="code_id_3_7"><img alt="4" src="assets/4.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"</code><code class="s">Hello World %d</code><code class="s">"</code><code class="p">,</code><code class="w"> </code><code class="n">counter</code><code class="p">)</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="n">counter</code><code class="o">+</code><code class="o">+</code><code class="p">;</code><code class="w">&#13;
</code><code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="n">XDP_PASS</code><code class="p">;</code><code class="w">&#13;
</code><code class="p">}</code><code class="w">&#13;
</code><code class="w">&#13;
</code><code class="kt">char</code><code class="w"> </code><code class="n">LICENSE</code><code class="p">[</code><code class="p">]</code><code class="w"> </code><code class="n">SEC</code><code class="p">(</code><code class="s">"</code><code class="s">license</code><code class="s">"</code><code class="p">)</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s">"</code><code class="s">Dual BSD/GPL</code><code class="s">"</code><code class="p">;</code><code class="w">  </code><a class="co" href="#list_id_3_8" id="code_id_3_8"><img alt="5" src="assets/5.png"/></a></pre>&#13;
        <dl class="calloutlist">&#13;
            <dt><a class="co" href="#code_id_3_4" id="list_id_3_4"><img alt="1" src="assets/1.png"/></a></dt>&#13;
            <dd><a contenteditable="false" data-primary="header files, C" data-type="indexterm" id="idm46123201014304"/>This example&#13;
                starts by including some header files. Just in case you’re not familiar with C coding, every program has&#13;
                to include the header files that define any structures or functions the program is going to use. You can&#13;
                guess from the names that these header files are related to BPF.</dd>&#13;
            <dt><a class="co" href="#code_id_3_5" id="list_id_3_5"><img alt="2" src="assets/2.png"/></a></dt>&#13;
            <dd>This example shows how eBPF programs can use global variables. This counter will get incremented every&#13;
                time the program runs.</dd>&#13;
            <dt><a class="co" href="#code_id_3_6" id="list_id_3_6"><img alt="3" src="assets/3.png"/></a></dt>&#13;
            <dd><a contenteditable="false" data-primary="SEC()" data-type="indexterm" id="idm46123201008400"/>The macro&#13;
                <code>SEC()</code> defines a section called <code>xdp</code> that you’ll be able to see in the compiled&#13;
                object file. I’ll come back to how the section name is used in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, but for now you can&#13;
                simply think of it as defining that it’s an eXpress Data Path (XDP) type of eBPF program.</dd>&#13;
            <dt><a class="co" href="#code_id_3_7" id="list_id_3_7"><img alt="4" src="assets/4.png"/></a></dt>&#13;
            <dd>Here you can see the actual eBPF program. In eBPF, the program name is the function name, so this&#13;
                program is called <code>hello</code>. It uses a helper function, <code>bpf_printk</code>, to write a&#13;
                string of text, increments the global variable <code>counter</code>, and then returns the value&#13;
                <code>XDP_PASS</code>. This is the verdict indicating to the kernel that it should process this network&#13;
                packet as normal.</dd>&#13;
            <dt><a class="co" href="#code_id_3_8" id="list_id_3_8"><img alt="5" src="assets/5.png"/></a></dt>&#13;
            <dd>Finally there is another <code>SEC()</code> macro that defines a license string, and this is a crucial&#13;
                requirement for eBPF programs. Some of the BPF helper functions in the kernel are defined as “GPL only.”&#13;
                If you want to use any of these functions, your BPF code has to be declared as having a GPL-compatible&#13;
                license. The verifier (which we will discuss in <a data-type="xref" href="ch06.html#the_ebpf_verifier">Chapter 6</a>) will object if the declared license is not&#13;
                compatible with the functions a program uses. Certain eBPF program types, including those that use BPF&#13;
                LSM (which you’ll learn about in <a data-type="xref" href="ch09.html#ebpf_for_security">Chapter 9</a>),&#13;
                are also <a href="https://oreil.ly/ItahV">required to be GPL compatible</a>.</dd>&#13;
        </dl>&#13;
        <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
            <p><a contenteditable="false" data-primary="tracing" data-secondary="bpf_trace_printk()" data-type="indexterm" id="idm46123200944512"/>You might be wondering why the previous chapter used&#13;
                <code>bpf_trace_printk()</code> and this version uses <code>bpf_printk()</code>. The short answer is&#13;
                that BCC’s version is called <code>bpf_trace_printk()</code> and <em>libbpf</em>’s version is&#13;
                <code>bpf_printk()</code>, but both of those are wrappers around the kernel function&#13;
                <code>bpf_trace_printk()</code>. Andrii Nakryiko wrote a <a href="https://oreil.ly/9mNSY">good post</a>&#13;
                on this on his blog.</p>&#13;
        </div>&#13;
        <p>This is an example of an eBPF program that attaches to the XDP hook point on a network interface. You can&#13;
            think of the XDP event being triggered the moment a network packet arrives inbound on a (physical or&#13;
            virtual) network interface.</p>&#13;
        <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
            <p><a contenteditable="false" data-primary="XDP (eXpress Data Path)" data-secondary="offloading" data-type="indexterm" id="idm46123200938240"/>Some network cards support offloading XDP programs so that they can&#13;
                be executed on the network card itself. This means each network packet that arrives can be processed on&#13;
                the card, before it gets anywhere near the machine’s CPU. XDP programs can inspect and even modify each&#13;
                network packet, so this is very useful for doing things like DDoS protection, firewalling, or load&#13;
                balancing in a highly performant way. You’ll learn more about this in <a data-type="xref" href="ch08.html#ebpf_for_networking">Chapter 8</a>.</p>&#13;
        </div>&#13;
        <p>You have seen the C source code, so the next step is to compile it into an object the kernel can&#13;
            understand.<a contenteditable="false" data-primary="" data-startref="ch03.html7" data-type="indexterm" id="idm46123200934960"/></p>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Compiling an eBPF Object File" data-type="sect1"><div class="sect1" id="compiling_an_ebpf_object_file">&#13;
        <h1>Compiling an eBPF Object File</h1>&#13;
        <p><a contenteditable="false" data-primary="object file" data-secondary="compiling" data-type="indexterm" id="idm46123200932064"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="compiling an eBPF object file" data-type="indexterm" id="idm46123200930688"/>Our eBPF source code&#13;
            needs to be compiled into the machine instructions that the eBPF virtual machine can understand: eBPF&#13;
            bytecode. <a contenteditable="false" data-primary="Clang compiler" data-type="indexterm" id="idm46123200929216"/>The Clang&#13;
            compiler from the <a href="https://llvm.org">LLVM project</a> will do this if you specify&#13;
            <code>-target bpf</code>. The following is an extract from a Makefile that will do the compilation:</p>&#13;
        <pre data-code-language="make" data-type="programlisting"><code class="nf">hello.bpf.o</code><code class="o">:</code> %.<code class="n">o</code>: %.<code class="n">c</code>&#13;
   clang \<code class="w"/>&#13;
       -target bpf \<code class="w"/>&#13;
       -I/usr/include/<code class="k">$(</code><code class="nv">shell</code> <code class="nv">uname</code> -<code class="nv">m</code><code class="k">)</code>-linux-gnu \<code class="w"/>&#13;
       -g \<code class="w"/>&#13;
       -O2 -c <code class="k">$&lt;</code> -o <code class="k">$@</code><code class="w"/></pre>&#13;
        <p>This generates an object file called <em>hello.bpf.o</em> from the source code in <em>hello.bpf.c</em>. The&#13;
            <code>-g</code> flag is optional here,<sup><a data-type="noteref" href="ch03.html#ch03fn3" id="ch03fn3-marker">3</a></sup>&#13;
            but it generates debug information so that you can see the source code alongside the bytecode when you&#13;
            inspect the object file. Let’s inspect this object file to better understand the eBPF code it contains.</p>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Inspecting an eBPF Object File" data-type="sect1"><div class="sect1" id="inspecting_an_ebpf_object_file">&#13;
        <h1>Inspecting an eBPF Object File</h1>&#13;
        <p><a contenteditable="false" data-primary="object file" data-secondary="inspecting" data-type="indexterm" id="ch03.html9"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="inspecting an eBPF object file" data-type="indexterm" id="ch03.html10"/>The&#13;
            file utility is commonly used to determine the contents of a file:</p>&#13;
        <pre data-type="programlisting">$ file hello.bpf.o&#13;
hello.bpf.o: ELF 64-bit LSB relocatable, eBPF, version 1 (SYSV), with debug_info,&#13;
not stripped</pre>&#13;
        <p>This shows it’s an ELF (Executable and Linkable Format) file, containing eBPF code, for a 64-bit platform&#13;
            with LSB (least significant bit) architecture. It includes debug information if you used the <code>-g</code>&#13;
            flag at the compilation step.</p>&#13;
        <p><a contenteditable="false" data-primary="llvm-objdump" data-type="indexterm" id="idm46123200863216"/>You can inspect this&#13;
            object further with <code>llvm-objdump</code> to see the eBPF instructions:</p>&#13;
        <pre data-type="programlisting">$ llvm-objdump -S hello.bpf.o</pre>&#13;
        <p>Even if you’re not familiar with disassembly, the output from this command isn’t too hard to understand:</p>&#13;
        <pre data-type="programlisting">hello.bpf.o:    file format elf64-bpf               <a class="co" href="#list_id_3_9" id="code_id_3_9"><img alt="1" src="assets/1.png"/></a>&#13;
&#13;
Disassembly of section xdp:                         <a class="co" href="#list_id_3_10" id="code_id_3_10"><img alt="2" src="assets/2.png"/></a>&#13;
&#13;
0000000000000000 &lt;hello&gt;:                           <a class="co" href="#list_id_3_11" id="code_id_3_11"><img alt="3" src="assets/3.png"/></a>&#13;
;  bpf_printk("Hello World %d", counter");          <a class="co" href="#list_id_3_12" id="code_id_3_12"><img alt="4" src="assets/4.png"/></a> &#13;
    0:   18 06 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r6 = 0 ll&#13;
    2:   61 63 00 00 00 00 00 00 r3 = *(u32 *)(r6 + 0)&#13;
    3:   18 01 00 00 00 00 00 00 00 00 00 00 00 00 00 00 r1 = 0 ll&#13;
    5:   b7 02 00 00 0f 00 00 00 r2 = 15&#13;
    6:   85 00 00 00 06 00 00 00 call 6&#13;
;  counter++;                                       <a class="co" href="#list_id_3_13" id="code_id_3_13"><img alt="5" src="assets/5.png"/></a>&#13;
    7:   61 61 00 00 00 00 00 00 r1 = *(u32 *)(r6 + 0)&#13;
    8:   07 01 00 00 01 00 00 00 r1 += 1&#13;
    9:   63 16 00 00 00 00 00 00 *(u32 *)(r6 + 0) = r1&#13;
;  return XDP_PASS;                                 <a class="co" href="#list_id_3_14" id="code_id_3_14"><img alt="6" src="assets/6.png"/></a>&#13;
   10:   b7 00 00 00 02 00 00 00 r0 = 2&#13;
   11:   95 00 00 00 00 00 00 00 exit</pre>&#13;
        <dl class="calloutlist">&#13;
            <dt><a class="co" href="#code_id_3_9" id="list_id_3_9"><img alt="1" src="assets/1.png"/></a></dt>&#13;
            <dd>The first line gives further confirmation that <em>hello.bpf.o</em> is a 64-bit ELF file with eBPF code&#13;
                (there’s no particular rhyme or reason why some tools use the term <em>BPF</em> and others&#13;
                <em>eBPF</em>; as I said earlier, these terms are now practically interchangeable).</dd>&#13;
            <dt><a class="co" href="#code_id_3_10" id="list_id_3_10"><img alt="2" src="assets/2.png"/></a></dt>&#13;
            <dd>Next comes the disassembly of the section labeled <code>xdp</code>, which matches the <code>SEC()</code>&#13;
                definition in the C source code.</dd>&#13;
            <dt><a class="co" href="#code_id_3_11" id="list_id_3_11"><img alt="3" src="assets/3.png"/></a></dt>&#13;
            <dd>This section is a function called <code>hello</code>.</dd>&#13;
            <dt><a class="co" href="#code_id_3_12" id="list_id_3_12"><img alt="4" src="assets/4.png"/></a></dt>&#13;
            <dd>There are five lines of eBPF bytecode instructions that correspond to the source line&#13;
                <code>bpf_printk("Hello World %d", counter");</code>.</dd>&#13;
            <dt><a class="co" href="#code_id_3_13" id="list_id_3_13"><img alt="5" src="assets/5.png"/></a></dt>&#13;
            <dd>Three lines of eBPF bytecode instructions increment the <code>counter</code> variable.</dd>&#13;
            <dt><a class="co" href="#code_id_3_14" id="list_id_3_14"><img alt="6" src="assets/6.png"/></a></dt>&#13;
            <dd>And another two lines of bytecode are generated from the source code <code>return XDP_PASS;</code>.</dd>&#13;
        </dl>&#13;
        <p>Unless you’re particularly keen to do so, there’s no real need to understand exactly how each line of&#13;
            bytecode relates to the source. The compiler takes care of generating the bytecode so that you don’t have to&#13;
            think about it! But let’s examine the output in a little more detail so you can get a feel for how this&#13;
            output relates to the eBPF instructions and registers you learned about earlier in this chapter.</p>&#13;
        <p>To the left of each line of bytecode you can see the offset of that instruction from wherever&#13;
            <code>hello</code> is located in memory. As described earlier in this chapter, eBPF instructions are&#13;
            generally 8 bytes long, and since on a 64-bit platform each memory location can hold 8 bytes, the offset is&#13;
            usually incremented by one for each instruction. <a contenteditable="false" data-primary="wide instruction encoding" data-type="indexterm" id="idm46123200813360"/>However, the first instruction&#13;
            in this program happens to be a wide instruction encoding that requires 16 bytes in order to set Register 6&#13;
            to a 64-bit value of <code>0</code>. That places the instruction in the second line of output at offset&#13;
            <code>2</code>. After that there is another 16-byte instruction, setting Register 1 to a 64-bit value of&#13;
            <code>0</code>. And after that, the remaining instructions each fit in 8 bytes, so the offset increments by&#13;
            one in each line.</p>&#13;
        <p>The first byte of each line is the opcode that tells the kernel what operation to perform, and on the right&#13;
            side of each instruction line is the human-readable interpretation of the instruction. <a contenteditable="false" data-primary="documentation" data-type="indexterm" id="idm46123200810400"/>At the time of this&#13;
            writing, the Iovisor project has the most complete <a href="https://oreil.ly/nLbLp">documentation</a> of the&#13;
            eBPF opcodes, but the official <a href="https://oreil.ly/yp-jW">Linux kernel documentation</a> is catching&#13;
            up, and the eBPF Foundation is working on <a href="https://oreil.ly/7ZWzj">standard documentation</a> that&#13;
            is not tied to a specific operating system.</p>&#13;
        <p>For example, let’s take the instruction at offset <code>5</code>, which looks like this:</p>&#13;
        <pre data-type="programlisting">    5:   b7 02 00 00 0f 00 00 00 r2 = 15</pre>&#13;
        <p>The opcode is <code>0xb7</code>, and the documentation tells us the pseudocode corresponding to this is&#13;
            <code>dst = imm</code>, which can be read as “Set the destination to the immediate value.” The destination&#13;
            is defined by the second byte, <code>0x02</code>, which means “Register 2.” The “immediate” (or literal)&#13;
            value here is <code>0x0f</code>, which is 15 in decimal. So we can understand that this instruction tells&#13;
            the kernel to “set Register 2 to value 15.” This corresponds to the output we see on the right side of the&#13;
            instruction: <code>r2 = 15</code>.</p>&#13;
        <p>The instruction at offset <code>10</code> is similar:</p>&#13;
        <pre data-type="programlisting">   10:   b7 00 00 00 02 00 00 00 r0 = 2</pre>&#13;
        <p>This line also has opcode <code>0xb7</code>, and this time it’s setting the value of Register 0 to&#13;
            <code>2</code>. When an eBPF program finishes running, Register 0 holds the return code, and&#13;
            <code>XDP_PASS</code> has the value <code>2</code>. This matches the source code, which always returns&#13;
            <code>XDP_PASS</code>.</p>&#13;
        <p>You now know that <em>hello.bpf.o</em> contains an eBPF program in bytecode. The next step is to load it into&#13;
            the kernel.<a contenteditable="false" data-primary="" data-startref="ch03.html10" data-type="indexterm" id="idm46123200797120"/><a contenteditable="false" data-primary="" data-startref="ch03.html9" data-type="indexterm" id="idm46123200795744"/></p>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Loading the Program into the Kernel" data-type="sect1"><div class="sect1" id="loading_the_program_into_the_kernel">&#13;
        <h1>Loading the Program into the Kernel</h1>&#13;
        <p><a contenteditable="false" data-primary="bpftool" data-secondary="loading program into kernel with" data-type="indexterm" id="idm46123200793088"/><a contenteditable="false" data-primary="kernel" data-secondary="loading eBPF program into" data-type="indexterm" id="idm46123200791648"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="loading into kernel" data-type="indexterm" id="idm46123200790256"/>For&#13;
            this example we’ll use a utility called <code>bpftool</code>. You can also load programs programmatically,&#13;
            and you’ll see examples of that later in the book.</p>&#13;
        <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
            <p>Some Linux distributions provide a package that includes <code>bpftool</code>, or you can <a href="https://github.com/libbpf/bpftool">compile it from source code</a>. You can find more details&#13;
                about installing or building this tool on <a href="https://oreil.ly/Yqepv">Quentin Monnet’s blog</a>, as&#13;
                well as additional documentation and usage on the <a href="https://oreil.ly/rnTIg">Cilium site</a>.</p>&#13;
        </div>&#13;
        <p>The following is an example of using <code>bpftool</code> to load a program into the kernel. <a contenteditable="false" data-primary="privileges" data-secondary="for running eBPF programs" data-type="indexterm" id="idm46123200783344"/>Note that you’ll likely need to be root (or use&#13;
            <code>sudo</code>) to get the BPF privileges that <code>bpftool</code> requires.</p>&#13;
        <pre data-type="programlisting">$ bpftool prog load hello.bpf.o /sys/fs/bpf/hello</pre>&#13;
        <p>This loads the eBPF program from our compiled object file and “pins” it to the location&#13;
            <em>/sys/fs/bpf/hello</em>.<sup><a data-type="noteref" href="ch03.html#ch03fn4" id="ch03fn4-marker">4</a></sup> No output&#13;
            response to this command indicates success, but you can confirm that the program is in place using&#13;
            <code>ls</code>:</p>&#13;
        <pre data-type="programlisting">$ ls /sys/fs/bpf&#13;
hello</pre>&#13;
        <p>The eBPF program has been successfully loaded. Let’s use the <code>bpftool</code> utility to find out more&#13;
            about the program and its status within the kernel.</p>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Inspecting the Loaded Program" data-type="sect1"><div class="sect1" id="inspecting_the_loaded_program">&#13;
        <h1>Inspecting the Loaded Program</h1>&#13;
        <p><a contenteditable="false" data-primary="inspecting loaded programs" data-type="indexterm" id="ch03.html12"/><a contenteditable="false" data-primary="kernel" data-secondary="inspecting loaded program in" data-type="indexterm" id="ch03.html13"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="inspecting loaded program in kernel" data-type="indexterm" id="ch03.html14"/>The <a contenteditable="false" data-primary="bpftool" data-secondary="listing programs with" data-type="indexterm" id="idm46123200767440"/><code>bpftool</code> utility can&#13;
            list all the programs that are loaded into the kernel. If you try this yourself you’ll probably see several&#13;
            preexisting eBPF programs in this output, but for clarity I will just show the lines that relate to our&#13;
            “Hello World” example:</p>&#13;
        <pre data-type="programlisting">$ bpftool prog list &#13;
...&#13;
540: xdp  name hello  tag d35b94b4c0c10efb  gpl&#13;
        loaded_at 2022-08-02T17:39:47+0000  uid 0&#13;
        xlated 96B  jited 148B  memlock 4096B  map_ids 165,166&#13;
        btf_id 254</pre>&#13;
        <p>The program has been assigned the ID 540. This identity is a number assigned to each program as it’s loaded.&#13;
            Knowing the ID, you can ask <code>bpftool</code> to show more information about this program. This time,&#13;
            let’s get the output in prettified JSON format so that the field names are visible, as well as the values:&#13;
        </p>&#13;
        <pre data-type="programlisting">$ bpftool prog show id 540 --pretty&#13;
{&#13;
    "id": 540,&#13;
    "type": "xdp",&#13;
    "name": "hello",&#13;
    "tag": "d35b94b4c0c10efb",&#13;
    "gpl_compatible": true,&#13;
    "loaded_at": 1659461987,&#13;
    "uid": 0,&#13;
    "bytes_xlated": 96,&#13;
    "jited": true,&#13;
    "bytes_jited": 148,&#13;
    "bytes_memlock": 4096,&#13;
    "map_ids": [165,166&#13;
    ],&#13;
    "btf_id": 254&#13;
}</pre>&#13;
        <p>Given the field names, a lot of this is straightforward to understand:</p>&#13;
        <ul>&#13;
            <li>&#13;
                <p>The program’s ID is 540.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>The <code>type</code> field tells us this program can be attached to a network interface using the&#13;
                    XDP event. Several other types of BPF programs can be attached to different sorts of events, and&#13;
                    we’ll discuss this more in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>The name of the program is <code>hello</code>, which is the function name from the source code.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>The <code>tag</code> is another identifier for this program, which I’ll describe in more detail&#13;
                    shortly.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>The program is defined with a GPL-compatible license.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>There’s a timestamp showing when the program was loaded.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>User ID 0 (which is root) loaded the program.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>There are 96 bytes of translated eBPF bytecode in this program, which I’ll show you shortly.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>This program has been JIT-compiled, and the compilation resulted in 148 bytes of machine code. I’ll&#13;
                    cover this shortly too.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>The <code>bytes _memlock</code> field tells us this program reserves 4,096 bytes of memory that won’t&#13;
                    be paged out.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>This program refers to BPF maps with IDs 165 and 166. This might seem surprising, since there is no&#13;
                    obvious reference to maps in the source code. You’ll see later in this chapter how map semantics are&#13;
                    used to handle global data in eBPF programs.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>You’ll learn about BTF in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, but for now just&#13;
                    know that <code>btf_id</code> indicates there is a block of BTF information for this program. This&#13;
                    information is included in the object file only if you compile with the <code>-g</code> flag.</p>&#13;
            </li>&#13;
        </ul>&#13;
        <section data-pdf-bookmark="The BPF Program Tag" data-type="sect2"><div class="sect2" id="the_bpf_program_tag">&#13;
            <h2>The BPF Program Tag</h2>&#13;
            <p><a contenteditable="false" data-primary="inspecting loaded programs" data-secondary="BPF program tag" data-type="indexterm" id="idm46123200744832"/><a contenteditable="false" data-primary="program tag" data-type="indexterm" id="idm46123200743440"/><a contenteditable="false" data-primary="tag, BPF program" data-type="indexterm" id="idm46123200742336"/>The <code>tag</code> is a SHA (Secure Hashing Algorithm) sum of the&#13;
                program’s instructions, which can be used as another identifier for the program. The ID can vary every&#13;
                time you load or unload the program, but the tag will remain the same. The <code>bpftool</code> utility&#13;
                accepts references to a BPF program by ID, name, tag, or pinned path, so in the example here, all of the&#13;
                following would give the same output:</p>&#13;
            <ul>&#13;
                <li>&#13;
                    <p><code>bpftool prog show id 540</code></p>&#13;
                </li>&#13;
                <li>&#13;
                    <p><code>bpftool prog show name hello</code></p>&#13;
                </li>&#13;
                <li>&#13;
                    <p><code>bpftool prog show tag d35b94b4c0c10efb</code></p>&#13;
                </li>&#13;
                <li>&#13;
                    <p><code>bpftool prog show pinned /sys/fs/bpf/hello</code></p>&#13;
                </li>&#13;
            </ul>&#13;
            <p>You could have multiple programs with the same name, and even multiple instances of programs with the&#13;
                same tag, but the ID and pinned path will always be unique.</p>&#13;
        </div></section>&#13;
        <section data-pdf-bookmark="The Translated Bytecode" data-type="sect2"><div class="sect2" id="the_translated_bytecode">&#13;
            <h2>The Translated Bytecode</h2>&#13;
            <p><a contenteditable="false" data-primary="bytecode" data-secondary="translated" data-type="indexterm" id="idm46123200733248"/><a contenteditable="false" data-primary="inspecting loaded programs" data-secondary="translated bytecode" data-type="indexterm" id="idm46123200731872"/>The <code>bytes_xlated</code>&#13;
                field tells us how many bytes of “translated” eBPF code there are. This is the eBPF bytecode after it&#13;
                has passed through the verifier (and possibly been modified by the kernel for reasons I’ll discuss later&#13;
                in this book).</p>&#13;
            <p><a contenteditable="false" data-primary="bpftool" data-secondary="showing translated code with" data-type="indexterm" id="idm46123200729568"/>Let’s use <code>bpftool</code> to show this translated version of&#13;
                our “Hello World” code:</p>&#13;
            <pre data-type="programlisting">$ bpftool prog dump xlated name hello &#13;
int hello(struct xdp_md * ctx):&#13;
; bpf_printk("Hello World %d", counter);&#13;
   0: (18) r6 = map[id:165][0]+0&#13;
   2: (61) r3 = *(u32 *)(r6 +0)&#13;
   3: (18) r1 = map[id:166][0]+0&#13;
   5: (b7) r2 = 15&#13;
   6: (85) call bpf_trace_printk#-78032&#13;
; counter++; &#13;
   7: (61) r1 = *(u32 *)(r6 +0)&#13;
   8: (07) r1 += 1&#13;
   9: (63) *(u32 *)(r6 +0) = r1&#13;
; return XDP_PASS;&#13;
  10: (b7) r0 = 2&#13;
  11: (95) exit</pre>&#13;
            <p>This looks very similar to the disassembled code you saw earlier in the output from&#13;
                <code>llvm-objdump</code>. The offset addresses are the same, and the instructions look similar—for&#13;
                example, we can see the instruction at offset <code>5</code> is <code>r2=15</code>.</p>&#13;
        </div></section>&#13;
        <section data-pdf-bookmark="The JIT-Compiled Machine Code" data-type="sect2"><div class="sect2" id="the_jit_compiled_machine_code">&#13;
            <h2>The JIT-Compiled Machine Code</h2>&#13;
            <p><a contenteditable="false" data-primary="bytecode" data-secondary="JIT-compiled machine code" data-type="indexterm" id="idm46123200723344"/><a contenteditable="false" data-primary="inspecting loaded programs" data-secondary="JIT-compiled machine code" data-type="indexterm" id="idm46123200721904"/><a contenteditable="false" data-primary="JIT compilation" data-type="indexterm" id="idm46123200720496"/>The&#13;
                translated bytecode is pretty low level, but it’s not quite machine code yet. eBPF uses a JIT compiler&#13;
                to convert eBPF bytecode to machine code that runs natively on the target CPU. The&#13;
                <code>bytes_jited</code> field shows that after this conversation the program is 108 bytes long.</p>&#13;
            <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
                <p>For higher performance, eBPF programs are generally JIT-compiled. The alternative is to interpret the&#13;
                    eBPF bytecode at runtime. The eBPF instruction set and registers were designed to map fairly closely&#13;
                    to native machine instructions to make this interpretation straightforward and therefore relatively&#13;
                    fast, but compiled programs will be faster, and most architectures now support JIT.<sup><a data-type="noteref" href="ch03.html#ch03fn5" id="ch03fn5-marker">5</a></sup></p>&#13;
            </div>&#13;
            <p><a contenteditable="false" data-primary="bpftool" data-secondary="generating dump of JIT-compiled code with" data-type="indexterm" id="idm46123200714768"/>The <code>bpftool</code>&#13;
                utility can generate a dump of this JITed code in assembly language. Don’t worry if you’re not familiar&#13;
                with assembly language and this looks entirely incomprehensible! I have included it only to illustrate&#13;
                all the transformations the eBPF code goes through from source code to the executable machine&#13;
                instructions. Here is the command and its output:</p>&#13;
            <pre data-type="programlisting">$ bpftool prog dump jited name hello &#13;
int hello(struct xdp_md * ctx):&#13;
bpf_prog_d35b94b4c0c10efb_hello:&#13;
; bpf_printk("Hello World %d", counter);&#13;
   0:   hint    #34&#13;
   4:   stp     x29, x30, [sp, #-16]!&#13;
   8:   mov     x29, sp&#13;
   c:   stp     x19, x20, [sp, #-16]!&#13;
  10:   stp     x21, x22, [sp, #-16]!&#13;
  14:   stp     x25, x26, [sp, #-16]!&#13;
  18:   mov     x25, sp&#13;
  1c:   mov     x26, #0&#13;
  20:   hint    #36&#13;
  24:   sub     sp, sp, #0&#13;
  28:   mov     x19, #-140733193388033&#13;
  2c:   movk    x19, #2190, lsl #16&#13;
  30:   movk    x19, #49152&#13;
  34:   mov     x10, #0&#13;
  38:   ldr     w2, [x19, x10]&#13;
  3c:   mov     x0, #-205419695833089&#13;
  40:   movk    x0, #709, lsl #16&#13;
  44:   movk    x0, #5904&#13;
  48:   mov     x1, #15&#13;
  4c:   mov     x10, #-6992&#13;
  50:   movk    x10, #29844, lsl #16&#13;
  54:   movk    x10, #56832, lsl #32&#13;
  58:   blr     x10&#13;
  5c:   add     x7, x0, #0&#13;
; counter++; &#13;
  60:   mov     x10, #0&#13;
  64:   ldr     w0, [x19, x10]&#13;
  68:   add     x0, x0, #1&#13;
  6c:   mov     x10, #0&#13;
  70:   str     w0, [x19, x10]&#13;
; return XDP_PASS;&#13;
  74:   mov     x7, #2&#13;
  78:   mov     sp, sp&#13;
  7c:   ldp     x25, x26, [sp], #16&#13;
  80:   ldp     x21, x22, [sp], #16&#13;
  84:   ldp     x19, x20, [sp], #16&#13;
  88:   ldp     x29, x30, [sp], #16&#13;
  8c:   add     x0, x7, #0&#13;
  90:   ret</pre>&#13;
            <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
                <p>Some packaged distributions of <code>bpftool</code> don’t yet include support for dumping the JITed&#13;
                    output, and if that’s the case, you’ll see “Error: No libbfd support.” You can build&#13;
                    <code>bpftool</code> for yourself by following the instructions at <a href="https://github.com/libbpf/bpftool"><em class="hyperlink">https://github.com/libbpf/bpftool</em></a>.</p>&#13;
            </div>&#13;
            <p>You’ve seen that the “Hello World” program has been loaded into the kernel, but at this point it’s not&#13;
                yet associated with an event, so nothing will trigger it to run. It needs to be attached to an event.<a contenteditable="false" data-primary="" data-startref="ch03.html14" data-type="indexterm" id="idm46123200707168"/><a contenteditable="false" data-primary="" data-startref="ch03.html13" data-type="indexterm" id="idm46123200705792"/><a contenteditable="false" data-primary="" data-startref="ch03.html12" data-type="indexterm" id="idm46123200704416"/></p>&#13;
        </div></section>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Attaching to an Event" data-type="sect1"><div class="sect1" id="attaching_to_an_event">&#13;
        <h1>Attaching to an Event</h1>&#13;
        <p><a contenteditable="false" data-primary="attachment" data-secondary="of program to event" data-type="indexterm" id="ch03.html15"/><a contenteditable="false" data-primary="event" data-secondary="attaching program to" data-type="indexterm" id="ch03.html16"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="attaching to an event" data-type="indexterm" id="ch03.html17"/>The program type has to match the type of event it’s&#13;
            being attached to; you’ll learn more about this in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>. <a contenteditable="false" data-primary="bpftool" data-secondary="attaching program to event with" data-type="indexterm" id="idm46123200694960"/>In this case it’s an XDP program, and you can&#13;
            use <code>bpftool</code> to attach the example eBPF program to the XDP event on a network interface, like&#13;
            this:</p>&#13;
        <pre data-type="programlisting">$ bpftool net attach xdp id 540 dev eth0</pre>&#13;
        <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
            <p>At the time of this writing, the <code>bpftool</code> utility doesn’t support the ability to attach all&#13;
                program types, but it has <a href="https://oreil.ly/Tt99p">recently been extended</a> to auto-attach&#13;
                k(ret)probes, u(ret)probes, and tracepoints.</p>&#13;
        </div>&#13;
        <p><a contenteditable="false" data-primary="tag, BPF program" data-type="indexterm" id="idm46123200689392"/>Here I have used&#13;
            the program’s ID of 540, but you can also use the name (provided it is unique) or tag to identify the&#13;
            program being attached. In this example, I have attached the program to the network interface&#13;
            <code>eth0</code>.</p>&#13;
        <p>You can view all the network-attached eBPF programs using <code>bpftool</code>:</p>&#13;
        <pre data-type="programlisting">$ bpftool net list &#13;
xdp:&#13;
eth0(2) driver id 540&#13;
&#13;
tc:&#13;
&#13;
flow_dissector:</pre>&#13;
        <p>The program with ID 540 is attached to the XDP event on the <code>eth0</code> interface. This output also&#13;
            gives some clues about some other potential events in the network stack that you can attach eBPF programs&#13;
            to: <code>tc</code> and <code>flow_dissector</code>. More on this in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>.</p>&#13;
        <p><a contenteditable="false" data-primary="ip link" data-type="indexterm" id="idm46123200682880"/>You can also inspect the&#13;
            network interfaces using <code>ip link</code>, and you’ll see output that looks something like this (some&#13;
            details have been removed for clarity):</p>&#13;
        <pre data-type="programlisting">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT&#13;
group default qlen 1000&#13;
    ...&#13;
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 xdp qdisc fq_codel state UP&#13;
mode DEFAULT group default qlen 1000&#13;
    ...&#13;
    prog/xdp id 540 tag 9d0e949f89f1a82c jited &#13;
    ...</pre>&#13;
        <p>In this example there are two interfaces: the loopback interface <code>lo</code>, which is used to send&#13;
            traffic to processes on this machine; and the <code>eth0</code> interface, which connects this machine to&#13;
            the outside world. This output also shows that <code>eth0</code> has a JIT-compiled eBPF program, with&#13;
            identity <code>540</code> and tag <code>9d0e949f89f1a82c</code>, attached to its XDP hook.</p>&#13;
        <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
            <p>You can also use <code>ip link</code> to attach and detach XDP programs to a network interface. I have&#13;
                included this as an exercise at the end of this chapter, and there are further examples in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>.&#13;
            </p>&#13;
        </div>&#13;
        <p>At this point, the <em>hello</em> eBPF program should be producing trace output every time a network packet&#13;
            is received. You can check this out by running <code>cat /sys/kernel/debug/tracing/trace_pipe</code>. This&#13;
            should show a lot of output that looks similar to this:</p>&#13;
        <pre data-type="programlisting">&lt;idle&gt;-0       [003] d.s.. 655370.944105: bpf_trace_printk: Hello World 4531&#13;
&lt;idle&gt;-0       [003] d.s.. 655370.944587: bpf_trace_printk: Hello World 4532&#13;
&lt;idle&gt;-0       [003] d.s.. 655370.944896: bpf_trace_printk: Hello World 4533</pre>&#13;
        <p><a contenteditable="false" data-primary="tracing" data-secondary="trace pipe" data-type="indexterm" id="idm46123200672176"/>If you’re struggling to remember the location of the trace pipe,&#13;
            you can get the same output using the command <code>bpftool prog tracelog</code>.</p>&#13;
        <p>In comparison to the output you saw in <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a>, this time&#13;
            there is no command or process ID associated with each of these events; instead, you see&#13;
            <code>&lt;idle&gt;-0</code> at the start of each line of trace. In <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a>, each&#13;
            syscall event happened because a process executing a command in user space made a call to the syscall API.&#13;
            That process ID and command are part of the context in which the eBPF program was executed. But in the&#13;
            example here, the XDP event happens due to the arrival of a network packet. There is no user space process&#13;
            associated with this packet—at the point the <em>hello</em> eBPF program is triggered, the system hasn’t&#13;
            done anything with the packet other than receive it in memory, and it has no idea what the packet is or&#13;
            where it’s going.</p>&#13;
        <p>You can see that the counter value that is traced out is being incremented by one each time, as expected. In&#13;
            the source code, <code>counter</code> is a global variable. Let’s see how that is implemented in eBPF using&#13;
            a map.<a contenteditable="false" data-primary="" data-startref="ch03.html17" data-type="indexterm" id="idm46123200665584"/><a contenteditable="false" data-primary="" data-startref="ch03.html16" data-type="indexterm" id="idm46123200664208"/><a contenteditable="false" data-primary="" data-startref="ch03.html15" data-type="indexterm" id="idm46123200662832"/></p>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Global Variables" data-type="sect1"><div class="sect1" id="global_variables">&#13;
        <h1>Global Variables</h1>&#13;
        <p><a contenteditable="false" data-primary="global variables" data-type="indexterm" id="ch03.html18"/><a contenteditable="false" data-primary="maps, BPF" data-secondary="repurposing semantics for use as global variables" data-type="indexterm" id="ch03.html19"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="global variables" data-type="indexterm" id="ch03.html20"/>As you learned in the&#13;
            previous chapter, an eBPF map is a data structure that can be accessed from an eBPF program or from user&#13;
            space. Since the same map can be accessed repeatedly by different runs of the same program, it can be used&#13;
            to hold state from one execution to the next. Multiple programs can also access the same map. Because of&#13;
            these characteristics, map semantics can be repurposed for use as global variables.</p>&#13;
        <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
            <p>Before support for <a href="https://oreil.ly/IDftt">global variables was added in 2019</a>, eBPF&#13;
                programmers had to write maps explicitly to perform the same task.</p>&#13;
        </div>&#13;
        <p>You saw earlier that <code>bpftool</code> shows this example program using two maps with the identities 165&#13;
            and 166. (You will probably see different identities if you try this for yourself, as the identities are&#13;
            assigned when the maps are created in the kernel.) Let’s explore what is in those maps.</p>&#13;
        <p><a contenteditable="false" data-primary="bpftool" data-secondary="showing maps loaded into kernel" data-type="indexterm" id="idm46123200650960"/>The <code>bpftool</code> utility can show the&#13;
            maps loaded into the kernel. For clarity I will only show the entries 165 and 166 that relate to the example&#13;
            “Hello World” program:</p>&#13;
        <pre data-type="programlisting">$ bpftool map list&#13;
165: array  name hello.bss  flags 0x400&#13;
        key 4B  value 4B  max_entries 1  memlock 4096B&#13;
        btf_id 254&#13;
166: array  name hello.rodata  flags 0x80&#13;
        key 4B  value 15B  max_entries 1  memlock 4096B&#13;
        btf_id 254  frozen</pre>&#13;
        <p>A bss<sup><a data-type="noteref" href="ch03.html#ch03fn6" id="ch03fn6-marker">6</a></sup>&#13;
            section in an object file compiled from a C program typically holds global variables, and you can use&#13;
            <code>bpftool</code> to inspect its contents, like this:</p>&#13;
        <pre data-type="programlisting">$ bpftool map dump name hello.bss&#13;
[{&#13;
        "value": {&#13;
            ".bss": [{&#13;
                    "counter": 11127&#13;
                }&#13;
            ]&#13;
        }&#13;
    }&#13;
]</pre>&#13;
        <p>I could also have used <code>bpftool map dump id 165</code> to retrieve the same information. If I run either&#13;
            of these commands again, I’ll see that the counter has increased, as the program has been run every time a&#13;
            network packet is received.</p>&#13;
        <p>As you’ll learn in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>, <code>bpftool</code> is able&#13;
            to pretty-print the field names from a map (here, the variable name <code>counter</code>) only if BTF&#13;
            information is available, and that information is included only if you compile with the <code>-g</code>&#13;
            flag. If you omitted that flag during the compilation step, you’d see something that looks more like this:&#13;
        </p>&#13;
        <pre data-type="programlisting">$ bpftool map dump name hello.bss&#13;
key: 00 00 00 00  value: 19 01 00 00&#13;
Found 1 element</pre>&#13;
        <p>Without BTF information, <code>bpftool</code> has no way of knowing what variable name was used in the source&#13;
            code. You can infer that since there is only one item in this map, the hex value <code>19 01 00 00</code>&#13;
            must be the current value of <code>counter</code> (281 in decimal, since the bytes are ordered starting with&#13;
            the least significant byte).</p>&#13;
        <p>You’ve seen here that the eBPF program uses the semantics of a map to read and write to a global variable.&#13;
            Maps are also used to hold static data, as you can see by inspecting the other map.</p>&#13;
        <p>The fact that the other map is named <code>hello.rodata</code> gives a hint that this could be read-only data&#13;
            related to our <em>hello</em> program. You can dump the contents of this map to see that it holds the string&#13;
            used by the eBPF program for tracing:</p>&#13;
        <pre data-type="programlisting">$ bpftool map dump name hello.rodata&#13;
[{&#13;
        "value": {&#13;
            ".rodata": [{&#13;
                    "hello.____fmt": "Hello World %d"&#13;
                }&#13;
            ]&#13;
        }&#13;
    }&#13;
]</pre>&#13;
        <p>If you didn’t compile the object with the <code>-g</code> flag, you’ll see output that looks like this:</p>&#13;
        <pre data-type="programlisting">$ bpftool map dump id 166&#13;
key: 00 00 00 00  value: 48 65 6c 6c 6f 20 57 6f  72 6c 64 20 25 64 00&#13;
Found 1 element</pre>&#13;
        <p>There is one key–value pair in this map, and the value contains 12 bytes of data ending with a 0. It probably&#13;
            won’t surprise you that those bytes are the ASCII representation of the string&#13;
            <code>"Hello World %d"</code>.</p>&#13;
        <p>Now that we’ve finished inspecting this program and its maps, it’s time to clean it up. We’ll start by&#13;
            detaching it from the event that triggers it.<a contenteditable="false" data-primary="" data-startref="ch03.html20" data-type="indexterm" id="idm46123200632944"/><a contenteditable="false" data-primary="" data-startref="ch03.html19" data-type="indexterm" id="idm46123200631568"/><a contenteditable="false" data-primary="" data-startref="ch03.html18" data-type="indexterm" id="idm46123200630192"/></p>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Detaching the Program" data-type="sect1"><div class="sect1" id="detaching_the_program">&#13;
        <h1>Detaching the Program</h1>&#13;
        <p><a contenteditable="false" data-primary="detaching program from network interface" data-type="indexterm" id="idm46123200627376"/><a contenteditable="false" data-primary="network interface" data-secondary="detaching program from" data-type="indexterm" id="idm46123200626176"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="detaching from network interface" data-type="indexterm" id="idm46123200624800"/><a contenteditable="false" data-primary="bpftool" data-secondary="detaching program from network interface with" data-type="indexterm" id="idm46123200623360"/>You can detach the program from&#13;
            the network interface like this:</p>&#13;
        <pre data-type="programlisting">$ bpftool net detach xdp dev eth0</pre>&#13;
        <p>There is no output if this command runs successfully, but you can confirm that the program is no longer&#13;
            attached by the lack of XDP entries in the output from <code>bpftool net list</code>:</p>&#13;
        <pre data-type="programlisting">$ bpftool net list &#13;
xdp:&#13;
&#13;
tc:&#13;
&#13;
flow_dissector:</pre>&#13;
        <p>However, the program is still loaded into the kernel:</p>&#13;
        <pre data-type="programlisting">$ bpftool prog show name hello &#13;
395: xdp  name hello  tag 9d0e949f89f1a82c  gpl&#13;
        loaded_at 2022-12-19T18:20:32+0000  uid 0&#13;
        xlated 48B  jited 108B  memlock 4096B  map_ids 4</pre>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Unloading the Program" data-type="sect1"><div class="sect1" id="unloading_the_program">&#13;
        <h1>Unloading the Program</h1>&#13;
        <p><a contenteditable="false" data-primary="kernel" data-secondary="removing program from" data-type="indexterm" id="idm46123200616416"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="removing from kernel" data-type="indexterm" id="idm46123200615040"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="unloading" data-type="indexterm" id="idm46123200613664"/><a contenteditable="false" data-primary="unloading programs" data-type="indexterm" id="idm46123200612288"/><a contenteditable="false" data-primary="bpftool" data-secondary="removing program from kernel with" data-type="indexterm" id="idm46123200611184"/>There’s no inverse of&#13;
            <code>bpftool prog load</code> (at least not at the time of this writing), but you can remove the program&#13;
            from the kernel by deleting the pinned pseudofile:</p>&#13;
        <pre data-type="programlisting">$ rm /sys/fs/bpf/hello&#13;
$ bpftool prog show name hello</pre>&#13;
        <p>There is no output from this <code>bpftool</code> command because the program is no longer loaded in the&#13;
            kernel.</p>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="BPF to BPF Calls" data-type="sect1"><div class="sect1" id="bpf_to_bpf_calls">&#13;
        <h1>BPF to BPF Calls</h1>&#13;
        <p><a contenteditable="false" data-primary="function calls" data-type="indexterm" id="ch03.html21"/><a contenteditable="false" data-primary="programs, eBPF" data-secondary="BPF to BPF calls" data-type="indexterm" id="ch03.html22"/><a contenteditable="false" data-primary="subprograms, eBPF" data-type="indexterm" id="ch03.html23"/>In the previous&#13;
            chapter you saw tail calls in action, and I mentioned that now there is also the ability to call functions&#13;
            from within an eBPF program. Let’s take a look at a simple example, which, like the tail call example, can&#13;
            be attached to the <code>sys_enter</code> tracepoint, except this time it will trace out the opcode for the&#13;
            syscall. You’ll find the code in <em>chapter3/hello-func.bpf.c</em>.</p>&#13;
        <p>For illustrative purposes I have written a very simple function that extracts the syscall opcode from the&#13;
            tracepoint arguments:</p>&#13;
        <pre data-code-language="c" data-type="programlisting"><code class="k">static</code><code class="w"> </code><code class="n">__attribute</code><code class="p">((</code><code class="n">noinline</code><code class="p">))</code><code class="w"> </code><code class="kt">int</code><code class="w"> </code><code class="n">get_opcode</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">bpf_raw_tracepoint_args</code><code class="w"> </code>&#13;
<code class="w">                                                                         </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="n">ctx</code><code class="o">-&gt;</code><code class="n">args</code><code class="p">[</code><code class="mi">1</code><code class="p">];</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
        <p>Given the choice, the compiler would probably inline this very simple function that I’m only going to call&#13;
            from one place. Since that would defeat the point of this example, I have added&#13;
            <code>__attribute((noinline))</code> to force the compiler’s hand. In normal circumstances you should&#13;
            probably omit this and allow the compiler to optimize as it sees fit.</p>&#13;
        <p>The eBPF function that calls this function looks like this:</p>&#13;
        <pre data-code-language="c" data-type="programlisting"><code class="n">SEC</code><code class="p">(</code><code class="s">"raw_tp"</code><code class="p">)</code><code class="w"/>&#13;
<code class="kt">int</code><code class="w"> </code><code class="n">hello</code><code class="p">(</code><code class="k">struct</code><code class="w"> </code><code class="nc">bpf_raw_tracepoint_args</code><code class="w"> </code><code class="o">*</code><code class="n">ctx</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">   </code><code class="kt">int</code><code class="w"> </code><code class="n">opcode</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="n">get_opcode</code><code class="p">(</code><code class="n">ctx</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="n">bpf_printk</code><code class="p">(</code><code class="s">"Syscall: %d"</code><code class="p">,</code><code class="w"> </code><code class="n">opcode</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">   </code><code class="k">return</code><code class="w"> </code><code class="mi">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
        <p><a contenteditable="false" data-primary="bpftool" data-secondary="loading program into kernel with" data-type="indexterm" id="idm46123200470128"/>After compiling this to an eBPF object file,&#13;
            you can load it into the kernel and confirm that it is loaded with <code>bpftool</code>:</p>&#13;
        <pre data-type="programlisting">$ bpftool prog load hello-func.bpf.o /sys/fs/bpf/hello&#13;
$ bpftool prog list name hello &#13;
893: raw_tracepoint  name hello  tag 3d9eb0c23d4ab186  gpl&#13;
        loaded_at 2023-01-05T18:57:31+0000  uid 0&#13;
        xlated 80B  jited 208B  memlock 4096B  map_ids 204&#13;
        btf_id 302</pre>&#13;
        <p>The interesting part of this exercise is inspecting the eBPF bytecode to see the <code>get_opcode()</code>&#13;
            function:</p>&#13;
        <pre data-type="programlisting">$ bpftool prog dump xlated name hello &#13;
int hello(struct bpf_raw_tracepoint_args * ctx):&#13;
; int opcode = get_opcode(ctx);                            <a class="co" href="#list_id_3_15" id="code_id_3_15"><img alt="1" src="assets/1.png"/></a>&#13;
   0: (85) call pc+7#bpf_prog_cbacc90865b1b9a5_get_opcode&#13;
; bpf_printk("Syscall: %d", opcode);&#13;
   1: (18) r1 = map[id:193][0]+0&#13;
   3: (b7) r2 = 12&#13;
   4: (bf) r3 = r0&#13;
   5: (85) call bpf_trace_printk#-73584&#13;
; return 0;&#13;
   6: (b7) r0 = 0&#13;
   7: (95) exit&#13;
int get_opcode(struct bpf_raw_tracepoint_args * ctx):      <a class="co" href="#list_id_3_16" id="code_id_3_16"><img alt="2" src="assets/2.png"/></a>&#13;
; return ctx-&gt;args[1];&#13;
   8: (79) r0 = *(u64 *)(r1 +8)&#13;
; return ctx-&gt;args[1];&#13;
   9: (95) exit</pre>&#13;
        <dl class="calloutlist">&#13;
            <dt><a class="co" href="#code_id_3_15" id="list_id_3_15"><img alt="1" src="assets/1.png"/></a></dt>&#13;
            <dd>Here you can see the <code>hello()</code> eBPF program making a call to <code>get_opcode()</code>. The&#13;
                eBPF instruction at offset <code>0</code> is <code>0x85</code>, which from the instruction set&#13;
                documentation corresponds to “Function call.” Instead of executing the next instruction, which would be&#13;
                at offset 1, execution will jump seven instructions ahead (<code>pc+7</code>), which means the&#13;
                instruction at offset <code>8</code>.</dd>&#13;
            <dt><a class="co" href="#code_id_3_16" id="list_id_3_16"><img alt="2" src="assets/2.png"/></a></dt>&#13;
            <dd>Here’s the bytecode for <code>get_opcode()</code>, and as you might hope, the first instruction is at&#13;
                offset <code>8</code>.</dd>&#13;
        </dl>&#13;
        <p>The function call instruction necessitates putting the current state on the eBPF virtual machine’s stack so&#13;
            that when the called function exits, execution can continue in the calling function. Since the stack size is&#13;
            limited to 512 bytes, BPF to BPF calls can’t be very deeply nested.</p>&#13;
        <div data-type="note" epub:type="note"><h6>Note</h6>&#13;
            <p>For a lot more detail on tail calls and BPF to BPF calls, there’s an excellent post by Jakub Sitnicki on&#13;
                Cloudflare’s blog: <a href="https://oreil.ly/6kOp3">“Assembly within! BPF tail calls on x86 and&#13;
                    ARM”</a>.<a contenteditable="false" data-primary="" data-startref="ch03.html22" data-type="indexterm" id="idm46123200432144"/><a contenteditable="false" data-primary="" data-startref="ch03.html21" data-type="indexterm" id="idm46123200430768"/><a contenteditable="false" data-primary="" data-startref="ch03.html23" data-type="indexterm" id="idm46123200429392"/></p>&#13;
        </div>&#13;
    </div></section>&#13;
    <section class="pagebreak-before" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary_id000012">&#13;
        <h1 class="less_space">Summary</h1>&#13;
        <p>In this chapter you saw some example C source code transformed into eBPF bytecode and then compiled to&#13;
            machine code so that it’s ready to be executed in the kernel. You also learned how to use&#13;
            <code>bpftool</code> to inspect programs and maps loaded into the kernel, and to attach to XDP events.</p>&#13;
        <p>In addition, you saw examples of different types of eBPF programs triggered by different kinds of events. An&#13;
            XDP event is triggered by the arrival of a packet of data on a network interface, whereas kprobe and&#13;
            tracepoint events are triggered by hitting some particular point in kernel code. I’ll discuss some other&#13;
            eBPF program types in <a data-type="xref" href="ch07.html#ebpf_program_and_attachment_types">Chapter 7</a>.</p>&#13;
        <p>You also learned how maps are used to implement global variables for eBPF programs, and you saw BPF to BPF&#13;
            function calls.</p>&#13;
        <p>The next chapter goes into another level of detail as I show you what’s happening at the system call level&#13;
            when <code>bpftool</code>—or any other user space code—loads programs and attaches them to events.<a contenteditable="false" data-primary="" data-startref="ch03.html1" data-type="indexterm" id="idm46123200422016"/><a contenteditable="false" data-primary="" data-startref="ch03.html0" data-type="indexterm" id="idm46123200420640"/></p>&#13;
    </div></section>&#13;
    <section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="exercises_id000002">&#13;
        <h1>Exercises</h1>&#13;
        <p>Here are a few things to try if you want to explore BPF programs further:</p>&#13;
        <ol>&#13;
            <li>&#13;
                <p>Try using <code>ip link</code> commands like the following to attach and detach the XDP program:</p>&#13;
                <pre data-type="programlisting">$ ip link set dev eth0 xdp obj hello.bpf.o sec xdp&#13;
$ ip link set dev eth0 xdp off</pre>&#13;
            </li>&#13;
            <li>&#13;
                <p>Run any of the BCC examples from <a data-type="xref" href="ch02.html#ebpfapostrophes_quotation_markhello_wor">Chapter 2</a>.&#13;
                    While the program is running, use a second terminal window to inspect the loaded program using&#13;
                    <code>bpftool</code>. Here’s an example of what I saw by running the <em>hello-map.py</em> example:&#13;
                </p>&#13;
                <pre data-type="programlisting">$ bpftool prog show name hello &#13;
197: kprobe  name hello  tag ba73a317e9480a37  gpl&#13;
        loaded_at 2022-08-22T08:46:22+0000  uid 0&#13;
        xlated 296B  jited 328B  memlock 4096B  map_ids 65&#13;
        btf_id 179&#13;
        pids hello-map.py(2785)</pre>&#13;
                <p>You can also use <code>bpftool prog dump</code> commands to see the bytecode and machine code&#13;
                    versions of those programs.</p>&#13;
            </li>&#13;
            <li>&#13;
                <p>Run <em>hello-tail.py</em> from the <em>chapter2</em> directory, and while it’s running, take a look&#13;
                    at the programs it loaded. You’ll see that each tail call program is listed individually, like this:&#13;
                </p>&#13;
                <pre data-type="programlisting">$ bpftool prog list &#13;
...&#13;
120: raw_tracepoint  name hello  tag b6bfd0e76e7f9aac  gpl&#13;
        loaded_at 2023-01-05T14:35:32+0000  uid 0&#13;
        xlated 160B  jited 272B  memlock 4096B  map_ids 29&#13;
        btf_id 124&#13;
        pids hello-tail.py(3590)&#13;
121: raw_tracepoint  name ignore_opcode  tag a04f5eef06a7f555  gpl&#13;
        loaded_at 2023-01-05T14:35:32+0000  uid 0&#13;
        xlated 16B  jited 72B  memlock 4096B&#13;
        btf_id 124&#13;
        pids hello-tail.py(3590)&#13;
122: raw_tracepoint  name hello_exec  tag 931f578bd09da154  gpl&#13;
        loaded_at 2023-01-05T14:35:32+0000  uid 0&#13;
        xlated 112B  jited 168B  memlock 4096B&#13;
        btf_id 124&#13;
        pids hello-tail.py(3590)&#13;
123: raw_tracepoint  name hello_timer  tag 6c3378ebb7d3a617  gpl&#13;
        loaded_at 2023-01-05T14:35:32+0000  uid 0&#13;
        xlated 336B  jited 356B  memlock 4096B&#13;
        btf_id 124&#13;
        pids hello-tail.py(3590)</pre>&#13;
                <p>You could also use <code>bpftool prog dump xlated</code> to look at the bytecode instructions and&#13;
                    compare them to what you saw in <a data-type="xref" href="#bpf_to_bpf_calls">“BPF to BPF Calls”</a>.&#13;
                </p>&#13;
            </li>&#13;
            <li>&#13;
                <p><em>Be careful with this one, as it may be best to simply think about why this happens rather than&#13;
                        trying it!</em> If you return a <code>0</code> value from an XDP program, this corresponds to&#13;
                    <code>XDP_ABORTED</code>, which tells the kernel to abort any further processing of this packet.&#13;
                    This might seem a bit counterintuitive given that the <code>0</code> value usually indicates success&#13;
                    in C, but that’s how it is. So, if you try modifying the program to return <code>0</code> and attach&#13;
                    it to a virtual machine’s <code>eth0</code> interface, all network packets will get dropped. This&#13;
                    will be somewhat unfortunate if you’re using SSH to attach to that machine, and you’ll likely have&#13;
                    to reboot the machine to regain access!</p>&#13;
                <p>You could run the program within a container so that the XDP program is attached to a virtual&#13;
                    Ethernet interface that only affects that container and not the whole virtual machine. There’s an&#13;
                    example of doing this at <a href="https://github.com/lizrice/lb-from-scratch"><em class="hyperlink">https://github.com/lizrice/lb-from-scratch</em></a>.</p>&#13;
            </li>&#13;
        </ol>&#13;
    </div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="ch03fn1"><sup><a href="ch03.html#ch03fn1-marker">1</a></sup> Increasingly, eBPF programs are also being&#13;
            written in Rust, since the Rust compiler supports eBPF bytecode as a target.</p><p data-type="footnote" id="ch03fn2"><sup><a href="ch03.html#ch03fn2-marker">2</a></sup> There are a few instructions where the operation is&#13;
                        “modified” by the value of other fields in the instruction. For example, there are a set of <a href="https://oreil.ly/oyTI7">atomic instructions</a> introduced in kernel 5.12 that include&#13;
                        an arithmetic operation (<code>ADD</code>, <code>AND</code>, <code>OR</code>, <code>XOR</code>)&#13;
                        that is specified in the <code>imm</code> field.</p><p data-type="footnote" id="ch03fn3"><sup><a href="ch03.html#ch03fn3-marker">3</a></sup> The <code>-g</code> flag is&#13;
                required to generate BTF information that you’ll need for CO-RE eBPF programs, which I’ll cover in <a data-type="xref" href="ch05.html#co_recomma_btfcomma_and_libbpf">Chapter 5</a>.</p><p data-type="footnote" id="ch03fn4"><sup><a href="ch03.html#ch03fn4-marker">4</a></sup> In general, this is optional—eBPF&#13;
                programs can be loaded into the kernel without being pinned to a file location—but it’s not optional for&#13;
                <code>bpftool</code>, which always has to pin the programs it loads. The reason for this is covered&#13;
                further in <a data-type="xref" href="ch04.html#bpf_program_and_map_references">“BPF Program and Map References”</a>.</p><p data-type="footnote" id="ch03fn5"><sup><a href="ch03.html#ch03fn5-marker">5</a></sup> The kernel setting <code>CONFIG_BPF_JIT</code> needs to be&#13;
                        enabled to take advantage of JIT compilation, and it can be enabled or disabled at runtime with&#13;
                        the <code>net.core.bpf_jit_enable sysctl</code> setting. See <a href="https://oreil.ly/4-xi6">the docs</a> for more&#13;
                        information on JIT support on different chip architectures.</p><p data-type="footnote" id="ch03fn6"><sup><a href="ch03.html#ch03fn6-marker">6</a></sup> Here, <em>bss</em> stands for “block started by symbol.”</p></div></div></section></body></html>