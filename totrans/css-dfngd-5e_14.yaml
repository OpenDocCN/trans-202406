- en: Chapter 14\. Fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The “Font Properties” section of the CSS1 specification, written in 1996, begins
    with this sentence: “Setting font properties will be among the most common uses
    of style sheets.” Despite the awareness of font’s importance from the very beginning
    of CSS, it wasn’t until about 2009 that this capability really began to be widely
    and consistently supported. With the introduction of variable fonts, typography
    on the web has become an art form. While you can include any fonts you are legally
    allowed to distribute in your design, you have to pay attention to how you use
    them.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to remember this does not grant absolute control over fonts.
    If the font you’re using fails to download, or is in a file format the user’s
    browser doesn’t understand, the text will (eventually) be displayed with a fallback
    font. That’s a good thing, as it means the user still gets your content.
  prefs: []
  type: TYPE_NORMAL
- en: While fonts may seem vital to a design, always bear in mind you can’t depend
    on the presence of a given font. If a font is slow to load, browsers generally
    delay text rendering. While that prevents text being redrawn while a user is reading,
    it’s bad to have no text on the page.
  prefs: []
  type: TYPE_NORMAL
- en: Your font choice may also be overridden by user preference, or a browser extension
    meant to enhance the reading experience. An example is the browser extension OpenDyslexic,
    which “overrides all fonts on web pages with the OpenDyslexic font, and formats
    pages to be more easily readable.” In general, always design assuming your fonts
    will be delayed and even fail altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Font Families
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What we think of as a “font” is usually composed of many variations to describe
    bold text, italic text, bold italic text, and so on. For example, you’re probably
    familiar with (or at least have heard of) the font Times. Times is actually a
    combination of many variants, including TimesRegular, TimesBold, TimesItalic,
    TimesBoldItalic, and so on. Each variant of Times is an actual *font face*, and
    Times, as we usually think of it, is a combination of all these variant faces.
    In other words, system-standard fonts like Times are actually a *font family*,
    not just a single font, even though most of us think about fonts as being single
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: With such font families, a separate file is required for each width, weight,
    and style combination (that is, each font face), meaning you can have upward of
    20 separate files for a complete typeface. *Variable fonts*, on the other hand,
    are able to store multiple variants, such as regular, bold, italic, and bold italic,
    in a single file. Variable font files are generally a little bit larger (maybe
    just a few kilobytes) than any single font face file, but smaller than the multiple
    files required of a regular font, and require only a single HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: 'To cover all the bases, CSS defines five generic font families:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Serif fonts*'
  prefs: []
  type: TYPE_NORMAL
- en: Serif fonts are proportional and have serifs. A font is *proportional* if all
    characters in the font have different widths. For example, a lowercase *i* and
    a lowercase *m* take up different horizontal spaces because they have different
    widths. (This book’s paragraph font is proportional, for example.) *Serifs* are
    the decorations on the ends of strokes within each character, such as little lines
    at the top and bottom of a lowercase *l*, or at the bottom of each leg of an uppercase
    *A*. Examples of serif fonts are Times, Georgia, and New Century Schoolbook.
  prefs: []
  type: TYPE_NORMAL
- en: '*Sans-serif fonts*'
  prefs: []
  type: TYPE_NORMAL
- en: Sans-serif fonts are proportional and do not have serifs. Examples of sans-serif
    fonts are Helvetica, Geneva, Verdana, Arial, and Univers.
  prefs: []
  type: TYPE_NORMAL
- en: '*Monospace fonts*'
  prefs: []
  type: TYPE_NORMAL
- en: Monospace fonts are not proportional. Rather, each character uses up the same
    amount of horizontal space as all the others; thus, a lowercase *i* takes up the
    same horizontal space as a lowercase *m*, even though their actual letterforms
    may have different widths. These generally are used for displaying programmatic
    code or tabular data, like this book’s code font, for example. If a font has uniform
    character widths, it is classified as monospace, regardless of whether it has
    serifs. Examples of monospace fonts are Courier, Courier New, Consolas, and Andale
    Mono.
  prefs: []
  type: TYPE_NORMAL
- en: '*Cursive fonts*'
  prefs: []
  type: TYPE_NORMAL
- en: Cursive fonts attempt to emulate human handwriting or lettering. Usually, they
    are composed largely of flowing curves and have stroke decorations that exceed
    those found in serif fonts. For example, an uppercase *A* might have a small curl
    at the bottom of its left leg or be composed entirely of swashes and curls. Examples
    of cursive fonts are Zapf Chancery, Author, and Comic Sans.
  prefs: []
  type: TYPE_NORMAL
- en: '*Fantasy fonts*'
  prefs: []
  type: TYPE_NORMAL
- en: Fantasy fonts are not really defined by any single characteristic other than
    our inability to easily classify them in one of the other families (these are
    sometimes called *decorative* or *display* fonts). A few such fonts are Western,
    Woodblock, and Klingon.
  prefs: []
  type: TYPE_NORMAL
- en: Your operating system and browser will have a default font family for each of
    these generic families. Fonts a browser cannot classify as serif, sans-serif,
    monospace, or cursive are generally considered fantasy. While most font families
    fall into one of these generic families, not all do. For example, SVG icon fonts,
    dingbat fonts, and Material Icons Round contain images rather than letters.
  prefs: []
  type: TYPE_NORMAL
- en: Using Generic Font Families
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can call on any available font family by using the property `font-family`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a document to use a sans-serif font but do not particularly care
    which one, the appropriate declaration would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the user agent to pick a sans-serif font family (such as Helvetica)
    and apply it to the `<body>` element. Thanks to inheritance, the same font family
    choice will be applied to all visible elements that descend from the `<body>`,
    unless overridden by the user agent. User agents generally apply a `font-family`
    property to some elements, such as `monospace` in the case of `<code>` and `<pre>`,
    or a system font to some form-input controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using nothing more than these generic families, you can create a fairly sophisticated
    stylesheet. The following rule set is illustrated in [Figure 14-1](#various_font_families):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Thus, most of this document will use a serif font such as Times, including all
    paragraphs except those that have a `class` of `signature`, which will instead
    be rendered in a cursive font such as Author. Heading levels 1 through 4 will
    use a sans-serif font like Helvetica, while the elements `<code>`, `<pre>`, `<tt>`,
    and `<kbd>` will use a monospace font like Courier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using generic defaults is excellent for rendering speed, as it allows the browser
    to use whichever default fonts it already has in memory rather than having to
    parse through a list of specific fonts and load characters as needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1401](assets/css5_1401.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-1\. Various font families
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A page author may, on the other hand, have more specific preferences for which
    font to use in the display of a document or element. In a similar vein, a user
    may want to create a user stylesheet that defines the exact fonts to be used in
    the display of all documents. In either case, `font-family` is still the property
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume for the moment that all `<h1>` elements should use Georgia as their
    font. The simplest rule for this would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the user agent displaying the document to use Georgia for all
    `<h1>` elements, assuming that the user agent has Georgia available for use. If
    it doesn’t, the user agent will be unable to use the rule at all. It won’t ignore
    the rule, but if it can’t find a font called `Georgia`, it can’t do anything but
    display `<h1>` elements using the user agent’s default font.
  prefs: []
  type: TYPE_NORMAL
- en: 'To handle a situation like this, you can give the user agent options by combining
    specific font families with generic font families. For example, the following
    markup tells a user agent to use Georgia if it’s available, and to use another
    serif font like Times as a fallback if it isn’t:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For this reason, we strongly encourage you to always provide a generic family
    as part of any `font-family` rule. By doing so, you provide a fallback mechanism
    that lets user agents pick an alternative when they can’t provide an exact font
    match. This is often referred to as a *font stack*. Here are a few more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you’re familiar with fonts, you might have a number of similar fonts in
    mind for displaying a given element. Let’s say that you want all paragraphs in
    a document to be displayed using Times, but you would also accept Times New Roman,
    Georgia, New Century Schoolbook, and New York (all of which are serif fonts) as
    alternate choices. First, decide the order of preference for these fonts, and
    then string them together with commas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Based on this list, a user agent will look for the fonts in the order they’re
    listed. If none of the listed fonts are available, it will just pick an available
    serif font.
  prefs: []
  type: TYPE_NORMAL
- en: Using Quotation Marks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed the presence of single quotes in the previous code example,
    which we haven’t used before in this chapter. Quotation marks are advisable in
    a `font-family` declaration only if a font name contains one or more spaces, such
    as `New York`, or if the font name includes symbols. Thus, a font called `Karrank%`
    should be quoted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While quoting font names is almost never required, if you leave off the quotation
    marks, user agents may ignore the font name and continue to the next available
    font in the font stack. The exception to this is font names that match accepted
    `font-family` keywords. For example, if your font name is `cursive`, `serif`,
    `sans-serif`, `monospace`, or `fantasy`, it must be quoted so the user agent knows
    the difference between a font name and a font-family keyword, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The actual generic family names (`serif`, `monospace`, etc.) should never be
    quoted. If they are quoted, the browser will look for a font with that exact name.
  prefs: []
  type: TYPE_NORMAL
- en: 'When quoting font names, either single or double quotes are acceptable, as
    long as they match. Remember that if you place a `font-family` rule in a `style`
    attribute, which you generally shouldn’t, you’ll need to use whichever quotes
    you didn’t use for the attribute itself. Therefore, if you use double quotes to
    enclose the `font-family` rule, you’ll have to use single quotes within the rule,
    as in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you use double quotes in such a circumstance, they interfere with the attribute
    syntax. Note the font name is case-insensitive.
  prefs: []
  type: TYPE_NORMAL
- en: Using Custom Fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `@font-face` rule enables you to use custom fonts on the web, instead of
    being forced to rely only on “web-safe” fonts (that is, font families that are
    widely installed, such as Times). The two required functions of the `@font-face`
    rule are to declare the name used to refer to a font and to provide the URL of
    that font’s file for downloading. In addition to these required descriptors, CSS
    has 14 optional descriptors.
  prefs: []
  type: TYPE_NORMAL
- en: While there’s no guarantee that every user will see the font you want, `@font-face`
    is supported in all browsers except ones like Opera Mini that intentionally don’t
    support it for performance reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to use a very specific font in your stylesheets, one that
    is not widely installed. Through the magic of `@font-face`, you can define a specific
    family name to correspond to a font file on your server that you can refer to
    throughout your CSS. The user agent will download that file and use it to render
    the text in your page, the same as if it were installed on the user’s machine.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows you to tell user agents to load the defined *.otf* file and use
    that font to render text when called upon via `font-family: SwitzeraADF`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The examples in this section refer to SwitzeraADF, a font face collection available
    from the [Arkandis Digital Foundry](http://arkandis.tuxfamily.org/openfonts.html).
  prefs: []
  type: TYPE_NORMAL
- en: The `@font-face` declaration doesn’t automatically load all the referenced font
    files. The intent of `@font-face` is to allow *lazy loading* of font faces. This
    means only faces needed to render a document will be loaded. Font files referenced
    in your CSS that aren’t necessary to render the page will not be downloaded. Font
    files are generally cached, and aren’t redownloaded as your users navigate your
    site.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ability to load any font is quite powerful, but keep these concerns in
    mind:'
  prefs: []
  type: TYPE_NORMAL
- en: For security reasons, font files must be retrieved from the same domain as the
    page requesting them. There’s a solution for that.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requiring lots of font downloads can lead to slow load times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fonts with lots of characters can lead to large font files. Fortunately, online
    tools and CSS enable limiting character sets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If fonts load slowly, this can lead to flashes of unstyled text or invisible
    text. CSS has a way of addressing this issue as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll cover these problems and their solutions in this chapter. But remember,
    with great power comes great responsibility. Use fonts wisely!
  prefs: []
  type: TYPE_NORMAL
- en: Using Font-Face Descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All the parameters that define the font you’re referencing are contained within
    the `@font-face { }` construct. These are called *descriptors*, and very much
    like properties, they take the format `*descriptor*: *value*;`. In fact, most
    of the descriptor names refer directly to property names, as will be examined
    throughout the rest of the chapter. [Table 14-1](#font_descriptors) lists the
    possible descriptors, both required and optional.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-1\. Font descriptors
  prefs: []
  type: TYPE_NORMAL
- en: '| Descriptor | Default value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `font-family` | *n/a* | *Required.* The name used for this font in `font-family`
    property values. |'
  prefs: []
  type: TYPE_TB
- en: '| `src` | *n/a* | *Required.* One or more URLs pointing to the font file(s)
    that must be loaded to display the font. |'
  prefs: []
  type: TYPE_TB
- en: '| `font-display` | `auto` | Determines how a font face is displayed based on
    whether and when it is downloaded and ready to use. |'
  prefs: []
  type: TYPE_TB
- en: '| `font-stretch` | `normal` | Distinguishes between varying degrees of character
    widths (e.g., `condensed` and `expanded`). |'
  prefs: []
  type: TYPE_TB
- en: '| `font-style` | `normal` | Distinguishes between `normal`, `italic`, and `oblique`
    faces. |'
  prefs: []
  type: TYPE_TB
- en: '| `font-weight` | `normal` | Distinguishes between various weights (e.g., `bold`).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `font-variant` | `normal` | A value of the `font-variant` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `font-feature-settings` | `normal` | Permits direct access to low-level OpenType
    features (e.g., enabling ligatures). |'
  prefs: []
  type: TYPE_TB
- en: '| `font-variation-settings` | `normal` | Allows low-level control over OpenType
    or TrueType font variations, by specifying the four-letter axis names of the features
    to vary, along with their variation values. |'
  prefs: []
  type: TYPE_TB
- en: '| `ascent-override` | `normal` | Defines the ascent metric for the font. |'
  prefs: []
  type: TYPE_TB
- en: '| `descent-override` | `normal` | Defines the descent metric for the font.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `line-gap-override` | `normal` | Defines the line gap metric for the font.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `size-adjust` | `100%` | Defines a multiplier for glyph outlines and metrics
    associated with the font. |'
  prefs: []
  type: TYPE_TB
- en: '| `unicode-range` | `U+0-10FFFF` | Defines the range of characters for which
    a given face may be used. |'
  prefs: []
  type: TYPE_TB
- en: 'As noted in [Table 14-1](#font_descriptors), two descriptors are required:
    `font-family` and `src`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The point of `src` is pretty straightforward, so we’ll describe it first: `src`
    lets you define one or more comma-separated sources for the font face you’re defining.
    With each source, you can provide an optional (but recommended) format hint that
    can help improve download performance.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can point to a font face at any URL—including files on the user’s computer
    using `local()`, and files elsewhere with `url()`. There is a default restriction:
    unless you set an exception, font faces can be loaded from only the same origin
    as the stylesheet. You can’t simply point your `src` at someone else’s site and
    download their font. You’ll need to host a local copy on your own server, use
    HTTP access controls to relax the same domain restriction, or use a font-hosting
    service that provides both the stylesheet(s) and the font file(s).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To create an exception to the same-origin restriction for fonts, include the
    following in your server’s *.htaccess* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `FilesMatch` line includes all the file extensions of the fonts you want
    to import. This will allow anyone, from anywhere, to point at your font files
    and load them directly off your server.
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering how it is that we’re defining `font-family` here when it
    was already defined in a previous section. This `font-family` is the font-family
    *descriptor*, whereas the previously defined `font-family` is the font-family
    *property*. If this seems confusing, stick with us a moment and all should become
    clear.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, `@font-face` lets you create low-level definitions that underpin
    the font-related properties like `font-family`. When you define a font family
    name via the descriptor `font-family: "Switzera";`, you’re setting up an entry
    in the user agent’s table of font families that you can refer to in your `font-family`
    property values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `font-family` descriptor value and the entry in the `font-family`
    property match case-insensitively. If they didn’t match at all, the `h1` rule
    would ignore the first font-family name listed in the `font-family` value and
    move on to the next (Helvetica, in this case).
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the `font-family` descriptor can be (almost) any name you want
    to give it. It doesn’t have to exactly match the name of the font file, though
    it usually makes sense to use a descriptor that’s at least close to the font’s
    name for purposes of clarity. That said, the value used in the `font-family` property
    does have to (case-insensitively) match the `font-family` descriptor.
  prefs: []
  type: TYPE_NORMAL
- en: As long as the font has cleanly downloaded and is in a format the user agent
    can handle, it will be used in the manner you direct, as illustrated in [Figure 14-2](#using_a_downloaded_font).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1402](assets/css5_1402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-2\. Using a downloaded font
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In a similar manner, the comma-separated `src` descriptor value can provide
    fallbacks. That way, if the user agent doesn’t understand the file type defined
    by the hint or, for whatever reason, the user agent is unable to download the
    first source, it can move on to the second source and try to load the file defined
    there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Remember that the same-origin policy mentioned earlier generally applies in
    this case, so pointing to a copy of the font on some other server will usually
    fail, unless that server is set up to permit cross-origin access.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to be sure the user agent understands the kind of font you’re telling
    it to use, use the optional but highly recommended `format()` hint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of supplying a `format()` hint is that user agents can skip downloading
    files in formats they don’t support, thus reducing bandwidth use and load time.
    If no format hint is supplied, the font resource will be downloaded even if its
    format isn’t supported. The `format()` hint also lets you explicitly declare a
    format for a file that might not have a common filename extension:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 14-2](#recognized_font_format_values) lists all of the allowed format
    values (as of late 2022).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-2\. Recognized font-format values
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Format | Full name |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `collection` | OTC/TTC | OpenType Collection (formerly: TrueType Collection)
    |'
  prefs: []
  type: TYPE_TB
- en: '| `embedded-opentype` | EOT | Embedded OpenType |'
  prefs: []
  type: TYPE_TB
- en: '| `opentype` | OTF | OpenType |'
  prefs: []
  type: TYPE_TB
- en: '| `svg` | SVG | Scalable Vector Graphics |'
  prefs: []
  type: TYPE_TB
- en: '| `truetype` | TTF | TrueType |'
  prefs: []
  type: TYPE_TB
- en: '| `woff2` | WOFF2 | Web Open Font Format, version 2 |'
  prefs: []
  type: TYPE_TB
- en: '| `woff` | WOFF | Web Open Font Format |'
  prefs: []
  type: TYPE_TB
- en: 'In addition to the format, you can supply a value corresponding to a font technology
    with the `tech()` function. A color font version of Switzera might look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[Table 14-3](#recognized_font_tech_values) lists all of the recognized font-technology
    values (as of late 2022).'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-3\. Recognized font-technology values
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| color-CBDT | Font colors are defined using the OpenType `CBDT` (Color Bitmap
    Data Table) table. |'
  prefs: []
  type: TYPE_TB
- en: '| color-COLRv0 | Font colors are defined using the OpenType `COLR` (Color Table)
    table. |'
  prefs: []
  type: TYPE_TB
- en: '| color-COLRv1 | Font colors are defined using the OpenType `COLR` table. |'
  prefs: []
  type: TYPE_TB
- en: '| color-sbix | Font colors are defined using the OpenType `sbix` (Standard
    Bitmap Graphics Table) table. |'
  prefs: []
  type: TYPE_TB
- en: '| color-SVG | Font colors are defined using the OpenType `SVG` (Scalable Vector
    Graphics) table. |'
  prefs: []
  type: TYPE_TB
- en: '| feature-aat | Font uses tables from the Apple Advanced Typography (AAT) Font
    Feature Registry. |'
  prefs: []
  type: TYPE_TB
- en: '| feature-graphite | Font uses tables from the Graphite open source font-rendering
    engine. |'
  prefs: []
  type: TYPE_TB
- en: '| feature-opentype | Font uses tables from the OpenType specification. |'
  prefs: []
  type: TYPE_TB
- en: '| incremental | Incremental font-loading using the range-request or patch-subset
    server methods. |'
  prefs: []
  type: TYPE_TB
- en: '| palettes | A font that offers palettes by way of the OpenType `CPAL` table.
    |'
  prefs: []
  type: TYPE_TB
- en: '| variations | Font uses variations as defined by the OpenType tables such
    as `GSUB` and `GPOS`, the AAT tables `morx` and `kerx`, or the Graphite tables
    `Silf`, `Glat`, `Gloc`, `Feat`, and `Sill`. |'
  prefs: []
  type: TYPE_TB
- en: Delving into the details of all these feature tables is well beyond the scope
    of this book, and you are unlikely to need to use them most of the time. Even
    if a font has one or more of the listed feature tables, listing them is not required.
    Even with `tech("color-SVG")`, an SVG color font will still render using its colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the combination of `url()`, `format()`, and `tech()`, you can
    supply a font family name (or several names) in case the font is already locally
    available on the user’s machine, using the aptly named `local()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the user agent looks to see if it already has a font family
    named `Switzera-Regular` or `SwitzeraADF-Regular`, case-insensitively, available
    on the local machine. If so, it will use the name `Switzera` to refer to that
    locally installed font. If not, it will use the `url()` values to try downloading
    the first remote font listed that has a format type it supports.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that the order of the resources listed in `src` matters. As soon
    as the browser encounters a source in a format it supports, it attempts to use
    that source. For this reason, `local()` values should be listed first, with no
    format hint needed. This should be followed by external resources with file type
    hints, generally in order of smallest file size to largest to minimize performance
    hits.
  prefs: []
  type: TYPE_NORMAL
- en: 'This capability allows an author to create custom names for locally installed
    fonts. For example, you could set up a shorter name for versions of Hiragino,
    a Japanese font, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As long as the user has one of the versions of Hiragino Kaku Gothic installed
    on their machine, those rules will cause the first three heading levels to be
    rendered using that font.
  prefs: []
  type: TYPE_NORMAL
- en: Online services let you upload font-face files and generate all the `@font-face`
    rules you need, convert those files to all the formats required, and hand everything
    back to you as a single package. One of the best known is [Font Squirrel’s @Font-Face
    Kit Generator](https://www.fontsquirrel.com/tools/webfont-generator). Just make
    sure you’re legally able to convert and use the font faces you’re running through
    the generator (see the following sidebar for more information).
  prefs: []
  type: TYPE_NORMAL
- en: Restricting Character Range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At times you might want to use a custom font in very limited circumstances;
    for example, to ensure that a font face is applied only to characters that are
    in a specific language. In these cases, it can be useful to restrict the use of
    a font to certain characters or symbols, and the `unicode-range` descriptor allows
    precisely that.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the value of this descriptor covers U+0 to U+10FFFF, which is the
    entirety of Unicode—meaning that if a font can supply the glyph for a character,
    it will. Most of the time, this is exactly what you want. For all the other times,
    you’ll want to use specific font faces for specific kinds of content. You can
    define a single code point, a code-point range, or a set of ranges with the `?`
    wildcard character.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pick a few examples from the CSS Fonts Module Level 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, a single code point is specified. The font will be used only
    for the ampersand (&) character. If the ampersand is not used, the font is not
    downloaded. If it is used, the entire font file is downloaded. For this reason,
    it is sometimes good to optimize your font files to include only characters in
    the specified Unicode range, especially if, as in this case, you’re using only
    one character from a font that could contain several thousand characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second case, a single range is specified, spanning Unicode character
    code point 590 through code point 5FF. This covers the 111 total characters used
    when writing Hebrew. Thus, an author might specify a Hebrew font and restrict
    it to be used only for Hebrew characters, even if the face contains glyphs for
    other code points:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the third case, a series of ranges are specified in a comma-separated list
    to cover all the Japanese characters. The interesting feature there is the `U+30??`
    value, with a question mark, which is a special format permitted in `unicode-range`
    values. The question marks are wildcards meaning “any possible digit,” making
    `U+30??` equivalent to `U+3000-30FF`. The question mark is the only “special”
    character pattern permitted in the value.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges must always ascend. Any descending range, such as `U+400-300`, is treated
    as a parsing error and ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Because `@font-face` is designed to optimize lazy loading, it’s possible to
    use `unicode-range` to download only the font faces a page actually needs, with
    possibly a much smaller file size when using a font file optimized to contain
    only the defined subset character range. If the page doesn’t use any character
    in the range, the font is not downloaded. If a single character on a page requires
    a font, the whole font is downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a website that uses a mixture of English, Russian, and basic
    mathematical operators, but you don’t know which will appear on any given page.
    A page could be all English, a mixture of Russian and math, and so on. Furthermore,
    suppose you have special font faces for all three types of content. You can make
    sure a user agent downloads only the faces it needs with a properly constructed
    series of `@font-face` rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Because the first rule doesn’t specify a Unicode range, the entire font file
    is always downloaded—unless a page happens to contain no characters at all (and
    maybe even then). The second rule causes *myfont-cyrillic.otf* to be downloaded
    only if the page contains characters in its declared Unicode range; the third
    rule does the same for mathematical symbols.
  prefs: []
  type: TYPE_NORMAL
- en: If the content calls for the mathematical character U+2222 (∢, the spherical
    angle character), *myfont-math.otf* will be downloaded and the character from
    *myfont-math.otf* will be used, even if *myfont-general.otf* has that character.
  prefs: []
  type: TYPE_NORMAL
- en: 'A more likely way to use this capability would be our ampersand example; we
    can include a fancy ampersand from a cursive font and use it in place of the ampersand
    found in a headline font. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In a case like this, to keep page weights low, take a cursive font (that you
    have the rights to use) and minimize it down to contain just the ampersand character.
    You can use a tool like Font Squirrel to create a single-character font file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that pages can be translated with automated services like Google Translate.
    If you too aggressively restrict your Unicode ranges (say, to the range of unaccented
    letters used in English), an auto-translated version of the page into French or
    Swedish, for example, could end up a mishmash of characters in different font
    faces, as the accented characters in those languages would use a fallback font
    and the unaccented characters would be in your intended font.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Font Display
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re a designer or developer of a certain vintage, you may remember the
    days of the *flash of unstyled content* (*FOUC*). This happened in earlier browsers
    that would load the HTML and display it to the screen before the CSS was finished
    loading, or, at least, before the layout of the page via CSS was finished.
  prefs: []
  type: TYPE_NORMAL
- en: A *flash of unstyled text* (*FOUT*) happens when a browser has loaded the page
    and the CSS and then displays the laid-out page, along with all the text, before
    it’s done loading custom fonts. FOUT causes text to appear in the default font,
    or a fallback font, before being replaced by text using the custom-loaded font.
  prefs: []
  type: TYPE_NORMAL
- en: A cousin to this problem is the *flash of invisible text* (*FOIT*). This user-agent
    solution to FOUT is caused when the browser detects that text is set in a custom
    font that hasn’t loaded yet and makes the text invisible until the font loads
    or a certain amount of time has passed.
  prefs: []
  type: TYPE_NORMAL
- en: Since the replacement of text can change its size, whether via FOUT or FOIT,
    take care when selecting fallback fonts. If a significant height difference exists
    between the font used to initially display the text and the custom font eventually
    loaded and used, significant page reflows are likely to occur.
  prefs: []
  type: TYPE_NORMAL
- en: In an attempt to help with this, the `font-display` descriptor guides the browser
    to proceed with text rendering when a web font has yet to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we can call the *font-display timeline timer* starts when the user agent
    first paints the page. The timeline is divided into three periods: block, swap,
    and failure.'
  prefs: []
  type: TYPE_NORMAL
- en: During the *font-block period*, if the font face is not loaded, the browser
    renders any content that should use that font by using an invisible fallback font
    face, meaning the text content is not visible but the space is reserved. If the
    font loads successfully during the block period, the text is rendered with the
    downloaded font and made visible.
  prefs: []
  type: TYPE_NORMAL
- en: During the *swap period*, if the font face is not loaded, the browser renders
    the content by using a visible fallback font face, most likely one it has installed
    locally (e.g., Helvetica). If the font loads successfully, the fallback font face
    is swapped to the downloaded font.
  prefs: []
  type: TYPE_NORMAL
- en: Once the *failure period* is entered, the user agent treats the requested font
    as a failed load, falls back to an available font, and will not swap the font
    if it does eventually load. If the swap period is infinite, the failure period
    is never entered.
  prefs: []
  type: TYPE_NORMAL
- en: The values of the `font-display` descriptor match these periods of the timeline,
    and their effect is to emphasize one part of the timeline at the expense of the
    others. The effects are summarized in [Table 14-4](#font-display-values).
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-4\. `font-display` values
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Block period^([a](ch14.html#fn-fdv-1)) | Swap period^([a](#fn-fdv-1))
    | Failure period^([a](#fn-fdv-1)) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `auto` | Browser defined | Browser defined | Browser defined |'
  prefs: []
  type: TYPE_TB
- en: '| `block` | 3s | Infinite | *n/a* |'
  prefs: []
  type: TYPE_TB
- en: '| `swap` | < 100 ms | Infinite | *n/a* |'
  prefs: []
  type: TYPE_TB
- en: '| `fallback` | < 100 ms | 3s | Infinite |'
  prefs: []
  type: TYPE_TB
- en: '| `optional` | 0 | 0 | Infinite |'
  prefs: []
  type: TYPE_TB
- en: '| ^([a](ch14.html#fn-fdv-1-marker)) Recommended period length; actual times
    may vary |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s consider each value in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '`block`'
  prefs: []
  type: TYPE_NORMAL
- en: Tells the browser to hold open space for the font for a few seconds (3 is what
    the specification recommends, but browsers may choose their own values), and then
    enters an infinitely long swap period. If the font ever finally loads, even if
    it’s 10 minutes later, the fallback font that was used in its place will be replaced
    with the loaded font.
  prefs: []
  type: TYPE_NORMAL
- en: '`swap`'
  prefs: []
  type: TYPE_NORMAL
- en: Is similar, except it doesn’t hold the space open for longer than a fraction
    of a second (100 milliseconds is the recommendation). A fallback font is then
    used, and is replaced with the intended font whenever it finally loads.
  prefs: []
  type: TYPE_NORMAL
- en: '`fallback`'
  prefs: []
  type: TYPE_NORMAL
- en: Gives the same brief block window that `swap` does, and then enters a short
    period in which the fallback font can be replaced by the intended font. If that
    short period (3 seconds is recommended) is exceeded, the fallback font is used
    indefinitely, and the user agent may cancel the download of the intended font
    since a swap will never happen.
  prefs: []
  type: TYPE_NORMAL
- en: '`optional`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Is the most stringent of them all: if the font isn’t immediately available
    at first paint, the user agent goes straight to the fallback font and skips right
    over the block and swap periods to sit in the failure period for the rest of the
    page’s life.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining Descriptors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something that might not be immediately obvious is that you can supply multiple
    descriptors in order to assign specific faces for specific property combinations.
    For example, you can assign one face to bold text, another to italic text, and
    a third to text that is both bold and italic.
  prefs: []
  type: TYPE_NORMAL
- en: 'This capability is implicit, as any undeclared descriptor is assigned its default
    value. Let’s consider a basic set of three face assignments, using both descriptors
    we’ve covered and a few we’ll get to in a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that we’ve explicitly declared some descriptors with their
    default values, even though we didn’t need to. The previous example is exactly
    the same as a set of three rules in which we remove every descriptor that shows
    a value of `normal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In all three rules, no font-stretching occurs beyond the default `normal` amount,
    and the values of `font-weight` and `font-style` vary by which face is being assigned.
    So what if we want to assign a specific face to unstretched text that’s both bold
    and italic?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: And then what about bold, italic, condensed text?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How about normal-weight, italic, condensed text?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We could keep this up for quite a while, but let’s stop there. If we take all
    those rules and strip out anything with a `normal` value, we end up with the following
    result, illustrated in [Figure 14-3](#employing_a_variety_of_faces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1403](assets/css5_1403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-3\. Employing a variety of faces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you declare `html { +font-family: switzera;}`, you don’t have to declare
    the font family again for additional selectors that use `switzera`. The browser
    will use the correct font file for your bold, italic, stretched, and normal text
    depending on your selector-specific values for the `font-weight`, `font-style`,
    and `font-stretch` property values.'
  prefs: []
  type: TYPE_NORMAL
- en: The point is, we can have a specific font file for every weight, style, and
    stretch. The ability to declare all the variations within a few `@font-face` rules
    with a single `font-family` name ensures cohesive typeface design and avoids font
    synthesis even when using nonvariable fonts. Declaring all the variations of a
    font via `@font-face`, with the same `font-family` descriptor name, reduces `font-family`
    property overrides, reducing the chance of other developers on your team using
    the wrong font file for a specific selector.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, when using standard fonts, a lot of possible combinations exist
    just for those three descriptors—consider that `font-stretch` has 10 possible
    values—but you’ll likely never have to run through them all. In fact, most font
    families don’t have as many faces as SwitzeraADF offers (24 at last count), so
    there wouldn’t be much point in writing out all the possibilities. Nevertheless,
    the options are there, and in some cases you may find that you need to assign,
    say, a specific face for bold condensed text so that the user agent doesn’t try
    to compute them for you. Or else use a variable font that has weight and condensing
    axes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered `@font-face` and provided an overview of a few descriptors,
    let’s get back to properties.
  prefs: []
  type: TYPE_NORMAL
- en: Font Weights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most of us are used to normal and bold text, which are the two most basic font
    weights available. CSS gives you a lot more control over font weights with the
    property `font-weight`.
  prefs: []
  type: TYPE_NORMAL
- en: The <*`number`*> value can be from `1` to `1000`, inclusive, where `1` is the
    lightest and `1000` is the heaviest possible weight. Unless you are using variable
    fonts, discussed later, limited weights are almost always available for a font
    family (sometimes there is only a single weight).
  prefs: []
  type: TYPE_NORMAL
- en: Generally speaking, the heavier a font weight becomes, the darker and “more
    bold” a font appears. There are a great many ways to label a heavy font face.
    For example, the font family known as SwitzeraADF has variants such as SwitzeraADF
    Bold, SwitzeraADF Extra Bold, SwitzeraADF Light, and SwitzeraADF Regular. All
    of these use the same basic font shapes, but each has a different weight.
  prefs: []
  type: TYPE_NORMAL
- en: If the specified weight doesn’t exist, a nearby weight is used. [Table 14-5](#weight_mappings)
    lists the numbers used for each of the commonly accepted font weight labels, as
    defined in the `"wght"` variation axis. If a font has only two weights corresponding
    to `400` and `700` (normal and bold), any number value for `font-weight` will
    be mapped to the closest value. Thus, any `font-weight` value from `1` through
    `550` will be mapped to `400`, and any value greater than `550` up through `1000`
    will be mapped to `700`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-5\. Weight mappings
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Mapping |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Lowest valid value |'
  prefs: []
  type: TYPE_TB
- en: '| 100 | Thin |'
  prefs: []
  type: TYPE_TB
- en: '| 200 | Extra Light (Ultra Light) |'
  prefs: []
  type: TYPE_TB
- en: '| 300 | Light |'
  prefs: []
  type: TYPE_TB
- en: '| 400 | Normal |'
  prefs: []
  type: TYPE_TB
- en: '| 500 | Medium |'
  prefs: []
  type: TYPE_TB
- en: '| 600 | Semi Bold (Demi Bold) |'
  prefs: []
  type: TYPE_TB
- en: '| 700 | Bold |'
  prefs: []
  type: TYPE_TB
- en: '| 800 | Extra Bold (Ultra Bold) |'
  prefs: []
  type: TYPE_TB
- en: '| 900 | Black (Heavy) |'
  prefs: []
  type: TYPE_TB
- en: '| 950 | Extra Black (Ultra Black) |'
  prefs: []
  type: TYPE_TB
- en: '| 1000 | Highest valid value |'
  prefs: []
  type: TYPE_TB
- en: 'Let’s say that you want to use SwitzeraADF for a document but would like to
    make use of all those heaviness levels. If your user has all the font files locally
    on their machine and you didn’t use `@font-face` to rename all the options to
    `Switzera`, you could refer to them directly through the `font-family` property—but
    you really shouldn’t have to do that. It’s no fun having to write a stylesheet
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s pretty tedious. This is a perfect example of why specifying a single
    font family for the whole document and then assigning different weights to various
    elements by using `@font-face` is so powerful: you can include several `@font-face`
    declarations, each with the same `font-family` name, but with various values for
    the `font-weight` descriptors. Then you can use different font files with fairly
    simple `font-weight` declarations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first declaration says the `<strong>` element should be displayed using
    a bold font face or, to put it another way, a font face that is heavier than the
    normal font face. The second declaration says `<b>` should use a font face that
    is the inherited `font-weight` value plus 100.
  prefs: []
  type: TYPE_NORMAL
- en: 'What’s really happening behind the scenes is that heavier faces of the font
    are used for displaying `<strong>` and `<b>` elements. Thus, if you display a
    paragraph using Times, and part of it is bold, then two faces of the same font
    are really in use: Times and TimesBold. The regular text is displayed using Times,
    and the bold and bolder text are displayed using TimesBold.'
  prefs: []
  type: TYPE_NORMAL
- en: If the font doesn’t have a boldfaced version, it may be synthesized by the browser,
    creating a faux bold. (To prevent this, use `font-synthesis` property, which is
    described later.)
  prefs: []
  type: TYPE_NORMAL
- en: How Weights Work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To understand how a user agent determines the heaviness, or weight, of a given
    font variant (not to mention how weight is inherited), it’s easiest to start by
    talking about the values `1` through `1000` inclusive, specifically the values
    divisible by 100, `100` through `900`. These number values were defined to map
    to a relatively common feature of font design that gives a font nine levels of
    weight. If a nonvariable font family has faces for all nine weight levels available,
    the numbers are mapped directly to the predefined levels, with `100` as the lightest
    variant of the font and `900` as the heaviest.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, these numbers have no intrinsic weight. The CSS specification says
    only that each number corresponds to a weight at least as heavy as the number
    that precedes it. Thus, `100`, `200`, `300`, and `400` might all map to a single
    relatively lightweight variant; `500` and `600` could correspond to a single medium-heavy
    font variant; and `700`, `800`, and `900` could all produce the same very heavy
    font variant. As long as no number corresponds to a variant that is lighter than
    the variant assigned to the previous lower number, everything will be all right.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to nonvariable fonts, these numbers are defined to be equivalent
    to certain common variant names. The value `400` is defined to be equivalent to
    `normal`, and `700` corresponds to `bold`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user agent has to do some calculations if a font family has fewer than nine
    weights. In this case, the user agent must fill in the gaps in a predetermined
    way:'
  prefs: []
  type: TYPE_NORMAL
- en: If the value `500` is unassigned, it is given the same font weight as that assigned
    to `400`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `300` is unassigned, it is given the next variant lighter than `400`. If
    no lighter variant is available, `300` is assigned the same variant as `400`.
    In this case, it will usually be Normal or Medium. This method is also used for
    `200` and `100`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `600` is unassigned, it is given the next variant darker than that assigned
    for `500`. If no darker variant is available, `600` is assigned the same variant
    as `500`. This method is also used for `700`, `800`, and `900`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To illustrate this weighting scheme more clearly, let’s look at a couple of
    examples. In the first example, assume that the font family Karrank% is an OpenType
    font, so it has nine weights already defined. In this case, the numbers are assigned
    to each level, and the keywords `normal` and `bold` are assigned to the numbers
    `400` and `700`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In our second example, consider the font family SwitzeraADF. Hypothetically,
    its variants might be assigned numeric values for `font-weight`, as shown in [Table 14-6](#hypothetical_weight_assignments_for_a_sp).
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-6\. Hypothetical weight assignments for a specific font family
  prefs: []
  type: TYPE_NORMAL
- en: '| Font face | Assigned keyword | Assigned number(s) |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| SwitzeraADF Light |  | `100` through `300` |'
  prefs: []
  type: TYPE_TB
- en: '| SwitzeraADF Regular | `normal` | `400` |'
  prefs: []
  type: TYPE_TB
- en: '| SwitzeraADF Medium |  | `500` |'
  prefs: []
  type: TYPE_TB
- en: '| SwitzeraADF Bold | `bold` | `600` through `700` |'
  prefs: []
  type: TYPE_TB
- en: '| SwitzeraADF Extra Bold |  | `800` through `900` |'
  prefs: []
  type: TYPE_TB
- en: The first three number values are assigned to the lightest weight. The Regular
    face gets the keyword `normal` and the number weight `400`. Since there is a Medium
    font, it’s assigned to the number `500`. There is nothing to assign to `600`,
    so it’s mapped to the Bold font face, which is also the variant to which `700`
    and `bold` are assigned. Finally, `800` and `900` are assigned to the Black and
    Ultra Black variants, respectively. Note that this last assignment would happen
    only if those faces had the top two weight levels already assigned. Otherwise,
    the user agent might ignore them and assign `800` and `900` to the Bold face instead,
    or it might assign them both to one or the other of the Black variants.
  prefs: []
  type: TYPE_NORMAL
- en: The `font-weight` property is inherited, so if you set a paragraph to be `bold`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: then all of its children will inherit that boldness, as we see in [Figure 14-4](#inherited_font-weight).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1404](assets/css5_1404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-4\. Inherited font-weight
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This isn’t unusual, but the situation gets interesting when you use the last
    two values we have to discuss: `bolder` and `lighter`. In general terms, these
    keywords have the effect you’d anticipate: they make text more or less bold compared
    to its parent’s font weight. How they do so is slightly complicated. First, let’s
    consider `bolder`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you set an element to have a weight of `bolder` or `lighter`, the user agent
    first must determine what `font-weight` value was inherited from the parent element.
    Once it has that number (say, `400`), it then changes the value as shown in [Table 14-7](#bolder_and_lighter_weight_mappings).
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-7\. `bolder` and `lighter` weight mappings
  prefs: []
  type: TYPE_NORMAL
- en: '| Inherited value | `bolder` | `lighter` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| value < 100 | 400 | No change |'
  prefs: []
  type: TYPE_TB
- en: '| 100 ≤ value < 350 | 400 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 350 ≤ value < 550 | 700 | 100 |'
  prefs: []
  type: TYPE_TB
- en: '| 550 ≤ value < 750 | 900 | 400 |'
  prefs: []
  type: TYPE_TB
- en: '| 750 ≤ value < 900 | 900 | 700 |'
  prefs: []
  type: TYPE_TB
- en: '| 900 ≤ value | No change | 700 |'
  prefs: []
  type: TYPE_TB
- en: 'Thus, you might encounter the following situations, illustrated in [Figure 14-5](#text_trying_to_be_bolder):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1405](assets/css5_1405.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-5\. Text trying to be bolder
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first example, the user agent moves up from `400` to `700`. In the second
    example, `<h1>` text is already set to `bold`, which equates to `700`. If no bolder
    face is available, the user agent sets the weight of `<b>` text within an `<h1>`
    to `900`, since that is the next step up from `700`. Since `900` is assigned to
    the same font face as `700`, no visible difference exists between normal `<h1>`
    text and bold `<h1>` text, but the weight values are different nonetheless.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, `lighter` works in much the same way, except it causes
    the user agent to move down the weight scale instead of up.
  prefs: []
  type: TYPE_NORMAL
- en: The font-weight Descriptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `font-weight` descriptor, authors can assign faces of varying weights
    to the weighting levels permitted by the `font-weight` property. The allowable
    values are different for the descriptor, which supports `auto`, `normal`, `bold`,
    or one to two numeric values as a range. Neither `lighter` nor `bolder` are supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following rules explicitly assign five faces to six `font-weight`
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'With these faces assigned, the author now has multiple weighting levels available
    for their use, as illustrated in [Figure 14-6](#using_declared_font-weight_faces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1406](assets/css5_1406.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-6\. Using declared font-weight faces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In any given situation, the user agent picks which face to use depending on
    the exact value of a `font-weight` property, using the resolution algorithm detailed
    in [“How Weights Work”](#how_weights_work). While the `font-weight` property has
    numerous keyword values, the `font-weight` descriptor accepts only `normal` and
    `bold` as keywords, and any number from `1` to `1000` inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Font Size
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While size doesn’t have a `@font-face` descriptor, you need to understand the
    `font-size` property to better understand some of the descriptors to come, so
    we’ll explore it now. The methods for determining font size are both very familiar
    and very different.
  prefs: []
  type: TYPE_NORMAL
- en: What can be a real head-scratcher at first is that different fonts declared
    to be the same size may not appear to be the same size. This is because the actual
    relation of the `font-size` property to what you see rendered is determined by
    the font’s designer. This relationship is set as an *em square* (some call it
    an *em box*) within the font itself. This em square (and thus the font size) doesn’t
    have to refer to any boundaries established by the characters in a font. Instead,
    it refers to the distance between baselines when the font is set without any extra
    leading (`` `line-height` `` in CSS).
  prefs: []
  type: TYPE_NORMAL
- en: The effect of `font-size` is to provide a size for the em box of a given font.
    This does not guarantee that any of the displayed characters will be this size.
    It is quite possible for fonts to have characters that are taller than the default
    distance between baselines. For that matter, a font might be defined such that
    all of its characters are smaller than its em square, as many fonts are. [Figure 14-7](#font_characters_and_em_squares)
    shows some hypothetical examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1407](assets/css5_1407.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-7\. Font characters and em squares
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using Absolute Sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having established all that, we turn now to the absolute-size keywords. The
    `font-size` property has eight absolute-size values: `xx-small`, `x-small`, `small`,
    `medium`, `large`, `x-large`, `xx-large`, and the relatively new `xxx-large`.
    These are not defined precisely but instead are defined relative to each other,
    as [Figure 14-8](#absolute_font_sizes) demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1408](assets/css5_1408.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-8\. Absolute font sizes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the CSS1 specification, the difference (or *scaling factor*) between one
    absolute size and the next was 1.5 going up the ladder, or 0.66 going down. This
    was determined to be too large a scaling factor. In CSS2, the suggested scaling
    factor for computer screens between adjacent indexes was 1.2\. This didn’t resolve
    all the issues, though, as it created issues for the small sizes.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS Fonts Level 4 specification doesn’t have a one-size-fits-all scaling
    factor. Rather, each absolute-size keyword value has a size-specific scaling factor
    based on the value of `medium` (see [Table 14-8](#size_mappings)). The `small`
    value is listed as eight-ninths the size of `medium`, while `xx-small` is three-fifths.
    In any case, the scaling factors are guidelines, and user agents are free to alter
    them for any reason.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-8\. Font-size mappings
  prefs: []
  type: TYPE_NORMAL
- en: '| CSS absolute-size values | `xx-small` | `x-small` | `small` | `medium` |
    `large` | `x-large` | `xx-large` | `xxx-large` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Scaling factor | 3/5 | 3/4 | 8/9 | 1 | 6/5 | 3/2 | 2/1 | 3/1 |'
  prefs: []
  type: TYPE_TB
- en: '| Sizes at `medium`==`16px` | `9px` | `10px` | `13px` | `16px` | `18px` | `24px`
    | `32px` | `48px` |'
  prefs: []
  type: TYPE_TB
- en: '| HTML heading equivalent | `h6` | - | `h5` | `h4` | `h3` | `h2` | `h1` | *n/a*
    |'
  prefs: []
  type: TYPE_TB
- en: Note that we’ve set the default size, `medium`, explicitly to `16px`. The default
    `font-size` value is the same, `medium`, for all generic font families, but the
    `medium` keyword may have different definitions based on operating system or browser
    user settings. For example, in many browsers, serif and sans-serif fonts have
    `medium` equal to `16px`, but `monospace` set to `13px`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, the `xxx-large` keyword is not supported by Safari or Opera,
    either on desktop or mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Using Relative Sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just as `font-weight` has the keywords `bolder` and `lighter`, the `font-size`
    property has relative-size keywords called `larger` and `smaller`. Much as with
    relative font weights, these keywords cause the computed value of `font-size`
    to move up and down a scale of size values.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `larger` and `smaller` keywords are fairly straightforward: they cause
    the size of an element to be shifted up or down the absolute-size scale, relative
    to their parent element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the relative values for weight, the relative-size values are not necessarily
    constrained to the limits of the absolute-size range. Thus, a font’s size can
    be pushed beyond the sizes for `xx-small` and `xxx-large`. If the parent element
    `font-size` is the largest or smallest absolute value, the browser will use a
    scaling factor between 1.2 and 1.5 to create an even smaller or larger font size.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in [Figure 14-9](#relative_font_sizing_at_the_edges_of_the),
    the emphasized text in the `<h1>` element is slightly larger than `xxx-large`.
    The amount of scaling is left up to the user agent, with a scaling factor in the
    range of 1.2 to 1.5 being preferred, but not required. The `em` text in the paragraph
    is shifted up one slot to 140%.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1409](assets/css5_1409.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-9\. Relative font sizing at the edges of the absolute sizes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: User agents are not required to increase or decrease font size beyond the limits
    of the absolute-size keywords, but they may do so anyway. Also, while it is technically
    possible to declare `smaller` than `xx-small`, small text can be very difficult
    to read onscreen, leading to content being not accessible to users. Use very small
    text sparingly and with a great deal of caution.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Sizes as Percentages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a way, percentage values are very similar to the relative-size keywords.
    A percentage value is always computed in terms of whatever size is inherited from
    an element’s parent. Unlike the size keywords previously discussed, percentages
    permit much finer control over the computed font size. Consider the following
    example, illustrated in [Figure 14-10](#throwing_percentages_into_the_mix):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1410](assets/css5_1410.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-10\. Throwing percentages into the mix
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, the exact pixel-size values are shown. These are the values
    calculated by the browser, regardless of the displayed size of the characters
    onscreen, which may have been rounded to the nearest whole number of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using em measurements, the same principles apply as with percentages,
    such as the inheritance of computed sizes and so forth. CSS defines the length
    value `em` to be equivalent to percentage values, in the sense that `1em` is the
    same as `100%` when sizing fonts. Thus, the following would yield identical results,
    assuming that both paragraphs have the same parent element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As with the relative-size keywords, percentages are effectively cumulative.
    Thus, the following markup is displayed as shown in [Figure 14-11](#the_issues_of_inheritance):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1411](assets/css5_1411.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-11\. The issues of inheritance
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The size value for the `<strong>` element shown in [Figure 14-11](#the_issues_of_inheritance)
    is computed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 12 px × 120% = 14.4 px + 14.4 px × 135% = 19.44 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The problem of runaway scaling can go the other direction, too. Imagine the
    effect of the following rule on a nested list item if we have lists nested four
    levels deep:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: The unordered list nested four levels deep would have a computed `font-size`
    value 40.96% the size of the parent of the top-level list. Every nested list would
    have a font size 80% as big as its parent list, causing each level to become harder
    and harder to read.
  prefs: []
  type: TYPE_NORMAL
- en: Automatically Adjusting Size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two of the main factors that influence a font’s legibility are its size and
    its *x-height*, which is the height of a lowercase *x* character in the font.
    The number that results from dividing the x-height by the `font-size` is referred
    to as the *aspect value*. Fonts with higher aspect values tend to remain legible
    as the font’s size is reduced; conversely, fonts with low aspect values become
    illegible more quickly. CSS provides a way to deal with shifts in aspect values
    between font families, as well as ways to use different metrics to compute an
    aspect value, with the property `font-size-adjust`.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of this property is to preserve legibility when the font used is not
    the author’s first choice. Because of the differences in font appearance, one
    font may be legible at a certain size, while another font at the same size is
    difficult or impossible to read.
  prefs: []
  type: TYPE_NORMAL
- en: The property value can be `none`, `from-font`, or a number. The number specified
    should generally be the aspect value (the ratio of a given font metric to font
    size) of the first-choice font family. To pick the font metric used to compute
    the aspect ratio, you can add a keyword specifying it. If not included, it defaults
    to `ex-height`, which normalizes the aspect value of the fonts using the x-height
    divided by the font size.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other possibilities for the font metric keyword are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cap-height`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the cap-height (height of capital letters) of the font.
  prefs: []
  type: TYPE_NORMAL
- en: '`ch-width`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the horizontal pitch (also the width of `1ch`) of the font.
  prefs: []
  type: TYPE_NORMAL
- en: '`ic-width`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the width of the font using the CJK water ideograph, “水” (U+6C34) of the
    font.
  prefs: []
  type: TYPE_NORMAL
- en: '`ic-height`'
  prefs: []
  type: TYPE_NORMAL
- en: Use the height of the ideograph “水” (U+6C34) of the font.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring `font-size-adjust: none` will suppress any adjustment of font sizes.
    This is the default state.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `from-font` keyword directs the user agent to use the built-in value of
    the specified font metric from the first available font, rather than requiring
    the author to figure out what that value is and write it explicitly. Thus, writing
    `font-size-adjust: cap-height from-font` will automatically set an aspect value
    by dividing the cap-height by the em-square height.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example is to compare the common fonts Verdana and Times. Consider [Figure 14-12](#comparing_verdana_and_times)
    and the following markup, which shows both fonts at a `font-size` of `10px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1412](assets/css5_1412.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-12\. Comparing Verdana and Times
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The text in Times is much harder to read than the Verdana text. This is partly
    due to the limitations of pixel-based display, but it is also because Times becomes
    harder to read at smaller font sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, the ratio of x-height to character size in Verdana is 0.58,
    whereas in Times it is 0.46\. To make these font faces look more consistent with
    each other, you can declare the aspect value of Verdana, and have the user agent
    adjust the size of the text that’s actually used. This is accomplished using the
    following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: Declared `font-size` ×
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (`font-size-adjust` value ÷ aspect
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: value of available font) = Adjusted `font-size`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'So, when Times is used instead of Verdana, the adjustment is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10px` × (`0.58` ÷ `0.46`) = `12.6px`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This leads to the result shown in [Figure 14-13](#adjusting_times):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1413](assets/css5_1413.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-13\. Adjusting Times
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The catch is that for a user agent to intelligently make size adjustments, it
    first has to know the aspect value of the fonts you specify. User agents that
    support `@font-face` will be able to pull that information directly from the font
    file, assuming the files contain the information—any professionally produced font
    should, but there’s no guarantee. If a font file doesn’t contain the aspect value,
    a user agent may try to compute it; but again, there’s no guarantee that they
    will or even can.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the user agent can’t find or figure out aspect values on its own, the `auto`
    value for `font-size-adjust` is a way of getting the desired effect even if you
    don’t know the actual aspect value of your first-choice font. For example, assuming
    that the user agent can determine that the aspect value of Verdana is 0.58, the
    following will have the same result as that shown in [Figure 14-13](#adjusting_times):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, the only user-agent line to support `font-size-adjust` is the
    Gecko (Firefox) family.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding font size adjustment comes in handy when considering `size-adjust`.
    This font descriptor behaves similarly to the `font-size-adjust` property, though
    it’s restricted to comparing only x-heights instead of the range of font metrics
    available for `font-size-adjust`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `font-size-adjust` property is a rare case where the property and descriptor
    names are not the same: the descriptor is `size-adjust`. The value is any positive
    percentage value (from 0 to infinity) by which you want the fallback font scaled
    so it better matches the primary font selected. That percentage is used as a multiplier
    for the glyph outline sizes and other metrics of the font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, the only user-agent line that does *not* support the `size-adjust`
    descriptor is the WebKit (Safari) family.
  prefs: []
  type: TYPE_NORMAL
- en: Font Style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `font-style` property sounds very simple: you can choose from three values,
    and optionally provide an angle for oblique text if you’re using it.'
  prefs: []
  type: TYPE_NORMAL
- en: The default value of `font-style` is `normal`. This value refers to *upright*
    text, which is best described as text that is not italic or otherwise slanted.
    For instance, the vast majority of text in this book is upright.
  prefs: []
  type: TYPE_NORMAL
- en: Italic font faces are usually a bit cursive in appearance, and generally use
    less horizontal space than the `normal` version of the same font. In standard
    fonts, italic text is a separate font face, with small changes made to the structure
    of each letter to account for the altered appearance. This is especially true
    of serif fonts because, in addition to the text characters “leaning,” the serifs
    may be altered. Font faces with labels like `Italic`, `Cursive`, and `Kursiv`
    are usually mapped to the `italic` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '*Oblique text*, on the other hand, is a slanted version of the normal, upright
    text. Oblique text is generally not altered from the upright text other than being
    given a slope. If a font has oblique versions, they are often in faces with labels
    such as `Oblique`, `Slanted`, and `Incline`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When fonts don’t have italic or oblique versions, the browser can simulate
    italic and oblique fonts by artificially sloping the glyphs of the regular face.
    (To prevent this from happening, use `font-synthesis: none`, covered later in
    the chapter.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Italic and oblique text at the same angle are not the same: italic is stylized
    and usually obsessively designed, and oblique is merely slanted. By default, if
    `oblique` is declared without an angle, a value of `14deg` is used.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When oblique is given an angle, such as `font-style: oblique 25deg`, the browser
    selects the face classified as oblique, if available. If one or more oblique faces
    are available in the chosen font family, the one most closely matching the specified
    angle by the `font-style` descriptor is chosen. If no oblique faces are available,
    the browser may synthesize an oblique version of the font by slanting a normal
    face by the specified angle.'
  prefs: []
  type: TYPE_NORMAL
- en: Unless further limited by the font or the descriptor, the oblique angle specified
    must be between `90deg` and `-90deg`, inclusive. If the given value is outside
    those limits, the declaration is ignored. Positive values are slanted toward the
    end (inline-end) of the line, while negative values are slanted toward the beginning
    (inline-start) of the line.
  prefs: []
  type: TYPE_NORMAL
- en: To visualize the difference between italic and oblique text, refer to [Figure 14-14](#italic_and_oblique_text_in_detail).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1414](assets/css5_1414.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-14\. Italic and oblique text in detail
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For TrueType or OpenType variable fonts, the `"slnt"` variation axis is used
    to implement varying slant angles for oblique, and the `"ital"` variation axis
    with a value of `1` is used to implement italic values. See [“Font Variation Settings”](#font-variation-settings)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to make sure that a document uses italic text in familiar ways,
    you could write a stylesheet like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'These styles would make paragraphs use an upright font, as usual, and cause
    the `<em>` and `<i>` elements to use an italic font, also as usual. On the other
    hand, you might decide that there should be a subtle difference between `<em>`
    and `<i>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If you look closely at [Figure 14-15](#more_font_styles), you’ll see no apparent
    difference between the `<em>` and `<i>` elements. In practice, not every font
    is so sophisticated as to have both an italic face and an oblique face, and even
    fewer web browsers are sophisticated enough to tell the difference when both faces
    do exist.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1415](assets/css5_1415.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-15\. More font styles
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The equivalent `font-variation-settings` setting for `italic` is `"ital"`.
    For the `oblique <*angle*>` value, the equivalent is `"slnt"`, which is used to
    vary between upright and slanted text. Just as with `font-style`, the slant axis
    is interpreted as the angle of slant in counterclockwise degrees from upright:
    inline-start-leaning oblique design will have a negative slant value, whereas
    inline-end-leaning needs a positive value.'
  prefs: []
  type: TYPE_NORMAL
- en: The font-style Descriptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a descriptor, `font-style` lets an author link specific faces to specific
    font-style values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we might want to assign very particular faces of Switzera to the
    various kinds of `font-style` property values. Given the following, the result
    would be to render `<h2>` and `<h3>` elements using SwitzeraADF-Italic instead
    of SwitzeraADF-Regular, as illustrated in [Figure 14-16](#using_declared_font-style_faces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1416](assets/css5_1416.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-16\. Using declared font-style faces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Ideally, if a SwitzeraADF face with an oblique typeface existed, a page author
    could point to it instead of the italic variant. There isn’t such a face, though,
    so the author mapped the italic face to both the `italic` and `oblique` values.
    As with `font-weight`, the `font-style` descriptor can take all of the values
    of the `font-style` property *except* for `inherit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Oblique text changes the angle of letterforms without performing any kind of
    character substitution. Any variable font that supports oblique text also supports
    normal or upright text: upright text is oblique text at a `0deg` angle. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The angle given in the CSS value `oblique 3deg` is a clockwise slant of 3 degrees.
    Positive angles are clockwise slants, whereas negative angles are counterclockwise
    slants. If no angle is included, it is the same as writing `oblique 14deg`. The
    degree angle can be any value between `-90deg` and `90deg`, inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: Font Stretching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In some font families, variant faces have wider or narrower letterforms. These
    often take names like Condensed, Wide, and Ultra Expanded. The utility of such
    variants is that a designer can use a single font family while also having skinny
    and fat variants. CSS provides a property that allows an author to select among
    such variants, when they exist, without having to explicitly define them in `font-family`
    declarations. It does this via the somewhat misleadingly named `font-stretch`.
  prefs: []
  type: TYPE_NORMAL
- en: You might expect from the property name that `font-stretch` will stretch or
    squeeze a font like saltwater taffy, but that’s not the case. This property instead
    behaves very much like the absolute-size keywords (e.g., `` `xx-large` ``) for
    the `font-size` property. You can set a percentage between 50% and 200% inclusive,
    or use a range of keyword values that have defined percentage equivalents. [Table 14-9](#font_stretch_keyword_mapping)
    shows the mapping between keyword values and numeric percentages.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-9\. Percentage equivalents for `font-stretch` keyword values
  prefs: []
  type: TYPE_NORMAL
- en: '| Keyword | Percentage |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ultra-condensed` | 50% |'
  prefs: []
  type: TYPE_TB
- en: '| `extra-condensed` | 62.5% |'
  prefs: []
  type: TYPE_TB
- en: '| `condensed` | 75% |'
  prefs: []
  type: TYPE_TB
- en: '| `semi-condensed` | 87.5% |'
  prefs: []
  type: TYPE_TB
- en: '| `normal` | 100% |'
  prefs: []
  type: TYPE_TB
- en: '| `semi-expanded` | 112.5% |'
  prefs: []
  type: TYPE_TB
- en: '| `expanded` | 125% |'
  prefs: []
  type: TYPE_TB
- en: '| `extra-expanded` | 150% |'
  prefs: []
  type: TYPE_TB
- en: '| `ultra-expanded` | 200% |'
  prefs: []
  type: TYPE_TB
- en: For example, you might decide to stress the text in a strongly emphasized element
    by changing the font characters to a wider face than its parent element’s font
    characters.
  prefs: []
  type: TYPE_NORMAL
- en: The catch is that this property works only if the font family in use actually
    *has* wider and narrower faces, which mostly come with only expensive traditional
    fonts. (They’re much more widely available in variable fonts.)
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the common font Verdana, which has only one width face;
    this is equivalent to `font-stretch: normal`. Declaring the following will have
    no effect on the width of the displayed text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'All of the text will be at Verdana’s usual width. However, if the font family
    is changed to one that has multiple width faces, such as Futura, things will be
    different, as shown in [Figure 14-17](#stretching_font_characters):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1417](assets/css5_1417.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-17\. Stretching font characters
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For variable fonts that support the `"wdth"` axis, set the width in `font-variation-settings`
    to a value greater than 0\. This controls the glyph width or stroke thickness,
    depending on the font design.
  prefs: []
  type: TYPE_NORMAL
- en: The font-stretch Descriptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much as with the `font-weight` descriptor, the `font-stretch` descriptor allows
    you to explicitly assign faces of varying widths to the width values permitted
    in the `font-stretch` property. For example, the following rules explicitly assign
    three faces to the most directly analogous `font-stretch` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'In a parallel to what you saw in previous sections, you can call on these different
    width faces through the `font-stretch` property, as illustrated in [Figure 14-18](#using_declared_font-stretch_faces):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1418](assets/css5_1418.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-18\. Using declared font-stretch faces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you use a variable font that contains the full spectrum of font-stretch
    sizing, you can import a single font file with `@font-face`, then use it for all
    of your text font-stretch requirements. This produces the same degree of horizontal
    stretching shown in [Figure 14-18](#using_declared_font-stretch_faces), albeit
    with a different font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `font-stretch` descriptor can take all of the values of the `font-stretch`
    property *except* for `inherit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do want to use a different font for your variable fonts depending on
    whether the text is extended or condensed, use the `"wdth"` value in the comma-separated
    value of the `@font-face` `font-variation-settings` descriptor, as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Font Synthesis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes a given font family will lack alternate faces for options like bold
    or italic text or small capital letters. In such situations, the user agent may
    attempt to synthesize a face from the faces it has available, but this can lead
    to unattractive letterforms. To address this, CSS offers `font-synthesis`, which
    lets you say how much synthesis you will or won’t permit in the rendering of a
    page. This doesn’t have a `@font-face` descriptor, but it has bearing on all the
    font variants to follow, so we’re dealing with it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'In many user agents, a font family that has no bold face can have one computed
    for it. This might be done by adding pixels to either side of each character glyph,
    for example. While this might seem useful, it can lead to results that are visually
    unappealing, especially at smaller font sizes. This is why most font families
    have bold faces included: the font’s designer wanted to make sure that bolded
    text in that font looked good.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, a font family that lacks an italic face can have one synthesized
    by simply slanting the characters in the normal face. This tends to look even
    worse than synthesized bold faces, particularly when it comes to serif fonts.
    Compare the difference between the actual italic face included in Georgia and
    a synthesized italic version of Georgia (which we’re calling “oblique” here),
    illustrated in [Figure 14-19](#synthesized_versus_designed_italics).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1419](assets/css5_1419.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-19\. Synthesized versus designed italics
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In supporting user agents, declaring `font-synthesis: none` blocks the user
    agent from doing any such synthesis for the affected elements. You can block it
    for the whole document with `html {font-synthesis: none;}`, for example. The downside
    is that any attempts to create variant text using a font that doesn’t offer the
    appropriate faces will stay the normal face, instead of even approximating what
    was intended. The upside is that you don’t have to worry about a user agent trying
    to synthesize those variants and doing a poor job of it.'
  prefs: []
  type: TYPE_NORMAL
- en: Font Variants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Beyond font weights and font styles, there are font variants. These are embedded
    within a font face and can cover aspects like various styles of historical ligatures,
    small-caps presentation, ways of presenting fractions, the spacing of numbers,
    whether zeros get slashes through them, and much more. CSS lets you invoke these
    variants, when they exist, through the shorthand property `font-variant`.
  prefs: []
  type: TYPE_NORMAL
- en: This property is shorthand for five separate properties, which we’ll get to
    in just a moment. The most common values you’ll find in the wild are `normal`,
    which is the default and describes ordinary text, and `small-caps`, which has
    existed since CSS1.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, however, let’s cover the two values that don’t correspond to other properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`none`'
  prefs: []
  type: TYPE_NORMAL
- en: Disables all variants of any kind by setting `font-feature-ligatures` to `none`
    and all the other font variant properties to `normal`
  prefs: []
  type: TYPE_NORMAL
- en: '`normal`'
  prefs: []
  type: TYPE_NORMAL
- en: Disables most variants by setting all the font variant properties, including
    `font-feature-ligatures`, to `normal`
  prefs: []
  type: TYPE_NORMAL
- en: 'Understanding the variant aspect of `small-caps` might help explain the idea
    of variants, making all the other properties easier to understand. The `small-caps`
    value calls for the use of small caps (`font-feature-settings: "smcp"`). Instead
    of upper- and lowercase letters, a small-caps font employs capital letters of
    different sizes. Thus, you might see something like what’s shown in [Figure 14-20](#the_small-caps_value_in_use):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1420](assets/css5_1420.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-20\. The `small-caps` value in use
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you may notice, in the display of the `<h1>` element, there is a larger
    capital letter wherever an uppercase letter appears in the source, and a small
    capital letter wherever there is a lowercase letter in the source. This is very
    similar to `text-transform: uppercase`, with the only real difference being that,
    here, the capital letters are of different sizes. However, the reason that `small-caps`
    is declared using a font property is that some fonts have a specific small-caps
    face, which a font property is used to select.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What happens if no font-face variant, such as `small-caps`, exists? The specification
    provides two options. The first is for the user agent to create a small-caps face
    by scaling capital letters on its own. The second is to make all letters uppercase
    and the same size, exactly as if the declaration `text-transform: uppercase` had
    been used instead. This is not an ideal solution but it is permitted.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Bear in mind that not every font supports every variant. For example, most Latin
    fonts won’t support any of the East Asian variants. In addition, not every font
    will include support for, say, some of the numeric and ligature variants. Many
    fonts will support *none* of the variants.
  prefs: []
  type: TYPE_NORMAL
- en: To find out what a given font supports, you have to consult its documentation,
    or do a lot of testing if no documentation is available. Most commercial fonts
    do come with documentation, and most free fonts don’t. Fortunately, some browser
    developer tools (not including Chromium browsers, as of late 2022) have a tab
    that provides information about font variants and feature settings.
  prefs: []
  type: TYPE_NORMAL
- en: Capital Font Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the `small-caps` value we just discussed, CSS has other capital-text
    variants. These are addressed via the property `font-variant-caps`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value is `normal`, which means no capital-letter variant is used.
    From there, we have the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`small-caps`'
  prefs: []
  type: TYPE_NORMAL
- en: Renders all of the letters using capital letters. The capital letters for characters
    that are uppercase in the source text are the same height as uppercase letters.
    Characters that are lowercase in the text are rendered as smaller capitals, usually
    a bit taller than the font’s x-height.
  prefs: []
  type: TYPE_NORMAL
- en: '`all-small-caps`'
  prefs: []
  type: TYPE_NORMAL
- en: The same as `small-caps`, except all letters are rendered as smaller capitals,
    even those that are uppercase in the source text.
  prefs: []
  type: TYPE_NORMAL
- en: '`petite-caps`'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to `small-caps`, except the capitals used for lowercase letters are
    equal in height to, or even a bit shorter than, the font’s x-height. If the font
    has no petite-caps variant, the result is likely to be the same as for `small-caps`.
  prefs: []
  type: TYPE_NORMAL
- en: '`all-petite-caps`'
  prefs: []
  type: TYPE_NORMAL
- en: The same as `petite-caps`, except all letters are rendered as smaller capitals,
    even those that are uppercase in the source text.
  prefs: []
  type: TYPE_NORMAL
- en: '`titling-caps`'
  prefs: []
  type: TYPE_NORMAL
- en: If a row has multiple uppercase letters, alternate capital forms are used to
    keep the letters from appearing too visually strong. Usually these are thinner
    versions of the normal capitals in the font.
  prefs: []
  type: TYPE_NORMAL
- en: '`unicase`'
  prefs: []
  type: TYPE_NORMAL
- en: The text is rendered using a mixture of capital and noncapital letterforms,
    usually all the same height. This can vary widely even among the few fonts that
    offer this variant.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is illustrated in [Figure 14-21](#different_types_of_capital_variants);
    note that the values marked with a dagger (†) were faked in one way or another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1421](assets/css5_1421.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-21\. Different types of capital variants
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Why did we fake some of the examples in [Figure 14-21](#different_types_of_capital_variants)?
    In part, because finding a single font that contains all the capital variants
    is exceedingly difficult, and it is literally faster to fake some results than
    dig up a font, or set of fonts, that might work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also want to highlight that exact situation: most of the time, you’re going
    to get either a fallback (as from `petite-caps` to `small-caps`) or no variant
    at all. Because of this, make sure to use the `@font-face` `font-variant` descriptor
    to define what should happen. Otherwise, if a `font-variant-caps` category variant
    is not available, the browser will decide how to render it. For example, if `petite-caps`
    is specified and the font doesn’t have a petite-caps face or variable axis defined,
    the user agent may render the text using small capital glyphs. If small capital
    glyphs are not included in the font, the browser may synthesize them by proportionally
    shrinking uppercase glyphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, you can use `{font-synthesis: none;}` to prevent the browser
    from synthesizing the text. You can also include `{font-synthesis: small-caps;}`,
    or omit `font-synthesis` altogether, to allow a small-caps typeface to be synthesized
    if needed.'
  prefs: []
  type: TYPE_NORMAL
- en: Fonts sometimes include special glyphs for various caseless characters like
    punctuation marks to match the cap-variant text. The browser will not synthesize
    caseless characters on its own.
  prefs: []
  type: TYPE_NORMAL
- en: All the values of `font-variant-caps` other than `normal` have defined equivalent
    OpenType features. These are summarized in [Table 14-10](#font_variant_caps_opentype).
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-10\. `font-variant-caps` values and equivalent OpenType features
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | OpenType feature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `normal` | *n/a* |'
  prefs: []
  type: TYPE_TB
- en: '| `small-caps` | `"smcp"` |'
  prefs: []
  type: TYPE_TB
- en: '| `all-small-caps` | `"c2sc"`, `"smcp"` |'
  prefs: []
  type: TYPE_TB
- en: '| `petite-caps` | `"pcap"` |'
  prefs: []
  type: TYPE_TB
- en: '| `all-petite-caps` | `"c2pc"`, `"pcap"` |'
  prefs: []
  type: TYPE_TB
- en: '| `titling-caps` | `"titl"` |'
  prefs: []
  type: TYPE_TB
- en: '| `unicase` | `"unic"` |'
  prefs: []
  type: TYPE_TB
- en: Numeric Font Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many font faces have variant behaviors for use when rendering numerals. When
    available, these can be accessed via the `font-variant-numeric` property. The
    values of this property affect the usage of alternate glyphs for numbers, fractions,
    and ordinal markers.
  prefs: []
  type: TYPE_NORMAL
- en: The default value, `normal`, means that nothing special will be done when rendering
    numbers. They’ll just appear the same as they usually do for the font face. [Figure 14-22](#different_types_of_numeric_variants)
    demonstrates all the values, and as before, the examples marked with a dagger
    (†) were faked in one way or another because fonts lacked those features.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1422](assets/css5_1422.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-22\. Different types of numeric variants
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Perhaps the simplest numeric variant is `slashed-zero`. This causes the numeral
    0 to appear with a slash through it, most likely on a diagonal. Slashed zeros
    are often the default rendering in monospace fonts, where distinguishing 0 from
    the capital letter *O* can be difficult. In serif and sans-serif fonts, they are
    usually not the default appearance of zeros. Setting `font-variant-numeric: slashed-zero`
    will bring out a slashed zero if one is available.'
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of diagonal slashes, the value `diagonal-fractions` causes characters
    arranged as a fraction (e.g., 1/2) to be rendered as smaller numbers, the first
    raised up, separated by a diagonal slash. The `stacked-fractions` value renders
    the fraction as the first number above the second, and the two separated by a
    horizontal slash.
  prefs: []
  type: TYPE_NORMAL
- en: If the font has features for ordinal labels, like the letters following the
    numbers of 1st, 2nd, 3rd, and 4th in English, `ordinal` enables the use of those
    special glyphs. These will generally look like superscripted, smaller versions
    of the letters.
  prefs: []
  type: TYPE_NORMAL
- en: Authors can affect the figures used for numbers with `lining-nums`, which sets
    all numbers on the baseline; and `oldstyle-nums`, which enables numbers like 3,
    4, 7, and 9 to descend below the baseline. Georgia is a common example of a font
    that has old-style numbers.
  prefs: []
  type: TYPE_NORMAL
- en: You can also influence the sizing of figures used for numbers. The `proportional-nums`
    value enables the numbers to be proportional, as in proportional fonts; and `tabular-nums`
    gives all numbers the same width, as in monospace fonts. The advantage of these
    values is that you can, assuming there are glyphs to support them in the font
    face, get the monospace effect in proportional fonts without converting the numbers
    to a monospace face, and similarly cause monospace numbers to be sized proportionally.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can include multiple values, but only one value from each of the numeric-value
    sets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: All the values of `font-variant-numeric` other than `normal` have defined equivalent
    OpenType features. These are summarized in [Table 14-11](#font_variant_numeric_opentype).
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-11\. `font-variant-numeric` values and equivalent OpenType features
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | OpenType feature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `normal` | *n/a* |'
  prefs: []
  type: TYPE_TB
- en: '| `ordinal` | `"ordn"` |'
  prefs: []
  type: TYPE_TB
- en: '| `slashed-zero` | `"zero"` |'
  prefs: []
  type: TYPE_TB
- en: '| `lining-nums` | `"lnum"` |'
  prefs: []
  type: TYPE_TB
- en: '| `oldstyle-nums` | `"onum"` |'
  prefs: []
  type: TYPE_TB
- en: '| `proportional-nums` | `"pnum"` |'
  prefs: []
  type: TYPE_TB
- en: '| `tabular-nums` | `"tnum"` |'
  prefs: []
  type: TYPE_TB
- en: '| `diagonal-fractions` | `"frac"` |'
  prefs: []
  type: TYPE_TB
- en: '| `stacked-fractions` | `"afrc"` |'
  prefs: []
  type: TYPE_TB
- en: Ligature Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *ligature* is a joining of two (or more) characters into one shape. As an
    example, two lowercase *f* characters could have their crossbars merged into a
    single line when they appear next to each other, or the crossbar could extend
    over a lowercase *i* and replace its usual dot in the sequence *fi*. More archaically,
    a combination like *st* could have a swash curve from one to the other. When available,
    these features can be enabled or disabled with the `font-variant-ligatures` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values have the following effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`common-ligatures`'
  prefs: []
  type: TYPE_NORMAL
- en: Enables the use of common ligatures, such as those combining *f* or *t* with
    letters that follow them. In French, the sequence *oe* is more usually rendered
    using the ligature *œ*. Browsers usually have these enabled by default, so if
    you want to disable them, use `no-common-ligatures` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`discretionary-ligatures`'
  prefs: []
  type: TYPE_NORMAL
- en: Enables the use of special ligatures created by font designers that are unusual
    or otherwise not regarded as common.
  prefs: []
  type: TYPE_NORMAL
- en: '`historical-ligatures`'
  prefs: []
  type: TYPE_NORMAL
- en: Enables the use of historical ligatures, which are generally those found in
    the typography of centuries past but are not used today. For example, in German
    the *tz* digraph used to be rendered as ![](assets/tz_italic.png).
  prefs: []
  type: TYPE_NORMAL
- en: '`contextual-ligatures`'
  prefs: []
  type: TYPE_NORMAL
- en: Enables the use of ligatures that appear based on context, such as a cursive
    font enabling connecting curves from one letter to the next depending on not just
    the character that follows, but possibly also what characters came before. These
    are also sometimes used in programming fonts, where sequences like `!=` may be
    rendered as `≠` instead.
  prefs: []
  type: TYPE_NORMAL
- en: '`no-common-ligatures`'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly disables the use of common ligatures.
  prefs: []
  type: TYPE_NORMAL
- en: '`no-discretionary-ligatures`'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly disables the use of discretionary ligatures.
  prefs: []
  type: TYPE_NORMAL
- en: '`no-historical-ligatures`'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly disables the use of historical ligatures.
  prefs: []
  type: TYPE_NORMAL
- en: '`no-contextual-ligatures`'
  prefs: []
  type: TYPE_NORMAL
- en: Explicitly disables the use of contextual ligatures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value, `normal`, turns off all these ligatures *except* common
    ligatures, which are enabled by default. This is especially relevant because `font-variant:
    normal` turns off all the `font-variant-ligatures` except the common ones, whereas
    `font-variant: none` turns them all off *including* common ligatures. [Table 14-12](#font_variant_caps)
    provides a condensed summary of how each value translates into OpenType features.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-12\. `font-variant-ligatures` values and equivalent OpenType features
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | OpenType feature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `common-ligatures` | `"clig" on`, `"liga" on` |'
  prefs: []
  type: TYPE_TB
- en: '| `discretionary-ligatures` | `"dlig" on` |'
  prefs: []
  type: TYPE_TB
- en: '| `historical-ligatures` | `"hlig" on` |'
  prefs: []
  type: TYPE_TB
- en: '| `contextual-ligatures` | `"calt" on` |'
  prefs: []
  type: TYPE_TB
- en: '| `no-common-ligatures` | `"clig" off`, `"liga" off` |'
  prefs: []
  type: TYPE_TB
- en: '| `no-discretionary-ligatures` | `"dlig" off` |'
  prefs: []
  type: TYPE_TB
- en: '| `no-historical-ligatures` | `"hlig" off` |'
  prefs: []
  type: TYPE_TB
- en: '| `no-contextual-ligatures` | `"calt" off` |'
  prefs: []
  type: TYPE_TB
- en: Less likely to be used or supported by browsers are the `font-variant-alternates`
    and `font-variant-east-asian` properties.
  prefs: []
  type: TYPE_NORMAL
- en: Alternate Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For any given character, a font may include alternate glyphs in addition to
    the default glyph for that character. The `font-variant-alternates` property affects
    the usage of those alternate glyphs.
  prefs: []
  type: TYPE_NORMAL
- en: The default value, `normal`, means don’t use any alternate variants. The `historical-forms`
    keyword enables historical forms, glyphs that were common in the past but not
    today. All the other values are functions.
  prefs: []
  type: TYPE_NORMAL
- en: These alternate glyphs may be referenced by alternative names defined in `@font-feature-values`.
    With `@font-feature-values`, you can define a common name for the `font-variant-alternates`
    function values to activate OpenType features.
  prefs: []
  type: TYPE_NORMAL
- en: The `@font-feature-values` at-rule may be used either at the top level of your
    CSS or inside any CSS conditional-group at-rule.
  prefs: []
  type: TYPE_NORMAL
- en: In [Table 14-13](#font_variant_alternates), *`XY`* is replaced by a number representing
    the feature set. With OpenType fonts and `font-feature-settings`, some features
    are already defined. For example, the OpenType equivalent of the `styleset()`
    function is `"ss*XY*"`. As of late 2022, `ss01` through `ss20` are currently defined.
    Values higher than 99 are allowed, but they don’t map to any OpenType values and
    will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-13\. `font-variant-alternates` values and equivalent OpenType features
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | OpenType feature |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `annotation()` | `"nalt"` |'
  prefs: []
  type: TYPE_TB
- en: '| `character-variant()` | `"cv*XY*"` |'
  prefs: []
  type: TYPE_TB
- en: '| `historical-forms` | `"hist"` |'
  prefs: []
  type: TYPE_TB
- en: '| `ornaments()` | `"ornm"` |'
  prefs: []
  type: TYPE_TB
- en: '| `styleset()` | `"ss*XY*"` |'
  prefs: []
  type: TYPE_TB
- en: '| `stylistic()` | `"salt"` |'
  prefs: []
  type: TYPE_TB
- en: '| `swash()` | `"swsh"`, `"cswh"` |'
  prefs: []
  type: TYPE_TB
- en: 'An at-rule version of `font-variant-alternates`, called `@font-feature-values`,
    allows authors to define labels for alternate values of `font-variant-alternates`
    using at-rules of their own. The following two styles (taken from the CSS specification)
    demonstrate how to label the numeric values of the `swash` alternate, and then
    use them later in `font-variant-alternates`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Without the presence of the `@font-feature-values` at-rule, the paragraph styles
    would have to say `font-variant-alternates: swash(2)` instead of using `flowing`
    for the value of the `swash` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, while all browsers support `font-variant` and its associated
    subproperties, only Firefox and Safari have `font-variant-alternates` and `@font-feature-values`
    support. You can more reliably set these variants by using the `font-feature-settings`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: East Asian Font Variants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The values of the `font-variant-east-asian` property allow for controlling glyph
    substitution and sizing in East Asian text.
  prefs: []
  type: TYPE_NORMAL
- en: The assorted Japanese Industrial Standard (JIS) variants reflect the glyph forms
    defined in different Japanese national standards. Fonts generally include glyphs
    defined by the most recent national standard. JIS values allow for the inclusion
    of older Japanese glyph variations when such variants are needed, such as when
    reproducing historical documents.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, the `simplified` and `traditional` values allow control over the
    glyph forms for characters that have been simplified over time but for which the
    older, traditional form is still used in some contexts.
  prefs: []
  type: TYPE_NORMAL
- en: The `ruby` value enables display of Ruby variant glyphs. Ruby text is generally
    smaller than the associated body text.
  prefs: []
  type: TYPE_NORMAL
- en: This property value allows font designers to include glyphs better suited for
    smaller typography than scaled-down versions of the default glyphs would be. Only
    glyph selection is affected; there is no associated font scaling.
  prefs: []
  type: TYPE_NORMAL
- en: Font Variant Position
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Compared to the previous variants, `font-variant-position` is fairly straightforward.
    It’s strange, then, that it’s so poorly supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'This property can be used to enable specialized variant glyphs that are meant
    solely for superscripted and subscripted text. As it says in the [CSS specification](https://www.w3.org/TR/css-fonts-4/#font-variant-position-prop),
    these glyphs are:'
  prefs: []
  type: TYPE_NORMAL
- en: …designed within the same em-box as default glyphs and are intended to be laid
    out on the same baseline as the default glyphs, with no resizing or repositioning
    of the baseline. They are explicitly designed to match the surrounding text and
    to be more readable without affecting the line height.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This is in contrast to what happens with super- and subscripted text in fonts
    that lack such alternates, which is usually just smaller text that’s been shifted
    up or down from the baseline. This sort of synthesis of super- and subscripted
    text often leads to line-height increases, which variant glyphs are generally
    designed to prevent.
  prefs: []
  type: TYPE_NORMAL
- en: Font Feature Settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we’ve discussed font features but have yet to cover
    the `font-feature-settings` property or descriptor. Similarly to `font-variant`,
    `font-feature-settings` allows you to exercise low-level control over which OpenType
    font features are available for use.
  prefs: []
  type: TYPE_NORMAL
- en: The `font-feature-settings` property controls advanced typographic features
    in OpenType fonts, as opposed to the `font-variation-settings` property, which
    provides low-level control over variable font characteristics.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list one or more comma-separated OpenType features, as defined by the
    OpenType specification. For example, enabling common ligatures, small caps, and
    slashed zeros would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'The exact format of a <*`feature-tag-value`*> value is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <*`feature-tag-value`*>
  prefs: []
  type: TYPE_NORMAL
- en: <*`string`*> [ <*`integer`*> | `on` | `off` ]?
  prefs: []
  type: TYPE_NORMAL
- en: 'For many features, the only permitted integer values are `0` and `1`, which
    are equivalent to `off` and `on` (and vice versa). Some features allow a range
    of numbers, however, in which case values greater than 1 both enable the feature
    and define the feature’s selection index. If a feature is listed but no number
    is provided, `1` (on) is assumed. Thus, the following descriptors are all equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that all <*`string`*> values *must* be quoted. Thus, the first of
    the following descriptors will be recognized, but the second will be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: A further restriction is that OpenType requires that all feature tags be four
    ASCII characters long. Any feature name longer or shorter, or that uses non-ASCII
    characters, is invalid and will be ignored. (This isn’t something you need to
    worry about unless you’re using a font that has its own made-up feature names
    and the font’s creator didn’t follow the naming rules.)
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, OpenType fonts *always* have the following features enabled unless
    the author explicitly disables them via `font-feature-settings` or `font-variant`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"calt"`'
  prefs: []
  type: TYPE_NORMAL
- en: Contextual alternates
  prefs: []
  type: TYPE_NORMAL
- en: '`"ccmp"`'
  prefs: []
  type: TYPE_NORMAL
- en: Composed characters
  prefs: []
  type: TYPE_NORMAL
- en: '`"clig"`'
  prefs: []
  type: TYPE_NORMAL
- en: Contextual ligatures
  prefs: []
  type: TYPE_NORMAL
- en: '`"liga"`'
  prefs: []
  type: TYPE_NORMAL
- en: Standard ligatures
  prefs: []
  type: TYPE_NORMAL
- en: '`"locl"`'
  prefs: []
  type: TYPE_NORMAL
- en: Localized forms
  prefs: []
  type: TYPE_NORMAL
- en: '`"mark"`'
  prefs: []
  type: TYPE_NORMAL
- en: Mark-to-base positioning
  prefs: []
  type: TYPE_NORMAL
- en: '`"mkmk"`'
  prefs: []
  type: TYPE_NORMAL
- en: Mark-to-mark positioning
  prefs: []
  type: TYPE_NORMAL
- en: '`"rlig"`'
  prefs: []
  type: TYPE_NORMAL
- en: Required ligatures
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, other features may be enabled by default in specific situations,
    such as vertical alternatives (`"vert"`) for vertical runs of text.
  prefs: []
  type: TYPE_NORMAL
- en: The OpenType `font-feature-setting` values we’ve discussed so far are all listed
    in [Table 14-14](#opentype_values), along with a few others we didn’t touch on
    for lack of support.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-14\. OpenType values
  prefs: []
  type: TYPE_NORMAL
- en: '| Code | Meaning | Longhand |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"afrc"` | Alternative fractions | `stacked-fractions` |'
  prefs: []
  type: TYPE_TB
- en: '| `"c2pc"` | Petite capitals | `petite-caps` |'
  prefs: []
  type: TYPE_TB
- en: '| `"c2sc"` | Small capitals from capitals | `all-small-caps` |'
  prefs: []
  type: TYPE_TB
- en: '| `"calt"` | Contextual alternates | `contextual` |'
  prefs: []
  type: TYPE_TB
- en: '| `"case"` | Case-sensitive forms |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"clig"` | Common ligatures | `common-ligatures` |'
  prefs: []
  type: TYPE_TB
- en: '| `"cswh"` | Swash function | `swash()` |'
  prefs: []
  type: TYPE_TB
- en: '| `"cv01"` | Character variants (01–99) | `character-variant()` |'
  prefs: []
  type: TYPE_TB
- en: '| `"dnom"` | Denominators |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"frac"` | Fractions | `diagonal-fractions` |'
  prefs: []
  type: TYPE_TB
- en: '| `"fwid"` | Full-width variants | `full-width` |'
  prefs: []
  type: TYPE_TB
- en: '| `"hist"` | Enable historical forms | `historical-forms` |'
  prefs: []
  type: TYPE_TB
- en: '| `"liga"` | Standard ligatures | `common-ligatures` |'
  prefs: []
  type: TYPE_TB
- en: '| `"lnum"` | Lining figures | `lining-nums` |'
  prefs: []
  type: TYPE_TB
- en: '| `"locl"` | Localized forms |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"numr"` | Numerators |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"nalt"` | Annotation function | `annotation()` |'
  prefs: []
  type: TYPE_TB
- en: '| `"onum"` | Old-style figures | `oldstyle-nums` |'
  prefs: []
  type: TYPE_TB
- en: '| `"ordn"` | Ordinal markers | `ordinal` |'
  prefs: []
  type: TYPE_TB
- en: '| `"ornm"` | Ornaments (function) | `ornaments()` |'
  prefs: []
  type: TYPE_TB
- en: '| `"pcap"` | Petite capitals | `petite-caps` |'
  prefs: []
  type: TYPE_TB
- en: '| `"pnum"` | Proportional figures |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"pwid"` | Proportionally spaced variants | `proportional-width` |'
  prefs: []
  type: TYPE_TB
- en: '| `"ruby"` | Ruby | `ruby` |'
  prefs: []
  type: TYPE_TB
- en: '| `"salt"` | Stylistic function | `stylistic()` |'
  prefs: []
  type: TYPE_TB
- en: '| `"sinf"` | Scientific inferiors |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"smcp"` | Small capitals | `small-caps` |'
  prefs: []
  type: TYPE_TB
- en: '| `"smpl"` | Simplified forms | `simplified` |'
  prefs: []
  type: TYPE_TB
- en: '| `"ss01"` | Stylistic set 1 (numero correct) | `styleset()` |'
  prefs: []
  type: TYPE_TB
- en: '| `"ss07"` | Stylistic set (1–20) | `styleset()` |'
  prefs: []
  type: TYPE_TB
- en: '| `"subs"` | Subscript |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"sups"` | Superscript |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"swsh"` | Swash function | `swash()` |'
  prefs: []
  type: TYPE_TB
- en: '| `"titl"` | Titling capitals | `titling-caps` |'
  prefs: []
  type: TYPE_TB
- en: '| `"tnum"` | Tabular figures | `tabular-nums` |'
  prefs: []
  type: TYPE_TB
- en: '| `"trad"` | Traditional forms | `traditional` |'
  prefs: []
  type: TYPE_TB
- en: '| `"unic"` | Unicase | `unicase` |'
  prefs: []
  type: TYPE_TB
- en: '| `"zero"` | Slashed zero | `slashed-zero` |'
  prefs: []
  type: TYPE_TB
- en: The complete list of standard OpenType feature names can be found at [Microsoft’s
    Registered Features page](https://microsoft.com/typography/otspec/featurelist.htm).
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, `font-feature-settings` is a low-level feature designed to handle
    special cases for which no other way exists to enable or access an OpenType font
    feature. You also have to list all of the feature settings you want to use in
    a single property value. Whenever possible, use the `font-variant` shorthand property
    or one of the six associated longhand properties: `font-variant-ligatures`, `font-variant-caps`,
    `font-variant-east-asian`, `font-variant-alternates`, `font-variant-position`,
    and `font-variant-numeric`.'
  prefs: []
  type: TYPE_NORMAL
- en: The font-feature-settings Descriptor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `font-feature-settings` descriptor lets you decide which of an OpenType
    font face’s settings can or cannot be used, specified as a space-separated list.
    Now, wait a second—isn’t that almost exactly what we did with `font-variant` just
    a few paragraphs ago? Yes! The `font-variant` descriptor covers nearly everything
    `font-feature-settings` does, plus a little more besides. It just does so in a
    more CSS-like way, with value names instead of cryptic OpenType identifiers and
    Boolean toggles. Because of this, the CSS specification explicitly encourages
    authors to use `font-variant` instead of `font-feature-settings`, except when
    there’s a font feature that the value list of `font-variant` doesn’t include.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that this descriptor merely makes features available for use (or
    suppresses their use). It does not turn them on for the display of text; for that,
    see [“Font Feature Settings”](#font_feature_settings).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as with the `font-variant` descriptor, the `font-feature-settings` descriptor
    defines which font features are enabled (or disabled) for the font face being
    declared in the `@font-face` rule. For example, given the following, Switzera
    will have alternative fractions and small-caps disabled, even if such features
    exist in SwitzeraADF:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The `font-feature-settings` descriptor can take all of the values of the `font-feature-settings`
    property *except* for `inherit`.
  prefs: []
  type: TYPE_NORMAL
- en: Font Variation Settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `font-variation-settings` property provides low-level control over variable
    font characteristics, by specifying a four-letter axis name along with a value.
  prefs: []
  type: TYPE_NORMAL
- en: There are five registered axes, listed in [Table 14-15](#font_variation_axes).
    We have covered almost all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Table 14-15\. Font variation axes
  prefs: []
  type: TYPE_NORMAL
- en: '| Axis | Property | Property value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `"wght"` | `font-weight` | `1` – `1000` |'
  prefs: []
  type: TYPE_TB
- en: '| `"slnt"` | `font-style` | `oblique` / `oblique` *<angle>* |'
  prefs: []
  type: TYPE_TB
- en: '| `"ital"` | `font-style` | `italic` |'
  prefs: []
  type: TYPE_TB
- en: '| `"opsz"` | `font-optical-sizing` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `"wdth"` | `font-stretch` |  |'
  prefs: []
  type: TYPE_TB
- en: 'We use the term *registered axes* because font developers are not limited to
    weight, width, optical size, slant, and italics: they can create custom axes,
    and “register” them by giving them a four-letter label. The simplest way to know
    if a font has such axes is to look at the font’s documentation; otherwise, you
    have to know how to dig into the internals of a font’s file(s) to find out. These
    axes can control any aspect of the font’s appearance, such as the size of the
    dot on lowercase *i* and *j*. Creating custom axes is beyond the scope of this
    book, but calling on them where they exist is not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because these axes are string values, they have to be quoted, are case-sensitive,
    and are always lowercase. Imagine a font for which the size of the dots (which
    are properly called *diacritic marks* or just *diacritics*) over lowercase *i*
    and *j* can be changed by way of an axis called `DCSZ` (for *diacritic size*).
    Furthermore, this axis has been defined by the font’s designer to allow values
    from 1 to 10\. The diacritic size could be maximized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The `font-variation-settings` descriptor is the same as the property. Instead
    of declaring each registered axis separately, they are declared on one line, comma
    separated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although you can set the weight, style, and so forth of a given font by using
    `font-variation-settings`, it is recommended that you use the more widely supported
    and human-readable properties `font-weight` and `font-style` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Font Optical Sizing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Text rendered at different sizes often benefits from slightly different visual
    representations. For example, to aid reading at small text sizes, glyphs have
    less detail and strokes are often thicker with larger serifs. Larger text can
    have more features and a greater contrast between thicker and thinner strokes.
    The property `font-optical-sizing` allows authors to enable or disable this feature
    of variable fonts.
  prefs: []
  type: TYPE_NORMAL
- en: By default (via `auto`), browsers can modify the shape of glyphs based on font
    size and pixel density. The `none` value tells the browser to *not* do this.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In fonts that support it, optical sizing is usually defined as a range of numbers.
    If you want to explicitly change the optical sizing of a given element’s font
    to be a specific number, perhaps to make text sturdier or more delicate than it
    would be by default, use the `font-variation-settings` property and give it a
    value like `'opsz' 10` (where `10` can be any number in the optical-sizing range).
  prefs: []
  type: TYPE_NORMAL
- en: Override Descriptors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This brings us to the last three `@font-face` descriptors that we have yet
    to discuss. Three descriptors enable override settings for font families: `ascent-override`,
    `descent-override`, and `line-gap-override`, which define the ascent, descent,
    and line gap metrics, respectively. All three descriptors take the same values:
    `normal` or a <*`percentage`*>.'
  prefs: []
  type: TYPE_NORMAL
- en: The goal of these descriptors is to help fallback fonts better match a primary
    font by overriding the metrics of the fallback font and using those of the primary
    font instead.
  prefs: []
  type: TYPE_NORMAL
- en: The *ascent metric* is the distance above the baseline used to lay out line
    boxes (the distance from the baseline to the top of the em box). The *descent
    metric* is the distance below the baseline used to lay out line boxes (the distance
    from the baseline to the bottom of the em box). The *line-gap metric* is the font’s
    recommended distance between adjacent lines of text, which is sometimes called
    *external leading*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a hypothetical font and its ascent, descent, and line-gap
    override descriptors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: This will direct the browser to alter the ascent and descent heights by 110%
    and 95%, respectively, and increase the line gap to 105% the distance in the fallback
    font.
  prefs: []
  type: TYPE_NORMAL
- en: Font Kerning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A font property that doesn’t have a descriptor equivalent is `font-kerning`.
    Some fonts contain data indicating how characters should be spaced relative to
    one another, known as *kerning*. Kerning can make character spacing more visually
    appealing and pleasant to read.
  prefs: []
  type: TYPE_NORMAL
- en: Kerning space varies depending on the way characters are combined; for example,
    the character pair *oc* may have a different spacing than the pair *ox*. Similarly,
    *AB* and *AW* may have different separation distances, to the point that in some
    fonts, the top-right tip of the *W* is actually placed to the left of the bottom-right
    tip of the *A*. This kerning data can be explicitly called for or suppressed using
    the property `font-kerning`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The value `none` is pretty simple: it tells the user agent to ignore any kerning
    information in the font. The `normal` value tells the user agent to kern the text
    normally—that is, according to the kerning data contained in the font. The `auto`
    value tells the user agent to do whatever it thinks best, possibly depending on
    the type of font in use. The OpenType specification, for example, recommends (but
    does not require) that kerning be applied whenever the font supports it. Furthermore,
    as per the [CSS specification](https://www.w3.org/TR/css-fonts-4/#font-kerning-prop):'
  prefs: []
  type: TYPE_NORMAL
- en: '[Browsers] may synthetically support the kern feature with fonts that contain
    kerning data in the form of a `kern` table but lack kern feature support in the
    `GPOS` table.'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This means, in effect, that if kerning information is built into the font, browsers
    are allowed to enforce it even if the font lacks an explicit enabling of kerning
    via a feature table.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the `letter-spacing` property (see [Chapter 15](ch15.html#text_properties))
    is applied to kerned text, the kerning is done first and *then* the letters’ spacing
    is adjusted according to the value of `letter-spacing`, not the other way around.
  prefs: []
  type: TYPE_NORMAL
- en: The font Property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All of the properties discussed thus far are very sophisticated, but writing
    them all out could get a little tedious:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Some of this problem could be solved by grouping selectors, but wouldn’t it
    be easier to combine everything into a single property? Enter `font`, which is
    a shorthand property encompassing most (not quite all) of the other font properties,
    and a little more besides.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generally speaking, a `font` declaration can have any one value from each of
    the listed font properties, or else a system font value (described in [“Using
    System Fonts”](#using_system_fonts)). Therefore, the preceding example could be
    shortened as follows (and have exactly the same effect, as illustrated by [Figure 14-23](#typical_font_rules)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1423](assets/css5_1423.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-23\. Typical font rules
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We say that the styles “could be” shortened in this way because a few other
    possibilities exist, thanks to the relatively loose way in which `font` can be
    written. If you look closely at the preceding example, you’ll see that the first
    three values don’t occur in the same order. In the `h1` rule, the first three
    values are for `font-style`, `font-weight`, and `font-variant`, in that order.
    In the second, they’re ordered `font-weight`, `font-variant`, and `font-style`.
    There is nothing wrong here because these three can be written in any order. Furthermore,
    if any has a value of `normal`, that can be left out altogether. Therefore, the
    following rules are equivalent to the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the value of `normal` is left out of the `h2` rule, but the
    effect is exactly the same as in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to realize, however, that this free-for-all situation applies
    only to the first three values of `font`. The last two are much stricter in their
    behavior. Not only must `font-size` and `font-family` appear in that order as
    the last two values in the declaration, but both must always be present in a `font`
    declaration. Period, end of story. If either is left out, the entire rule will
    be invalidated and will be ignored completely by a user agent. Thus, the following
    rules will get you the result shown in [Figure 14-24](#the_necessity_of_both_size_and_family):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1424](assets/css5_1424.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-24\. The necessity of both size and family
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding font Property Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because the `font` property has been part of CSS since the very beginning, and
    because so many properties dealing with all the variants came later, the `font`
    property has some limitations when it comes to font variations.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, it’s important to remember that when using the `font` shorthand property,
    the following properties are all set to their default values even though they
    cannot be represented in `font`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`font-feature-settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-kerning`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-language-override`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-optical-sizing`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-palette`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-size-adjust`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-variant-alternates`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-variant-caps` (unless `small-caps` is included in the `font` value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-variant-east-asian`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-variant-ligatures`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-variant-numeric`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font-variation-settings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Second, and following on the note in the previous list, only two variation
    values are permitted: `small-caps` and `normal`. The numeric, ligature, alternate,
    East Asian, and many of the caps variants cannot be set via the `font` property.
    If you want, for example, to use small caps and slashed zeros in your top-level
    headings, you would need to write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: Third, another property value that suffers from the weight of history is font
    stretching. As we discussed earlier in the chapter, `font-stretch` allows you
    to choose from numerous keywords or to set a percentage in the range of 50% to
    200% (inclusive). The keywords may be used in `font`, but the percentage value
    may not.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Line Height
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also can set the value of the `line-height` property by using `font`, even
    though `line-height` is a text property (not covered in this chapter), not a font
    property. It’s done as a sort of addition to the `font-size` value, separated
    from it by a forward slash (`/`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: These rules, demonstrated in [Figure 14-25](#adding_line_height_to_the_mix),
    set all `<h2>` elements to be bold and italic (using face for one of the sans-serif
    font families), set the `font-size` to `24px` (twice the `body`’s size), and set
    the `line-height` to `28.8px`.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1425](assets/css5_1425.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-25\. Adding line height to the mix
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This addition of a value for `line-height` is entirely optional, just as the
    first three `font` values are. If you do include a `line-height` value, remember
    that `font-size` always comes before `line-height`, never after, and the two are
    always separated by a slash.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This may seem repetitive, but it’s one of the most common errors made by CSS
    authors, so we can’t say it enough: the required values for `font` are `font-size`
    and `font-family`, in that order. Everything else is strictly optional.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Shorthand Properly
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is important to remember that `font`, being a shorthand property, can act
    in unexpected ways if you are careless with its use. Consider the following rules,
    which are illustrated in [Figure 14-26](#shorthand_changes):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1426](assets/css5_1426.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14-26\. Shorthand changes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Did you notice that the `<h2>` element is neither italicized nor small-capped,
    and that none of the elements are bold? This is the correct behavior. When the
    shorthand property `font` is used, any omitted values are reset to their defaults.
    Thus, the previous example could be written as follows and still be exactly equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This sets the `<h2>` element’s font style and variant to `normal`, and the `font-weight`
    of all three elements to `normal`. This is the expected behavior of shorthand
    properties. The `<h3>` does not suffer the same fate as the `<h2>` because you
    use the property `font-size`, which is not a shorthand property and therefore
    affects only its own value.
  prefs: []
  type: TYPE_NORMAL
- en: Using System Fonts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to make a web page blend in with the user’s operating system,
    the system font values of `font` come in handy. These are used to take the font
    size, family, weight, style, and variant of elements of the operating system,
    and apply them to an element. The values are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`caption`'
  prefs: []
  type: TYPE_NORMAL
- en: Used for captioned controls, such as buttons
  prefs: []
  type: TYPE_NORMAL
- en: '`icon`'
  prefs: []
  type: TYPE_NORMAL
- en: Used to label icons
  prefs: []
  type: TYPE_NORMAL
- en: '`menu`'
  prefs: []
  type: TYPE_NORMAL
- en: Used in menus—that is, drop-down menus and menu lists
  prefs: []
  type: TYPE_NORMAL
- en: '`message-box`'
  prefs: []
  type: TYPE_NORMAL
- en: Used in dialog boxes
  prefs: []
  type: TYPE_NORMAL
- en: '`small-caption`'
  prefs: []
  type: TYPE_NORMAL
- en: Used for labeling small controls
  prefs: []
  type: TYPE_NORMAL
- en: '`status-bar`'
  prefs: []
  type: TYPE_NORMAL
- en: Used in window status bars
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you might want to set the font of a button to be the same as that
    of the buttons found in the operating system. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: With these values, you can create web-based applications that look very much
    like applications native to the user’s operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that system fonts may be set only as a whole; that is, the font family,
    size, weight, style, etc., are all set together. Therefore, the button text from
    our previous example will look exactly the same as button text in the operating
    system, whether or not the size matches any of the content around the button.
    You can, however, alter the individual values after the system font has been set.
    Thus, the following rule will make sure the button’s font is the same size as
    its parent element’s font:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: If you call for a system font and no such font exists on the user’s machine,
    the user agent may try to find an approximation, such as reducing the size of
    the `caption` font to arrive at the `small-caption` font. If no such approximation
    is possible, the user agent should use a default font of its own. If it can find
    a system font but can’t read all of its values, it should use the default value.
    For example, a user agent may be able to find a `status-bar` font but not get
    any information about whether the font is small caps. In that case, the user agent
    will use the value `normal` for the `small-caps` property.
  prefs: []
  type: TYPE_NORMAL
- en: Font Matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you’ve seen, CSS allows for the matching of font families, weights, and
    variants. This is all accomplished through font matching, which is a vaguely complicated
    procedure. Understanding it is important for authors who want to help user agents
    make good font selections when displaying their documents. We left it for the
    end of the chapter because it’s not really necessary to understand how the font
    properties work, and some readers will probably want to skip this part. If you’re
    still interested, here’s how font matching works:'
  prefs: []
  type: TYPE_NORMAL
- en: The user agent creates, or otherwise accesses, a database of font properties.
    This database lists the various CSS properties of all the fonts to which the user
    agent has access. Typically, this will be all fonts installed on the machine,
    although there could be others (for example, the user agent could have its own
    built-in fonts). If the user agent encounters two identical fonts, it will ignore
    one of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The user agent takes apart an element to which font properties have been applied
    and constructs a list of font properties necessary for the display of that element.
    Based on that list, the user agent makes an initial choice of a font family to
    use in displaying the element. If there is a complete match, the user agent can
    use that font. Otherwise, the user agent needs to do a little more work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A font is first matched against the `font-stretch` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A font is next matched against the `font-style` property. The keyword `italic`
    is matched by any font that is labeled as either `italic` or `oblique`. If neither
    is available, the match fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next match is to `font-weight`, which can never fail thanks to the way `font-weight`
    is handled in CSS (explained in [“How Weights Work”](#how_weights_work)).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, `font-size` is tackled. This must be matched within a certain tolerance,
    but that tolerance is defined by the user agent. Thus, one user agent might allow
    matching within a 20% margin of error, whereas another might allow only 10% differences
    between the size specified and the size that is actually used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If no font matched in step 2, the user agent looks for alternate fonts within
    the same font family. If it finds any, it repeats step 2 for that font.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming a generic match has been found but doesn’t contain everything needed
    to display a given element—the font is missing the copyright symbol, for instance—the
    user agent goes back to step 3, which entails a search for another alternate font
    and another trip through step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, if no match has been made and all alternate fonts have been tried,
    the user agent selects the default font for the given generic font family and
    does the best it can to display the element correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Furthermore, the user agent does the following to resolve the handling of font
    variants and features:'
  prefs: []
  type: TYPE_NORMAL
- en: Check for font features enabled by default, including features required for
    a given script. The core set of default-enabled features is `"calt"`, `"ccmp"`,
    `"clig"`, `"liga"`, `"locl"`, `"mark"`, `"mkmk"`, and `"rlig"`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the font is defined via an `@font-face` rule, check for the features implied
    by the `font-variant` descriptor in the `@font-face` rule. Then check for the
    font features implied by the `font-feature-settings` descriptor in the `@font-face`
    rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check feature settings determined by properties other than `font-variant` or
    `font-feature-settings`. (For example, setting a nondefault value for the `letter-spacing`
    property will disable ligatures.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for features implied by the value of the `font-variant` property, the
    related `font-variant` subproperties (e.g., `` `font-variant-ligatures` ``), and
    any other property that may call for the use of OpenType features (e.g., `` `font-kerning`
    ``).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check for the features implied by the value of the `font-feature-settings` property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The whole process is long and tedious, but it helps to understand how user
    agents pick the fonts they do. For example, you might specify the use of Times
    or any other serif font in a document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: For each element, the user agent should examine the characters in that element
    and determine whether Times can provide characters to match. In most cases, it
    can do so with no problem.
  prefs: []
  type: TYPE_NORMAL
- en: Assume, however, that a Chinese character has been placed in the middle of a
    paragraph. Times has nothing that can match this character, so the user agent
    has to work around the character or look for another font that can fulfill the
    needs of displaying that element. Any Western font is highly unlikely to contain
    Chinese characters, but should one exist (let’s call it AsiaTimes), the user agent
    could use it in the display of that one element—or simply for the single character.
    Thus, the whole paragraph might be displayed using AsiaTimes, or everything in
    the paragraph might be in Times except for the single Chinese character, which
    is displayed in AsiaTimes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From what was initially a very simple set of font properties, CSS has grown
    to allow fine-grained and wide-ranging influence over the way fonts are displayed
    on the web. From custom fonts downloaded over the web to custom-built families
    assembled out of a variety of individual faces, authors may be fairly said to
    overflow with font power.
  prefs: []
  type: TYPE_NORMAL
- en: 'The typographic options available to authors today are far stronger than ever,
    but always remember: you must use this power wisely. While you can have 17 fonts
    in use on your site, that definitely doesn’t mean that you should. Quite aside
    from the aesthetic difficulties this could present for your users, it would also
    make the total page weight much, much higher than it needs to be. As with any
    other aspect of web design, you are advised to use your power wisely, not wildly.'
  prefs: []
  type: TYPE_NORMAL
