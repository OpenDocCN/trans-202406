<html><head></head><body><section data-pdf-bookmark="Chapter 7. Concurrent React" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch07">&#13;
<h1><span class="label">Chapter 7. </span>Concurrent React</h1>&#13;
&#13;
&#13;
<p>In the previous chapter, we delved deep into the world of server-side&#13;
rendering with React. We examined the importance of server-side&#13;
rendering for improving the performance and user experience of our&#13;
applications, especially in the context of modern web development. We&#13;
explored different server rendering APIs, such as <code>renderToString</code> and&#13;
<code>renderToPipeableStream</code>, and discussed their use cases and benefits. We&#13;
also touched upon the challenges of implementing server-side rendering&#13;
and how it’s better to rely on established frameworks like Next.js and&#13;
Remix to handle the complexities for us.</p>&#13;
&#13;
<p>We covered the concept of hydration and its significance in connecting&#13;
server-rendered markup with client-side React components, creating a&#13;
seamless user experience. Additionally, we discussed the potential&#13;
security issues and challenges that come with managing multiple client&#13;
connections in a serverful environment, emphasizing the need for using&#13;
frameworks that handle these concerns effectively.</p>&#13;
&#13;
<p>Now, as we transition to the next <a data-primary="concurrent rendering and updating" data-type="indexterm" id="ix_concurrentrenderingandupdating.07.21.35"/>concurrent React—we will build upon&#13;
our understanding of all that we’ve learned so far. We will dive into&#13;
the Fiber reconciler and learn about the concurrent features of React,&#13;
as well as how efficiently it manages updates and rendering. By&#13;
examining scheduling, deferring updates, and render lanes, we’ll gain&#13;
insights into the performance optimizations made possible by React’s&#13;
core architecture.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Once again, it’s worth noting that Fiber itself and the things we’re&#13;
about to discuss are implementation details in React that are likely to&#13;
change and that you don’t need to know to use React effectively.&#13;
However, learning the underlying mechanisms will help you better&#13;
understand how React works and how to use it effectively, while also&#13;
making you more knowledgeable as an engineer in general.</p>&#13;
</div>&#13;
&#13;
<p>With that, let’s embark on our journey into the fascinating world of&#13;
concurrent React, as we continue to build on our expertise and discover&#13;
new ways to harness the power of React for creating high-performance&#13;
applications.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Problem with Synchronous Rendering" data-type="sect1"><div class="sect1" id="id102">&#13;
<h1>The Problem with Synchronous Rendering</h1>&#13;
&#13;
<p>To recap, the problem with synchronous rendering<a data-primary="synchronous rendering" data-secondary="problem with" data-type="indexterm" id="id879"/><a data-primary="concurrent rendering and updating" data-secondary="synchronous rendering problem" data-type="indexterm" id="id880"/> is that it blocks the&#13;
main thread, which can lead to a poor user experience. This is&#13;
especially true for complex applications with many components and&#13;
frequent updates. In such cases, the UI can become unresponsive,&#13;
resulting in a frustrating user experience.</p>&#13;
&#13;
<p>A typical mitigation step to this problem is to batch<a data-primary="batched updates" data-secondary="limitations of" data-type="indexterm" id="id881"/><a data-primary="updates" data-secondary="batching" data-type="indexterm" id="id882"/> a series of&#13;
updates into one update and minimize work done on the main thread:&#13;
instead of processing 10 things 10 times, batch them and process them&#13;
once. We covered batching in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>, so we won’t go into more detail&#13;
here, but for the purposes of our discussion, it’s important to&#13;
understand that batching is a mitigation step to these problems, but even&#13;
that has limitations, as we’ll uncover in the next few paragraphs.</p>&#13;
&#13;
<p>The problems we’ve been talking about, even with batching, are further&#13;
compounded by the fact that by design, synchronous rendering has no&#13;
sense of priority. It treats all updates equally, regardless of their&#13;
visibility. For example, with sync rendering you may block the main&#13;
thread with rendering work for items that the user can’t see, such as&#13;
tabs that aren’t visible, content behind a modal, or content in a&#13;
loading state. You still want those items to render if there is CPU&#13;
available, but you want to prioritize rendering the thing the user can&#13;
see and interact with. Before React had concurrent features, we often had situations where critical updates were blocked by less important ones, resulting in&#13;
a poor user experience.</p>&#13;
&#13;
<p>With concurrent rendering, React can prioritize updates based on their&#13;
importance and urgency, ensuring that critical updates are not blocked&#13;
by less important ones. This allows React to maintain a responsive UI&#13;
even under heavy load, resulting in a better user experience. For&#13;
example, when a user hovers over or clicks on a button, the expectation is&#13;
that it immediately shows feedback for that action. If React is working&#13;
on rerendering a long list of items, then the hover or active state&#13;
feedback will be delayed until the entire list is rendered. With&#13;
concurrent rendering, rendering tasks that are CPU bound and&#13;
CPU intensive can be given a back seat to rendering tasks that are more&#13;
important, such as user interactions and animations.</p>&#13;
&#13;
<p>Moreover, with the concurrent rendering capabilities, React is able to&#13;
time slice<a data-primary="time slicing" data-type="indexterm" id="id883"/>: that is, it can break up the rendering process into smaller&#13;
chunks and process them incrementally. This allows React to perform work&#13;
over multiple frames, and if the work needs to be interrupted, it can&#13;
be.</p>&#13;
&#13;
<p>We’ll dive into all of this together starting now.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Revisiting Fiber" data-type="sect1"><div class="sect1" id="id181">&#13;
<h1>Revisiting Fiber</h1>&#13;
&#13;
<p>As covered in <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>, the Fiber reconciler<a data-primary="Fiber reconciler" data-secondary="revisiting with concurrent React" data-type="indexterm" id="id884"/><a data-primary="concurrent rendering and updating" data-secondary="Fiber reconciler" data-type="indexterm" id="id885"/><a data-primary="reconciliation" data-secondary="Fiber reconciler" data-type="indexterm" id="id886"/> is the core mechanism in&#13;
React that enables concurrent rendering. It was introduced in React 16&#13;
and represented a significant architectural shift from the previous&#13;
stack reconciler. The primary goal of the Fiber reconciler is to improve&#13;
the responsiveness and performance of React applications, particularly&#13;
for large and complex UIs.</p>&#13;
&#13;
<p>The Fiber reconciler achieves this by breaking the rendering process&#13;
into smaller, more manageable units of work called Fibers. This allows&#13;
React to pause, resume, and prioritize rendering tasks, making it&#13;
possible to defer or schedule updates based on their importance. This&#13;
improves the responsiveness of the application and ensures that critical&#13;
updates are not blocked by less important tasks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scheduling and Deferring Updates" data-type="sect1"><div class="sect1" id="id103">&#13;
<h1>Scheduling and Deferring Updates</h1>&#13;
&#13;
<p>React’s ability to schedule and defer updates<a data-primary="updates" data-secondary="scheduling" data-type="indexterm" id="ix_updatesscheduling.07.109.46"/><a data-primary="scheduling and deferring updates" data-type="indexterm" id="ix_schedulinganddeferringupdates.07.109.46"/><a data-primary="concurrent rendering and updating" data-secondary="scheduling and deferring updates" data-type="indexterm" id="ix_concurrentrenderingandupdatingschedulinganddeferringupdates.07.109.46"/><a data-primary="prioritizing updates" data-secondary="scheduling and deferring" data-type="indexterm" id="ix_prioritizingupdatesschedulinganddeferring.07.109.46"/> is crucial for maintaining&#13;
a responsive application. The Fiber reconciler enables this&#13;
functionality by relying on a scheduler and a number of efficient APIs.&#13;
These APIs allow React to perform work during idle periods and schedule&#13;
updates at the most opportune times.</p>&#13;
&#13;
<p>We’ll dive into the scheduler in more detail in upcoming sections, but&#13;
for now, consider it to be exactly what it sounds like: a system that&#13;
receives updates and says, “you do this now,” “you do this later,”&#13;
etc., using browser APIs like <code>setTimeout</code>, <code>MessageChannel</code>, and others.</p>&#13;
&#13;
<p>Consider a real-time chat application where users can send and receive&#13;
messages. We will have a chat component that displays a list of messages,&#13;
and a message input component where users can type and submit their&#13;
messages. Additionally, the chat application receives new messages from&#13;
the server in real time. In this scenario, we want to prioritize user&#13;
interactions (typing and submitting messages) to maintain a responsive&#13;
experience, while ensuring that incoming messages are rendered&#13;
efficiently without blocking the UI.</p>&#13;
&#13;
<p>To make this example a little more concrete, let’s create some&#13;
components. First, a list of messages:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MessageList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">messages</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">{</code><code class="nx">messages</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">message</code><code class="p">,</code><code class="w"> </code><code class="nx">index</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">index</code><code class="p">}&gt;{</code><code class="nx">message</code><code class="p">}&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">Next, we have a message input component that allows users to type and&#13;
submit &#13;
<span class="keep-together">messages:</span></p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">MessageInput</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">({</code><code class="w"> </code><code class="nx">onSubmit</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">message</code><code class="p">,</code><code class="w"> </code><code class="nx">setMessage</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">handleSubmit</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">e</code><code class="p">.</code><code class="nx">preventDefault</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">onSubmit</code><code class="p">(</code><code class="nx">message</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">setMessage</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">form</code> <code class="na">onSubmit</code><code class="o">=</code><code class="p">{</code><code class="nx">handleSubmit</code><code class="p">}&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">input</code>&#13;
        <code class="na">type</code><code class="o">=</code><code class="s">"text"</code>&#13;
        <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">message</code><code class="p">}</code>&#13;
        <code class="na">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setMessage</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
      <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">type</code><code class="o">=</code><code class="s">"submit"</code><code class="p">&gt;</code><code class="nx">Send</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">form</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Finally, we have a chat component that combines the two components and&#13;
handles the logic for sending and receiving messages:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">ChatApp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">messages</code><code class="p">,</code><code class="w"> </code><code class="nx">setMessages</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">([]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="nx">useEffect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Connect to the server and subscribe to incoming messages</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">socket</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="ow">new</code><code class="w"> </code><code class="nx">WebSocket</code><code class="p">(</code><code class="s2">"wss://your-websocket-server.com"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">socket</code><code class="p">.</code><code class="nx">onmessage</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">setMessages</code><code class="p">((</code><code class="nx">prevMessages</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">[...</code><code class="nx">prevMessages</code><code class="p">,</code><code class="w"> </code><code class="nx">event</code><code class="p">.</code><code class="nx">data</code><code class="p">]);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">socket</code><code class="p">.</code><code class="nx">close</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">sendMessage</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Send the message to the server</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">MessageList</code> <code class="na">messages</code><code class="o">=</code><code class="p">{</code><code class="nx">messages</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">MessageInput</code> <code class="na">onSubmit</code><code class="o">=</code><code class="p">{</code><code class="nx">sendMessage</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, React’s concurrent rendering capabilities come into&#13;
play by efficiently managing the updates of both the message list and&#13;
the user’s interactions with the message input. When a user types or&#13;
submits a message, React prioritizes the text input updates above other&#13;
updates to ensure a smooth user experience.</p>&#13;
&#13;
<p>When new messages arrive from the server and need to be rendered, they are rendered in the default/unknown render lane, which updates the DOM&#13;
synchronously and instantly in a blocking manner: this would delay any&#13;
user input. If we want rendering the new list of messages to be&#13;
de-prioritized, we can wrap the corresponding state update in a&#13;
<code>startTransition</code> function<a data-primary="startTransition function" data-type="indexterm" id="id887"/><a data-primary="useTransition hook" data-type="indexterm" id="id888"/> from the <code>useTransition</code> hook, like so:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">ChatApp</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">messages</code><code class="p">,</code><code class="w"> </code><code class="nx">setMessages</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">([]);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">isPending</code><code class="p">,</code><code class="w"> </code><code class="nx">startTransition</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useTransition</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="nx">useEffect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Connect to the server and subscribe to incoming messages</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">socket</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="ow">new</code><code class="w"> </code><code class="nx">WebSocket</code><code class="p">(</code><code class="s2">"wss://your-websocket-server.com"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">socket</code><code class="p">.</code><code class="nx">onmessage</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">startTransition</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">setMessages</code><code class="p">((</code><code class="nx">prevMessages</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">[...</code><code class="nx">prevMessages</code><code class="p">,</code><code class="w"> </code><code class="nx">event</code><code class="p">.</code><code class="nx">data</code><code class="p">]);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">socket</code><code class="p">.</code><code class="nx">close</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">sendMessage</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">message</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Send the message to the server</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">MessageList</code> <code class="na">messages</code><code class="o">=</code><code class="p">{</code><code class="nx">messages</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">MessageInput</code> <code class="na">onSubmit</code><code class="o">=</code><code class="p">{</code><code class="nx">sendMessage</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>With this, we signal to React to schedule the message list updates with&#13;
a lower priority and render them without blocking the UI, allowing the&#13;
chat application to function efficiently, even under heavy load. Thus,&#13;
user input is never interrupted, and incoming messages are rendered with&#13;
a lower priority than user interactions since they are less critical to&#13;
the user experience.</p>&#13;
&#13;
<p>This example demonstrates how React’s concurrent rendering capabilities&#13;
can be leveraged to build responsive applications that handle complex&#13;
interactions and frequent updates without compromising on performance or&#13;
user experience. We will dive deeper into <code>useTransition</code> further in&#13;
this chapter. For now, let’s look a little deeper at how, exactly, React&#13;
schedules updates.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Diving Deeper" data-type="sect1"><div class="sect1" id="id245">&#13;
<h1>Diving Deeper</h1>&#13;
&#13;
<p>In React, the process of scheduling, prioritizing, and deferring updates&#13;
is essential to maintaining a responsive user interface. This process&#13;
ensures that high-priority tasks are addressed promptly, while&#13;
low-priority tasks can be deferred, allowing the UI to remain smooth&#13;
even under heavy load. To delve deeper into this topic, we’ll examine&#13;
several core concepts: the scheduler, the priority levels of tasks, and&#13;
the mechanisms that defer updates.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Before we proceed—let’s remind ourselves one more time that the&#13;
information covered here consists of implementation details and is <em>not&#13;
requisite to using React</em>. However, understanding these concepts will&#13;
help you better understand how React works and how to use it&#13;
effectively, while also teaching you the underlying mechanism that you&#13;
can apply in other engineering endeavors, improving your overall&#13;
skill set. With that in mind, let’s proceed.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Scheduler" data-type="sect2"><div class="sect2" id="id104">&#13;
<h2>The Scheduler</h2>&#13;
&#13;
<p>At the core of React’s architecture, the scheduler<a data-primary="scheduling and deferring updates" data-secondary="scheduler package" data-type="indexterm" id="ix_schedulinganddeferringupdatesschedulerpackage.07.285.51"/> is a standalone&#13;
package that provides timing-related utilities, independent of the <a data-primary="Fiber reconciler" data-secondary="and scheduler" data-secondary-sortas="scheduler" data-type="indexterm" id="id889"/><a data-primary="reconciliation" data-secondary="Fiber reconciler" data-type="indexterm" id="id890"/>Fiber&#13;
reconciler. React uses this scheduler within the reconciler. The&#13;
scheduler and reconciler, through the usage of render lanes, enable&#13;
tasks to cooperate by prioritizing and organizing them based on their&#13;
urgency. We will dive deep into render lanes shortly. The scheduler’s&#13;
primary role in React today is to manage the yielding of the main&#13;
thread, mainly by scheduling microtasks to ensure smooth execution.</p>&#13;
&#13;
<p>To understand this in a little more detail, let’s look at a portion of&#13;
React’s source code at the time of writing:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">export</code> <code class="kd">function</code> <code class="nx">ensureRootIsScheduled</code><code class="p">(</code><code class="nx">root</code><code class="o">:</code> <code class="nx">FiberRoot</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">// This function is called whenever a root receives an update. It does two</code>&#13;
  <code class="c1">// things 1) it ensures the root is in the root schedule, and 2) it ensures</code>&#13;
  <code class="c1">// there's a pending microtask to process the root schedule.</code>&#13;
  <code class="c1">//</code>&#13;
  <code class="c1">// Most of the actual scheduling logic does not happen until</code>&#13;
  <code class="c1">// `scheduleTaskForRootDuringMicrotask` runs.</code>&#13;
&#13;
  <code class="c1">// Add the root to the schedule</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">root</code> <code class="o">===</code> <code class="nx">lastScheduledRoot</code> <code class="o">||</code> <code class="nx">root</code><code class="p">.</code><code class="nx">next</code> <code class="o">!==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Fast path. This root is already scheduled.</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">lastScheduledRoot</code> <code class="o">===</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">firstScheduledRoot</code> <code class="o">=</code> <code class="nx">lastScheduledRoot</code> <code class="o">=</code> <code class="nx">root</code><code class="p">;</code>&#13;
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
      <code class="nx">lastScheduledRoot</code><code class="p">.</code><code class="nx">next</code> <code class="o">=</code> <code class="nx">root</code><code class="p">;</code>&#13;
      <code class="nx">lastScheduledRoot</code> <code class="o">=</code> <code class="nx">root</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// Any time a root received an update, we set this to true until the next time</code>&#13;
  <code class="c1">// we process the schedule. If it's false, then we can quickly exit flushSync</code>&#13;
  <code class="c1">// without consulting the schedule.</code>&#13;
  <code class="nx">mightHavePendingSyncWork</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// At the end of the current event, go through each of the roots and ensure</code>&#13;
  <code class="c1">// there's a task scheduled for each one at the correct priority.</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">__DEV__</code> <code class="o">&amp;&amp;</code> <code class="nx">ReactCurrentActQueue</code><code class="p">.</code><code class="nx">current</code> <code class="o">!==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// We're inside an `act` scope.</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">didScheduleMicrotask_act</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">didScheduleMicrotask_act</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
      <code class="nx">scheduleImmediateTask</code><code class="p">(</code><code class="nx">processRootScheduleInMicrotask</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">didScheduleMicrotask</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">didScheduleMicrotask</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
      <code class="nx">scheduleImmediateTask</code><code class="p">(</code><code class="nx">processRootScheduleInMicrotask</code><code class="p">);</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">enableDeferRootSchedulingToMicrotask</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// While this flag is disabled, we schedule the render task immediately</code>&#13;
    <code class="c1">// instead of waiting for a microtask.</code>&#13;
    <code class="c1">// TODO: We need to land enableDeferRootSchedulingToMicrotask ASAP to</code>&#13;
    <code class="c1">// unblock additional features we have planned.</code>&#13;
    <code class="nx">scheduleTaskForRootDuringMicrotask</code><code class="p">(</code><code class="nx">root</code><code class="p">,</code> <code class="nx">now</code><code class="p">());</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">if</code> <code class="p">(</code>&#13;
    <code class="nx">__DEV__</code> <code class="o">&amp;&amp;</code>&#13;
    <code class="nx">ReactCurrentActQueue</code><code class="p">.</code><code class="nx">isBatchingLegacy</code> <code class="o">&amp;&amp;</code>&#13;
    <code class="nx">root</code><code class="p">.</code><code class="nx">tag</code> <code class="o">===</code> <code class="nx">LegacyRoot</code>&#13;
  <code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Special `act` case: Record whenever a legacy update is scheduled.</code>&#13;
    <code class="nx">ReactCurrentActQueue</code><code class="p">.</code><code class="nx">didScheduleLegacyUpdate</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>ensureRootIsScheduled</code> function<a data-primary="ensureRootIsScheduled function" data-type="indexterm" id="id891"/><a data-primary="root, React" data-secondary="ensureRootIsScheduled function" data-type="indexterm" id="id892"/> in React’s codebase plays a crucial&#13;
role in managing the rendering process. When a React root, represented&#13;
by <code>root: FiberRoot</code>, receives an update, this function is called to&#13;
perform two critical actions. Remember from <a data-type="xref" href="ch04.html#ch04">Chapter 4</a>: a&#13;
React root<a data-primary="root, React" data-secondary="in commit phase" data-type="indexterm" id="id893"/> is the final “swap” that happens during the commit phase to&#13;
make updates.</p>&#13;
&#13;
<p>When <code>ensureRootIsScheduled</code> is called, it confirms that the root is&#13;
included in the root schedule: a list that tracks which roots need to be&#13;
processed. Secondly, it ensures the existence of a pending microtask&#13;
dedicated to processing this root schedule.</p>&#13;
&#13;
<p>A microtask<a data-primary="microtasks, JavaScript event loop" data-type="indexterm" id="ix_microtasksJavaScripteventloop.07.370.12"/> is a concept in JavaScript<a data-primary="JavaScript" data-secondary="microtasks in event loop" data-type="indexterm" id="ix_JavaScriptmicrotasksineventloop.07.370.39"/> event-loop management,&#13;
representing a type of task that is managed by the microtask queue. To&#13;
understand microtasks, it’s important to first have a basic grasp of the&#13;
JavaScript event loop<a data-primary="event loop, JavaScript" data-type="indexterm" id="ix_eventloopJavaScript.07.373.22"/> and the task queues associated with it:</p>&#13;
<dl>&#13;
<dt>Event loop</dt>&#13;
<dd>&#13;
<p>The JavaScript engine uses an event loop to manage&#13;
asynchronous operations. The event loop continuously checks if there’s&#13;
any work (like executing a callback) that needs to be done. It operates&#13;
on two kinds of task queues: the task queue (macro task queue) and the&#13;
microtask queue.</p>&#13;
</dd>&#13;
<dt>Task queue (macro task queue)</dt>&#13;
<dd>&#13;
<p>This queue<a data-primary="task queue, JavaScript event loop" data-type="indexterm" id="id894"/><a data-primary="macro task queue, JavaScript event loop" data-type="indexterm" id="id895"/> holds tasks such as&#13;
handling events, executing <code>setTimeout</code> and <code>set​Interval</code> callbacks, and&#13;
performing I/O operations. Tasks in this queue are processed one at a&#13;
time, and the next task is picked up only after the current one is&#13;
completed.</p>&#13;
</dd>&#13;
<dt>Microtask queue</dt>&#13;
<dd>&#13;
<p>A microtask is a smaller, more immediate task.&#13;
Microtasks arise from operations like promises, <code>Object.observe</code>, and&#13;
<code>MutationObserver</code>. They are stored in the microtask queue, which is&#13;
different from the regular task queue.</p>&#13;
</dd>&#13;
<dt>Execution</dt>&#13;
<dd>&#13;
<p>Microtasks are processed at the end of the current task,&#13;
before the JavaScript engine picks up the next (macro) task from the&#13;
task queue. After executing a task, the engine checks if there are any&#13;
microtasks in the microtask queue and executes them all before moving&#13;
on. This ensures that microtasks are processed quickly and in order,&#13;
just after the currently executing script and before any other tasks,&#13;
like rendering or handling events.</p>&#13;
</dd>&#13;
<dt>Characteristics and usage</dt>&#13;
<dd>&#13;
<p>Microtasks have higher priority over&#13;
other tasks in the task queue, meaning they are executed before moving&#13;
on to the next macro task. If a microtask continuously adds more&#13;
microtasks to the queue, it can lead to a situation where the task queue&#13;
never gets processed. This is known<a data-primary="starvation, in microtask processing" data-type="indexterm" id="id896"/> as <em>starvation</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>In the context of React and the <code>ensureRootIsScheduled</code> function, a&#13;
microtask is used to ensure that the processing of the root schedule&#13;
happens promptly and with high priority, right after the current script&#13;
execution and before the browser performs other tasks like rendering or&#13;
handling events. This helps in maintaining smooth UI updates and&#13;
efficient task management within the React framework.</p>&#13;
&#13;
<p>The function starts by adding the root to the schedule. This involves&#13;
checking if the root is either the last scheduled one or already present&#13;
in the schedule. If it’s not present, the function adds the root to the end of&#13;
the schedule, updating the &#13;
<span class="keep-together"><code>lastScheduledRoot</code></span> to point to the current&#13;
root. If no root was previously scheduled&#13;
(<code>lastScheduledRoot === null</code>), the current root becomes both the first&#13;
and the last in the schedule.</p>&#13;
&#13;
<p>Next, the function sets the flag <code>mightHavePendingSyncWork</code> to <code>true</code>.&#13;
This flag signals that there might be synchronous work pending, essential for the <code>flushSync</code> function, which we’ll&#13;
cover in the next section.</p>&#13;
&#13;
<p>The function then ensures that a microtask is scheduled to process the&#13;
root schedule. This is done by calling&#13;
<code>scheduleImmediateTask(processRootScheduleInMicrotask)</code>. This scheduling&#13;
happens both within and outside of React’s <code>act</code> testing utility scope,&#13;
indicated by <code>__DEV__</code> and <code>ReactCurrentActQueue.current</code>.</p>&#13;
&#13;
<p>Another significant part of this function<a data-primary="deferring updates" data-type="indexterm" id="id897"/><a data-primary="updates" data-secondary="deferring" data-type="indexterm" id="id898"/> is the conditional block&#13;
checking the <code>enableDeferRootSchedulingToMicrotask</code> flag. If this flag&#13;
is disabled, the function schedules the render task immediately instead&#13;
of deferring it to a microtask. This part is marked with a <code>TODO</code>&#13;
comment (at the time of writing), indicating future plans to enable this&#13;
feature for unlocking additional functionalities.</p>&#13;
&#13;
<p>Finally, the function includes a condition for handling legacy updates&#13;
within React’s <code>act</code> utility. This is specific to testing scenarios&#13;
where updates are batched differently, and it records whenever a legacy&#13;
update is scheduled.</p>&#13;
&#13;
<p>The long and short<a data-primary="ensureRootIsScheduled function" data-type="indexterm" id="id899"/><a data-primary="root, React" data-secondary="ensureRootIsScheduled function" data-type="indexterm" id="id900"/> of this is that <code>ensureRootIsScheduled</code> is a sophisticated&#13;
function that integrates several aspects of React’s scheduling and&#13;
rendering logic, focusing on efficiently managing updates to React roots&#13;
and ensuring smooth rendering by strategically scheduling tasks and&#13;
microtasks<a data-startref="ix_microtasksJavaScripteventloop.07.370.12" data-type="indexterm" id="id901"/><a data-startref="ix_JavaScriptmicrotasksineventloop.07.370.39" data-type="indexterm" id="id902"/><a data-startref="ix_eventloopJavaScript.07.373.22" data-type="indexterm" id="id903"/>.</p>&#13;
&#13;
<p>From this, we understand the role of the scheduler in React: scheduling work based on the render lanes that work falls into. We get&#13;
pretty deep into lanes in the next section, but for now, suffice it to&#13;
say that lanes are indicative of an update’s priority.</p>&#13;
&#13;
<p>If we model the scheduler’s behavior in code, it would look like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="k">if</code> <code class="p">(</code><code class="nx">nextLane</code> <code class="o">===</code> <code class="nx">Sync</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="nx">queueMicrotask</code><code class="p">(</code><code class="nx">processNextLane</code><code class="p">);</code>&#13;
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>&#13;
  <code class="nx">Scheduler</code><code class="p">.</code><code class="nx">scheduleCallback</code><code class="p">(</code><code class="nx">callback</code><code class="p">,</code> <code class="nx">processNextLane</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>From this, we see that:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the next lane is <code>Sync</code>, then the scheduler queues a microtask to&#13;
process the next lane immediately. Ideally, by now we understand what&#13;
microtasks are and how this fits.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the next lane is not <code>Sync</code>, then the scheduler schedules a&#13;
callback and processes the next lane<a data-startref="ix_updatesscheduling.07.109.46" data-type="indexterm" id="id904"/><a data-startref="ix_schedulinganddeferringupdates.07.109.46" data-type="indexterm" id="id905"/><a data-startref="ix_concurrentrenderingandupdatingschedulinganddeferringupdates.07.109.46" data-type="indexterm" id="id906"/><a data-startref="ix_prioritizingupdatesschedulinganddeferring.07.109.46" data-type="indexterm" id="id907"/><a data-startref="ix_schedulinganddeferringupdatesschedulerpackage.07.285.51" data-type="indexterm" id="id908"/>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Thus, the scheduler is exactly what it sounds like: a system that&#13;
schedules functions to run determined by that function’s lane. OK,&#13;
we’ve been talking about lanes for a while. Let’s dive in and understand&#13;
them in detail!</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Render Lanes" data-type="sect1"><div class="sect1" id="id105">&#13;
<h1>Render Lanes</h1>&#13;
&#13;
<p>Render lanes<a data-primary="render lanes, concurrent React" data-type="indexterm" id="ix_renderlanesconcurrentReact.07.481.13"/><a data-primary="concurrent rendering and updating" data-secondary="render lanes" data-type="indexterm" id="ix_concurrentrenderingandupdatingrenderlanes.07.481.13"/><a data-primary="prioritizing updates" data-secondary="render lanes’ role in" data-type="indexterm" id="ix_prioritizingupdatesrenderlanesrolein.07.481.13"/><a data-primary="scheduling and deferring updates" data-secondary="render lanes" data-type="indexterm" id="ix_schedulinganddeferringupdatesrenderlanes.07.481.13"/> are an essential part of React’s scheduling system, which&#13;
ensures efficient rendering and prioritization of tasks. A lane<a data-primary="lane, as unit of work" data-type="indexterm" id="id909"/> is a&#13;
unit of work that represents a priority level and can be processed by&#13;
React as part of its rendering cycle. The concept of render lanes was&#13;
introduced in React 18, replacing the previous scheduling mechanism that&#13;
used expiration times. Let’s dive into the details of render lanes, how&#13;
they work, and their underlying representation as bitmasks.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Once again, these are implementation details in React that may change at&#13;
any time. The point here is to understand the underlying mechanism that&#13;
will help us in our everyday engineering work, and will also help us&#13;
understand how React works and enable us to use it more effectively or&#13;
fluently. It would serve us well to not get hung up on the details, but&#13;
to instead stick to the mechanism and its potential for real-world&#13;
application.</p>&#13;
</div>&#13;
&#13;
<p>First off, a render lane is a lightweight abstraction that React uses to&#13;
organize and prioritize updates that need to be made during the&#13;
rendering process.</p>&#13;
&#13;
<p>For example, when you call <code>setState</code>, that update is put into a lane.&#13;
We can understand the different priorities based on the context of the&#13;
updates, like so:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If <code>setState</code> is called inside of a click handler, it is put into the&#13;
Sync lane (highest priority) and scheduled in a microtask.</p>&#13;
</li>&#13;
<li>&#13;
<p>If <code>setState</code> is called inside a transition from <code>startTransition</code>,&#13;
it’s put in a transition lane (lower priority) and scheduled in a&#13;
microtask.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Each lane corresponds to a specific priority level, with higher-priority&#13;
lanes processed before lower-priority lanes. Some examples of lanes in&#13;
React are:</p>&#13;
<dl>&#13;
<dt><code>SyncHydrationLane</code></dt>&#13;
<dd>&#13;
<p>When users click<a data-primary="SyncHydrationLane" data-type="indexterm" id="id910"/> on a React app during hydration,&#13;
the click event is put into this lane.</p>&#13;
</dd>&#13;
<dt><code>SyncLane</code></dt>&#13;
<dd>&#13;
<p>When users click<a data-primary="SyncLane" data-type="indexterm" id="id911"/> on a React app, the click event is put&#13;
into this lane.</p>&#13;
</dd>&#13;
<dt><code>InputContinuousHydrationLane</code></dt>&#13;
<dd>&#13;
<p>Hover events<a data-primary="InputContinuousHydrationLane" data-type="indexterm" id="id912"/>, scroll events, and other&#13;
continuous events during hydration are put into this lane.</p>&#13;
</dd>&#13;
<dt><code>InputContinuousLane</code></dt>&#13;
<dd>&#13;
<p>Same as the preceding<a data-primary="InputContinuousLane" data-type="indexterm" id="id913"/>, but for after a React app is&#13;
hydrated.</p>&#13;
</dd>&#13;
<dt><code>DefaultLane</code></dt>&#13;
<dd>&#13;
<p>Any updates<a data-primary="DefaultLane" data-type="indexterm" id="id914"/> from the network, timers like <code>setTimeout</code>,&#13;
and the initial render where priority isn’t inferred are put into this&#13;
lane.</p>&#13;
</dd>&#13;
<dt><code>TransitionHydrationLane</code></dt>&#13;
<dd>&#13;
<p>Any transitions<a data-primary="TransitionHydrationLane" data-type="indexterm" id="id915"/> from <code>startTransition</code>&#13;
during hydration are put into this lane.</p>&#13;
</dd>&#13;
<dt><code>TransitionLanes</code> (1–15)</dt>&#13;
<dd>&#13;
<p>Any transitions<a data-primary="TransitionLanes" data-type="indexterm" id="id916"/> from <code>startTransition</code> after&#13;
hydration are put into these lanes.</p>&#13;
</dd>&#13;
<dt><code>RetryLanes</code> (1–4)</dt>&#13;
<dd>&#13;
<p>Any Suspense retries are put into these lanes.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>It’s worth noting that these lanes are indicative of React’s internal&#13;
implementation at the time of writing and are subject to change.&#13;
To reiterate, the point of this book is to understand the <em>mechanism</em> by&#13;
which React works without being too married to the exact implementation&#13;
details, so the names of lanes likely don’t matter too much. What&#13;
matters infinitely more is our understanding of the mechanism—that is,&#13;
how React uses the concept—and how we can apply it to our work.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Render Lanes Work" data-type="sect2"><div class="sect2" id="id246">&#13;
<h2>How Render Lanes Work</h2>&#13;
&#13;
<p>When a component updates or a new component is added to the render tree,&#13;
React assigns a lane to the update based on its priority using the lanes&#13;
we previously discussed. As we know, the priority is determined by&#13;
the type of update (e.g., user interaction, data fetching, or background&#13;
task) and other factors, such as the component’s visibility.</p>&#13;
&#13;
<p>React then uses the render lanes to schedule and prioritize updates in&#13;
the following manner:</p>&#13;
<dl>&#13;
<dt>1. Collect updates</dt>&#13;
<dd>&#13;
<p>React collects all the updates that have been&#13;
scheduled since the last render and assigns them to their respective&#13;
lanes based on their priority.</p>&#13;
</dd>&#13;
<dt>2. Process lanes</dt>&#13;
<dd>&#13;
<p>React processes the updates in their respective&#13;
lanes, starting with the highest priority lane. Updates in the same lane&#13;
are batched together and processed in a single pass.</p>&#13;
</dd>&#13;
<dt>3. Commit phase</dt>&#13;
<dd>&#13;
<p>After processing all the updates, React enters the&#13;
commit phase, where it applies the changes to the DOM, runs effects, and&#13;
performs other finalization tasks.</p>&#13;
</dd>&#13;
<dt>4. Repeat</dt>&#13;
<dd>&#13;
<p>The process repeats for each render, ensuring that updates&#13;
are always processed in priority order, and that high-priority updates&#13;
are not starved by lower-priority ones.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>React takes care of assigning updates to the correct lanes based on&#13;
these priorities, allowing the application to function efficiently&#13;
without manual intervention.</p>&#13;
&#13;
<p>When an update is triggered, React performs the following steps to&#13;
determine its priority and assign it to the correct lane:</p>&#13;
<dl>&#13;
<dt>1. Determine the update’s context</dt>&#13;
<dd>&#13;
<p>React evaluates the context in which&#13;
the update was triggered. This context could be a user interaction, an&#13;
internal update due to state or props changes, or even an update that’s&#13;
a result of a server response. The context plays a crucial role in&#13;
determining the priority of the update.</p>&#13;
</dd>&#13;
<dt>2. Estimate priority based on the context</dt>&#13;
<dd>&#13;
<p>Based on the context, React&#13;
estimates the priority of the update. For instance, if the update is a&#13;
result of user input, it’s likely to have a higher priority, while an&#13;
update triggered by a noncritical background process might have a lower&#13;
priority. We’ve already discussed the different priority levels in&#13;
detail, so we won’t go into more detail here.</p>&#13;
</dd>&#13;
<dt>3. Check for any priority overrides</dt>&#13;
<dd>&#13;
<p>In some cases, developers can&#13;
explicitly set the priority of an update using React’s <code>useTransition</code>&#13;
or <code>useDeferredValue</code> hooks. If such a priority override is present,&#13;
React will consider the provided priority instead of the estimated one.</p>&#13;
</dd>&#13;
<dt>4. Assign the update to the correct lane</dt>&#13;
<dd>&#13;
<p>Once the priority is&#13;
determined, React assigns the update to the corresponding lane. This&#13;
process is done using the bitmask we just looked at, which allows React&#13;
to efficiently work with multiple lanes and ensure that updates are&#13;
correctly grouped and processed.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Throughout this process, React relies on its internal heuristics and the&#13;
context in which updates occur to make informed decisions about their&#13;
priorities. This dynamic assignment of priorities and lanes allows React&#13;
to balance responsiveness and performance, ensuring that applications&#13;
function efficiently without manual intervention from developers.</p>&#13;
&#13;
<p>Let’s look into how exactly React processes updates in their respective&#13;
lanes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Processing Lanes" data-type="sect2"><div class="sect2" id="id106">&#13;
<h2>Processing Lanes</h2>&#13;
&#13;
<p>Once updates<a data-primary="processing lanes, render lanes" data-type="indexterm" id="id917"/> have been assigned to their respective lanes, React&#13;
processes them in priority order. In our chat application example, React&#13;
would process updates in the following order:</p>&#13;
<dl>&#13;
<dt><code>ImmediatePriority</code></dt>&#13;
<dd>&#13;
<p>Process updates<a data-primary="ImmediatePriority level, render lanes" data-type="indexterm" id="id918"/> to the message input, ensuring it&#13;
remains responsive and updates quickly.</p>&#13;
</dd>&#13;
<dt><code>UserBlockingPriority</code></dt>&#13;
<dd>&#13;
<p>Process updates<a data-primary="UserBlockingPriority level, render lanes" data-type="indexterm" id="id919"/> to the typing indicator,&#13;
providing users with real-time feedback.</p>&#13;
</dd>&#13;
<dt><code>NormalPriority</code></dt>&#13;
<dd>&#13;
<p>Process updates<a data-primary="NormalPriority level, render lanes" data-type="indexterm" id="id920"/> to the message list, displaying new&#13;
messages and updates at a reasonable pace.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>By processing updates in priority order, React ensures that the most&#13;
important parts of the application remain responsive even under heavy&#13;
load.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Commit Phase" data-type="sect2"><div class="sect2" id="id107">&#13;
<h2>Commit Phase</h2>&#13;
&#13;
<p>After processing<a data-primary="commit phase" data-secondary="render lanes" data-type="indexterm" id="id921"/> all the updates in their respective lanes, React enters&#13;
the commit phase, where it applies the changes to the DOM, runs effects,&#13;
and performs other finalization tasks. In our chat application example,&#13;
this might include updating the message input value, showing or hiding&#13;
the typing indicator, and appending new messages to the message list.&#13;
React then moves on to the next render cycle, repeating the process of&#13;
collecting updates, processing lanes, and committing changes.</p>&#13;
&#13;
<p>This process, however, is exceedingly more complex than we can truly&#13;
appreciate in this book: there are concepts<a data-primary="entanglement" data-type="indexterm" id="id922"/> like <em>entanglement</em>, which&#13;
decides when two lanes need to be processed together, and further&#13;
concepts<a data-primary="rebasing" data-type="indexterm" id="id923"/> like <em>rebasing</em>, which decides when an update needs to be rebased&#13;
on top of updates that have already been processed. Rebasing is useful,&#13;
for example, in cases where a transition is interrupted by a sync update&#13;
before it finished, and you need to run both together.</p>&#13;
&#13;
<p>There’s also a lot to say here about flushing effects<a data-primary="flushing effects" data-type="indexterm" id="id924"/>. For example, like when there is a synchronous update, React may flush effects before/after the update to ensure consistent ordering of state between sync updates.</p>&#13;
&#13;
<p>Ultimately, this is why React exists, and the true value React adds&#13;
behind the scenes as an abstraction layer: it fundamentally handles the&#13;
update problems, their prioritization, and their ordering for us,&#13;
while we continue to focus on our applications.</p>&#13;
&#13;
<p>It’s important to note that while React is good at estimating&#13;
priorities, it’s not always perfect. As a developer, you may sometimes&#13;
need to override the default priority assignments using some of the APIs&#13;
we’ve mentioned so far: <code>useTransition</code> and &#13;
<span class="keep-together"><code>useDeferredValue</code></span> to&#13;
fine-tune your application’s performance and responsiveness. Let’s dive&#13;
into these APIs in more detail<a data-startref="ix_renderlanesconcurrentReact.07.481.13" data-type="indexterm" id="id925"/><a data-startref="ix_concurrentrenderingandupdatingrenderlanes.07.481.13" data-type="indexterm" id="id926"/><a data-startref="ix_prioritizingupdatesrenderlanesrolein.07.481.13" data-type="indexterm" id="id927"/><a data-startref="ix_schedulinganddeferringupdatesrenderlanes.07.481.13" data-type="indexterm" id="id928"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="useTransition" data-type="sect1"><div class="sect1" id="id108">&#13;
<h1>useTransition</h1>&#13;
&#13;
<p><code>useTransition</code> is a powerful React Hook<a data-primary="useTransition hook" data-type="indexterm" id="ix_useTransitionhook.07.675.41"/><a data-primary="concurrent rendering and updating" data-secondary="useTransition hook" data-type="indexterm" id="ix_concurrentrenderingandupdatinguseTransitionhook.07.675.41"/> that allows you to manage the&#13;
priority of state updates in your components and prevent the UI from&#13;
becoming unresponsive due to high-priority updates. It’s particularly&#13;
useful when dealing with updates that can be visually disruptive, such&#13;
as loading new data or navigating between pages.</p>&#13;
&#13;
<p>It essentially puts whatever update you wrap in its returned&#13;
<code>startTransition</code> function<a data-primary="startTransition function" data-type="indexterm" id="id929"/> into the transition lane, which is lower&#13;
priority than the Sync lane as we’ve seen earlier, allowing you to&#13;
control the timing of updates and maintain a smooth user experience,&#13;
even when other higher-priority updates are competing for the main&#13;
thread.</p>&#13;
&#13;
<p><code>useTransition</code> is a hook, meaning you can only use it inside function&#13;
components. It returns an array containing two elements:</p>&#13;
<dl>&#13;
<dt><code>isPending</code></dt>&#13;
<dd>&#13;
<p>A boolean indicating whether a transition is in progress.&#13;
One interesting part about the way <code>useTransition</code> works is that the&#13;
first thing it does when you call <code>startTransition</code> is schedule&#13;
a sync <code>setState({ isPending: false })</code> on this property, which means&#13;
updates depending on <code>isPending</code> need to be fast or it defeats the&#13;
purpose of <code>useTransition</code>.</p>&#13;
</dd>&#13;
<dt><code>startTransition</code></dt>&#13;
<dd>&#13;
<p>A function that you can use to wrap updates that&#13;
should be deferred<a data-primary="deferring updates" data-type="indexterm" id="id930"/><a data-primary="concurrent rendering and updating" data-secondary="scheduling and deferring updates" data-type="indexterm" id="id931"/><a data-primary="updates" data-secondary="deferring" data-type="indexterm" id="id932"/> or given a lower priority.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>It’s probably worth mentioning here that there is also a&#13;
<code>startTransition</code> API that is available not as a hook, but as a regular&#13;
function. The second way to start a nonurgent transition is by using&#13;
the function <code>startTransition</code> imported directly from React. This&#13;
approach doesn’t give us access to the <code>isPending</code> flag, but it’s&#13;
available for places in your code when you can’t use hooks, like&#13;
<code>useTransition</code>, but still want to signal a low-priority update to React.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Simple Example" data-type="sect2"><div class="sect2" id="id247">&#13;
<h2>Simple Example</h2>&#13;
&#13;
<p>Here’s a simple example that demonstrates the basic usage of&#13;
<code>useTransition</code>:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="p">,</code><code class="w"> </code><code class="nx">useTransition</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">count</code><code class="p">,</code><code class="w"> </code><code class="nx">setCount</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">0</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">isPending</code><code class="p">,</code><code class="w"> </code><code class="nx">startTransition</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useTransition</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">handleClick</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">doSomethingImportant</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">startTransition</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">setCount</code><code class="p">(</code><code class="nx">count</code><code class="w"> </code><code class="o">+</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Count</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{</code><code class="nx">handleClick</code><code class="p">}&gt;</code><code class="nx">Increment</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">isPending</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">Loading</code><code class="p">...&lt;/</code><code class="nt">p</code><code class="p">&gt;}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="nx">App</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we use <code>useTransition</code> to manage the priority of a state&#13;
update that increments a counter. By wrapping the <code>setCount</code> update&#13;
inside the <code>startTransition</code> function, we are telling React that this update&#13;
can be deferred, preventing the UI &#13;
<span class="keep-together">from becoming</span> unresponsive if there&#13;
are other high-priority updates happening &#13;
<span class="keep-together">simultaneously.</span></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Advanced Example: Navigation" data-type="sect2"><div class="sect2" id="id109">&#13;
<h2>Advanced Example: Navigation</h2>&#13;
&#13;
<p><code>useTransition</code> is also useful when navigating between pages. By&#13;
managing the priority of updates related to navigation, you can ensure&#13;
that the user experience remains smooth and responsive, even when&#13;
dealing with complex page transitions.</p>&#13;
&#13;
<p>Consider this example where we demonstrate how to use <code>useTransition</code>&#13;
for managing page transitions in a single-page application (SPA)<a data-primary="single-page applications (SPAs)" data-type="indexterm" id="id933"/><a data-primary="SPAs (single-page applications)" data-type="indexterm" id="id934"/>:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">useState</code><code class="p">,</code> <code class="nx">useTransition</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">PageOne</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">Page</code> <code class="nx">One</code><code class="o">&lt;</code><code class="err">/div&gt;;</code>&#13;
<code class="kr">const</code> <code class="nx">PageTwo</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">Page</code> <code class="nx">Two</code><code class="o">&lt;</code><code class="err">/div&gt;;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">currentPage</code><code class="p">,</code> <code class="nx">setCurrentPage</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">"pageOne"</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">isPending</code><code class="p">,</code> <code class="nx">startTransition</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useTransition</code><code class="p">();</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">handleNavigation</code> <code class="o">=</code> <code class="p">(</code><code class="nx">page</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="nx">startTransition</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">setCurrentPage</code><code class="p">(</code><code class="nx">page</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="kr">const</code> <code class="nx">renderPage</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
    <code class="k">switch</code> <code class="p">(</code><code class="nx">currentPage</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">case</code> <code class="s2">"pageOne"</code><code class="o">:</code>&#13;
        <code class="k">return</code> <code class="o">&lt;</code><code class="nx">PageOne</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
      <code class="k">case</code> <code class="s2">"pageTwo"</code><code class="o">:</code>&#13;
        <code class="k">return</code> <code class="o">&lt;</code><code class="nx">PageTwo</code> <code class="o">/&gt;</code><code class="p">;</code>&#13;
      <code class="k">default</code><code class="o">:</code>&#13;
        <code class="k">return</code> <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="nx">Unknown</code> <code class="nx">page</code><code class="o">&lt;</code><code class="err">/div&gt;;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">};</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">nav</code><code class="o">&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">handleNavigation</code><code class="p">(</code><code class="s2">"pageOne"</code><code class="p">)}</code><code class="o">&gt;</code><code class="nx">Page</code> <code class="nx">One</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
        <code class="o">&lt;</code><code class="nx">button</code> <code class="nx">onClick</code><code class="o">=</code><code class="p">{()</code> <code class="o">=&gt;</code> <code class="nx">handleNavigation</code><code class="p">(</code><code class="s2">"pageTwo"</code><code class="p">)}</code><code class="o">&gt;</code><code class="nx">Page</code> <code class="nx">Two</code><code class="o">&lt;</code><code class="err">/button&gt;</code>&#13;
      <code class="o">&lt;</code><code class="err">/nav&gt;</code>&#13;
      <code class="p">{</code><code class="nx">isPending</code> <code class="o">&amp;&amp;</code> <code class="o">&lt;</code><code class="nx">p</code><code class="o">&gt;</code><code class="nx">Loading</code><code class="p">...</code><code class="o">&lt;</code><code class="err">/p&gt;}</code>&#13;
      <code class="p">{</code><code class="nx">renderPage</code><code class="p">()}</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">App</code><code class="p">;</code></pre>&#13;
&#13;
<p>In this example, we have two simple components representing different&#13;
pages in our SPA. We use <code>useTransition</code> to wrap the state update that&#13;
changes the current page, ensuring that the page transition is deferred&#13;
if there are other high-priority updates (like user input) happening&#13;
simultaneously.</p>&#13;
&#13;
<p>In this example, you might be thinking, “Wait, shouldn’t the page&#13;
transition be instant though since it happens in response to a user&#13;
click?” Yes, you’d be right; however, if the next page requires some&#13;
data to be fetched using <code>Suspense</code>, then the page transition might be&#13;
delayed. This is where <code>useTransition</code> comes in handy, as it allows you&#13;
to manage the priority of updates related to navigation, ensuring that&#13;
the user experience remains smooth and responsive, even when dealing&#13;
with complex page transitions. It’s worth noting that if the next page&#13;
data fetching happens in an effect, then <code>startTranstion</code> won’t wait for&#13;
the data in the effect to be fetched; however, when you suspend inside of&#13;
a transition, React will tie the <code>isPending</code> state to the data fetch and&#13;
the rendering of that data when it comes back.</p>&#13;
&#13;
<p>In this case, the <code>isPending</code> state will be <code>true</code> while the page&#13;
transition is in progress, allowing us to immediately show a loading indicator to&#13;
the user in response to their button click. Once the&#13;
transition is complete, the <code>isPending</code> state will be <code>false</code>, and the&#13;
new page will be rendered.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Diving Deeper" data-type="sect2"><div class="sect2" id="id110">&#13;
<h2>Diving Deeper</h2>&#13;
&#13;
<p>With the background knowledge of React’s Fiber architecture, the React&#13;
scheduler, priority levels, and the render lanes mechanism, we can now delve&#13;
into the inner workings of the <code>useTransition</code> hook.</p>&#13;
&#13;
<p>The <code>useTransition</code> hook works by creating a transition and assigning a&#13;
specific priority level to the updates made within that transition. When&#13;
an update is wrapped in a transition, React ensures that the update gets&#13;
scheduled and rendered based on the assigned priority level.</p>&#13;
&#13;
<p>Here’s an overview of the steps involved in using the <code>useTransition</code>&#13;
hook:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Import and invoke the <code>useTransition</code> hook within a functional&#13;
component.</p>&#13;
</li>&#13;
<li>&#13;
<p>The hook returns an array with two elements: the first is the&#13;
<code>isPending</code> state, and the second is the <code>startTransition</code> function.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use the <code>startTransition</code> function to wrap any state update or&#13;
component rendering that you want to control the timing of.</p>&#13;
</li>&#13;
<li>&#13;
<p>The <code>isPending</code> state provides an indicator of whether the transition&#13;
is still in progress or has completed.</p>&#13;
</li>&#13;
<li>&#13;
<p>React ensures that updates wrapped in a transition are treated with&#13;
the appropriate priority level. This is achieved by using the scheduler&#13;
and render lanes mechanism to assign and manage the updates.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>By using <code>useTransition</code>, we can effectively control the timing of&#13;
updates and maintain a smooth user experience, even when other&#13;
higher-priority updates are competing for the main thread<a data-startref="ix_useTransitionhook.07.675.41" data-type="indexterm" id="id935"/><a data-startref="ix_concurrentrenderingandupdatinguseTransitionhook.07.675.41" data-type="indexterm" id="id936"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="useDeferredValue" data-type="sect1"><div class="sect1" id="id111">&#13;
<h1>useDeferredValue</h1>&#13;
&#13;
<p><code>useDeferredValue</code> is a React Hook<a data-primary="concurrent rendering and updating" data-secondary="useDeferredValue hook" data-type="indexterm" id="ix_concurrentrenderingandupdatinguseDeferredValuehook.07.859.35"/><a data-primary="useDeferredValue hook" data-type="indexterm" id="ix_useDeferredValuehook.07.859.35"/><a data-primary="deferring updates" data-type="indexterm" id="ix_deferringupdates.07.859.35"/><a data-primary="updates" data-secondary="deferring" data-type="indexterm" id="ix_updatesdeferring.07.859.35"/> that allows for the deferral of&#13;
certain UI updates to a later time, especially useful in scenarios where&#13;
the application is dealing with a heavy load or computationally intensive&#13;
tasks, thereby aiding in managing update prioritization and promoting&#13;
smoother transitions and an improved user experience.</p>&#13;
&#13;
<p>During the initial render, the returned deferred value is the same as&#13;
the supplied value. In subsequent updates, <code>useDeferredValue</code> helps&#13;
maintain a smooth user experience by keeping the old value for a longer&#13;
duration before updating to the new value, particularly in scenarios&#13;
with computationally intensive operations. This does not entail multiple&#13;
rerenders with old and new values, but a controlled update to the new&#13;
value. This mechanism is akin to a <code>stale-while-revalidate</code> strategy,&#13;
holding on to stale values to keep the UI responsive while awaiting new&#13;
values.</p>&#13;
&#13;
<p>Looking through React’s commit history, we see that the first&#13;
implementation of <code>useDeferredValue</code> looked something like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">function</code> <code class="nx">useDeferredValue</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">newValue</code><code class="p">,</code> <code class="nx">setNewValue</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code> <code class="c1">// only stores initial value</code>&#13;
  <code class="nx">useEffect</code><code class="p">(()</code> <code class="p">{</code>&#13;
    <code class="c1">// update the returned value in a transition whenever it changes,</code>&#13;
    <code class="c1">// "deferring" it</code>&#13;
    <code class="nx">startTransition</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">setNewValue</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>&#13;
    <code class="p">});</code>&#13;
 <code class="p">},</code> <code class="p">[</code><code class="nx">value</code><code class="p">]);</code>&#13;
&#13;
 <code class="k">return</code> <code class="nx">newValue</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s chat a bit about what this code is doing. Initially, it sets up a&#13;
state (<code>newValue</code>) with the initial value passed to it. The function&#13;
then utilizes the <code>useEffect</code> hook to observe changes in this value.&#13;
When a change is detected, the <code>startTransition</code> function is invoked,&#13;
which is crucial for deferring the update.</p>&#13;
&#13;
<p>Within <code>startTransition</code>, the state is updated to the new value using&#13;
<code>setNewValue</code>. The use of <code>startTransition</code> signifies to React that this&#13;
update is not urgent, allowing React to prioritize other, more critical&#13;
updates first. This is more or less exactly how <code>useDeferredValue</code> works&#13;
today and should be helpful for our mental model of it.</p>&#13;
&#13;
<p><code>useDeferredValue</code> is a part of React’s concurrent features that enables&#13;
interruptibility by allowing certain state updates to be deferred.</p>&#13;
&#13;
<p>When a component rerenders with a deferred value, React keeps showing&#13;
the old value for a certain period, allowing high-priority updates to be&#13;
processed before low-priority ones. This breaks up the rendering work&#13;
into smaller chunks, which can be spread out over time, improving&#13;
responsiveness and ensuring that high-priority updates (like user&#13;
interactions) are not delayed by lower-priority updates, hence boosting&#13;
positive user experience.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Purpose of useDeferredValue" data-type="sect2"><div class="sect2" id="id112">&#13;
<h2>Purpose of useDeferredValue</h2>&#13;
&#13;
<p>The primary purpose of <code>useDeferredValue</code> is to allow you to defer the&#13;
rendering of less critical updates. This is particularly useful when you&#13;
want to prioritize more important updates, such as user interactions,&#13;
over less critical ones, such as displaying updated data from the&#13;
server.</p>&#13;
&#13;
<p>By using <code>useDeferredValue</code>, you can provide a smoother user experience&#13;
and ensure that your application remains responsive even under heavy&#13;
load or when dealing with complex operations.</p>&#13;
&#13;
<p>To use <code>useDeferredValue</code>, you will need to import it from the React&#13;
package and pass a value to be deferred as its argument. The hook will&#13;
then return a deferred version of the value that can be used in your&#13;
component.</p>&#13;
&#13;
<p>Here’s an example of how to use <code>useDeferredValue</code> in a simple&#13;
application:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">import</code> <code class="nx">React</code><code class="p">,</code> <code class="p">{</code> <code class="nx">memo</code> <code class="nx">useState</code><code class="p">,</code> <code class="nx">useDeferredValue</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">App</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">[</code><code class="nx">searchValue</code><code class="p">,</code> <code class="nx">setSearchValue</code><code class="p">]</code> <code class="o">=</code> <code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code>&#13;
  <code class="kr">const</code> <code class="nx">deferredSearchValue</code> <code class="o">=</code> <code class="nx">useDeferredValue</code><code class="p">(</code><code class="nx">searchValue</code><code class="p">);</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">input</code>&#13;
        <code class="nx">type</code><code class="o">=</code><code class="s2">"text"</code>&#13;
        <code class="nx">value</code><code class="o">=</code><code class="p">{</code><code class="nx">searchValue</code><code class="p">}</code>&#13;
        <code class="nx">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">event</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">setSearchValue</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
      <code class="o">/&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">SearchResults</code> <code class="nx">searchValue</code><code class="o">=</code><code class="p">{</code><code class="nx">deferredSearchValue</code><code class="p">}</code> <code class="o">/&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">SearchResults</code> <code class="o">=</code> <code class="nx">memo</code><code class="p">(({</code> <code class="nx">searchValue</code> <code class="p">})</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// Perform the search and render the results</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>In this example, we have a search input and a <code>SearchResults</code> component&#13;
that displays the results. We use <code>useDeferredValue</code> to defer the&#13;
rendering of the search results, allowing the application to prioritize&#13;
user input and remain responsive even when rendering the list of results&#13;
is expensive. Let’s understand this in a little more detail:</p>&#13;
<ol>&#13;
<li>&#13;
<p>We use <code>memo</code> on the component to make sure it doesn’t unnecessarily&#13;
update, as we’ve discussed in prior chapters.</p>&#13;
</li>&#13;
<li>&#13;
<p>When it updates, it causes performance problems because it’s expensive&#13;
to &#13;
<span class="keep-together">render.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>When we give it a deferred prop, <code>deferredSearchValue</code>, since the prop&#13;
itself is updated after more urgent rendering work, so is the component. Thus, the component only rerenders when there’s no more urgent work to be done, like updating the text input field.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>One might ask here, “Why not just debounce or throttle <code>searchValue</code>?”</p>&#13;
&#13;
<p>Great question. Let’s contrast those here:</p>&#13;
<dl>&#13;
<dt>Debouncing</dt>&#13;
<dd>&#13;
<p>Involves a pause<a data-primary="debouncing" data-type="indexterm" id="id937"/> before updating the list, waiting for&#13;
the user to finish typing, such as a delay of one second</p>&#13;
</dd>&#13;
<dt>Throttling</dt>&#13;
<dd>&#13;
<p>Updates<a data-primary="throttling" data-type="indexterm" id="id938"/> the list at regular&#13;
intervals, say, no more than once per second</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>While these methods can be effective in certain situations,&#13;
<code>useDeferredValue</code> emerges as a more tailored solution for rendering&#13;
optimization since it adapts seamlessly to the performance capabilities&#13;
of the user’s device and isn’t some arbitrary delay.</p>&#13;
&#13;
<p>The key difference with <code>useDeferredValue</code> lies in its dynamic approach&#13;
to delays. It eliminates the need for setting a fixed delay time. On a&#13;
high-performance device, such as a powerful laptop, the delay in&#13;
rerendering is almost imperceptible, occurring almost instantaneously.&#13;
Conversely, on slower devices, the rendering delay adjusts accordingly,&#13;
causing the list to update with a slight lag in response to the input,&#13;
proportional to the device’s speed.</p>&#13;
&#13;
<p>Moreover, <code>useDeferredValue</code> has a significant advantage in its ability&#13;
to interrupt deferred rerenders. In scenarios where React is processing&#13;
a substantial list, and the user enters a new keystroke, React can pause&#13;
the rerendering, respond to the new input, and then resume the&#13;
rendering process in the background. This is a contrast to debouncing&#13;
and throttling, which, despite delaying updates, can still lead to a&#13;
disjointed experience as they block interactivity during rendering.</p>&#13;
&#13;
<p>That said, debouncing and throttling are still useful in scenarios not&#13;
directly related to rendering. For instance, they can be effective in&#13;
reducing the frequency of network requests. These techniques can also be&#13;
used in conjunction with <code>useDeferredValue</code> for a comprehensive&#13;
optimization strategy.</p>&#13;
&#13;
<p>Based on all of this, we see several advantages to using&#13;
<code>useDeferredValue</code> in React applications:</p>&#13;
<dl>&#13;
<dt>Improved responsiveness</dt>&#13;
<dd>&#13;
<p>In the example, when the user types into&#13;
the search box, the input field updates immediately and the results are&#13;
deferred. If the user quickly types five characters in a row, the input&#13;
field updates immediately five times, and the <code>searchResults</code> are only&#13;
rendered once, after the user stops typing. For characters 1–4, the&#13;
rendering of <code>SearchResults</code> is interrupted by the new values.</p>&#13;
</dd>&#13;
<dt>Declarative prioritization</dt>&#13;
<dd>&#13;
<p><code>useDeferredValue</code> provides a simple and&#13;
declarative<a data-primary="declarative programming" data-secondary="prioritizing updates" data-type="indexterm" id="id939"/><a data-primary="prioritizing updates" data-secondary="and declarative programming" data-secondary-sortas="declarative programming" data-type="indexterm" id="id940"/> way to manage the prioritization of updates in your&#13;
application. By encapsulating the logic for deferring updates within the&#13;
hook, you can keep your component code clean and focused on the&#13;
essential aspects of your app.</p>&#13;
</dd>&#13;
<dt>Better resource utilization</dt>&#13;
<dd>&#13;
<p>By deferring less critical updates,&#13;
<code>useDeferredValue</code> allows your application to make better use of&#13;
available resources. This can help reduce the likelihood of performance&#13;
bottlenecks and improve the overall performance of your application.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When to Use useDeferredValue" data-type="sect2"><div class="sect2" id="id113">&#13;
<h2>When to Use useDeferredValue</h2>&#13;
&#13;
<p><code>useDeferredValue</code> is most useful in situations where your application&#13;
needs to prioritize certain updates over others. Some common scenarios&#13;
where you might consider using <code>useDeferredValue</code> include:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Searching or filtering large data sets</p>&#13;
</li>&#13;
<li>&#13;
<p>Rendering complex visualizations or animations</p>&#13;
</li>&#13;
<li>&#13;
<p>Updating data from a server in the background</p>&#13;
</li>&#13;
<li>&#13;
<p>Handling computationally expensive operations that could impact user&#13;
&#13;
<span class="keep-together">interactions</span></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s take a look at an example where <code>useDeferredValue</code> can be&#13;
particularly useful. Imagine we have a large list of items that we want&#13;
to filter based on user input. Filtering a large list can be&#13;
computationally expensive, so using <code>useDeferredValue</code> can help keep the&#13;
application responsive:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">memo</code><code class="p">,</code><code class="w"> </code><code class="nx">useState</code><code class="p">,</code><code class="w"> </code><code class="nx">useMemo</code><code class="p">,</code><code class="w"> </code><code class="nx">useDeferredValue</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">filter</code><code class="p">,</code><code class="w"> </code><code class="nx">setFilter</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">deferredFilter</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useDeferredValue</code><code class="p">(</code><code class="nx">filter</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">items</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useMemo</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">generateLargeListOfItems</code><code class="p">(),</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">filteredItems</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useMemo</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">items</code><code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">item</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">item</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="nx">deferredFilter</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[</code><code class="nx">items</code><code class="p">,</code><code class="w"> </code><code class="nx">deferredFilter</code><code class="p">]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">input</code>&#13;
        <code class="na">type</code><code class="o">=</code><code class="s">"text"</code>&#13;
        <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">filter</code><code class="p">}</code>&#13;
        <code class="na">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">event</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setFilter</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code>&#13;
      <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ItemList</code> <code class="na">items</code><code class="o">=</code><code class="p">{</code><code class="nx">filteredItems</code><code class="p">}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ItemList</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">memo</code><code class="p">(({</code><code class="w"> </code><code class="nx">items</code><code class="w"> </code><code class="p">})</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// Render the list of items</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">generateLargeListOfItems</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// Generate a large list of items for the example</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we use <code>useDeferredValue</code> to defer the rendering of the&#13;
filtered list. As the user types in the filter input, the deferred value&#13;
updates less frequently, allowing the application to prioritize the user&#13;
input and remain responsive.</p>&#13;
&#13;
<p>The <code>useMemo</code> hooks<a data-primary="useMemo hook" data-type="indexterm" id="id941"/> are used to memoize the items and <code>filteredItems</code>&#13;
arrays<a data-primary="arrays, memoization of" data-type="indexterm" id="id942"/><a data-primary="memoization" data-secondary="arrays" data-type="indexterm" id="id943"/>, preventing unnecessary rerendering and recalculations. This&#13;
further improves the performance of the application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When Not to Use useDeferredValue" data-type="sect2"><div class="sect2" id="id114">&#13;
<h2>When Not to Use useDeferredValue</h2>&#13;
&#13;
<p>While <code>useDeferredValue</code> can be beneficial in certain scenarios, it’s&#13;
important to recognize the trade-offs. Namely, by deferring updates,&#13;
there’s a possibility that the data displayed to the user might be&#13;
slightly out-of-date. While this is usually acceptable for less critical&#13;
updates, it’s important to consider the implications of displaying stale&#13;
data to users.</p>&#13;
&#13;
<p>A good question to ask yourself when deciding whether to use&#13;
<code>useDeferredValue</code> or not is, “Is this update user input?”</p>&#13;
&#13;
<p>React is called React for a reason: it enables our web applications to&#13;
react to things. Anything that causes a user to expect a reaction ought&#13;
not be deferred. Everything else should be.</p>&#13;
&#13;
<p>While the usage of <code>useDeferredValue</code> can greatly enhance your&#13;
application’s responsiveness under load, it should not be seen as a&#13;
magic bullet. Always remember that the best way to improve performance&#13;
is to write efficient code and avoid unnecessary computations<a data-startref="ix_concurrentrenderingandupdatinguseDeferredValuehook.07.859.35" data-type="indexterm" id="id944"/><a data-startref="ix_useDeferredValuehook.07.859.35" data-type="indexterm" id="id945"/><a data-startref="ix_deferringupdates.07.859.35" data-type="indexterm" id="id946"/><a data-startref="ix_updatesdeferring.07.859.35" data-type="indexterm" id="id947"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problems with Concurrent Rendering" data-type="sect1"><div class="sect1" id="id182">&#13;
<h1>Problems with Concurrent Rendering</h1>&#13;
&#13;
<p>Concurrent rendering<a data-primary="concurrent rendering and updating" data-secondary="problems with" data-type="indexterm" id="ix_concurrentrenderingandupdatingproblemswith.07.1122.21"/>, while allowing for performant and responsive user&#13;
interactions, presents new problems for developers to consider. The main&#13;
problem is that it’s difficult to reason about the order in which&#13;
updates will be processed, which can lead to unexpected behavior and&#13;
bugs.</p>&#13;
&#13;
<p>One such bug is called <em>tearing</em>, where the UI becomes inconsistent&#13;
due to updates being processed out of order. This can happen when a&#13;
component depends on some value that is updated while it’s still&#13;
rendering, causing applications to be rendered with inconsistent data.&#13;
Let’s dive into this a little bit.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tearing" data-type="sect2"><div class="sect2" id="id115">&#13;
<h2>Tearing</h2>&#13;
&#13;
<p>Tearing<a data-primary="tearing problem in concurrent rendering" data-type="indexterm" id="ix_tearingprobleminconcurrentrendering.07.1136.8"/><a data-primary="debugging" data-secondary="tearing problem in concurrent rendering" data-type="indexterm" id="ix_debuggingtearingprobleminconcurrentrendering.07.1136.8"/> is a bug that occurs when a component depends on some state that&#13;
is updated while the application is still rendering. To understand this,&#13;
let’s contrast synchronous rendering with concurrent rendering.</p>&#13;
&#13;
<p>In a synchronous<a data-primary="synchronous rendering" data-secondary="versus concurrent rendering" data-type="indexterm" id="ix_synchronousrenderingversusconcurrentrendering.07.1140.17"/> world, React would walk down a tree of components and&#13;
render them one by one, from top to bottom. This ensures that the state&#13;
of the application is consistent throughout the rendering process, as&#13;
each component is rendered with the latest state.</p>&#13;
&#13;
<p>Consider this example:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="p">,</code><code class="w"> </code><code class="nx">useSyncExternalStore</code><code class="p">,</code><code class="w"> </code><code class="nx">useTransition</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="c1">// External state</code><code class="w"/>&#13;
<code class="kd">let</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="nx">setInterval</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">count</code><code class="o">++</code><code class="p">,</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="nx">setName</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">isPending</code><code class="p">,</code><code class="w"> </code><code class="nx">startTransition</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useTransition</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">updateName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">newVal</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">startTransition</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">setName</code><code class="p">(</code><code class="nx">newVal</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">input</code> <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="na">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">updateName</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">isPending</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="nx">Loading</code><code class="p">...&lt;/</code><code class="nt">div</code><code class="p">&gt;}</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ExpensiveComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">now</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">performance</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nx">performance</code><code class="p">.</code><code class="nx">now</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">now</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">100</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Do nothing, just wait.</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;&gt;</code><code class="nx">Expensive</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="p">{</code><code class="nx">count</code><code class="p">}&lt;/&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>At the very top of our app, we have <code>count</code>: a variable that we set&#13;
globally and keep updating via <code>setInterval</code> outside of the React render&#13;
cycle so that we can simulate a tearing bug by having it update while&#13;
the application is rendering. Since rendering is concurrent and&#13;
interruptible, it’s possible for the <code>ExpensiveComponent</code> to be rendered&#13;
with different values for <code>count</code>, resulting in inconsistent data being&#13;
displayed to the user, or tearing.</p>&#13;
&#13;
<p>We expect to see inconsistent values for <code>count</code> rendered inside&#13;
<code>ExpensiveComponent</code> as React “stops” rendering on user input to&#13;
prioritize a more urgent update, like updating the text input field,&#13;
thereby leaving a stale value of <code>count</code> in the <code>ExpensiveComponent</code>, but&#13;
only sometimes.</p>&#13;
&#13;
<p>Our example renders a text input field and a list of five&#13;
<code>ExpensiveComponent</code>s. These components are not memoized intentionally&#13;
to illustrate a point here, as they cause performance problems and we&#13;
need these performance problems, to identify tearing for the purposes of&#13;
understanding it. In the real world, you’ll want to wrap&#13;
<code>ExpensiveComponent</code> in <code>React.memo</code>. Here, we’re intentionally avoiding&#13;
this to demonstrate tearing—which you’ll want to avoid in your&#13;
application.</p>&#13;
&#13;
<p><code>ExpensiveComponent</code> takes a long time to render,&#13;
simulating a computationally expensive operation. The&#13;
<code>ExpensiveComponent</code> also displays the current value of the <code>count</code>&#13;
variable, which is incremented every millisecond and read from an&#13;
external store, in this case the global namespace.</p>&#13;
&#13;
<p>If we run this example, we’ll see that for the five instances of&#13;
<code>ExpensiveComponent</code> that we render, after typing a few keystrokes in&#13;
the <code>input</code>, the <code>ExpensiveComponent</code>s will render with different values for <code>count</code>.</p>&#13;
&#13;
<p>This is because the <code>ExpensiveComponent</code> is rendered five times, and&#13;
each time it’s rendered, the value of <code>count</code> is different. Since React&#13;
is rendering the components concurrently, it’s possible for the&#13;
<code>ExpensiveComponent</code> to be rendered with different values for <code>count</code>,&#13;
resulting in inconsistent data displayed to the user.</p>&#13;
&#13;
<p>This is called tearing, and it’s a bug that can occur when a component&#13;
depends on some state that is updated while the application is still&#13;
rendering. In this case, the <code>ExpensiveComponent</code> depends on the <code>count</code>&#13;
variable, which is updated while the component is still rendering,&#13;
causing the application to be rendered with inconsistent data. With tearing, we see the following output for the five instances of &#13;
<span class="keep-together"><code>ExpensiveComponent</code>:</span></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>Expensive count is 568</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Expensive count is 568</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Expensive count is 569</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Expensive count is 569</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Expensive count is 570</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This makes sense because earlier instances of the component are&#13;
rendered, the updated <code>count</code> value is flushed/committed to the DOM, and&#13;
lower instances continue to be rendered and yielded (flushed, updated)&#13;
with newer values of <code>count</code>.</p>&#13;
&#13;
<p>This isn’t a huge deal because React will eventually render the&#13;
consistent state<a data-startref="ix_synchronousrenderingversusconcurrentrendering.07.1140.17" data-type="indexterm" id="id948"/>. The bigger issue is when you have something like:</p>&#13;
<pre>&lt;UserDetails id={user.id} /&gt;</pre>&#13;
&#13;
<p>With this code, if the user is deleted from the global store between&#13;
renders, this will throw a sudden error that can surprise a user.&#13;
This is why tearing is a problem.</p>&#13;
&#13;
<p>To solve this problem of tearing, React exposes a hook called&#13;
<code>useSyncExternalStore</code>. Let’s dive into this hook.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="useSyncExternalStore" data-type="sect3"><div class="sect3" id="id116">&#13;
<h3>useSyncExternalStore</h3>&#13;
&#13;
<p><code>useSyncExternalStore</code> is a React Hook<a data-primary="useSyncExternalStore hook" data-type="indexterm" id="ix_useSyncExternalStorehook.07.1274.39"/><a data-primary="synchronous rendering" data-secondary="useSyncExternalStore hook" data-type="indexterm" id="ix_synchronousrenderinguseSyncExternalStorehook.07.1274.39"/> that allows you to synchronize&#13;
external state with the internal state of your application. It’s&#13;
particularly useful when dealing with computationally expensive&#13;
operations that might cause tearing if not handled properly. The&#13;
“sync” in <code>useSyncExternalStore</code> has a double meaning. It’s&#13;
“synchronize,” but it’s also “synchronous”: it forces a synchronous&#13;
update when the store changes.</p>&#13;
&#13;
<p>The <code>useSyncExternalStore</code> hook has the following signature:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">useSyncExternalStore</code><code class="p">(</code><code class="nx">store</code><code class="p">.</code><code class="nx">subscribe</code><code class="p">,</code> <code class="nx">store</code><code class="p">.</code><code class="nx">getSnapshot</code><code class="p">);</code></pre>&#13;
<dl>&#13;
<dt><code>store.subscribe</code></dt>&#13;
<dd>&#13;
<p>A function<a data-primary="store.subscribe function" data-type="indexterm" id="id949"/> that receives a callback function as&#13;
its first and only argument. Inside this function, you can subscribe to&#13;
changes in the external store and call the callback function whenever&#13;
the store changes. The callback can be considered a call to prompt React&#13;
to rerender the component with the new value. The expected return of&#13;
this function is a cleanup function that unsubscribes from the store.</p>&#13;
&#13;
<p class="less_space pagebreak-before">A typical <code>subscribe</code> function looks like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">store</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">rerender</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">newData</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">getNewData</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">rerender</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// unsubscribe somehow</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>A simple use case for this would be subscribing to browser events, such&#13;
as <code>resize</code> or <code>scroll</code> events, and updating the component when these&#13;
events occur, like this:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">store</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">rerenderImmediately</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nb">window</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"resize"</code><code class="p">,</code><code class="w"> </code><code class="nx">rerenderImmediately</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nb">window</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s2">"resize"</code><code class="p">,</code><code class="w"> </code><code class="nx">rerenderImmediately</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, our React components would rerender whenever the browser window is&#13;
resized. However, how does it get the new value? That’s where the second&#13;
argument to <code>useSyncExternalStore</code> comes in.</p>&#13;
</dd>&#13;
<dt><code>store.getSnapshot</code></dt>&#13;
<dd>&#13;
<p>A function<a data-primary="store.getSnapshot function" data-type="indexterm" id="id950"/> that returns the current value of&#13;
the external store. This function is called whenever the component is&#13;
rendered, and the returned value is used to update the component’s&#13;
internal state. This function is called synchronously, so it should not&#13;
perform any asynchronous operations or have any side effects. Moreover,&#13;
this function ensures the state at render time is consistent across&#13;
multiple instances of the component.</p>&#13;
&#13;
<p>To follow our window resize example, this is how we would get the&#13;
current window size:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">store</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">immediatelyRerenderSynchronously</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nb">window</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"resize"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">immediatelyRerenderSynchronously</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nb">window</code><code class="p">.</code><code class="nx">removeEventListener</code><code class="p">(</code><code class="s2">"resize"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">immediatelyRerenderSynchronously</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">getSnapshot</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">width</code><code class="o">:</code><code class="w"> </code><code class="nb">window</code><code class="p">.</code><code class="nx">innerWidth</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">height</code><code class="o">:</code><code class="w"> </code><code class="nb">window</code><code class="p">.</code><code class="nx">innerHeight</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">};</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>The object with <code>{ width, height }</code> is the snapshot of the current state&#13;
of the window, and it’s what <code>useSyncExternalStore</code> will return. We can&#13;
then use this object in our component with confidence that its state&#13;
will always be consistent across concurrent renders.</p>&#13;
&#13;
<p>How can we have this confidence? It’s because the&#13;
<code>immediatelyRerenderSynchronously</code> function<a data-primary="immediatelyRerenderSynchronously function" data-type="indexterm" id="id951"/> forces a synchronous&#13;
rerender and does not allow React to defer it. This is the key to&#13;
solving tearing.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Now, let’s take a look at how we can use <code>useSyncExternalStore</code> to solve&#13;
the tearing problem in our previous example. If we recall, we saw a list&#13;
of <code>ExpensiveComponent</code>s that rendered with different values for <code>count</code>&#13;
due to tearing. Let’s see how we can fix this using&#13;
<code>useSyncExternalStore</code>.</p>&#13;
&#13;
<p>For starters, we don’t want to subscribe to the store and have React&#13;
rerender when updates happen; but instead we want consistent state when&#13;
rerenders happen due to user input. So our <code>subscribe</code> function will be&#13;
empty, but to get consistent state, we’ll use the <code>getSnapshot</code> function&#13;
to get the current value of <code>count</code> and return it:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">const</code><code class="w"> </code><code class="nx">store</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">subscribe</code><code class="p">()</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">getSnapshot</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">count</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>This is what our previous example will look like with&#13;
<code>useSyncExternalStore</code>:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="p">,</code><code class="w"> </code><code class="nx">useSyncExternalStore</code><code class="p">,</code><code class="w"> </code><code class="nx">useTransition</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">let</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="nx">setInterval</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">count</code><code class="o">++</code><code class="p">,</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="nx">setName</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[,</code><code class="w"> </code><code class="nx">startTransition</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useTransition</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">updateName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">newVal</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">startTransition</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">setName</code><code class="p">(</code><code class="nx">newVal</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">input</code> <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="na">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">updateName</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ExpensiveComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// Instead of reading count globally,</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// we'll use the hook to ensure consistent state</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">consistentCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useSyncExternalStore</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{},</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">count</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">now</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">performance</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nx">performance</code><code class="p">.</code><code class="nx">now</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">now</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">100</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Do nothing</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;&gt;</code><code class="nx">Expensive</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="p">{</code><code class="nx">consistentCount</code><code class="p">}&lt;/&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, if we run this example, we will see that the <code>ExpensiveComponent</code>s&#13;
render with &#13;
<span class="keep-together">the same</span> value for <code>count</code>, preventing tearing from&#13;
occurring. This is because the &#13;
<span class="keep-together"><code>useSyncExternalStore</code></span> hook ensures that&#13;
the state at render time is consistent across multiple instances of the&#13;
component.</p>&#13;
&#13;
<p>We don’t use a <code>subscribe</code> function because its purpose is to tell React&#13;
when to rerender with the latest state, but in our case we just want&#13;
state to be consistent across renders. We use the <code>getSnapshot</code> function<a data-primary="store.getSnapshot function" data-type="indexterm" id="id952"/>&#13;
to get the current value of <code>count</code> and return it, ensuring that the&#13;
state at render time is consistent across multiple instances of the&#13;
component.</p>&#13;
&#13;
<p>This is how we can use <code>useSyncExternalStore</code> to solve the tearing&#13;
problem in our previous example, ensuring that&#13;
the state at render time is consistent across multiple instances of the&#13;
component.</p>&#13;
&#13;
<p>OK, this ensures that when the text input changes and&#13;
<code>ExpensiveComponent</code> rerenders, it will have the same value of <code>count</code>&#13;
as the other instances of <code>ExpensiveComponent</code>, preventing tearing—but&#13;
what if we wanted to update <code>count</code> inside <code>ExpensiveComponent</code> at the&#13;
same interval that we update <code>count</code> outside of <code>ExpensiveComponent</code>?</p>&#13;
&#13;
<p>We just create a store for this that follows the same update rules:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="p">,</code><code class="w"> </code><code class="nx">useSyncExternalStore</code><code class="p">,</code><code class="w"> </code><code class="nx">useTransition</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">let</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="nx">setInterval</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">count</code><code class="o">++</code><code class="p">,</code><code class="w"> </code><code class="mf">1</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">store</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">subscribe</code><code class="p">(</code><code class="nx">forceSyncRerender</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Whenever count changes,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">forceSyncRerender</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">getSnapshot</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="k">return</code><code class="w"> </code><code class="nx">count</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">name</code><code class="p">,</code><code class="w"> </code><code class="nx">setName</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="s2">""</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[,</code><code class="w"> </code><code class="nx">startTransition</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useTransition</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">updateName</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">(</code><code class="nx">newVal</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">startTransition</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">setName</code><code class="p">(</code><code class="nx">newVal</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">});</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">input</code> <code class="na">value</code><code class="o">=</code><code class="p">{</code><code class="nx">name</code><code class="p">}</code> <code class="na">onChange</code><code class="o">=</code><code class="p">{(</code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">updateName</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">value</code><code class="p">)}</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">ExpensiveComponent</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ExpensiveComponent</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// Instead of reading count globally,</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// we'll use the hook to ensure consistent state</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">consistentCount</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useSyncExternalStore</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">store</code><code class="p">.</code><code class="nx">subscribe</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">store</code><code class="p">.</code><code class="nx">getSnapshot</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">now</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">performance</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nx">performance</code><code class="p">.</code><code class="nx">now</code><code class="p">()</code><code class="w"> </code><code class="o">-</code><code class="w"> </code><code class="nx">now</code><code class="w"> </code><code class="o">&lt;</code><code class="w"> </code><code class="mf">100</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Do nothing</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">&lt;&gt;</code><code class="nx">Expensive</code><code class="w"> </code><code class="nx">count</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="p">{</code><code class="nx">consistentCount</code><code class="p">}&lt;/&gt;;</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/></pre>&#13;
&#13;
<p>Now, whenever <code>count</code> changes, <code>ExpensiveComponent</code> will rerender with&#13;
the new value of <code>count</code>, and we’ll see the same value for <code>count</code> across&#13;
all instances of &#13;
<span class="keep-together"><code>ExpensiveComponent</code>.</span> The change detection logic itself&#13;
can be as simple or as complex as you want it to be, but the key is that&#13;
we understand the mechanisms of how <code>useSyncExternalStore</code> does its main&#13;
things, which are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Ensuring consistent state across concurrent renders</p>&#13;
</li>&#13;
<li>&#13;
<p>Forcing a synchronous rerender when the store changes</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Now that we understand how <code>useSyncExternalStore</code> works and solves the&#13;
tearing problem, we have a solid grasp not only of concurrent rendering&#13;
in React but also of how to solve some of the problems that come with it.&#13;
This is a great place to be in as a React developer<a data-startref="ix_concurrentrenderingandupdating.07.21.35" data-type="indexterm" id="id953"/><a data-startref="ix_concurrentrenderingandupdatingproblemswith.07.1122.21" data-type="indexterm" id="id954"/><a data-startref="ix_tearingprobleminconcurrentrendering.07.1136.8" data-type="indexterm" id="id955"/><a data-startref="ix_debuggingtearingprobleminconcurrentrendering.07.1136.8" data-type="indexterm" id="id956"/><a data-startref="ix_useSyncExternalStorehook.07.1274.39" data-type="indexterm" id="id957"/><a data-startref="ix_synchronousrenderinguseSyncExternalStorehook.07.1274.39" data-type="indexterm" id="id958"/>.</p>&#13;
&#13;
<p>This was quite a deep dive, but we’re nearly done. Let’s review.</p>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chapter Review" data-type="sect1"><div class="sect1" id="id248">&#13;
<h1>Chapter Review</h1>&#13;
&#13;
<p>This comprehensive conversation focused on the deep exploration of&#13;
concurrent React, touching on multiple aspects, including the Fiber&#13;
Reconciler, scheduling, deferring updates, render lanes, and new hooks,&#13;
such as <code>useTransition</code> and &#13;
<span class="keep-together"><code>useDeferredValue</code>.</span></p>&#13;
&#13;
<p class="pagebreak-before">We began by discussing the Fiber reconciler, the heart of React’s&#13;
concurrent rendering engine. It’s the algorithm behind the framework’s&#13;
ability to break work into smaller chunks and manage the execution&#13;
priority, allowing React to be “interruptible” and support concurrent&#13;
rendering. This contributes significantly to the ability of React to&#13;
handle complex, high-performance applications smoothly, ensuring user&#13;
interactions remain responsive even during heavy computation.</p>&#13;
&#13;
<p>Then we moved on to the concept of scheduling and deferring updates,&#13;
which essentially allows React to prioritize certain state updates over&#13;
others. React can defer lower-priority updates in favor of higher-priority ones,&#13;
thus maintaining a smooth user experience even under heavy load. An&#13;
example illustrated a chat application where incoming message&#13;
updates were intelligently scheduled and rendered without blocking the&#13;
user interface.</p>&#13;
&#13;
<p>The discussion then moved to render lanes, a central concept in&#13;
React’s concurrent features. Render lanes are a mechanism that React&#13;
uses to assign priority to updates and effectively manage their execution. It’s the secret behind how React decides which updates&#13;
are urgent and need to be processed immediately and which ones can be&#13;
deferred until later. The detailed explanation mentioned how these&#13;
render lanes use bitmasking to efficiently handle multiple priorities.</p>&#13;
&#13;
<p>We then delved into the new hooks introduced for concurrent operations&#13;
in React, <code>useTransition</code> and <code>useDeferredValue</code>. These hooks are&#13;
designed to handle transitions and provide smoother user experiences,&#13;
particularly for operations that take a considerable amount of time.</p>&#13;
&#13;
<p>The <code>useTransition</code> hook was first discussed, which allows React to&#13;
transition between states in a way that ensures a responsive user&#13;
interface even if the new state takes a while to prepare. In other&#13;
words, it allows for delaying an update to the next render cycle if the&#13;
component is currently rendering.</p>&#13;
&#13;
<p>We also discussed the <code>useDeferredValue</code> hook, which defers the update&#13;
of less critical parts of a component, thus preventing janky user&#13;
experience. It essentially allows React to “hold on” to the previous&#13;
value for a little longer if the new value is taking too much time.</p>&#13;
&#13;
<p>Finally, we dove into issues with concurrency, including tearing, and&#13;
explored how <code>useSyncExternalStore</code> can help keep state consistent&#13;
across multiple concurrent renders.</p>&#13;
&#13;
<p>Throughout the conversation, the recurring theme was understanding the&#13;
“what” and “why” behind React’s strategies for managing complex,&#13;
dynamic applications with heavy computation, and how developers can&#13;
utilize these strategies to deliver a smooth, responsive user&#13;
experience.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Review Questions" data-type="sect1"><div class="sect1" id="id249">&#13;
<h1>Review Questions</h1>&#13;
&#13;
<p>Let’s ask ourselves a few questions to test our understanding of the concepts in this chapter:</p>&#13;
<ol>&#13;
<li>&#13;
<p>What is the Fiber reconciler in React, and how does it contribute to&#13;
the handling of complex, high-performance applications?</p>&#13;
</li>&#13;
<li>&#13;
<p>Explain the concept of scheduling and deferring updates in React. How&#13;
does it help in maintaining a smooth user experience even under heavy&#13;
load?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are render lanes in React, and how do they manage the execution of&#13;
updates? Can you describe how render lanes use bitmasking to handle&#13;
multiple priorities?</p>&#13;
</li>&#13;
<li>&#13;
<p>What is the purpose of the <code>useTransition</code> and <code>useDeferredValue</code>&#13;
hooks in React? Describe a situation where each hook would be&#13;
beneficial.</p>&#13;
</li>&#13;
<li>&#13;
<p>When might it be inappropriate to use <code>useDeferredValue</code>? What are&#13;
some of the trade-offs involved with using these hooks?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Up Next" data-type="sect1"><div class="sect1" id="id250">&#13;
<h1>Up Next</h1>&#13;
&#13;
<p>Now that you have a deep understanding of the concurrent features of&#13;
React and its inner workings, you are well equipped to harness its full&#13;
potential in building high-performance applications. In <a data-type="xref" href="ch08.html#ch08">Chapter 8</a>, we will explore various popular frameworks built on top of&#13;
React, such as Next.js and Remix, which further streamline the&#13;
development process by providing best practices, conventions, and&#13;
additional features.</p>&#13;
&#13;
<p>These frameworks are designed to help you build complex applications&#13;
with ease, taking care of many common concerns, such as server&#13;
rendering, routing, and code splitting. By leveraging the power of these&#13;
frameworks, you can focus on building your application’s features and&#13;
functionality while ensuring optimal performance and user experience.</p>&#13;
&#13;
<p>Stay tuned for an in-depth exploration of these powerful frameworks, and&#13;
learn how to build scalable, performant, and feature-rich applications&#13;
using React and its &#13;
<span class="keep-together">ecosystem.</span></p>&#13;
</div></section>&#13;
</div></section></body></html>