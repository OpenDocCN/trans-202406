<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Multi-Container Pods" class="praise"><div class="dedication" id="multi_container_pods">
<h1 class="calibre14"><span class="keep-together">Chapter 8. </span>Multi-Container Pods</h1>


<p class="author1"><a data-type="xref" href="ch05.xhtml#pods_namespaces" class="calibre10">Chapter 5</a> explained how to manage single-container Pods. That’s the norm, as you’ll want to run a microservice inside of a single Pod to reinforce separation of concerns and increase cohesion. Technically, a Pod allows you to configure and run multiple containers.</p>

<p class="author1">In this chapter, we’ll discuss the need for multi-container Pods, their relevant use cases, and the design patterns that have emerged in the Kubernetes community. The exam outline specifically mentions prominent design patterns: the init container, the sidecar container, and others. We’ll get a good grasp of their application with the help of representative examples.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id476">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objective:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Understand multi-container Pod design patterns</p>
</li>
</ul>
</div></aside>






<section data-type="sect1" data-pdf-bookmark="Working with Multiple Containers in a Pod" class="praise"><div class="dedication" id="id226">
<h1 class="calibre17">Working with Multiple Containers in a Pod</h1>

<p class="author1">Especially for Kubernetes beginners, how to appropriately design a Pod isn’t necessarily apparent. If you read the Kubernetes user documentation and tutorials on the internet, you’ll quickly discover that you can create a Pod that runs multiple containers at the same time. The question then arises: “Should I deploy my microservices stack to a single Pod with multiple containers, or should I create multiple Pods, each running a single microservice?” The short answer is to operate a single microservice per Pod. This modus operandi promotes a decentralized, decoupled, and distributed architecture. Furthermore, it helps with rolling out new versions of a microservice without necessarily interrupting other parts of the system.</p>

<p class="author1">So, what’s the point of running multiple containers in a Pod? There are two common use cases. Sometimes, you’ll want to initialize your Pod by executing setup scripts, commands, or any other kind of preconfiguration procedure before the application container should start. This logic runs in an init container. Other times, you’ll want to provide helper functionality that runs alongside the application container to avoid the need to bake the logic into application code. For example, you may want to massage the log output produced by the application. Containers running helper logic are called <em class="calibre3">sidecars</em>.</p>








<section data-type="sect2" data-pdf-bookmark="Init Containers" class="praise"><div class="dedication" id="id227">
<h2 class="calibre33">Init Containers</h2>

<p class="author1"><em class="calibre3">Init containers</em> provide initialization logic concerns to be run before the main application starts. To draw an analogy, let’s look at a similar concept in programming languages. Many programming languages, especially object-oriented ones like Java or C++, come with a constructor or a static method block. Those language constructs initialize fields, validate data, and set the stage before a class can be created. Not all classes need a constructor, but they are equipped with the capability.</p>

<p class="author1">In Kubernetes, this functionality can be achieved with the help of init containers. Init containers are always started before the main application containers, which means they have their own life cycle. To split up the initialization logic, you can even distribute the work into multiple init containers that are run in the order of definition in the manifest. Of course, initialization logic can fail. If an init container produces an error, the whole Pod is restarted, causing all init containers to run again in sequential order. Thus, to prevent any side effects, making init container logic idempotent is a good practice. <a data-type="xref" href="#init_containers" class="calibre10">Figure 8-1</a> shows a Pod with two init containers and the main application.</p>

<figure class="calibre35"><div id="init_containers" class="figure">
<img src="Images/ckd2_0801.png" alt="ckd2 0801" class="calibre76"/>
<h6 class="calibre32"><span class="keep-together">Figure 8-1. </span>Sequential and atomic life cycle of init containers in a Pod</h6>
</div></figure>

<p class="author1">In the past couple of chapters, we’ve explored how to define a container within a Pod: you simply specify its configuration under <code class="calibre15">spec.containers</code>. For init containers, Kubernetes provides a separate section: <code class="calibre15">spec.initContainers</code>. Init containers are always executed before the main application containers, regardless of the definition order in the manifest.</p>

<p class="author1">The manifest shown in <a data-type="xref" href="#init_container_pod" class="calibre10">Example 8-1</a> defines an init container and a main application container. For the most part, init containers use the same attributes as regular containers. There’s one big difference, however. They cannot define probes, discussed in <a data-type="xref" href="ch14.xhtml#container_probes" class="calibre10">Chapter 14</a>. The init container sets up a configuration file in the directory <em class="calibre3">/usr/shared/app</em>. This directory has been shared through a Volume so that it can be referenced by a Node.js-based application running in the main container.</p>
<div id="init_container_pod" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 8-1. </span>A Pod defining an init container</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">business-app</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">initContainers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">configurer</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">busybox:1.36.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="calibre15">[</code><code class="s">'sh'</code><code class="calibre15">,</code><code class="w"> </code><code class="s">'-c'</code><code class="calibre15">,</code><code class="w"> </code><code class="s">'echo</code><code class="nv"> </code><code class="s">Configuring</code><code class="nv"> </code><code class="s">application...</code><code class="nv"> </code><code class="s">&amp;&amp;</code><code class="nv"> </code><code class="s">\</code><code class="w"></code>
<code class="w">              </code><code class="s">mkdir</code><code class="nv"> </code><code class="s">-p</code><code class="nv"> </code><code class="s">/usr/shared/app</code><code class="nv"> </code><code class="s">&amp;&amp;</code><code class="nv"> </code><code class="s">echo</code><code class="nv"> </code><code class="s">-e</code><code class="nv"> </code><code class="s">"{\"dbConfig\":</code><code class="nv"> </code><code class="s">\</code><code class="w"></code>
<code class="w">              </code><code class="s">{\"host\":\"localhost\",\"port\":5432,\"dbName\":\"customers\"}}"</code><code class="nv"> </code><code class="s">\</code><code class="w"></code>
<code class="w">              </code><code class="s">&gt;</code><code class="nv"> </code><code class="s">/usr/shared/app/config.json'</code><code class="calibre15">]</code><code class="w"></code>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">configdir</code><code class="w"></code>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/usr/shared/app"</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-read-config:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">web</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w"></code>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">configdir</code><code class="w"></code>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="s">"/usr/shared/app"</code><code class="w"></code>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">configdir</code><code class="w"></code>
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="calibre15">{}</code><code class="w"></code></pre></div>

<p class="author1">When starting the Pod, you’ll see that the status column of the <code class="calibre15">get</code> command provides information on init containers as well. The prefix <code class="calibre15">Init:</code> signifies that an init container is in the process of being executed. The status portion after the colon character shows the number of init containers completed versus the overall number of init containers configured:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create -f init.yaml</strong>
pod/business-app created
<strong class="calibre38">$ kubectl get pod business-app</strong>
NAME           READY   STATUS    RESTARTS   AGE
business-app   0/1     Init:0/1  0          2s
<strong class="calibre38">$ kubectl get pod business-app</strong>
NAME           READY   STATUS    RESTARTS   AGE
business-app   1/1     Running   0          8s
</pre>

<p class="author1">Errors can occur during the execution of init containers. If any container fails in the sequential initialization chain, then the whole Pod will fail to start. You can always retrieve the logs of an init container by using the <code class="calibre15">--container</code> command-line option (or <code class="calibre15">-c</code> in its short form), as shown in <a data-type="xref" href="#target_container" class="calibre10">Figure 8-2</a>.</p>

<figure class="calibre35"><div id="target_container" class="figure">
<img src="Images/ckd2_0802.png" alt="ckd2 0802" class="calibre77"/>
<h6 class="calibre32"><span class="keep-together">Figure 8-2. </span>Targeting a specific container</h6>
</div></figure>

<p class="author1">The following command renders the logs of the <code class="calibre15">configurer</code> init container, which equates to the <code class="calibre15">echo</code> command we configured in the YAML manifest:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl logs business-app -c configurer</strong>
Configuring application...
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Sidecar Pattern" class="praise"><div class="dedication" id="id3">
<h2 class="calibre33">The Sidecar Pattern</h2>

<p class="author1">The life cycle of an init container looks like this: it starts up, runs its logic, then terminates once the work has been done. Init containers are not meant to keep running over a longer period of time. But some scenarios call for a different usage pattern. For example, you may want to create a Pod that runs multiple containers continuously alongside one another.</p>
<div data-type="warning" epub:type="warning" class="calibre28"><h1 class="calibre68">Sidecar containers introduced in Kubernetes 1.29</h1>
<p class="author1">Future exams using Kubernetes 1.29 or higher may cover the formalized <a href="https://kubernetes.io/docs/concepts/workloads/pods/sidecar-containers/" class="calibre10">sidecar container</a>. Sidecar containers are secondary containers that will start with the Pod and remain running during the entire life of the Pod.</p>
</div>

<p class="author1">Typically, there are two different categories of containers: the container that runs the application and another container that provides helper functionality to the primary application. In the Kubernetes space, the container providing helper functionality is called a sidecar. The most commonly used capabilities of a sidecar container include file synchronization, logging, and watcher capabilities. The sidecars are not part of the main traffic or API of the primary application. They usually operate asynchronously and are not involved in the public API.</p>

<p class="author1">To illustrate the behavior of a sidecar, consider the following use case. The main application container runs a web server—in this case, NGINX. Once started, the web server produces two standard logfiles. The file <em class="calibre3">/var/log/nginx/access.log</em> captures requests to the web server’s endpoint. The other file, <em class="calibre3">/var/log/nginx/error.log</em>, records failures while processing incoming requests.</p>

<p class="author1">As part of the Pod’s functionality, we want to implement a<a data-type="indexterm" data-primary="monitoring services" id="id477" class="calibre10"></a> monitoring service. The sidecar container polls the file’s <em class="calibre3">error.log</em> periodically and checks if any failures have been discovered. More specifically, the service tries to find failures assigned to the error log level, indicated by <code class="calibre15">[error]</code> in the log file. If an error is found, the monitoring service will react to it. For example, it could send a notification to the system administrators. We want to keep the functionality as simple as possible. The monitoring service will simply render an error message to standard output. The file exchange between the main application container and the sidecar container happens through a Volume, as shown in <a data-type="xref" href="#sidecar_pattern" class="calibre10">Figure 8-3</a>.</p>

<figure class="calibre35"><div id="sidecar_pattern" class="figure">
<img src="Images/ckd2_0803.png" alt="ckd2 0803" class="calibre78"/>
<h6 class="calibre32"><span class="keep-together">Figure 8-3. </span>The sidecar pattern in action</h6>
</div></figure>

<p class="author1">The YAML manifest shown in <a data-type="xref" href="#sidecar_pattern_pod" class="calibre10">Example 8-2</a> sets up the described scenario. The trickiest portion of the code is the lengthy bash command. This command runs an infinite loop. As part of each iteration, we inspect the contents of the file <em class="calibre3">error.log</em>, <em class="calibre3">grep</em> for an error and potentially act on it. The loop executes every 10 seconds.</p>
<div id="sidecar_pattern_pod" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 8-2. </span>An exemplary sidecar pattern implementation</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">webserver</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nginx:1.25.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">logs-vol</code><code class="w"></code>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/var/log/nginx</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">sidecar</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">busybox:1.36.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="calibre15">[</code><code class="s">"sh"</code><code class="calibre15">,</code><code class="s">"-c"</code><code class="calibre15">,</code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">if</code><code class="nv"> </code><code class="s">[</code><code class="nv"> </code><code class="s">\"$(cat</code><code class="nv"> </code><code class="s">/var/log/nginx/error.log</code><code class="nv"> </code><code class="s">\</code>
<code class="w">              </code><code class="s">|</code><code class="nv"> </code><code class="s">grep</code><code class="nv"> </code><code class="s">'error')\"</code><code class="nv"> </code><code class="s">!=</code><code class="nv"> </code><code class="s">\"\"</code><code class="nv"> </code><code class="s">];</code><code class="nv"> </code><code class="s">then</code><code class="nv"> </code><code class="s">echo</code><code class="nv"> </code><code class="s">'Error</code><code class="nv"> </code><code class="s">discovered!';</code><code class="nv"> </code><code class="s">fi;</code><code class="nv"> </code><code class="s">\</code>
<code class="w">              </code><code class="s">sleep</code><code class="nv"> </code><code class="s">10;</code><code class="nv"> </code><code class="s">done"</code><code class="calibre15">]</code><code class="w"></code>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">logs-vol</code><code class="w"></code>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/var/log/nginx</code><code class="w"></code>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">logs-vol</code><code class="w"></code>
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="calibre15">{}</code><code class="w"></code></pre></div>

<p class="author1">When starting up the Pod, you’ll notice that the overall number of containers will show 2. After all containers can be started, the Pod signals a <code class="calibre15">Running</code> status:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create -f sidecar.yaml</strong>
pod/webserver created
<strong class="calibre38">$ kubectl get pods webserver</strong>
NAME        READY   STATUS              RESTARTS   AGE
webserver   0/2     ContainerCreating   0          4s
<strong class="calibre38">$ kubectl get pods webserver</strong>
NAME        READY   STATUS    RESTARTS   AGE
webserver   2/2     Running   0          5s
</pre>

<p class="author1">You will find that <em class="calibre3">error.log</em> does not contain any failure to begin with. It starts out as an empty file. With the following commands, you’ll provoke an error on purpose. After waiting for at least 10 seconds, you’ll find the expected message on the terminal, which you can query for with the <code class="calibre15">logs</code> command:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl logs webserver -c sidecar
$ kubectl exec webserver -it -c sidecar -- /bin/sh</strong>
/ # wget -O- localhost?unknown
Connecting to localhost (127.0.0.1:80)
wget: server returned error: HTTP/1.1 404 Not Found
/ # cat /var/log/nginx/error.log
2020/07/18 17:26:46 [error] 29#29: *2 open() "/usr/share/nginx/html/unknown" \
failed (2: No such file or directory), client: 127.0.0.1, server: localhost, \
request: "GET /unknown HTTP/1.1", host: "localhost"
/ # exit
<strong class="calibre38">$ kubectl logs webserver -c sidecar</strong>
Error discovered!
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Adapter Pattern" class="praise"><div class="dedication" id="id228">
<h2 class="calibre33">The Adapter Pattern</h2>

<p class="author1">As application developers, we want to focus on implementing business logic. For example, as part of a two-week sprint, we’re tasked with adding a shopping cart 
<span class="keep-together">feature.</span> In addition to the functional requirements, we also have to think about operational aspects such as exposing administrative endpoints or crafting meaningful and properly formatted log output. It’s easy to fall into the habit of rolling all aspects into the application code, which makes it more complex and harder to maintain. 
<span class="keep-together">Cross-cutting</span> concerns in particular need to be replicated across multiple applications and are often copied and pasted from one code base to another.</p>

<p class="author1">In Kubernetes, we can avoid bundling cross-cutting concerns into the application code by running them in another container apart from the main application container. The adapter pattern transforms the output produced by the application to make it consumable in the format needed by another part of the system. <a data-type="xref" href="#adapter_pattern" class="calibre10">Figure 8-4</a> illustrates a concrete example of the adapter pattern.</p>

<figure class="calibre35"><div id="adapter_pattern" class="figure">
<img src="Images/ckd2_0804.png" alt="ckd2 0804" class="calibre79"/>
<h6 class="calibre32"><span class="keep-together">Figure 8-4. </span>The adapter pattern in action</h6>
</div></figure>

<p class="author1">The business application running the main container produces timestamped information—in this case, the available disk space—and writes it to the file <em class="calibre3">diskspace.txt</em>. As part of the architecture, we want to consume the file from a third-party monitoring application. The problem is that the external application requires the information to exclude the timestamp. Of course, we could change the logging format to avoid writing the timestamp, but what if we actually want to know when the log entry has been written? This is where the adapter pattern can help. A sidecar container executes transformation logic that turns the log entries into the format needed by the external system without having to change application logic.</p>

<p class="author1">The YAML manifest in <a data-type="xref" href="#adapter_pattern_pod" class="calibre10">Example 8-3</a> illustrates what this implementation of the adapter pattern could look like. The <code class="calibre15">app</code> container produces a new log entry every five seconds. The <code class="calibre15">transformer</code> container consumes the contents of the file, removes the timestamp, and writes it to a new file. Both containers have access to the same mount path through a Volume.</p>
<div id="adapter_pattern_pod" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 8-3. </span>An exemplary adapter pattern implementation</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">adapter</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">args</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">/bin/sh</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">-c</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="s">'while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">echo</code><code class="nv"> </code><code class="s">"$(date)</code><code class="nv"> </code><code class="s">|</code><code class="nv"> </code><code class="s">$(du</code><code class="nv"> </code><code class="s">-sh</code><code class="nv"> </code><code class="s">~)"</code><code class="nv"> </code><code class="s">&gt;&gt;</code><code class="nv"> </code><code class="s">/var/logs/diskspace.txt;</code><code class="nv"> </code><code class="s">\</code><code class="w"></code>
<code class="w">       </code><code class="s">sleep</code><code class="nv"> </code><code class="s">5;</code><code class="nv"> </code><code class="s">done;'</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">busybox:1.36.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">app</code><code class="w"></code>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">config-volume</code><code class="w"></code>
<code class="w">        </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/var/logs</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">busybox:1.36.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">transformer</code><code class="w"></code>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">/bin/sh</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">-c</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="s">'sleep</code><code class="nv"> </code><code class="s">20;</code><code class="nv"> </code><code class="s">while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">while</code><code class="nv"> </code><code class="s">read</code><code class="nv"> </code><code class="s">LINE;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">echo</code><code class="nv"> </code><code class="s">"$LINE"</code><code class="nv"> </code><code class="s">|</code><code class="nv"> </code><code class="s">cut</code><code class="nv"> </code><code class="s">-f2</code><code class="nv"> </code><code class="s">-d"|"</code><code class="nv"> </code><code class="s">\</code><code class="w"></code>
<code class="w">       </code><code class="s">&gt;&gt;</code><code class="nv"> </code><code class="s">$(date</code><code class="nv"> </code><code class="s">+%Y-%m-%d-%H-%M-%S)-transformed.txt;</code><code class="nv"> </code><code class="s">done</code><code class="nv"> </code><code class="s">&lt;</code><code class="nv"> </code><code class="s">\</code><code class="w"></code>
<code class="w">       </code><code class="s">/var/logs/diskspace.txt;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">20;</code><code class="nv"> </code><code class="s">done;'</code><code class="w"></code>
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">config-volume</code><code class="w"></code>
<code class="w">      </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/var/logs</code><code class="w"></code>
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">config-volume</code><code class="w"></code>
<code class="w">    </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="calibre15">{}</code><code class="w"></code></pre></div>

<p class="author1">After creating the Pod, we’ll find two running containers. We should be able to locate the original file, <em class="calibre3">/var/logs/diskspace.txt</em>, after shelling into the <code class="calibre15">transformer</code> container. The transformed data exists in a separate file in the user home directory:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create -f adapter.yaml</strong>
pod/adapter created
<strong class="calibre38">$ kubectl get pods adapter</strong>
NAME      READY   STATUS    RESTARTS   AGE
adapter   2/2     Running   0          10s
<strong class="calibre38">$ kubectl exec adapter --container=transformer -it -- /bin/sh</strong>
/ # cat /var/logs/diskspace.txt
Sun Jul 19 20:28:07 UTC 2020 | 4.0K	/root
Sun Jul 19 20:28:12 UTC 2020 | 4.0K	/root
/ # ls -l
total 40
-rw-r--r--  1  root  root  60 Jul 19 20:28 2020-07-19-20-28-28-transformed.txt
...
/ # cat 2020-07-19-20-28-28-transformed.txt
 4.0K	/root
 4.0K	/root
</pre>
</div></section>








<section data-type="sect2" data-pdf-bookmark="The Ambassador Pattern" class="praise"><div class="dedication" id="id229">
<h2 class="calibre33">The Ambassador Pattern</h2>

<p class="author1">Another important design pattern covered by the CKAD is the ambassador pattern. The ambassador pattern provides a proxy for communicating with external services.</p>

<p class="author1">Many use cases can justify the introduction of the ambassador pattern. The overarching goal is to hide and/or abstract the complexity of interacting with other parts of the system. Typical responsibilities include retry logic upon a request failure, security concerns such as providing authentication or authorization, and monitoring latency or resource usage. <a data-type="xref" href="#ambassador_pattern" class="calibre10">Figure 8-5</a> illustrates this pattern.</p>

<figure class="calibre35"><div id="ambassador_pattern" class="figure">
<img src="Images/ckd2_0805.png" alt="ckd2 0805" class="calibre80"/>
<h6 class="calibre32"><span class="keep-together">Figure 8-5. </span>The ambassador pattern in action</h6>
</div></figure>

<p class="author1">In this example, we’ll want to implement rate-limiting functionality for HTTP(S) calls to an external service. For example, the requirements for the rate limiter could say that an application can make a maximum of 5 calls every 15 minutes. Instead of strongly coupling the rate-limiting logic to the application code, it will be provided by an ambassador container. Any calls made from the business application need to be funneled through the ambassador container. <a data-type="xref" href="#rate_limiter_implementation" class="calibre10">Example 8-4</a> shows a Node.js-based rate limiter implementation that makes calls to the external service <a href="https://www.postman.com" class="calibre10">Postman</a>.</p>
<div id="rate_limiter_implementation" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 8-4. </span>Node.js HTTP rate limiter implementation</h5>

<pre data-type="programlisting" data-code-language="javascript" class="calibre47"><code class="k">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'express'</code><code class="p">);</code>
<code class="k">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>
<code class="k">const</code> <code class="nx">rateLimit</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'express-rate-limit'</code><code class="p">);</code>
<code class="k">const</code> <code class="nx">https</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s">'https'</code><code class="p">);</code>

<code class="k">const</code> <code class="nx">rateLimiter</code> <code class="o">=</code> <code class="nx">rateLimit</code><code class="p">({</code>
  <code class="nx">windowMs</code><code class="o">:</code> <code class="mi">15</code> <code class="o">*</code> <code class="mi">60</code> <code class="o">*</code> <code class="mi">1000</code><code class="p">,</code>
  <code class="nx">max</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code>
  <code class="nx">message</code><code class="o">:</code>
    <code class="s">'Too many requests have been made from this IP, please try again after an hour'</code>
<code class="p">});</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s">'/test'</code><code class="p">,</code> <code class="nx">rateLimiter</code><code class="p">,</code> <code class="k">function</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">'Received request...'</code><code class="p">);</code>
  <code class="k">var</code> <code class="nx">id</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">query</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>
  <code class="k">var</code> <code class="nx">url</code> <code class="o">=</code> <code class="s">'https://postman-echo.com/get?test='</code> <code class="o">+</code> <code class="nx">id</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">"Calling URL %s"</code><code class="p">,</code> <code class="nx">url</code><code class="p">);</code>

  <code class="nx">https</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="p">(</code><code class="nx">resp</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="k">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="s">''</code><code class="p">;</code>

    <code class="nx">resp</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'data'</code><code class="p">,</code> <code class="p">(</code><code class="nx">chunk</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">data</code> <code class="o">+=</code> <code class="nx">chunk</code><code class="p">;</code>
    <code class="p">});</code>

    <code class="nx">resp</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s">'end'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="nx">data</code><code class="p">);</code>
    <code class="p">});</code>

    <code class="p">}).</code><code class="nx">on</code><code class="p">(</code><code class="s">"error"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
      <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>
    <code class="p">});</code>
<code class="p">})</code>

<code class="k">var</code> <code class="nx">server</code> <code class="o">=</code> <code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="mi">8081</code><code class="p">,</code> <code class="k">function</code> <code class="p">()</code> <code class="p">{</code>
  <code class="k">var</code> <code class="nx">port</code> <code class="o">=</code> <code class="nx">server</code><code class="p">.</code><code class="nx">address</code><code class="p">().</code><code class="nx">port</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s">"Ambassador listening on port %s..."</code><code class="p">,</code> <code class="nx">port</code><code class="p">)</code>
<code class="p">})</code></pre></div>

<p class="author1">The corresponding Pod shown in <a data-type="xref" href="#ambassador_pattern_pod" class="calibre10">Example 8-5</a> runs the main application container on a different port than the ambassador container. Every call to the HTTP endpoint of the container named <code class="calibre15">business-app</code> would delegate to the HTTP endpoint of the container named <code class="calibre15">ambassador</code>. It’s important to mention that containers running inside of the same Pod can communicate via <code class="calibre15">localhost</code>. No additional networking configuration is required.</p>
<div id="ambassador_pattern_pod" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 8-5. </span>An exemplary ambassador pattern implementation</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">rate-limiter</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">business-app</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-business-app:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8080</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">ambassador</code><code class="w"></code>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-ambassador:1.0.0</code><code class="w"></code>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8081</code><code class="w"></code></pre></div>

<p class="author1">Let’s test the functionality. First, we’ll create the Pod, shell into the container that runs the business application, and execute a series of <code class="calibre15">curl</code> commands. The first five calls will be allowed to the external service. On the sixth call, we’ll receive an error message, as the rate limit has been reached within the given time frame:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl create -f ambassador.yaml</strong>
pod/rate-limiter created
<strong class="calibre38">$ kubectl get pods rate-limiter</strong>
NAME           READY   STATUS    RESTARTS   AGE
rate-limiter   2/2     Running   0          5s
<strong class="calibre38">$ kubectl exec rate-limiter -it -c business-app -- /bin/sh</strong>
# curl localhost:8080/test
{"args":{"test":"123"},"headers":{"x-forwarded-proto":"https", \
"x-forwarded-port":"443","host":"postman-echo.com", \
"x-amzn-trace-id":"Root=1-5f177dba-e736991e882d12fcffd23f34"}, \
"url":"https://postman-echo.com/get?test=123"}
...
# curl localhost:8080/test
Too many requests have been made from this IP, please try again after an hour
</pre>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id230">
<h1 class="calibre17">Summary</h1>

<p class="author1">Real-world scenarios call for running multiple containers inside of a Pod. An init container helps with setting the stage for the main application container by executing initializing logic. Once the initialized logic has been processed, the container will be terminated. The main application container starts only if the init container ran through its functionality successfully.</p>

<p class="author1">Other design patterns that involve multiple containers per Pod are the adapter pattern and the ambassador pattern. The adapter pattern helps with “translating” data produced by the application so that it becomes consumable by third-party services. The ambassador pattern acts as a proxy for the application container when communicating with external services by abstracting the “how.”</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id231">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Understand the need for running multiple containers in a Pod</dt>
<dd class="calibre20">
<p class="calibre21">Pods can run multiple containers. You will need to understand the difference between init containers and sidecar containers and their respective life cycles. Practice accessing a specific container in a multi-container Pod with the help of the command-line option <code class="calibre15">--container</code> or <code class="calibre15">-c</code>.</p>
</dd>
<dt class="calibre19">Know how to create an init container</dt>
<dd class="calibre20">
<p class="calibre21">Init containers see a lot of use in enterprise Kubernetes cluster environments. Understand the need for using them in their respective scenarios. Practice 
<span class="keep-together">defining</span> a Pod with one or even more init containers and observe their linear execution when creating the Pod. It’s important to experience the behavior of a Pod in failure situations that occur in an init container.</p>
</dd>
<dt class="calibre19">Understand multi-container design patterns and how to implement them</dt>
<dd class="calibre20">
<p class="calibre21">Multi-container Pods are best understood by implementing a scenario for one of the established patterns. Based on what you’ve learned, come up with your own applicable use case and create a multi-container Pod to solve it. It’s helpful to be able to identify sidecar patterns and understand why they are important in practice and how to stand them up yourself. As you implement your own sidecars, you may notice that you have to brush up on your knowledge of bash.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id232">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_004.xhtml#appendix_a_multicontainer_pods" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Create a YAML manifest for a Pod named <code class="calibre15">complex-pod</code>. The main application container named <code class="calibre15">app</code> should use the image <code class="calibre15">nginx:1.25.1</code> and expose the container port 80. Modify the YAML manifest so that the Pod defines an init container named <code class="calibre15">setup</code> that uses the image <code class="calibre15">busybox:1.36.1</code>. The init container runs the command <code class="calibre15">wget -O- google.com</code>.</p>

<p class="author1">Create the Pod from the YAML manifest.</p>

<p class="author1">Download the logs of the init container. You should see the output of the <code class="calibre15">wget</code> command.</p>

<p class="author1">Open an interactive shell to the main application container and run the <code class="calibre15">ls</code> command. Exit out of the container.</p>

<p class="author1">Force-delete the Pod.</p>
</li>
<li class="calibre56">
<p class="author1">Create a YAML manifest for a Pod named <code class="calibre15">data-exchange</code>. The main application container named <code class="calibre15">main-app</code> should use the image <code class="calibre15">busybox:1.36.1</code>. The container runs a command that writes a new file every 30 seconds in an infinite loop in the directory <em class="calibre3">/var/app/data</em>. The filename follows the pattern <em class="calibre3">{counter++}-data.txt</em>. The variable counter is incremented every interval and starts with the value 1.</p>

<p class="author1">Modify the YAML manifest by adding a sidecar container named <code class="calibre15">sidecar</code>. The sidecar container uses the image <code class="calibre15">busybox:1.36.1</code> and runs a command that counts the number of files produced by the <code class="calibre15">main-app</code> container every 60 seconds in an infinite loop. The command writes the number of files to standard output.</p>

<p class="author1">Define a Volume of type <code class="calibre15">emptyDir</code>. Mount the path <em class="calibre3">/var/app/data</em> for both 
<span class="keep-together">containers.</span></p>

<p class="author1">Create the Pod. Tail the logs of the sidecar container.</p>

<p class="author1">Delete the Pod.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>