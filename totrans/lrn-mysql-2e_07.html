<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Transactions and Locking"><div class="chapter" id="CH6_TRANSACTION_LOCKING">
<h1><span class="label">Chapter 6. </span>Transactions and Locking</h1>


<p>Using locks for transaction isolation is a pillar of SQL databases—but<a data-type="indexterm" data-primary="transactions" data-secondary="about" id="idm46177466242696"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="about" id="idm46177466241720"/> this is also an area that can cause a lot of confusion, especially for newcomers. Developers often think that locking is a database issue and belongs to the DBA realm. The DBAs, in turn, believe this is an application issue and consequently the responsibility of the developers. This chapter will clarify what happens in situations where different processes are trying to write in the same row at the same time. It will also shed light on the behavior of read queries inside a transaction with the different types of isolation levels available in MySQL.</p>

<p>First, let’s define the key concepts. A <em>transaction</em> is an<a data-type="indexterm" data-primary="transactions" data-secondary="definition" id="idm46177466239080"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="transaction definition" id="idm46177466209480"/><a data-type="indexterm" data-primary="database transactions" data-see="transactions" id="idm46177466208632"/><a data-type="indexterm" data-primary="committing transactions" data-secondary="definition" id="idm46177466207784"/><a data-type="indexterm" data-primary="ROLLBACK" data-secondary="transactions definition" id="idm46177466206936"/> operation performed (using one or more SQL statements) on a database as a single logical unit of work. All the SQL statements’ modifications in a transaction are either committed (applied to the database) or rolled back (undone from the database) as a unit, never only partially. <a data-type="indexterm" data-primary="ACID transactions" id="idm46177466205656"/>A database transaction must be atomic, consistent, isolated, and durable (the famous acronym <em>ACID</em>).</p>

<p><em>Locks</em> are mechanisms used to ensure the integrity of the<a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="definition" id="idm46177466203912"/><a data-type="indexterm" data-primary="transactions" data-secondary="locks" data-tertiary="definition" id="idm46177466203064"/> data stored in the database while applications and users are interacting with it. We will see that there are different types of lock, and some are more restrictive than others.</p>

<p>Databases would not need transactions and locks if requests were issued serially and processed in order, one at a time (a <code>SELECT</code>, then an <code>INSERT</code>, then an <code>UPDATE</code>, and so on). We illustrate this behavior in <a data-type="xref" href="#FIG-SQL-PROGRESSION">Figure 6-1</a>.</p>

<p>However, the reality (fortunately!) is that MySQL can handle thousands of requests per second  and process them in parallel, rather than serially. This chapter discusses what MySQL does to achieve this parallelism, for example, when requests to <code>SELECT</code> and <code>UPDATE</code> in the same row arrive simultaneously, or one arrives while the other is still executing. <a data-type="xref" href="#FIG-SQL-PARALLEL-PROGRESSION">Figure 6-2</a> shows what this looks like.</p>

<figure><div id="FIG-SQL-PROGRESSION" class="figure">
<img src="Images/lm2e_0601.png" alt="lm2e 0601" width="1287" height="575"/>
<h6><span class="label">Figure 6-1. </span>Serialized execution of SQL statements</h6>
</div></figure>

<figure><div id="FIG-SQL-PARALLEL-PROGRESSION" class="figure">
<img src="Images/lm2e_0602.png" alt="lm2e 0602" width="1578" height="925"/>
<h6><span class="label">Figure 6-2. </span>Parallel execution of SQL statements</h6>
</div></figure>

<p>For this chapter, we are particularly interested in how MySQL <em>isolates</em> the transactions (the <em>I</em> of ACID). We will show you common situations where locking occurs, investigate them, and discuss the MySQL parameters that control how much time a transaction can wait for a lock to be granted.</p>






<section data-type="sect1" data-pdf-bookmark="Isolation Levels"><div class="sect1" id="ISOLATION">
<h1>Isolation Levels</h1>

<p>The <em>isolation level</em> is the setting that balances performance,<a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="isolation levels" id="ch06-iso"/><a data-type="indexterm" data-primary="transactions" data-secondary="isolation levels" id="ch06-iso2"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="about" id="idm46177466187640"/><a data-type="indexterm" data-primary="InnoDB" data-secondary="transactions" data-tertiary="isolation levels" id="ch06-iso3"/> reliability, consistency, and reproducibility of results when multiple transactions are making changes and performing queries simultaneously.</p>

<p>The SQL:1992 standard defines four classic isolation levels, and MySQL supports all of them. InnoDB supports each of the transaction isolation levels described here using different locking strategies. <a data-type="indexterm" data-primary="isolation levels" data-secondary="SET TRANSACTION" id="idm46177466184568"/><a data-type="indexterm" data-primary="SET command" data-secondary="transaction isolation levels" id="idm46177466183720"/><a data-type="indexterm" data-primary="SET command" data-secondary="GLOBAL or SESSION" id="idm46177466182872"/><a data-type="indexterm" data-primary="SET command" data-secondary="SESSION or GLOBAL" id="idm46177466182024"/>A user can also change the isolation level for a single session or all subsequent connections with the statement <code>SET [GLOBAL/SESSION] TRANSACTION</code>.</p>

<p>We can enforce a high degree of consistency with the default<a data-type="indexterm" data-primary="committing transactions" data-secondary="isolation levels" id="idm46177466180152"/><a data-type="indexterm" data-primary="REPEATABLE READ isolation level" id="idm46177466178888"/><a data-type="indexterm" data-primary="defaults" data-secondary="isolation level" data-tertiary="MySQL" id="idm46177466178280"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="REPEATABLE READ" data-tertiary="default for MySQL" id="idm46177466177192"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="REPEATABLE READ" id="idm46177466176104"/> <code>REPEATABLE READ</code> isolation level for operations on data where ACID compliance is essential, <a data-type="indexterm" data-primary="committing transactions" data-secondary="consistency rules versus performance" id="idm46177466174744"/><a data-type="indexterm" data-primary="performance" data-secondary="transaction consistency rules relaxed" id="idm46177466173896"/>and we can relax the consistency rules with <code>READ COMMITTED</code> or even <code>READ UNCOMMITTED</code> isolation in situations such as bulk reporting where precise consistency and repeatable results are less important than minimizing the amount of overhead for locking.<a data-type="indexterm" data-primary="SERIALIZABLE isolation level" id="idm46177466171976"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="SERIALIZABLE" id="idm46177466171368"/> <code>SERIALIZABLE</code> isolation enforces even stricter rules than <code>REPEATABLE READ</code> and is used mainly for special situations such as troubleshooting. Before diving into the details, let’s take a look at some more terminology:</p>
<dl>
<dt>Dirty reads</dt>
<dd>
<p>These occur when a transaction is able to read data from a row<a data-type="indexterm" data-primary="dirty reads" id="idm46177466168216"/> that has been modified by another transaction that has not executed a <code>COMMIT</code> yet. If the transaction that made the modifications gets rolled back, the other one will have seen incorrect results that do not reflect the state of the database. Data integrity is compromised.</p>
</dd>
<dt>Non-repeatable reads</dt>
<dd>
<p>These occur when two queries in a transaction execute a<a data-type="indexterm" data-primary="non-repeatable reads" id="idm46177466165736"/> <code>SELECT</code> and the values returned differ between the readings because of changes made by another transaction in the interim (if you read a row at time T1 and then try to read it again at time T2, the row may have been updated). The difference from a dirty read is that in this case there is a <code>COMMIT</code>. The initial <code>SELECT</code> query is not repeatable because it returns different values when issued the second time.</p>
</dd>
<dt>Phantom reads</dt>
<dd>
<p>These occur when a transaction is running, and another<a data-type="indexterm" data-primary="phantom reads" id="idm46177466162280"/> transaction adds rows to or deletes them from the records being read (again, in this case there is a <code>COMMIT</code> by the transaction modifying the data). This means that if the same query is executed again in the same transaction, it will return a different number of rows. Phantom reads can occur when there are no range locks guaranteeing the consistency of the data.</p>
</dd>
</dl>

<p>With those concepts in mind, let’s take a closer look at the different isolation levels in MySQL.</p>








<section data-type="sect2" data-pdf-bookmark="REPEATABLE READ"><div class="sect2" id="idm46177466160024">
<h2>REPEATABLE READ</h2>

<p><code>REPEATABLE READ</code> is the default isolation level for InnoDB.<a data-type="indexterm" data-primary="isolation levels" data-secondary="REPEATABLE READ" id="idm46177466157976"/><a data-type="indexterm" data-primary="defaults" data-secondary="isolation level" data-tertiary="MySQL" id="idm46177466157128"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="REPEATABLE READ" data-tertiary="default for MySQL" id="idm46177466156040"/><a data-type="indexterm" data-primary="REPEATABLE READ isolation level" id="idm46177466154952"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="isolation levels" data-tertiary="REPEATABLE READ" id="idm46177466154344"/> It ensures consistent reads within the same transaction—that is, that all queries within the transaction will see the same snapshot of the data, established by the first read. <a data-type="indexterm" data-primary="gap locks" data-secondary="InnoDB" id="idm46177466152936"/>In this mode, InnoDB locks the index range scanned, using gap locks or next-key locks (described in <a data-type="xref" href="#LOCKING">“Locking”</a>) to block insertions by other sessions into any gaps within that range.</p>

<p>For example, suppose that in one session (session 1), we execute the following <code>SELECT</code>:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="k">BETWEEN</code><code> </code><code class="mi">1</code><code> </code><code class="k">AND</code><code> </code><code class="mi">4</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---+----------+
| i | name     |
+---+----------+
| 1 | Vinicius |
| 2 | Sergey   |
| 3 | Iwo      |
| 4 | Peter    |
+---+----------+
4 rows in set (0.00 sec)</pre>

<p>And in another session (session 2), we update the name in the second row:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">person</code><code> </code><code class="kt">SET</code><code> </code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Kuzmichev'</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code class="o">=</code><code class="mi">2</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="n">COMMIT</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.00 sec)</pre>

<p>We can confirm the change in session 2:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="k">BETWEEN</code><code> </code><code class="mi">1</code><code> </code><code class="k">AND</code><code> </code><code class="mi">4</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---+-----------+
| i | name      |
+---+-----------+
| 1 | Vinicius  |
| 2 | Kuzmichev |
| 3 | Iwo       |
| 4 | Peter     |
+---+-----------+
4 rows in set (0.00 sec)</pre>

<p class="pagebreak-before">But session 1 still shows the old value from its original snapshot of the data:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="k">BETWEEN</code><code> </code><code class="mi">1</code><code> </code><code class="k">AND</code><code> </code><code class="mi">4</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---+----------+
| i | name     |
+---+----------+
| 1 | Vinicius |
| 2 | Sergey   |
| 3 | Iwo      |
| 4 | Peter    |
+---+----------+</pre>

<p>With the <code>REPEATABLE READ</code> isolation level, there are thus<a data-type="indexterm" data-primary="dirty reads" id="idm46177465981032"/> no dirty reads and or non-repeatable reads. Each transaction reads the snapshot established by the first read.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="READ COMMITTED"><div class="sect2" id="idm46177466159432">
<h2>READ COMMITTED</h2>

<p>As a curiosity, the <code>READ COMMITTED</code> isolation level is the<a data-type="indexterm" data-primary="READ COMMITTED isolation level" id="idm46177465977928"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="READ COMMITTED" id="idm46177465977224"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="READ COMMITTED" data-tertiary="default for non-MySQL" id="idm46177465976280"/><a data-type="indexterm" data-primary="defaults" data-secondary="isolation level" data-tertiary="non-MySQL databases" id="idm46177465975064"/> default for many databases, like Postgres, Oracle, and SQL Server, but not MySQL. So, those who are migrating to MySQL must be aware of this difference in the default behavior.</p>

<p>The main difference between <code>READ COMMITTED</code> and <code>REPEATABLE READ</code> is that with <code>READ COMMITTED</code> each consistent read, even within the same transaction, creates and reads its own fresh snapshot. <a data-type="indexterm" data-primary="phantom reads" id="idm46177465958952"/>This behavior can lead to <em>phantom reads</em> when executing multiple queries inside a transaction. Let’s take a look at an example. In session 1, row 1 looks like this:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---+----------+
| i | name     |
+---+----------+
| 1 | Vinicius |
+---+----------+
1 row in set (0.00 sec)</pre>

<p>Now suppose that in session 2 we update the first row of the <code>person</code> table and commit the transaction:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">person</code><code> </code><code class="kt">SET</code><code> </code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Grippa'</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="n">COMMIT</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.00 sec)</pre>

<p>If we check session 1 again, we’ll see that the value of the first row has changed:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---+--------+
| i | name   |
+---+--------+
| 1 | Grippa |
+---+--------+</pre>

<p>The significant advantage of <code>READ COMMITTED</code> is that there<a data-type="indexterm" data-primary="gap locks" data-secondary="READ COMMITTED having none" id="idm46177465840984"/> are no gap locks, allowing the free insertion of new records next to locked records.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="READ UNCOMMITTED"><div class="sect2" id="idm46177465979480">
<h2>READ UNCOMMITTED</h2>

<p>With the <code>READ UNCOMMITTED</code> isolation level MySQL<a data-type="indexterm" data-primary="READ UNCOMMITTED isolation level" id="idm46177465837512"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="READ UNCOMMITTED" id="idm46177465836808"/> performs <code>SELECT</code> statements in a non-locking fashion, which means two <code>SELECT</code> statements within the same transaction might not read the same version of a row. <a data-type="indexterm" data-primary="dirty reads" id="idm46177465834904"/>As we saw earlier, this phenomenon is called a dirty read. Consider how the previous example would play out using <code>READ UNCOMMITTED</code>. The main difference is that session 1 can see the results  of session 2’s update <em>before</em> the commit. Let’s walk through another example. Suppose that in session 1 we execute the following <code>SELECT</code> statement:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="o">=</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---+---------+
| i | name    |
+---+---------+
| 5 | Marcelo |
+---+---------+
1 row in set (0.00 sec)</pre>

<p>And in session 2, we perform this update <em>without</em> committing:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">person</code><code> </code><code class="kt">SET</code><code> </code><code class="n">name</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Altmann'</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="o">=</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0</pre>

<p>If we now perform the <code>SELECT</code> again in session 1, here’s what we’ll see:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">i</code><code> </code><code class="o">=</code><code> </code><code class="mi">5</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+---+---------+
| i | name    |
+---+---------+
| 5 | Altmann |
+---+---------+
1 row in set (0.00 sec)</pre>

<p>We can see that session 1 can read the modified data even though it is in a transient state, and this change may end up being rolled back and not committed.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="SERIALIZABLE"><div class="sect2" id="idm46177465839288">
<h2>SERIALIZABLE</h2>

<p>The most restricted isolation level available in MySQL is<a data-type="indexterm" data-primary="isolation levels" data-secondary="SERIALIZABLE" id="ch06-ser"/><a data-type="indexterm" data-primary="SERIALIZABLE isolation level" id="ch06-ser2"/> <code>SERIALIZABLE</code>. This is similar to <code>REPEATABLE READ</code>, but has an additional restriction of not allowing one transaction to interfere with another. So, with this locking mechanism, the inconsistent data scenario is no longer possible.<a data-type="indexterm" data-primary="transactions" data-secondary="retry strategy for SERIALIZABLE" id="idm46177465713592"/></p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>For applications using <code>SERIALIZABLE</code>, it is important to have a retry strategy.</p>
</div>

<p>To make this clearer, imagine a finance database where we<a data-type="indexterm" data-primary="REPEATABLE READ isolation level" data-secondary="SERIALIZABLE versus" id="ch06-rvs"/><a data-type="indexterm" data-primary="SERIALIZABLE isolation level" data-secondary="REPEATABLE READ versus" id="ch06-rvs2"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="SERIALIZABLE" data-tertiary="REPEATABLE READ versus" id="ch06-rvs3"/><a data-type="indexterm" data-primary="isolation levels" data-secondary="REPEATABLE READ" data-tertiary="SERIALIZABLE versus" id="ch06-rvs4"/> register customers’ account balances in an <code>accounts</code> table. What will happen if two transactions try to update a customer’s account balance at the same time? The following example illustrates this scenario. Assume that we have started two sessions using the default isolation level, <code>REPEATABLE READ</code>, and explicitly opened a transaction in each with <code>BEGIN</code>. In session 1, we select all the accounts in the <code>accounts</code> table:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">accounts</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+--------+---------+----------+---------------------+
| id | owner  | balance | currency | created_at          |
+----+--------+---------+----------+---------------------+
|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |
|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |
|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |
+----+--------+---------+----------+---------------------+
3 rows in set (0.00 sec)</pre>

<p>Then, in session 2, we select all accounts with balance of at least 80 USD:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">accounts</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">balance</code><code> </code><code class="o">&gt;</code><code class="o">=</code><code> </code><code class="mi">80</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+--------+---------+----------+---------------------+
| id | owner  | balance | currency | created_at          |
+----+--------+---------+----------+---------------------+
|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |
|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |
|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |
+----+--------+---------+----------+---------------------+
3 rows in set (0.00 sec)</pre>

<p>Now, in session 1, we subtract 10 USD from account 1 and check the result:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">accounts</code><code> </code><code class="kt">SET</code><code> </code><code class="n">balance</code><code> </code><code class="o">=</code><code> </code><code class="n">balance</code><code> </code><code class="o">-</code><code> </code><code class="mi">10</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong><code>
</code><code class="n">Query</code><code> </code><code class="n">OK</code><code class="p">,</code><code> </code><code class="mi">1</code><code> </code><code class="n">row</code><code> </code><code class="nf">affected</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">.</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code><code>
</code><code class="n">Rows</code><code> </code><code class="n">matched</code><code class="p">:</code><code> </code><code class="mi">1</code><code>  </code><code class="n">Changed</code><code class="p">:</code><code> </code><code class="mi">1</code><code>  </code><code class="n">Warnings</code><code class="p">:</code><code> </code><code class="mi">0</code><code>

</code><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">accounts</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+--------+---------+----------+---------------------+
| id | owner  | balance | currency | created_at          |
+----+--------+---------+----------+---------------------+
|  1 | Vinnie |      70 | USD      | 2021-07-13 20:39:27 |
|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |
|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |
+----+--------+---------+----------+---------------------+
3 rows in set (0.00 sec)</pre>

<p>We can see that the balance of account 1 has decreased to 70 USD. So, we commit session 1 and then move to session 2 to see if it can read the new changes made by session 1:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="n">COMMIT</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.01 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">accounts</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+--------+---------+----------+---------------------+
| id | owner  | balance | currency | created_at          |
+----+--------+---------+----------+---------------------+
|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |
+----+--------+---------+----------+---------------------+
1 row in set (0.01 sec)</pre>

<p>This <code>SELECT</code> query still returns the old data for account 1, with a balance of 80 USD, even though transaction 1 changed it to 70 USD and was committed successfully. That’s because the <code>REPEATABLE READ</code> isolation level ensures that all read queries in a transaction are repeatable, which means they always return the same result, even if changes have been made by other committed transactions.</p>

<p>But what will happen if we also run the <code>UPDATE</code> query to subtract 10 USD from account 1’s balance in session 2? Will it change the balance to 70 USD, or 60 USD, or throw an error? Let’s see:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">accounts</code><code> </code><code class="kt">SET</code><code> </code><code class="n">balance</code><code> </code><code class="o">=</code><code> </code><code class="n">balance</code><code> </code><code class="o">-</code><code> </code><code class="mi">10</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">accounts</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+--------+---------+----------+---------------------+
| id | owner  | balance | currency | created_at          |
+----+--------+---------+----------+---------------------+
|  1 | Vinnie |      60 | USD      | 2021-07-13 20:39:27 |
+----+--------+---------+----------+---------------------+
1 row in set (0.01 sec)</pre>

<p>There’s no error, and the account balance is now 60 USD, which is the correct value because transaction 1 has already committed the change that modified the balance to 70 USD.</p>

<p>However, from transaction 2’s point of view, this doesn’t make sense: in the last <code>SELECT</code> query it saw a balance of 80 USD, but after subtracting 10 USD from the account, now it sees a balance of 60 USD. The math doesn’t work here because this transaction is still being affected by concurrent updates from other transactions.</p>

<p>This is the scenario where using <code>SERIALIZABLE</code> can help. Let’s rewind to before we made any changes. <a data-type="indexterm" data-primary="isolation levels" data-secondary="SET TRANSACTION" id="idm46177465394824"/><a data-type="indexterm" data-primary="SET command" data-secondary="transaction isolation levels" id="idm46177465393848"/>This time we’ll explicitly set the isolation level of both sessions to <code>SERIALIZABLE</code> with <code>SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE</code> before starting the transactions with <code>BEGIN</code>. Again, in session 1 we select all the accounts:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">accounts</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+--------+---------+----------+---------------------+
| id | owner  | balance | currency | created_at          |
+----+--------+---------+----------+---------------------+
|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |
|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |
|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |
+----+--------+---------+----------+---------------------+
3 rows in set (0.00 sec)</pre>

<p>And in session 2 we select all the accounts with a balance greater than 80 USD:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">accounts</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">balance</code><code> </code><code class="o">&gt;</code><code class="o">=</code><code> </code><code class="mi">80</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+--------+---------+----------+---------------------+
| id | owner  | balance | currency | created_at          |
+----+--------+---------+----------+---------------------+
|  1 | Vinnie |      80 | USD      | 2021-07-13 20:39:27 |
|  2 | Sergey |     100 | USD      | 2021-07-13 20:39:32 |
|  3 | Markus |     100 | USD      | 2021-07-13 20:39:39 |
+----+--------+---------+----------+---------------------+
3 rows in set (0.00 sec)</pre>

<p>Now, in session 1 we subtract 10 USD from account 1:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">accounts</code><code> </code><code class="kt">SET</code><code> </code><code class="n">balance</code><code> </code><code class="o">=</code><code> </code><code class="n">balance</code><code> </code><code class="o">-</code><code> </code><code class="mi">10</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">id</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<p>And…nothing happens. This time the <code>UPDATE</code> query is blocked—the <code>SELECT</code> query in session 1 has locked those rows and prevents the <code>UPDATE</code> in session 2 from succeeding. Because we explicitly started our transactions with <code>BEGIN</code> (which has the same effect as disabling autocommit), InnoDB implicitly converts all plain <code>SELECT</code> statements in each transaction to <code>SELECT ... FOR SHARE</code>. It does not know ahead of time if the transaction will perform only reads or will modify rows, so InnoDB needs to place a lock on it to avoid the issue we demonstrated in the previous example. In this example, if autocommit were enabled, the <code>SELECT</code> query in session 2 would not block the update that we are trying to perform in session 1: MySQL would recognize that the query is a plain <code>SELECT</code> and does not need to block other queries because it is not going to modify any rows.</p>

<p>However, the update in session 2 will not hang forever; <a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="timeout duration" id="idm46177465279176"/><a data-type="indexterm" data-primary="timeout duration of transaction lock" id="idm46177465278232"/><a data-type="indexterm" data-primary="timeout duration of transaction lock" data-secondary="parameter reference online" id="idm46177465277592"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="timeout duration" data-tertiary="parameter reference online" id="idm46177465276712"/>this lock has a timeout duration that is controlled by the <a href="https://oreil.ly/rfrv0"><code>innodb_lock_wait_timeout</code> parameter</a>. So, if session 1 doesn’t commit or roll back its transaction to release the lock, once the session timeout is reached, MySQL will throw the following error:<a data-type="indexterm" data-startref="ch06-ser" id="idm46177465261608"/><a data-type="indexterm" data-startref="ch06-ser2" id="idm46177465261000"/><a data-type="indexterm" data-startref="ch06-rvs" id="idm46177465260392"/><a data-type="indexterm" data-startref="ch06-rvs2" id="idm46177465259784"/><a data-type="indexterm" data-startref="ch06-rvs3" id="idm46177465259176"/><a data-type="indexterm" data-startref="ch06-rvs4" id="idm46177465258568"/><a data-type="indexterm" data-startref="ch06-iso" id="idm46177465257960"/><a data-type="indexterm" data-startref="ch06-iso2" id="idm46177465257352"/><a data-type="indexterm" data-startref="ch06-iso3" id="idm46177465256744"/></p>

<pre data-type="programlisting">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Locking"><div class="sect1" id="LOCKING">
<h1>Locking</h1>

<p>Now that we’ve seen how each isolation level works, let’s look at the different locking strategies InnoDB employs to implement them.<a data-type="indexterm" data-primary="InnoDB" data-secondary="transactions" data-tertiary="locking" id="idm46177465254248"/><a data-type="indexterm" data-primary="transactions" data-secondary="locks" id="idm46177465253160"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="about" id="idm46177465252312"/><a data-type="indexterm" data-primary="transactions" data-secondary="about" data-tertiary="locking" id="idm46177465251464"/></p>

<p>Locks are used in databases to protect shared resources or objects. They can act at different levels, such as:</p>

<ul>
<li>
<p>Table locking</p>
</li>
<li>
<p>Metadata locking</p>
</li>
<li>
<p>Row locking</p>
</li>
<li>
<p>Application-level locking</p>
</li>
</ul>

<p>MySQL uses metadata locking to manage concurrent access to database objects and to ensure data consistency.  When there is an active transaction (explicit or implicit) on the table, MySQL does not allow writing of metadata (DDL statements, for example, update the metadata of the table). It does this to maintain metadata consistency in a concurrent environment.</p>

<p>If there is an active transaction (running, uncommitted, or rolled back) when a session performs one of the operations mentioned in the following list, the session requesting the data write will be held in the <code>Waiting for table metadata lock</code> status. A metadata lock wait may occur in any of the following scenarios:</p>

<ul>
<li>
<p>When you create or delete an index</p>
</li>
<li>
<p>When you modify the table structure</p>
</li>
<li>
<p>When you perform table maintenance operations (<code>OPTIMIZE TABLE</code> <code>REPAIR TABLE</code>, etc.)</p>
</li>
<li>
<p>When you delete a table</p>
</li>
<li>
<p>When you try to obtain a table-level write lock on the table (<code>LOCK TABLE table_name WRITE</code>)</p>
</li>
</ul>

<p>To enable simultaneous write access by multiple sessions, InnoDB supports row-level locking.</p>

<p>Application-level or user-level locks, such as those provided by <code>GET_LOCK()</code>, can be used to simulate database locks such as record locks.</p>

<p>This book focuses on metadata and the row locks since they are the ones that affect the majority of users and are the most common.</p>








<section data-type="sect2" data-pdf-bookmark="Metadata Locks"><div class="sect2" id="CH6_TRANSACTION_LOCKING_METADATA">
<h2>Metadata Locks</h2>

<p>The <a href="https://oreil.ly/zjDjG">MySQL documentation</a> provides the best definition of metadata locks:<a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="metadata locks" data-tertiary="definition" id="idm46177465233784"/><a data-type="indexterm" data-primary="metadata locks" data-secondary="definition" id="idm46177465232696"/><a data-type="indexterm" data-primary="metadata locks" data-secondary="DDL statement execution" id="idm46177465231848"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="metadata locks" id="ch06-mdl"/><a data-type="indexterm" data-primary="metadata locks" id="ch06-mdl2"/><a data-type="indexterm" data-primary="data definition language (DDL)" data-secondary="metadata locks" id="idm46177465229064"/></p>
<blockquote>
<p>To ensure transaction serializability, the server must not permit one session to perform a data definition language (DDL) statement on a table that is used in an uncompleted explicitly or implicitly started transaction in another session. The server achieves this by acquiring metadata locks on tables used within a transaction and deferring the locks’ release until the transaction ends. A metadata lock on a table prevents changes to the table’s structure. This locking approach has the implication that a table that is being used by a transaction within one session cannot be used in DDL statements by other sessions until the transaction ends.</p>
</blockquote>

<p>With this definition in mind, let’s take a look at metadata locking in action. First, we will create a dummy table and load some rows into it:</p>

<pre data-type="programlisting" data-code-language="mysql"><strong><code class="k">USE</code><code> </code><code class="n">test</code><code class="p">;</code><code>

</code><code class="k">DROP</code><code> </code><code class="k">TABLE</code><code> </code><code class="k">IF</code><code> </code><code class="k">EXISTS</code><code> </code><code class="ss">`joinit`</code><code class="p">;</code><code>

</code><code class="k">CREATE</code><code> </code><code class="k">TABLE</code><code> </code><code class="ss">`joinit`</code><code> </code><code class="p">(</code><code>
  </code><code class="ss">`i`</code><code> </code><code class="kt">int</code><code class="p">(</code><code class="mi">11</code><code class="p">)</code><code> </code><code class="k">NOT</code><code> </code><code class="no">NULL</code><code> </code><code class="kp">AUTO_INCREMENT</code><code class="p">,</code><code>
  </code><code class="ss">`s`</code><code> </code><code class="kt">varchar</code><code class="p">(</code><code class="mi">64</code><code class="p">)</code><code> </code><code class="k">DEFAULT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code>
  </code><code class="ss">`t`</code><code> </code><code class="kt">time</code><code> </code><code class="k">NOT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code>
  </code><code class="ss">`g`</code><code> </code><code class="kt">int</code><code class="p">(</code><code class="mi">11</code><code class="p">)</code><code> </code><code class="k">NOT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code>
  </code><code class="k">PRIMARY</code><code> </code><code class="k">KEY</code><code> </code><code class="p">(</code><code class="ss">`i`</code><code class="p">)</code><code>
</code><code class="p">)</code><code> </code><code class="kp">ENGINE</code><code class="o">=</code><code class="n">InnoDB</code><code>  </code><code class="k">DEFAULT</code><code> </code><code class="kp">CHARSET</code><code class="o">=</code><code class="n">latin1</code><code class="p">;</code><code>

</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">VALUES</code><code> </code><code class="p">(</code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code>
</code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code class="p">;</code><code>
</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">SELECT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code> </code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">FROM</code><code> </code><code class="n">joinit</code><code class="p">;</code><code>
</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">SELECT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code> </code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">FROM</code><code> </code><code class="n">joinit</code><code class="p">;</code><code>
</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">SELECT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code> </code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">FROM</code><code> </code><code class="n">joinit</code><code class="p">;</code><code>
</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">SELECT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code> </code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">FROM</code><code> </code><code class="n">joinit</code><code class="p">;</code><code>
</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">SELECT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code> </code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">FROM</code><code> </code><code class="n">joinit</code><code class="p">;</code><code>
</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">SELECT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code> </code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">FROM</code><code> </code><code class="n">joinit</code><code class="p">;</code><code>
</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">SELECT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code> </code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">FROM</code><code> </code><code class="n">joinit</code><code class="p">;</code><code>
</code><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">joinit</code><code> </code><code class="k">SELECT</code><code> </code><code class="no">NULL</code><code class="p">,</code><code> </code><code class="nf">uuid</code><code class="p">(</code><code class="p">)</code><code class="p">,</code><code> </code><code class="kt">time</code><code class="p">(</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>  </code><code class="p">(</code><code class="nf">FLOOR</code><code class="p">(</code><code> </code><code class="mi">1</code><code> </code><code class="o">+</code><code> </code><code class="nf">RAND</code><code class="p">(</code><code> </code><code class="p">)</code><code> </code><code class="o">*</code><code class="mi">60</code><code> </code><code class="p">)</code><code class="p">)</code><code>
</code><code class="k">FROM</code><code> </code><code class="n">joinit</code><code class="p">;</code></strong></pre>

<p>Now that we have some dummy data, we will open one session (session 1) and execute an <code>UPDATE</code>:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">joinit</code><code> </code><code class="kt">SET</code><code> </code><code class="n">t</code><code class="o">=</code><code class="nf">now</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></strong></pre>

<p>Then, in a second session, we will try to add a new column to this table while the <code>UPDATE</code> is still running:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">ALTER</code><code> </code><code class="k">TABLE</code><code> </code><code class="n">joinit</code><code> </code><code class="k">ADD</code><code> </code><code class="k">COLUMN</code><code> </code><code class="n">b</code><code> </code><code class="kt">INT</code><code class="p">;</code></strong></pre>

<p>And in a third session, we can execute the <code>SHOW PROCESSLIST</code> command to visualize the metadata lock:<a data-type="indexterm" data-primary="metadata locks" data-secondary="SHOW PROCESSLIST" id="idm46177465223176"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="metadata locks" data-tertiary="SHOW PROCESSLIST" id="idm46177462848904"/><a data-type="indexterm" data-primary="SHOW" data-secondary="PROCESSLIST" id="idm46177462847816"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="metadata locks" data-tertiary="observing" id="ch06-obs"/><a data-type="indexterm" data-primary="metadata locks" data-secondary="observing" id="ch06-obs2"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session3</code><code class="o">&gt;</code><code> </code><strong><code class="k">SHOW</code><code> </code><code class="n">PROCESSLIST</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+----------+-----------+------+---------+------+...
| Id | User     | Host      | db   | Command | Time |...
+----+----------+-----------+------+---------+------+...
| 10 | msandbox | localhost | test | Query   |    3 |...
| 11 | msandbox | localhost | test | Query   |    1 |...
| 12 | msandbox | localhost | NULL | Query   |    0 |...
+----+----------+-----------+------+---------+------+...
...+---------------------------------+-------------------------------------+...
...| State                           | Info                                |...
...+---------------------------------+-------------------------------------+...
...| updating                        | UPDATE joinit SET t=now()           |...
...| Waiting for table metadata lock | ALTER TABLE joinit ADD COLUMN b INT |...
...| starting                        | SHOW PROCESSLIST                    |...
...+---------------------------------+-------------------------------------+...
...+-----------+---------------+
...| Rows_sent | Rows_examined |
...+-----------+---------------+
...|         0 |        179987 |
...|         0 |             0 |
...|         0 |             0 |
...+-----------+---------------+</pre>

<p>Note that a long-running query or a query that is not using autocommit will have the same effect. For example, suppose we have an <code>UPDATE</code> running in session 1:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="kt">SET</code><code> </code><code class="n">SESSION</code><code> </code><code class="n">autocommit</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.00 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">joinit</code><code> </code><code class="kt">SET</code><code> </code><code class="n">t</code><code class="o">=</code><code class="nf">NOW</code><code class="p">(</code><code class="p">)</code><code> </code><code class="k">LIMIT</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0</pre>

<p class="pagebreak-before">And we execute a DML statement in session 2:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">ALTER</code><code> </code><code class="k">TABLE</code><code> </code><code class="n">joinit</code><code> </code><code class="k">ADD</code><code> </code><code class="k">COLUMN</code><code> </code><code class="n">b</code><code> </code><code class="kt">INT</code><code class="p">;</code></strong></pre>

<p>If we check the process list in session 3, we can see the DDL waiting on the metadata lock (thread 11), while thread 10 has been sleeping since it executed the <code>UPDATE</code> (still not committed):</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">SHOW</code><code> </code><code class="n">PROCESSLIST</code><code class="p">;</code></strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>MySQL is multithreaded, so there may be many clients issuing queries for a given table simultaneously. <a data-type="indexterm" data-primary="tables" data-secondary="concurrent sessions independent" id="idm46177462953208"/><a data-type="indexterm" data-primary="performance" data-secondary="tables in concurrent sessions" id="idm46177462968024"/>To minimize the problem with multiple client sessions having different states for the same table, each concurrent session opens the table independently. This uses additional memory but typically increases performance.</p>
</div>

<p>Before we start using the <code>sys</code> schema, it is necessary to<a data-type="indexterm" data-primary="sys schema for monitoring locks" id="ch06-sys"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="sys schema for monitoring" id="ch06-sys2"/> enable MySQL instrumentation to monitor these locks. To do this, run the following command:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">performance_schema</code><code class="p">.</code><code class="n">setup_instruments</code><code> </code><code class="kt">SET</code><code> </code><code class="n">enabled</code><code> </code><code class="o">=</code><code> </code><code class="s1">'YES'</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">WHERE</code><code> </code><code class="n">NAME</code><code> </code><code class="o">=</code><code> </code><code class="s1">'wait/lock/metadata/sql/mdl'</code><code class="p">;</code></strong><code>
</code><code class="n">Query</code><code> </code><code class="n">OK</code><code class="p">,</code><code> </code><code class="mi">0</code><code> </code><code class="n">rows</code><code> </code><code class="nf">affected</code><code> </code><code class="p">(</code><code class="mi">0</code><code class="p">.</code><code class="mi">00</code><code> </code><code class="n">sec</code><code class="p">)</code><code>
</code><code class="n">Rows</code><code> </code><code class="n">matched</code><code class="p">:</code><code> </code><code class="mi">1</code><code> </code><code class="n">Changed</code><code class="p">:</code><code> </code><code class="mi">0</code><code> </code><code class="n">Warnings</code><code class="p">:</code><code> </code><code class="mi">0</code></pre>

<p>The following query uses the <code>schema_table_lock_waits</code> view from the <code>sys</code> schema to illustrate how to observe metadata locks in the MySQL database:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code>  </code><code class="k">FROM</code><code> </code><code class="n">sys</code><code class="p">.</code><code class="n">schema_table_lock_waits</code><code class="p">;</code></strong></pre>

<p>This view displays which sessions are blocked waiting on metadata locks and what is blocking them. Rather than selecting all fields, the following example shows a more compact view:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">object_name</code><code class="p">,</code><code> </code><code class="n">waiting_thread_id</code><code class="p">,</code><code> </code><code class="n">waiting_lock_type</code><code class="p">,</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">waiting_query</code><code class="p">,</code><code> </code><code class="n">sql_kill_blocking_query</code><code class="p">,</code><code> </code><code class="n">blocking_thread_id</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">FROM</code><code> </code><code class="n">sys</code><code class="p">.</code><code class="n">schema_table_lock_waits</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+-------------------+-------------------+...
| object_name | waiting_thread_id | waiting_lock_type |...
+-------------+-------------------+-------------------+...
| joinit      |                29 | EXCLUSIVE         |...
| joinit      |                29 | EXCLUSIVE         |...
+-------------+-------------------+-------------------+...
...+-------------------------------------------------------------------+...
...| waiting_query                                                     |...
...+-------------------------------------------------------------------+...
...| ALTER TABLE joinit ADD COLUMN  ...  CHAR(32) DEFAULT 'dummy_text' |...
...| ALTER TABLE joinit ADD COLUMN  ...  CHAR(32) DEFAULT 'dummy_text' |...
...|-------------------------------------------------------------------+...</pre>

<pre data-type="programlisting" class="less_space pagebreak-before">...+-------------------------+--------------------+
...| sql_kill_blocking_query | blocking_thread_id |
...+-------------------------+--------------------+
...| KILL QUERY 3            |                 29 |
...| KILL QUERY 5            |                 31 |
...+-------------------------+--------------------+
2 rows in set (0.00 sec)</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The MySQL <code>sys</code> schema is a set of objects that helps DBAs and developers interpret data collected by the Performance Schema, a feature for monitoring MySQL Server execution at a low level. It is available for MySQL 5.7 and MySQL 8.0. If you want to use the <code>sys</code> schema in MySQL 5.6, it is possible to install it using the <code>sys</code> project available on GitHub:</p>

<pre data-type="programlisting"># <strong>git clone https://github.com/mysql/mysql-sys.git</strong>
# <strong>cd mysql-sys/</strong>
# <strong>mysql -u root -p &lt; ./sys_56.sql</strong></pre>
</div>

<p>Let’s see what happens when we query the <code>metadata_locks</code> table:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">performance_schema</code><code class="p">.</code><code class="n">metadata_locks</code><code class="err">\</code><code class="n">G</code></strong></pre>

<pre data-type="programlisting">*************************** 1. row ***************************
          OBJECT_TYPE: GLOBAL
        OBJECT_SCHEMA: NULL
          OBJECT_NAME: NULL
OBJECT_INSTANCE_BEGIN: 140089691017472
            LOCK_TYPE: INTENTION_EXCLUSIVE
        LOCK_DURATION: STATEMENT
          LOCK_STATUS: GRANTED
               SOURCE:
      OWNER_THREAD_ID: 97
       OWNER_EVENT_ID: 34
...
*************************** 6. row ***************************
          OBJECT_TYPE: TABLE
        OBJECT_SCHEMA: performance_schema
          OBJECT_NAME: metadata_locks
OBJECT_INSTANCE_BEGIN: 140089640911984
            LOCK_TYPE: SHARED_READ
        LOCK_DURATION: TRANSACTION
          LOCK_STATUS: GRANTED
               SOURCE:
      OWNER_THREAD_ID: 98
       OWNER_EVENT_ID: 10
6 rows in set (0.00 sec)</pre>

<p>Note that a <code>SHARED_UPGRADABLE</code> lock is set on the <code>joinit</code> table, and an <code>EXCLUSIVE</code> lock is pending on the same table.</p>

<p>We can get a nice view of all metadata locks from other sessions, excluding our current one, with the following query:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="n">object_type</code><code class="p">,</code><code> </code><code class="n">object_schema</code><code class="p">,</code><code> </code><code class="n">object_name</code><code class="p">,</code><code> </code><code class="n">lock_type</code><code class="p">,</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">lock_status</code><code class="p">,</code><code> </code><code class="n">thread_id</code><code class="p">,</code><code> </code><code class="n">processlist_id</code><code class="p">,</code><code> </code><code class="n">processlist_info</code><code> </code><code class="k">FROM</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="n">performance_schema</code><code class="p">.</code><code class="n">metadata_locks</code><code> </code><code class="k">INNER</code><code> </code><code class="k">JOIN</code><code> </code><code class="n">performance_schema</code><code class="p">.</code><code class="n">threads</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="k">ON</code><code> </code><code class="n">thread_id</code><code> </code><code class="o">=</code><code> </code><code class="n">owner_thread_id</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">processlist_id</code><code> </code><code class="o">&lt;</code><code class="o">&gt;</code><code> </code><code class="nf">connection_id</code><code class="p">(</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-------------+---------------+-------------+---------------------+...
| OBJECT_TYPE | OBJECT_SCHEMA | OBJECT_NAME | LOCK_TYPE           |...
+-------------+---------------+-------------+---------------------+...
| GLOBAL      | NULL          | NULL        | INTENTION_EXCLUSIVE |...
| SCHEMA      | test          | NULL        | INTENTION_EXCLUSIVE |...
| TABLE       | test          | joinit      | SHARED_UPGRADABLE   |...
| BACKUP      | NULL          | NULL        | INTENTION_EXCLUSIVE |...
| TABLE       | test          | joinit      | EXCLUSIVE           |...
+-------------+---------------+-------------+---------------------+...
...+-------------+-----------+----------------+...
...| LOCK_STATUS | THREAD_ID | PROCESSLIST_ID |...
...+-------------+-----------+----------------+...
...| GRANTED     |        97 |             71 |...
...| GRANTED     |        97 |             71 |...
...| GRANTED     |        97 |             71 |...
...| GRANTED     |        97 |             71 |...
...| PENDING     |        97 |             71 |...
...+-------------+-----------+----------------+...
...+-------------------------------------+
...| PROCESSLIST_INFO                    |
...+-------------------------------------+
...| alter table joinit add column b int |
...| alter table joinit add column b int |
...| alter table joinit add column b int |
...| alter table joinit add column b int |
...| alter table joinit add column b int |
...+-------------------------------------+
5 rows in set (0.00 sec)</pre>

<p>If we look carefully, a DDL statement waiting for a query on its own is not a problem: it will have to wait until it can acquire the metadata lock, which is expected. The problem is that while waiting, it blocks every other query from accessing the resource.</p>

<p>We recommend the following actions to avoid long metadata locks:<a data-type="indexterm" data-primary="metadata locks" data-secondary="avoiding long locks" id="idm46177463273832"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="metadata locks" data-tertiary="avoiding long locks" id="idm46177463272856"/></p>

<ul>
<li>
<p>Perform DDL operations in non-busy times. This way you reduce the concurrency in the database between the regular application workload and the extra workload that the operation carries.</p>
</li>
<li>
<p>Always use autocommit. MySQL has autocommit enabled by default. This will avoid transactions with pending commits.<a data-type="indexterm" data-primary="committing transactions" data-secondary="autocommit always" id="idm46177463269448"/><a data-type="indexterm" data-primary="autocommit always" id="idm46177463278440"/><a data-type="indexterm" data-primary="defaults" data-secondary="transactions autocommit" id="idm46177463277768"/></p>
</li>
<li>
<p>When performing a DDL operation, set a low value for <code>lock_wait_timeout</code> at the session level. <a data-type="indexterm" data-primary="lock_wait_timeout" id="idm46177463275576"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="metadata locks" data-tertiary="lock_wait_timeout" id="idm46177463274840"/><a data-type="indexterm" data-primary="SET command" data-secondary="lock_wait_timeout" id="idm46177463289144"/>Then, if the metadata lock can’t be acquired, it won’t block for a long time waiting. For example:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="kt">SET</code><code> </code><code class="n">lock_wait_timeout</code><code> </code><code class="o">=</code><code> </code><code class="mi">3</code><code class="p">;</code></strong><code>
</code><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">CREATE</code><code> </code><code class="k">INDEX</code><code> </code><code class="n">idx_1</code><code> </code><code class="k">ON</code><code> </code><code class="nf">example</code><code> </code><code class="p">(</code><code class="n">col1</code><code class="p">)</code><code class="p">;</code></strong></pre>
</li>
</ul>

<p>You might also want to consider using the <a href="https://oreil.ly/C4rMb"><code>pt-kill</code> tool</a> to kill queries that have been running for a long time. For example, to kill queries that have been running for more than 60 seconds, issue this command:<a data-type="indexterm" data-startref="ch06-mdl" id="idm46177463320904"/><a data-type="indexterm" data-startref="ch06-mdl2" id="idm46177463320200"/><a data-type="indexterm" data-startref="ch06-obs" id="idm46177463319528"/><a data-type="indexterm" data-startref="ch06-obs2" id="idm46177463318856"/><a data-type="indexterm" data-startref="ch06-sys" id="idm46177463318184"/><a data-type="indexterm" data-startref="ch06-sys2" id="idm46177463333592"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="err">$</code><code> </code><strong><code class="n">pt</code><code class="o">-</code><code class="k">kill</code><code> </code><code class="o">-</code><code class="o">-</code><code class="n">busy</code><code class="o">-</code><code class="kt">time</code><code> </code><code class="mi">60</code><code> </code><code class="o">-</code><code class="o">-</code><code class="k">kill</code></strong></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Row Locks"><div class="sect2" id="idm46177463351816">
<h2>Row Locks</h2>

<p>InnoDB implements standard row-level locking. This means that, in general terms, there are two types of locks:<a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="row locks" id="ch06-ro"/><a data-type="indexterm" data-primary="row locks" id="ch06-ro2"/></p>

<ul>
<li>
<p>A <em>shared</em> (S) lock permits the transaction that holds the lock to read a row.<a data-type="indexterm" data-primary="row locks" data-secondary="shared locks" id="idm46177463347960"/><a data-type="indexterm" data-primary="shared locks" id="idm46177463346984"/></p>
</li>
<li>
<p>An <em>exclusive</em> (X) lock permits the transaction that holds the lock to update or delete a row.<a data-type="indexterm" data-primary="row locks" data-secondary="exclusive locks" id="idm46177463366824"/><a data-type="indexterm" data-primary="exclusive locks" id="idm46177463365816"/></p>
</li>
</ul>

<p>The names are self-explanatory: exclusive locks don’t allow multiple transactions to acquire an exclusive lock in the same row while sharing a shared lock. That is why it is possible to have parallel reads for the same row, while parallel writes are not allowed.</p>

<p>InnoDB also supports multiple granularity locking, which permits the coexistence of row locks and table locks. <a data-type="indexterm" data-primary="InnoDB" data-secondary="transactions" data-tertiary="locking granular" id="idm46177463363672"/><a data-type="indexterm" data-primary="intention locks" id="idm46177463362424"/>Granular locking is possible due to the existence of <em>intention locks</em>, which are table-level locks that indicate which type of lock (shared or exclusive) a transaction requires later for a row in a table. There are two types of intention locks:</p>

<ul>
<li>
<p>An <em>intention shared</em> (IS) lock indicates that a transaction intends to set a shared lock on individual rows in a table.<a data-type="indexterm" data-primary="shared locks" data-secondary="intention shared locks" id="idm46177463359128"/><a data-type="indexterm" data-primary="row locks" data-secondary="shared locks" data-tertiary="intention shared locks" id="idm46177463358152"/><a data-type="indexterm" data-primary="intention locks" data-secondary="intention shared locks" id="idm46177463356936"/></p>
</li>
<li>
<p>An <em>intention exclusive</em> (IX) lock indicates that a transaction intends to set an exclusive lock on individual rows in a table.<a data-type="indexterm" data-primary="exclusive locks" data-secondary="intention exclusive locks" id="idm46177463370696"/><a data-type="indexterm" data-primary="row locks" data-secondary="exclusive locks" data-tertiary="intention exclusive locks" id="idm46177463369752"/><a data-type="indexterm" data-primary="intention locks" data-secondary="intention exclusive locks" id="idm46177463368568"/></p>
</li>
</ul>

<p>Before a transaction can acquire a shared or an exclusive lock, it is necessary to obtain the respective intention lock (IS or IX).</p>

<p>To make things a bit easier to understand, take a look at <a data-type="xref" href="#table0601">Table 6-1</a>.</p>
<table id="table0601">
<caption><span class="label">Table 6-1. </span>Lock type compatibility matrix</caption>
<thead>
<tr>
<th/>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>X</p></td>
<td><p>Conflict</p></td>
<td><p>Conflict</p></td>
<td><p>Conflict</p></td>
<td><p>Conflict</p></td>
</tr>
<tr>
<td><p>IX</p></td>
<td><p>Conflict</p></td>
<td><p>Compatible</p></td>
<td><p>Conflict</p></td>
<td><p>Compatible</p></td>
</tr>
<tr>
<td><p>S</p></td>
<td><p>Conflict</p></td>
<td><p>Conflict</p></td>
<td><p>Compatible</p></td>
<td><p>Compatible</p></td>
</tr>
<tr>
<td><p>IS</p></td>
<td><p>Conflict</p></td>
<td><p>Compatible</p></td>
<td><p>Compatible</p></td>
<td><p>Compatible</p></td>
</tr>
</tbody>
</table>

<p>Another important concept is the <em>gap lock</em>, which is a lock on<a data-type="indexterm" data-primary="gap locks" id="idm46177465183224"/><a data-type="indexterm" data-primary="row locks" data-secondary="gap locks" id="idm46177465182488"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="row locks" data-tertiary="gap locks" id="idm46177465181544"/> the gap between index records. Gap locks ensure that no new rows are added in the interval specified by the query; this means that when you run the same query twice, you get the same number of rows, regardless of other sessions’ modifications to that table. They make the reads consistent and therefore make the replication between servers consistent. If you execute <code>SELECT * FROM example_table WHERE id &gt; 1000 FOR UPDATE</code> twice, you expect to get the same result twice. To accomplish that, InnoDB locks all index records found by the <code>WHERE</code> clause with an exclusive lock and the gaps between them with a shared gap lock.</p>

<p>Let’s see an example of a gap lock in action. First, we will execute a <code>SELECT</code> statement on the <code>person</code> table:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">PERSON</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+-----------+
| i  | name      |
+----+-----------+
|  1 | Vinicius  |
|  2 | Kuzmichev |
|  3 | Iwo       |
|  4 | Peter     |
|  5 | Marcelo   |
|  6 | Guli      |
|  7 | Nando     |
| 10 | Jobin     |
| 15 | Rafa      |
| 18 | Leo       |
+----+-----------+
10 rows in set (0.00 sec)</pre>

<p>Now, in session 1, we will perform a delete operation, but we will <em>not</em> commit:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">DELETE</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">name</code><code> </code><code class="k">LIKE</code><code> </code><code class="s1">'Jobin'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)</pre>

<p class="pagebreak-before">And if we check in session 2, we can still see the row with Jobin:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+----+-----------+
| i  | name      |
+----+-----------+
|  1 | Vinicius  |
|  2 | Kuzmichev |
|  3 | Iwo       |
|  4 | Peter     |
|  5 | Marcelo   |
|  6 | Guli      |
|  7 | Nando     |
| 10 | Jobin     |
| 15 | Rafa      |
| 18 | Leo       |
+----+-----------+
10 rows in set (0.00 sec)</pre>

<p>The results show that there are gaps in the values of the primary key column that in theory are available to be used to insert new records. So what happens if we try to insert a new row with a value of 11? The insert will be locked and will fail:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">transaction2</code><code> </code><code class="o">&gt;</code><code> </code><strong><code class="k">INSERT</code><code> </code><code class="k">INTO</code><code> </code><code class="n">person</code><code> </code><code class="k">VALUES</code><code> </code><code class="p">(</code><code class="mi">11</code><code class="p">,</code><code> </code><code class="s1">'Bennie'</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">ERROR 1205 (HY000): Lockwait timeout exceeded; try restarting transaction</pre>

<p>If we run <code>SHOW ENGINE INNODB STATUS</code>, we will see the locked transaction in the <code>TRANSACTIONS</code> section:<a data-type="indexterm" data-primary="SHOW" data-secondary="ENGINE INNODB STATUS" id="idm46177463490408"/><a data-type="indexterm" data-primary="transactions" data-secondary="SHOW ENGINE INNODB STATUS" id="idm46177463489400"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="SHOW ENGINE INNODB STATUS" id="idm46177463505816"/><a data-type="indexterm" data-primary="InnoDB" data-secondary="transactions" data-tertiary="SHOW ENGINE INNODB STATUS" id="idm46177463504936"/></p>

<pre data-type="programlisting">------- TRX HAS BEEN WAITING 17 SEC FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 28 page no 3 n bits 80 index PRIMARY of table
`test`.`person` trx id 4773 lock_mode X locks gap before rec insert
intention waiting</pre>

<p>Note that MySQL does not need gap locking for statements that lock rows using a unique index to search for a unique row. (This does not include the case where the search condition includes only some columns of a multiple-column unique index; in that case, gap locking does occur.) For example, if the <code>name</code> column has a unique index, the following <code>DELETE</code> statement uses only an index-record lock:<a data-type="indexterm" data-startref="ch06-ro" id="idm46177463501288"/><a data-type="indexterm" data-startref="ch06-ro2" id="idm46177463500248"/></p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">CREATE</code><code> </code><code class="k">UNIQUE</code><code> </code><code class="k">INDEX</code><code> </code><code class="n">idx</code><code> </code><code class="k">ON</code><code> </code><code class="nf">PERSON</code><code> </code><code class="p">(</code><code class="n">name</code><code class="p">)</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.01 sec)
Records: 0  Duplicates: 0  Warnings: 0</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">DELETE</code><code> </code><code class="k">FROM</code><code> </code><code class="n">person</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">name</code><code> </code><code class="k">LIKE</code><code> </code><code class="s1">'Jobin'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Deadlocks"><div class="sect2" id="idm46177463341032">
<h2>Deadlocks</h2>

<p>A <em>deadlock</em> is a situation where two (or more) competing<a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="deadlocks" id="ch06-dea"/><a data-type="indexterm" data-primary="deadlocks" id="ch06-dea2"/> actions are waiting for the other to finish. As a consequence, neither ever does. In computer science, the term refers to a specific condition where two or more processes are each waiting for another to release a resource. In this section, we will talk specifically about transaction deadlocks and how InnoDB solves this issue.</p>

<p>For a deadlock to happen, four conditions (known as the <em>Coffman conditions</em>) must exist:<a data-type="indexterm" data-primary="Coffman conditions" id="idm46177463559512"/><a data-type="indexterm" data-primary="deadlocks" data-secondary="Coffman conditions" id="idm46177463558776"/></p>
<ol>
<li>
<p><em>Mutual exclusion</em>. The process must hold at least one resource in a non-shareable mode. Otherwise, MySQL would not prevent the process from using the resource when necessary. Only one process can use the resource at any given moment in time.</p>
</li>
<li>
<p><em>Hold and wait or resource holding</em>. A process is currently holding at least one resource and requesting additional resources held by other processes.</p>
</li>
<li>
<p><em>No preemption</em>. A resource can be released only voluntarily by the process holding it.</p>
</li>
<li>
<p><em>Circular wait</em>. Each process must be waiting for a resource held by another process, which in turn is waiting for the first process to release the resource.</p>
</li>

</ol>

<p>Before moving on to an example, there are some<a data-type="indexterm" data-primary="deadlocks" data-secondary="misconceptions" id="idm46177463563384"/> misconceptions that you might hear and that it is essential to clarify. They are:</p>
<dl>
<dt>Transaction isolation levels are responsible for deadlocks.</dt>
<dd>
<p>The possibility of deadlocks is not affected by the isolation<a data-type="indexterm" data-primary="isolation levels" data-secondary="deadlock possibility and" id="idm46177463578504"/> level. The <code>READ COMMITTED</code> isolation level sets fewer locks, and hence it can help you avoid certain lock types (e.g., gap locking), but it won’t prevent deadlocks entirely.</p>
</dd>
<dt>Small transactions are not affected by deadlocks.</dt>
<dd>
<p>Small transactions are less prone to deadlocks because they run fast, so the chance of a conflict occurring is smaller than with more prolonged operations. However, it can still happen if transactions do not use the same order of operations.</p>
</dd>
<dt>Deadlocks are terrible things.</dt>
<dd>
<p>It’s problematic to have deadlocks in a database, but InnoDB can resolve them automatically, <a data-type="indexterm" data-primary="deadlocks" data-secondary="innodb_deadlock_detect" id="idm46177463573704"/><a data-type="indexterm" data-primary="innodb_deadlock_detect" id="idm46177463572440"/><a data-type="indexterm" data-primary="innodb_lock_wait_timeout" id="idm46177463571768"/><a data-type="indexterm" data-primary="deadlocks" data-secondary="innodb_lock_wait_timeout" id="idm46177463571128"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="innodb_lock_wait_timeout" id="idm46177463570216"/>unless deadlock detection is disabled (by changing the value of <code>innodb_deadlock_detect</code>). A deadlock is a a bad situation, but resolution through the termination of one of the transactions ensures that processes cannot hold onto the resources for a long time, slowing or stalling the database completely until the offending query gets canceled by the <code>innodb_lock_wait_timeout</code> setting.</p>
</dd>
</dl>

<p>To illustrate deadlocks, we’ll use the <code>world</code> database. If you need to import it, you can do so now by following the instructions in <a data-type="xref" href="ch02.xhtml#BAS-SEC-MODELING-EXAMPLES">“Entity Relationship Modeling Examples”</a>.</p>

<p>Let’s start by getting a list of Italian cities in the province of Toscana:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SELECT</code><code> </code><code class="o">*</code><code> </code><code class="k">FROM</code><code> </code><code class="n">city</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">CountryCode</code><code> </code><code class="o">=</code><code> </code><code class="s1">'ITA'</code><code> </code><code class="k">AND</code><code> </code><code class="n">District</code><code class="o">=</code><code class="s1">'Toscana'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+------+---------+-------------+----------+------------+
| ID   | Name    | CountryCode | District | Population |
+------+---------+-------------+----------+------------+
| 1471 | Firenze | ITA         | Toscana  |     376662 |
| 1483 | Prato   | ITA         | Toscana  |     172473 |
| 1486 | Livorno | ITA         | Toscana  |     161673 |
| 1516 | Pisa    | ITA         | Toscana  |      92379 |
| 1518 | Arezzo  | ITA         | Toscana  |      91729 |
+------+---------+-------------+----------+------------+
5 rows in set (0.00 sec)</pre>

<p>Now let’s say we have two transactions trying to update the populations of the same two cities in Toscana at the same time, but in different orders:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">city</code><code> </code><code class="kt">SET</code><code> </code><code class="n">Population</code><code class="o">=</code><code class="n">Population</code><code> </code><code class="o">+</code><code> </code><code class="mi">1</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">ID</code><code> </code><code class="o">=</code><code> </code><code class="mi">1471</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">city</code><code> </code><code class="kt">SET</code><code> </code><code class="n">Population</code><code class="o">=</code><code class="n">Population</code><code> </code><code class="o">+</code><code> </code><code class="mi">1</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">ID</code><code> </code><code class="o">=</code><code class="mi">1516</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (0.00 sec)
Rows matched: 1  Changed: 1  Warnings: 0</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session1</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">city</code><code> </code><code class="kt">SET</code><code> </code><code class="n">Population</code><code class="o">=</code><code class="n">Population</code><code> </code><code class="o">+</code><code> </code><code class="mi">1</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">ID</code><code> </code><code class="o">=</code><code class="mi">1516</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">session2</code><code class="o">&gt;</code><code> </code><strong><code class="k">UPDATE</code><code> </code><code class="n">city</code><code> </code><code class="kt">SET</code><code> </code><code class="n">Population</code><code class="o">=</code><code class="n">Population</code><code> </code><code class="o">+</code><code> </code><code class="mi">1</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">ID</code><code> </code><code class="o">=</code><code> </code><code class="mi">1471</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 1 row affected (5.15 sec)
Rows matched: 1  Changed: 1  Warnings: 0</pre>

<p>And we had a deadlock in session 1. It is important to note that it is not always the second transaction that will fail. In this example, session 1 was the one that MySQL aborted. We can get information on the latest deadlock that happened in the MySQL database by running <code>SHOW ENGINE INNODB STATUS</code>:</p>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SHOW</code><code> </code><code class="kp">ENGINE</code><code> </code><code class="n">INNODB</code><code> </code><code class="n">STATUS</code><code class="err">\</code><code class="n">G</code></strong></pre>

<pre data-type="programlisting">------------------------
LATEST DETECTED DEADLOCK
------------------------
2020-12-05 16:08:19 0x7f6949359700
*** (1) TRANSACTION:
TRANSACTION 10502342, ACTIVE 34 sec starting index read
mysql tables in use 1, locked 1
LOCK WAIT 3 lock struct(s), heap size 1136, 2 row lock(s), undo log
entries 1
MySQL thread id 71, OS thread handle 140090386671360, query id 5979282
localhost msandbox updating
update city set Population=Population + 1 where ID = 1471
*** (1) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 6041 page no 15 n bits 248 index PRIMARY of table
`world`.`city` trx id 10502342 lock_mode X locks rec but not gap waiting
*** (2) TRANSACTION:
TRANSACTION 10502341, ACTIVE 62 sec starting index read
mysql tables in use 1, locked 1
3 lock struct(s), heap size 1136, 2 row lock(s), undo log entries 1
MySQL thread id 75, OS thread handle 140090176542464, query id 5979283
localhost msandbox updating
update city set Population=Population + 1 where ID =1516
*** (2) HOLDS THE LOCK(S):
RECORD LOCKS space id 6041 page no 15 n bits 248 index PRIMARY of table
`world`.`city` trx id 10502341 lock_mode X locks rec but not gap
*** (2) WAITING FOR THIS LOCK TO BE GRANTED:
RECORD LOCKS space id 6041 page no 16 n bits 248 index PRIMARY of table
`world`.`city` trx id 10502341 lock_mode X locks rec but not gap waiting
*** WE ROLL BACK TRANSACTION (2)
...</pre>

<p>If you want, you can log all the deadlocks that happen in MySQL in the MySQL error log. <a data-type="indexterm" data-primary="deadlocks" data-secondary="innodb_print_all_deadlocks" id="idm46177463765992"/><a data-type="indexterm" data-primary="innodb_print_all_deadlocks" id="idm46177463752824"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="deadlocks" data-tertiary="logging in MySQL error log" id="idm46177466376920"/><a data-type="indexterm" data-primary="deadlocks" data-secondary="logging in MySQL error log" id="idm46177466375768"/><a data-type="indexterm" data-primary="MySQL" data-secondary="error log deadlock logging" id="idm46177466374856"/>Using the <code>innodb_print_all_deadlocks</code> parameter, MySQL records all information about deadlocks from InnoDB user transactions in the error log. Otherwise, you see information about only the last deadlock using the <code>SHOW ENGINE INNODB STATUS</code> command.<a data-type="indexterm" data-startref="ch06-dea" id="idm46177463777480"/><a data-type="indexterm" data-startref="ch06-dea2" id="idm46177463776776"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="MySQL Parameters Related to Isolation and Locks"><div class="sect1" id="idm46177465255384">
<h1>MySQL Parameters Related to Isolation and Locks</h1>

<p>To round out this chapter, let’s take a look at a few MySQL parameters that are related to isolation behavior and lock duration:</p>
<dl>
<dt><code>transaction_isolation</code></dt>
<dd>
<p>Sets the transaction isolation level. This parameter can change<a data-type="indexterm" data-primary="transactions" data-secondary="transaction_isolation" id="idm46177463773160"/><a data-type="indexterm" data-primary="transaction_isolation" id="idm46177463785144"/><a data-type="indexterm" data-primary="SET command" data-secondary="transaction isolation levels" id="idm46177463784472"/><a data-type="indexterm" data-primary="SHOW" data-secondary="SESSION VARIABLES" id="idm46177463783560"/><a data-type="indexterm" data-primary="variables" data-secondary="SHOW SESSION VARIABLES" id="idm46177463782616"/> the behavior at the <code>GLOBAL</code>, <code>SESSION</code>, or <code>NEXT_TRANSACTION</code> level:</p>
</dd>
</dl>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="kt">SET</code><code> </code><code class="n">SESSION</code><code> </code><code class="n">transaction_isolation</code><code class="o">=</code><code class="s1">'READ-COMMITTED'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">Query OK, 0 rows affected (0.00 sec)</pre>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">SHOW</code><code> </code><code class="n">SESSION</code><code> </code><code class="n">VARIABLES</code><code> </code><code class="k">LIKE</code><code> </code><code class="s1">'%isol%'</code><code class="p">;</code></strong></pre>

<pre data-type="programlisting">+-----------------------+----------------+
| Variable_name         | Value          |
+-----------------------+----------------+
| transaction_isolation | READ-COMMITTED |
| tx_isolation          | READ-COMMITTED |
+-----------------------+----------------+</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><code>transaction_isolation</code> was added in MySQL 5.7.20 as a<a data-type="indexterm" data-primary="tx_isolation deprecated" id="idm46177463814168"/> synonym for <code>tx_isolation</code>, which is now deprecated and has been removed in MySQL 8.0. Applications should be adjusted to use 
<span class="keep-together"><code>transaction_isolation</code></span> in preference to <code>tx_isolation</code>.</p>
</div>
<dl>
<dt><code>innodb_lock_wait_timeout</code></dt>
<dd>
<p>Specifies the amount of time in seconds an InnoDB transaction<a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="innodb_lock_wait_timeout" id="idm46177463850200"/><a data-type="indexterm" data-primary="innodb_lock_wait_timeout" id="idm46177463849288"/><a data-type="indexterm" data-primary="deadlocks" data-secondary="innodb_lock_wait_timeout" id="idm46177463848648"/> waits for a row lock before giving up. The default value is 50 seconds. The transaction raises 
<span class="keep-together">the following</span> error if the time waiting for the lock exceeds the <code>innodb_lock_wait_timeout</code> value:</p>
</dd>
</dl>

<pre data-type="programlisting">ERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction</pre>
<dl>
<dt><code>innodb_print_all_deadlocks</code></dt>
<dd>
<p>Causes MySQL to record information about all deadlocks<a data-type="indexterm" data-primary="innodb_print_all_deadlocks" id="idm46177463843224"/><a data-type="indexterm" data-primary="deadlocks" data-secondary="innodb_print_all_deadlocks" id="idm46177463842456"/><a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="deadlocks" data-tertiary="logging in MySQL error log" id="idm46177463841496"/><a data-type="indexterm" data-primary="SET command" data-secondary="innodb_print_all_deadlocks" id="idm46177463840248"/> resulting from InnoDB user transactions in the MySQL error log. We can enable this dynamically with the following command:</p>
</dd>
</dl>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="kt">SET</code><code> </code><code class="n">GLOBAL</code><code> </code><code class="n">innodb_print_all_deadlocks</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code class="p">;</code></strong></pre>
<dl>
<dt><code>lock_wait_timeout</code></dt>
<dd>
<p>Specifies the timeout in seconds for attempts to acquire<a data-type="indexterm" data-primary="locks for transaction isolation" data-secondary="metadata locks" data-tertiary="lock_wait_timeout" id="idm46177463872280"/><a data-type="indexterm" data-primary="lock_wait_timeout" id="idm46177463871176"/><a data-type="indexterm" data-primary="SET command" data-secondary="lock_wait_timeout" id="idm46177463870504"/> metadata locks. To avoid long metadata locks stalling the database, we can set <code>lock_wait_timeout=1</code> at the session level before executing the DDL statement. In this case, if the operation can’t acquire the lock, it will give up and let other requests execute. For example:</p>
</dd>
</dl>

<pre data-type="programlisting" data-code-language="mysql"><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="kt">SET</code><code> </code><code class="n">SESSION</code><code> </code><code class="n">lock_wait_timeout</code><code class="o">=</code><code class="mi">1</code><code class="p">;</code></strong><code>
</code><code class="n">mysql</code><code class="o">&gt;</code><code> </code><strong><code class="k">CREATE</code><code> </code><code class="k">TABLE</code><code> </code><code class="nf">t1</code><code class="p">(</code><code class="n">i</code><code> </code><code class="kt">INT</code><code> </code><code class="k">NOT</code><code> </code><code class="no">NULL</code><code> </code><code class="kp">AUTO_INCREMENT</code><code> </code><code class="k">PRIMARY</code><code> </code><code class="k">KEY</code><code class="p">)</code></strong><code>
    </code><code class="o">-</code><code class="o">&gt;</code><code> </code><strong><code class="kp">ENGINE</code><code class="o">=</code><code class="n">InnoDB</code><code class="p">;</code></strong></pre>
<dl>
<dt><code>innodb_deadlock_detect</code></dt>
<dd>
<p>Disables deadlock monitoring. Note that this only means that<a data-type="indexterm" data-primary="innodb_deadlock_detect" id="idm46177463934392"/><a data-type="indexterm" data-primary="deadlocks" data-secondary="innodb_deadlock_detect" id="idm46177463933784"/> MySQL will not kill a query to undo the deadlock knot. Disabling deadlock detection will <em>not</em> prevent deadlocks from happening, but it will make MySQL rely on the <code>innodb_lock_wait_timeout</code> setting for transaction rollback when a deadlock occurs.</p>
</dd>
</dl>
</div></section>







</div></section></div></body></html>