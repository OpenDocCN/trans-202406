- en: Chapter 7\. Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two broad categories of types in JavaScript. On one side is a small
    set of *primitive* types, like strings and numbers. On the other side are genuine
    objects, all of which derive from JavaScript’s `Object`.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript’s built-in objects are easy to recognize. They have constructors,
    and you’ll usually instantiate them with the `new` keyword. Basic ingredients
    like arrays, `Date`, error objects, `Map` and `Set` collections, and `RegExp`
    regular expressions are all objects.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript objects also differ in important ways from the objects you find in
    traditional object-oriented programming languages. For example, JavaScript allows
    you to create instances of the base `Object` type, and attach new properties and
    functions at runtime. In fact, you can take a live object—any object—and modify
    its members, with no need to respect a class definition.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter you’ll take a closer look at the functionality and quirks of
    JavaScript’s `Object` type. You’ll see how to use the core `Object` features to
    inspect, extend, and copy objects of all types. And in the next chapter, you’ll
    go one step further and learn the best practices for formalizing your own custom
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if an Object Is a Certain Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have a mystery object and you want to determine its type.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `instanceof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test if an object is *not* an instance of some type using the not operator
    (`!`). But make sure you use parentheses to apply the `!` to the entire `instanceof`
    condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s one gap in the `instanceof` operator. It doesn’t work with primitive
    values, like numbers, strings, Booleans, `BigInt` values, `null`, and `undefined`.
    Here’s a demonstration of the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The solution is to use the `typeof` operator if you’re testing a variable that
    might hold one of the primitive data types. Unlike `instanceof`, `typeof` provides
    you with one of nine predefined string values (as described in [“Checking for
    an Existing, Nonempty String”](ch02.html#checking_existing_nonempty_string)).
    If you get a value of `object`, you can use the `instanceof` operator to dig deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `instanceof` operator works by inspecting an object’s *prototype chain*,
    a concept explained in [“Extra: Prototype Chains”](ch08.html#prototype_chains).
    Depending on how an object is constructed, there can be several types in the prototype
    chain (similar to the way an object in a traditional OOP language might inherit
    from a sequence of classes). For example, every object has the `Object` prototype
    at the base of its chain, so this is always true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Remember, primitives don’t just include numbers, strings, and Booleans. They
    encompass the specialized `BigInt` and `Symbol`, and the special values `null`
    and `undefined`. All of these values will return `false` if you use the `instanceof
    Object` test.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Object Literal to Bundle Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to group several variables together to create a basic data package.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the *object literal* syntax to create a new instance of the `Object` type.
    You don’t use the `new` keyword or even name the `Object` type. Instead, you simply
    write a set of `{}` braces that encloses a comma-separated list of properties.
    Each property consists of a property name, followed by a colon, followed by the
    property value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, you can add additional properties after creating the object, as
    with any JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This technique works even if you’ve declared your object with `const`, because
    object literals are *reference types*, not values (unlike structs in other languages).
    Adding a property changes the object, but it doesn’t change the reference. (On
    the other hand, assigning the `employee` variable to a new object wouldn’t be
    allowed in this example, because that operation would change the reference.)
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Object literal syntax gives you the cleanest, most compact way to quickly create
    a simple object. However, it’s just a shortcut for explicitly creating a new `Object`
    instance and assigning properties, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'or you can use key-value syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'One of the nicer features of object literal syntax is the way it handles nested
    objects, like `birthPlace` in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In JavaScript’s eyes, an object literal is an instance of the base `Object`
    type. This simplicity makes it easy to create an object out of any ad hoc grouping
    of data, but it also has a cost—your object has no meaningful *identity*.
  prefs: []
  type: TYPE_NORMAL
- en: Yes, you can test if an object has a certain property ([“Checking If an Object
    Has a Property”](#checking_object_for_property)) or enumerate all its properties
    ([“Iterating Over All the Properties of an Object”](#iterating_all_object_properties)).
    But you can’t use `instanceof` to test against a custom object type. In other
    words, there’s no contract to program against, and no easy way to validate that
    your objects are what you expect. If you need to use more durable objects that
    are passed around your code, model complex entities, and include their own methods,
    you should consider using formal classes ([“Creating a Reusable Class”](ch08.html#using_es6_classes)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It might occur to you that you could streamline the object creation process
    by creating a factory function that accepts parameters and builds the corresponding
    object. While there’s nothing inherently wrong with this approach, there’s a more
    powerful and conventional alternative. As soon as you want to build multiple objects
    with the same structure, consider using classes ([“Creating a Reusable Class”](ch08.html#using_es6_classes)).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find all the properties on an object literal, see [“Iterating Over All the
    Properties of an Object”](#iterating_all_object_properties). To step up to a formal
    class definition, see [“Creating a Reusable Class”](ch08.html#using_es6_classes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Computed Property Names'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you know, you can add a new property to any JavaScript object in two ways.
    You can use dot-syntax with property names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Or key-value syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These two approaches aren’t equivalent. When you use key-value syntax, the property
    name is stored as a string, which means you have the opportunity to generate the
    property name at runtime. This is called a *computed property name*, and it’s
    important in certain extensibility scenarios. (For example, imagine if you’re
    fetching some external data and using that to create a matching object.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Computed property names are always converted to strings. They support characters
    that wouldn’t be allowed in ordinary variable names, like spaces. For example,
    this is possible (although it’s a very bad idea):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Object literal syntax also allows you to created computed properties. But because
    it doesn’t use a format with string key names, you need to enclose each computed
    property name in square brackets. Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you’re creating property names dynamically, you may run into a situation
    where you need to ensure your property name is unique. Various homemade workarounds
    are possible: checking for the property and adding a sequence number until you
    get something unique, or just using a GUID (globally unique identifer). But JavaScript
    provides a built-in solution with the `Symbol` type, which is your best bet (see
    [“Creating Absolutely Unique Object Property Keys”](#symbol_properties_unique)).'
  prefs: []
  type: TYPE_NORMAL
- en: Checking If an Object Has a Property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to check at runtime if an object has a given property.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `in` operator to look for a property by name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you attempt to read a property that doesn’t exist, you get the value `undefined`.
    You could test for `undefined`, but that alone is not an ironclad guarantee that
    the property doesn’t exist. (It’s technically possible to have a property and
    set it to `undefined`, in which case the property still exists but your test would
    miss it.) A better approach to finding properties is using the `in` operator.
  prefs: []
  type: TYPE_NORMAL
- en: The `in` operator searches an object *and* its prototype chain. That means if
    you create an object `Dog` that derives from another object `Animal`, an `in`
    test will return `true` if a property is defined in `Dog` or `Animal`. Alternatively,
    you can use the `hasOwnProperty()` method, which only searches the current object,
    and ignores inherited properties.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For more information about using inheritance, see [“Inheriting Functionality
    from Another Class”](ch08.html#custom_class_inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Iterating Over All the Properties of an Object”](#iterating_all_object_properties)
    shows how to retrieve all the properties of an object into an array. [“Testing
    for an Empty Object”](#testing_for_empty_object) shows how to test if your object
    is empty of all data.'
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Over All the Properties of an Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to examine all the properties in an object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the static `Object.keys()` method to get an array with the property names
    for your object. For example, this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'creates this console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This technique—examining an object, finding all its properties, and displaying
    them—is similar to what the `console.log()` method does when you pass it an object.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using `Object.keys()`, you retrieve all the property names (also known
    as *keys*). But you still need to look up the corresponding value in the object.
    You can’t use the dot syntax to do that (`object.propertyName`) because you have
    the property as a string. Instead, you use the array-like indexer syntax (`object['propertyName']`).
    Properties will typically appear in the order they were defined, but JavaScript
    doesn’t guarantee the order.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Object.keys()` method is also commonly used to count the number of properties
    (or *length*) of an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Object.keys()` method is just one of many possible solutions for reflecting
    on JavaScript objects. However, it’s a good default starting point because it
    ignores inherited properties and nonenumerable properties, which is the behavior
    you want in most scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to use a `for...in` loop, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `for...in` loop travels up the prototype chain to find properties that your
    object has inherited. In this example, with the object literal named `address`,
    there’s no difference. However, if you need to reflect on objects often, inadvertently
    using `for...in` loops when `Object.keys()` would suffice could adversely affect
    `performance`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Contrary to what you might expect, the `for...in` loop has slightly different
    coverage than the `in` operator. The `in` operator examines *all* properties,
    including nonenumerable properties, symbol properties, and inherited properties.
    The `for...in` loop finds inherited properties but ignores nonenumerable properties
    and symbol properties.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript also has other, more specialized functions that find different subsets
    of properties. For example, the `getOwnPropertyNames()` function ignores inherited
    properties, and the `getOwnPropertyDescriptors()` function ignores inherited properties
    but also finds nonenumerable properties and symbol properties, which are often
    used for extensibility (see [“Creating Absolutely Unique Object Property Keys”](#symbol_properties_unique)).
    [Table 7-1](#enumerate_properties) outlines these different approaches. For even
    more detailed information, the Mozilla Developer Network has a full accounting
    of the [different property searching functions](https://oreil.ly/rbd7z).
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-1\. Different ways to find object properties
  prefs: []
  type: TYPE_NORMAL
- en: '| Method | Returns | Gets enumerable properties | Gets non-enumerable properties
    | Gets symbol properties | Includes inherited properties |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.keys()` | An array of property names | Yes | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.values()` | An array of property values | Yes | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.entries()` | An array of property arrays, each of which holds a property
    name and the corresponding value | Yes | No | No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnPropertyNames()` | An array of property names | Yes | Yes |
    No | No |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnProperty​Sym⁠bols()` | An array of property names | No | No
    | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `Object.getOwnProperty​De⁠scriptors()` | An array of property descriptor
    objects, like when you use `defineProperty()` ([“Customizing the Way a Property
    Is Defined”](#creating_properties_with_define_property)) | Yes | Yes | Yes | No
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Reflect.ownKeys()` | An array of property names | Yes | Yes | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| `for...in` loop | Each property name | Yes | No | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Checking If an Object Has a Property”](#checking_object_for_property) explains
    how to use the `in` operator to check for a single property.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing for an Empty Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to determine if an object is empty (has no properties).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Get an array of properties using `Object.keys()`, and check for a `length`
    of 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s possible to create an empty object with object literal syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'or by creating an instance of `Object` with `new`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Empty objects can also come about from other, less common, methods, such as
    taking an existing object and removing properties with the `delete` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because objects are reference types, you can’t just compare one empty object
    to another. For example, this test won’t recognize that your unknown object is
    empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Many JavaScript libraries, like Underscore and Lodash, provide an `isEmpty()`
    method for checking objects. However, the `Object.keys()` test is just as easy.
  prefs: []
  type: TYPE_NORMAL
- en: Merging the Properties of Two Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve created two simple objects with properties, and you want to combine their
    data into a single object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the spread operator (`...`) to expand both objects, and assign them to
    a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Merging two objects is an easy operation, but not without potential problems.
    If both objects have properties with the same name, the properties from the second
    object (that’s `address` in the previous example) will quietly overwrite the properties
    from the first object. Here’s a modified version of the example that demonstrates
    the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, there are two instances of the `country` property. When the
    two objects are merged, the `customer` object is expanded first, followed by the
    `address` object. As a result, the `address.country` property overwrites the `customer.country`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the Way a Property Is Defined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can easily slap a new property onto an object. But sometimes you need to
    explicitly customize your property so you have more control of how it’s used.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Instead of creating a property by assigning to it, use the `Object.defineProperty()`
    method to define it. For example, consider the following object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s say you want to add the following two properties, with the given characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`type`'
  prefs: []
  type: TYPE_NORMAL
- en: Initial value set and can’t be changed, can’t be deleted or modified, but can
    be enumerated
  prefs: []
  type: TYPE_NORMAL
- en: '`id`'
  prefs: []
  type: TYPE_NORMAL
- en: Initial value set, but can be changed, can’t be deleted or modified, and can’t
    be enumerated
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this example, attempting to change the read-only property fails silently.
    More commonly, you’ll be in strict mode, either because your code is in a module
    (see [“Organizing Your JavaScript Classes with Modules”](ch08.html#using_es6_modules))
    or because you’ve added the `'use strict';` directive to the top of your JavaScript
    file. In strict mode, trying to set a read-only property interrupts your code
    with a `TypeError`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `defineProperty()` is a way of adding a property to an object other than
    direct assignment that gives you some control over its behavior and state. Even
    if all you do with `defineProperty()` is set the property name and value, it’s
    not the same as simply setting the property. That’s because the properties created
    with `defineProperty()` are read-only and nonenumerable by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `defineProperty()` method takes three arguments: the object you’re setting
    the property on, the name of the property, and a descriptor object that configures
    the property. Here’s where things get a bit more interesting. There are actually
    two types of descriptors you can use. The example in the solution uses a *data
    descriptor*, which has four details you can set:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configurable`'
  prefs: []
  type: TYPE_NORMAL
- en: Controls whether the property descriptor can be changed. It’s `false` by default.
  prefs: []
  type: TYPE_NORMAL
- en: '`enumerable`'
  prefs: []
  type: TYPE_NORMAL
- en: Controls whether the property can be enumerated. It’s `false` by default.
  prefs: []
  type: TYPE_NORMAL
- en: '`value`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the initial value for the property.
  prefs: []
  type: TYPE_NORMAL
- en: '`writable`'
  prefs: []
  type: TYPE_NORMAL
- en: Controls whether the property value can be changed. It’s `false` by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using a data descriptor, you can use an *accessor descriptor*, which
    supports a slightly different set of options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`configurable`'
  prefs: []
  type: TYPE_NORMAL
- en: Same as for a data descriptor
  prefs: []
  type: TYPE_NORMAL
- en: '`enumerable`'
  prefs: []
  type: TYPE_NORMAL
- en: Same as for a data descriptor
  prefs: []
  type: TYPE_NORMAL
- en: '`get`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a function to use as a property getter, which returns the property value
  prefs: []
  type: TYPE_NORMAL
- en: '`set`'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a function to use as a property setter, which applies the property value
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that uses `defineProperty()` with an accessor descriptor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Here `defineProperty()` creates a computed property (`age`) that performs a
    calculation using a different property (`birthdate`). (You’ll note that you can
    refer to other instance properties in a setter or getter using `this`.) At this
    point, the design of the object is becoming a bit too ambitious for ad hoc creation
    with object literal syntax. You’ll do better using a formal class, which has a
    more natural way of exposing the same property getter and setter feature ([“Adding
    Properties to a Class”](ch08.html#custom_class_properties)).
  prefs: []
  type: TYPE_NORMAL
- en: You can use `defineProperty()` to *change* an existing property rather than
    add a new one. In fact, the syntax is exactly the same—the only difference is
    that the property name you specify already exists in the object. However, there’s
    one restriction. If the property is set to be nonconfigurable, you’ll get a `TypeError`
    when you call `defineProperty()` on it.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Adding Properties to a Class”](ch08.html#custom_class_properties) explains
    how properties are set on classes, which partially overlaps with the `defineProperty()`
    approach. [“Preventing Any Changes to an Object”](#preventing_any_changes_to_an_object)
    covers freezing an object to prevent property changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing Any Changes to an Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve defined your object, and now you want to make sure that its properties
    aren’t redefined or edited by other code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use `Object.freeze()` to freeze the object against any and all changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: When you attempt to change a frozen object, one of two things will happen. If
    strict mode is on, a `TypeError` exception is thrown. If strict mode is off, the
    operation fails silently—the object is not changed but your code continues to
    execute. Strict mode is always on in modules (see [“Organizing Your JavaScript
    Classes with Modules”](ch08.html#using_es6_modules)) or if you add the `'use strict';`
    directive to the top of your JavaScript file.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you know, objects are reference types and JavaScript allows you to change
    them in any way. You can change property values and add or remove properties,
    even if you’ve declared your object variable with `const`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, JavaScript also includes some static methods in the `Object` class
    that you can use to lock down your object. You have three choices, listed here
    from least to most restrictive:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.preventExtensions()`'
  prefs: []
  type: TYPE_NORMAL
- en: Prevents you from adding new properties. However, you can still set property
    values. You can also delete properties and configure properties with `Object.getOwnPropertyDescriptor()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.seal()`'
  prefs: []
  type: TYPE_NORMAL
- en: Prevents properties from being added, removed, or configured. However, you can
    still set property values. This is sometimes used to catch assignments to nonexistent
    properties, which is a silent mistake.
  prefs: []
  type: TYPE_NORMAL
- en: '`Object.freeze()`'
  prefs: []
  type: TYPE_NORMAL
- en: Disallows property modifications of any kind. You can’t configure properties,
    add new properties, or set property values. The object becomes immutable.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using strict mode (as you always will be, except when writing test
    code in the console), attempting to change a frozen object throws a `TypeError`
    exception. If you’re not using strict mode, attempts to change a property will
    fail silently, leaving the original property values but allowing the code to continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check if an object is frozen using `Object.isFrozen()`, the companion
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Intercepting and Changing Actions on an Object with a Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to run code when certain actions take place with an object, but you
    don’t want to put your code *inside* the object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Proxy` class allows you to intercept a variety of different actions on
    any object. The following example uses a proxy to perform validation on an object
    named `product`. The proxy ensures that code can use a property that doesn’t exist,
    or use a nonnumeric data type to set a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once you’ve created a useful proxy that works on one property, you can reuse
    it to intercept actions on other properties or other objects.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Proxy` object wraps an object and can be used to *trap* specific actions,
    and then provide additional or alternative behaviors based the action and the
    object’s data at the time of the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a `Proxy`, you supply two parameters: the object you want to
    watch, and the handler that can intercept the operations you choose. In the solution
    shown here, the handler only intercepts property set operations. Each time it
    intercepts a property set action, it receives the target object, the property
    that’s being set, and the new property value. The function then tests to see if
    the property being set is `price`. If so, it then checks to see if it’s a number.
    If it isn’t, a `TypeError` is thrown. If it is, then the value is checked to make
    sure it’s greater than zero. If it’s not, then a `RangeError` is thrown. Finally,
    the handler checks to see if the property is `name`. If it isn’t, the final exception,
    a `ReferenceError`, is thrown. If none of the error conditions are triggered,
    then the property is assigned the value, as usual.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Proxy` object supports a considerable number of traps, which are listed
    in [Table 7-2](#proxy_traps). The table lists each trap, followed by the parameters
    the handler function expects, expected return value, and how it’s triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Table 7-2\. Proxy traps
  prefs: []
  type: TYPE_NORMAL
- en: '| Proxy trap | Function parameters | Expected return value | How the trap is
    triggered |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `getOwnProperty​Descrip⁠tor` | target, name | desc or undefined | `Object.getOwnPropertyDescriptor(proxy,name)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `getOwnPropertyNames` | target | string | `Object.getOwnPropertyNames(proxy)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `getPrototypeOf` | target | any | `Object.getPrototypeOf(proxy)` |'
  prefs: []
  type: TYPE_TB
- en: '| `defineProperty` | target, name, desc | Boolean | `Object.defineProperty(proxy,name,desc)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `deleteProperty` | target, name | Boolean | `Object.deleteProperty(proxy,name)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `freeze` | target | Boolean | `Object.freeze(target)` |'
  prefs: []
  type: TYPE_TB
- en: '| `seal` | target | Boolean | `Object.seal(target)` |'
  prefs: []
  type: TYPE_TB
- en: '| `preventExtensions` | target | Boolean | `Object.preventExtensions(proxy)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `isFrozen` | target | Boolean | `Object.isFrozen(proxy)` |'
  prefs: []
  type: TYPE_TB
- en: '| `isSealed` | target | Boolean | `Object.isSealed(proxy)` |'
  prefs: []
  type: TYPE_TB
- en: '| `isExtensible` | target | Boolean | `Object.isExtensible(proxy)` |'
  prefs: []
  type: TYPE_TB
- en: '| `has` | target, name | Boolean | name in proxy |'
  prefs: []
  type: TYPE_TB
- en: '| `hasOwn` | target, name | Boolean | `({}).hasOwnProperty.call(proxy,name)`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `get` | target, name, receiver | any | `receiver[name]` |'
  prefs: []
  type: TYPE_TB
- en: '| `set` | target, name, value, receiver | Boolean | `receiver[name] = val`
    |'
  prefs: []
  type: TYPE_TB
- en: '| `enumerator` | target | iterator | `for` (name in proxy) (iterator should
    yield all enumerable own and inherited properties) |'
  prefs: []
  type: TYPE_TB
- en: '| `keys` | target | string | `Object.keys(proxy)` (return array of enumerable
    own properties only) |'
  prefs: []
  type: TYPE_TB
- en: '| `apply` | target, thisArg, args | any | `proxy(...args)` |'
  prefs: []
  type: TYPE_TB
- en: '| `construct` | target, args | any | `new proxy(...args`) |'
  prefs: []
  type: TYPE_TB
- en: 'Proxies can also wrap built-in objects, such as the `Array` or `Date` object.
    In the following code, a proxy is used to redefine the semantics of what happens
    when the code accesses an array. When a `get` operation takes place, the handler
    checks the value of the array at the given index. If it’s a value of zero (0),
    a value of `false` is returned; otherwise, a value of `true` is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The array value at an index of 2 is not zero, so `true` is returned. The same
    is true for the value at an index of zero. However, the value at the index of
    1 is zero, so `false` is returned. This behavior holds anytime this array proxy
    is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning an Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create an exact copy of a custom object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the spread operator (`...`) to unpack your object into a collection of
    properties, and put that property list inside brackets `{}` to build a new object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might expect that this statement would copy an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: This works for primitive types, like strings, numbers, and `BigInt`. But objects
    are reference types, and assigning an object copies the reference. You end up
    with two variables (`animal` and `animalCopy`) pointing to the same in-memory
    object.
  prefs: []
  type: TYPE_NORMAL
- en: To properly copy a custom object, you need to create a new object and then iterate
    over the old one, copying each of its properties. You could do the long way, using
    the `in` operator ([“Iterating Over All the Properties of an Object”](#iterating_all_object_properties)).
    But the spread operator offers a better approach, because you can compress the
    work down to a single clean line of code.
  prefs: []
  type: TYPE_NORMAL
- en: When you use the spread operator, you get all the *enumerable* properties of
    an object. This includes all the properties you create using object literal syntax,
    or any new property you assign after the fact. However, you can specifically choose
    to create nonenumerable properties using the `Object.defineProperty()` method
    (as introduced in [“Customizing the Way a Property Is Defined”](#creating_properties_with_define_property)).
    Usually, a nonenumerable property is something extra—for example, a piece of data
    that another service adds as part of some kind of extensibility system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Usually, you don’t want to copy nonenumerable properties, so it makes sense
    that the spread operator ignores them. However, other approaches are possible.
    JavaScript objects have special built-in plumbing, like the `Object.getOwnPropertyDescriptors()`
    method, that let you find nonenumerable properties. [“Iterating Over All the Properties
    of an Object”](#iterating_all_object_properties) explains property enumeration
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may also see a slightly older cloning approach that uses the `Object.assign()`
    method. This is equivalent to using the spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Either way, these operations perform a *shallow copy*. If your object includes
    arrays or other objects as properties, these details won’t be copied. Instead,
    they’ll be *shared* between the original object and the new object. Here’s a demonstration
    of the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t necessarily a problem, depending on what you’re trying to accomplish.
    But if you want to copy more than one layer deep, you’ll need to consider a different
    cloning approach that can create a *deep copy* ([“Making a Deep Copy of an Object”](#deep_clone_an_object)).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Making a Deep Copy of an Object”](#deep_clone_an_object) shows how to take
    the same basic structure of data (an student object that holds an array) and create
    a deep copy of it.'
  prefs: []
  type: TYPE_NORMAL
- en: Making a Deep Copy of an Object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create an exact copy of a custom object. You want to copy not just
    the top-level object, but also every object it references.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no single solution for deep copying an object. Instead, there are a
    variety of techniques that developers use, each with its own trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: The safest approach is to write your own cloning logic that’s specific to the
    type of object you want to clone. Here’s an example that makes a deep copy of
    the `student` object introduced in [“Cloning an Object”](#shallow_clone_an_object).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The beauty of this approach is that you know the object, so you know how deep
    you should go. In this example, we know that the `testScores` array holds numbers.
    Therefore, you know simple cloning with the spread operator is good enough to
    duplicate it. But if the array held objects, you’d need to decide whether to duplicate
    all those objects, a technique demonstrated in [“Cloning an Array”](ch05.html#cloning_arrays).
    Or, if `testScores` was some other type of collection object (like a `Set` or
    `Map`), you could properly create and fill a new collection of the corresponding
    type.
  prefs: []
  type: TYPE_NORMAL
- en: If you want a generic solution that can deep copy any arbitrary object, your
    best bet (by far) is to use a prebuilt, pretested routine from a well-known JavaScript
    library, like Lodash’s `cloneDeep()`, which can be imported separately through
    the `lodash.clonedeep` module.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There has been discussion about built-in serialization and deep copying support
    in future versions of JavaScript. But right now, deep cloning is a gap you’ll
    need to patch yourself.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re making a full-fledged class ([“Creating a Reusable Class”](ch08.html#using_es6_classes)),
    consider making your custom cloning function a method of the class itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This example doesn’t use the spread operator. Instead, it creates a new `Student`
    object using the constructor. If you use the spread operator, your copy will be
    an instance of the base `Object` class, not an instance of `Student`. Your copy
    will still have the same properties as the original, but it won’t appear to be
    a `Student` if you test it with `instanceof` ([“Checking if an Object Is a Certain
    Type”](#check_object_type)). It also won’t be able to use any methods you add
    to the `Student` class. To avoid these issues, you should always create the correct
    object type for your copies.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder whether it’s possible to create your own a generic object-copying
    routine. The problems are more difficult than they seem, and there are many anti-patterns
    that are recommended on the web but are likely to cause serious headaches.
  prefs: []
  type: TYPE_NORMAL
- en: A naïve approach with recursive logic will fail catastrophically (with a stack
    overflow) for self-referencing object chains. A simple example is when an object
    references another object that references the original object. However, subtler
    versions are surprisingly common.
  prefs: []
  type: TYPE_NORMAL
- en: Another variation of this problem is if one object has two references to the
    same object. For example, consider a `ProductCatalog` that has an array of `Product`
    objects, some of which refer to the same `Supplier` object. A naïve approach will
    create multiple copies of the `Supplier`, one for each `Product`. A more sophisticated
    implementation, like Lodash’s `cloneDeep()`, tracks references as it goes to make
    sure it doesn’t recreate the same object more than once. (The [source for its
    cloning implementation](https://github.com/lodash/lodash/blob/master/.internal/baseClone.js)
    is a useful antidote for anyone considering reinventing the wheel.)
  prefs: []
  type: TYPE_NORMAL
- en: Another commonly recommended cloning approach is to use JSON serialization to
    convert an object to a string representation and back. This runs into problems
    with `Date` objects (which become strings), special values like `Infinity`, and
    custom objects that include functions (which are discarded). Worst of all, you
    won’t be alerted about the missing information.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The same considerations come into play if you want to test if two objects are
    equal. The `===` operator will only tell you if the two variables point to the
    same object. It returns `false` if you have separate objects with the same data.
    You could write a generic routine that finds and compares all the properties of
    any two objects. However, the meaning of equality depends on the type of data
    you’re comparing, so writing your own `isEqual()` function is always the safest
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Absolutely Unique Object Property Keys
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add a uniquely named property to an object, and you want to be guaranteed
    that it won’t clash with any other property name.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new property name using the `Symbol` type. Then, use that name to
    set the property, using key-value syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Interestingly, you never actually see the unique identifier that the `Symbol`
    type uses. In this example, here’s the output you’ll get in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'To access a property created with `Symbol`, you need to keep track of the variable
    that has the property name. You use that to retrieve your value at will:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Property name collisions are not a common event, but they are more common in
    JavaScript than many other languages. Part of the problem is that properties are
    always public. That means that if you’re inheriting from another class (see [“Inheriting
    Functionality from Another Class”](ch08.html#custom_class_inheritance)), you need
    to be aware of every inherited property and make sure not to use the same name
    yourself. But the most common cause of naming clashes is if you’re creating some
    kind of extensibility system or service that needs you to add properties to other
    people’s objects. In this situation, you won’t know if your properties will conflict
    with the properties already in that object, because you don’t own the design of
    that object.
  prefs: []
  type: TYPE_NORMAL
- en: There are various workarounds you can use to check for properties and generate
    random names. But the `Symbol` type gives you a quick and effective solution.
    Every `Symbol` is guaranteed to be unique. You create it by calling the `Symbol()`
    method. (You don’t call a constructor with `new`, because `Symbol` is a primitive
    type, not an object.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Optionally, you can give your symbol a description, which is useful for debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: However, the description is not used to create the `Symbol`. If you create two
    `Symbol` instances with the same description, there will be two completely separate
    unique identifiers, which JavaScript stores internally in a global registry of
    `Symbol` values.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Enums with Symbol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to store a small, related group of constants, so you can refer to them
    by name in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Symbol()` to set the value for each constant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An enum (or *enumerated identifier*) is a group of named constants. Enums are
    useful anytime you have a variable that can only take a small set of allowed values.
    By using the enum values, you make your code clearer. You also reduce the chance
    of mistakes (versus using magic numbers), because you won’t forget what each number
    means and you can’t accidentally use a number that doesn’t have a constant defined
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There’s some debate about the proper convention for the capitalization of constants.
    The `Math` class puts read-only properties like `Math.PI` and `Math.E` in uppercase.
    The solution in this example uses initial capitalization for enum constants and
    the object that wraps them, as in `TrafficLight.Red`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often constants are created with numeric values or string values. That’s a
    particularly good approach if the constant maps to some other useful bit of information,
    like the unit conversion values shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t have a natural unique value to use for your enum constants, consider
    using a `Symbol`. This saves you from needing to pick your own arbitrary numbers,
    and the guaranteed uniqueness of every `Symbol` ensures that you can’t substitute
    any other value. (It also removes the chance that you’ll accidentally use a hard-coded
    number in some places and a `const` variable in other places, which can lead to
    bug-causing inconsistencies when you make changes.) The `TrafficLight` example
    in this recipe uses a `Symbol` for each of its three values.
  prefs: []
  type: TYPE_NORMAL
- en: The drawback to using `Symbol` is that the underlying value is completely opaque.
    That’s why the solution in this recipe gives each Symbol a descriptive name, like
    `Symbol('red')`. That’s the text you’ll see when you log the `Symbol` to the console
    or convert it to a string. If you don’t supply a descriptive name when you create
    your `Symbol`, you’ll only see the generic text `"Symbol()"`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To look closer at the `Symbol` data type, see [“Creating Absolutely Unique Object
    Property Keys”](#symbol_properties_unique).
  prefs: []
  type: TYPE_NORMAL
