<html><head></head><body><section data-pdf-bookmark="Chapter 10. Floating and Positioning" data-type="chapter" epub:type="chapter"><div class="chapter" id="floating_and_positioning">&#13;
<h1><span class="label">Chapter 10. </span>Floating and Positioning</h1>&#13;
&#13;
&#13;
<p>For a very long time, floated elements were the basis of all our web&#13;
layout schemes. (This is largely because of the property <code>clear</code>, which&#13;
we’ll get to in a bit.) But floats were never meant for layout; their&#13;
use as a layout tool was a hack nearly as egregious as the use of tables&#13;
for layout. They were just what we had. Floats <a data-primary="floating" data-type="indexterm" id="ix_float_ch10"/>are quite interesting and useful in their own right, however. This is especially true given the recent addition of float <em>shaping</em>, which allows the&#13;
creation of nonrectangular shapes that content can flow past.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Floating" data-type="sect1"><div class="sect1" id="floating">&#13;
<h1>Floating</h1>&#13;
&#13;
<p>Ever since the early 1990s, it has been possible to float images&#13;
by declaring, for instance, <code>&lt;img src="b5.gif" alt="B4" align="right"&gt;</code>. <a data-primary="align attribute" data-type="indexterm" id="idm45176085116432"/>This&#13;
causes an image to float to the right and allows other content (such as&#13;
text) to “flow around” the image. The name <em>floating</em>, in fact, came&#13;
from the Netscape DevEdge page “Extensions to HTML 2.0,” which explained the then-new <code>align</code> attribute. Unlike HTML, CSS lets you <a data-primary="float property" data-type="indexterm" id="ix_float_prop"/>float any element, from images to paragraphs to lists. This is accomplished using the property <code>float</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176085099040">&#13;
<h1>float</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>left</code> | <code>right</code> | <code>inline-start</code> | <code>inline-end</code> | <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>For example, to float an image to the left, you could use this markup:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">&lt;</code><code class="n">img</code> <code class="n">src</code><code class="o">=</code><code class="s2">"b4.gif"</code> <code class="n">style</code><code class="o">=</code><code class="s2">"float: left;"</code> <code class="n">alt</code><code class="o">=</code><code class="s2">"b4"</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>As <a data-type="xref" href="#floating_image_fig">Figure 10-1</a> illustrates, the image “floats” to the left side of the browser window, and the text flows around it.</p>&#13;
&#13;
<figure><div class="figure" id="floating_image_fig">&#13;
<img alt="css5 1001" src="assets/css5_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>A floating image</h6>&#13;
</div></figure>&#13;
&#13;
<p>You can float to the <code>left</code> or <code>right</code>, as well as to the <code>inline-start</code> and <code>inline-end</code> edges of an element.  These latter two are useful when you want to float an element toward the start or end of the inline axis, regardless of the direction that axis is pointing. (See <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a> for details on the inline axis.)</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Throughout the rest of this section, we mostly stick to <code>left</code> and <code>right</code> because they simplify explanations.  They will also be nearly the only <code>float</code> values you see in the wild, at least for the next few years.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Floated Elements" data-type="sect2"><div class="sect2" id="floated_elements">&#13;
<h2>Floated Elements</h2>&#13;
&#13;
<p>Keep a few points in mind with regard to <a data-primary="floating" data-secondary="floated element rules" data-type="indexterm" id="ix_float_elem_rule"/>floating elements. First, a floated element is, in some ways, removed from the normal flow&#13;
of the document, although it still affects the layout of the normal flow.&#13;
In a manner&#13;
utterly unique within CSS, floated elements exist almost on their own&#13;
plane, yet they still have influence over the rest of the document.</p>&#13;
&#13;
<p>This influence arises because when an element is floated,&#13;
other normal-flow content “flows around” it. This is familiar behavior with floated&#13;
images, but the same is true if you float a paragraph, for example. In&#13;
<a data-type="xref" href="#floating_paragraph_fig">Figure 10-2</a>, you can see this effect quite clearly, thanks to the margin&#13;
added to the floated paragraph:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.aside</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">inline</code><code class="o">-</code><code class="n">end</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">15em</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0</code> <code class="m">1em</code> <code class="m">1em</code><code class="p">;</code>&#13;
     <code class="k">padding</code><code class="o">:</code> <code class="m">0.25em</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="floating_paragraph_fig">&#13;
<img alt="css5 1002" src="assets/css5_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>A floating paragraph</h6>&#13;
</div></figure>&#13;
&#13;
<p>One of the first <a data-primary="floating" data-secondary="margins and" data-type="indexterm" id="idm45176084983584"/><a data-primary="margins" data-secondary="floating images" data-type="indexterm" id="idm45176084982576"/>facts to notice about floated elements is&#13;
that margins around floated elements do not collapse. If you float an&#13;
image and give it 25-pixel margins, there will be at least 25 pixels of space&#13;
around that image. If other elements adjacent to the image—and that&#13;
means adjacent horizontally <em>and</em> vertically—also have margins, those&#13;
margins will not collapse with the margins on the floated image. The following code results in <a data-type="xref" href="#floating_images_with_margins_fig">Figure 10-3</a>, with 50 pixels of space&#13;
between the two floated images:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="nt">img</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">inline</code><code class="o">-</code><code class="n">start</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">25px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="floating_images_with_margins_fig">&#13;
<img alt="css5 1003" src="assets/css5_1003.png"/>&#13;
<h6><span class="label">Figure 10-3. </span>Floating images with margins</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="No floating at all" data-type="sect3"><div class="sect3" id="no_floating_at_all">&#13;
<h3>No floating at all</h3>&#13;
&#13;
<p>CSS has one other value for <code>float</code> <a data-primary="floating" data-secondary="preventing" data-type="indexterm" id="idm45176084950016"/>besides the ones we’ve discussed:&#13;
<code>float: none</code> is used to prevent an element from floating at all.</p>&#13;
&#13;
<p>This might seem a little silly, since the easiest way to keep an element&#13;
from floating is to avoid declaring a <code>float</code>, right? Well, first&#13;
of all, the default value of <code>float</code> is <code>none</code>. In other words, the value&#13;
has to exist in order for normal, nonfloating behavior to be possible;&#13;
without it, all elements would float in one way or another.</p>&#13;
&#13;
<p>Second, you might want to override floating in some cases.&#13;
Imagine that you’re using a server-wide stylesheet that&#13;
floats images. On one particular page, you don’t want those images to&#13;
float. Rather than writing a whole new stylesheet, you could place <code>img {float: none;}</code> in your document’s embedded stylesheet.<a data-primary="" data-startref="ix_float_prop" data-type="indexterm" id="idm45176084945840"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Floating: The Details" data-type="sect2"><div class="sect2" id="floating_the_details">&#13;
<h2>Floating: The Details</h2>&#13;
&#13;
<p>Before we start <a data-primary="blocks" data-secondary="containing blocks" data-type="indexterm" id="idm45176084942672"/><a data-primary="containing blocks" data-secondary="floated elements and" data-type="indexterm" id="idm45176084941664"/><a data-primary="blocks" data-secondary="floated elements and" data-type="indexterm" id="idm45176084940720"/><a data-primary="floating" data-secondary="containing blocks" data-type="indexterm" id="idm45176084939776"/>digging into details of floating, it’s important to&#13;
establish the concept of a <em>containing block</em>. A floated element’s&#13;
containing block is the nearest block-level ancestor element. Therefore,&#13;
in the following markup, the floated element’s containing block is the&#13;
paragraph element that contains it:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1&gt;</code><code class="w"/>&#13;
<code class="w">    </code>Test<code class="w"/>&#13;
<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>This<code class="w"> </code>is<code class="w"> </code>paragraph<code class="w"> </code>text,<code class="w"> </code>but<code class="w"> </code>you<code class="w"> </code>knew<code class="w"> </code>that.<code class="w"> </code>Within<code class="w"> </code>the<code class="w"> </code>content<code class="w"> </code>of<code class="w"> </code>this<code class="w"/>&#13;
<code class="w">    </code>paragraph<code class="w"> </code>is<code class="w"> </code>an<code class="w"> </code>image<code class="w"> </code>that's<code class="w"> </code>been<code class="w"> </code>floated.<code class="w"> </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"testy.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="w"/>&#13;
<code class="w">    </code><code class="na">class=</code><code class="s">"floated-figure"</code><code class="nt">&gt;</code><code class="w"> </code>The<code class="w"> </code>containing<code class="w"> </code>block<code class="w"> </code>for<code class="w"> </code>the<code class="w"> </code>floated<code class="w"> </code>image<code class="w"> </code>is<code class="w"/>&#13;
<code class="w">    </code>the<code class="w"> </code>paragraph.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>We’ll return to the concept of containing blocks when we discuss&#13;
positioning in <a data-type="xref" href="#positioning">“Positioning”</a>.</p>&#13;
&#13;
<p>Furthermore, a floated element generates a block box, regardless of the&#13;
kind of element it is. Thus, if you float a link, even though the&#13;
element is inline and would ordinarily generate an inline box, it&#13;
generates a block box. It will be laid out and act as if it&#13;
was, for example, a <code>&lt;div&gt;</code>. This is not unlike declaring <code>display: block</code> for&#13;
the floated element, although it is not necessary to do so.</p>&#13;
&#13;
<p>A series of specific rules govern the placement of a floated element, so&#13;
let’s cover those before digging into applied behavior. These rules are&#13;
vaguely similar to those that govern the evaluation of margins and&#13;
widths and have the same initial appearance of common sense. They are as&#13;
follows:</p>&#13;
<ol class="less_space pagebreak-before">&#13;
<li>&#13;
<p>The left (or right) outer edge of a floated element may not be to&#13;
the left (or right) of the inner edge of its containing block.</p>&#13;
&#13;
<p>This is straightforward enough. The outer-left edge of a left-floated&#13;
element can go only as far left as the inner-left edge of its containing&#13;
block. Similarly, the farthest right a right-floated element may go is&#13;
its containing block’s inner-right edge, as shown in <a data-type="xref" href="#floating_to_the_left_fig">Figure 10-4</a>. (In this&#13;
and subsequent figures, the circled numbers show the position where the&#13;
markup element actually appears in relation to the source, and the&#13;
numbered boxes show the position and size of the floated visible&#13;
element.)</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="floating_to_the_left_fig">&#13;
<img alt="css5 1004" src="assets/css5_1004.png"/>&#13;
<h6><span class="label">Figure 10-4. </span>Floating to the left (or right)</h6>&#13;
</div></figure>&#13;
</li>&#13;
<li>&#13;
<p>To prevent <a data-primary="overlapping elements" data-secondary="floated" data-type="indexterm" id="ix_overlap_elem_float"/><a data-primary="floating" data-secondary="overlapping content prevention" data-type="indexterm" id="ix_float_overlap"/>overlap with other floated elements, the left outer edge of a floated element must be to the right of the right outer edge of a left-floating element that occurs earlier in the document source, unless the top of the latter element is below the bottom of the earlier element.  Similarly, the right outer edge of a floated element must be to the left of the left outer edge of a right-floating element that comes earlier in the document source, unless the top of the latter element is below the bottom of the &#13;
<span class="keep-together">earlier</span> element.</p>&#13;
&#13;
<p>This rule prevents floated elements from “overwriting” each other. If an&#13;
element is floated to the left, and another floated element is already&#13;
there, the latter element will be placed against the outer-right edge of&#13;
the previously floated element. If, however, a floated element’s top is&#13;
below the bottom of all earlier floated images, it can float all&#13;
the way to the inner-left edge of the parent. <a data-type="xref" href="#keeping_floats_from_overlapping_fig">Figure 10-5</a> shows some examples.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="keeping_floats_from_overlapping_fig">&#13;
<img alt="css5 1005" src="assets/css5_1005.png"/>&#13;
<h6><span class="label">Figure 10-5. </span>Keeping floats from overlapping</h6>&#13;
</div></figure>&#13;
&#13;
<p>The advantage of this rule is that all your floated content will be&#13;
visible, since you don’t have to worry about one floated element&#13;
obscuring another. This makes floating a fairly safe thing to do. The&#13;
situation is markedly different when using positioning, where it is very&#13;
easy to cause elements to overwrite one another.</p>&#13;
</li>&#13;
<li>&#13;
<p>The right outer edge of a left-floating element may not be to the&#13;
right of the left outer edge of any right-floating element to its right.&#13;
The left outer edge of a right-floating element may not be to the left&#13;
of the right outer edge of any left-floating element to its left.</p>&#13;
&#13;
<p>This rule prevents floated elements from overlapping each other. Let’s&#13;
say you have a body that is 500 pixels wide, and its sole content is two&#13;
images that are 300 pixels wide. The first is floated to the left, and&#13;
the second is floated to the right. This rule prevents the second image&#13;
from overlapping the first by 100 pixels. Instead, it is forced down&#13;
until its top is below the bottom of the right-floating image, as&#13;
depicted in <a data-type="xref" href="#more_overlap_prevention_fig">Figure 10-6</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="more_overlap_prevention_fig">&#13;
<img alt="css5 1006" src="assets/css5_1006.png"/>&#13;
<h6><span class="label">Figure 10-6. </span>More overlap prevention</h6>&#13;
</div></figure>&#13;
</li>&#13;
<li>&#13;
<p>A floating element’s top may not be higher than the inner top of its&#13;
parent. If a floating element is between two collapsing margins, the floated element is placed as though it had a block-level parent&#13;
element between the two elements.</p>&#13;
&#13;
<p>The first part of this rule keeps floating elements&#13;
from floating all the way to the top of the document. <a data-type="xref" href="#unlike_balloons_fig">Figure 10-7</a> illustrates the correct behavior. The second part of this rule&#13;
fine-tunes the alignment in some situations—for example, when the middle of&#13;
three paragraphs is floated. In that case, the floated paragraph is&#13;
floated as if it had a block-level parent element (say, a <code>&lt;div&gt;</code>). This&#13;
prevents the floated paragraph from moving up to the top of whatever&#13;
common parent the three paragraphs share.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="unlike_balloons_fig">&#13;
<img alt="css5 1007" src="assets/css5_1007.png"/>&#13;
<h6><span class="label">Figure 10-7. </span>Unlike balloons, floated elements can’t float upward</h6>&#13;
</div></figure>&#13;
</li>&#13;
<li>&#13;
<p>A floating element’s top may not be higher than the top of any&#13;
earlier floating or block-level element.<a data-primary="" data-startref="ix_float_overlap" data-type="indexterm" id="idm45176084803632"/><a data-primary="" data-startref="ix_overlap_elem_float" data-type="indexterm" id="idm45176084802656"/></p>&#13;
&#13;
<p>Similarly to rule 4, rule 5 keeps floated elements from floating all the&#13;
way to the top of their parent elements. It is also impossible for a&#13;
floated element’s top to be any higher than the top of a floated element&#13;
that occurs earlier. <a data-type="xref" href="#keeping_floats_below_fig">Figure 10-8</a> shows an example: since the second float was forced to be below the first one, the&#13;
third float’s top is even with the top of the second float, not the&#13;
first.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="keeping_floats_below_fig">&#13;
<img alt="css5 1008" src="assets/css5_1008.png"/>&#13;
<h6><span class="label">Figure 10-8. </span>Keeping floats below their predecessors</h6>&#13;
</div></figure>&#13;
</li>&#13;
<li>&#13;
<p>A floating element’s top may not be higher than the top of any line&#13;
box that contains a box generated by an element that comes earlier in&#13;
the document source.</p>&#13;
&#13;
<p>Similarly to rules 4 and 5, this rule further limits the upward floating&#13;
of an element by preventing it from being above the top of a line box&#13;
containing content that precedes the floated element. Let’s say that,&#13;
right in the middle of a paragraph, there is a floated image. The highest the top of that image may be placed is the top of the line box from which the image originates. As you can see in <a data-type="xref" href="#keeping_floats_level_fig">Figure 10-9</a>, this keeps&#13;
images from floating too far upward.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="keeping_floats_level_fig">&#13;
<img alt="css5 1009" src="assets/css5_1009.png"/>&#13;
<h6><span class="label">Figure 10-9. </span>Keeping floats level with their context</h6>&#13;
</div></figure>&#13;
</li>&#13;
<li>&#13;
<p>A left-floating element that has another floating element&#13;
to its left may not have its right outer edge to the right&#13;
of its containing block’s right edge. Similarly, a right-floating element that has another floating element to its right may not have its right outer edge to the left of its containing block’s left edge.</p>&#13;
&#13;
<p>In other words, a floating element cannot stick out beyond the edge of&#13;
its containing element, unless it’s too wide to fit on its own. This&#13;
prevents a succeeding number of floated elements from&#13;
appearing in a horizontal line and far exceeding the edges of the containing&#13;
block. Instead, a float that would otherwise stick out of its containing&#13;
block by appearing next to another one will be floated down to a point&#13;
below any previous floats, as illustrated by <a data-type="xref" href="#if_theres_no_room_fig">Figure 10-10</a> (in the figure,&#13;
the floats start on the next line in order to more clearly illustrate&#13;
the principle at work here).</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="if_theres_no_room_fig">&#13;
<img alt="css5 1010" src="assets/css5_1010.png"/>&#13;
<h6><span class="label">Figure 10-10. </span>If there isn’t room, floats get pushed to a new “line”</h6>&#13;
</div></figure>&#13;
</li>&#13;
<li>&#13;
<p>A floating element must be placed as high as possible.</p>&#13;
&#13;
<p>Rule 8 is, as you might expect, subject to the restrictions introduced by the&#13;
previous seven rules. Historically, browsers aligned the top of a&#13;
floated element with the top of the line box after the one in which the&#13;
image’s tag appears. Rule 8, however, implies that its top should be&#13;
even with the top of the same line box as that in which its tag appears,&#13;
assuming there is enough room. <a data-type="xref" href="#given_the_other_constraints_fig">Figure 10-11</a> shows the theoretically correct behaviors.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="given_the_other_constraints_fig">&#13;
<img alt="css5 1011" src="assets/css5_1011.png"/>&#13;
<h6><span class="label">Figure 10-11. </span>Given the other constraints, go as high as possible</h6>&#13;
</div></figure>&#13;
</li>&#13;
<li>&#13;
<p>A left-floating element must be put as far to the left as possible,&#13;
and a right-floating element as far to the right as possible.<a data-primary="" data-startref="ix_float_elem_rule" data-type="indexterm" id="idm45176084784080"/> A higher&#13;
position is preferred to one that is farther to the right or left.</p>&#13;
&#13;
<p>Again, this rule is subject to restrictions introduced in the preceding&#13;
rules. As you can see in <a data-type="xref" href="#get_as_far_to_the_left_fig">Figure 10-12</a>, it is pretty easy to&#13;
tell when an element has gone as far as possible to the right or left.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="get_as_far_to_the_left_fig">&#13;
<img alt="css5 1012" src="assets/css5_1012.png"/>&#13;
<h6><span class="label">Figure 10-12. </span>Get as far to the left (or right) as possible</h6>&#13;
</div></figure>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Applied Behavior" data-type="sect2"><div class="sect2" id="applied_behavior">&#13;
<h2>Applied Behavior</h2>&#13;
&#13;
<p>Several interesting consequences fall out of the&#13;
rules we’ve just seen, both because of what they say and what they don’t&#13;
say. The first topic to discuss is what happens when the floated element&#13;
is taller than its parent element.</p>&#13;
&#13;
<p>This <a data-primary="floating" data-secondary="backgrounds and" data-type="indexterm" id="ix_float_backg"/>happens quite often, as a matter of fact. Take the example of a&#13;
short document, composed of no more than a few paragraphs and <code>&lt;h3&gt;</code>&#13;
elements, where the first paragraph contains a floated image. Further,&#13;
this floated image has a margin of 5 pixels (<code>5px</code>). You would expect&#13;
the document to be rendered as shown in <a data-type="xref" href="#expected_floating_fig">Figure 10-13</a>.</p>&#13;
&#13;
<figure><div class="figure" id="expected_floating_fig">&#13;
<img alt="image" src="assets/css5_1013.png"/>&#13;
<h6><span class="label">Figure 10-13. </span>Expected floating behavior</h6>&#13;
</div></figure>&#13;
&#13;
<p>Nothing there is unusual, but <a data-type="xref" href="#backgrounds_and_floated_elements">Figure 10-14</a> shows what happens&#13;
when you set the first paragraph to have a background.</p>&#13;
&#13;
<p>Nothing is different about the second example, except for the&#13;
visible background. As you can see, the floated image sticks out of the&#13;
bottom of its parent element. It also did so in the first example,&#13;
but it was less obvious there because you couldn’t see the background.&#13;
The floating rules we discussed earlier address only the left, right,&#13;
and top edges of floats and their parents. The deliberate omission of&#13;
bottom edges requires the behavior in <a data-type="xref" href="#backgrounds_and_floated_elements">Figure 10-14</a>.</p>&#13;
&#13;
<figure><div class="figure" id="backgrounds_and_floated_elements">&#13;
<img alt="image" src="assets/css5_1014.png"/>&#13;
<h6><span class="label">Figure 10-14. </span>Backgrounds and floated elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>CSS clarified this: one important aspect of floated-element behavior is that a&#13;
floated element will expand to contain any floated descendants. Thus,&#13;
you could contain a float within its parent element by floating the&#13;
parent, as in this example:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"float: left; width: 100%;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"hay.gif"</code><code class="w"> </code><code class="na">style=</code><code class="s">"float: left;"</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="nt">&gt;</code><code class="w"> </code>The<code class="w"> </code>'div'<code class="w"> </code>will<code class="w"> </code>stretch<code class="w"/>&#13;
<code class="w">    </code>around<code class="w"> </code>the<code class="w"> </code>floated<code class="w"> </code>image<code class="w"> </code>because<code class="w"> </code>the<code class="w"> </code>'div'<code class="w"> </code>has<code class="w"> </code>been<code class="w"> </code>floated.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>On a related note, consider backgrounds and their relationship to&#13;
floated elements that occur earlier in the document, which is&#13;
illustrated in <a data-type="xref" href="#element_backgrounds_fig_">Figure 10-15</a>.</p>&#13;
&#13;
<p>Because the <a data-primary="floating" data-secondary="width of" data-type="indexterm" id="idm45176084688704"/>floated element is both within and outside of the flow, this&#13;
sort of thing is bound to happen. What’s going on? The content of the&#13;
heading is being “displaced” by the floated element. However, the&#13;
heading’s element width is still as wide as its parent element.&#13;
Therefore, its content area spans the width of the parent, and so does&#13;
the background. The actual content doesn’t flow all the way across its&#13;
own content area so that it can avoid being obscured behind the floating&#13;
element.<a data-primary="" data-startref="ix_float_backg" data-type="indexterm" id="idm45176084705888"/></p>&#13;
&#13;
<figure><div class="figure" id="element_backgrounds_fig_">&#13;
<img alt="image" src="assets/css5_1015.png"/>&#13;
<h6><span class="label">Figure 10-15. </span>Element backgrounds “slide under” floated elements</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Negative margins" data-type="sect3"><div class="sect3" id="negative_margins">&#13;
<h3>Negative margins</h3>&#13;
&#13;
<p>Interestingly, <a data-primary="margins" data-secondary="negative" data-type="indexterm" id="ix_margin_neg4"/><a data-primary="negative margins" data-type="indexterm" id="ix_neg_margin4"/><a data-primary="margins" data-secondary="floating images" data-type="indexterm" id="ix_margin_float"/>negative margins can cause floated elements to move&#13;
outside of their parent elements. This seems to be in direct&#13;
contradiction to the rules explained earlier, but it isn’t. In the same&#13;
way that elements can appear to be wider than their parents through&#13;
negative margins, floated elements can appear to protrude out of their&#13;
parents.</p>&#13;
&#13;
<p>Let’s consider an image that is floated to the left, and that has&#13;
left and top margins of <code>-15px</code>. This image is placed inside a <code>&lt;div&gt;</code> that&#13;
has no padding, borders, or margins. <a data-type="xref" href="#floating_with_negative_fig">Figure 10-16</a> shows the result.</p>&#13;
&#13;
<figure><div class="figure" id="floating_with_negative_fig">&#13;
<img alt="image" src="assets/css5_1016.png"/>&#13;
<h6><span class="label">Figure 10-16. </span>Floating with negative margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>Contrary to appearances, this does not violate the restrictions on&#13;
floated elements being placed outside their parent elements.</p>&#13;
&#13;
<p>Here’s the technicality that permits this behavior: a close reading of&#13;
the rules in the previous section will show that the outer edges of a&#13;
floating element must be within the element’s parent. However, negative&#13;
margins can place the floated element’s content such that it effectively&#13;
overlaps its own outer edge, as detailed in <a data-type="xref" href="#the_details_of_floating_fig">Figure 10-17</a>.</p>&#13;
&#13;
<figure><div class="figure" id="the_details_of_floating_fig">&#13;
<img alt="image" src="assets/css5_1017.png"/>&#13;
<h6><span class="label">Figure 10-17. </span>The details of floating up and left with negative margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>One important question arises: what happens to the document&#13;
display when an element is floated out of its parent element by using&#13;
negative margins? For example, an image could be floated so far up that&#13;
it intrudes into a paragraph that has already been displayed by the user&#13;
agent. In such a case, it’s up to the user agent to decide whether the&#13;
document should be reflowed.</p>&#13;
&#13;
<p>The CSS specification explicitly&#13;
states that user agents are not required to reflow previous content to&#13;
accommodate things that happen later in the document. In other words, if&#13;
an image is floated up into a previous paragraph, it will probably&#13;
overwrite whatever was already there.  This&#13;
makes the utility of negative margins on floats somewhat limited.&#13;
Hanging floats are usually fairly safe, but trying to push an element&#13;
upward on the page is generally a bad idea.<a data-primary="" data-startref="ix_neg_margin4" data-type="indexterm" id="idm45176084677760"/><a data-primary="" data-startref="ix_margin_float" data-type="indexterm" id="idm45176084676784"/><a data-primary="" data-startref="ix_margin_neg4" data-type="indexterm" id="idm45176084675840"/></p>&#13;
&#13;
<p class="pagebreak-before">Another way for a floated element to exceed its parent’s&#13;
inner left and right edges occurs when the floated element is wider&#13;
than its parent. In that case, the floated element will overflow&#13;
the right or left inner edge—depending on which way the element is&#13;
floated—in its best attempt to display itself correctly. This will lead&#13;
to a result like that shown in <a data-type="xref" href="#floating_an_element_thats_wider_fig">Figure 10-18</a>.</p>&#13;
&#13;
<figure><div class="figure" id="floating_an_element_thats_wider_fig">&#13;
<img alt="image" src="assets/css5_1018.png"/>&#13;
<h6><span class="label">Figure 10-18. </span>Floating an element that is wider than its parent</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Floats, Content, and Overlapping" data-type="sect2"><div class="sect2" id="floats_content_and_overlapping">&#13;
<h2>Floats, Content, and Overlapping</h2>&#13;
&#13;
<p>An <a data-primary="floating" data-secondary="overlapping content prevention" data-type="indexterm" id="ix_float_overlap2"/><a data-primary="overlapping elements" data-secondary="floated" data-type="indexterm" id="ix_overlap_float2"/><a data-primary="floating" data-secondary="inline elements" data-type="indexterm" id="ix_float_inline"/>interesting question is this: what happens when a float&#13;
overlaps content in the normal flow? This can happen if, for example, a&#13;
float has a negative margin on the side where content is flowing past&#13;
(e.g., a negative left margin on a right-floating element). You’ve&#13;
already seen what happens to the borders and backgrounds of block-level&#13;
elements. What about inline elements?</p>&#13;
&#13;
<p>The <a data-primary="CSS2 specification" data-secondary="inline boxes overlapping with floats" data-type="indexterm" id="idm45176084665424"/>CSS 2.1 specification states the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>An inline box that overlaps with a float has its borders, background,&#13;
and content all rendered “on top” of the float.</p>&#13;
</li>&#13;
<li>&#13;
<p>A block box that overlaps with a float has its borders and background&#13;
rendered “behind” the float, whereas its content is rendered “on top” of&#13;
the float.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To illustrate these rules, consider the following situation:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"testy.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">""</code><code class="w"> </code><code class="na">class=</code><code class="s">"sideline"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"box"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>This<code class="w"> </code>paragraph,<code class="w"> </code>unremarkable<code class="w"> </code>in<code class="w"> </code>most<code class="w"> </code>ways,<code class="w"> </code>does<code class="w"> </code>contain<code class="w"> </code>an<code class="w"> </code>inline<code class="w"> </code>element.<code class="w"/>&#13;
<code class="w">    </code>This<code class="w"> </code>inline<code class="w"> </code>contains<code class="w"> </code>some<code class="w"> </code><code class="nt">&lt;strong&gt;</code>strongly<code class="w"> </code>emphasized<code class="w"> </code>text,<code class="w"> </code>which<code class="w"> </code>is<code class="w"> </code>so<code class="w"/>&#13;
<code class="w">    </code>marked<code class="w"> </code>to<code class="w"> </code>make<code class="w"> </code>an<code class="w"> </code>important<code class="w"> </code>point<code class="nt">&lt;/strong&gt;</code>.<code class="w"> </code>The<code class="w"> </code>rest<code class="w"> </code>of<code class="w"> </code>the<code class="w"> </code>element's<code class="w"/>&#13;
<code class="w">    </code>content<code class="w"> </code>is<code class="w"> </code>normal<code class="w"> </code>anonymous<code class="w"> </code>inline<code class="w"> </code>content.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>This<code class="w"> </code>is<code class="w"> </code>a<code class="w"> </code>second<code class="w"> </code>paragraph.<code class="w">  </code>There's<code class="w"> </code>nothing<code class="w"> </code>remarkable<code class="w"> </code>about<code class="w"> </code>it,<code class="w"> </code>really.<code class="w"/>&#13;
<code class="w">    </code>Please<code class="w"> </code>move<code class="w"> </code>along<code class="w"> </code>to<code class="w"> </code>the<code class="w"> </code>next<code class="w"> </code>bit.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h2</code><code class="w"> </code><code class="na">id=</code><code class="s">"jump-up"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>A<code class="w"> </code>Heading!<code class="w"/>&#13;
<code class="nt">&lt;/h2&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>To that markup, apply the following styles, with the result seen in&#13;
<a data-type="xref" href="#layout_behavior_when_overlapping_fig">Figure 10-19</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.sideline</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">10px</code> <code class="m">-15px</code> <code class="m">10px</code> <code class="m">10px</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.box</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="n">hsl</code><code class="p">(</code><code class="m">117</code><code class="o">,</code><code class="m">50%</code><code class="o">,</code><code class="m">80%</code><code class="p">);</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.box</code> <code class="nt">strong</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">double</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="n">hsl</code><code class="p">(</code><code class="m">215</code><code class="o">,</code><code class="m">100%</code><code class="o">,</code><code class="m">80%</code><code class="p">);</code> <code class="k">padding</code><code class="o">:</code> <code class="m">2px</code><code class="p">;}</code>&#13;
<code class="nt">h2</code><code class="nf">#jump-up</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">-25px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="n">hsl</code><code class="p">(</code><code class="m">42</code><code class="o">,</code><code class="m">70%</code><code class="o">,</code><code class="m">70%</code><code class="p">);}</code></pre>&#13;
&#13;
<figure><div class="figure" id="layout_behavior_when_overlapping_fig">&#13;
<img alt="image" src="assets/css5_1019.png"/>&#13;
<h6><span class="label">Figure 10-19. </span>Layout behavior when overlapping floats</h6>&#13;
</div></figure>&#13;
&#13;
<p>The inline element (<code>strong</code>) completely overlaps the floated&#13;
image—background, border, content, and all. The block elements, on the&#13;
other hand, have only their content appear on top of the float. Their&#13;
backgrounds and borders are placed behind the float.</p>&#13;
&#13;
<p>The described overlapping behavior is independent of the document source&#13;
order. It does not matter if an element comes before or after a float:&#13;
the same behaviors still apply.<a data-primary="" data-startref="ix_float_inline" data-type="indexterm" id="idm45176084386224"/><a data-primary="" data-startref="ix_float_overlap2" data-type="indexterm" id="idm45176084385248"/><a data-primary="" data-startref="ix_overlap_float2" data-type="indexterm" id="idm45176084384304"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Clearing" data-type="sect1"><div class="sect1" id="clearing">&#13;
<h1>Clearing</h1>&#13;
&#13;
<p>We’ve <a data-primary="floating" data-secondary="clearing to control" data-type="indexterm" id="ix_float_clear"/>talked quite a bit about floating behavior, so we have only one&#13;
more subject to discuss before we turn to shapes. You won’t always want&#13;
your content to flow past a floated element—in some cases, you’ll&#13;
specifically want to prevent it. If your document is grouped&#13;
into sections, you might not want the floated elements from one section&#13;
hanging down into the next.</p>&#13;
&#13;
<p>In that case, you’d want to set the first&#13;
element of each section to prohibit floating elements from appearing&#13;
next to it. If the first element might otherwise be placed next to a&#13;
floated element, it will be pushed down until it appears below the&#13;
floated image, and all subsequent content will appear after that, as&#13;
shown in <a data-type="xref" href="#displaying_an_element_fig">Figure 10-20</a>.</p>&#13;
&#13;
<figure class="smaller"><div class="figure" id="displaying_an_element_fig">&#13;
<img alt="image" src="assets/css5_1020.png"/>&#13;
<h6><span class="label">Figure 10-20. </span>Displaying an element in the clear</h6>&#13;
</div></figure>&#13;
&#13;
<p>This is <a data-primary="clear property" data-type="indexterm" id="ix_clear_prop"/>done with <code>clear</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176084374480">&#13;
<h1>clear</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>both</code> | <code>left</code> | <code>right</code> | <code>inline-start</code> | <code>inline-end</code> | <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Block-level elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>For example, to make sure all <code>&lt;h3&gt;</code> elements are not placed to the right&#13;
of left-floating elements, you would declare <code>h3 {clear: left;}</code>. This&#13;
can be translated as “make sure that the left side of an <code>&lt;h3&gt;</code> is clear&#13;
of floating elements and pseudo-elements.”  The following rule uses <code>clear</code>&#13;
to prevent <code>&lt;h3&gt;</code> elements from flowing past floated elements to the left&#13;
side:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h3</code> <code class="p">{</code><code class="k">clear</code><code class="o">:</code> <code class="nb">left</code><code class="p">;}</code></pre>&#13;
&#13;
<p>While this will push the <code>&lt;h3&gt;</code> past any left-floating elements, it will&#13;
allow floated elements to appear on the right side of <code>&lt;h3&gt;</code> elements, as&#13;
shown in <a data-type="xref" href="#clear_to_the_left_fig">Figure 10-21</a>.</p>&#13;
&#13;
<figure><div class="figure" id="clear_to_the_left_fig">&#13;
<img alt="image" src="assets/css5_1021.png"/>&#13;
<h6><span class="label">Figure 10-21. </span>Clear to the left, but not the right</h6>&#13;
</div></figure>&#13;
&#13;
<p>To avoid this sort of thing, and to make sure that <code>&lt;h3&gt;</code>&#13;
elements do not coexist on a line with any floated elements, you use the&#13;
value <code>both</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h3</code> <code class="p">{</code><code class="k">clear</code><code class="o">:</code> <code class="nb">both</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Understandably, this value prevents coexistence with floated&#13;
elements on both sides of the cleared element, as demonstrated in <a data-type="xref" href="#clear_on_both_sides_fig">Figure 10-22</a>.</p>&#13;
&#13;
<figure><div class="figure" id="clear_on_both_sides_fig">&#13;
<img alt="image" src="assets/css5_1022.png"/>&#13;
<h6><span class="label">Figure 10-22. </span>Clear on both sides</h6>&#13;
</div></figure>&#13;
&#13;
<p>If, on the other hand, we were worried only about <code>&lt;h3&gt;</code> elements being&#13;
pushed down past floated elements to their right, then we’d use&#13;
<code>h3 {clear: right;}</code>.</p>&#13;
&#13;
<p>As with <code>float</code>, you can give <code>clear</code> the values <code>inline-start</code> (and <code>both</code>) or <code>inline-end</code>.  If you’re floating with those values, clearing with them makes sense.  If you’re floating using <code>left</code> and <code>right</code>, using those values for <code>clear</code> is sensible.</p>&#13;
&#13;
<p>Finally, <code>clear: none</code> allows elements to float to either&#13;
side of an element. As with <code>float: none</code>, this value mostly exists to&#13;
allow for normal document behavior, in which elements will permit&#13;
floated elements to both sides. The <code>none</code> value can be used to override other&#13;
styles, as shown in <a data-type="xref" href="#not_clear_at_all_fig">Figure 10-23</a>. Despite the document-wide rule&#13;
that <code>&lt;h3&gt;</code> elements will not permit floated elements to either side, one&#13;
<code>&lt;h3&gt;</code> in particular has been set so that it does permit floated elements&#13;
on either side:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h3</code> <code class="p">{</code><code class="k">clear</code><code class="o">:</code> <code class="nb">both</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">h3</code> <code class="nt">style</code><code class="o">=</code><code class="s2">"clear: none;"</code><code class="o">&gt;</code><code class="nt">What</code><code class="err">'</code><code class="nt">s</code> <code class="nt">With</code> <code class="nt">All</code> <code class="nt">The</code> <code class="nt">NEO</code><code class="o">?&lt;/</code><code class="nt">h3</code><code class="o">&gt;</code></pre>&#13;
&#13;
<figure><div class="figure" id="not_clear_at_all_fig">&#13;
<img alt="image" src="assets/css5_1023.png"/>&#13;
<h6><span class="label">Figure 10-23. </span>Not clear at all</h6>&#13;
</div></figure>&#13;
&#13;
<p>The <code>clear</code> property <a data-primary="clearance, floating elements" data-type="indexterm" id="idm45176084255216"/>works by way of <em>clearance</em>—extra spacing added&#13;
above an element’s top margin in order to push it past any floated&#13;
elements. This means that the top margin of a cleared element does not&#13;
change when an element is cleared. Its downward movement is caused by&#13;
the clearance instead. Pay close attention to the placement of the&#13;
heading’s border in <a data-type="xref" href="#clearing_and_its_effect_fig">Figure 10-24</a>, which results from the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.sider</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">clear</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code> <code class="k">margin-top</code><code class="o">:</code> <code class="m">15px</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">img</code> <code class="nt">src</code><code class="o">=</code><code class="s2">"chrome.jpg"</code> <code class="nt">class</code><code class="o">=</code><code class="s2">"sider"</code> <code class="nt">height</code><code class="o">=</code><code class="s2">"50"</code> <code class="nt">width</code><code class="o">=</code><code class="s2">"50"</code> <code class="nt">alt</code><code class="o">=</code><code class="s2">""</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;</code><code class="nt">img</code> <code class="nt">src</code><code class="o">=</code><code class="s2">"stripe.gif"</code> <code class="nt">height</code><code class="o">=</code><code class="s2">"10"</code> <code class="nt">width</code><code class="o">=</code><code class="s2">"100"</code> <code class="nt">alt</code><code class="o">=</code><code class="s2">""</code><code class="o">&gt;</code>&#13;
<code class="o">&lt;</code><code class="nt">h3</code><code class="o">&gt;</code>&#13;
    <code class="nt">Why</code> <code class="nt">Doubt</code> <code class="nt">Salmon</code><code class="o">?</code>&#13;
<code class="o">&lt;/</code><code class="nt">h3</code><code class="o">&gt;</code></pre>&#13;
&#13;
<figure><div class="figure" id="clearing_and_its_effect_fig">&#13;
<img alt="image" src="assets/css5_1024.png"/>&#13;
<h6><span class="label">Figure 10-24. </span>Clearing and its effect on margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>There is no <a data-primary="floating" data-secondary="margins and" data-type="indexterm" id="idm45176084142064"/><a data-primary="margins" data-secondary="floating images" data-type="indexterm" id="idm45176084141056"/>separation between the top border of the <code>&lt;h3&gt;</code> and the bottom&#13;
border of the floated image because 25 pixels of clearance was added&#13;
above the 15-pixel top margin in order to push the <code>&lt;h3&gt;</code>’s top border&#13;
edge just past the bottom edge of the float. This occurs unless the <code>&lt;h3&gt;</code>’s top margin calculates to 40 pixels or more, in which&#13;
case the <code>&lt;h3&gt;</code> will naturally place itself below the float, and the <code>clear</code>&#13;
value will be irrelevant.</p>&#13;
&#13;
<p>In most cases, you can’t know how far an element needs to be cleared.&#13;
The way to make sure a cleared element has some space between its top&#13;
and the bottom of a float is to put a bottom margin on the float itself.&#13;
Therefore, if you want at least 15 pixels of space below the&#13;
float in the previous example, you would change the CSS like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.sider</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0</code> <code class="m">0</code> <code class="m">15px</code><code class="p">;}</code>&#13;
<code class="nt">h3</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">clear</code><code class="o">:</code> <code class="nb">left</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The floated element’s bottom margin increases the size of the float box,&#13;
and thus the point past which cleared elements must be pushed. This is&#13;
because, as you’ve seen before, the margin edges of a floated element&#13;
define the edges of the floated box.<a data-primary="" data-startref="ix_float_ch10" data-type="indexterm" id="idm45176084066656"/><a data-primary="" data-startref="ix_float_clear" data-type="indexterm" id="idm45176084065808"/><a data-primary="" data-startref="ix_clear_prop" data-type="indexterm" id="idm45176084064896"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Positioning" data-type="sect1"><div class="sect1" id="positioning">&#13;
<h1>Positioning</h1>&#13;
&#13;
<p>The idea <a data-primary="positioning" data-type="indexterm" id="ix_position_ch10"/>behind positioning is fairly simple. It allows you to define&#13;
exactly where element boxes will appear relative to where they would&#13;
ordinarily be—or position them in relation to a parent element, another&#13;
element, or even to the viewport (e.g., the browser window) itself.</p>&#13;
&#13;
<p>Before we delve into the various kinds of positioning, it’s a good idea&#13;
to look at what types exist and how they differ.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Types of Positioning" data-type="sect2"><div class="sect2" id="types-of-positioning">&#13;
<h2>Types of Positioning</h2>&#13;
&#13;
<p>You can <a data-primary="positioning" data-secondary="types" data-type="indexterm" id="ix_position_types"/><a data-primary="position property" data-type="indexterm" id="ix_position_prop"/>choose one of five types of positioning, which affect&#13;
how the element’s box is &#13;
<span class="keep-together">generated,</span> by using the <code>position</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176084052672">&#13;
<h1>position</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>static</code> | <code>relative</code> | <code>sticky</code> | <code>absolute</code> | <code>fixed</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>static</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The values of <code>position</code> have the following meanings:</p>&#13;
<dl>&#13;
<dt><code>static</code></dt>&#13;
<dd>&#13;
<p>	The element’s <a data-primary="offsets" data-secondary="static positioning" data-type="indexterm" id="idm45176084035504"/><a data-primary="static positioning" data-type="indexterm" id="idm45176084034496"/><a data-primary="positioning" data-secondary="static" data-type="indexterm" id="idm45176084033824"/><a data-primary="visual formatting" data-secondary="block flow direction" data-type="indexterm" id="idm45176084032880"/>box is generated as normal. Block-level elements generate&#13;
a rectangular box that is part of the document’s flow, and inline-level&#13;
boxes cause the creation of one or more line boxes that are flowed&#13;
within their parent element.</p>&#13;
</dd>&#13;
<dt><code>relative</code></dt>&#13;
<dd>&#13;
<p>	The element’s <a data-primary="offsets" data-secondary="relative positioning" data-type="indexterm" id="idm45176084030400"/><a data-primary="relative positioning" data-type="indexterm" id="idm45176084029392"/><a data-primary="positioning" data-secondary="relative" data-type="indexterm" id="idm45176084028720"/>box is offset by a certain distance; <code>0px</code> by default. The element retains the&#13;
shape it would have had were it not positioned, and the space that the&#13;
element would ordinarily have occupied is preserved.</p>&#13;
</dd>&#13;
<dt><code>absolute</code></dt>&#13;
<dd>&#13;
<p>	The element’s box is <a data-primary="absolute positioning" data-type="indexterm" id="idm45176084025824"/><a data-primary="offsets" data-secondary="absolute positioning" data-type="indexterm" id="idm45176084025120"/>completely removed from the flow of the document&#13;
and positioned relative to its closest positioned ancestor, if any, or its containing block, which may be&#13;
another element in the document or the initial containing block&#13;
(described in the next section). Whatever space the element might have&#13;
occupied in the normal document flow is closed up, as though the element&#13;
did not exist. The positioned element generates a block-level box,&#13;
regardless of the type of box it would have generated if it were in the&#13;
normal flow.</p>&#13;
</dd>&#13;
<dt><code>fixed</code></dt>&#13;
<dd>&#13;
<p>	The element’s <a data-primary="fixed positioning" data-type="indexterm" id="idm45176084022640"/><a data-primary="offsets" data-secondary="fixed positioning" data-type="indexterm" id="idm45176084021904"/><a data-primary="positioning" data-secondary="fixed" data-type="indexterm" id="idm45176084020960"/>box behaves as though it was set to <code>absolute</code>, but its&#13;
containing block is the viewport itself.</p>&#13;
</dd>&#13;
<dt><code>sticky</code></dt>&#13;
<dd>&#13;
<p>	The <a data-primary="sticky positioning" data-type="indexterm" id="idm45176084018064"/><a data-primary="offsets" data-secondary="sticky positioning" data-type="indexterm" id="idm45176084017328"/><a data-primary="positioning" data-secondary="sticky" data-type="indexterm" id="idm45176084016384"/>element is left in the normal flow, until the conditions that trigger&#13;
its stickiness come to pass, at which point it is removed from the&#13;
normal flow but its original space in the normal flow is preserved. It&#13;
will then act as if absolutely positioned with respect to its containing&#13;
block. Once the conditions to enforce stickiness are no longer met, the&#13;
element is returned to the normal flow in its original space.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Don’t worry so much about the details right now, as we’ll look at each&#13;
of these kinds of positioning later. Before we do that, we&#13;
need to discuss containing blocks.<a data-primary="" data-startref="ix_position_types" data-type="indexterm" id="idm45176084014928"/><a data-primary="" data-startref="ix_position_prop" data-type="indexterm" id="idm45176084014016"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="The Containing Block" data-type="sect2"><div class="sect2" id="pos_the-containing-block">&#13;
<h2>The Containing Block</h2>&#13;
&#13;
<p>In <a data-primary="blocks" data-secondary="containing blocks" data-type="indexterm" id="idm45176084010640"/><a data-primary="containing blocks" data-secondary="positioning and" data-type="indexterm" id="idm45176084009664"/><a data-primary="positioning" data-secondary="containing blocks and" data-type="indexterm" id="idm45176084008688"/>general terms, a <em>containing block</em> is the box that contains another&#13;
element, as we said earlier in the chapter. As an example, in the normal-flow case, the root element&#13;
(<code>&lt;html&gt;</code> in HTML) is the containing block for the <code>&lt;body&gt;</code> element, which&#13;
is in turn the containing block for all its children, and so on. When it&#13;
comes to positioning, the containing block depends entirely on the type&#13;
of positioning.</p>&#13;
&#13;
<p>For a nonroot element whose <code>position</code> value is <code>relative</code> or <code>static</code>,&#13;
its containing block is formed by the content edge of the nearest&#13;
block-level, table-cell, or inline-block ancestor box.</p>&#13;
&#13;
<p>For a nonroot element that has a <code>position</code> value of <code>absolute</code>, its&#13;
containing block is set to the nearest ancestor (of any kind) that has a&#13;
<code>position</code> value other than <code>static</code>. This happens as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the ancestor is block-level, the containing block is set to be&#13;
that element’s padding edge; in other words, the area that would be&#13;
bounded by a border.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the ancestor is <a data-primary="inline formatting" data-secondary="containing block and" data-type="indexterm" id="idm45176084000704"/>inline-level, the containing block is set to the&#13;
content edge of the ancestor. In left-to-right languages, the top and&#13;
left of the containing block are the top and left content edges of the&#13;
first box in the ancestor, and the bottom and right edges are the bottom&#13;
and right content edges of the last box. In right-to-left languages, the&#13;
right edge of the containing block corresponds to the right content edge&#13;
of the first box, and the left is taken from the last box. The top and&#13;
bottom are the same.</p>&#13;
</li>&#13;
<li>&#13;
<p>If <a data-primary="initial containing block" data-type="indexterm" id="idm45176083998736"/>there are no ancestors, the element’s containing block is&#13;
defined to be the initial containing block.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>There’s an <a data-primary="positioning" data-secondary="sticky" data-type="indexterm" id="idm45176083997152"/><a data-primary="sticky-constraint rectangle" data-type="indexterm" id="idm45176083996144"/><a data-primary="sticky positioning" data-type="indexterm" id="idm45176083995504"/>interesting variant to the containing-block rules when it&#13;
comes to sticky-positioned elements, which is that a rectangle is&#13;
defined in relation to the containing block called the&#13;
<em>sticky-constraint rectangle</em>. This rectangle has everything to do with&#13;
how sticky positioning works, and will be explained in full in&#13;
<a data-type="xref" href="#sticky-positioning">“Sticky Positioning”</a>.</p>&#13;
&#13;
<p>An important point: elements can be positioned&#13;
outside of their containing block.  This suggests that the term “containing&#13;
block” should really be “positioning context,” but since the&#13;
specification uses “containing block,” so will we.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Offset Properties" data-type="sect2"><div class="sect2" id="offset-properties">&#13;
<h2>Offset Properties</h2>&#13;
&#13;
<p>Four of the <a data-primary="offsets" data-secondary="basic properties" data-type="indexterm" id="ix_offset_position2"/><a data-primary="positioning" data-secondary="offset properties" data-type="indexterm" id="ix_position_offset_prop"/><a data-primary="logical properties" data-secondary="floating and positioning (inset)" data-type="indexterm" id="ix_log_prop_float"/>positioning schemes described in the previous&#13;
section—relative, absolute, sticky, and fixed—use distinct&#13;
properties to describe the offset of a positioned element’s sides with&#13;
respect to its containing block. These properties, which are&#13;
referred to as the <em>offset properties</em>, are a big part of what makes&#13;
positioning work.  <a data-primary="inset-inline-end property" data-type="indexterm" id="ix_inset_inline_end_prop"/><a data-primary="inset-inline-start property" data-type="indexterm" id="ix_inset_inline_strt_prop"/><a data-primary="inset-block-end property" data-type="indexterm" id="ix_inset_block_prop"/><a data-primary="inset-block-start property" data-type="indexterm" id="ix_inset_block_srt_prop"/><a data-primary="right property" data-type="indexterm" id="ix_right_prop"/><a data-primary="top property" data-type="indexterm" id="ix_top_prop"/><a data-primary="left property" data-type="indexterm" id="ix_left_prop"/><a data-primary="bottom property" data-type="indexterm" id="ix_bottom_prop"/>There are four physical offset properties and four logical offset properties.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176083978800">&#13;
<h1>top, right, bottom, left, inset-block-start, inset-block-end, &#13;
<span class="keep-together">inset-inline-start,</span> inset-inline-end</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Positioned elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the height of the containing block for <code>top</code> and&#13;
<code>bottom</code>, and the width of the containing block for <code>right</code> and <code>left</code>; to the size of the containing block along the block axis for <code>inset-block-start</code> and <code>inset-block-end</code>, and the size along the inline axis for <code>inset-inline-start</code> and <code>inset-inline-end</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For <code>relative</code> or <code>sticky</code>-positioned elements, see&#13;
the sections on those positioning types; for static elements, <code>auto</code>; for&#13;
length values, the corresponding absolute length; for percentage values,&#13;
the specified value; otherwise, <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>These properties describe an offset from the nearest side of the&#13;
containing block (thus the term <em>offset properties</em>).  The simplest way&#13;
to look at it is that positive values cause inward offsets,&#13;
moving the edges toward the center of the containing block, and negative&#13;
values cause outward offsets.</p>&#13;
&#13;
<p>For example, <code>top</code>&#13;
describes how far the top margin edge of the positioned element should&#13;
be placed from the top of its containing block. In the case of <code>top</code>,&#13;
positive values move the top margin edge of the positioned element&#13;
<em>downward</em>, while negative values move it <em>above</em> the top of its&#13;
containing block. Similarly, <code>left</code> describes how far to the right (for&#13;
positive values) or left (for negative values) the left margin edge of&#13;
the positioned element is from the left edge of the containing block.&#13;
Positive values will shift the margin edge of the positioned element to&#13;
the right, and negative values will move it to the left.</p>&#13;
&#13;
<p>The implication of offsetting the margin edges is that it’s&#13;
possible to set margins, borders, and padding for a positioned element;&#13;
these will be preserved and kept with the <span class="keep-together">positioned</span> element, and they&#13;
will be contained within the area defined by the offset &#13;
<span class="keep-together">properties.</span></p>&#13;
&#13;
<p>It is important to remember that the offset properties define an offset&#13;
from the analogous side (e.g., <code>inset-block-end</code> defines the offset from the block-end side) of the containing block, not from the upper-left corner of the&#13;
containing block. This is why, for example, one way to fill up the&#13;
lower-right corner of a containing block is to use these values:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">top</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code></pre>&#13;
&#13;
<p>In this example, the outer-left edge of the positioned element is placed&#13;
halfway across the containing block. This is its offset from the left&#13;
edge of the containing block. The outer-right edge of the positioned&#13;
element, on the other hand, is not offset from the right edge of the containing&#13;
block, so the two are coincident. Similar reasoning holds true for the&#13;
top and bottom of the positioned element: the outer-top edge is placed&#13;
halfway down the containing block, but the outer-bottom edge is not&#13;
moved up from the bottom. This leads to what’s shown in <a data-type="xref" href="#filling_lower-right-quarter">Figure 10-25</a>.</p>&#13;
&#13;
<figure><div class="figure" id="filling_lower-right-quarter">&#13;
<img alt="css5 1025" src="assets/css5_1025.png"/>&#13;
<h6><span class="label">Figure 10-25. </span>Filling the lower-right quarter of the containing block</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>What’s depicted in <a data-type="xref" href="#filling_lower-right-quarter">Figure 10-25</a>, and in most of the examples in this&#13;
chapter, is based around <a data-primary="offsets" data-secondary="absolute positioning" data-type="indexterm" id="idm45176083921024"/><a data-primary="absolute positioning" data-type="indexterm" id="idm45176083920080"/>absolute positioning. Since absolute&#13;
positioning is the simplest scheme in which to demonstrate how the offset properties work, we’ll stick to that for now.</p>&#13;
</div>&#13;
&#13;
<p>Note the background area of the positioned element. In <a data-type="xref" href="#filling_lower-right-quarter">Figure 10-25</a>, it has&#13;
no margins, but if it did, they would create blank space between the&#13;
borders and the offset edges. This would make the positioned element&#13;
appear as though it did not completely fill the lower-right quarter of&#13;
the containing block. In truth, it <em>would</em> fill the area, because margins count as part of the area of a positioned element, but this fact&#13;
wouldn’t be immediately apparent to the eye.</p>&#13;
&#13;
<p>Thus, the following two&#13;
sets of styles would have approximately the same visual appearance,&#13;
assuming that the containing block is <code>100em</code> high by <code>100em</code> wide:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#ex1</code> <code class="p">{</code><code class="k">top</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">10em</code><code class="p">;}</code>&#13;
<code class="nf">#ex2</code> <code class="p">{</code><code class="k">top</code><code class="o">:</code> <code class="m">60%</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">10%</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">60%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">10%</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<p>By using negative offset values, we can position an element&#13;
outside its <span class="keep-together">containing</span> block. For example, the following values will&#13;
lead to the result shown in <a data-type="xref" href="#positioning_outside_block">Figure 10-26</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">top</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">-2em</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">75%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">-7em</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="positioning_outside_block">&#13;
<img alt="css5 1026" src="assets/css5_1026.png"/>&#13;
<h6><span class="label">Figure 10-26. </span>Positioning an element outside its containing block</h6>&#13;
</div></figure>&#13;
&#13;
<p>In addition to length and percentage values, the offset properties can be set to <code>auto</code>, which is the default value. There is no single&#13;
behavior for <code>auto</code>; it changes based on the type of positioning used.&#13;
We’ll explore how <code>auto</code> works later, as we consider each of the&#13;
positioning types in turn.<a data-primary="" data-startref="ix_bottom_prop" data-type="indexterm" id="idm45176083786800"/><a data-primary="" data-startref="ix_left_prop" data-type="indexterm" id="idm45176083785824"/><a data-primary="" data-startref="ix_position_offset_prop" data-type="indexterm" id="idm45176083784880"/><a data-primary="" data-startref="ix_right_prop" data-type="indexterm" id="idm45176083783936"/><a data-primary="" data-startref="ix_top_prop" data-type="indexterm" id="idm45176083782992"/><a data-primary="" data-startref="ix_inset_block_prop" data-type="indexterm" id="idm45176083768032"/><a data-primary="" data-startref="ix_inset_block_srt_prop" data-type="indexterm" id="idm45176083767184"/><a data-primary="" data-startref="ix_inset_inline_end_prop" data-type="indexterm" id="idm45176083766336"/><a data-primary="" data-startref="ix_inset_inline_strt_prop" data-type="indexterm" id="idm45176083765488"/><a data-primary="" data-startref="ix_offset_position2" data-type="indexterm" id="idm45176083764608"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inset Shorthands" data-type="sect2"><div class="sect2" id="inset-shorthands">&#13;
<h2>Inset Shorthands</h2>&#13;
&#13;
<p>In <a data-primary="positioning" data-secondary="inset shorthand properties" data-type="indexterm" id="ix_position_inset_short"/><a data-primary="offsets" data-secondary="shorthand properties" data-type="indexterm" id="idm45176083760704"/>addition to the logical inset properties mentioned in the previous section, CSS has a few inset shorthand properties: two logical and one physical.<a data-primary="inset-block property" data-type="indexterm" id="idm45176083759632"/><a data-primary="inset-inline property" data-type="indexterm" id="idm45176083758960"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176083758160">&#13;
<h1>inset-block, inset-inline</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,2} | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Positioned elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the size of the containing block along the block axis for <code>inset-block</code>, and the size along the inline axis for <code>inset-inline</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For <code>relative</code> or <code>sticky</code>-positioned elements, see&#13;
the sections on those positioning types; for static elements, <code>auto</code>; for&#13;
length values, the corresponding absolute length; for percentage values,&#13;
the specified value; otherwise, <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>For both properties, you can supply one or two values.  If you supply one, the same value is used for both sides; that is, <code>inset-block: 10px</code> will use 10 pixels of inset for both the block-start and block-end edges.</p>&#13;
&#13;
<p>If you supply two values, the first is used for the start edge, and the second for the end edge.  Thus, <code>inset-inline: 1em 2em</code> will use 1 em of inset for the inline start edge, and 2 ems of inset for the inline end edge.</p>&#13;
&#13;
<p>It’s usually a lot easier to use these two shorthands for logical insets, since you can always supply <code>auto</code> when you don’t want to set a specific offset—for example, <code>inset-block: 25% auto</code>.</p>&#13;
&#13;
<p>The <a data-primary="inset property" data-type="indexterm" id="idm45176083735008"/>shorthand for all four edges in one property is called <code>inset</code>, but it’s a physical property—it’s shorthand for <code>top</code>, <code>bottom</code>, <code>left</code>, and <code>right</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176083731936">&#13;
<h1>inset</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,4} | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Positioned elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the height of the containing block for <code>top</code> and&#13;
<code>bottom</code>, and the width of the containing block for <code>right</code> and <code>left</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Yes, it looks like this should be shorthand for the logical properties, but it isn’t.  The following two rules have the same result:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#popup</code> <code class="p">{</code><code class="k">top</code><code class="o">:</code> <code class="m">25%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">4em</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">25%</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">2em</code><code class="p">;}</code>&#13;
<code class="nf">#popup</code> <code class="p">{</code><code class="nb">inset</code><code class="o">:</code> <code class="m">25%</code> <code class="m">4em</code> <code class="m">25%</code> <code class="m">2em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As with other physical shorthands such as those seen in <a data-type="xref" href="ch07.html#padding-borders-outlines-and-margins">Chapter 7</a>, the values are in the order TRBL (top, right, bottom, left), and an omitted value is copied from the opposite side.  Thus, <code>inset: 20px 2em</code> is the same as writing <code>inset: 20px 2em 20px 2em</code>.<a data-primary="" data-startref="ix_position_inset_short" data-type="indexterm" id="idm45176083688800"/><a data-primary="" data-startref="ix_log_prop_float" data-type="indexterm" id="idm45176083687920"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Width and Height" data-type="sect2"><div class="sect2" id="setting-width-and-height">&#13;
<h2>Setting Width and Height</h2>&#13;
&#13;
<p>After <a data-primary="offsets" data-secondary="length values" data-type="indexterm" id="ix_offset_length"/><a data-primary="positioning" data-secondary="width and height" data-type="indexterm" id="ix_position_w_h"/><a data-primary="width property" data-secondary="positioning elements" data-type="indexterm" id="ix_width_prop2"/><a data-primary="height property" data-secondary="positioning elements" data-type="indexterm" id="ix_height_prop2"/>determining where you’re going to&#13;
position an element, you will often want to declare how wide and how high that&#13;
element should be. In addition,&#13;
you’ll likely want to limit how high or wide a positioned element gets.</p>&#13;
&#13;
<p>If you want to give your positioned element a specific width, the property to turn to is <code>width</code>. Similarly, <code>height</code> will let you&#13;
declare a specific height for a positioned element.</p>&#13;
&#13;
<p>Although it is sometimes important to set the <code>width</code> and <code>height</code> of a positioned element, it is not always necessary. For&#13;
example, if the placement of the four sides of the element is described&#13;
using <code>top</code>, <code>right</code>, <code>bottom</code>, and <code>left</code> (or with <code>inset-block-start</code>, <code>inset-inline-start</code>, etc.), then the <code>height</code> and&#13;
<code>width</code> of the element are implicitly determined by the offsets. Assume&#13;
that we want an absolutely positioned element to fill the left half of&#13;
its containing block, from top to bottom. We could use these values,&#13;
with the result depicted in <a data-type="xref" href="#positioning_offset_only">Figure 10-27</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nb">inset</code><code class="o">:</code> <code class="m">0</code> <code class="m">50%</code> <code class="m">0</code> <code class="m">0</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="positioning_offset_only">&#13;
<img alt="css5 1027" src="assets/css5_1027.png"/>&#13;
<h6><span class="label">Figure 10-27. </span>Positioning and sizing an element by using only the offset properties</h6>&#13;
</div></figure>&#13;
&#13;
<p>Since the default value of both <code>width</code> and <code>height</code> is <code>auto</code>, the&#13;
result shown in <a data-type="xref" href="#positioning_offset_only">Figure 10-27</a> is exactly the same as if&#13;
we had used these values:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nb">inset</code><code class="o">:</code> <code class="m">0</code> <code class="m">50%</code> <code class="m">0</code> <code class="m">0</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">100%</code><code class="p">;</code></pre>&#13;
&#13;
<p>The presence of <code>width</code> and <code>height</code> in this specific example adds nothing to the&#13;
layout of the element.</p>&#13;
&#13;
<p>If we were to add padding, a border, or a margin to the&#13;
element, the presence of explicit values for <code>height</code> and <code>width</code>&#13;
could very well make a difference:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nb">inset</code><code class="o">:</code> <code class="m">0</code> <code class="m">50%</code> <code class="m">0</code> <code class="m">0</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">100%</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code></pre>&#13;
&#13;
<p>This will give us a positioned element that extends out of its&#13;
containing block, as shown in <a data-type="xref" href="#positioning_partially_outside_block">Figure 10-28</a>.</p>&#13;
&#13;
<figure><div class="figure" id="positioning_partially_outside_block">&#13;
<img alt="css5 1028" src="assets/css5_1028.png"/>&#13;
<h6><span class="label">Figure 10-28. </span>Positioning an element partially outside its containing block</h6>&#13;
</div></figure>&#13;
&#13;
<p>This happens because (by default) the padding is added to the content&#13;
area, and the content area’s size is determined by the values of&#13;
<code>height</code> and <code>width</code>. To get the padding we want and still have&#13;
the element fit inside its containing block, we would either remove the&#13;
<code>height</code> and <code>width</code> declarations, explicitly set them both to <code>auto</code>,&#13;
or set <code>box-sizing</code> to <code>border-box</code>.<a data-primary="" data-startref="ix_height_prop2" data-type="indexterm" id="idm45176083536064"/><a data-primary="" data-startref="ix_width_prop2" data-type="indexterm" id="idm45176083535056"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Limiting Width and Height" data-type="sect2"><div class="sect2" id="limiting-width-and-height">&#13;
<h2>Limiting Width and Height</h2>&#13;
&#13;
<p>Should it become necessary or desirable, you can place limits on an&#13;
element’s width by using the following properties, which we’ll refer to&#13;
as the <em>min-max properties</em>. An <a data-primary="min-width property" data-type="indexterm" id="ix_min_width_prop"/><a data-primary="min-height property" data-type="indexterm" id="ix_min_ht_prop"/>element’s content area can be defined to&#13;
have minimum dimensions by using <code>min-width</code> and <code>min-height</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176083528448">&#13;
<h1>min-width, min-height</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements except nonreplaced inline elements and table&#13;
elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the width of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For percentages, as specified; for length values, the&#13;
absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Similarly, an <a data-primary="max-height property" data-type="indexterm" id="ix_max_ht_prop"/><a data-primary="max-width property" data-type="indexterm" id="ix_max_width_prop"/>element’s dimensions can be limited using the properties&#13;
<code>max-width</code> and <code>max-height</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176083490304">&#13;
<h1>max-width, max-height</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements except nonreplaced inline elements and table&#13;
elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to the height of the containing block</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For percentages, as specified; for length values, the&#13;
absolute length; otherwise, <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The names of these properties make them fairly self-explanatory. What’s&#13;
less obvious at first, but makes sense once you think about it, is that&#13;
values for all these properties cannot be negative.</p>&#13;
&#13;
<p>The following styles will force the positioned element to be at least&#13;
<code>10em</code> wide by <code>20em</code> tall, as illustrated in <a data-type="xref" href="#setting_minimum_width_height">Figure 10-29</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nb">inset</code><code class="o">:</code> <code class="m">10%</code> <code class="m">10%</code> <code class="m">20%</code> <code class="m">50%</code><code class="p">;</code> <code class="k">min-width</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">min-height</code><code class="o">:</code> <code class="m">20em</code><code class="p">;</code></pre>&#13;
&#13;
<figure><div class="figure" id="setting_minimum_width_height">&#13;
<img alt="image" src="assets/css5_1029.png"/>&#13;
<h6><span class="label">Figure 10-29. </span>Setting a minimum width and height for a positioned element</h6>&#13;
</div></figure>&#13;
&#13;
<p>This isn’t a very robust solution since it forces the element to be at&#13;
least a certain size regardless of the size of its containing block.&#13;
Here’s a better one:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nb">inset</code><code class="o">:</code> <code class="m">10%</code> <code class="m">10%</code> <code class="nb">auto</code> <code class="m">50%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">min-width</code><code class="o">:</code> <code class="m">15em</code><code class="p">;</code></pre>&#13;
&#13;
<p>Here, the element should be 40% as wide as the&#13;
containing block but can never be less than <code>15em</code> wide. We’ve also&#13;
changed the <code>bottom</code> and <code>height</code> so that they’re automatically&#13;
determined. This will let the element be as tall as necessary to display&#13;
its content, no matter how narrow it gets (never less than <code>15em</code>, though!).</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We’ll look at the role <code>auto</code> plays in the height and width of&#13;
positioned elements in  <a data-type="xref" href="#placement-and-sizing-of-absolutely-positioned-elements">“Placement and Sizing of Absolutely Positioned Elements”</a>.</p>&#13;
</div>&#13;
&#13;
<p>You can turn all this around to keep elements from getting too wide or&#13;
tall by using <code>max-width</code> and <code>max-height</code>. Let’s imagine that, for some reason, we want an element to have three-quarters the&#13;
width of its containing block but to stop getting wider when it hits 400&#13;
pixels. The appropriate styles are as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">width</code><code class="o">:</code> <code class="m">75%</code><code class="p">;</code> <code class="k">max-width</code><code class="o">:</code> <code class="m">400px</code><code class="p">;</code></pre>&#13;
&#13;
<p>One great advantage of the min-max properties is that they let you mix&#13;
units with relative safety. You can use percentage-based sizes while&#13;
setting length-based limits, or vice versa.</p>&#13;
&#13;
<p>It’s worth mentioning that these min-max properties can be very useful&#13;
in conjunction with floated elements. For example, we can allow&#13;
a floated element’s width to be relative to the width of its parent&#13;
element (which is its containing block), while <span class="keep-together">making</span> sure that the&#13;
float’s width never goes below <code>10em</code>. The reverse approach is also&#13;
possible:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.aside</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">40em</code><code class="p">;</code> <code class="k">max-width</code><code class="o">:</code> <code class="m">40%</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will set the float to <code>40em</code> wide, unless that would be more than&#13;
40% the width of the containing block, in which case the float will be&#13;
limited to that 40% width.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For details on what to do with content that overflows an element when it’s been constrained to a certain maximum size, see <a data-type="xref" href="ch06.html#overflow">“Handling Content Overflow”</a>.<a data-primary="" data-startref="ix_position_w_h" data-type="indexterm" id="idm45176083332512"/><a data-primary="" data-startref="ix_max_ht_prop" data-type="indexterm" id="idm45176083331536"/><a data-primary="" data-startref="ix_max_width_prop" data-type="indexterm" id="idm45176083330592"/><a data-primary="" data-startref="ix_min_width_prop" data-type="indexterm" id="idm45176083329648"/><a data-primary="" data-startref="ix_min_ht_prop" data-type="indexterm" id="idm45176083328704"/><a data-primary="" data-startref="ix_offset_length" data-type="indexterm" id="idm45176083327760"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Absolute Positioning" data-type="sect1"><div class="sect1" id="pos_absolute-positioning">&#13;
<h1>Absolute Positioning</h1>&#13;
&#13;
<p>Since <a data-primary="offsets" data-secondary="absolute positioning" data-type="indexterm" id="ix_offset_absol_pos"/><a data-primary="absolute positioning" data-type="indexterm" id="ix_absol_pos_ch10"/>most of the examples and figures in the previous sections illustrate absolute positioning, you’ve already seen a bunch of it in action. Most of what remains are the details of what&#13;
happens when absolute positioning is invoked.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Containing Blocks and Absolutely Positioned Elements" data-type="sect2"><div class="sect2" id="containing-blocks-and-absolutely-positioned-elements">&#13;
<h2>Containing Blocks and Absolutely Positioned Elements</h2>&#13;
&#13;
<p>When an <a data-primary="absolute positioning" data-secondary="containing blocks and" data-type="indexterm" id="ix_absol_pos_cont"/><a data-primary="containing blocks" data-secondary="positioning and" data-type="indexterm" id="ix_contain_block_pos"/><a data-primary="visual formatting" data-secondary="block flow direction" data-type="indexterm" id="ix_vis_format_flow"/><a data-primary="positioning" data-secondary="containing blocks and" data-type="indexterm" id="ix_position_contain"/><a data-primary="blocks" data-secondary="containing blocks" data-type="indexterm" id="ix_block_contain"/>element is positioned absolutely, it is completely removed from&#13;
the document flow. It is then positioned with respect to its closest positioned ancestor, if any, otherwise its containing&#13;
block, and its margin edges are placed using the offset properties&#13;
(<code>top</code>, <code>left</code>, <code>inset-inline-start</code>, etc.). The positioned element does not flow around the&#13;
content of other elements, nor does their content flow around the&#13;
positioned element. This implies that an absolutely positioned element&#13;
may overlap other elements or be overlapped by them. (We’ll see how to&#13;
affect the overlapping order later.)</p>&#13;
&#13;
<p>The containing block for an absolutely positioned element is the nearest&#13;
ancestor element that has a <code>position</code> value other than <code>static</code>. It is&#13;
common for an author to pick an element that will serve as the&#13;
containing block for the absolutely positioned element and give it a&#13;
<code>position</code> of <code>relative</code> with no offsets, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.contain</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Consider the example in <a data-type="xref" href="#using_relative_positioning">Figure 10-30</a>, which illustrates the&#13;
following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">margin</code><code class="o">:</code> <code class="m">2em</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.contain</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;}</code> <code class="c">/* establish a containing block*/</code>&#13;
<code class="nt">b</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="nb">inset</code><code class="o">:</code> <code class="nb">auto</code> <code class="m">0</code> <code class="m">0</code> <code class="nb">auto</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">8em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">5em</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;body&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>This<code class="w"> </code>paragraph<code class="w"> </code>does<code class="w"> </code><code class="nt">&lt;em&gt;</code>not<code class="nt">&lt;/em&gt;</code><code class="w"> </code>establish<code class="w"> </code>a<code class="w"> </code>containing<code class="w"> </code>block<code class="w"> </code>for<code class="w"> </code>any<code class="w"> </code>of<code class="w"/>&#13;
<code class="w">    </code>its<code class="w"> </code>descendant<code class="w"> </code>elements<code class="w"> </code>that<code class="w"> </code>are<code class="w"> </code>absolutely<code class="w"> </code>positioned.<code class="w"> </code>Therefore,<code class="w"> </code>the<code class="w"/>&#13;
<code class="w">    </code>absolutely<code class="w"> </code>positioned<code class="w"> </code><code class="nt">&lt;b&gt;</code>boldface<code class="nt">&lt;/b&gt;</code><code class="w"> </code>element<code class="w"> </code>it<code class="w"> </code>contains<code class="w"> </code>will<code class="w"> </code>be<code class="w"/>&#13;
<code class="w">    </code>positioned<code class="w"> </code>with<code class="w"> </code>respect<code class="w"> </code>to<code class="w"> </code>the<code class="w"> </code>initial<code class="w"> </code>containing<code class="w"> </code>block.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"contain"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>Thanks<code class="w"> </code>to<code class="w"> </code><code class="nt">&lt;code&gt;</code>position:<code class="w"> </code>relative<code class="nt">&lt;/code&gt;</code>,<code class="w"> </code>this<code class="w"> </code>paragraph<code class="w"> </code>establishes<code class="w"> </code>a<code class="w"/>&#13;
<code class="w">    </code>containing<code class="w"> </code>block<code class="w"> </code>for<code class="w"> </code>any<code class="w"> </code>of<code class="w"> </code>its<code class="w"> </code>descendant<code class="w"> </code>elements<code class="w"> </code>that<code class="w"> </code>are<code class="w"> </code>absolutely<code class="w"/>&#13;
<code class="w">    </code>positioned.<code class="w"> </code>Since<code class="w"> </code>there<code class="w"> </code>is<code class="w"> </code>such<code class="w"> </code>an<code class="w"> </code>element--<code class="w"> </code><code class="nt">&lt;em&gt;</code>that<code class="w"> </code>is<code class="w"> </code>to<code class="w"> </code>say,<code class="w"> </code><code class="nt">&lt;b&gt;</code>a<code class="w"/>&#13;
<code class="w">    </code>boldfaced<code class="w"> </code>element<code class="w"> </code>that<code class="w"> </code>is<code class="w"> </code>absolutely<code class="w"> </code>positioned,<code class="nt">&lt;/b&gt;</code><code class="w"> </code>placed<code class="w"> </code>with<code class="w"> </code>respect<code class="w"/>&#13;
<code class="w">    </code>to<code class="w"> </code>its<code class="w"> </code>containing<code class="w"> </code>block<code class="w"> </code>(the<code class="w"> </code>paragraph)<code class="nt">&lt;/em&gt;</code>,<code class="w"> </code>it<code class="w"> </code>will<code class="w"> </code>appear<code class="w"> </code>within<code class="w"> </code>the<code class="w"/>&#13;
<code class="w">    </code>element<code class="w"> </code>box<code class="w"> </code>generated<code class="w"> </code>by<code class="w"> </code>the<code class="w"> </code>paragraph.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/body&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The <code>&lt;b&gt;</code> elements in both paragraphs have been absolutely positioned. The&#13;
difference is in the containing block used for each one. The <code>&lt;b&gt;</code> element&#13;
in the first paragraph is positioned with respect to the initial&#13;
containing block, because all of its ancestor elements have a <code>position</code>&#13;
of <code>static</code>. The second paragraph has been set to&#13;
<code>position: relative</code>, so it establishes a containing block for its&#13;
descendants.</p>&#13;
&#13;
<figure><div class="figure" id="using_relative_positioning">&#13;
<img alt="image" src="assets/css5_1030.png"/>&#13;
<h6><span class="label">Figure 10-30. </span>Using relative positioning to define containing blocks</h6>&#13;
</div></figure>&#13;
&#13;
<p>You’ve probably noted that in that second paragraph, the positioned&#13;
element overlaps some of the text content of the paragraph. There is no&#13;
way to avoid this, short of positioning the <code>&lt;b&gt;</code> element outside of the&#13;
paragraph or specifying a padding for the paragraph that is&#13;
wide enough to accommodate the positioned element. Also, since the <code>&lt;b&gt;</code>&#13;
element has a transparent background, the paragraph’s text shows through&#13;
the positioned element. The only way to avoid this is to set a&#13;
background for the positioned element, or else move it out of the&#13;
paragraph entirely.</p>&#13;
&#13;
<p>Assuming the containing block is the root element, you could drop in an absolutely positioned&#13;
paragraph, as follows, and get a result like that shown in <a data-type="xref" href="#positioning_element_contained_by_root">Figure 10-31</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">&lt;</code><code class="n">p</code> <code class="n">style</code><code class="o">=</code><code class="s2">"position: absolute; top: 0; right: 25%; left: 25%; bottom:</code>&#13;
<code class="s2">    auto; width: 50%; height: auto; background: silver;"</code><code class="o">&gt;</code>&#13;
    <code class="o">...</code>&#13;
<code class="o">&lt;/</code><code class="n">p</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>The paragraph is now positioned at the very beginning of the document,&#13;
half as wide as the document’s width and overwriting other content.</p>&#13;
&#13;
<figure><div class="figure" id="positioning_element_contained_by_root">&#13;
<img alt="image" src="assets/css5_1031.png"/>&#13;
<h6><span class="label">Figure 10-31. </span>Positioning an element whose containing block is the root element</h6>&#13;
</div></figure>&#13;
&#13;
<p>An important point to highlight is that when an element is absolutely&#13;
positioned, it establishes a containing block for its descendant&#13;
elements. For example, we can absolutely position an element and then&#13;
absolutely position one of its children by using the following styles and basic markup (depicted in <a data-type="xref" href="#containing_blocks_from_absolute_pos">Figure 10-32</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">100%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="m">#EEE</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.a</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">15em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">100%</code><code class="p">;</code>&#13;
    <code class="k">margin-left</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="m">#CCC</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nc">.b</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code>&#13;
    <code class="k">margin-top</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="m">#AAA</code><code class="p">;}</code>&#13;
&#13;
<code class="o">&lt;</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">class</code><code class="o">=</code><code class="s2">"a"</code><code class="o">&gt;</code>&#13;
        <code class="nt">absolutely</code> <code class="nt">positioned</code> <code class="nt">element</code> <code class="nt">A</code>&#13;
        <code class="o">&lt;</code><code class="nt">div</code> <code class="nt">class</code><code class="o">=</code><code class="s2">"b"</code><code class="o">&gt;</code>&#13;
            <code class="nt">absolutely</code> <code class="nt">positioned</code> <code class="nt">element</code> <code class="nt">B</code>&#13;
        <code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
    <code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code>&#13;
    <code class="nt">containing</code> <code class="nt">block</code>&#13;
<code class="o">&lt;/</code><code class="nt">div</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>Remember that if the <a data-primary="scrolling" data-secondary="absolutely positioned elements" data-type="indexterm" id="idm45176082787920"/>document is scrolled, the absolutely positioned&#13;
elements will scroll right along with it. This is true of all absolutely&#13;
positioned elements that are not descendants of fixed-position or&#13;
sticky-position elements.</p>&#13;
&#13;
<p>This happens because, eventually, the elements are positioned in&#13;
relation to something that’s part of the normal flow. For example, if&#13;
you absolutely position a table, and its containing block is the initial&#13;
containing block, then the positioned table will scroll because the initial containing&#13;
block is part of the normal flow, and thus it scrolls.<a data-primary="" data-startref="ix_block_contain" data-type="indexterm" id="idm45176082786560"/><a data-primary="" data-startref="ix_position_contain" data-type="indexterm" id="idm45176082870896"/><a data-primary="" data-startref="ix_vis_format_flow" data-type="indexterm" id="idm45176082869952"/><a data-primary="" data-startref="ix_contain_block_pos" data-type="indexterm" id="idm45176082768416"/><a data-primary="" data-startref="ix_absol_pos_cont" data-type="indexterm" id="idm45176082767568"/></p>&#13;
&#13;
<p>If you want to position elements so that they’re placed relative to the&#13;
viewport and don’t scroll along with the rest of the document, keep&#13;
reading. <a data-type="xref" href="#fixed-positioning">“Fixed Positioning”</a> has the answers you&#13;
seek.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="containing_blocks_from_absolute_pos">&#13;
<img alt="image" src="assets/css5_1032.png"/>&#13;
<h6><span class="label">Figure 10-32. </span>Absolutely positioned elements establish containing blocks</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Placement and Sizing of Absolutely Positioned Elements" data-type="sect2"><div class="sect2" id="placement-and-sizing-of-absolutely-positioned-elements">&#13;
<h2>Placement and Sizing of Absolutely Positioned Elements</h2>&#13;
&#13;
<p>Combining the concepts of placement and sizing may seem odd, but&#13;
it’s a necessity with absolutely positioned elements because the&#13;
specification binds them closely together. This is not such a&#13;
strange pairing, upon reflection. Consider what happens if an element is&#13;
positioned using the four physical offset properties, like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#masthead</code> <code class="nt">h1</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="nb">inset</code><code class="o">:</code> <code class="m">1em</code> <code class="m">25%</code> <code class="m">10px</code> <code class="m">1em</code><code class="p">;</code>&#13;
    <code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Here, the height and width of the <code>&lt;h1&gt;</code>’s element box is determined by&#13;
the placement of its outer margin edges, as shown in <a data-type="xref" href="#determining_height_based_on_offset">Figure 10-33</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="determining_height_based_on_offset">&#13;
<img alt="image" src="assets/css5_1033.png"/>&#13;
<h6><span class="label">Figure 10-33. </span>Determining the height of an element based on the offset properties</h6>&#13;
</div></figure>&#13;
&#13;
<p>If the containing block were made taller, the <code>&lt;h1&gt;</code> would also&#13;
become taller; if the containing block were narrowed, the <code>&lt;h1&gt;</code> would&#13;
become narrower. If we were to add margins or padding to the <code>&lt;h1&gt;</code>,&#13;
that would have further effects on its calculated height and width.</p>&#13;
&#13;
<p>But what if we do all that and then also try to set an explicit height and width?</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#masthead</code> <code class="nt">h1</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">10%</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Something has to give, because it’s incredibly unlikely that all those&#13;
values will be accurate. In fact, the containing block would have to be&#13;
exactly two and a half times as wide as the <code>&lt;h1&gt;</code>’s computed value of&#13;
<code>font-size</code> for all of the shown values to be accurate. Any other&#13;
<code>width</code> would mean at least one value is wrong and has to be ignored.&#13;
Figuring out which one depends on multiple factors, and the factors&#13;
change depending on whether an element is replaced or nonreplaced. (See <a data-type="xref" href="ch06.html#basic-visual-formatting">Chapter 6</a> for replaced versus nonreplaced &#13;
<span class="keep-together">elements.)</span></p>&#13;
&#13;
<p>For that matter, consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#masthead</code> <code class="nt">h1</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>What should the result be? As it happens, the answer is <em>not</em> “reset the&#13;
values to 0.” We’ll see the actual answer, starting in the next&#13;
section.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Auto-edges" data-type="sect2"><div class="sect2" id="auto-edges">&#13;
<h2>Auto-edges</h2>&#13;
&#13;
<p>When <a data-primary="positioning" data-secondary="auto edges and" data-type="indexterm" id="ix_position_auto_edge"/><a data-primary="auto-edges, absolute positioning" data-type="indexterm" id="ix_auto_edge_absol_pos"/><a data-primary="absolute positioning" data-secondary="auto-edges" data-type="indexterm" id="ix_absol_pos_auto"/>absolutely positioning an element, a special behavior&#13;
applies when any of the offset properties other than <code>bottom</code> are set to&#13;
<code>auto</code>. Let’s take <code>top</code> as an example. Consider the following:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>When<code class="w"> </code>we<code class="w"> </code>consider<code class="w"> </code>the<code class="w"> </code>effect<code class="w"> </code>of<code class="w"> </code>positioning,<code class="w"> </code>it<code class="w"> </code>quickly<code class="w"> </code>becomes<code class="w"> </code>clear<code class="w"> </code>that<code class="w"/>&#13;
<code class="w">    </code>authors<code class="w"> </code>can<code class="w"> </code>do<code class="w"> </code>a<code class="w"> </code>great<code class="w"> </code>deal<code class="w"> </code>of<code class="w"> </code>damage<code class="w"> </code>to<code class="w"> </code>layout,<code class="w"> </code>just<code class="w"> </code>as<code class="w"> </code>they<code class="w"> </code>can<code class="w"> </code>do<code class="w"> </code>very<code class="w"/>&#13;
<code class="w">    </code>interesting<code class="w"> </code>things.<code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; top: auto;</code>&#13;
<code class="s">    left: 0;"</code><code class="nt">&gt;</code>[4]<code class="nt">&lt;/span&gt;</code><code class="w"> </code>This<code class="w"> </code>is<code class="w"> </code>usually<code class="w"> </code>the<code class="w"> </code>case<code class="w"> </code>with<code class="w"> </code>useful<code class="w"> </code>technologies:<code class="w"/>&#13;
<code class="w">    </code>the<code class="w"> </code>sword<code class="w"> </code>always<code class="w"> </code>has<code class="w"> </code>at<code class="w"> </code>least<code class="w"> </code>two<code class="w"> </code>edges,<code class="w"> </code>both<code class="w"> </code>of<code class="w"> </code>them<code class="w"> </code>sharp.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>What should happen? For <code>left</code>, the left edge of the <a data-primary="positioning" data-secondary="static" data-type="indexterm" id="idm45176082540320"/><a data-primary="static positioning" data-type="indexterm" id="idm45176082494160"/><a data-primary="offsets" data-secondary="static positioning" data-type="indexterm" id="idm45176082493488"/>element&#13;
should be placed against the left edge of its containing block (which&#13;
we’ll assume here to be the initial containing block).</p>&#13;
&#13;
<p>For <code>top</code>,&#13;
however, something much more interesting happens. The top of the&#13;
positioned element should line up with the place where its top would&#13;
have been if it were not positioned at all. In other words, imagine&#13;
where the <code>&lt;span&gt;</code> would have been placed if its <code>position</code> value were&#13;
<code>static</code>; this is its <em>static position</em>—the place where its top edge&#13;
should be calculated to sit.  Therefore, we should get the result shown in <a data-type="xref" href="#using_static_top_for_absolute_pos">Figure 10-34</a>.</p>&#13;
&#13;
<figure><div class="figure" id="using_static_top_for_absolute_pos">&#13;
<img alt="image" src="assets/css5_1034.png"/>&#13;
<h6><span class="label">Figure 10-34. </span>Absolutely positioning an element consistently with its “static” top edge</h6>&#13;
</div></figure>&#13;
&#13;
<p>The “[4]” sits just outside the paragraph’s content because the initial&#13;
containing block’s left edge is to the left of the paragraph’s left&#13;
edge.</p>&#13;
&#13;
<p>The same basic rules hold true for <code>left</code> and <code>right</code> being set to&#13;
<code>auto</code>. In those cases, the left (or right) edge of a positioned element&#13;
lines up with the spot where the edge would have been placed if the&#13;
element weren’t positioned. So let’s modify our previous example so that both <code>top</code> and <code>left</code> are set to <code>auto</code>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>When<code class="w"> </code>we<code class="w"> </code>consider<code class="w"> </code>the<code class="w"> </code>effect<code class="w"> </code>of<code class="w"> </code>positioning,<code class="w"> </code>it<code class="w"> </code>quickly<code class="w"> </code>becomes<code class="w"> </code>clear<code class="w"> </code>that<code class="w"/>&#13;
<code class="w">    </code>authors<code class="w"> </code>can<code class="w"> </code>do<code class="w"> </code>a<code class="w"> </code>great<code class="w"> </code>deal<code class="w"> </code>of<code class="w"> </code>damage<code class="w"> </code>to<code class="w"> </code>layout,<code class="w"> </code>just<code class="w"> </code>as<code class="w"> </code>they<code class="w"> </code>can<code class="w"> </code>do<code class="w"> </code>very<code class="w"/>&#13;
<code class="w">    </code>interesting<code class="w"> </code>things.<code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; top: auto; left:</code>&#13;
<code class="s">    auto;"</code><code class="nt">&gt;</code>[4]<code class="nt">&lt;/span&gt;</code><code class="w"> </code>This<code class="w"> </code>is<code class="w"> </code>usually<code class="w"> </code>the<code class="w"> </code>case<code class="w"> </code>with<code class="w"> </code>useful<code class="w"> </code>technologies:<code class="w"/>&#13;
<code class="w">    </code>the<code class="w"> </code>sword<code class="w"> </code>always<code class="w"> </code>has<code class="w"> </code>at<code class="w"> </code>least<code class="w"> </code>two<code class="w"> </code>edges,<code class="w"> </code>both<code class="w"> </code>of<code class="w"> </code>them<code class="w"> </code>sharp.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This results in <a data-type="xref" href="#static_pos_for_absolute_pos">Figure 10-35</a>.</p>&#13;
&#13;
<figure><div class="figure" id="static_pos_for_absolute_pos">&#13;
<img alt="image" src="assets/css5_1035.png"/>&#13;
<h6><span class="label">Figure 10-35. </span>Absolutely positioning an element consistently with its “static” position</h6>&#13;
</div></figure>&#13;
&#13;
<p>The “[4]” now sits right where it would have were it not positioned.&#13;
Note that, since it <em>is</em> positioned, its normal-flow space is closed up.&#13;
This causes the positioned element to overlap the normal-flow content.</p>&#13;
&#13;
<p>This auto-placement works only in certain situations, generally wherever&#13;
there are few constraints on the other dimensions of a positioned&#13;
element. Our previous example could be auto-placed because it had no&#13;
constraints on its height or width, nor on the&#13;
placement of the bottom and right edges. But suppose, for some reason,&#13;
there had been such constraints. Consider the following:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>When<code class="w"> </code>we<code class="w"> </code>consider<code class="w"> </code>the<code class="w"> </code>effect<code class="w"> </code>of<code class="w"> </code>positioning,<code class="w"> </code>it<code class="w"> </code>quickly<code class="w"> </code>becomes<code class="w"> </code>clear<code class="w"> </code>that<code class="w"/>&#13;
<code class="w">    </code>authors<code class="w"> </code>can<code class="w"> </code>do<code class="w"> </code>a<code class="w"> </code>great<code class="w"> </code>deal<code class="w"> </code>of<code class="w"> </code>damage<code class="w"> </code>to<code class="w"> </code>layout,<code class="w"> </code>just<code class="w"> </code>as<code class="w"> </code>they<code class="w"> </code>can<code class="w"> </code>do<code class="w"> </code>very<code class="w"/>&#13;
<code class="w">    </code>interesting<code class="w"> </code>things.<code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; inset: auto 0 0 auto;</code>&#13;
<code class="s">    height: 2em; width: 5em;"</code><code class="nt">&gt;</code>[4]<code class="nt">&lt;/span&gt;</code><code class="w"> </code>This<code class="w"> </code>is<code class="w"> </code>usually<code class="w"> </code>the<code class="w"> </code>case<code class="w"> </code>with<code class="w"> </code>useful<code class="w"/>&#13;
<code class="w">    </code>technologies:<code class="w"> </code>the<code class="w"> </code>sword<code class="w"> </code>always<code class="w"> </code>has<code class="w"> </code>at<code class="w"> </code>least<code class="w"> </code>two<code class="w"> </code>edges,<code class="w"> </code>both<code class="w"> </code>of<code class="w"> </code>them<code class="w"> </code>sharp.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>It is not possible to satisfy all of those values. Determining what&#13;
happens is the subject of the next section.<a data-primary="" data-startref="ix_absol_pos_auto" data-type="indexterm" id="idm45176082307856"/><a data-primary="" data-startref="ix_auto_edge_absol_pos" data-type="indexterm" id="idm45176082228656"/><a data-primary="" data-startref="ix_offset_position3" data-type="indexterm" id="idm45176082227744"/><a data-primary="" data-startref="ix_position_auto_edge" data-type="indexterm" id="idm45176082226800"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Placing and Sizing Nonreplaced Elements" data-type="sect2"><div class="sect2" id="placing-and-sizing-nonreplaced-elements">&#13;
<h2>Placing and Sizing Nonreplaced Elements</h2>&#13;
&#13;
<p>In general, the size and <a data-primary="positioning" data-secondary="nonreplaced elements" data-type="indexterm" id="ix_pos_nonrep"/><a data-primary="absolute positioning" data-secondary="nonreplaced elements" data-type="indexterm" id="ix_absol_pos_nonrep"/>placement of an element depends on its&#13;
containing block. The values of its various properties (<code>width</code>,&#13;
<code>right</code>, <code>padding-left</code>, and so on) affect its layout, but&#13;
the foundation is the containing block.</p>&#13;
&#13;
<p>Consider the width and horizontal placement of a positioned element. It&#13;
can be represented as an equation that states the following:</p>&#13;
&#13;
<pre data-type="programlisting">left + margin-left + border-left-width + padding-left + width +&#13;
padding-right + border-right-width + margin-right + right =&#13;
the width of the containing block</pre>&#13;
&#13;
<p>This calculation is fairly reasonable. It’s basically the equation that&#13;
determines how block-level elements in the normal flow are sized, except&#13;
it adds <code>left</code> and <code>right</code> to the mix. So how do all these interact?&#13;
We have a series of rules to work through.</p>&#13;
&#13;
<p>First, if <code>left</code>, <code>width</code>, and <code>right</code> are all set to <code>auto</code>, you&#13;
get the result seen in the previous section: the left edge is placed at&#13;
its static position, assuming a left-to-right language. In right-to-left&#13;
languages, the right edge is placed at its static position. The width of&#13;
the element is set to be “shrink to fit,” which means the element’s&#13;
content area is made only as wide as necessary to contain its content.&#13;
The nonstatic position property (<code>right</code> in left-to-right languages,&#13;
<code>left</code> in right-to-left) is set to take up the remaining distance. For&#13;
&#13;
<span class="keep-together">example:</span></p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: relative; width: 25em; border: 1px dotted;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>An<code class="w"> </code>absolutely<code class="w"> </code>positioned<code class="w"> </code>element<code class="w"> </code>can<code class="w"> </code>have<code class="w"> </code>its<code class="w"> </code>content<code class="w"> </code><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position:</code>&#13;
<code class="s">    absolute; top: 0; left: 0; right: auto; width: auto; background:</code>&#13;
<code class="s">    silver;"</code><code class="nt">&gt;</code>shrink-wrapped<code class="nt">&lt;/span&gt;</code><code class="w"> </code>thanks<code class="w"> </code>to<code class="w"> </code>the<code class="w"> </code>way<code class="w"> </code>positioning<code class="w"> </code>rules<code class="w"> </code>work.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This results in <a data-type="xref" href="#shrink-to-fit">Figure 10-36</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="shrink-to-fit">&#13;
<img alt="image" src="assets/css5_1036.png"/>&#13;
<h6><span class="label">Figure 10-36. </span>The “shrink-to-fit” behavior of absolutely positioned elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>The top of the element is placed against the top of its containing block&#13;
(the <code>&lt;div&gt;</code>, in this case), and the width of the element is just as wide&#13;
as is needed to contain the content. The remaining distance from the&#13;
right edge of the element to the right edge of the containing block&#13;
becomes the computed value of <code>right</code>.</p>&#13;
&#13;
<p>Now suppose that only the left and right margins are set to <code>auto</code>, not&#13;
<code>left</code>, <code>width</code>, and <code>right</code>, as in this example:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: relative; width: 25em; border: 1px dotted;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>An<code class="w"> </code>absolutely<code class="w"> </code>positioned<code class="w"> </code>element<code class="w"> </code>can<code class="w"> </code>have<code class="w"> </code>its<code class="w"> </code>content<code class="w"> </code><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position:</code>&#13;
<code class="s">    absolute; top: 0; left: 1em; right: 1em; width: 10em; margin: 0 auto;</code>&#13;
<code class="s">    background: silver;"</code><code class="nt">&gt;</code>shrink-wrapped<code class="nt">&lt;/span&gt;</code><code class="w"> </code>thanks<code class="w"> </code>to<code class="w"> </code>the<code class="w"> </code>way<code class="w"> </code>positioning<code class="w"/>&#13;
<code class="w">    </code>rules<code class="w"> </code>work.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>What happens here is that the left and right margins, which are both&#13;
<code>auto</code>, are set to be equal. This will effectively center the element,&#13;
as shown in <a data-type="xref" href="#horizontally_centering_with_auto_margins">Figure 10-37</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="horizontally_centering_with_auto_margins">&#13;
<img alt="image" src="assets/css5_1037.png"/>&#13;
<h6><span class="label">Figure 10-37. </span>Horizontally centering an absolutely positioned element with &#13;
<span class="keep-together"><code>auto</code> margins</span></h6>&#13;
</div></figure>&#13;
&#13;
<p>This is basically the same as <code>auto</code>-margin centering in the normal flow.&#13;
So let’s make the margins something other than <code>auto</code>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: relative; width: 25em; border: 1px dotted;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>An<code class="w"> </code>absolutely<code class="w"> </code>positioned<code class="w"> </code>element<code class="w"> </code>can<code class="w"> </code>have<code class="w"> </code>its<code class="w"> </code>content<code class="w"> </code><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position:</code>&#13;
<code class="s">    absolute; top: 0; left: 1em; right: 1em; width: 10em; margin-left: 1em;</code>&#13;
<code class="s">    margin-right: 1em; background: silver;"</code><code class="nt">&gt;</code>shrink-wrapped<code class="nt">&lt;/span&gt;</code><code class="w"> </code>thanks<code class="w"> </code>to<code class="w"> </code>the<code class="w"/>&#13;
<code class="w">    </code>way<code class="w"> </code>positioning<code class="w"> </code>rules<code class="w"> </code>work.<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Now we have a problem. The positioned <code>&lt;span&gt;</code>’s properties add up to only&#13;
<code>14em</code>, whereas the containing block is <code>25em</code> wide. That’s an 11-em deficit&#13;
we have to make up somewhere.</p>&#13;
&#13;
<p>The rules state that, in this case, the user agent ignores the value for the inline-end side of the element and&#13;
solves for that. In other words, the result will be the same as if we’d&#13;
declared this:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 1em;</code>&#13;
<code class="s">right: 12em; width: 10em; margin-left: 1em; margin-right: 1em;</code>&#13;
<code class="s">right: auto; background: silver;"</code><code class="nt">&gt;</code>shrink-wrapped<code class="nt">&lt;/span&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This results in <a data-type="xref" href="#ignoring_value_for_right">Figure 10-38</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="ignoring_value_for_right">&#13;
<img alt="image" src="assets/css5_1038.png"/>&#13;
<h6><span class="label">Figure 10-38. </span>Ignoring the value for <code>right</code> in an overconstrained situation</h6>&#13;
</div></figure>&#13;
&#13;
<p>If one of the margins had been set to <code>auto</code>, that would have been&#13;
changed instead. Suppose we change the styles to state the following:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 1em;</code>&#13;
<code class="s">right: 1em; width: 10em; margin-left: 1em; margin-right: auto;</code>&#13;
<code class="s">background: silver;"</code><code class="nt">&gt;</code>shrink-wrapped<code class="nt">&lt;/span&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>The visual result would be the same as that in <a data-type="xref" href="#ignoring_value_for_right">Figure 10-38</a>, only it would&#13;
be attained by computing the right margin to <code>12em</code> instead of overriding&#13;
the value assigned to the property <code>right</code>.</p>&#13;
&#13;
<p>If, on the other hand, we&#13;
made the left margin <code>auto</code>, <em>it</em> would be reset, as illustrated in&#13;
<a data-type="xref" href="#ignoring_margin-right">Figure 10-39</a>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 1em;</code>&#13;
<code class="s">right: 1em; width: 10em; margin-left: auto; margin-right: 1em;</code>&#13;
<code class="s">background: silver;"</code><code class="nt">&gt;</code>shrink-wrapped<code class="nt">&lt;/span&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="ignoring_margin-right">&#13;
<img alt="image" src="assets/css5_1039.png"/>&#13;
<h6><span class="label">Figure 10-39. </span>Making use of an <code>auto</code> left margin</h6>&#13;
</div></figure>&#13;
&#13;
<p>In general, if only one of the properties is set to <code>auto</code>, that property will&#13;
be used to satisfy <span class="keep-together">the equation</span> given earlier in the section. Thus,&#13;
given the following styles, the element’s width would expand to whatever&#13;
size is needed, instead of “shrink-wrapping” the content:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;span</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 1em;</code>&#13;
<code class="s">right: 1em; width: auto; margin-left: 1em; margin-right: 1em;</code>&#13;
<code class="s">background: silver;"</code><code class="nt">&gt;</code>not<code class="w"> </code>shrink-wrapped<code class="nt">&lt;/span&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>So far we’ve really examined behavior only along the horizontal axis,&#13;
but very similar rules hold true along the vertical axis. If we take the&#13;
previous discussion and rotate it 90 degrees, as it were, we get almost&#13;
the same behavior. For example, the following markup results in <a data-type="xref" href="#vertical_layout_behavior">Figure 10-40</a>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: relative; width: 30em; height: 10em; border: 1px solid;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; left: 0; width: 30%;</code>&#13;
<code class="s">        background: #CCC; top: 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">            </code>element<code class="w"> </code>A<code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; left: 35%; width: 30%;</code>&#13;
<code class="s">        background: #AAA; top: 0; height: 50%;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">            </code>element<code class="w"> </code>B<code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; left: 70%; width: 30%;</code>&#13;
<code class="s">        background: #CCC; height: 50%; bottom: 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">            </code>element<code class="w"> </code>C<code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In the first case, the height of the element is shrink-wrapped to the&#13;
content. In the second, the unspecified property (<code>bottom</code>) is set to&#13;
make up the distance between the bottom of the positioned element and&#13;
the bottom of its containing block. In the third case, <code>top</code> is unspecified, and therefore used to make up the difference.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="vertical_layout_behavior">&#13;
<img alt="image" src="assets/css5_1040.png"/>&#13;
<h6><span class="label">Figure 10-40. </span>Vertical layout behavior for absolutely positioned elements</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">For that matter, auto-margins can lead to vertical centering. Given the&#13;
following styles, the absolutely positioned <code>&lt;div&gt;</code> will be vertically&#13;
centered within its containing block, as shown in <a data-type="xref" href="#vertically_centering_with_auto_margins">Figure 10-41</a>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: relative; width: 10em; height: 10em; border: 1px solid;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; left: 0; width: 100%; background: #CCC;</code>&#13;
<code class="s">        top: 0; height: 5em; bottom: 0; margin: auto 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">            </code>element<code class="w"> </code>D<code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="vertically_centering_with_auto_margins">&#13;
<img alt="css5 1041" src="assets/css5_1041.png"/>&#13;
<h6><span class="label">Figure 10-41. </span>Vertically centering an absolutely positioned element with auto-margins</h6>&#13;
</div></figure>&#13;
&#13;
<p>There are two small variations to point out. In horizontal layout,&#13;
either <code>right</code> or <code>left</code> can be placed according to the static position&#13;
if their values are <code>auto</code>. In vertical layout, only <code>top</code> can take on&#13;
the static position; <code>bottom</code>, for whatever reason, cannot.</p>&#13;
&#13;
<p>Also, if an absolutely positioned element’s size is overconstrained in&#13;
the vertical direction, <code>bottom</code> is ignored. Thus, in the following&#13;
situation, the declared value of <code>bottom</code> would be overridden by the&#13;
calculated value of <code>5em</code>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: relative; width: 10em; height: 10em; border: 1px solid;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; left: 0; width: 100%; background: #CCC;</code>&#13;
<code class="s">        top: 0; height: 5em; bottom: 0; margin: 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">            </code>element<code class="w"> </code>D<code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>There is no provision for <code>top</code> to be ignored if the properties are&#13;
overconstrained.<a data-primary="" data-startref="ix_absol_pos_nonrep" data-type="indexterm" id="idm45176081749376"/><a data-primary="" data-startref="ix_pos_nonrep" data-type="indexterm" id="idm45176081748528"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Placing and Sizing Replaced Elements" data-type="sect2"><div class="sect2" id="placing-and-sizing-replaced-elements">&#13;
<h2>Placing and Sizing Replaced Elements</h2>&#13;
&#13;
<p>Positioning <a data-primary="positioning" data-secondary="replaced elements" data-type="indexterm" id="ix_pos_replaced"/><a data-primary="replaced elements" data-secondary="positioning" data-type="indexterm" id="ix_replaced_pos"/><a data-primary="absolute positioning" data-secondary="replaced elements" data-type="indexterm" id="ix_absol_pos_rep"/>rules are different for replaced elements (e.g., images)&#13;
than they are for nonreplaced elements. This is because replaced&#13;
elements have an intrinsic height and width, and therefore are not&#13;
altered unless explicitly changed by the author. Thus, there is no&#13;
concept of “shrink to fit” in the positioning of replaced elements.</p>&#13;
&#13;
<p class="pagebreak-before">The behaviors that go into placing and sizing replaced elements are most&#13;
easily expressed by this series of rules, to be taken one after the other:</p>&#13;
<ol>&#13;
<li>&#13;
<p>If <code>width</code> is set to <code>auto</code>, the used value of <code>width</code> is determined&#13;
by the intrinsic width of the element’s content. Thus, if an image is&#13;
intrinsically 50 pixels wide, the used value is calculated to be&#13;
<code>50px</code>. If <code>width</code> is explicitly declared (that is, something like&#13;
<code>100px</code> or <code>50%</code>), the width is set to that value.</p>&#13;
</li>&#13;
<li>&#13;
<p>If <code>left</code> has the value <code>auto</code> in a left-to-right language, replace&#13;
<code>auto</code> with the static position. In right-to-left languages, replace an&#13;
<code>auto</code> value for <code>right</code> with the static position.</p>&#13;
</li>&#13;
<li>&#13;
<p>If either <code>left</code> or <code>right</code> is still <code>auto</code> (in other words, it&#13;
hasn’t been replaced in a previous step), replace any <code>auto</code> on&#13;
<code>margin-left</code> or <code>margin-right</code> with <code>0</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If, at this point, both <code>margin-left</code> and <code>margin-right</code> are still&#13;
defined to be <code>auto</code>, set them to be equal, thus centering the element&#13;
in its containing block.</p>&#13;
</li>&#13;
<li>&#13;
<p>After all that, if only one <code>auto</code> value is left, change it to&#13;
equal the remainder of the equation.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This leads to the same basic behaviors you saw with absolutely positioned&#13;
nonreplaced elements, as long as you assume that there is an explicit&#13;
<code>width</code> for the nonreplaced element. Therefore, the following two&#13;
elements will have the same width and placement, assuming the image’s&#13;
intrinsic width is 100 pixels (see <a data-type="xref" href="#absolutely_positioning_replaced_element">Figure 10-42</a>):</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"frown.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"a frowny face"</code><code class="w"/>&#13;
<code class="w">        </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 50px; margin: 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 50px;</code>&#13;
<code class="s">        width: 100px; height: 100px; margin: 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code>it's<code class="w"> </code>a<code class="w"> </code>div!<code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="absolutely_positioning_replaced_element">&#13;
<img alt="css5 1042" src="assets/css5_1042.png"/>&#13;
<h6><span class="label">Figure 10-42. </span>Absolutely positioning a replaced element</h6>&#13;
</div></figure>&#13;
&#13;
<p>As with nonreplaced elements, if the values are overconstrained, the&#13;
user agent is supposed to ignore the value on the inline-end side: <code>right</code> in left-to-right&#13;
languages and <code>left</code> in right-to-left languages. Thus, in the following&#13;
example, the declared value for <code>right</code> is overridden with a computed&#13;
value of <code>50px</code>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: relative; width: 300px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"frown.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"a frowny face"</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: absolute; top: 0;</code>&#13;
<code class="s">        left: 50px; right: 125px; width: 200px; margin: 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Similarly, layout along the vertical axis is governed by this series of&#13;
rules:</p>&#13;
<ol>&#13;
<li>&#13;
<p>If <code>height</code> is set to <code>auto</code>, the computed value of <code>height</code> is&#13;
determined by the intrinsic height of the element’s content. Thus, the&#13;
height of an image 50 pixels tall is computed to be <code>50px</code>. If <code>height</code>&#13;
is explicitly declared (that is, something like <code>100px</code> or <code>50%</code>), the height is set to that value.</p>&#13;
</li>&#13;
<li>&#13;
<p>If <code>top</code> has the value <code>auto</code>, replace it with the replaced&#13;
element’s static position.</p>&#13;
</li>&#13;
<li>&#13;
<p>If <code>bottom</code> has a value of <code>auto</code>, replace any <code>auto</code> value on&#13;
<code>margin-top</code> or <code>margin-bottom</code> with <code>0</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If, at this point, both <code>margin-top</code> and <code>margin-bottom</code> are still&#13;
defined to be <code>auto</code>, set them to be equal, thus centering the element&#13;
in its containing block.</p>&#13;
</li>&#13;
<li>&#13;
<p>After all that, if only one <code>auto</code> value is left, change it to&#13;
equal the remainder of the equation.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>As with nonreplaced elements, if the values are overconstrained, the user agent is supposed to ignore the value for <code>bottom</code>.<a data-primary="" data-startref="ix_absol_pos_rep" data-type="indexterm" id="idm45176081558944"/><a data-primary="" data-startref="ix_pos_replaced" data-type="indexterm" id="idm45176081557936"/><a data-primary="" data-startref="ix_replaced_pos" data-type="indexterm" id="idm45176081556992"/></p>&#13;
&#13;
<p>Thus, the following markup results in <a data-type="xref" href="#stretching_replaced_elements">Figure 10-43</a>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">style=</code><code class="s">"position: relative; height: 200px; width: 200px; border: 1px solid;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"one.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"one"</code><code class="w"> </code><code class="na">width=</code><code class="s">"25"</code><code class="w"> </code><code class="na">height=</code><code class="s">"25"</code><code class="w"/>&#13;
<code class="w">        </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 0; margin: 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"two.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"two"</code><code class="w"> </code><code class="na">width=</code><code class="s">"25"</code><code class="w"> </code><code class="na">height=</code><code class="s">"25"</code><code class="w"/>&#13;
<code class="w">        </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 60px; margin: 10px 0;</code>&#13;
<code class="s">            bottom: 4377px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"three.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"three"</code><code class="w"> </code><code class="na">width=</code><code class="s">"25"</code><code class="w"> </code><code class="na">height=</code><code class="s">"25"</code><code class="w"/>&#13;
<code class="w">        </code><code class="na">style=</code><code class="s">"position: absolute; left: 0; width: 100px; margin: 10px;</code>&#13;
<code class="s">            bottom: 0;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"four.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"four"</code><code class="w"> </code><code class="na">width=</code><code class="s">"25"</code><code class="w"> </code><code class="na">height=</code><code class="s">"25"</code><code class="w"/>&#13;
<code class="w">        </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; height: 100px; right: 0;</code>&#13;
<code class="s">            width: 50px;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"five.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"five"</code><code class="w"> </code><code class="na">width=</code><code class="s">"25"</code><code class="w"> </code><code class="na">height=</code><code class="s">"25"</code><code class="w"/>&#13;
<code class="w">        </code><code class="na">style=</code><code class="s">"position: absolute; top: 0; left: 0; bottom: 0; right: 0;</code>&#13;
<code class="s">            margin: auto;"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="stretching_replaced_elements">&#13;
<img alt="css5 1043" src="assets/css5_1043.png"/>&#13;
<h6><span class="label">Figure 10-43. </span>Stretching replaced elements through positioning</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Placement on the Z-Axis" data-type="sect2"><div class="sect2" id="placement-on-the-z-axis">&#13;
<h2>Placement on the Z-Axis</h2>&#13;
&#13;
<p>With all of the <a data-primary="z-index property" data-type="indexterm" id="ix_zindex_prop"/><a data-primary="absolute positioning" data-secondary="z-index placement" data-type="indexterm" id="ix_absol_pos_zindex"/>positioning going on, there will inevitably be a&#13;
situation where two elements will try to exist in the same place,&#13;
visually speaking. One of them will have to overlap the&#13;
other—so how do we control which element comes out “on top”? This is&#13;
where &#13;
<span class="keep-together"><code>z-index</code></span> comes in.</p>&#13;
&#13;
<p>This property lets you alter the way that elements overlap one another.&#13;
It takes its name from the coordinate system in which side-to-side is&#13;
the x-axis and top-to-bottom is the y-axis. In such a case, the&#13;
third axis—which runs from back to front, as you look at the&#13;
display surface—is termed the <em>z-axis</em>. Thus, elements are given values&#13;
along this axis by using <code>z-index</code>. <a data-type="xref" href="#conceptual_view_of_zindex">Figure 10-44</a> illustrates this system.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176081411904">&#13;
<h1>z-index</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>integer</code></em>&gt; | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Positioned elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<figure><div class="figure" id="conceptual_view_of_zindex">&#13;
<img alt="css5 1044" src="assets/css5_1044.png"/>&#13;
<h6><span class="label">Figure 10-44. </span>A conceptual view of z-index stacking</h6>&#13;
</div></figure>&#13;
&#13;
<p>In this <a data-primary="stacking of elements" data-type="indexterm" id="ix_stack_elem"/>coordinate system, an element with a higher <code>z-index</code> value is&#13;
closer to the reader than those with lower <code>z-index</code> values. This will&#13;
cause the high-value element to overlap the others, as illustrated in&#13;
<a data-type="xref" href="#how_elements_are_stacked">Figure 10-45</a>, which is a “head-on” view of <a data-type="xref" href="#conceptual_view_of_zindex">Figure 10-44</a>. This precedence of&#13;
overlapping is referred to as <em>stacking</em>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="how_elements_are_stacked">&#13;
<img alt="image" src="assets/css5_1045.png"/>&#13;
<h6><span class="label">Figure 10-45. </span>How the elements are stacked</h6>&#13;
</div></figure>&#13;
&#13;
<p>Any integer can be used as a value for <code>z-index</code>, including negative&#13;
numbers. Assigning an element a negative <code>z-index</code> will move it further&#13;
away from the reader; that is, it will be moved lower in the stack.&#13;
Consider the following styles, illustrated in <a data-type="xref" href="#stacked_elements_can_overlap">Figure 10-46</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="n">rgba</code><code class="p">(</code><code class="m">255</code><code class="o">,</code><code class="m">255</code><code class="o">,</code><code class="m">255</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">9</code><code class="p">);</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nf">#first</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">40%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">z-index</code><code class="o">:</code> <code class="m">8</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nf">#second</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">-0.75em</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">15%</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">60%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">5.5em</code><code class="p">;</code> <code class="k">z-index</code><code class="o">:</code> <code class="m">4</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nf">#third</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">23%</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">25%</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">30%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">z-index</code><code class="o">:</code> <code class="m">1</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nf">#fourth</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">10%</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">10%</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">80%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">z-index</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Each of the elements is positioned according to its styles, but the&#13;
usual order of stacking is altered by the <code>z-index</code> values. Assuming the&#13;
paragraphs were in numeric order, a reasonable stacking order would&#13;
have been, from lowest to highest, <code>p#first</code>, <code>p#second</code>, <code>p#third</code>,&#13;
<code>p#fourth</code>. This would have put <code>p#first</code> behind the other three&#13;
elements, and <code>p#fourth</code> in front of the others. Thanks to <code>z-index</code>,&#13;
the stacking order is under your control.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="stacked_elements_can_overlap">&#13;
<img alt="image" src="assets/css5_1046.png"/>&#13;
<h6><span class="label">Figure 10-46. </span>Stacked elements can overlap</h6>&#13;
</div></figure>&#13;
&#13;
<p>As the previous example demonstrates, the <code>z-index</code> values don’t need to be contiguous. You can assign any integer of&#13;
any size. If you want to be fairly certain that an element stays in&#13;
front of everything else, you might use a rule along the lines of&#13;
<code>z-index: 100000</code>. This would work as expected in most cases—although if&#13;
you ever declared another element’s <code>z-index</code> to be <code>100001</code> (or&#13;
higher), it would appear in front.</p>&#13;
&#13;
<p>Once you assign an element a value for <code>z-index</code> (other than <code>auto</code>),&#13;
that element establishes its own local <em>stacking context</em>. This means&#13;
that all of the element’s descendants have their own stacking order,&#13;
except relative to their ancestor element. This is very similar to the way that&#13;
elements establish new containing blocks. Given the following styles,&#13;
you would see something like <a data-type="xref" href="#local_stacking_from_positioned">Figure 10-47</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="m">#DDD</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="nf">#one</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">40%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">z-index</code><code class="o">:</code> <code class="m">3</code><code class="p">;}</code>&#13;
<code class="nf">#two</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">-0.75em</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">15%</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">60%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">5.5em</code><code class="p">;</code> <code class="k">z-index</code><code class="o">:</code> <code class="m">10</code><code class="p">;}</code>&#13;
<code class="nf">#three</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">10%</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">30%</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">30%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">z-index</code><code class="o">:</code> <code class="m">8</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="o">[</code><code class="nt">id</code><code class="o">]</code> <code class="nt">em</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">-1em</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">-1em</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">5em</code><code class="p">;}</code>&#13;
<code class="nf">#one</code> <code class="nt">em</code> <code class="p">{</code><code class="k">z-index</code><code class="o">:</code> <code class="m">100</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="n">hsla</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="m">50%</code><code class="o">,</code><code class="m">70%</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">9</code><code class="p">);}</code>&#13;
<code class="nf">#two</code> <code class="nt">em</code> <code class="p">{</code><code class="k">z-index</code><code class="o">:</code> <code class="m">10</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="n">hsla</code><code class="p">(</code><code class="m">120</code><code class="o">,</code><code class="m">50%</code><code class="o">,</code><code class="m">70%</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">9</code><code class="p">);}</code>&#13;
<code class="nf">#three</code> <code class="nt">em</code> <code class="p">{</code><code class="k">z-index</code><code class="o">:</code> <code class="m">-343</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="n">hsla</code><code class="p">(</code><code class="m">240</code><code class="o">,</code><code class="m">50%</code><code class="o">,</code><code class="m">70%</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">9</code><code class="p">);}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="local_stacking_from_positioned">&#13;
<img alt="image" src="assets/css5_1047.png"/>&#13;
<h6><span class="label">Figure 10-47. </span>Positioned elements establish local stacking contexts</h6>&#13;
</div></figure>&#13;
&#13;
<p>Note where the <code>&lt;em&gt;</code> elements fall in the stacking order (you can find a list of the various ways to establish a stacking context in <a data-type="xref" href="ch20.html#blending-in-isolation1">“Blending in Isolation”</a> in <a data-type="xref" href="ch20.html#filters-compositing">Chapter 20</a>). Each is&#13;
correctly layered with respect to its parent element. Each&#13;
<code>&lt;em&gt;</code> is drawn in front of its parent element, whether or not its&#13;
<code>z-index</code> is negative, and parents and children are grouped together like layers in an editing program. (The specification keeps children from&#13;
being drawn behind their parents when using <code>z-index</code> stacking, so the&#13;
<code>em</code> in <code>p#three</code> is drawn on top of <code>p#one</code>, even though its <code>z-index</code>&#13;
value is <code>-343</code>.) This is because its <code>z-index</code> value is taken with respect to its local&#13;
stacking context: its containing block. That containing block, in turn,&#13;
has a <code>z-index</code>, which operates within its local stacking context.</p>&#13;
&#13;
<p>We have one more <code>z-index</code> value to examine. The CSS specification has this&#13;
to say about the default value, <code>auto</code>:</p>&#13;
<blockquote>&#13;
<p>The stack level of the generated box in the current stacking context is&#13;
0. The box does not establish a new stacking context unless it is the&#13;
root element.</p></blockquote>&#13;
&#13;
<p>So, any element with <code>z-index: auto</code> can be treated as though it is set&#13;
to <code>z-index: 0</code>.<a data-primary="" data-startref="ix_stack_elem" data-type="indexterm" id="idm45176080886992"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><code>z-index</code> is also honored by flex and grid items, even though they are not positioned using the <code>position</code> property.  The rules are essentially the same.<a data-primary="" data-startref="ix_absol_pos_zindex" data-type="indexterm" id="idm45176080884464"/><a data-primary="" data-startref="ix_zindex_prop" data-type="indexterm" id="idm45176080883488"/><a data-primary="" data-startref="ix_offset_absol_pos" data-type="indexterm" id="idm45176080882544"/><a data-primary="" data-startref="ix_absol_pos_ch10" data-type="indexterm" id="idm45176080881600"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Fixed Positioning" data-type="sect1"><div class="sect1" id="fixed-positioning">&#13;
<h1>Fixed Positioning</h1>&#13;
&#13;
<p>As implied in a <a data-primary="positioning" data-secondary="fixed" data-type="indexterm" id="ix_pos_fixed"/><a data-primary="fixed positioning" data-type="indexterm" id="ix_fixed_pos"/><a data-primary="offsets" data-secondary="fixed positioning" data-type="indexterm" id="ix_offset_fix_pos"/>previous section, <em>fixed positioning</em> is just like&#13;
absolute positioning, except the containing block of a fixed element is&#13;
the <em>viewport</em>. A <a data-primary="containing blocks" data-secondary="viewport as fixed element’s" data-type="indexterm" id="idm45176080873920"/><a data-primary="viewport (browser display)" data-secondary="as container for fixed positioning" data-secondary-sortas="container for fixed positioning" data-type="indexterm" id="idm45176080872944"/>fixed-position <span class="keep-together">element</span> is totally removed from the&#13;
document’s flow and does not have a position relative to any part of&#13;
&#13;
<span class="keep-together">the document.</span></p>&#13;
&#13;
<p>Fixed positioning can be exploited in interesting ways.&#13;
First off, it’s possible to create frame-style interfaces by using fixed&#13;
positioning. Consider <a data-type="xref" href="#emulating_frames_with_fixed">Figure 10-48</a>, which shows a common layout scheme.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="emulating_frames_with_fixed">&#13;
<img alt="image" src="assets/css5_1048.png"/>&#13;
<h6><span class="label">Figure 10-48. </span>Emulating frames with fixed positioning</h6>&#13;
</div></figure>&#13;
&#13;
<p>This could be done using the following styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">header</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">fixed</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">80%</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">20%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#sidebar</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">fixed</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">80%</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will fix the header and sidebar to the top and side of the&#13;
viewport, where they will remain regardless of how the document is&#13;
scrolled. The drawback here, though, is that the rest of the document&#13;
will be overlapped by the fixed elements. Therefore, the rest of the&#13;
content should probably be contained in its own wrapper element and employ&#13;
something like the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">main</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">20%</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">20%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">overflow</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<p>It would even be possible to create small gaps between the three&#13;
positioned elements by adding some appropriate margins, as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code> <code class="c">/* colors for safety's sake */</code>&#13;
<code class="nt">div</code><code class="nf">#header</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">fixed</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">80%</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">20%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">margin-bottom</code><code class="o">:</code> <code class="m">2px</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#sidebar</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">fixed</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">80%</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">margin-right</code><code class="o">:</code> <code class="m">2px</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code>&#13;
<code class="nt">div</code><code class="nf">#main</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">absolute</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">20%</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">20%</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">overflow</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Given such a case, a tiled image could be applied to the <code>&lt;body&gt;</code>&#13;
background. This image would show through the gaps created by the&#13;
margins, which could certainly be widened if the author saw fit.</p>&#13;
&#13;
<p>Another use for fixed positioning is to place a “persistent” element on&#13;
the screen, like a short list of links. We could create a persistent&#13;
<code>footer</code> with copyright and other information as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">footer</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">fixed</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">100%</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This would place the <code>footer</code> element at the bottom of the viewport and&#13;
leave it there no matter how much the document is scrolled.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Many of the layout cases for fixed positioning, besides&#13;
“persistent elements,” are handled as well, if not better, by grid layout (see <a data-type="xref" href="ch12.html#grid-layout">Chapter 12</a> for more).<a data-primary="" data-startref="ix_fixed_pos" data-type="indexterm" id="idm45176080523984"/><a data-primary="" data-startref="ix_pos_fixed" data-type="indexterm" id="idm45176080521008"/><a data-primary="" data-startref="ix_offset_fix_pos" data-type="indexterm" id="idm45176080520064"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Relative Positioning" data-type="sect1"><div class="sect1" id="relative-positioning">&#13;
<h1>Relative Positioning</h1>&#13;
&#13;
<p>The simplest of the <a data-primary="positioning" data-secondary="relative" data-type="indexterm" id="ix_position_rel"/><a data-primary="relative positioning" data-type="indexterm" id="ix_rel_position"/>positioning schemes to understand is <em>relative&#13;
positioning</em>. <a data-primary="offsets" data-secondary="relative positioning" data-type="indexterm" id="ix_offset_position4"/>In this scheme, a positioned element is shifted by use of&#13;
the offset properties. However, this can have some interesting&#13;
consequences.</p>&#13;
&#13;
<p>On the surface, it seems simple enough. Suppose we want to shift an image up and to the left. <a data-type="xref" href="#relatively_positioned_element">Figure 10-49</a> shows the result of these styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">-20px</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">-20px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="width-50"><div class="figure" id="relatively_positioned_element">&#13;
<img alt="image" src="assets/css5_1049.png"/>&#13;
<h6><span class="label">Figure 10-49. </span>A relatively positioned element</h6>&#13;
</div></figure>&#13;
&#13;
<p>All we’ve done here is offset the image’s top-edge 20 pixels upward and&#13;
offset the left-edge 20 pixels to the left. However, notice the blank&#13;
space where the image would have been had it not been positioned. This&#13;
happened because when an element is relatively positioned, it’s shifted&#13;
from its normal place, but the space it would have occupied &#13;
<span class="keep-together">doesn’t disappear.</span></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Relative positioning is very similar to translation element transforms, which are discussed in <a data-type="xref" href="ch17.html#transforms">Chapter 17</a>.</p>&#13;
</div>&#13;
&#13;
<p>Consider the results of the following styles, which are&#13;
depicted in <a data-type="xref" href="#another_relatively_positioned_element">Figure 10-50</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">em</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">10em</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="width-50"><div class="figure" id="another_relatively_positioned_element">&#13;
<img alt="image" src="assets/css5_1050.png"/>&#13;
<h6><span class="label">Figure 10-50. </span>Another relatively positioned element</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you can see, the paragraph has some blank space in it. This is where&#13;
the <code>&lt;em&gt;</code> element would have been, and the layout of the <code>&lt;em&gt;</code> element in&#13;
its new position exactly mirrors the space it left behind.</p>&#13;
&#13;
<p>It’s also possible to shift a relatively positioned element&#13;
to overlap other content. For example, the following styles and markup&#13;
are illustrated in <a data-type="xref" href="#relatively_positioned_elements_overlap_content">Figure 10-51</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.slide</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">30px</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
<code class="w">    </code>In<code class="w"> </code>this<code class="w"> </code>paragraph,<code class="w"> </code>we<code class="w"> </code>will<code class="w"> </code>find<code class="w"> </code>that<code class="w"> </code>there<code class="w"> </code>is<code class="w"> </code>an<code class="w"> </code>image<code class="w"> </code>that<code class="w"> </code>has<code class="w"> </code>been<code class="w"/>&#13;
<code class="w">    </code>pushed<code class="w"> </code>to<code class="w"> </code>the<code class="w"> </code>right.<code class="w"> </code>It<code class="w"> </code>will<code class="w"> </code>therefore<code class="w"> </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"star.gif"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"A star!"</code><code class="w"/>&#13;
<code class="w">    </code><code class="na">class=</code><code class="s">"slide"</code><code class="nt">&gt;</code><code class="w"> </code>overlap<code class="w"> </code>content<code class="w"> </code>nearby,<code class="w"> </code>assuming<code class="w"> </code>that<code class="w"> </code>it<code class="w"> </code>is<code class="w"> </code>not<code class="w"> </code>the<code class="w"/>&#13;
<code class="w">    </code>last<code class="w"> </code>element<code class="w"> </code>in<code class="w"> </code>its<code class="w"> </code>line<code class="w"> </code>box.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="width-50"><div class="figure" id="relatively_positioned_elements_overlap_content">&#13;
<img alt="image" src="assets/css5_1051.png"/>&#13;
<h6><span class="label">Figure 10-51. </span>Relatively positioned elements can overlap other content</h6>&#13;
</div></figure>&#13;
&#13;
<p>Relative positioning has one interesting wrinkle. What happens&#13;
when a relatively positioned element is overconstrained? For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">20px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Here we have values that call for two very different behaviors. If we&#13;
consider only <code>top: 10px</code>, the element should be shifted downward&#13;
10 pixels, but <code>bottom: 20px</code> clearly calls for the element to be&#13;
shifted upward 20 pixels.</p>&#13;
&#13;
<p>CSS states that when it comes to <a data-primary="overconstraining" data-secondary="relative positioning" data-type="indexterm" id="idm45176080259552"/>overconstrained relative&#13;
positioning, one value is reset to be the negative of the other. Thus,&#13;
<code>bottom</code> would always equal <code>-top</code>. This means the previous example&#13;
would be treated as though it had been the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">strong</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">10px</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">-10px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Therefore, the <code>&lt;strong&gt;</code> element will be shifted downward 10 pixels. The&#13;
specification also makes allowances for writing directions. In relative&#13;
positioning, <code>right</code> always equals <code>-left</code> in left-to-right languages;&#13;
but in right-to-left languages, this is reversed: <code>left</code> always equals&#13;
<code>-right</code>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As you saw in <a data-primary="positioning" data-secondary="containing blocks and" data-type="indexterm" id="idm45176080215792"/><a data-primary="containing blocks" data-secondary="positioning and" data-type="indexterm" id="idm45176080214784"/>previous sections, when we relatively position an&#13;
element, it immediately establishes a new containing block for any of&#13;
its children. This containing block corresponds to the place where the&#13;
element has been newly positioned.<a data-primary="" data-startref="ix_offset_position4" data-type="indexterm" id="idm45176080213712"/><a data-primary="" data-startref="ix_position_rel" data-type="indexterm" id="idm45176080212768"/><a data-primary="" data-startref="ix_rel_position" data-type="indexterm" id="idm45176080211824"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sticky Positioning" data-type="sect1"><div class="sect1" id="sticky-positioning">&#13;
<h1>Sticky Positioning</h1>&#13;
&#13;
<p>The last type of <a data-primary="positioning" data-secondary="sticky" data-type="indexterm" id="ix_pos_sticky"/><a data-primary="sticky positioning" data-type="indexterm" id="ix_sticky_pos"/><a data-primary="offsets" data-secondary="sticky positioning" data-type="indexterm" id="ix_offset_sticky"/>positioning in CSS is <em>sticky positioning</em>. If you’ve&#13;
ever used a decent music app on a mobile device, you’ve probably noticed&#13;
this in action: as you <a data-primary="scrolling" data-secondary="sticky positioning and" data-type="indexterm" id="ix_scroll_sticky"/>scroll through an alphabetized list of artists,&#13;
the current letter stays stuck at the top of the window until a new&#13;
letter section is entered, at which point the new letter replaces the&#13;
old. It’s a little hard to show in print, but <a data-type="xref" href="#sticky_positioning">Figure 10-52</a> takes a stab at&#13;
it by showing three points in a scroll.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sticky_positioning">&#13;
<img alt="image" src="assets/css5_1052.png"/>&#13;
<h6><span class="label">Figure 10-52. </span>Sticky positioning</h6>&#13;
</div></figure>&#13;
&#13;
<p>CSS makes this sort of thing possible by declaring an element to be&#13;
<code>position: sticky</code>, but (as usual) there’s more to it than that.</p>&#13;
&#13;
<p>First off, the offsets (<code>top</code>, <code>left</code>, etc.) are used to define a&#13;
<em>sticky-positioning rectangle</em> with relation to the containing block.&#13;
Take the following as an example. It will have the effect shown in&#13;
<a data-type="xref" href="#sticky-positioning_rectangle">Figure 10-53</a>, where the dashed line shows where the sticky-positioning &#13;
<span class="keep-together">rectangle is created:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#scrollbox</code> <code class="p">{</code><code class="k">overflow</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">15em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">18em</code><code class="p">;}</code>&#13;
<code class="nf">#scrollbox</code> <code class="nt">h2</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="n">sticky</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
    <code class="k">left</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sticky-positioning_rectangle">&#13;
<img alt="css5 1053" src="assets/css5_1053.png"/>&#13;
<h6><span class="label">Figure 10-53. </span>The sticky-positioning rectangle</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that the <code>&lt;h2&gt;</code> is in the middle of the rectangle in <a data-type="xref" href="#sticky-positioning_rectangle">Figure 10-53</a>. That’s its place in the normal flow of the content inside the&#13;
<code>#scrollbox</code> element. The only way to make the <code>&lt;h2&gt;</code>&#13;
sticky is to scroll that content until the top of the <code>&lt;h2&gt;</code> touches the&#13;
top of the sticky-positioning rectangle (which is <code>2em</code> below the top of the scrollbox)—at which point, the <code>&lt;h2&gt;</code> will stick&#13;
there. This is illustrated in <a data-type="xref" href="#sticking_to_the_top">Figure 10-54</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sticking_to_the_top">&#13;
<img alt="image" src="assets/css5_1054.png"/>&#13;
<h6><span class="label">Figure 10-54. </span>Sticking to the top of the sticky-positioning rectangle</h6>&#13;
</div></figure>&#13;
&#13;
<p>In other words, the <code>&lt;h2&gt;</code> sits in the normal flow until its sticky edge&#13;
touches the sticky edge of the sticky-positioning rectangle.&#13;
At that point, it sticks there&#13;
as if absolutely &#13;
<span class="keep-together">positioned,</span> <em>except</em> that it leaves behind the space it otherwise would have occupied in the normal flow.</p>&#13;
&#13;
<p>You may have noticed that the <code>#scrollbox</code> element doesn’t have a&#13;
<code>position</code> declaration. One isn’t hiding offstage, either: it’s&#13;
the <code>overflow: scroll</code> set on <code>#scrollbox</code> that creates a containing block for the&#13;
sticky-positioned <code>&lt;h2&gt;</code> elements. This is a case where a containing&#13;
block isn’t determined by <code>position</code>.</p>&#13;
&#13;
<p>If the scrolling is reversed so that the <code>&lt;h2&gt;</code>’s normal-flow position&#13;
moves lower than the top of the rectangle, the <code>&lt;h2&gt;</code> is detached from the&#13;
rectangle and resumes its place in the normal flow. This is shown in&#13;
<a data-type="xref" href="#detaching_from_the_top">Figure 10-55</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="detaching_from_the_top">&#13;
<img alt="image" src="assets/css5_1055.png"/>&#13;
<h6><span class="label">Figure 10-55. </span>Detaching from the top of the sticky-positioning rectangle</h6>&#13;
</div></figure>&#13;
&#13;
<p>Note that the reason the <code>&lt;h2&gt;</code> sticks to the <em>top</em> of the rectangle in&#13;
these examples is that the value of <code>top</code> is set to something other&#13;
than <code>auto</code> for the <code>&lt;h2&gt;</code> (that is, for the sticky-positioned element).&#13;
You can use whatever offset side you want. For example, you&#13;
could have elements stick to the bottom of the rectangle as you scroll&#13;
downward through the content. The following code is illustrated in <a data-type="xref" href="#sticking_to_the_bottom">Figure 10-56</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#scrollbox</code> <code class="p">{</code><code class="k">overflow</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;</code> <code class="k">position</code><code class="o">:</code> <code class="nb">relative</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">15em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;}</code>&#13;
<code class="nf">#scrollbox</code> <code class="nt">h2</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="n">sticky</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sticking_to_the_bottom">&#13;
<img alt="image" src="assets/css5_1056.png"/>&#13;
<h6><span class="label">Figure 10-56. </span>Sticking to the bottom of the sticky-positioning rectangle</h6>&#13;
</div></figure>&#13;
&#13;
<p>This could be a way to show footnotes or comments for a given paragraph,&#13;
for example, while allowing them to scroll away as the paragraph moves&#13;
upward. The same rules apply for the left and right sides, which is&#13;
useful for side-scrolling content.</p>&#13;
&#13;
<p>If you define more than one offset property to have a value other than&#13;
<code>auto</code>, <em>all</em> of them will become sticky edges. For example, this&#13;
set of styles will force the <code>&lt;h2&gt;</code> to always appear inside the scrollbox,&#13;
regardless of which way its content is scrolled (see <a data-type="xref" href="#making_every_side_sticky">Figure 10-57</a>):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#scrollbox</code> <code class="p">{</code><code class="k">overflow</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;</code> <code class="o">:</code> <code class="m">15em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">10em</code><code class="p">;}</code>&#13;
<code class="nf">#scrollbox</code> <code class="nt">h2</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="n">sticky</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">bottom</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">left</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">right</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="making_every_side_sticky">&#13;
<img alt="image" src="assets/css5_1057.png"/>&#13;
<h6><span class="label">Figure 10-57. </span>Making every side a sticky side</h6>&#13;
</div></figure>&#13;
&#13;
<p>You might wonder: what happens if I have multiple sticky-positioned&#13;
elements in a situation like this, and I scroll past two or more? In&#13;
effect, they pile up on top of one another:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#scrollbox</code> <code class="p">{</code><code class="k">overflow</code><code class="o">:</code> <code class="nb">scroll</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">15em</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">18em</code><code class="p">;}</code>&#13;
<code class="nf">#scrollbox</code> <code class="nt">h2</code> <code class="p">{</code><code class="k">position</code><code class="o">:</code> <code class="n">sticky</code><code class="p">;</code> <code class="k">top</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">40%</code><code class="p">;}</code>&#13;
<code class="nt">h2</code><code class="nf">#h01</code> <code class="p">{</code><code class="k">margin-right</code><code class="o">:</code> <code class="m">60%</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="n">hsla</code><code class="p">(</code><code class="m">0</code><code class="o">,</code><code class="m">100%</code><code class="o">,</code><code class="m">50%</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">75</code><code class="p">);}</code>&#13;
<code class="nt">h2</code><code class="nf">#h02</code> <code class="p">{</code><code class="k">margin-left</code><code class="o">:</code> <code class="m">60%</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="n">hsla</code><code class="p">(</code><code class="m">120</code><code class="o">,</code><code class="m">100%</code><code class="o">,</code><code class="m">50%</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">75</code><code class="p">);}</code>&#13;
<code class="nt">h2</code><code class="nf">#h03</code> <code class="p">{</code><code class="k">margin-left</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code> <code class="k">margin-right</code><code class="o">:</code> <code class="nb">auto</code><code class="p">;</code>&#13;
    <code class="k">background</code><code class="o">:</code> <code class="n">hsla</code><code class="p">(</code><code class="m">240</code><code class="o">,</code><code class="m">100%</code><code class="o">,</code><code class="m">50%</code><code class="o">,</code><code class="m">0</code><code class="o">.</code><code class="m">75</code><code class="p">);}</code></pre>&#13;
&#13;
<p>It’s not easy to see in static images like <a data-type="xref" href="#sticky-header_pileup">Figure 10-58</a>, but the way the headers are&#13;
piling up is that the later they are in the source, the closer they are&#13;
to the viewer. <a data-primary="z-index property" data-type="indexterm" id="idm45176079800160"/>This is the usual <code>z-index</code> behavior—which means that you&#13;
can decide which sticky elements sit on top of others by assigning&#13;
explicit <code>z-index</code> values. For example, suppose we want the first&#13;
sticky element in our content to sit atop all the others. By giving it&#13;
<code class="keep-together">z-index: 1000</code>, or any other sufficiently high number, it would sit on&#13;
top of all the other sticky elements that are stuck in the same place.<a data-primary="" data-startref="ix_position_ch10" data-type="indexterm" id="idm45176079797680"/><a data-primary="" data-startref="ix_offset_sticky" data-type="indexterm" id="idm45176079796704"/><a data-primary="" data-startref="ix_pos_sticky" data-type="indexterm" id="idm45176079795760"/><a data-primary="" data-startref="ix_sticky_pos" data-type="indexterm" id="idm45176079794816"/><a data-primary="" data-startref="ix_scroll_sticky" data-type="indexterm" id="idm45176079793872"/> The&#13;
visual effect would be of the other elements “sliding under” the topmost&#13;
element.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="sticky-header_pileup">&#13;
<img alt="image" src="assets/css5_1058.png"/>&#13;
<h6><span class="label">Figure 10-58. </span>A sticky-header pileup</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="pos_summary">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>As you saw in this chapter, CSS offers numerous ways to affect the placement of basic elements.&#13;
Floats may be a fundamentally simple aspect of CSS, but that doesn’t&#13;
keep them from being useful and powerful. They fill a vital and&#13;
honorable niche, allowing the placement of content to one side while the&#13;
rest of the content flows around it.</p>&#13;
&#13;
<p>Thanks to positioning, it’s possible to move elements around in ways that&#13;
the normal flow could never accommodate. Combined with the&#13;
stacking possibilities of the z-axis and the various overflow&#13;
patterns, there’s still a lot to like in positioning, even in a time when flexbox and grid layout are available to us.</p>&#13;
</div></section>&#13;
</div></section></body></html>