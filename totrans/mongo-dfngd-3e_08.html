<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Special Index and Collection Types"><div class="chapter" id="chapter-idx-types"><h1><span class="label">Chapter 6. </span>Special Index and Collection Types</h1><p>This chapter covers the special collections and index types MongoDB
  has available, including:</p><ul><li><p>Capped collections for queue-like data</p></li><li><p>TTL indexes for caches</p></li><li><p>Full-text indexes for simple string searching</p></li><li><p>Geospatial indexes for 2D and spherical geometries</p></li><li><p>GridFS for storing large files</p></li></ul><section data-type="sect1" data-pdf-bookmark="Geospatial Indexes"><div class="sect1" id="sect1_d1e5868"><h1>Geospatial Indexes</h1><p>MongoDB<a data-type="indexterm" data-primary="indexes" data-secondary="geospatial" id="Igeo06"/><a data-type="indexterm" data-primary="geospatial indexes" data-secondary="types of" id="idm45882369369480"/> has two types of geospatial indexes: <code>2dsphere<a data-type="indexterm" data-primary="2dsphere indexes" id="idm45882369367960"/></code> and <code>2d<a data-type="indexterm" data-primary="2d indexes" id="idm45882369366680"/></code>. <code>2dsphere</code>
    indexes work with spherical geometries that model the surface of the earth
    based on the WGS84 datum.<a data-type="indexterm" data-primary="WGS84 datum" id="idm45882369365144"/> This datum models the surface of the earth as an oblate
    spheroid, meaning that there is some flattening at the poles. Distance
    calculations using <code>2sphere</code> indexes,
    therefore, take the shape of the earth into account and provide a more
    accurate treatment of distance between, for example, two cities, than do
    <code>2d</code> indexes. Use <code>2d</code> indexes for points stored on a
    two-dimensional plane.</p><p><code>2dsphere</code> allows you to specify
    geometries for points, lines, and polygons in the <a href="http://www.geojson.org/">GeoJSON format</a><a data-type="indexterm" data-primary="GeoJSON format" id="idm45882369361576"/>. A point is given by a two-element array, representing
    [<em><code>longitude</code></em>,
    <em><code>latitude</code></em>]:</p><pre class="pagebreak-before" data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
    <code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"New York City"</code><code class="p">,</code>
    <code class="s2">"loc"</code> <code class="o">:</code> <code class="p">{</code>
        <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Point"</code><code class="p">,</code>
        <code class="s2">"coordinates"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">50</code><code class="p">,</code> <code class="mi">2</code><code class="p">]</code>
    <code class="p">}</code>
<code class="p">}</code></pre><p>A line is given by an array of points:</p><pre data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
    <code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"Hudson River"</code><code class="p">,</code>
    <code class="s2">"loc"</code> <code class="o">:</code> <code class="p">{</code>
        <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"LineString"</code><code class="p">,</code>
        <code class="s2">"coordinates"</code> <code class="o">:</code> <code class="p">[[</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">]]</code>
    <code class="p">}</code>
<code class="p">}</code></pre><p>A polygon is specified the same way a line is (an array of points),
    but with a different <code>"type"</code>:</p><pre data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
    <code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"New England"</code><code class="p">,</code>
    <code class="s2">"loc"</code> <code class="o">:</code> <code class="p">{</code>
        <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Polygon"</code><code class="p">,</code>
        <code class="s2">"coordinates"</code> <code class="o">:</code> <code class="p">[[</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">]]</code>
    <code class="p">}</code>
<code class="p">}</code></pre><p>The field that we are naming, <code>"loc"</code> in this example, can be called anything,
    but the field names in the embedded object are specified by GeoJSON and cannot be changed.</p><p>You<a data-type="indexterm" data-primary="indexes" data-secondary="basic operations" data-tertiary="creating" id="idm45882369188248"/> can create a geospatial index using the <code>"2dsphere"</code> type with <code class="function"><code>createIndex</code></code>:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">openStreetMap</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"loc"</code> <code class="o">:</code> <code class="s2">"2dsphere"</code><code class="p">})</code></pre><p>To create a <code>2dsphere</code> index, pass
    a document to <code>createIndex</code> that
    specifies the field containing geometries you want to index for the
    collection in question and specify <code>"2dsphere"</code> as the value.</p><section data-type="sect2" data-pdf-bookmark="Types of Geospatial Queries"><div class="sect2" id="idm45882369126600"><h2>Types of Geospatial Queries</h2><p>There<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="geospatial query types" id="idm45882369179480"/> are three types of geospatial queries that you can
      perform: intersection, within, and nearness. You specify what you’re
      looking for as a GeoJSON object that looks like <code>{"$geometry" :
      <em><code>geoJsonDesc</code></em>}</code>.</p><p class="pagebreak-before">For example, you can find documents that intersect the query’s
      location using the <code>"$geoIntersects<a data-type="indexterm" data-primary="$geoIntersects&#10;          operator" data-primary-sortas="geoIntersects operator" id="idm45882369176184"/>"</code> operator:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">eastVillage</code> <code class="o">=</code> <code class="p">{</code>
<code class="p">...</code> <code class="s2">"type"</code> <code class="o">:</code> <code class="s2">"Polygon"</code><code class="p">,</code>
<code class="p">...</code> <code class="s2">"coordinates"</code> <code class="o">:</code> <code class="p">[</code>
<code class="p">...</code>  <code class="p">[</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9732566</code><code class="p">,</code> <code class="mf">40.7187272</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9724573</code><code class="p">,</code> <code class="mf">40.7217745</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9717144</code><code class="p">,</code> <code class="mf">40.7250025</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9714435</code><code class="p">,</code> <code class="mf">40.7266002</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.975735</code><code class="p">,</code> <code class="mf">40.7284702</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9803565</code><code class="p">,</code> <code class="mf">40.7304255</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9825505</code><code class="p">,</code> <code class="mf">40.7313605</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9887732</code><code class="p">,</code> <code class="mf">40.7339641</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9907554</code><code class="p">,</code> <code class="mf">40.7348137</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9914581</code><code class="p">,</code> <code class="mf">40.7317345</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9919248</code><code class="p">,</code> <code class="mf">40.7311674</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9904979</code><code class="p">,</code> <code class="mf">40.7305556</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9907017</code><code class="p">,</code> <code class="mf">40.7298849</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9908171</code><code class="p">,</code> <code class="mf">40.7297751</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9911416</code><code class="p">,</code> <code class="mf">40.7286592</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9911943</code><code class="p">,</code> <code class="mf">40.728492</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9914313</code><code class="p">,</code> <code class="mf">40.7277405</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9914635</code><code class="p">,</code> <code class="mf">40.7275759</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9916003</code><code class="p">,</code> <code class="mf">40.7271124</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9915386</code><code class="p">,</code> <code class="mf">40.727088</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.991788</code><code class="p">,</code> <code class="mf">40.7263908</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9920616</code><code class="p">,</code> <code class="mf">40.7256489</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9923298</code><code class="p">,</code> <code class="mf">40.7248907</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9925954</code><code class="p">,</code> <code class="mf">40.7241427</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9863029</code><code class="p">,</code> <code class="mf">40.7222237</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9787659</code><code class="p">,</code> <code class="mf">40.719947</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9772317</code><code class="p">,</code> <code class="mf">40.7193229</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9750886</code><code class="p">,</code> <code class="mf">40.7188838</code> <code class="p">],</code>
<code class="p">...</code>    <code class="p">[</code> <code class="o">-</code><code class="mf">73.9732566</code><code class="p">,</code> <code class="mf">40.7187272</code> <code class="p">]</code>
<code class="p">...</code>  <code class="p">]</code>
<code class="p">...</code> <code class="p">]}</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">openStreetMap</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code>
<code class="p">...</code> <code class="p">{</code><code class="s2">"loc"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$geoIntersects"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$geometry"</code> <code class="o">:</code> <code class="nx">eastVillage</code><code class="p">}}})</code></pre><p>This would find all point-, line-, and polygon-containing
      documents that had a point in the East Village in New York City.</p><p>You can use <code>"$geoWithin"<a data-type="indexterm" data-primary="$geoWithin operator" data-primary-sortas="geoWithin operator" id="idm45882369161048"/></code> to query for things that are completely
      contained in an area (for instance, “What restaurants are in the East
      Village?”):</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">openStreetMap</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"loc"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$geoWithin"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$geometry"</code> <code class="o">:</code> <code class="nx">eastVillage</code><code class="p">}}})</code></pre><p class="pagebreak-before">Unlike our first query, this will not return things that merely
      pass through the East Village (such as streets) or partially overlap it
      (such as a polygon describing <span class="keep-together">Manhattan</span>).</p><p>Finally, you can query for nearby locations with <code>"$near"</code>:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">openStreetMap</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"loc"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$near"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$geometry"</code> <code class="o">:</code> <code class="nx">eastVillage</code><code class="p">}}})</code></pre><p>Note that <code>"$near"</code> is the only
      geospatial operator that implies a sort: results from<a data-type="indexterm" data-primary="$near operator" data-primary-sortas="near operator" id="idm45882368863448"/> <code>"$near"</code> are always
      returned in order of distance, from closest to farthest.</p></div></section><section data-type="sect2" data-pdf-bookmark="Using Geospatial Indexes"><div class="sect2" id="idm45882369126296"><h2>Using Geospatial Indexes</h2><p>MongoDB’s<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="using" id="GIusing06"/> geospatial indexing allows you to efficiently execute
      spatial queries on a collection that contains geospatial shapes and
      points. To showcase the capabilities of geospatial features and compare
      different approaches, we will go through the process of writing queries
      for a simple geospatial application. We’ll go a little deeper into a few
      concepts central to geospatial indexes and then demonstrate their
      use<a data-type="indexterm" data-primary="$geoNear operator" data-primary-sortas="geoNear operator" id="idm45882368815544"/><a data-type="indexterm" data-primary="$geoIntersects&#10;          operator" data-primary-sortas="geoIntersects operator" id="idm45882368814440"/><a data-type="indexterm" data-primary="$geoWithin operator" data-primary-sortas="geoWithin operator" id="idm45882368813368"/> with <code>"$geoWithin"</code>,
      <code>"$geoIntersects"</code>, and <code>"$geoNear"</code>.</p><p>Suppose we are designing a mobile application to help users find
      restaurants in New York City. The application must:</p><ul><li><p>Determine the neighborhood the user is currently in.</p></li><li><p>Show the number of restaurants in that neighborhood.</p></li><li><p>Find restaurants within a specified distance.</p></li></ul><p>We will use a <code>2dsphere</code> index to
      query on this spherical geometry data.</p><section data-type="sect3" data-pdf-bookmark="2D versus spherical geometry in queries"><div class="sect3" id="twod_vs_sgq"><h3>2D versus spherical geometry in queries</h3><p>Geospatial queries<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="using" data-tertiary="2D versus spherical geometry" id="idm45882368807192"/> can use either spherical or 2D (flat) geometries,
        depending on both the query and the type of index in use. <a data-type="xref" href="#table0601">Table 6-1</a> shows what kind of geometry<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="query types and geometries in MongoDB" id="idm45882368804600"/> each geospatial operator uses.</p><table id="table0601"><caption><span class="label">Table 6-1. </span>Query types and geometries in MongoDB</caption><thead><tr><th>Query type</th><th>Geometry type</th></tr></thead><tbody><tr><td><code>$near</code> (GeoJSON
                point, <code>2dsphere</code>
                index)</td><td>Spherical</td></tr><tr><td><code>$near</code> (legacy
                coordinates, <code>2d</code>
                index)</td><td>Flat</td></tr><tr><td><code>$geoNear</code> (GeoJSON
                point, <code>2dsphere</code>
                index)</td><td>Spherical</td></tr><tr><td><code>$geoNear</code> (legacy
                coordinates, <code>2d</code>
                index)</td><td>Flat</td></tr><tr><td><code>$nearSphere</code> (GeoJSON
                point, <code>2dsphere</code>
                index)</td><td>Spherical</td></tr><tr><td><code>$nearSphere</code> (legacy
                coordinates, <code>2d</code>
                index)<sup><a data-type="noteref" id="idm45882368776472-marker" href="ch06.xhtml#idm45882368776472">a</a></sup></td><td>Spherical</td></tr><tr><td><code>$geoWithin : { $geometry: ... }</code></td><td>Spherical</td></tr><tr><td><code>$geoWithin: { $box: ... }</code></td><td>Flat</td></tr><tr><td><code>$geoWithin: { $polygon: ... }</code></td><td>Flat</td></tr><tr><td><code>$geoWithin : { $center: ... }</code></td><td>Flat</td></tr><tr><td><code>$geoWithin : { $centerSphere: ... }</code></td><td>Spherical</td></tr><tr><td><code>$geoIntersects</code></td><td>Spherical</td></tr></tbody><tbody><tr class="footnotes"><td colspan="2"><p data-type="footnote" id="idm45882368776472"><sup><a href="ch06.xhtml#idm45882368776472-marker">a</a></sup> Use GeoJSON points instead.</p></td></tr></tbody></table><p>Note also that <code>2d</code> indexes
        support both flat geometries and distance-only calculations on spheres
        (i.e., using <code>$nearSphere</code>). However,
        queries using spherical geometries will be more performant and
        accurate with a <code>2dsphere</code>
        index.</p><p>Note also that the <code>$geoNear</code>
        operator is an aggregation operator. The aggregation framework is
        discussed in <a data-type="xref" href="ch07.xhtml#chapter_d1e6036">Chapter 7</a>. In addition to the
        <code>$near</code> query operation, the <code>$geoNear</code> aggregation operator and the
        special command <code>geoNear</code> enable us
        to query for nearby locations. Keep in mind that the <code>$near</code> query operator will not work on
        collections that are distributed using sharding, MongoDB’s scaling
        solution (see <a data-type="xref" href="ch15.xhtml#chapter-shard-config">Chapter 15</a>).</p><p>The <code>geoNear</code> command and the
        <code>$geoNear</code> aggregation operator
        require that a collection have at most one <code>2dsphere</code> index and at most one <code>2d</code> index, whereas geospatial query operators
        (e.g., <code>$near</code> and <code>$geoWithin</code>) permit collections to have
        multiple geospatial indexes.</p><p>The geospatial index restriction for the <code>geoNear</code> command and the <code>$geoNear</code> aggregation operator exists because
        neither the <code>geoNear</code> command nor the
        <code>$geoNear</code> syntax includes the
        location field. As such, index selection among multiple <code>2d</code> indexes or <code>2dsphere</code> indexes is ambiguous.</p><p>No such restriction applies for geospatial query operators;
        these operators take a location field, eliminating the
        ambiguity.</p></div></section><section data-type="sect3" data-pdf-bookmark="Distortion"><div class="sect3" id="idm45882368757896"><h3>Distortion</h3><p>Spherical<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="using" data-tertiary="distortion" id="idm45882368756952"/> geometry will appear distorted when visualized on a map
        due to the nature of projecting a three-dimensional sphere, such as
        the earth, onto a flat plane.</p><p>For example, take the specification of the spherical square
        defined by the longitude, latitude points (0,0), (80,0), (80,80), and
        (0,80). <a data-type="xref" href="#fig0601">Figure 6-1</a> depicts the area covered by this
        region.</p><figure style="float: 0"><div id="fig0601" class="figure"><img src="Images/mdb3_0601.png" width="1194" height="1170"/><h6><span class="label">Figure 6-1. </span>The spherical square defined by the points (0,0), (80,0),
          (80, 80), and (0,80)</h6></div></figure></div></section><section data-type="sect3" data-pdf-bookmark="Searching for restaurants"><div class="sect3" id="idm45882368752264"><h3>Searching for restaurants</h3><p>In<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="using" data-tertiary="searching for restaurants" id="idm45882368751336"/> this example, we will work with <a href="https://oreil.ly/rpGna">neighborhood</a>
        and <a href="https://oreil.ly/JXYd-">restaurant</a>
        datasets based in New York City. You can download the example datasets
        from GitHub.</p><p>We can import the datasets into our database using the <code>mongoimport</code> tool as follows:</p><pre data-type="programlisting">$ mongoimport <em><code>&lt;path to neighborhoods.json&gt;</code></em> -c neighborhoods
$ mongoimport <em><code>&lt;path to restaurants.json&gt;</code></em> -c restaurants</pre><p class="pagebreak-before">We can create a <code>2dsphere</code>
        index on each collection using the <code>createIndex</code> command in the <a href="https://oreil.ly/NMUhn"><em>mongo</em> shell</a>:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">neighborhoods</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="nx">location</code><code class="o">:</code><code class="s2">"2dsphere"</code><code class="p">})</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">restaurants</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="nx">location</code><code class="o">:</code><code class="s2">"2dsphere"</code><code class="p">})</code></pre></div></section><section data-type="sect3" data-pdf-bookmark="Exploring the data"><div class="sect3" id="idm45882368743064"><h3>Exploring the data</h3><p>We<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="using" data-tertiary="exploring data" id="idm45882368727864"/> can get a sense for the schema used for documents in
        these collections with a couple of quick queries in the
        <em>mongo</em> shell:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">neighborhoods</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">name</code><code class="o">:</code> <code class="s2">"Clinton"</code><code class="p">})</code>
<code class="p">{</code>
  <code class="s2">"_id"</code><code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"55cb9c666c522cafdb053a4b"</code><code class="p">),</code>
  <code class="s2">"geometry"</code><code class="o">:</code> <code class="p">{</code>
    <code class="s2">"coordinates"</code><code class="o">:</code> <code class="p">[</code>
      <code class="p">[</code>
        <code class="p">[</code><code class="o">-</code><code class="mf">73.99</code><code class="p">,</code><code class="mf">40.77</code><code class="p">],</code>
        <code class="p">.</code>
        <code class="p">.</code>
        <code class="p">.</code>
        <code class="p">[</code><code class="o">-</code><code class="mf">73.99</code><code class="p">,</code><code class="mf">40.77</code><code class="p">],</code>
        <code class="p">[</code><code class="o">-</code><code class="mf">73.99</code><code class="p">,</code><code class="mf">40.77</code><code class="p">]]</code>
      <code class="p">]</code>
    <code class="p">],</code>
    <code class="s2">"type"</code><code class="o">:</code> <code class="s2">"Polygon"</code>
  <code class="p">},</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Clinton"</code>
<code class="p">}</code>

<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">restaurants</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">name</code><code class="o">:</code> <code class="s2">"Little Pie Company"</code><code class="p">})</code>
<code class="p">{</code>
  <code class="s2">"_id"</code><code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"55cba2476c522cafdb053dea"</code><code class="p">),</code>
  <code class="s2">"location"</code><code class="o">:</code> <code class="p">{</code>
    <code class="s2">"coordinates"</code><code class="o">:</code> <code class="p">[</code>
      <code class="o">-</code><code class="mf">73.99331699999999</code><code class="p">,</code>
      <code class="mf">40.7594404</code>
    <code class="p">],</code>
    <code class="s2">"type"</code><code class="o">:</code> <code class="s2">"Point"</code>
  <code class="p">},</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Little Pie Company"</code>
<code class="p">}</code></pre><p>The neighborhood document in the previous code corresponds to
        the area of New York City shown in <a data-type="xref" href="#fig0602">Figure 6-2</a>.</p><figure style="float: 0"><div id="fig0602" class="figure"><img src="Images/mdb3_0602.png" width="1440" height="1336"/><h6><span class="label">Figure 6-2. </span>The Hell’s Kitchen (Clinton) neighborhood of New York
          City</h6></div></figure><p>The bakery corresponds to the location shown in <a data-type="xref" href="#fig0603">Figure 6-3</a>.</p><figure style="float: 0"><div id="fig0603" class="figure"><img src="Images/mdb3_0603.png" width="1440" height="1404"/><h6><span class="label">Figure 6-3. </span>The Little Pie Company at 424 West 43rd Street</h6></div></figure></div></section><section data-type="sect3" data-pdf-bookmark="Finding the current neighborhood"><div class="sect3" id="idm45882368465400"><h3>Finding the current neighborhood</h3><p>Assuming<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="using" data-tertiary="finding current neighborhood" id="idm45882368464520"/> the user’s mobile device can give a reasonably accurate
        location user, it is simple to find the user’s current neighborhood
        with<a data-type="indexterm" data-primary="$geoIntersects&#10;            operator" data-primary-sortas="geoIntersects operator" id="idm45882368462856"/> <code>$geoIntersects</code>.</p><p>Suppose the user is located at −73.93414657 longitude and
        40.82302903 latitude. To find the current neighborhood (Hell’s
        Kitchen), we can specify a point using the special <code>$geometry</code> field in GeoJSON format:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">neighborhoods</code><code class="p">.</code><code class="nx">findOne</code><code class="p">({</code><code class="nx">geometry</code><code class="o">:</code><code class="p">{</code><code class="nx">$geoIntersects</code><code class="o">:</code><code class="p">{</code><code class="nx">$geometry</code><code class="o">:</code><code class="p">{</code><code class="nx">type</code><code class="o">:</code><code class="s2">"Point"</code><code class="p">,</code>
<code class="p">...</code> <code class="nx">coordinates</code><code class="o">:</code><code class="p">[</code><code class="o">-</code><code class="mf">73.93414657</code><code class="p">,</code><code class="mf">40.82302903</code><code class="p">]}}}})</code></pre><p>This query will return the following result:</p><pre data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
  <code class="s2">"_id"</code><code class="o">:</code><code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"55cb9c666c522cafdb053a68"</code><code class="p">),</code>
  <code class="s2">"geometry"</code><code class="o">:</code><code class="p">{</code>
    <code class="s2">"type"</code><code class="o">:</code><code class="s2">"Polygon"</code><code class="p">,</code>
    <code class="s2">"coordinates"</code><code class="o">:</code><code class="p">[[[</code><code class="o">-</code><code class="mf">73.93383000695911</code><code class="p">,</code><code class="mf">40.81949109558767</code><code class="p">],...]]},</code>
    <code class="s2">"name"</code><code class="o">:</code><code class="s2">"Central Harlem North-Polo Grounds"</code>
<code class="p">}</code></pre></div></section><section data-type="sect3" data-pdf-bookmark="Finding all restaurants in the neighborhood"><div class="sect3" id="idm45882368459192"><h3>Finding all restaurants in the neighborhood</h3><p>We<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="using" data-tertiary="finding all restaurants in neighborhoods" id="idm45882368420136"/> can also query to find all restaurants contained in a
        given neighborhood. To do so, we can execute the following in the
        <em>mongo</em> shell to find the neighborhood containing
        the user, and then count the restaurants within that neighborhood. For
        example, to find all the restaurants in the Hell’s Kitchen
        neighborhood:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">neighborhood</code> <code class="o">=</code> <code class="nx">db</code><code class="p">.</code><code class="nx">neighborhoods</code><code class="p">.</code><code class="nx">findOne</code><code class="p">({</code>
  <code class="nx">geometry</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">$geoIntersects</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">$geometry</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">type</code><code class="o">:</code> <code class="s2">"Point"</code><code class="p">,</code>
        <code class="nx">coordinates</code><code class="o">:</code> <code class="p">[</code><code class="o">-</code><code class="mf">73.93414657</code><code class="p">,</code><code class="mf">40.82302903</code><code class="p">]</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">});</code>

<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">restaurants</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code>
    <code class="nx">location</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">$geoWithin</code><code class="o">:</code> <code class="p">{</code>
        <code class="c1">// Use the geometry from the neighborhood object we retrieved above</code>
        <code class="nx">$geometry</code><code class="o">:</code> <code class="nx">neighborhood</code><code class="p">.</code><code class="nx">geometry</code>
      <code class="p">}</code>
    <code class="p">}</code>
  <code class="p">},</code>
  <code class="c1">// Project just the name of each matching restaurant</code>
  <code class="p">{</code><code class="nx">name</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">_id</code><code class="o">:</code> <code class="mi">0</code><code class="p">});</code></pre><p>This query will tell you that there are 127 restaurants in the
        requested neighborhood that have the following names:</p><pre data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"White Castle"</code>
<code class="p">}</code>
<code class="p">{</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Touch Of Dee'S"</code>
<code class="p">}</code>
<code class="p">{</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Mcdonald'S"</code>
<code class="p">}</code>
<code class="p">{</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Popeyes Chicken &amp; Biscuits"</code>
<code class="p">}</code>
<code class="p">{</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Make My Cake"</code>
<code class="p">}</code>
<code class="p">{</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Manna Restaurant Ii"</code>
<code class="p">}</code>
<code class="p">...</code>
<code class="p">{</code>
  <code class="s2">"name"</code><code class="o">:</code> <code class="s2">"Harlem Coral Llc"</code>
<code class="p">}</code></pre></div></section><section data-type="sect3" data-pdf-bookmark="Finding restaurants within a distance"><div class="sect3" id="idm45882368343800"><h3>Finding restaurants within a distance</h3><p>To<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="using" data-tertiary="finding restaurants within a distance" id="idm45882368140216"/><a data-type="indexterm" data-primary="$geoWithin operator" data-primary-sortas="geoWithin operator" id="idm45882368138776"/><a data-type="indexterm" data-primary="$centerSphere&#10;            operator" data-primary-sortas="centerSphere operator" id="idm45882368137672"/><a data-type="indexterm" data-primary="$nearSphere&#10;            operator" data-primary-sortas="nearSphere operator" id="idm45882368136600"/><a data-type="indexterm" data-primary="$maxDistance&#10;            operator" data-primary-sortas="maxDistance operator" id="idm45882368135528"/> find restaurants within a specified distance of a
        point, you can use either <code>"$geoWithin"</code> with <code>"$centerSphere"</code> to return results in
        unsorted order, or <code>"$nearSphere"</code>
        with <code>"$maxDistance"</code> if you need
        results sorted by distance.</p><p>To find restaurants within a circular region, use <code>"$geoWithin"</code> with <code>"$centerSphere"</code>. <code>"$centerSphere"</code> is a MongoDB-specific syntax
        to denote a circular region by specifying the center and the radius in
        radians. <code>"$geoWithin"</code> does not
        return the documents in any specific order, so it might return the
        furthest documents first.</p><p>The following will find all restaurants within five miles of the
        user:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">restaurants</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code>
  <code class="nx">location</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">$geoWithin</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">$centerSphere</code><code class="o">:</code> <code class="p">[</code>
        <code class="p">[</code><code class="o">-</code><code class="mf">73.93414657</code><code class="p">,</code><code class="mf">40.82302903</code><code class="p">],</code>
        <code class="mi">5</code><code class="o">/</code><code class="mf">3963.2</code>
      <code class="p">]</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">})</code></pre><p><code>"$centerSphere"</code>’s second
        argument accepts the radius in radians. The query converts the
        distance to radians by dividing by the approximate equatorial radius
        of the earth, 3963.2 miles.</p><p>Applications can use <code>"$centerSphere"</code> without having a geospatial
        index. However, geospatial indexes support much faster queries than
        the unindexed equivalents. Both <code>2dsphere</code> and <code>2d</code> geospatial indexes support <code>"$centerSphere"</code>.</p><p>You may also use <code>"$nearSphere"</code> and specify a <code>"$maxDistance"</code> term in meters. This will
        return all restaurants within five miles of the user in sorted order
        from nearest to<a data-type="indexterm" data-startref="GIusing06" id="idm45882368101288"/> farthest:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="kd">var</code> <code class="nx">METERS_PER_MILE</code> <code class="o">=</code> <code class="mf">1609.34</code><code class="p">;</code>
<code class="nx">db</code><code class="p">.</code><code class="nx">restaurants</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code>
  <code class="nx">location</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">$nearSphere</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">$geometry</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">type</code><code class="o">:</code> <code class="s2">"Point"</code><code class="p">,</code>
        <code class="nx">coordinates</code><code class="o">:</code> <code class="p">[</code><code class="o">-</code><code class="mf">73.93414657</code><code class="p">,</code><code class="mf">40.82302903</code><code class="p">]</code>
      <code class="p">},</code>
      <code class="nx">$maxDistance</code><code class="o">:</code> <code class="mi">5</code><code class="o">*</code><code class="nx">METERS_PER_MILE</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">});</code></pre></div></section></div></section><section data-type="sect2" data-pdf-bookmark="Compound Geospatial Indexes"><div class="sect2" id="sect2_d1e5996"><h2>Compound Geospatial Indexes</h2><p>As<a data-type="indexterm" data-primary="compound indexes" data-secondary="geospatial" id="idm45882368034632"/><a data-type="indexterm" data-primary="geospatial indexes" data-secondary="compound" id="idm45882368033656"/> with other types of indexes, you can combine geospatial
      indexes with other fields to optimize more complex queries. A possible
      query mentioned earlier was: “What restaurants are in Hell’s Kitchen?”
      Using only a geospatial index, we could narrow the field to everything
      in Hell’s Kitchen, but narrowing it down to only “restaurants” or
      “pizza” would require another field in the index:</p><pre id="I_programlisting5_d1e6289" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">openStreetMap</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"tags"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"location"</code> <code class="o">:</code> <code class="s2">"2dsphere"</code><code class="p">})</code></pre><p>Then we can quickly find a pizza place in Hell’s Kitchen:</p><pre id="I_programlisting5_d1e6293" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">openStreetMap</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"loc"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$geoWithin"</code> <code class="o">:</code> 
<code class="p">...</code> <code class="p">{</code><code class="s2">"$geometry"</code> <code class="o">:</code> <code class="nx">hellsKitchen</code><code class="p">.</code><code class="nx">geometry</code><code class="p">}},</code> 
<code class="p">...</code> <code class="s2">"tags"</code> <code class="o">:</code> <code class="s2">"pizza"</code><code class="p">})</code></pre><p>We can have the “vanilla” index field either before or after the
      <code>"2dsphere"</code> field, depending on
      whether we’d like to filter by the vanilla field or the location first.
      Choose whichever is more selective (i.e., will filter out more results
      as the first index term).</p></div></section><section data-type="sect2" data-pdf-bookmark="2d Indexes"><div class="sect2" id="idm45882368000984"><h2>2d Indexes</h2><p>For<a data-type="indexterm" data-primary="geospatial indexes" data-secondary="2d indexes" id="GI2d06"/><a data-type="indexterm" data-primary="2d indexes" id="twodindex06"/> nonspherical maps (videogame maps, time series data,
      etc.) you can use a <code>"2d"</code> index
      instead of <code>"2dsphere"</code>:</p><pre id="I_programlisting5_d1e6126" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"tile"</code> <code class="o">:</code> <code class="s2">"2d"</code><code class="p">})</code></pre><p><code>2d</code> indexes assume a perfectly
      flat surface, instead of a sphere. Thus, <code>2d</code> indexes should not be used with spheres
      unless you don’t mind massive distortion around the poles.</p><p>Documents should use a two-element array for their <code>"2d"</code> indexed field. The elements in this array
      should reflect the longitude and lattitude coordinates, respectively. A
      sample document might look like this:</p><pre id="I_programlisting5_d1e6136" data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
    <code class="s2">"name"</code> <code class="o">:</code> <code class="s2">"Water Temple"</code><code class="p">,</code>
    <code class="s2">"tile"</code> <code class="o">:</code> <code class="p">[</code> <code class="mi">32</code><code class="p">,</code> <code class="mi">22</code> <code class="p">]</code>
<code class="p">}</code></pre><p>Do not use a <code>2d</code> index if you
      plan to store GeoJSON data<a data-type="indexterm" data-primary="GeoJSON format" id="idm45882367877848"/>—they can only index points. You can store an array of
      points, but it will be stored as exactly that: an array of points, not a
      line. This is an important distinction for <a data-type="indexterm" data-primary="$geoWithin operator" data-primary-sortas="geoWithin operator" id="idm45882367876776"/><code>"$geoWithin"</code> queries,
      in particular. If you store a street as an array of points, the document
      will match <span class="keep-together"><code>"$geoWithin"</code> if</span> one of those points
      is within the given shape. However, the line created by those points
      might not be wholly contained in the shape.</p><p>By default, <code>2d</code> indexes assume
      that your values are going to range from −180 to 180. If you are
      expecting larger or smaller bounds, you can specify what the minimum and
      maximum values will be as options to <code class="function">createIndex</code>:</p><pre id="I_programlisting5_d1e6156" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"light-years"</code> <code class="o">:</code> <code class="s2">"2d"</code><code class="p">},</code> <code class="p">{</code><code class="s2">"min"</code> <code class="o">:</code> <code class="o">-</code><code class="mi">1000</code><code class="p">,</code> <code class="s2">"max"</code> <code class="o">:</code> <code class="mi">1000</code><code class="p">})</code></pre><p>This will create a spatial index calibrated for a 2,000 × 2,000
      square.</p><p><code>2d</code> indexes support the <code>"$geoWithin"</code>, <code>"$nearSphere"</code>, and <code>"$near"</code> query selectors. Use <code>"$geoWithin"</code> to query for points within a
      shape defined on a flat surface. <code>"$geoWithin"</code> can query for all points within a
      rectangle, polygon, circle<a data-type="indexterm" data-primary="circle, querying for points within" id="idm45882367805016"/>, or sphere; it uses the <code>"$geometry"</code> operator to specify the GeoJSON
      object. Returning to our grid indexed as follows:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"tile"</code> <code class="o">:</code> <code class="s2">"2d"</code><code class="p">})</code></pre><p>the following queries for documents within a rectangle defined by
      [10, 10] at the bottom-left corner and by [100, 100] at the top-right
      corner:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code>
  <code class="nx">tile</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">$geoWithin</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">$box</code><code class="o">:</code> <code class="p">[[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">10</code><code class="p">],</code> <code class="p">[</code><code class="mi">100</code><code class="p">,</code> <code class="mi">100</code><code class="p">]]</code>
    <code class="p">}</code> 
   <code class="p">}</code>
<code class="p">})</code></pre><p><code>$box</code><a data-type="indexterm" data-primary="$box operator" data-primary-sortas="box operator" id="idm45882367791608"/> takes a two-element array: the first element specifies
      the coordinates of the lower-left corner and the second element the
      upper right.</p><p>To query for documents that are within the circle centered on [−17
      , 20.5] and with a radius of 25 we can issue the following
      command:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code>
  <code class="nx">tile</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">$geoWithin</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">$center</code><code class="o">:</code> <code class="p">[[</code><code class="o">-</code><code class="mi">17</code><code class="p">,</code> <code class="mf">20.5</code><code class="p">]</code> <code class="p">,</code> <code class="mi">25</code><code class="p">]</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">})</code></pre><p>The following query returns all documents with coordinates that
      exist within the polygon defined by [0, 0], [3, 6], and [6 , 0]:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code>
  <code class="nx">tile</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">$geoWithin</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">$polygon</code><code class="o">:</code> <code class="p">[[</code><code class="mi">0</code><code class="p">,</code> <code class="mi">0</code><code class="p">],</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code> <code class="p">[</code><code class="mi">6</code><code class="p">,</code> <code class="mi">0</code><code class="p">]]</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">})</code></pre><p>You specify a polygon as an array of points. The final point in
      the list will be “connected to” the first point to form the polygon.
      This example would locate all documents containing points within the
      given triangle.</p><p>MongoDB also supports rudimentary spherical queries on flat
      <code>2d</code> indexes for legacy reasons. In
      general, spherical calculations should use a 2dsphere index, as
      described in <a data-type="xref" href="#twod_vs_sgq">“2D versus spherical geometry in queries”</a>. However, to query for
      legacy coordinate pairs within a sphere, use <code>"$geoWithin"</code> <a data-type="indexterm" data-primary="$geoWithin operator" data-primary-sortas="geoWithin operator" id="idm45882367593768"/><a data-type="indexterm" data-primary="$centerSphere&#10;          operator" data-primary-sortas="centerSphere operator" id="idm45882367592664"/>with the “<code>$centerSphere”</code> operator. Specify an array that
      contains:</p><ul><li><p>The grid coordinates of the circle’s center point</p></li><li><p>The circle’s radius measured in radians</p></li></ul><p>For example:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code>
  <code class="nx">loc</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">$geoWithin</code><code class="o">:</code> <code class="p">{</code>
      <code class="nx">$centerSphere</code><code class="o">:</code> <code class="p">[[</code><code class="mi">88</code><code class="p">,</code> <code class="mi">30</code><code class="p">],</code> <code class="mi">10</code><code class="o">/</code><code class="mf">3963.2</code><code class="p">]</code>
    <code class="p">}</code>
  <code class="p">}</code>
<code class="p">})</code></pre><p>To query for nearby points, use <code>"$near"</code>. Proximity queries return the
      documents with coordinate pairs closest to the defined point and sort
      the results by distance. This finds all of the documents in the
      <em>hyrule</em> collection in order by distance from the
      point (20, 21):</p><pre id="I_programlisting5_d1e6180" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"tile"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$near"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">]}})</code></pre><p>A default limit of 100 documents is applied if no limit is
      specified. If you don’t need that many results, you should set a limit
      to conserve server resources. For<a data-type="indexterm" data-startref="GI2d06" id="idm45882367524200"/> example, the following code returns the
      10 documents<a data-type="indexterm" data-startref="Igeo06" id="idm45882367523336"/><a data-type="indexterm" data-startref="twodindex06" id="idm45882367522600"/> nearest to (20, 21):</p><pre id="I_programlisting5_d1e6195" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">hyrule</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"tile"</code> <code class="o">:</code> <code class="p">{</code><code class="s2">"$near"</code> <code class="o">:</code> <code class="p">[</code><code class="mi">20</code><code class="p">,</code> <code class="mi">21</code><code class="p">]}}).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code></pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="Indexes for Full Text Search"><div class="sect1" id="idm45882367521544"><h1>Indexes for Full Text Search</h1><p><code>text</code> indexes<a data-type="indexterm" data-primary="indexes" data-secondary="for full text search" id="Ifull06"/><a data-type="indexterm" data-primary="full-text indexes" data-secondary="versus MongoDB Atlas Full-Text Search Indexes" id="idm45882367441544"/> in MongoDB support full-text search requirements. This type
    of <code>text</code> index should not be confused
    with the MongoDB Atlas Full-Text Search Indexes, which utilize Apache
    Lucene<a data-type="indexterm" data-primary="Apache Lucene" id="idm45882367439672"/> for additional text search capabilities when compared to
    MongoDB text indexes. Use<a data-type="indexterm" data-primary="full-text indexes" data-secondary="uses for" id="idm45882367438712"/> a <code>text</code> index if your
    application needs to enable users to submit keyword queries that should
    match titles, descriptions, and text in other fields within a
    collection.</p><p>In<a data-type="indexterm" data-primary="full-text indexes" data-secondary="benefits and drawbacks of" id="idm45882367436712"/> previous chapters, we’ve queried for strings using exact
    matches and regular expressions, but these techniques have some
    limitations. Searching a large block of text for a regular expression is
    slow, and it’s tough to take morphology (e.g., that “entry” should match
    “entries”) and other challenges presented by human language into account.
    <code>text</code> indexes give you the ability to
    search text quickly and provide support for common search engine
    requirements such as language-appropriate tokenization, stop words, and
    stemming.</p><p><code>text</code> indexes require a number of
    keys proportional to the words in the fields being indexed. As a
    consequence, creating a <code>text</code> index can
    consume a large amount of system resources. You should create such an
    index at a time when it will not negatively impact the performance of your
    application for users or build the index in the background, if possible.
    To ensure good performance, as with all indexes, you should also take care
    that any <code>text</code> index you create fits in
    RAM. See <a data-type="xref" href="ch19.xhtml#chapter-data-admin">Chapter 19</a> for more information on
    creating indexes with minimal impact on your application.</p><p>Writes to a collection require that all indexes are updated. If you
    are using text search, strings will be tokenized and stemmed and the index
    updated in, potentially, many places. For this reason, writes involving
    <code>text</code> indexes are usually more expensive
    than writes to single-field, compound, or even multikey indexes. Thus, you
    will tend to see poorer write performance on <code>text</code>-indexed collections than on others. They
    will also slow down data movement if you are sharding: all text must be
    reindexed when it is migrated to a new shard.</p><section data-type="sect2" data-pdf-bookmark="Creating a Text Index"><div class="sect2" id="idm45882367429864"><h2>Creating a Text Index</h2><p>Suppose<a data-type="indexterm" data-primary="full-text indexes" data-secondary="creating" id="idm45882367428664"/> we have a collection of Wikipedia articles that we want
      to index. To run a search over the text, we first need to create a
      <code>text</code> index. The following call to
      <code class="function">createIndex</code> will create the index
      based on the terms in both the <code>"title"</code> and <code>"body"</code> fields:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"title"</code><code class="o">:</code> <code class="s2">"text"</code><code class="p">,</code>
                           <code class="s2">"body"</code> <code class="o">:</code> <code class="s2">"text"</code><code class="p">})</code></pre><p>This is not like a “normal” compound index where there is an
      ordering on the keys. By default, each field is given equal
      consideration in a <code>text</code> index. You
      can control the relative importance MongoDB attaches to each field by
      specifying weights:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"title"</code><code class="o">:</code> <code class="s2">"text"</code><code class="p">,</code> 
                           <code class="s2">"body"</code><code class="o">:</code> <code class="s2">"text"</code><code class="p">},</code>
                          <code class="p">{</code><code class="s2">"weights"</code> <code class="o">:</code> <code class="p">{</code>
                               <code class="s2">"title"</code> <code class="o">:</code> <code class="mi">3</code><code class="p">,</code> 
                               <code class="s2">"body"</code> <code class="o">:</code> <code class="mi">2</code><code class="p">}})</code></pre><p>This would weight the <code>"title"</code>
      field at a ratio of 3:2 in comparison to the <code>"body"</code> field.</p><p>You cannot change field weights after index creation (without
      dropping the index and recreating it), so you may want to play with
      weights on a sample dataset before creating the index on your production
      data.</p><p>For some collections, you may not know which fields a document
      will contain. You<a data-type="indexterm" data-primary="$ (dollar sign)" data-secondary="creating indexes on $**" id="idm45882367341096"/> can create a full-text index on all string fields in a
      document by creating an index on <code>"$**"</code>—this not only indexes all top-level
      string fields, but also searches embedded documents and arrays for
      string fields:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"$**"</code> <code class="o">:</code> <code class="s2">"text"</code><code class="p">})</code></pre></div></section><section data-type="sect2" data-pdf-bookmark="Text Search"><div class="sect2" id="idm45882367339224"><h2>Text Search</h2><p>Use<a data-type="indexterm" data-primary="full-text indexes" data-secondary="text search" id="idm45882367330568"/><a data-type="indexterm" data-primary="$text operator" data-primary-sortas="text operator" id="idm45882367329672"/> the <code>"$text"</code> query
      operator to perform text searches on a collection with a <code>text</code> index. <code>"$text"</code> will tokenize the search string using
      whitespace and most punctuation as delimiters, and perform a logical OR
      of all such tokens in the search string. For example, you could use the
      following query to find all articles containing any of the terms
      “impact,” “crater,” or “lunar.” Note that because our index is based on
      terms in both the title and body of an article, this query will match
      documents in which those terms are found in either field. For the
      purposes of this example, we will project the title so that we can fit
      more results on the page:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="s2">"$text"</code><code class="o">:</code> <code class="p">{</code><code class="s2">"$search"</code><code class="o">:</code> <code class="s2">"impact crater lunar"</code><code class="p">}},</code> 
                   <code class="p">{</code><code class="nx">title</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>
                  <code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"170375"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Chengdu"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"34331213"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Avengers vs. X-Men"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"498834"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Culture of Tunisia"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"602564"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"ABC Warriors"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"40255"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Jupiter (mythology)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"80356"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"History of Vietnam"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"22483"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Optics"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"8919057"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Characters in The Legend of Zelda series"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"20767983"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"First inauguration of Barack Obama"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"17845285"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Kushiel's Mercy"</code> <code class="p">}</code></pre><p>You can see that the results with our initial query are not
      terribly relevant. As with all technologies, it’s important to have a
      good grasp of how <code>text</code> indexes work
      in MongoDB in order to use them effectively. In this case, there are two
      problems with the way we’ve issued the query. The first is that our
      query is pretty broad, given that MongoDB issues the query using a
      logical OR of “impact,” “crater,” and “lunar.” The second problem is
      that, by default, a text search does not sort the results by
      relevance.</p><p>We<a data-type="indexterm" data-primary="full-text indexes" data-secondary="phrases and logical ANDs in queries" id="idm45882367317096"/> can begin to address the problem of the query itself by
      using a phrase in our query. You can search for<a data-type="indexterm" data-primary="exact phrase searches" id="idm45882367145112"/> exact phrases by wrapping them in double quotes. For
      example, the following will find all documents containing the phrase
      “impact crater.” Possibly surprising is that MongoDB will issue this
      query as “impact crater” AND “lunar”:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">$text</code><code class="o">:</code> <code class="p">{</code><code class="nx">$search</code><code class="o">:</code> <code class="s2">"\"impact crater\" lunar"</code><code class="p">}},</code>
                   <code class="p">{</code><code class="nx">title</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>
                     <code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"2621724"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Schjellerup (crater)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"2622075"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Steno (lunar crater)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"168118"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"South Pole–Aitken basin"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"1509118"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Jackson (crater)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"10096822"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Victoria Island structure"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"968071"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Buldhana district"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"780422"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Puchezh-Katunki crater"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"28088964"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Svedberg (crater)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"780628"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Zeleny Gai crater"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"926711"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Fracastorius (crater)"</code> <code class="p">}</code></pre><p>To make sure the semantics of this are clear, let’s look at an
      expanded example. For the following query, MongoDB will issue the query
      as “impact crater” AND (“lunar” OR “meteor”). MongoDB performs a logical
      AND of the phrase with the individual terms in the search string and a
      logical OR of the individual terms with one another:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">$text</code><code class="o">:</code> <code class="p">{</code><code class="nx">$search</code><code class="o">:</code> <code class="s2">"\"impact crater\" lunar meteor"</code><code class="p">}},</code>
                 <code class="p">{</code><code class="nx">title</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>
		<code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code></pre><p>If you want to issue a logical AND between individual terms in a
      query, treat each term as a phrase by wrapping it in quotes. The
      following query will return documents containing “impact crater” AND
      “lunar” AND “meteor”:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">$text</code><code class="o">:</code> <code class="p">{</code><code class="nx">$search</code><code class="o">:</code> <code class="s2">"\"impact crater\" \"lunar\" \"meteor\""</code><code class="p">}},</code>
                   <code class="p">{</code><code class="nx">title</code><code class="o">:</code> <code class="mi">1</code><code class="p">}</code>
		     <code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"168118"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"South Pole–Aitken basin"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"330593"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Giordano Bruno (crater)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"421051"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Opportunity (rover)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"2693649"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Pascal Lee"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"275128"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Tektite"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"14594455"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Beethoven quadrangle"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"266344"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Space debris"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"2137763"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Wegener (lunar crater)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"929164"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Dawes (lunar crater)"</code> <code class="p">}</code>
<code class="p">{</code> <code class="s2">"_id"</code> <code class="o">:</code> <code class="s2">"24944"</code><code class="p">,</code> <code class="s2">"title"</code> <code class="o">:</code> <code class="s2">"Plate tectonics"</code> <code class="p">}</code></pre><p>Now<a data-type="indexterm" data-primary="full-text indexes" data-secondary="sorting for relevance" id="idm45882366888936"/> that you have a better understanding of using phrases and
      logical ANDs in your queries, let’s return to the problem of the results
      not being sorted by relevance. While the preceding results are certainly
      relevant, this is mostly due to the fairly strict query we’ve issued. We
      can do better by sorting for relevance.</p><p>Text queries cause some metadata to be associated with each query
      result. The metadata is not displayed in the query results unless we
      explicitly project it using the <code>$meta</code>
      operator<a data-type="indexterm" data-primary="$meta operator" data-primary-sortas="meta operator" id="idm45882366886744"/>. So, in addition to the title, we will project the
      relevance score calculated for each document. The relevance score is
      stored in the metadata field named <code>"textScore"</code>. For this example, we’ll return to
      our query of “impact crater” AND “lunar”:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">$text</code><code class="o">:</code> <code class="p">{</code><code class="nx">$search</code><code class="o">:</code> <code class="s2">"\"impact crater\" lunar"</code><code class="p">}},</code>
                   <code class="p">{</code><code class="nx">title</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">score</code><code class="o">:</code> <code class="p">{</code><code class="nx">$meta</code><code class="o">:</code> <code class="s2">"textScore"</code><code class="p">}}</code>
		     <code class="p">).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"2621724"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Schjellerup (crater)"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">2.852987132352941</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"2622075"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Steno (lunar crater)"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">2.4766639610389607</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"168118"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"South Pole–Aitken basin"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">2.980198136295181</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"1509118"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Jackson (crater)"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">2.3419137286324787</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"10096822"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Victoria Island structure"</code><code class="p">,</code> 
 <code class="s2">"score"</code><code class="o">:</code> <code class="mf">1.782051282051282</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"968071"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Buldhana district"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">1.6279783393501805</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"780422"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Puchezh-Katunki crater"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">1.9295977011494254</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"28088964"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Svedberg (crater)"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">2.497767857142857</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"780628"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Zeleny Gai crater"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">1.4866071428571428</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"926711"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Fracastorius (crater)"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">2.7511877111486487</code><code class="p">}</code></pre><p>Now you can see the relevance score projected with the title for
      each result. Note that they are not sorted. To sort the results in order
      of relevance score, we must add a call to <code class="function">sort</code>, again using <code>$meta</code> to specify the <code>"textScore"</code> field value. Note that we must use
      the same field name in our sort as we used in our projection. In this
      case, we used the field name <code>"score"</code>
      for the relevance score value displayed in our search results. As you
      can see, the results are now sorted in decreasing order of
      relevance:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">articles</code><code class="p">.</code><code class="nx">find</code><code class="p">({</code><code class="nx">$text</code><code class="o">:</code> <code class="p">{</code><code class="nx">$search</code><code class="o">:</code> <code class="s2">"\"impact crater\" lunar"</code><code class="p">}},</code>
                   <code class="p">{</code><code class="nx">title</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">score</code><code class="o">:</code> <code class="p">{</code><code class="nx">$meta</code><code class="o">:</code> <code class="s2">"textScore"</code><code class="p">}}</code>
		     <code class="p">).</code><code class="nx">sort</code><code class="p">({</code><code class="nx">score</code><code class="o">:</code> <code class="p">{</code><code class="nx">$meta</code><code class="o">:</code> <code class="s2">"textScore"</code><code class="p">}}).</code><code class="nx">limit</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"1621514"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Lunar craters"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.1655242042922014</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"14580008"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Kuiper quadrangle"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.0847527829208814</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"1019830"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Shackleton (crater)"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.076471119932001</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"2096232"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Geology of the Moon"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.064981949458484</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"927269"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Messier (crater)"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.0638183133686008</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"206589"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Lunar geologic timescale"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.062029540854157</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"14536060"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Borealis quadrangle"</code><code class="p">,</code> <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.0573010719646687</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"14609586"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Michelangelo quadrangle"</code><code class="p">,</code> 
 <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.057224063486582</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"14568465"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Shakespeare quadrangle"</code><code class="p">,</code> 
 <code class="s2">"score"</code><code class="o">:</code> <code class="mf">3.0495256481056443</code><code class="p">}</code>
<code class="p">{</code><code class="s2">"_id"</code><code class="o">:</code> <code class="s2">"275128"</code><code class="p">,</code> <code class="s2">"title"</code><code class="o">:</code> <code class="s2">"Tektite"</code><code class="p">,</code> <code class="s2">"score"</code> <code class="o">:</code> <code class="mf">3.0378807169646915</code><code class="p">}</code></pre><p>Text search is also available in the aggregation pipeline. We
      discuss the aggregation pipeline in <a data-type="xref" href="ch07.xhtml#chapter_d1e6036">Chapter 7</a>.</p></div></section><section data-type="sect2" data-pdf-bookmark="Optimizing Full-Text Search"><div class="sect2" id="idm45882367331256"><h2>Optimizing Full-Text Search</h2><p>There<a data-type="indexterm" data-primary="full-text indexes" data-secondary="optimizing" id="idm45882366562104"/> are a couple of ways to optimize full-text searches. If
      you can first narrow your search results by other criteria, you can
      create a compound index with a prefix of those criteria and then the
      full-text fields:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"date"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"post"</code> <code class="o">:</code> <code class="s2">"text"</code><code class="p">})</code></pre><p>This is referred to as <em>partitioning</em> the
      full-text index, as it breaks it into several smaller trees based on
      <code>"date"</code> (in this example). This makes
      full-text searches for a specific date or date range much faster.</p><p>You can also use a postfix of other criteria to cover queries with
      the index. For example, if we were only returning the <code>"author"</code> and <code>"post"</code> fields, we could create a compound
      index on both:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"post"</code> <code class="o">:</code> <code class="s2">"text"</code><code class="p">,</code> <code class="s2">"author"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">})</code></pre><p>These prefix and postfix forms can be combined:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">blog</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"date"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"post"</code> <code class="o">:</code> <code class="s2">"text"</code><code class="p">,</code> <code class="s2">"author"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">})</code></pre></div></section><section data-type="sect2" data-pdf-bookmark="Searching in Other Languages"><div class="sect2" id="idm45882366228488"><h2>Searching in Other Languages</h2><p>When<a data-type="indexterm" data-primary="full-text indexes" data-secondary="searching other languages" id="idm45882366168536"/> a document is inserted (or the index is first created),
      MongoDB looks at the index’s fields and <span class="firstterm">stems</span>
      each word, reducing it to an essential unit. However, different
      languages stem words in different ways, so you must specify what
      language the index or document is in. <code>text</code> indexes allow a <code>"default_language"</code> option to be specified,
      which defaults to <code>"english"</code> but can
      be set to a number of other languages (see the <a href="https://oreil.ly/eUt0Z">online
      documentation</a> for an up-to-date list).</p><p>For example, to create a French-language index, we could
      say:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"profil"</code> <code class="o">:</code> <code class="s2">"text"</code><code class="p">,</code> 
                        <code class="s2">"intérêts"</code> <code class="o">:</code> <code class="s2">"text"</code><code class="p">},</code> 
                       <code class="p">{</code><code class="s2">"default_language"</code> <code class="o">:</code> <code class="s2">"french"</code><code class="p">})</code></pre><p>Then French would be used for stemming, unless otherwise
      specified. You can, on a per-document basis, specify another stemming
      language by having a <code>"language"</code> field
      that describes the<a data-type="indexterm" data-startref="Ifull06" id="idm45882366133192"/> document’s language:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">users</code><code class="p">.</code><code class="nx">insert</code><code class="p">({</code><code class="s2">"username"</code> <code class="o">:</code> <code class="s2">"swedishChef"</code><code class="p">,</code> 
<code class="p">...</code> <code class="s2">"profile"</code> <code class="o">:</code> <code class="s2">"Bork de bork"</code><code class="p">,</code> <code class="nx">language</code> <code class="o">:</code> <code class="s2">"swedish"</code><code class="p">})</code></pre></div></section></div></section><section data-type="sect1" data-pdf-bookmark="Capped Collections"><div class="sect1" id="sect1_d1e7549"><h1>Capped Collections</h1><p>“Normal” collections<a data-type="indexterm" data-primary="capped collections" data-secondary="versus normal" id="idm45882366045976"/><a data-type="indexterm" data-primary="indexes" data-secondary="capped collections" id="Icapped06"/><a data-type="indexterm" data-primary="collections" data-secondary="capped" id="Ccap06"/> in MongoDB are created dynamically and automatically grow
    in size to fit additional data. MongoDB also supports a different type of
    collection, called a <em>capped collection</em>, which is
    created in advance and is fixed in size (see <a data-type="xref" href="#figure_d1e7559">Figure 6-4</a>). </p><figure style="float: none"><div id="figure_d1e7559" class="figure"><img src="Images/mdb3_0604.png" width="1061" height="820"/><h6><span class="label">Figure 6-4. </span>New documents are inserted at the end of the queue</h6></div></figure><p>Having fixed-size collections brings up an
    interesting question: what happens when we try to insert into a capped
    collection that is already full? The<a data-type="indexterm" data-primary="capped collections" data-secondary="circular queue-like behavior" id="idm45882366004360"/> answer is that capped collections behave like circular
    queues: if we’re out of space, the oldest document will be deleted, and
    the new one will take its place (see <a data-type="xref" href="#figure_d1e7572">Figure 6-5</a>).
    This means that capped collections automatically age out the oldest
    documents as new documents are inserted.</p><p>Certain<a data-type="indexterm" data-primary="capped collections" data-secondary="restricted operation" id="idm45882366001656"/> operations are not allowed on capped collections. Documents
    cannot be removed or deleted (aside from the automatic age-out described
    earlier), and updates that would cause documents to grow in size are
    disallowed. By preventing these two operations, we guarantee that
    documents in a capped collection are stored in insertion order and that
    there is no need to maintain a free list for space from removed
    documents.</p><figure style="float: none"><div id="figure_d1e7572" class="figure"><img src="Images/mdb3_0605.png" width="823" height="984"/><h6><span class="label">Figure 6-5. </span>When the queue is full, the oldest element will be replaced by
      the newest</h6></div></figure><p>Capped collections<a data-type="indexterm" data-primary="capped collections" data-secondary="access pattern in" id="idm45882365998328"/> have a different access pattern than most MongoDB
    collections: data is written sequentially over a fixed section of disk.
    This makes them tend to perform writes quickly on spinning disks,
    especially if they can be given their own disk (so as not to be
    “interrupted” by other collections’ random writes).</p><p>In<a data-type="indexterm" data-primary="time-to-live (TTL) indexes" data-secondary="versus capped&#10;        collections" id="idm45882365996504"/><a data-type="indexterm" data-primary="capped indexes, versus time-to-live indexes" id="idm45882365995384"/> general, MongoDB TTL indexes are recommended over capped
    collections because they perform better with the WiredTiger storage
    engine. TTL indexes expire and remove data from normal collections based
    on the value of a date-typed field and a TTL value for the index. These
    are covered in more depth later in this chapter.</p><div data-type="note" epub:type="note"><h6>Note</h6><p>Capped collections cannot be sharded. If an update or a
      replacement operation changes the document size in a capped collection,
      the operation will fail.</p></div><p>Capped collections tend to be useful for logging, although they lack
    flexibility: you cannot control when data ages out, other than setting a
    size when you create the <span class="keep-together">collection</span>.</p><section data-type="sect2" data-pdf-bookmark="Creating Capped Collections"><div class="sect2" id="sect2_d1e7616"><h2>Creating Capped Collections</h2><p>Unlike<a data-type="indexterm" data-primary="capped collections" data-secondary="creating" id="idm45882365990520"/> normal collections, capped collections must be explicitly
      created before they are used. To create a capped collection, use the
      <code>create</code> command<a data-type="indexterm" data-primary="create command" id="idm45882365988680"/>. From the shell, this can be done using <code class="function">createCollection<a data-type="indexterm" data-primary="createCollection command" id="idm45882365987128"/></code>:</p><pre id="I_programlisting7_d1e7910" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">createCollection</code><code class="p">(</code><code class="s2">"my_collection"</code><code class="p">,</code> <code class="p">{</code><code class="s2">"capped"</code> <code class="o">:</code> <code class="kc">true</code><code class="p">,</code> <code class="s2">"size"</code> <code class="o">:</code> <code class="mi">100000</code><code class="p">});</code></pre><p>The previous command creates a capped collection,
      <em>my_collection</em>, that has a fixed size of 100,000
      bytes.</p><p><code>createCollection</code> can also
      specify a limit on the number of documents in a capped
      collection:</p><pre id="I_programlisting7_d1e7920" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">createCollection</code><code class="p">(</code><code class="s2">"my_collection2"</code><code class="p">,</code> 
                      <code class="p">{</code><code class="s2">"capped"</code> <code class="o">:</code> <code class="kc">true</code><code class="p">,</code> <code class="s2">"size"</code> <code class="o">:</code> <code class="mi">100000</code><code class="p">,</code> <code class="s2">"max"</code> <code class="o">:</code> <code class="mi">100</code><code class="p">});</code></pre><p>You could use this to keep, say, the latest 10 news articles or
      limit a user to 1,000 <span class="keep-together">documents</span>.</p><p>Once<a data-type="indexterm" data-primary="capped collections" data-secondary="inability to change" id="idm45882365937864"/> a capped collection has been created, it cannot be
      changed (it must be dropped and recreated if you wish to change its
      properties). Thus, you should think carefully about the size of a large
      collection before creating it.</p><div data-type="note" epub:type="note"><h6>Note</h6><p>When<a data-type="indexterm" data-primary="capped collections" data-secondary="limiting number of documents in" id="idm45882365935752"/> limiting the number of documents in a capped
        collection, you must specify a size limit as well. Age-out will be
        based on whichever limit is reached first: it can neither hold more
        than <code>"max"</code> documents nor take up
        more than <code>"size"</code> space.</p></div><p>Another option for creating a capped collection is to convert an
      existing regular collection into a capped collection. This can be done
      using the <code>convertToCapped</code> <span class="keep-together">command—</span>in the following example, we
      convert the <em>test</em> collection to a capped collection
      of 10,000 bytes:</p><pre id="I_programlisting7_d1e7942" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">runCommand</code><code class="p">({</code><code class="s2">"convertToCapped"</code> <code class="o">:</code> <code class="s2">"test"</code><code class="p">,</code> <code class="s2">"size"</code> <code class="o">:</code> <code class="mi">10000</code><code class="p">});</code>
<code class="p">{</code> <code class="s2">"ok"</code> <code class="o">:</code> <code class="kc">true</code> <code class="p">}</code></pre><p>There is no way to “uncap” a capped collection (other than
      dropping it).</p></div></section><section data-type="sect2" data-pdf-bookmark="Tailable Cursors"><div class="sect2" id="sect2_d1e7721"><h2>Tailable Cursors</h2><p>Tailable cursors<a data-type="indexterm" data-primary="tailable cursors" id="idm45882365845272"/><a data-type="indexterm" data-primary="cursors" data-secondary="tailable cursors" id="idm45882365844504"/><a data-type="indexterm" data-primary="capped collections" data-secondary="tailable cursors" id="idm45882365843400"/> are a special type of cursor that are not closed when
      their results are exhausted. They were inspired by the <code>tail -f</code> command and, similar to that command,
      will continue fetching output for as long as possible. Because the
      cursors do not die when they run out of results, they can continue to
      fetch new results as documents are added to the collection. Tailable
      cursors can be used only on capped collections, since insert order is
      not tracked for normal collections. For the vast majority of uses,
      change streams, covered in <a data-type="xref" href="ch16.xhtml#chapter-shardkey">Chapter 16</a>, are
      recommended over tailable cursors as they offer vastly more control and
      configuration plus they work with normal <span class="keep-together">collections</span>.</p><p>Tailable cursors are often used for processing documents as they
      are inserted onto a “work queue” (the capped collection). Because
      tailable cursors will time out after 10 minutes of no results, it is
      important to include logic to requery the collection if they die. The
      <em class="filename">mongo</em> shell does not allow you to
      use tailable cursors, but using one in PHP looks something like the
      following:</p><pre id="I_programlisting7_d1e8023" data-type="programlisting" data-code-language="php"><code class="nv">$cursor</code> <code class="o">=</code> <code class="nv">$collection</code><code class="o">-&gt;</code><code class="na">find</code><code class="p">([],</code> <code class="p">[</code>
    <code class="s1">'cursorType'</code> <code class="o">=&gt;</code> <code class="nx">MongoDB\Operation\Find</code><code class="o">::</code><code class="na">TAILABLE_AWAIT</code><code class="p">,</code>
    <code class="s1">'maxAwaitTimeMS'</code> <code class="o">=&gt;</code> <code class="mi">100</code><code class="p">,</code>
<code class="p">]);</code>


<code class="k">while</code> <code class="p">(</code><code class="k">true</code><code class="p">)</code> <code class="p">{</code>
   <code class="k">if</code> <code class="p">(</code><code class="nv">$iterator</code><code class="o">-&gt;</code><code class="na">valid</code><code class="p">())</code> <code class="p">{</code>
      <code class="nv">$document</code> <code class="o">=</code> <code class="nv">$iterator</code><code class="o">-&gt;</code><code class="na">current</code><code class="p">();</code>
      <code class="nb">printf</code><code class="p">(</code><code class="s2">"Consumed document created at: %s</code><code class="se">\n</code><code class="s2">"</code><code class="p">,</code> <code class="nv">$document</code><code class="o">-&gt;</code><code class="na">createdAt</code><code class="p">);</code>
   <code class="p">}</code>

   <code class="nv">$iterator</code><code class="o">-&gt;</code><code class="na">next</code><code class="p">();</code>
<code class="p">}</code></pre><p>The cursor will process results or wait for more results to arrive
      until it times out or someone kills the query<a data-type="indexterm" data-startref="Ccap06" id="idm45882365836744"/><a data-type="indexterm" data-startref="Icapped06" id="idm45882365728584"/> operation.</p></div></section></div></section><section data-type="sect1" data-pdf-bookmark="Time-To-Live Indexes"><div class="sect1" id="sect1-ttl"><h1>Time-To-Live Indexes</h1><p>As<a data-type="indexterm" data-primary="indexes" data-secondary="time-to-live (TTL)" id="idm45882365726456"/><a data-type="indexterm" data-primary="time-to-live (TTL) indexes" data-secondary="uses for" id="idm45882365725320"/> mentioned in the previous section, capped collections give
    you limited control over when their contents are overwritten. If you need
    a more flexible age-out system, TTL indexes allow you to set a timeout for
    each document. When a document reaches a preconfigured age, it will be
    deleted. This type of index is useful for caching use cases such as
    session storage.</p><p>You<a data-type="indexterm" data-primary="time-to-live (TTL) indexes" data-secondary="creating" id="idm45882365723464"/> can create a TTL index by specifying the
    <code class="option">"expireAfterSeconds"</code> option in the second argument to
    <code class="function">createIndex</code>:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="c1">// 24-hour timeout</code>
<code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">sessions</code><code class="p">.</code><code class="nx">createIndex</code><code class="p">({</code><code class="s2">"lastUpdated"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="p">{</code><code class="s2">"expireAfterSeconds"</code> <code class="o">:</code> <code class="mi">60</code><code class="o">*</code><code class="mi">60</code><code class="o">*</code><code class="mi">24</code><code class="p">})</code></pre><p>This creates a TTL index on the <code>"lastUpdated"</code> field. If a document’s
    <code class="varname">"lastUpdated"</code> field exists and is a date, the document
    will be removed once the server time is
    <code class="option">"expireAfterSeconds"</code> seconds ahead of the document’s
    time.</p><p>To prevent an active session from being removed, you can update the
    <code class="varname">"lastUpdated"</code> field to the current time whenever there
    is activity. Once <code class="varname">"lastUpdated"</code> is 24 hours old, the
    document will be removed.</p><p>MongoDB sweeps the TTL index once per minute, so you should not
    depend on to-the-second granularity. You can change the
    <code class="option">"expireAfterSeconds"</code> using the <code>collMod</code> <span class="keep-together">command</span>:</p><pre data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">runCommand</code><code class="p">(</code> <code class="p">{</code><code class="s2">"collMod"</code> <code class="o">:</code> <code class="s2">"someapp.cache"</code> <code class="p">,</code> <code class="s2">"index"</code> <code class="o">:</code> <code class="p">{</code> <code class="s2">"keyPattern"</code> <code class="o">:</code> 
<code class="p">...</code> <code class="p">{</code><code class="s2">"lastUpdated"</code> <code class="o">:</code> <code class="mi">1</code><code class="p">}</code> <code class="p">,</code> <code class="s2">"expireAfterSeconds"</code> <code class="o">:</code> <code class="mi">3600</code> <code class="p">}</code> <code class="p">}</code> <code class="p">);</code></pre><p>You can have multiple TTL indexes on a given collection. They cannot
    be compound indexes but can be used like “normal” indexes for the purposes
    of sorting and query optimization.</p></div></section><section data-type="sect1" data-pdf-bookmark="Storing Files with GridFS"><div class="sect1" id="sect1_d1e7744"><h1>Storing Files with GridFS</h1><p>GridFS<a data-type="indexterm" data-primary="files and filesystems" data-secondary="storing files with GridFS" id="FFstoring06"/><a data-type="indexterm" data-primary="indexes" data-secondary="GridFS file storage" id="Igrid06"/><a data-type="indexterm" data-primary="GridFS" data-secondary="benefits and drawbacks of" id="idm45882365637032"/> is a mechanism for storing large binary files in MongoDB.
    There are several reasons why you might consider using GridFS for file
    storage:</p><ul><li><p>Using GridFS can simplify your stack. If you’re already using
        MongoDB, you might be able to use GridFS instead of a separate tool
        for file storage.</p></li><li><p>GridFS will leverage any existing replication or autosharding
        that you’ve set up for MongoDB, so getting failover and scale-out for
        file storage is easier.</p></li><li><p>GridFS can alleviate some of the issues that certain filesystems
        can exhibit when being used to store user uploads. For example, GridFS
        does not have issues with storing large numbers of files in the same
        directory.</p></li></ul><p>There are some downsides, too:</p><ul><li><p>Performance is slower. Accessing files from MongoDB will not be
        as fast as going directly through the filesystem.</p></li><li><p>You can only modify documents by deleting them and resaving the
        whole thing. MongoDB stores files as multiple documents, so it cannot
        lock all of the chunks in a file at the same time.</p></li></ul><p>GridFS is generally best when you have large files you’ll be
    accessing in a sequential fashion that won’t be changing much.</p><section data-type="sect2" data-pdf-bookmark="Getting Started with GridFS: mongofiles"><div class="sect2" id="sect2_d1e7779"><h2>Getting Started with GridFS: mongofiles</h2><p>The<a data-type="indexterm" data-primary="mongofiles utility" id="idm45882365630632"/><a data-type="indexterm" data-primary="GridFS" data-secondary="mongofiles utility" id="idm45882365629768"/> easiest way to try out GridFS is by using the
      <em>mongofiles</em> utility. <em>mongofiles</em>
      is included with all MongoDB distributions and can be used to upload,
      download, list, search for, or delete files in GridFS.</p><p>As with any of the other command-line tools, run <code>mongofiles --help</code> to see the options available
      for <em>mongofiles</em>.</p><p>The following session shows how to use
      <em>mongofiles</em> to upload a file from the filesystem to
      GridFS, list all of the files in GridFS, and download a file that we’ve
      previously <span class="keep-together">uploaded</span>:</p><pre data-type="programlisting">$ echo "Hello, world" &gt; foo.tx
$ mongofiles put foo.txt 
2019-10-30T10:12:06.588+0000  connected to: localhost
2019-10-30T10:12:06.588+0000  added file: foo.txt
$  mongofiles list
2019-10-30T10:12:41.603+0000  connected to: localhost
foo.txt 13
$ rm foo.txt
$ mongofiles get foo.txt
2019-10-30T10:13:23.948+0000  connected to: localhost
2019-10-30T10:13:23.955+0000  finished writing to foo.txt
$ cat foo.txt
Hello, world</pre><p>In the previous example, we perform three basic operations using
      <em>mongofiles</em>: <code>put</code>,
      <code>list</code>, and <code>get</code>. The <code>put</code> operation takes a file in the filesystem
      and adds it to GridFS. <code>list</code> will list
      any files that have been added to GridFS. <code>get</code> does the inverse of <code>put</code>: it takes a file from GridFS and writes it
      to the filesystem. <em>mongofiles</em> also supports two
      other operations: <code>search</code> for finding
      files in GridFS by filename and <code>delete</code> for removing a file from GridFS.</p></div></section><section data-type="sect2" data-pdf-bookmark="Working with GridFS from the MongoDB Drivers"><div class="sect2" id="sect2_d1e7836"><h2>Working with GridFS from the MongoDB Drivers</h2><p>All<a data-type="indexterm" data-primary="GridFS" data-secondary="working with from MongoDB drivers" id="idm45882365617112"/> the client libraries have GridFS APIs. For example, with
      PyMongo<a data-type="indexterm" data-primary="PyMongo" id="idm45882365615784"/> (the Python driver for MongoDB) you can perform the same
      series of operations (this assumes Python 3 and a locally running
      <em>mongod</em> on port 27017) as we did with
      <em>mongofiles</em> as follows:</p><pre id="I_programlisting7_d1e8147" data-type="programlisting" data-code-language="python"><code class="o">&gt;&gt;&gt;</code> <code class="kn">import</code> <code class="nn">pymongo</code>
<code class="o">&gt;&gt;&gt;</code> <code class="kn">import</code> <code class="nn">gridfs</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">client</code> <code class="o">=</code> <code class="n">pymongo</code><code class="o">.</code><code class="n">MongoClient</code><code class="p">()</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">db</code> <code class="o">=</code> <code class="n">client</code><code class="o">.</code><code class="n">test</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">fs</code> <code class="o">=</code> <code class="n">gridfs</code><code class="o">.</code><code class="n">GridFS</code><code class="p">(</code><code class="n">db</code><code class="p">)</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">file_id</code> <code class="o">=</code> <code class="n">fs</code><code class="o">.</code><code class="n">put</code><code class="p">(</code><code class="s-Affix">b</code><code class="s2">"Hello, world"</code><code class="p">,</code> <code class="n">filename</code><code class="o">=</code><code class="s2">"foo.txt"</code><code class="p">)</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">fs</code><code class="o">.</code><code class="n">list</code><code class="p">()</code>
<code class="p">[</code><code class="s1">'foo.txt'</code><code class="p">]</code>
<code class="o">&gt;&gt;&gt;</code> <code class="n">fs</code><code class="o">.</code><code class="n">get</code><code class="p">(</code><code class="n">file_id</code><code class="p">)</code><code class="o">.</code><code class="n">read</code><code class="p">()</code>
<code class="s-Affix">b</code><code class="s1">'Hello, world'</code></pre><p>The API for working with GridFS from PyMongo is very similar to
      that of <em>mongofiles</em>: you can easily perform the
      basic <code>put</code>, <code>get</code>, and <code>list</code> operations. Almost all the <span class="keep-together">MongoDB</span> drivers follow this basic pattern
      for working with GridFS, while often exposing more advanced
      functionality as well. For driver-specific information on GridFS, please
      check out the documentation for the specific driver you’re using.</p></div></section><section data-type="sect2" data-pdf-bookmark="Under the Hood"><div class="sect2" id="sect2_d1e7858"><h2>Under the Hood</h2><p>GridFS<a data-type="indexterm" data-primary="GridFS" data-secondary="how it works" id="idm45882365358552"/> is a lightweight specification for storing files that is
      built on top of normal MongoDB documents. The MongoDB server actually
      does almost nothing to “special-case” the handling of GridFS requests;
      all the work is handled by the client-side drivers and tools.</p><p>The basic idea behind GridFS is that we can store large files by
      splitting them up into <em>chunks</em> and storing each
      chunk as a separate document. Because MongoDB supports storing binary
      data in documents, we can keep the storage overhead for chunks to a
      minimum. In addition to storing each chunk of a file, we store a single
      document that groups the chunks together and contains metadata about the
      file.</p><p>The chunks for GridFS are stored in their own collection. By
      default chunks will use the collection
      <em>fs.chunks</em>,<a data-type="indexterm" data-primary="fs.chunks collection" id="idm45882365355048"/> but this can be overridden. Within the chunks collection
      the structure of the individual documents is pretty simple:</p><pre id="I_programlisting7_d1e8194" data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
    <code class="s2">"_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>
    <code class="s2">"n"</code> <code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
    <code class="s2">"data"</code> <code class="o">:</code> <code class="nx">BinData</code><code class="p">(</code><code class="s2">"..."</code><code class="p">),</code>
    <code class="s2">"files_id"</code> <code class="o">:</code> <code class="nx">ObjectId</code><code class="p">(</code><code class="s2">"..."</code><code class="p">)</code>
<code class="p">}</code></pre><p>Like<a data-type="indexterm" data-primary="GridFS" data-secondary="keys in" id="idm45882365352488"/> any other MongoDB document, a chunk has its own unique
      <code>"_id"</code>. In addition, it has a couple
      of other keys:</p><dl><dt><code>"files_id"</code></dt><dd><p>The <code>"_id"</code> of the file
            document that contains the metadata for the file this chunk is
            from</p></dd><dt><code>"n"</code></dt><dd><p>The chunk’s position in the file, relative to the other
            chunks</p></dd><dt><code>"data"</code></dt><dd><p>The bytes in this chunk of the file</p></dd></dl><p>The<a data-type="indexterm" data-primary="GridFS" data-secondary="metadata location" id="idm45882365327672"/> metadata for each file is stored in a separate
      collection, which defaults to <em>fs.files</em>.<a data-type="indexterm" data-primary="fs.files collection" id="idm45882365326056"/> Each document in the files collection represents a single
      file in GridFS and can contain any custom metadata that should be
      associated with that file. In addition to any user-defined keys, there
      are a couple of keys that are mandated by the GridFS
      <span class="keep-together">specification</span>:</p><dl><dt><code>"_id"</code></dt><dd><p>A unique ID for the file—this is what will be stored in each
            chunk as the value for the <code>"files_id"</code> key.</p></dd><dt><code>"length"</code></dt><dd><p>The total number of bytes making up the content of the
            file.</p></dd><dt><code>"chunkSize"</code></dt><dd><p>The size of each chunk comprising the file, in bytes. The
            default is 255 KB, but this can be adjusted if needed.</p></dd><dt><code>"uploadDate"</code></dt><dd><p>A timestamp representing when this file was stored in
            GridFS.</p></dd><dt><code>"md5"</code></dt><dd><p>An MD5 checksum of this file’s contents, generated on the
            server side.</p></dd></dl><p>Of<a data-type="indexterm" data-primary="md5 key" id="idm45882365318584"/><a data-type="indexterm" data-primary="GridFS" data-secondary="md5 key" id="idm45882365317784"/> all the required keys, perhaps the most interesting (or
      least self-explanatory) is <code>"md5"</code>. The
      value for <code>"md5"</code> is generated by the
      MongoDB server using the <code>filemd5</code>
      command, which computes the MD5 checksum of the uploaded chunks. This
      means that users can check the value of the <code>"md5"</code> key to ensure that a file was uploaded
      <span class="keep-together">correctly</span>.</p><p>As mentioned previously, you are not limited to the required
      fields in <em class="filename">fs.files</em>: feel free to
      keep any other file metadata in this collection as well. You might want
      to keep information such as download count, MIME type, or user rating
      with a file’s metadata.</p><p>Once you understand the underlying GridFS specification, it
      becomes trivial to implement features that the driver you’re using might
      not provide helpers for. For example, you can use<a data-type="indexterm" data-primary="distinct command" id="idm45882365312184"/> the <code>distinct</code> command
      to get a list of unique filenames stored in GridFS:</p><pre id="I_programlisting7_d1e8305" data-type="programlisting" data-code-language="javascript"><code class="o">&gt;</code> <code class="nx">db</code><code class="p">.</code><code class="nx">fs</code><code class="p">.</code><code class="nx">files</code><code class="p">.</code><code class="nx">distinct</code><code class="p">(</code><code class="s2">"filename"</code><code class="p">)</code>
<code class="p">[</code> <code class="s2">"foo.txt"</code> <code class="p">,</code> <code class="s2">"bar.txt"</code> <code class="p">,</code> <code class="s2">"baz.txt"</code> <code class="p">]</code></pre><p>This allows your application a great deal of flexibility in
      loading and collecting information about files. We’ll change direction
      slightly in the next chapter, as we introduce the aggregation framework.
      It offers a range of data analytic tools to process the data in
      your<a data-type="indexterm" data-startref="FFstoring06" id="idm45882365265928"/><a data-type="indexterm" data-startref="Igrid06" id="idm45882365265192"/> database.</p></div></section></div></section></div></section></div>



  </body></html>