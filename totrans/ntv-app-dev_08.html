<html><head></head><body><section data-pdf-bookmark="Chapter 7. Persistence" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_databases">&#13;
<h1><span class="label">Chapter 7. </span>Persistence</h1>&#13;
&#13;
&#13;
<p>The persistence of data allows an app to form what might appear to be a memory. There are a number of ways to accomplish this within mobile software development, but the most common is through the use of<a data-primary="persistence" data-secondary="relational databases for" data-type="indexterm" id="idm46177229883272"/> a relational database. From the start Android and iOS have had the ability to connect, read, and write to databases.</p>&#13;
&#13;
<p>The result of this is that a user’s session within an app is no longer an ephemeral existence, but one that is anchored to a point in time. Data can be stored, information can be saved, and state can be restored. Through very different architectures and approaches, there is a shared set of functionality that powers both Android and iOS in a way that makes it similar enough to discuss side by side.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177229881144">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="persistence" data-secondary="task overview" data-type="indexterm" id="idm46177229879816"/> this chapter, you’ll learn to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Establish a database connection.</p>&#13;
</li>&#13;
<li>&#13;
<p>Create a database table or persistent object.</p>&#13;
</li>&#13;
<li>&#13;
<p>Write data to that table or persistent object.</p>&#13;
</li>&#13;
<li>&#13;
<p>Read data from that table or persistent object.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177229874488">&#13;
<h1>Android</h1>&#13;
&#13;
<p>In<a data-primary="persistence" data-secondary="Android" data-tertiary="SQLite" data-type="indexterm" id="idm46177229872920"/><a data-primary="Android" data-secondary="persistence" data-tertiary="SQLite" data-type="indexterm" id="idm46177229871640"/><a data-primary="SQLite" data-type="indexterm" id="idm46177229870424"/> Android, the framework-provided database management system is SQLite. The exact version depends on the Android OS level, but at the time of this writing it ranges from 3.4 in Android 1 to 3.19 in Android 27. See <a href="https://oreil.ly/lQegA">Android’s developer documentation</a> for up-to-date information.</p>&#13;
&#13;
<p>SQLite is a SQL-based relational<a data-primary="database management system (DBMS)" data-type="indexterm" id="idm46177229868360"/> database management system (DBMS) and is very similar to MySQL and PostgreSQL. There are differences, in datatypes, functions, and implementation details for things like <code>ALTER TABLE</code>, but they’re still very similar, and if you’ve had experience with any SQL database, you’ll find yourself at home with SQLite in no time.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Establish a Database Connection" data-type="sect2"><div class="sect2" id="idm46177229866648">&#13;
<h2>Establish a Database Connection</h2>&#13;
&#13;
<p>In<a data-primary="persistence" data-secondary="Android" data-tertiary="establish database connections" data-type="indexterm" id="idm46177229864888"/><a data-primary="Android" data-secondary="persistence" data-tertiary="establish database connections" data-type="indexterm" id="idm46177229863592"/> Android (but not traditional Java), the primary class you’ll use is <code>SqliteOpenHelper</code>, but it is <code>abstract</code>, so <em>it must be a subclass</em>. Here’s<a data-primary="Java" data-secondary="persistence" data-tertiary="establish database connections" data-type="indexterm" id="idm46177229839112"/><a data-primary="Kotlin" data-secondary="persistence" data-tertiary="establish database connections" data-type="indexterm" id="idm46177229837992"/> a stripped-down example:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177229836648">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">DbHelper</code> <code class="kd">extends</code> <code class="n">SQLiteOpenHelper</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">DbHelper</code><code class="o">(</code><code class="n">Context</code> <code class="n">context</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kd">super</code><code class="o">(</code><code class="n">context</code><code class="o">,</code> <code class="s">"db"</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="mi">1</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">SQLiteDatabase</code> <code class="n">sqLiteDatabase</code><code class="o">)</code> <code class="o">{</code>&#13;
   <code class="c1">// no op for now</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onUpgrade</code><code class="o">(</code><code class="n">SQLiteDatabase</code> <code class="n">sqLiteDatabase</code><code class="o">,</code> <code class="kt">int</code> <code class="n">i</code><code class="o">,</code> <code class="kt">int</code> <code class="n">i1</code><code class="o">)</code> <code class="o">{</code>&#13;
   <code class="c1">// no op for now</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">DbHelper</code><code class="p">(</code><code class="n">context</code><code class="p">:</code> <code class="n">Context</code><code class="p">)</code> <code class="p">:</code> <code class="n">SQLiteOpenHelper</code><code class="p">(</code><code class="n">context</code><code class="p">,</code> <code class="s">"db"</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="m">1</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">sqLiteDatabase</code><code class="p">:</code> <code class="n">SQLiteDatabase</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// no op for now</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onUpgrade</code><code class="p">(</code><code class="n">sqLiteDatabase</code><code class="p">:</code> <code class="n">SQLiteDatabase</code><code class="p">,</code> <code class="n">i</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">i1</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// no op for now</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>The<a data-primary="Android commands and methods" data-secondary="onUpgrade" data-type="indexterm" id="idm46177229754968"/> <code>onUpgrade</code> method is useful for adding or migrating data when changes are made to your database schema. This happens when the version number of your database (the fourth argument of the helper constructor) has changed and runs only once per change. Really we should say “increased” rather than “changed” because running a lower DB version than exists on a device will crash immediately.</p>&#13;
&#13;
<p>Note that convention is to use public constants for table and column names; that’ll make things easier when reading or writing data from the table in other classes.</p>&#13;
&#13;
<p>To<a data-primary="Android commands and methods" data-secondary="getWritableData base" data-type="indexterm" id="idm46177229686840"/><a data-primary="Android commands and methods" data-secondary="getReadableDatabase" data-type="indexterm" id="idm46177229685864"/> get a database instance from this helper class, we call either the <code>getWritableDatabase</code> or <code>getReadableDatabase</code> method, depending on what we need. The writable does everything the readable does, so if you plan on doing both reads and writes, use the former. The only time you’d want the readable version is to make sure that the underlying data does not get changed when performing operations.</p>&#13;
&#13;
<p>Here’s how you’d get a writable database instance from your helper class:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177229683144">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">SQLiteDatabase</code> <code class="n">database</code> <code class="o">=</code> <code class="k">new</code> <code class="n">DbHelper</code><code class="o">(</code><code class="k">this</code><code class="o">).</code><code class="na">getWritableDatabase</code><code class="o">();</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">database</code> <code class="p">=</code> <code class="n">DbHelper</code><code class="p">(</code><code class="k">this</code><code class="p">).</code><code class="n">getWritableDatabase</code><code class="p">()</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>From that point on, you’ve got access to a <code>SqliteDatabase</code> instance, which has APIs for common operations like querying and inserting, and broader APIs for executing arbitrary SQL strings, like <code>execSql</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Create a Database Table or Persistent Object" data-type="sect2"><div class="sect2" id="idm46177229661592">&#13;
<h2>Create a Database Table or Persistent Object</h2>&#13;
&#13;
<p>In<a data-primary="persistence" data-secondary="Android" data-tertiary="creating database tables or objects" data-type="indexterm" id="idm46177229660136"/><a data-primary="Android" data-secondary="persistence" data-tertiary="creating database tables or objects" data-type="indexterm" id="idm46177229658888"/> the subclass, you’ll have an opportunity to<a data-primary="Android commands and methods" data-secondary="onCreate" data-type="indexterm" id="idm46177229657512"/><a data-primary="Android commands and methods" data-secondary="onUpgrade" data-type="indexterm" id="idm46177229656600"/> override <code>onCreate</code> and <code>onUpgrade</code> methods; let’s concentrate on just the former for now, which will be fired once, when the helper is first created (generally speaking, this will happen the first time the helper is instantiated, and it is a persistent value, so this will happen shortly after the first installation of the app). Subsequent launches will not trigger <code>onCreate</code>.</p>&#13;
&#13;
<p><code>onCreate</code> is a great opportunity to create your initial schema. For example, let’s say we want to create a database with a single table (for now), <code>USAGE_EVENTS</code>, which has an identifier, an event name, and a timestamp when the event occurred. We’ll use standard SQL to create the database in our helper’s <code>onCreate</code> method; let’s extend the simple example shown earlier, but really we’re just adding some <code>String</code> constants to compose a SQL <code>create table</code> statement and<a data-primary="Java" data-secondary="persistence" data-tertiary="creating database tables or objects" data-type="indexterm" id="idm46177229593304"/><a data-primary="Kotlin" data-secondary="persistence" data-tertiary="creating database tables or objects" data-type="indexterm" id="idm46177229592056"/> execute it <code>onCreate</code>:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177229590328">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">private</code> <code class="kd">class</code> <code class="nc">DbHelper</code> <code class="kd">extends</code> <code class="n">SQLiteOpenHelper</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">TABLE_NAME</code> <code class="o">=</code> <code class="s">"EVENTS"</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">COLUMN_ID</code> <code class="o">=</code> <code class="s">"ID"</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">COLUMN_NAME</code> <code class="o">=</code> <code class="s">"NAME"</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">COLUMN_TIMESTAMP</code> <code class="o">=</code> <code class="s">"TIMESTAMP"</code><code class="o">;</code>&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="kd">final</code> <code class="n">String</code> <code class="n">CREATE_TABLE</code> <code class="o">=</code> <code class="s">"CREATE TABLE IF NOT EXISTS "</code> <code class="o">+</code>&#13;
      <code class="n">TABLE_NAME</code> <code class="o">+</code> <code class="s">" ("</code> <code class="o">+</code>&#13;
      <code class="n">COLUMN_ID</code> <code class="o">+</code> <code class="s">" STRING PRIMARY KEY, "</code> <code class="o">+</code>&#13;
      <code class="n">COLUMN_NAME</code> <code class="o">+</code> <code class="s">" STRING, "</code> <code class="o">+</code>&#13;
      <code class="n">COLUMN_TIMESTAMP</code> <code class="o">+</code> <code class="s">" INTEGER);"</code><code class="o">;</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">DbHelper</code><code class="o">(</code><code class="n">Context</code> <code class="n">context</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kd">super</code><code class="o">(</code><code class="n">context</code><code class="o">,</code> <code class="s">"db"</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="mi">1</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">SQLiteDatabase</code> <code class="n">sqLiteDatabase</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">sqLiteDatabase</code><code class="o">.</code><code class="na">execSQL</code><code class="o">(</code><code class="n">CREATE_TABLE</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onUpgrade</code><code class="o">(</code><code class="n">SQLiteDatabase</code> <code class="n">sqLiteDatabase</code><code class="o">,</code> <code class="kt">int</code> <code class="n">i</code><code class="o">,</code> <code class="kt">int</code> <code class="n">i1</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="c1">// no op for now</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">private</code> <code class="k">class</code> <code class="nc">DbHelper</code><code class="p">(</code><code class="n">context</code><code class="p">:</code> <code class="n">Context</code><code class="p">)</code> <code class="p">:</code> <code class="n">SQLiteOpenHelper</code><code class="p">(</code><code class="n">context</code><code class="p">,</code> <code class="s">"db"</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="m">1</code><code class="p">)</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">database</code><code class="p">:</code> <code class="n">SQLiteDatabase</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">database</code><code class="p">.</code><code class="n">execSQL</code><code class="p">(</code><code class="n">CREATE_TABLE</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onUpgrade</code><code class="p">(</code><code class="n">database</code><code class="p">:</code> <code class="n">SQLiteDatabase</code><code class="p">,</code> <code class="n">i</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">i1</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// no op for now</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="n">companion</code> <code class="k">object</code> <code class="err">{</code>&#13;
&#13;
    <code class="n">const</code> <code class="k">val</code> <code class="py">TABLE_NAME</code> <code class="p">=</code> <code class="s">"EVENTS"</code>&#13;
    <code class="n">const</code> <code class="k">val</code> <code class="py">COLUMN_ID</code> <code class="p">=</code> <code class="s">"ID"</code>&#13;
    <code class="n">const</code> <code class="k">val</code> <code class="py">COLUMN_NAME</code> <code class="p">=</code> <code class="s">"NAME"</code>&#13;
    <code class="n">const</code> <code class="k">val</code> <code class="py">COLUMN_TIMESTAMP</code> <code class="p">=</code> <code class="s">"TIMESTAMP"</code>&#13;
    <code class="n">const</code> <code class="k">val</code> <code class="py">CREATE_TABLE</code> <code class="p">=</code> <code class="s">"CREATE TABLE IF NOT EXISTS "</code> <code class="p">+</code>&#13;
        <code class="n">TABLE_NAME</code> <code class="p">+</code> <code class="s">" ("</code> <code class="p">+</code>&#13;
        <code class="n">COLUMN_ID</code> <code class="p">+</code> <code class="s">" STRING PRIMARY KEY, "</code> <code class="p">+</code>&#13;
        <code class="n">COLUMN_NAME</code> <code class="p">+</code> <code class="s">" STRING, "</code> <code class="p">+</code>&#13;
        <code class="n">COLUMN_TIMESTAMP</code> <code class="p">+</code> <code class="s">" INTEGER);"</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Write Data to That Table or Persistent Object" data-type="sect2"><div class="sect2" id="idm46177229447640">&#13;
<h2>Write Data to That Table or Persistent Object</h2>&#13;
&#13;
<p>The<a data-primary="persistence" data-secondary="Android" data-tertiary="writing data" data-type="indexterm" id="idm46177229446280"/><a data-primary="Android" data-secondary="persistence" data-tertiary="writing data" data-type="indexterm" id="idm46177229276216"/> framework provides<a data-primary="SQLite" data-type="indexterm" id="idm46177229274872"/> the <code>SQLiteDatabase</code> API, which as we’ve already seen is perfectly capable of executing arbitrary SQL commands, but also provides methods for CRUD functions, including insertion. Further, the API supports database transactions, which we can leverage for extra control of database writes. In the following simple example, it may appear that the transaction isn’t doing much for us, but in reality it will catch errors and give us an opportunity to react to them; further, and perhaps more critically, if the insert operation fails—or if we add more database operations in the <code>try</code> block that fail—the transaction would <em>not</em> be set to successful and would silently roll back the entire block of statements in the <code>try</code> portion.</p>&#13;
&#13;
<p>While this example does appear simple, it demonstrates the pattern that you’ll probably want to use for any or all of your database transactions—just add more operations to the <code>try</code> block, and do anything extra in the <code>catch</code> block. (Remember, throwing an <code>Exception</code> will cause the transaction to roll back implicitly; there is no explicit “roll back” method.) This pattern is appropriate<a data-primary="Java" data-secondary="persistence" data-tertiary="writing data" data-type="indexterm" id="idm46177229269720"/><a data-primary="Kotlin" data-secondary="persistence" data-tertiary="writing data" data-type="indexterm" id="idm46177229268472"/> for much more complicated modifying operations:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177229266936">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">ContentValues</code> <code class="n">contentValues</code> <code class="o">=</code> <code class="k">new</code> <code class="n">ContentValues</code><code class="o">();</code>&#13;
<code class="n">contentValues</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="n">DbHelper</code><code class="o">.</code><code class="na">COLUMN_ID</code><code class="o">,</code> <code class="n">UUID</code><code class="o">.</code><code class="na">randomUUID</code><code class="o">().</code><code class="na">toString</code><code class="o">());</code>&#13;
<code class="n">contentValues</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="n">DbHelper</code><code class="o">.</code><code class="na">COLUMN_NAME</code><code class="o">,</code> <code class="s">"Request Data"</code><code class="o">);</code>&#13;
<code class="n">contentValues</code><code class="o">.</code><code class="na">put</code><code class="o">(</code><code class="n">DbHelper</code><code class="o">.</code><code class="na">COLUMN_TIMESTAMP</code><code class="o">,</code> <code class="n">System</code><code class="o">.</code><code class="na">currentTimeMillis</code><code class="o">());</code>&#13;
<code class="n">SQLiteDatabase</code> <code class="n">database</code> <code class="o">=</code> <code class="n">getDatabase</code><code class="o">();</code>&#13;
<code class="n">database</code><code class="o">.</code><code class="na">beginTransaction</code><code class="o">();</code>&#13;
<code class="k">try</code> <code class="o">{</code>&#13;
  <code class="n">database</code><code class="o">.</code><code class="na">insert</code><code class="o">(</code><code class="n">DbHelper</code><code class="o">.</code><code class="na">TABLE_NAME</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="n">contentValues</code><code class="o">);</code>&#13;
  <code class="n">database</code><code class="o">.</code><code class="na">setTransactionSuccessful</code><code class="o">();</code>&#13;
  <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"wrote data to database"</code><code class="o">);</code>&#13;
<code class="o">}</code> <code class="k">catch</code> <code class="o">(</code><code class="n">Exception</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code>&#13;
  <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"there was a problem inserting data: "</code> <code class="o">+</code> <code class="n">e</code><code class="o">.</code><code class="na">getMessage</code><code class="o">());</code>&#13;
<code class="o">}</code> <code class="k">finally</code> <code class="o">{</code>&#13;
  <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"finally"</code><code class="o">);</code>&#13;
  <code class="n">database</code><code class="o">.</code><code class="na">endTransaction</code><code class="o">();</code>&#13;
  <code class="n">database</code><code class="o">.</code><code class="na">close</code><code class="o">();</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">contentValues</code> <code class="p">=</code> <code class="n">ContentValues</code><code class="p">()</code>&#13;
<code class="n">contentValues</code><code class="p">.</code><code class="n">put</code><code class="p">(</code><code class="n">COLUMN_ID</code><code class="p">,</code> <code class="n">UUID</code><code class="p">.</code><code class="n">randomUUID</code><code class="p">().</code><code class="n">toString</code><code class="p">())</code>&#13;
<code class="n">contentValues</code><code class="p">.</code><code class="n">put</code><code class="p">(</code><code class="n">COLUMN_NAME</code><code class="p">,</code> <code class="s">"Request Data"</code><code class="p">)</code>&#13;
<code class="n">contentValues</code><code class="p">.</code><code class="n">put</code><code class="p">(</code><code class="n">COLUMN_TIMESTAMP</code><code class="p">,</code> <code class="n">System</code><code class="p">.</code><code class="n">currentTimeMillis</code><code class="p">())</code>&#13;
<code class="n">writableDatabase</code><code class="p">.</code><code class="n">beginTransaction</code><code class="p">()</code>&#13;
<code class="k">try</code> <code class="p">{</code>&#13;
  <code class="n">writableDatabase</code><code class="p">.</code><code class="n">insert</code><code class="p">(</code><code class="n">DbHelper</code><code class="p">.</code><code class="n">TABLE_NAME</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="n">contentValues</code><code class="p">)</code>&#13;
  <code class="n">writableDatabase</code><code class="p">.</code><code class="n">setTransactionSuccessful</code><code class="p">()</code>&#13;
  <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"wrote data to database"</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"there was a problem inserting data: "</code> <code class="p">+</code> <code class="n">e</code><code class="p">.</code><code class="n">message</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>&#13;
  <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"finally"</code><code class="p">)</code>&#13;
  <code class="n">writableDatabase</code><code class="p">.</code><code class="n">endTransaction</code><code class="p">()</code>&#13;
  <code class="n">writableDatabase</code><code class="p">.</code><code class="n">close</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Read Data from That Table or Persistent Object" data-type="sect2"><div class="sect2" id="idm46177229120232">&#13;
<h2>Read Data from That Table or Persistent Object</h2>&#13;
&#13;
<p>The<a data-primary="persistence" data-secondary="Android" data-tertiary="reading data" data-type="indexterm" id="idm46177228932776"/><a data-primary="Android" data-secondary="persistence" data-tertiary="reading data" data-type="indexterm" id="idm46177228931640"/> <code>SqliteDatabase</code> method <code>query</code> is the most direct way to get information back out of your database. That said, the signature you’ll probably want to use takes eight parameters! Let’s pretend everything is fine and dive right in.</p>&#13;
&#13;
<p>Here’s the most basic version (with only seven parameters!). This will grab everything from the table—all rows populated with all columns—and return a <code>Cursor</code> instance to navigate that data set. This<a data-primary="Java" data-secondary="persistence" data-tertiary="reading data" data-type="indexterm" id="idm46177228928200"/><a data-primary="Kotlin" data-secondary="persistence" data-tertiary="reading data" data-type="indexterm" id="idm46177228926952"/> is effectively <code>"SELECT * FROM EVENTS"</code>:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177228925064">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">SqliteDatabase</code> <code class="n">database</code> <code class="o">=</code> <code class="k">new</code> <code class="n">DbHelper</code><code class="o">(</code><code class="k">this</code><code class="o">).</code><code class="na">getWritableDatabase</code><code class="o">();</code>&#13;
<code class="n">database</code><code class="o">.</code><code class="na">query</code><code class="o">(</code><code class="n">DbHelper</code><code class="o">.</code><code class="na">TABLE_NAME</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">database</code> <code class="p">=</code> <code class="n">DbHelper</code><code class="p">(</code><code class="k">this</code><code class="p">).</code><code class="n">getWritableDatabase</code><code class="p">()</code>&#13;
<code class="n">database</code><code class="p">.</code><code class="n">query</code><code class="p">(</code><code class="n">DbHelper</code><code class="p">.</code><code class="n">TABLE_NAME</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">);</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Let’s take a look inside, with a more realistic query:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177228804552">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">SqliteDatabase</code> <code class="n">database</code> <code class="o">=</code> <code class="k">new</code> <code class="n">DbHelper</code><code class="o">(</code><code class="k">this</code><code class="o">).</code><code class="na">getWritableDatabase</code><code class="o">();</code>&#13;
<code class="n">database</code><code class="o">.</code><code class="na">query</code><code class="o">(</code>&#13;
  <code class="n">DbHelper</code><code class="o">.</code><code class="na">TABLE_NAME</code><code class="o">,</code> <code class="c1">// String name of the table query</code>&#13;
  <code class="k">new</code> <code class="n">String</code><code class="o">[]</code> <code class="o">{</code> <code class="n">DbHelper</code><code class="o">.</code><code class="na">COLUMN_ID</code> <code class="o">},</code>  <code class="c1">// String array of columns</code>&#13;
  <code class="n">DbHelper</code><code class="o">.</code><code class="na">COLUMN_NAME</code> <code class="o">+</code> <code class="s">" = ?"</code><code class="o">,</code>  <code class="c1">// String WHERE clause</code>&#13;
  <code class="k">new</code> <code class="n">String</code><code class="o">[]</code> <code class="o">{</code> <code class="s">"Request Data"</code> <code class="o">},</code>  <code class="c1">// String array of WHERE values</code>&#13;
  <code class="kc">null</code><code class="o">,</code> <code class="c1">// GROUP BY</code>&#13;
  <code class="kc">null</code><code class="o">,</code> <code class="c1">// HAVING</code>&#13;
  <code class="kc">null</code><code class="o">,</code> <code class="c1">// ORDER BY</code>&#13;
  <code class="s">"1"</code> <code class="c1">// String LIMIT</code>&#13;
<code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">database</code> <code class="p">=</code> <code class="n">DbHelper</code><code class="p">(</code><code class="n">context</code><code class="p">).</code><code class="n">writableDatabase</code>&#13;
<code class="n">database</code><code class="p">.</code><code class="n">query</code><code class="p">(</code>&#13;
    <code class="n">DbHelper</code><code class="p">.</code><code class="n">TABLE_NAME</code><code class="p">,</code> <code class="c1">// String name of the table query</code>&#13;
    <code class="n">arrayOf</code><code class="p">(</code><code class="n">DbHelper</code><code class="p">.</code><code class="n">COLUMN_ID</code><code class="p">),</code> <code class="c1">// String array of columns</code>&#13;
    <code class="n">DbHelper</code><code class="p">.</code><code class="n">COLUMN_NAME</code> <code class="p">+</code> <code class="s">" = ?"</code><code class="p">,</code> <code class="c1">// String WHERE clause</code>&#13;
    <code class="n">arrayOf</code><code class="p">(</code><code class="s">"Request Data"</code><code class="p">),</code> <code class="c1">// String array of WHERE values</code>&#13;
    <code class="k">null</code><code class="p">,</code> <code class="c1">// GROUP BY</code>&#13;
    <code class="k">null</code><code class="p">,</code> <code class="c1">// HAVING</code>&#13;
    <code class="k">null</code><code class="p">,</code> <code class="c1">// ORDER BY</code>&#13;
    <code class="s">"1"</code> <code class="c1">// String LIMIT</code>&#13;
<code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>The preceding is effectively <code>SELECT ID FROM EVENTS WHERE NAME = \"Request Data\" LIMIT 1</code> in most SQL flavors. The placeholders are a common concept and can help with constancy and provide some recognition of SQL injection.</p>&#13;
&#13;
<p>So now that we’ve successfully executed our query, where’s our data? It’s in an in-memory dataset we can access with the <code>Cursor</code> API; the <code>query</code> method returns a <code><span class="keep-together">Cursor</span></code> instance. Here’s an example:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177228629288">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">Cursor</code> <code class="n">cursor</code> <code class="o">=</code> <code class="n">database</code><code class="o">.</code><code class="na">query</code><code class="o">(</code><code class="n">DbHelper</code><code class="o">.</code><code class="na">TABLE_NAME</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code> <code class="kc">null</code><code class="o">,</code>&#13;
  <code class="kc">null</code><code class="o">);</code>&#13;
<code class="k">while</code> <code class="o">(</code><code class="n">cursor</code><code class="o">.</code><code class="na">moveToNext</code><code class="o">())</code> <code class="o">{</code>&#13;
  <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"id: "</code> <code class="o">+</code> <code class="n">cursor</code><code class="o">.</code><code class="na">getString</code><code class="o">(</code><code class="mi">0</code><code class="o">));</code>&#13;
  <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"name: "</code> <code class="o">+</code> <code class="n">cursor</code><code class="o">.</code><code class="na">getString</code><code class="o">(</code><code class="mi">1</code><code class="o">));</code>&#13;
  <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"time: "</code> <code class="o">+</code> <code class="n">cursor</code><code class="o">.</code><code class="na">getLong</code><code class="o">(</code><code class="mi">2</code><code class="o">));</code>&#13;
<code class="o">}</code>&#13;
<code class="n">cursor</code><code class="o">.</code><code class="na">close</code><code class="o">();</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">cursor</code> <code class="p">=</code> <code class="n">database</code><code class="p">.</code><code class="n">query</code><code class="p">(</code><code class="n">DbHelper</code><code class="p">.</code><code class="n">TABLE_NAME</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code>&#13;
  <code class="k">null</code><code class="p">)</code>&#13;
<code class="k">while</code> <code class="p">(</code><code class="n">cursor</code><code class="p">.</code><code class="n">moveToNext</code><code class="p">())</code> <code class="p">{</code>&#13;
  <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"id: "</code> <code class="p">+</code> <code class="n">cursor</code><code class="p">.</code><code class="n">getString</code><code class="p">(</code><code class="m">0</code><code class="p">))</code>&#13;
  <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"name: "</code> <code class="p">+</code> <code class="n">cursor</code><code class="p">.</code><code class="n">getString</code><code class="p">(</code><code class="m">1</code><code class="p">))</code>&#13;
  <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"time: "</code> <code class="p">+</code> <code class="n">cursor</code><code class="p">.</code><code class="n">getLong</code><code class="p">(</code><code class="m">2</code><code class="p">))</code>&#13;
<code class="p">}</code>&#13;
<code class="n">cursor</code><code class="p">.</code><code class="n">close</code><code class="p">()</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>You can see we used the cursor to access each column by its index, but there’s a <code>Cursor</code> method to look up that index by name as well, <code>getColumnByIndex</code>, so you might do something like:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177228515512">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">cursor</code><code class="o">.</code><code class="na">getString</code><code class="o">(</code><code class="n">cursor</code><code class="o">.</code><code class="na">getColumnByIndex</code><code class="o">(</code><code class="n">DbHelper</code><code class="o">.</code><code class="na">COLUMN_ID</code><code class="o">));</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">cursor</code><code class="p">.</code><code class="n">getString</code><code class="p">(</code><code class="n">cursor</code><code class="p">.</code><code class="n">getColumnByIndex</code><code class="p">(</code><code class="n">DbHelper</code><code class="p">.</code><code class="n">COLUMN_ID</code><code class="p">))</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>That’s it! There are a ton of other APIs available<a data-primary="object-relational mapper (ORM)" data-type="indexterm" id="idm46177228327640"/> (and third-party object-relational mappers [ORM]) and really unlimited things you can do with raw SQL. If<a data-primary="Android commands and methods" data-secondary="compileStatement" data-type="indexterm" id="idm46177228326776"/> you’re working on an application that regularly uses database reads, you should check out the <code>compileStatement</code> method, which compiles a SQL string and allows you to redefine the values with each invocation. This method is extremely fast and can really improve perceived performance if working with large data sets.</p>&#13;
&#13;
<p>At the time of this writing, Google recommended we use Room (from the <a href="https://oreil.ly/rtG9C">Android dev docs</a>):</p>&#13;
<blockquote>&#13;
<p>Although<a data-primary="Room Persistence Library" data-type="indexterm" id="idm46177228323128"/> these APIs (SQLiteDatabase, etc.) are powerful, they are fairly low-level and require a great deal of time and effort to use:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>There is no compile-time verification of raw SQL queries. As your data graph changes, you need to update the affected SQL queries manually. This process can be time consuming and error prone.</p>&#13;
</li>&#13;
<li>&#13;
<p>You need to use lots of boilerplate code to convert between SQL queries and data objects.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For these reasons, we highly recommended using the Room Persistence Library as an abstraction layer for accessing information in your app’s SQLite databases.</p></blockquote>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why SQLite? Why not room? Why not realm? Why not &lt;insert my favorite ORM here&gt;?" data-type="sect3"><div class="sect3" id="idm46177228318968">&#13;
<h3>Why SQLite? Why not room? Why not realm? Why not &lt;insert my favorite ORM here&gt;?</h3>&#13;
&#13;
<p>We<a data-primary="persistence" data-secondary="Android" data-tertiary="database selection" data-type="indexterm" id="idm46177228317704"/><a data-primary="Android" data-secondary="persistence" data-tertiary="database selection" data-type="indexterm" id="idm46177228365688"/> (the authors) have used SQLite as our working example for a couple reasons: first, and as with other patterns and toolsets in the Android ecosystem, this predates Room by some distance. Second, SQL is something that developers coming from virtually any language are likely to have some knowledge of and will be able to carry between platforms.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177229119640">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>The<a data-primary="Core Data" data-secondary="benefits of" data-type="indexterm" id="idm46177228362312"/><a data-primary="persistence" data-secondary="iOS" data-tertiary="Core Data" data-type="indexterm" id="idm46177228361304"/><a data-primary="iOS" data-secondary="persistence" data-tertiary="Core Data" data-type="indexterm" id="idm46177228360088"/> primary difference in persistence of data between iOS and Android is related to the technology used. In Android, as you’ve seen, a SQLite database is a common approach, and there are classes and objects that interact directly with the database through database connections and SQL. Now iOS, on the other hand, abstracts the database layer technology away from the developer and has a first-party object graph that’s used for data persistence called Core Data. Although Core Data <em>can</em> use a SQLite database (and usually does) for persistence of data, it can operate wholly in-memory as transient storage or output to XML files. The database, then, becomes an implementation detail that the developer can, mostly, ignore.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Set Up and Connect to a Persistence Layer" data-type="sect2"><div class="sect2" id="idm46177228357480">&#13;
<h2>Set Up and Connect to a Persistence Layer</h2>&#13;
&#13;
<p>Even<a data-primary="persistence" data-secondary="iOS" data-tertiary="persistence layers" data-type="indexterm" id="idm46177228356184"/><a data-primary="iOS" data-secondary="persistence" data-tertiary="persistence layers" data-type="indexterm" id="idm46177228354904"/><a data-primary="Core Data" data-secondary="versus raw SQLite" data-secondary-sortas="raw SQLite" data-type="indexterm" id="idm46177228353688"/> though developers are supposed to forget about the differences between the object graph that is Core Data and a raw SQLite database, there are equivalences between the two that we’ll use to direct this chapter about data persistence to compare and contrast with Android. Establishing a database connection is <em>not</em> something you’ll need to do with Core Data; the raw SQL queries and connections are handled by Core Data itself. An equivalent part of setup, however, is spinning up the Core Data “stack.”</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Set up Core Data stack" data-type="sect3"><div class="sect3" id="idm46177228273352">&#13;
<h3>Set up Core Data stack</h3>&#13;
&#13;
<p>Getting<a data-primary="Core Data" data-secondary="Core Data stack setup" data-type="indexterm" id="idm46177228271784"/> started with Core Data in a new or existing project isn’t too hard, but you first need to understand what, exactly, Core Data is. Let’s start with the persistence layer. For our purposes, we’ll assume that we’re dealing with a Core Data stack that has, at its root, a SQLite database. This is, arguably, the most common approach to Core Data development.</p>&#13;
&#13;
<p>Above<a data-primary="Core Data" data-secondary="NSPersistent StoreCoordinator" data-type="indexterm" id="idm46177228269912"/> the SQLite database and persistent store is an object called an <code>NSPersistentStoreCoordinator</code>. This object handles the communication between the database, the managed object model, and the managed object context. It uses the managed object model that’s defined with the different model object and translates those objects and relationships into database tables and SQL. It also optimizes a lot of the objects delivered and is really the “brains” behind a lot of the magic and optimization built into Core Data. You could think of it as a traffic coordinator between SQLite and the rest of the app.</p>&#13;
&#13;
<p>A<a data-primary="Core Data" data-secondary="NSManagedObjectModel" data-type="indexterm" id="idm46177228267288"/> managed object model, or <code>NSManagedObjectModel</code>, is defined with every project with an <em>.xcdatamodeld</em> file. This is what the persistent store coordinator uses to determine how everything is structured. It is a file that a developer uses to add new entities, relationship, and properties; it’s how the data model is, essentially, created and defined in a project. The objects that are created as part of this are called “managed objects,” and they inherit<a data-primary="Core Data" data-secondary="NSManagedObject" data-type="indexterm" id="idm46177228264920"/> from <code>NSManagedObject</code>, which is part of the Core Data framework. Most of the work involved in maintaining and working with Core Data is done at this level, along with the next class we need to discuss: the managed object context.</p>&#13;
&#13;
<p>You<a data-primary="Core Data" data-secondary="NSManagedObjectContext" data-type="indexterm" id="idm46177228262696"/> can think of a managed object context, or <code>NSManagedObjectContext</code>, as a scratchpad of sorts where you can change data contained in instances of your data model objects before they’re persisted in the database. A managed object context is the object you’ll use to provide context to Core Data for how your object should be created and updated. There are typically two types of contexts in a Core Data application, the view context (which operates on the main thread) and a background, or private, context that’s used for saving objects—effectively translating them from <code>NSManagedObject</code> instances to database table row <code>INSERT</code> and <code>UPDATE</code> commands.</p>&#13;
&#13;
<p>In<a data-primary="iOS methods" data-secondary="application(_:didFinishLaunchingWithOptions:)" data-type="indexterm" id="idm46177228259016"/> order to work with Core Data, this stack must be set up and functional before persistence is needed. Typically, this means when the application starts. In fact, most setup is done in the <code>application(_:didFinishLaunchingWithOptions:)</code> method inside the application delegate.</p>&#13;
&#13;
<p>All<a data-primary="Core Data" data-secondary="NSPersistentContainer" data-type="indexterm" id="idm46177228256712"/> this setup used to be cumbersome, but Core Data now has a handy class for initializing our Core Data stack called <code>NSPersistentContainer</code>. The persistent container handles the initialization required for a managed object model file and has a convenience method that can load persistent stores asynchronously. Here’s an example of how it’s used:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">persistentContainer</code> <code class="p">=</code> <code class="n">NSPersistentContainer</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"MyModel"</code><code class="p">)</code>&#13;
<code class="n">persistentContainer</code><code class="p">.</code><code class="n">loadPersistentStores</code> <code class="p">{</code> <code class="p">(</code><code class="n">description</code><code class="p">,</code> <code class="n">error</code><code class="p">)</code> <code class="k">in</code>&#13;
    <code class="c1">// Completion handler</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This creates a container targeting a managed object model named “MyModel” and stores it in a variable named <code>persistentContainer</code>. The next line loads the persistent store, ultimately the SQLite database in our example, from the disk with a completion handler to check for any errors and execute code afterward. If you place this code in the application delegate’s startup code, the application will look for the managed object model file <em>MyModel.xcdatamodeld</em> in the application bundle and use that to create or load a SQLite database file named <em>MyModel.sqlite</em> in the <em>Application Support</em> directory.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You<a data-primary="Core Data" data-secondary="NSPersistentStoreDescription" data-type="indexterm" id="idm46177228227336"/> can customize the location where the database files are placed. Historically the <em>Documents</em> directory has been used as a place to store the SQLite database. Your needs will vary, but you can do this by adding an <code>NSPersistentStoreDescription</code> after creating the <code>NSPersistentContainer</code> and adding it to <code>persistentStoreDescriptions</code>. There are other options available used to describe the persistent container, but those are outside the scope of this chapter.</p>&#13;
</div>&#13;
&#13;
<p>Inside the completion closure, you should check for errors and then update any user interface that might be waiting for the persistent store to load. An example of a more complete persistent container load might look like this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">persistentContainer</code> <code class="p">=</code> <code class="n">NSPersistentContainer</code><code class="p">(</code><code class="n">name</code><code class="p">:</code> <code class="s">"MyModel"</code><code class="p">)</code>&#13;
<code class="n">persistentContainer</code><code class="p">.</code><code class="n">loadPersistentStores</code> <code class="p">{</code> <code class="p">(</code><code class="n">description</code><code class="p">,</code> <code class="n">error</code><code class="p">)</code> <code class="k">in</code>&#13;
    <code class="k">guard</code> <code class="kd">let</code> <code class="nv">error</code> <code class="p">=</code> <code class="n">error</code> <code class="k">else</code> <code class="p">{</code>&#13;
        <code class="c1">// Display error to user and/or attempt to do this again</code>&#13;
        <code class="k">return</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="c1">// Update the user interface and/or start using Core Data</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now that our Core Data stack is up and running, let’s look at how we can define our objects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Define and Create a Database Table or Persistent Object" data-type="sect2"><div class="sect2" id="idm46177228272760">&#13;
<h2>Define and Create a Database Table or Persistent Object</h2>&#13;
&#13;
<p>Our<a data-primary="persistence" data-secondary="iOS" data-tertiary="creating database tables or objects" data-type="indexterm" id="idm46177228152712"/><a data-primary="iOS" data-secondary="persistence" data-tertiary="creating database tables or objects" data-type="indexterm" id="idm46177228151496"/> model objects are defined in the managed object model file created in Xcode. To<a data-primary="Core Data" data-secondary="adding objects to existing projects" data-type="indexterm" id="idm46177228150184"/> add to an existing project, go to File &gt; New &gt; File and select Data Model under the Core Data section. The name of the file is the name you’ll pass to the persistent container during initialization.</p>&#13;
&#13;
<p>Inside Xcode, you can edit this file to create a new managed object by clicking the Add Entity button. Inside the entity description, there will be areas for Attributes, Relationships, and Fetched Properties. You can add individual properties to an entity, change the name of the entity, and assign a backing class to this entity all within this editor.</p>&#13;
&#13;
<p>The individual properties are added as Attributes. These correspond to raw data types like <code>String</code> and <code>Int</code> in Swift classes that are generated (or provided manually) for each entity in a managed object model. It’s important to remember that the managed object model only defines the description of the entities and doesn’t actually interact with the database at all. It just provides, essentially, a mapping from the Swift code that the persistent store coordinator can understand.</p>&#13;
&#13;
<p>To add a new attribute, click the “+” button underneath the Attributes area of the editor. If you were adding a new property named <code>title</code> with a type of <code>String</code> on an entity named <code>MyEntity</code>, Xcode would automatically generate a class for you during compilation that’s hidden from the Xcode project. The class might look like this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">import</code> <code class="nc">Foundation</code>&#13;
<code class="kd">import</code> <code class="nc">CoreData</code>&#13;
&#13;
<code class="kr">@objc</code><code class="p">(</code><code class="n">MyEntity</code><code class="p">)</code>&#13;
<code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyEntity</code><code class="p">:</code> <code class="bp">NSManagedObject</code> <code class="p">{</code>&#13;
&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">extension</code> <code class="nc">MyEntity</code> <code class="p">{</code>&#13;
&#13;
    <code class="p">@</code><code class="n">nonobjc</code> <code class="kd">public</code> <code class="kd">class</code> <code class="nc">func</code> <code class="n">fetchRequest</code><code class="p">()</code> <code class="p">-&gt;</code> <code class="bp">NSFetchRequest</code><code class="p">&lt;</code><code class="n">MyEntity</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
        <code class="k">return</code> <code class="bp">NSFetchRequest</code><code class="p">&lt;</code><code class="n">MyEntity</code><code class="p">&gt;(</code><code class="n">entityName</code><code class="p">:</code> <code class="s">"MyEntity"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">@NSManaged</code> <code class="kd">public</code> <code class="kd">var</code> <code class="nv">title</code><code class="p">:</code> <code class="nb">String</code><code class="p">?</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The class itself inherits from <code>NSManagedObject</code> and is the same name as our entity description of <code>MyEntity</code>. It could, however, be anything we’d like it to be. That’s an important distinction: the class that backs a model object can be named separately from the entity description. Also notice that the <code>@NSManaged</code> attribute denotes that<a data-primary="Core Data" data-secondary="@NSManaged attribute" data-type="indexterm" id="idm46177228077816"/> Core Data manages the storage of this property. That means this is not a normal property that’s stored. It is, in fact, backed by <code>setValue:</code> whenever the property is written to.</p>&#13;
&#13;
<p>This kind of flexibility allows us to add properties to managed objects that aren’t written to a database. Fundamentally, this means that we can do things like having a computed property that’s added as a convenience property for a managed object that doesn’t have to interact with the database at all. For example, we could define a managed object ourselves called <code>Person</code> that has <code>firstName</code> and <code>lastName</code> attributes stored in Core Data, but that offers a <code>fullName</code> property that just combines these properties without duplicating data in the database:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Person</code><code class="p">:</code> <code class="bp">NSManagedObject</code> <code class="p">{</code>&#13;
	<code class="kr">@NSManaged</code> <code class="kd">public</code> <code class="kd">var</code> <code class="nv">firstName</code><code class="p">:</code> <code class="nb">String</code>&#13;
	<code class="kr">@NSManaged</code> <code class="kd">public</code> <code class="kd">var</code> <code class="nv">lastName</code><code class="p">:</code> <code class="nb">String</code>&#13;
	<code class="kd">public</code> <code class="kd">var</code> <code class="nv">fullName</code><code class="p">:</code> <code class="nb">String</code> <code class="p">{</code>&#13;
		<code class="k">return</code> <code class="s">"</code><code class="si">\(</code><code class="n">firstName</code><code class="si">)</code><code class="s"> </code><code class="si">\(</code><code class="n">lastName</code><code class="si">)</code><code class="s">"</code>&#13;
	<code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Using our <code>Person</code> managed object as an example (after we’ve created a corresponding entity description in the managed object model), let’s continue to see how we can persist some data.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Write and Persist Data to SQLite" data-type="sect2"><div class="sect2" id="idm46177228153752">&#13;
<h2>Write and Persist Data to SQLite</h2>&#13;
&#13;
<p>The<a data-primary="persistence" data-secondary="iOS" data-tertiary="writing data to SQLite" data-type="indexterm" id="idm46177227990456"/><a data-primary="iOS" data-secondary="persistence" data-tertiary="writing data to SQLite" data-type="indexterm" id="idm46177227989176"/><a data-primary="SQLite" data-type="indexterm" id="idm46177227987960"/> first, and very important, thing to note about writing data in<a data-primary="Core Data" data-secondary="writing data in" data-type="indexterm" id="idm46177227987160"/> Core Data is that you <em>don’t</em> want to write on the main thread. There is, in fact, a handy convenience method in our persistent container to allow us to quickly and easily hop over to a background thread to write some data as shown here:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">persistentContainer</code><code class="p">.</code><code class="n">performBackgroundTask</code> <code class="p">{</code> <code class="p">(</code><code class="n">managedObjectContext</code><code class="p">)</code> <code class="k">in</code>&#13;
	<code class="c1">// Some operation...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, the operation being performed could be a read. It could also be a write. We’re going to focus on the write aspect of this for now. In fact, let’s look at our earlier <code><span class="keep-together">Person</span></code> managed object and see how we can create a new one and add it to the data store.</p>&#13;
&#13;
<p>When<a data-primary="Core Data" data-secondary="creating and updating objects in" data-type="indexterm" id="idm46177227925432"/> creating and updating objects in Core Data, all the operations first take place inside a managed object context. We can change the objects as much as we want in this context without it affecting the database until we explicitly save the changes. Because of this, we also need a context to create a new object. Here’s an example of how we can create a new <code>Person</code> instance and assign some properties to it:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">persistentContainer</code><code class="p">.</code><code class="n">performBackgroundTask</code> <code class="p">{</code> <code class="p">(</code><code class="n">managedObjectContext</code><code class="p">)</code> <code class="k">in</code>&#13;
    <code class="kd">let</code> <code class="nv">person</code> <code class="p">=</code> <code class="n">Person</code><code class="p">(</code><code class="n">context</code><code class="p">:</code> <code class="n">managedObjectContext</code><code class="p">)</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">firstName</code> <code class="p">=</code> <code class="s">"Mike"</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">lastName</code> <code class="p">=</code> <code class="s">"Dunn"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Really, it’s that simple. We’ve created a new <code>Person</code> named <code>person</code> inside the managed object context passed into our closure. Then, we’ve assigned values to <code>firstName</code> and <code>lastName</code>.</p>&#13;
&#13;
<p>This object is not persisted yet, however. In fact, this object will exist until that closure completes, and then it’ll be destroyed along with the managed object context. Luckily, persisting the data isn’t hard either. It’s just one line with some error checking in a <code>do</code> and <code>try</code> block, like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="n">persistentContainer</code><code class="p">.</code><code class="n">performBackgroundTask</code> <code class="p">{</code> <code class="p">(</code><code class="n">managedObjectContext</code><code class="p">)</code> <code class="k">in</code>&#13;
    <code class="kd">let</code> <code class="nv">person</code> <code class="p">=</code> <code class="n">Person</code><code class="p">(</code><code class="n">context</code><code class="p">:</code> <code class="n">managedObjectContext</code><code class="p">)</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">firstName</code> <code class="p">=</code> <code class="s">"Mike"</code>&#13;
    <code class="n">person</code><code class="p">.</code><code class="n">lastName</code> <code class="p">=</code> <code class="s">"Dunn"</code>&#13;
&#13;
    <code class="c1">// Save the context</code>&#13;
    <code class="k">do</code> <code class="p">{</code>&#13;
        <code class="k">try</code> <code class="n">managedObjectContext</code><code class="p">.</code><code class="n">save</code><code class="p">()</code>&#13;
    <code class="p">}</code> <code class="k">catch</code> <code class="p">{</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="s">"Error during save. </code><code class="si">\(</code><code class="n">error</code><code class="si">)</code><code class="s">"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You’ll notice that we only save the <em>context</em>, not the object itself. This operation saves all the changes that are inside that context. So, if we created a million <code>Person</code>s, all of them would be saved at the same time. If we created different object types and changed properties in others, they would all be persisted at the same time as well. The entirety of the context is saved instead of individual objects. This can lead to performance issues. So profiling and testing with large data sets is recommended to prevent things like that.</p>&#13;
&#13;
<p>In order to update an object, you only need to fetch it from Core Data within a managed object context, update the properties desired, and then save the context. Let’s look at how we can fetch and read data from our SQLite store that’s been saved.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Read Data from SQLite" data-type="sect2"><div class="sect2" id="idm46177227991496">&#13;
<h2>Read Data from SQLite</h2>&#13;
&#13;
<p>Although<a data-primary="persistence" data-secondary="iOS" data-tertiary="reading data from SQLite" data-type="indexterm" id="idm46177227817048"/><a data-primary="iOS" data-secondary="persistence" data-tertiary="reading data from SQLite" data-type="indexterm" id="idm46177227815800"/> the title of this section says “Read Data <em>from SQLite</em>,” we’re actually going to read data through the managed object context. If it <em>chooses</em> to head back out to the SQLite store, it’ll contact the persistent store coordinator for help. Using an <code><span class="keep-together">NSFetchRequest</span></code> as we show in a moment will cause a trip to the persistent store and may wind up being a very slow path. However, managed object contexts often have a lot of data cached in-memory for performance reasons, and the data that’s fetched can be utilized and operated on just like a normal object after the fetch occurs.</p>&#13;
&#13;
<p>In order to find an object, we have to create a fetch request and execute it against a managed object context like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">managedObjectContext</code> <code class="p">=</code> <code class="n">persistentContainer</code><code class="p">.</code><code class="n">viewContext</code>&#13;
<code class="kd">let</code> <code class="nv">fetchRequest</code> <code class="p">=</code> <code class="bp">NSFetchRequest</code><code class="p">&lt;</code><code class="n">Person</code><code class="p">&gt;(</code><code class="n">entityName</code><code class="p">:</code> <code class="s">"Person"</code><code class="p">)</code>&#13;
<code class="k">do</code> <code class="p">{</code>&#13;
	<code class="kd">let</code> <code class="nv">persons</code> <code class="p">=</code> <code class="k">try</code> <code class="n">managedObjectContext</code><code class="p">.</code><code class="n">fetch</code><code class="p">(</code><code class="n">fetchRequest</code><code class="p">)</code>&#13;
<code class="p">}</code> <code class="k">catch</code> <code class="p">{</code>&#13;
	<code class="bp">fatalError</code><code class="p">(</code><code class="s">"Fetch could not be completed."</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s walk through what’s happening here.</p>&#13;
&#13;
<p>First, we grab a read-only managed object context from the persistent container via the <code>viewContext</code> property. This allows us to view objects, but not save changes. Next, we create a fetch request with a type of <code>Person</code> for an entity in the managed object model named “Person.” After that, we use that fetch request to <code>fetch(_:)</code> from our managed object context. This call can <code>throw</code>, so it’s wrapped in a <code>do</code> and <code>catch</code> block. If the fetch can’t be completed, we throw a fatal error with the message, “Fetch could not be completed.”</p>&#13;
&#13;
<p>At this point, we should have a populated <code>persons</code> object we can use to iterate through to read a list of all the people we’ve persisted.</p>&#13;
&#13;
<p>There’s<a data-primary="Core Data" data-secondary="benefits of" data-type="indexterm" id="idm46177227729928"/> a lot more you can do with Core Data. It’s a very powerful tool in every iOS developer’s toolkit that can be utilized to create a performant and optimized object graph to make persisting data easy. Its largest downsides include a bit more verbose text and a lot of setup initially. However, some legwork in the beginning of a project could save you from having to write intricate and brittle SQL statements and instead get some compile-time checking of property names and values.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>When<a data-primary="Core Data" data-secondary="NSFetchedResultsController" data-type="indexterm" id="idm46177227727096"/> fetching results for table views, it’s possible to use an object named <code>NSFetchedResultsController</code> that takes the results and an <code>NSFetchRequest</code> and updates the table whenever the data changes automatically. This makes interacting with Core Data easier for things like <code>UITableView</code> and <code>UICollectionView</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177227724088">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>Android and iOS are similar in so many ways as you have seen—and will continue to see—throughout this book. However, this chapter really demonstrates that, at times, they could not be further apart.</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The raw SQLite interaction method of Android offers an architectural simplicity not present with Core Data on iOS that allows developers to jump in with knowledge they might already have with server-side languages.</p>&#13;
</li>&#13;
<li>&#13;
<p>Core Data is not a database. It is a complex object graph framework that is <em>extremely</em> powerful and decoupled from SQLite itself in a way that attempts to mask its complexity.</p>&#13;
</li>&#13;
<li>&#13;
<p>Both approaches allow for persistence of data and require a good deal of planning and maintenance within future versions of the apps.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Once you start talking about object persistence, the next logical step is concurrency, which just happens to be what the next chapter is about. Let’s queue up and head over right now!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>