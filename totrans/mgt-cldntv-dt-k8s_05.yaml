- en: Chapter 4\. Automating Database Deployment on Kubernetes with Helm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：使用 Helm 在 Kubernetes 上自动化数据库部署
- en: In the previous chapter, you learned how to deploy both single-node and multinode
    databases on Kubernetes by hand, creating one element at a time. We did things
    the “hard way” on purpose to help maximize your understanding of using Kubernetes
    primitives to set up the compute, network, and storage resources that a database
    requires. Of course, this doesn’t represent the experience of running databases
    in production on Kubernetes, for a couple of reasons.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你学习了如何通过手工方式在 Kubernetes 上部署单节点和多节点数据库，逐个元素地创建。我们故意采取了“硬核”的方式，以帮助你最大程度地理解如何使用
    Kubernetes 原语来设置数据库所需的计算、网络和存储资源。当然，这并不代表在 Kubernetes 上生产环境中运行数据库的体验，有几个原因。
- en: First, teams typically don’t deploy databases by hand, one YAML file at a time.
    That can get pretty tedious. And even combining the configurations into a single
    file could start to get pretty complicated, especially for more sophisticated
    deployments. Consider the increase in the amount of configuration required in
    [Chapter 3](ch03.html#databases_on_kubernetes_the_hard_way) for Cassandra as a
    multinode database compared with the single-node MySQL deployment. This won’t
    scale for large enterprises.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，团队通常不会逐个 YAML 文件手动部署数据库。这可能变得非常乏味。即使将配置合并到单个文件中，对于更复杂的部署，也可能变得非常复杂。考虑在[第三章](ch03.html#databases_on_kubernetes_the_hard_way)中为
    Cassandra 的多节点数据库部署所需的配置量的增加，与单节点 MySQL 部署相比。这对大型企业来说是不可扩展的。
- en: Second, while deploying a database is great, what about keeping it running over
    time? You need your data infrastructure to remain reliable and performant over
    the long haul, and data infrastructure is known for requiring a lot of care and
    feeding. Put another way, the task of running a system is often divided into “day
    one” (the joyous day when you deploy an application to production) and “day two”
    (every day after the first, when you need to operate and evolve your application
    while maintaining high availability).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，虽然部署数据库很棒，但如何确保其长期运行呢？您需要保证数据基础设施在长时间内保持可靠和高性能，而数据基础设施通常需要大量的维护和投入。换句话说，运行系统的任务通常分为“第一天”（将应用部署到生产环境的欣喜日子）和“第二天”（首次之后的每一天，需要操作和演进应用，同时保持高可用性）。
- en: These considerations around database deployment and operations mirror the larger
    industry trends toward DevOps, an approach in which development teams take a more
    active role in supporting applications in production. DevOps practices include
    the use of automation tools for CI/CD of applications, shortening the amount of
    time it takes for code to get from a developer’s desktop into production.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数据库部署和运维的这些考虑反映了朝向 DevOps 的更大行业趋势，即开发团队在支持生产中的应用方面发挥更积极的作用。DevOps 实践包括使用自动化工具进行应用的
    CI/CD，缩短代码从开发者桌面到生产环境的时间。
- en: In this chapter, we’ll look at tools that help standardize the deployment of
    databases and other applications. These tools take an infrastructure as code (IaC)
    approach, allowing you to represent software installation and configuration options
    in a format that can be executed automatically, reducing the overall amount of
    configuration code you have to write. We’ll also emphasize data infrastructure
    operations in these next two chapters and carry that theme throughout the remainder
    of the book.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍帮助标准化数据库和其他应用部署的工具。这些工具采用基础设施即代码（IaC）的方法，允许您以可自动执行的格式表示软件安装和配置选项，从而减少需要编写的整体配置代码量。在接下来的两章中，我们还将强调数据基础设施运营，并贯穿整本书的主题。
- en: Deploying Applications with Helm Charts
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm Charts 部署应用程序
- en: 'Let’s start by taking a look at a tool that helps you manage the complexity
    of managing configurations: [Helm](https://helm.sh). This package manager for
    Kubernetes is open source and a CNCF [graduated project](https://oreil.ly/cDjD3).
    The concept of a package manager is a common one across multiple programming languages,
    such as `pip` for Python, the Node Package Manager (NPM) for JavaScript, and Ruby’s
    Gems feature. Package managers for specific operating systems also exist, such
    as Apt for Linux, or Homebrew for macOS. As shown in [Figure 4-1](#helmcomma_a_package_manager_for_kuberne),
    the essential elements of a package manager system are the packages, the registries
    where the packages are stored, and the package manager application (or *client*),
    which helps the chart developers register charts and allows chart users to locate,
    install, and update packages on their local systems.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从看一个工具开始，这个工具有助于您管理管理配置的复杂性：[Helm](https://helm.sh)。这个 Kubernetes 的包管理器是开源的，也是
    CNCF 的一个[毕业项目](https://oreil.ly/cDjD3)。包管理器的概念在多种编程语言中是一个常见的概念，例如 Python 的 `pip`、JavaScript
    的 Node Package Manager (NPM) 和 Ruby 的 Gems 特性。特定操作系统的包管理器也存在，例如 Linux 的 Apt 或
    macOS 的 Homebrew。正如在[图 4-1](#helmcomma_a_package_manager_for_kuberne)中所示，包管理系统的基本要素包括包、存储包的注册表以及包管理应用程序（或*客户端*），它帮助
    chart 开发人员注册 charts 并允许 chart 用户在其本地系统上查找、安装和更新 packages。
- en: '![Helm, a package manager for Kubernetes](assets/mcdk_0401.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![Helm，Kubernetes 的包管理器](assets/mcdk_0401.png)'
- en: Figure 4-1\. Helm, a package manager for Kubernetes
  id: totrans-9
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. Helm，Kubernetes 的包管理器
- en: Helm extends the package management concept to Kubernetes, with some interesting
    differences. If you’ve worked with one of the package managers listed previously,
    you’ll be familiar with the idea that a package consists of a binary (executable
    code) as well as metadata describing the binary, such as its functionality, API,
    and installation instructions. In Helm, the packages are called *charts*. Charts
    describe how to build a Kubernetes application piece by piece by using the Kubernetes
    resources for compute, networking, and storage introduced in previous chapters,
    such as Pods, Services, and PersistentVolumeClaims. For compute workloads, the
    descriptions point to container images that reside in public or private container
    registries.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 将包管理的概念扩展到 Kubernetes，具有一些有趣的差异。如果您曾经使用过前面列出的某个包管理器，您将会对一个包由二进制文件（可执行代码）及描述该二进制文件的元数据（如其功能、API
    和安装说明）的概念感到熟悉。在 Helm 中，这些包称为*charts*。Charts 描述如何逐步构建 Kubernetes 应用程序，使用在前几章介绍的
    Kubernetes 资源（如 Pods、Services 和 PersistentVolumeClaims）片段化地，例如计算工作负载，描述指向驻留在公共或私有容器注册表中的容器映像的情况。
- en: Helm allows charts to reference other charts as dependencies, which provides
    a great way to compose applications by creating assemblies of charts. For example,
    you could define an application such as the WordPress/MySQL example from the previous
    chapter by defining a chart for your WordPress deployment that referenced a chart
    defining a MySQL deployment that you wish to reuse. Or, you might even find a
    Helm chart that defines an entire WordPress application including the database.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 允许 charts 引用其他 charts 作为依赖关系，这提供了一种通过创建 charts 的集合来组合应用程序的好方法。例如，您可以通过定义一个用于
    WordPress 部署的 chart，引用一个定义 MySQL 部署的 chart 来定义一个应用程序，您希望重用这些定义。或者，您甚至可以找到一个定义了整个
    WordPress 应用程序（包括数据库）的 Helm chart。
- en: Kubernetes Environment Prerequisites
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 环境先决条件
- en: 'The examples in this chapter assume you have access to a Kubernetes cluster
    with a couple of characteristics:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的示例假设您可以访问一个 Kubernetes 集群，并具有以下一些特征：
- en: The cluster should have at least three Worker Nodes, in order to demonstrate
    mechanisms Kubernetes provides to allow you to request Pods to be spread across
    a cluster. You can create a simple cluster on your desktop by using an open source
    distribution called kind. See the kind quick start guide for instructions on installing
    kind and [creating a multinode cluster](https://oreil.ly/8nOHi). The code for
    this example also contains a configuration file you may find useful to create
    a simple three-node kind cluster.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群至少需要三个 Worker 节点，以展示 Kubernetes 提供的机制，允许您请求将 Pod 分布到集群中。您可以通过使用名为 kind 的开源发行版在桌面上创建一个简单的集群。有关安装
    kind 和[创建多节点集群](https://oreil.ly/8nOHi)的说明，请参阅 kind 快速入门指南。此示例的代码还包含一个配置文件，您可能会发现它对创建一个简单的三节点
    kind 集群很有用。
- en: You will also need a StorageClass that supports dynamic provisioning. You may
    wish to follow the instructions in [“StorageClasses”](ch02.html#storageclasses)
    for installing a simple StorageClass and provisioner that expose local storage.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还需要一个支持动态配置的StorageClass。您可能希望按照[“StorageClasses”](ch02.html#storageclasses)中的说明安装一个简单的StorageClass和提供者，以公开本地存储。
- en: Using Helm to Deploy MySQL
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Helm部署MySQL
- en: 'To make things a bit more concrete, let’s use Helm to deploy the databases
    you worked with in [Chapter 3](ch03.html#databases_on_kubernetes_the_hard_way).
    First, if it’s not already on your system, you’ll need to install Helm by using
    the [documentation](https://oreil.ly/tUPWL) on the Helm website. Next, add the
    Bitnami Helm repository:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让事情更具体化，让我们使用Helm来部署您在[第3章](ch03.html#databases_on_kubernetes_the_hard_way)中使用的数据库。首先，如果它尚未安装在您的系统上，您需要使用Helm网站上的[文档](https://oreil.ly/tUPWL)来安装Helm。接下来，添加Bitnami
    Helm存储库：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The Bitnami Helm repository contains a variety of Helm charts to help you deploy
    infrastructure such as databases, analytics engines, and log management systems,
    as well as applications including ecommerce, customer relationship management
    (CRM), and you guessed it: WordPress. You can find the source code for the charts
    in the Bitnami Charts repository on [GitHub](https://oreil.ly/lmcml). The *README*
    for this repo provides helpful instructions for using the charts in various Kubernetes
    distributions.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Bitnami Helm存储库包含各种Helm图表，可帮助您部署基础设施，如数据库、分析引擎和日志管理系统，以及应用程序，包括电子商务、客户关系管理（CRM），还有您猜到的：WordPress。您可以在[GitHub](https://oreil.ly/lmcml)上的Bitnami
    Charts存储库中找到这些图表的源代码。这个存储库的*README*提供了在不同Kubernetes分发中使用图表的有用说明。
- en: 'Now, let’s use the Helm chart provided in the `bitnami` repository to deploy
    MySQL. In Helm’s terminology, each deployment is known as a *release*. The simplest
    possible release that you could create using this chart would look something like
    this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`bitnami`存储库中提供的Helm图表来部署MySQL。在Helm的术语中，每个部署称为一个*release*。使用此图表创建的可能是最简单的发布如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If you execute this command, it will create a release called `mysql` using
    the Bitnami MySQL Helm chart with its default settings. As a result, you’d have
    a single MySQL node. Since you’ve already deployed a single node of MySQL manually
    in [Chapter 3](ch03.html#databases_on_kubernetes_the_hard_way), let’s do something
    a bit more interesting this time and create a MySQL cluster. To do this, you’ll
    create a *values.yaml* file with contents like the following, or you can reuse
    the [sample](https://oreil.ly/tsnuT) provided in the source code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您执行此命令，它将使用Bitnami MySQL Helm图表的默认设置创建一个名为`mysql`的发布。因此，您将拥有一个单独的MySQL节点。由于您已经在[第3章](ch03.html#databases_on_kubernetes_the_hard_way)中手动部署了一个单节点的MySQL，请这次尝试做一些更有趣的事情并创建一个MySQL集群。为此，您可以创建一个*values.yaml*文件，并添加以下内容，或者您可以重用源代码中提供的[sample](https://oreil.ly/tsnuT)：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The settings in this *values.yaml* file let Helm know that you want to use options
    in the Bitnami MySQL Helm chart to deploy MySQL in a replicated architecture in
    which there is a primary node and two secondary nodes.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 此*values.yaml*文件中的设置告诉Helm您希望在Bitnami MySQL Helm图表中使用选项来部署MySQL在一个有主节点和两个从节点的复制架构中。
- en: MySQL Helm Chart Configuration Options
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: MySQL Helm图表的配置选项
- en: 'If you examine the default [*values.yaml* file](https://oreil.ly/SGsN5) provided
    with the Bitnami MySQL Helm chart, you’ll see quite a few options available beyond
    the simple selections shown here. The configurable values include the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您查看了Bitnami MySQL Helm图表提供的默认[*values.yaml*文件](https://oreil.ly/SGsN5)，您会看到除了这里显示的简单选择外，还有很多可用的选项。可配置的值包括以下内容：
- en: Images to pull and their locations
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要拉取的图像及其位置
- en: The Kubernetes StorageClass that will be used to generate PersistentVolumes
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将用于生成持久卷的Kubernetes StorageClass
- en: Security credentials for user and administrator accounts
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户和管理员账户的安全凭据
- en: MySQL configuration settings for primary and secondary replicas
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MySQL主和从副本的配置设置
- en: Number of secondary replicas to create
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建次要副本的数量
- en: Details of liveness, readiness probes
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存活性、就绪探测的详细信息
- en: Affinity and anti-affinity settings
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 亲和性和反亲和性设置
- en: Managing high availability of the database using Pod disruption budgets
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Pod中断预算来管理数据库的高可用性
- en: Many of these concepts you’ll be familiar with already, and others like affinity
    and Pod disruption budgets are covered later in the book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些概念您可能已经熟悉了，而像亲和性和Pod中断预算这样的概念将在本书的后面进行介绍。
- en: 'Once you’ve created the *values.yaml* file, you can start the cluster using
    this command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 创建了*values.yaml*文件后，您可以使用以下命令启动集群：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'After running the command, you’ll see the status of the install from Helm,
    plus instructions that are provided with the chart under `NOTES`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 运行命令后，您将从Helm看到安装的状态，以及图表下`NOTES`中提供的说明：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We’ve omitted the notes here since they are a bit lengthy. They describe suggested
    commands for monitoring the status as MySQL initializes, how clients and administrators
    can connect to the database, how to upgrade the database, and more.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在此处省略了备注，因为它们有些冗长。它们描述了监视MySQL初始化状态的建议命令，客户端和管理员如何连接到数据库，如何升级数据库等。
- en: Use Namespaces to Help Isolate Resources
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用命名空间帮助隔离资源
- en: 'Since we did not specify a Namespace, the Helm release has been installed in
    the default Kubernetes Namespace unless you’ve separately configured a Namespace
    in your [kubeconfig](https://oreil.ly/C2vOM). If you want to install a Helm release
    in its own Namespace in order to work with its resources more effectively, you
    could run something like the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有指定命名空间，因此Helm发布已安装在默认的Kubernetes命名空间中，除非您在[kubeconfig](https://oreil.ly/C2vOM)中单独配置了命名空间。如果要在自己的命名空间中安装Helm发布，以便更有效地使用其资源，您可以运行类似以下命令：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This creates a Namespace called `mysql` and installs the `mysql` release inside
    it.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`mysql`的命名空间，并在其中安装`mysql`发布。
- en: 'To obtain information about the Helm releases you’ve created, use the `helm
    list` command, which produces output such as this (formatted for readability):'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取您创建的Helm发布的信息，请使用`helm list`命令，它会生成类似以下格式的输出：
- en: '[PRE6]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If you haven’t installed the release in its own Namespace, it’s still simple
    to see the compute resources that Helm has created on your behalf by running `kubectl
    get all`, because they have all been labeled with the name of your release. It
    may take several minutes for all the resources to initialize, but when complete,
    it will look something like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还没有将发布版本安装在其专用的命名空间中，您可以通过运行`kubectl get all`命令轻松查看Helm为您创建的计算资源，因为它们都已使用您发布的名称进行了标记。所有资源初始化可能需要几分钟，但完成后，它看起来将类似于以下内容：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, Helm has created two StatefulSets, one for primary replicas
    and one for secondary replicas. The `mysql-primary` StatefulSet is managing a
    single MySQL Pod containing a primary replica, while the `mysql-secondary` StatefulSet
    is managing two MySQL Pods containing secondary replicas. See if you can determine
    which Kubernetes Worker Node each MySQL replica is running on by using the `kubectl
    describe pod` command.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，Helm创建了两个StatefulSets，一个用于主要副本，另一个用于次要副本。`mysql-primary` StatefulSet正在管理一个包含主要副本的MySQL
    Pod，而`mysql-secondary` StatefulSet正在管理包含次要副本的两个MySQL Pods。使用`kubectl describe
    pod`命令，看看您能否确定每个MySQL副本运行在哪个Kubernetes Worker Node上。
- en: From the preceding output, you’ll also notice two Services created for each
    StatefulSet, one a headless service and another that has a dedicated IP address.
    Since `kubectl get all` tells you about only compute resources and services, you
    might also be wondering about the storage resources. To check on these, run the
    `kubectl get pv` command. Assuming you have a StorageClass installed that supports
    dynamic provisioning, you should see PersistentVolumes that are bound to PersistentVolumeClaims
    named `data-mysql-primary-0`, `data-mysql-secondary-0`, and `data-mysql-secondary-1`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 从上述输出中，您还会注意到为每个StatefulSet创建了两个服务，一个是无头服务，另一个具有专用IP地址。由于`kubectl get all`只告诉您计算资源和服务的情况，您可能也想了解存储资源。要检查这些资源，请运行`kubectl
    get pv`命令。假设您安装了支持动态配置的StorageClass，您应该看到绑定到PersistentVolumeClaim的PersistentVolumes，命名为`data-mysql-primary-0`、`data-mysql-secondary-0`和`data-mysql-secondary-1`。
- en: In addition to the resources we’ve discussed, installing the chart has also
    resulted in the creation of a few additional resources that we’ll explore next.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们讨论过的资源之外，安装图表还导致创建了一些额外的资源，我们将在接下来探讨。
- en: Namespaces and Kubernetes Resource Scope
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间和Kubernetes资源范围
- en: If you have chosen to install your Helm release in a Namespace, you’ll need
    to specify the Namespace on most of your `kubectl get` commands in order to see
    the created resources. The exception is `kubectl get pv`, because PersistentVolumes
    are one of the Kubernetes resources that are not Namespaced; that is, they can
    be used by Pods in any Namespace. To learn more about which Kubernetes resources
    in your cluster are Namespaced and which are not, run the command `kubectl api-resources`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你选择在一个命名空间中安装你的Helm发布版，那么在大多数`kubectl get`命令中，你需要指定这个命名空间才能看到创建的资源。唯一的例外是`kubectl
    get pv`，因为PersistentVolumes是Kubernetes中不归属于任何命名空间的资源之一；也就是说，它们可以被任何命名空间中的Pod使用。要了解集群中哪些Kubernetes资源是命名空间的，哪些不是，请运行命令`kubectl
    api-resources`。
- en: How Helm Works
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Helm的工作原理
- en: Did you wonder what happened when you executed the `helm install` command with
    a provided values file? To understand what’s going on, let’s take a look at the
    contents of a Helm chart, as shown in [Figure 4-2](#customizing_a_helm_release_using_a_valu).
    As we discuss these contents, it will also be helpful to look at the [source code](https://oreil.ly/xQbvb)
    of the MySQL Helm chart you just installed.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行带有提供的值文件的`helm install`命令时，你是否想知道发生了什么？要了解发生了什么，请看一下刚刚安装的MySQL Helm图表的源代码，如[图4-2](#customizing_a_helm_release_using_a_valu)所示。
- en: '![Customizing a Helm release using a values.yaml file](assets/mcdk_0402.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![使用values.yaml文件自定义Helm发布](assets/mcdk_0402.png)'
- en: Figure 4-2\. Customizing a Helm release using a values.yaml file
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-2\. 使用values.yaml文件自定义Helm发布
- en: 'Looking at the contents of a Helm chart, you’ll notice the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 查看Helm图表的内容时，你会注意到以下内容：
- en: '[README file](https://oreil.ly/i7XBa)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '[README文件](https://oreil.ly/i7XBa)'
- en: This explains how to use the chart. These instructions are provided along with
    the chart in registries.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这解释了如何使用图表。这些说明与图表一起提供在注册表中。
- en: '[Chart.yaml file](https://oreil.ly/zZb2Y)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[Chart.yaml文件](https://oreil.ly/zZb2Y)'
- en: This contains metadata about the chart such as its name, publisher, version,
    keywords, and any dependencies on other charts. These properties are useful when
    searching Helm registries to find charts.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含关于图表的元数据，如名称、发布者、版本、关键字以及对其他图表的任何依赖关系。在Helm注册表中搜索图表时，这些属性非常有用。
- en: '[values.yaml file](https://oreil.ly/mhfhZ)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '[values.yaml文件](https://oreil.ly/mhfhZ)'
- en: This lists out the configurable values supported by the chart and their default
    values. These files typically contain a good number of comments that explain the
    available options. For the Bitnami MySQL Helm chart, a lot of options are available,
    as we’ve noted.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这会列出图表支持的可配置值及其默认值。这些文件通常包含很多注释，解释了可用选项。对于Bitnami MySQL Helm图表，提供了许多选项，正如我们所注意到的。
- en: '[templates directory](https://oreil.ly/F21Lg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[templates目录](https://oreil.ly/F21Lg)'
- en: This contains [Go templates](https://oreil.ly/diTnu) that define the chart.
    The templates include a [*Notes.txt*](https://oreil.ly/v0aky) file used to generate
    the output you saw previously after executing the `helm install` command, and
    one or more YAML files that describe a pattern for a Kubernetes resource. These
    YAML files may be organized in subdirectories (for example, the [template](https://oreil.ly/iKedl)
    that defines a StatefulSet for MySQL primary replicas). Finally, a *_helpers.tpl*
    file describes how to use the templates. Some of the templates may be used multiple
    times or not at all, depending on the selected configuration values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含定义图表的Go模板。模板包括一个用于生成你之前在执行`helm install`命令后看到的输出的*Notes.txt*文件，以及一个或多个描述Kubernetes资源模式的YAML文件。这些YAML文件可能以子目录的形式组织（例如，定义MySQL主副本的StatefulSet的[模板](https://oreil.ly/iKedl)）。最后，*_helpers.tpl*文件描述了如何使用模板。根据所选的配置值，某些模板可能会被多次使用或根本不使用。
- en: When you execute the `helm install` command, the Helm client makes sure it has
    an up-to-date copy of the chart you’ve named by checking with the source repository.
    Then it uses the template to generate YAML configuration code, overriding default
    values from the chart’s *values.yaml* file with any values you’ve provided. It
    then uses the `kubectl` command to apply this configuration to your currently
    configured Kubernetes cluster.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你执行`helm install`命令时，Helm客户端确保通过与源代码库检查来获取你命名的图表的最新副本。然后，它使用模板生成YAML配置代码，覆盖图表的*values.yaml*文件中的默认值以及你提供的任何值。然后，它使用`kubectl`命令将此配置应用于当前配置的Kubernetes集群。
- en: 'If you’d like to see the configuration that a Helm chart will produce before
    applying it, you can use the handy `template` command. It supports the same syntax
    as the `install` command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在应用之前查看 Helm 图表生成的配置，可以使用方便的 `template` 命令。它支持与 `install` 命令相同的语法：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Running this command will produce quite a bit of output, so you may want to
    redirect it to a file (append `> values-template.yaml` to the command) so you
    can take a longer look. Alternatively, you can look at the [copy](https://oreil.ly/DhEtc)
    we have saved in the source code repository.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此命令将会产生大量输出，因此你可能想将其重定向到文件（在命令后添加 `> values-template.yaml`），以便长时间查看。或者，你可以查看我们在源代码仓库中保存的[副本](https://oreil.ly/DhEtc)。
- en: You’ll notice that several types of resources are created, as summarized in
    [Figure 4-3](#deploying_mysql_using_the_bitnami_helm). Many of the resources shown
    have been discussed, including the StatefulSets for managing the primary and secondary
    replicas, each with its own service (the chart also creates headless services
    that are not shown in the figure). Each Pod has its own PersistentVolumeClaim
    that is mapped to a unique PersistentVolume.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到生成了几种类型的资源，如 [图 4-3](#deploying_mysql_using_the_bitnami_helm) 所总结的。许多显示的资源已经讨论过，包括用于管理主副本的
    StatefulSets，每个都有自己的服务（该图还创建了未在图中显示的无头服务）。每个 Pod 都有自己的 PersistentVolumeClaim，映射到唯一的
    PersistentVolume。
- en: '[Figure 4-3](#deploying_mysql_using_the_bitnami_helm) also includes resource
    types we haven’t discussed previously. Notice first that each StatefulSet has
    an associated ConfigMap that is used to provide a common set of configuration
    settings to its Pods. Next, notice the Secret named `mysql`, which stores passwords
    needed for accessing various interfaces exposed by the database nodes. Finally,
    a ServiceAccount resource is applied to every Pod created by this Helm release.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 4-3](#deploying_mysql_using_the_bitnami_helm) 包含了我们之前未讨论过的资源类型。首先注意到每个 StatefulSet
    都有一个关联的 ConfigMap，用于为其 Pods 提供一组共享的配置设置。接着，注意到名为 `mysql` 的 Secret，用于存储访问数据库节点暴露的各种接口所需的密码。最后，每个由此
    Helm 发布创建的 Pod 都应用了一个 ServiceAccount 资源。'
- en: Let’s focus on some interesting aspects of this deployment, including the usage
    of labels, ServiceAccounts, Secrets, and ConfigMaps.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们专注于此部署的一些有趣方面，包括标签、ServiceAccounts、Secrets 和 ConfigMaps 的使用。
- en: '![Deploying MySQL using the Bitnami Helm chart](assets/mcdk_0403.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Bitnami Helm 图表部署 MySQL](assets/mcdk_0403.png)'
- en: Figure 4-3\. Deploying MySQL using the Bitnami Helm chart
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-3\. 使用 Bitnami Helm 图表部署 MySQL
- en: Labels
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: 'If you look through the output from the `helm template`, you’ll notice that
    the resources have a common set of labels:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看从 `helm template` 输出的内容，你会注意到这些资源具有一组共同的标签：
- en: '[PRE9]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These labels help identify the resources as being part of the `mysql` application
    and indicate that they are managed by Helm using a specific chart version. The
    labels are useful for selecting resources, which is often useful in defining configurations
    for other resources.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签有助于识别资源作为 `mysql` 应用程序的一部分，并指示它们是通过特定图表版本由 Helm 管理的。标签对于选择资源非常有用，通常用于定义其他资源的配置。
- en: ServiceAccounts
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ServiceAccounts
- en: Kubernetes clusters make a distinction between human users and applications
    for access control purposes. A ServiceAccount is a Kubernetes resource that represents
    an application and what it is allowed to access. For example, a ServiceAccount
    may be given access to some portions of the Kubernetes API, or access to one or
    more secrets containing privileged information such as login credentials. This
    latter capability is used in your Helm installation of MySQL to share credentials
    between Pods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群为了访问控制目的区分了人类用户和应用程序。ServiceAccount 是一个代表应用程序及其访问权限的 Kubernetes
    资源。例如，ServiceAccount 可以被授予访问 Kubernetes API 的某些部分或者访问包含登录凭据等敏感信息的一个或多个 Secrets
    的权限。后者的功能在你的 MySQL Helm 安装中用于在 Pods 之间共享凭据。
- en: 'Every Pod created in Kubernetes has a ServiceAccount assigned to it. If you
    do not specify one, the default ServiceAccount is used. Installing the MySQL Helm
    chart creates a ServiceAccount called `mysql`. You can see the specification for
    this resource in the generated template:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中创建的每个 Pod 都有一个分配给它的 ServiceAccount。如果未指定，则使用默认的 ServiceAccount。安装
    MySQL Helm 图表会创建一个名为 `mysql` 的 ServiceAccount。你可以在生成的模板中查看此资源的规范：
- en: '[PRE10]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, this ServiceAccount has access to a Secret called `mysql`, which
    we’ll discuss shortly. A ServiceAccount can also have an additional type of Secret
    known as an `imagePullSecret`. These Secrets are used when an application needs
    to use images from a private registry.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这个 ServiceAccount 可以访问名为 `mysql` 的 Secret，我们将很快讨论。ServiceAccount 还可以具有称为
    `imagePullSecret` 的附加类型的 Secret。当应用程序需要使用来自私有注册表的镜像时，会使用这些 Secrets。
- en: By default, a ServiceAccount does not have any access to the Kubernetes API.
    To give this ServiceAccount the access it needs, the MySQL Helm chart creates
    a Role specifying the Kubernetes resources and operations, and a RoleBinding to
    associate the ServiceAccount to the Role. We’ll discuss ServiceAccounts and role-based
    access in [Chapter 5](ch05.html#automating_database_management_on_kuber).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ServiceAccount 没有任何访问 Kubernetes API 的权限。为了给这个 ServiceAccount 提供所需的访问权限，MySQL
    Helm 图表创建一个角色，指定 Kubernetes 资源和操作，并创建一个 RoleBinding 将 ServiceAccount 绑定到该角色。我们将在[第5章](ch05.html#automating_database_management_on_kuber)讨论
    ServiceAccounts 和基于角色的访问控制。
- en: Secrets
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Secrets
- en: 'As you learned in [Chapter 2](ch02.html#managing_data_storage_on_kubernetes),
    a Secret provides secure access to information you need to keep private. Your
    `mysql` Helm release contains a Secret called `mysql` containing login credentials
    for the MySQL instances themselves:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在[第2章](ch02.html#managing_data_storage_on_kubernetes)学到的那样，Secret 提供了安全访问需要保密的信息。您的
    `mysql` Helm 发布包含一个名为 `mysql` 的 Secret，其中包含 MySQL 实例本身的登录凭据：
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The three passwords represent different types of access: the `mysql-root-password`
    provides administrative access to the MySQL node, while the `mysql-replication-password`
    is used for nodes to communicate for the purposes of data replication between
    nodes. The `mysql-password` is used by client applications to access the database
    to write and read data.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个密码代表不同类型的访问权限：`mysql-root-password` 提供对 MySQL 节点的管理访问，`mysql-replication-password`
    用于节点之间进行数据复制的通信，而 `mysql-password` 则由客户端应用程序用于访问数据库以读写数据。
- en: ConfigMaps
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ConfigMaps
- en: 'The Bitnami MySQL Helm chart creates Kubernetes ConfigMap resources to represent
    the configuration settings used for Pods that run the MySQL primary and secondary
    replica nodes. ConfigMaps store configuration data as key-value pairs. For example,
    the ConfigMap created by the Helm chart for the primary replicas looks like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Bitnami MySQL Helm 图表创建 Kubernetes ConfigMap 资源，用于表示运行 MySQL 主节点和次要复制节点的 Pod
    的配置设置。ConfigMaps 将配置数据存储为键-值对。例如，Helm 图表为主复制品创建的 ConfigMap 如下所示：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In this case, the key is the name `my.cnf`, which represents a filename, and
    the value is a multiline set of configuration settings that represent the contents
    of a configuration file (which we’ve abbreviated here). Next, look at the definition
    of the StatefulSet for the primary replicas. Notice that the contents of the ConfigMap
    are mounted as a read-only file inside each template, according to the Pod specification
    for the StatefulSet (again, we’ve omitted some detail to focus on key areas):'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，键是 `my.cnf` 的名称，表示文件名，值是代表配置文件内容的多行设置（在这里我们进行了简化）。接下来，查看主复制品的 StatefulSet
    的定义。请注意，根据 StatefulSet 的 Pod 规范，ConfigMap 的内容被挂载为每个模板内的只读文件（再次为了关注关键区域，我们省略了一些细节）：
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Mounting the ConfigMap as a volume in a container results in the creation of
    a read-only file in the mount directory that is named according to the key and
    has the value as its content. For our example, mounting the ConfigMap in the Pod’s
    `mysql` container results in the creation of the file */opt/bitnami/mysql/conf/my.cnf*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 将 ConfigMap 挂载为容器中的卷会在挂载目录中创建一个只读文件，文件名根据键命名，内容为对应的值。例如，在 Pod 的 `mysql` 容器中挂载
    ConfigMap 将创建文件 */opt/bitnami/mysql/conf/my.cnf*。
- en: 'This is one of several ways that ConfigMaps can be used in Kubernetes applications:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 ConfigMaps 可以在 Kubernetes 应用程序中使用的几种方式之一：
- en: As described in the [Kubernetes documentation](https://oreil.ly/yoEYv), you
    could choose to store configuration data in more granular key-value pairs, which
    also makes it easier to access individual values in your application.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如 [Kubernetes 文档](https://oreil.ly/yoEYv) 所述，您可以选择以更精细的键-值对存储配置数据，这样可以更轻松地访问应用程序中的各个值。
- en: You can also reference individual key-value pairs as environment variables you
    pass to a container.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以将单独的键-值对引用为传递给容器的环境变量。
- en: Finally, applications can access ConfigMap contents via the Kubernetes API.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，应用程序可以通过 Kubernetes API 访问 ConfigMap 的内容。
- en: More Configuration Options
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多配置选项
- en: Now that you have a Helm release with a working MySQL cluster, you can point
    an application to it, such as WordPress. Why not try seeing if you can adapt the
    WordPress deployment from [Chapter 3](ch03.html#databases_on_kubernetes_the_hard_way)
    to point to the MySQL cluster you’ve created here?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您已经有一个具有工作 MySQL 集群的 Helm 发布，您可以将一个应用程序指向它，例如 WordPress。为什么不尝试看看是否可以调整[第三章](ch03.html#databases_on_kubernetes_the_hard_way)中的
    WordPress 部署，使其指向您在这里创建的 MySQL 集群呢？
- en: For further learning, you could also compare your resulting configuration with
    that produced by the Bitnami WordPress Helm chart, which uses MariaDB instead
    of MySQL but is otherwise quite similar.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 进行进一步学习时，您还可以将您的配置结果与使用 MariaDB 而不是 MySQL 的 Bitnami WordPress Helm 图表生成的结果进行比较，但其余部分非常相似。
- en: Updating Helm Charts
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 Helm 图表
- en: 'If you’re running a Helm release in a production environment, chances are you’re
    going to need to maintain it over time. You might want to update a Helm release
    for various reasons:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在生产环境中运行 Helm 发布，很可能需要随时间维护它。您可能出于各种原因想要更新 Helm 发布：
- en: A new version of a chart is available.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图表的新版本已经可用。
- en: A new version of an image used by your application is available.
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序使用的图像的新版本已经可用。
- en: You want to change the selected options.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想要更改所选的选项。
- en: 'To check for a new version of a chart, execute the `helm repo update` command.
    Running this command with no options looks for updates in all of the chart repositories
    you have configured for your Helm client:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查图表的新版本，请执行`helm repo update`命令。运行此命令而不带任何选项将在您为 Helm 客户端配置的所有图表库中查找更新：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, you’ll want to make any desired updates to your configured values. If
    you’re upgrading to a new version of a chart, make sure to check the release notes
    and documentation of the configurable values. It’s a good idea to test out an
    upgrade before applying it. The `--dry-run` option allows you to do this, producing
    similar values to the `helm template` command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将希望对配置的值进行任何所需的更新。如果您要升级到图表的新版本，请确保检查可配置值的发布说明和文档。在应用之前测试升级是一个好主意。`--dry-run`选项允许您执行此操作，生成与`helm
    template`命令类似的值：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Using an Overlay Configuration File
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用覆盖配置文件
- en: 'One useful option you could use for the upgrade is to specify values you wish
    to override in a new configuration file, and apply both the new and old, something
    like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以用于升级的一个有用选项是指定要在新配置文件中覆盖的值，并应用新旧两者，类似于这样：
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Configuration files are applied in the order they appear on the command line,
    so if you use this approach, make sure your overridden values file appears after
    your original values file.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 配置文件按照它们在命令行上出现的顺序应用，因此如果您使用此方法，请确保您的覆盖值文件出现在原始值文件之后。
- en: Once you’ve applied the upgrade, Helm sets about its work, updating only those
    resources in the release that are affected by your configuration changes. If you’ve
    specified changes to the Pod template for a StatefulSet, the Pods will be restarted
    according to the update policy specified for the StatefulSet, as we discussed
    in [“StatefulSet lifecycle management”](ch03.html#statefulset_life_cycle_management).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 升级应用后，Helm 开始执行其工作，仅更新受您配置更改影响的发布中的资源。如果您已经为 StatefulSet 的 Pod 模板指定了更改，则 Pod
    将根据 StatefulSet 的更新策略重新启动，正如我们在[“StatefulSet 生命周期管理”](ch03.html#statefulset_life_cycle_management)中讨论的那样。
- en: Uninstalling Helm Charts
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 卸载 Helm 图表
- en: 'When you are finished using your Helm release, you can uninstall it by name:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当您完成使用 Helm 发布时，可以按名称卸载它：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that Helm does not remove any of the PersistentVolumeClaims or PersistentVolumes
    that were created for this Helm chart, following the behavior of StatefulSets
    discussed in [Chapter 3](ch03.html#databases_on_kubernetes_the_hard_way).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Helm 不会删除为此 Helm 图表创建的任何 PersistentVolumeClaims 或 PersistentVolumes，这遵循我们在[第三章](ch03.html#databases_on_kubernetes_the_hard_way)中讨论的
    StatefulSets 的行为。
- en: Using Helm to Deploy Apache Cassandra
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Helm 部署 Apache Cassandra
- en: 'Now let’s switch gears and look at deploying Apache Cassandra by using Helm.
    In this section, you’ll use another chart provided by Bitnami, so there’s no need
    to add another repository. You can find the implementation of this chart on [GitHub](https://oreil.ly/WzvXp).
    Helm provides a quick way to see the metadata about this chart:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们换个角度来看，使用 Helm 部署 Apache Cassandra。在本节中，您将使用 Bitnami 提供的另一个图表，因此不需要添加其他存储库。您可以在[GitHub](https://oreil.ly/WzvXp)上找到此图表的实现。Helm
    提供了一种快速查看有关此图表的元数据的方法：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'After reviewing the metadata, you’ll also want to learn about the configurable
    values. You can examine the [*values.yaml* file](https://oreil.ly/z69Z7) in the
    GitHub repo, or use another option on the `show` command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看了元数据之后，你还会想了解可配置的值。你可以检查GitHub存储库中的[*values.yaml*文件](https://oreil.ly/z69Z7)，或者在`show`命令上使用另一个选项：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The list of options for this chart is shorter than the list for the MySQL chart,
    because Cassandra doesn’t have the concept of primary and secondary replicas.
    However, you’ll certainly see similar options for images, StorageClasses, security,
    liveness and readiness probes, and so on. Some configuration options are unique
    to Cassandra, such as those having to do with JVM settings and seed nodes (as
    discussed in [Chapter 3](ch03.html#databases_on_kubernetes_the_hard_way)).
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与MySQL图表相比，此图表的选项列表较短，因为Cassandra没有主要和次要副本的概念。然而，你肯定会看到类似的选项，如镜像、StorageClasses、安全性、存活和就绪探针等。一些配置选项是Cassandra特有的，例如与JVM设置和种子节点相关的选项（如[第3章](ch03.html#databases_on_kubernetes_the_hard_way)所讨论的）。
- en: One interesting feature of this chart is the ability to export metrics from
    Cassandra nodes. If you set `metrics.enabled=true`, the chart will inject a sidecar
    container into each Cassandra Pod that exposes a port that can be scraped by Prometheus.
    Other values under `metrics` configure what metrics are exported, the collection
    frequency, and more. While we won’t use this feature here, metrics reporting is
    a key part of managing data infrastructure we’ll cover in [Chapter 6](ch06.html#integrating_data_infrastructure_in_a_ku).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此图表的一个有趣功能是能够从Cassandra节点导出指标。如果设置了`metrics.enabled=true`，图表将在每个Cassandra Pod中注入一个sidecar容器，该容器公开一个可以被Prometheus抓取的端口。`metrics`下的其他值配置导出的指标、收集频率等。虽然我们这里不会使用此功能，但指标报告是管理数据基础设施的关键部分，我们将在[第6章](ch06.html#integrating_data_infrastructure_in_a_ku)中进行介绍。
- en: 'For a simple three-node Cassandra configuration, you could set the replica
    count to 3 and set other configuration values to their defaults. However, since
    you’re overriding only a single configuration value, this is a good time to take
    advantage of Helm’s support for setting values on the command line, instead of
    providing a *values.yaml* file:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的三节点Cassandra配置，你可以将副本数设置为3，并将其他配置值设置为默认值。然而，既然你只是覆盖了一个配置值，这是一个很好的机会来利用Helm支持的在命令行上设置值，而不是提供一个*values.yaml*文件：
- en: '[PRE20]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As discussed previously, you can use the `helm template` command to check the
    configuration before installing it, or look at the file we’ve saved on GitHub.
    However, since you’ve already created the release, you can also use this command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前讨论的，你可以使用`helm template`命令在安装之前检查配置，或查看我们在GitHub上保存的文件。然而，既然你已经创建了发布版本，你也可以使用这个命令：
- en: '[PRE21]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Looking through the resources in the YAML, you’ll see that a similar set of
    infrastructure has been established, as shown in [Figure 4-4](#deploying_apache_cassandra_using_the_bi).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在YAML中查看资源时，你会看到已建立了类似的基础设施，如[图4-4](#deploying_apache_cassandra_using_the_bi)所示。
- en: 'The configuration includes the following:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 配置包括以下内容：
- en: A ServiceAccount referencing a Secret, which contains the password for the `cassandra`
    administrator account.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个引用了包含`cassandra`管理员帐户密码的Secret的ServiceAccount。
- en: A single StatefulSet, with a headless Service used to reference its Pods. The
    Pods are spread evenly across the available Kubernetes Worker Nodes, which we’ll
    discuss in the next section. The Service exposes Cassandra ports used for intra-node
    communication (`7000`, with `7001` used for secure communication via TLS), administration
    via JMX (`7199`), and client access via CQL (`9042`).
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个单一的StatefulSet，使用无头Service引用其Pod。Pod均匀分布在可用的Kubernetes Worker节点上，我们将在下一节讨论。该Service公开了用于节点内通信的Cassandra端口（`7000`，使用TLS进行安全通信的`7001`），通过JMX进行管理的端口（`7199`），以及通过CQL进行客户端访问的端口（`9042`）。
- en: '![Deploying Apache Cassandra using the Bitnami Helm chart](assets/mcdk_0404.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![使用Bitnami Helm图表部署Apache Cassandra](assets/mcdk_0404.png)'
- en: Figure 4-4\. Deploying Apache Cassandra using the Bitnami Helm chart
  id: totrans-137
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图4-4\. 使用Bitnami Helm图表部署Apache Cassandra
- en: This configuration represents a simple Cassandra topology, with all three nodes
    in a single Datacenter and rack. This simple topology reflects one of the limitations
    of this chart—it does not provide the ability to create a Cassandra cluster consisting
    of multiple Datacenters and racks. To create a more complex deployment, you’d
    have to install multiple Helm releases, using the same `clusterName` (in this
    case, you’re using the default name `cassandra`), but a different Datacenter and
    rack per deployment. You’d also need to obtain the IP address of a couple of nodes
    in the first Datacenter to use as `additionalSeeds` when configuring the releases
    for the other racks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置表示一个简单的Cassandra拓扑结构，所有三个节点位于单个数据中心和机架中。这种简单的拓扑反映了此图表的一个限制——它无法创建由多个数据中心和机架组成的Cassandra集群。要创建更复杂的部署，您需要安装多个Helm发布，使用相同的`clusterName`（在本例中，使用默认名称`cassandra`），但每个部署中的数据中心和机架不同。您还需要获取第一个数据中心中几个节点的IP地址，用作在配置其他机架的发布时的`additionalSeeds`。
- en: Affinity and Anti-Affinity
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 亲和性和反亲和性
- en: 'As shown in [Figure 4-4](#deploying_apache_cassandra_using_the_bi), the Cassandra
    nodes are spread evenly across the Worker Nodes in your cluster. To verify this
    in your own Cassandra release, you could run something like the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如[Figure 4-4](#deploying_apache_cassandra_using_the_bi)所示，Cassandra节点均匀分布在集群中的工作节点上。要在您自己的Cassandra发布中验证这一点，您可以运行类似以下内容的命令：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, each Cassandra node is running on a different Worker Node. If
    your Kubernetes cluster has at least three Worker Nodes and no other workloads,
    you’ll likely observe similar behavior. While it is true that this even allocation
    could happen naturally in a cluster that has an even load across Worker Nodes,
    this is probably not the case in your production environment. However, to promote
    maximum availability of your data, we want to try to honor the intent of Cassandra’s
    architecture to run nodes on different machines in order to promote high availability.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，每个Cassandra节点都运行在不同的工作节点上。如果您的Kubernetes集群至少有三个工作节点且没有其他工作负载，则可能会观察到类似的行为。尽管在负载均衡的集群中可能会自然发生这种均匀分配，但这可能并非在您的生产环境中的情况。然而，为了促进数据的最大可用性，我们希望尽量遵循Cassandra架构的意图，在不同的机器上运行节点以提高高可用性。
- en: 'To help guarantee this isolation, the Bitnami Helm chart uses Kubernetes’s
    affinity capabilities, specifically anti-affinity. If you examine the generated
    configuration for the Cassandra StatefulSet, you’ll see the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助保证此隔离性，Bitnami Helm图表使用Kubernetes的亲和性能力，具体来说是反亲和性。如果您查看生成的Cassandra StatefulSet配置，您会看到以下内容：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As shown here, the Pod template specification lists three possible types of
    affinity, with only the `podAntiAffinity` being defined. What do these concepts
    mean?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如此所示，Pod模板规范列出了三种可能的亲和性类型，仅定义了`podAntiAffinity`。这些概念意味着什么？
- en: Pod affinity
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Pod亲和性
- en: The preference that a Pod is scheduled onto a node where another specific Pod
    is running. For example, Pod affinity could be used to colocate a web server with
    its cache.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 希望Pod被调度到另一个特定Pod正在运行的节点上。例如，Pod亲和性可以用于将Web服务器与其缓存放置在一起。
- en: Pod anti-affinity
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 反亲和性
- en: The opposite of Pod affinity—that is, a preference that a Pod not be scheduled
    on a node where another identified Pod is running. This is the constraint used
    in this example, as we’ll discuss shortly.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Pod反亲和性是Pod亲和性的相反，即不希望Pod被调度到另一个已有特定Pod的节点上。这是本例中使用的约束条件，稍后我们将讨论。
- en: Node affinity
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 节点亲和性
- en: A preference that a Pod be run on a node with specific characteristics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 希望Pod在具有特定特征的节点上运行。
- en: Each type of affinity can be expressed as either hard or soft constraints. These
    are known as `requiredDuringSchedulingIgnoredDuringExecution` and `preferredDuringSchedulingIgnoredDuringExecution`.
    The first constraint specifies rules that must be met before a Pod is scheduled
    on a node, while the second specifies a preference that the scheduler will attempt
    to meet but may relax if necessary in order to schedule the Pod.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的亲和性可以表示为硬约束或软约束。这些被称为`requiredDuringSchedulingIgnoredDuringExecution`和`preferredDuringSchedulingIgnoredDuringExecution`。第一个约束指定必须在Pod被调度到节点之前满足的规则，而第二个指定了调度器将尝试满足的首选项，但如果必要的话可以放松以便调度Pod。
- en: '`IgnoredDuringExcecution` implies that the constraints apply only when the
    Pods are first scheduled. In the future, new `RequiredDuringExecution` options
    will be added called `requiredDuringSchedulingRequiredDuringExecution` and `requiredDuringSchedulingRequiredDuringExecution`.
    These will ask Kubernetes to evict Pods (that is, move them to another node) that
    no longer meet the criteria—for example, by a change in their labels.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`IgnoredDuringExcecution` 意味着这些约束仅在首次调度 Pods 时应用。未来将添加新的 `RequiredDuringExecution`
    选项，称为 `requiredDuringSchedulingRequiredDuringExecution` 和 `requiredDuringSchedulingRequiredDuringExecution`。这些选项将要求
    Kubernetes 逐出 Pods（即将其移动到另一个节点），这些 Pods 不再满足条件，例如它们标签的变更。'
- en: Looking at the preceding example, the Pod template specification for the Cassandra
    StatefulSet specifies an anti-affinity rule using the labels that are applied
    to each Cassandra Pod. The net effect is that Kubernetes will try to spread the
    Pods across the available Worker Nodes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 查看前面的示例，Cassandra StatefulSet 的 Pod 模板规范指定了使用应用于每个 Cassandra Pod 的标签的反亲和性规则。其主要效果是
    Kubernetes 将尝试在可用的 Worker 节点上分布这些 Pods。
- en: 'Those are the highlights of looking at the Bitnami Helm chart for Cassandra.
    To clean things up, uninstall the Cassandra release:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是查看 Cassandra 的 Bitnami Helm 图表的亮点。为了清理事务，卸载 Cassandra 发行版：
- en: '[PRE24]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If you don’t want to work with Bitnami Helm charts any longer, you can also
    remove the repository from your Helm client:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不想再使用 Bitnami Helm 图表，您也可以从 Helm 客户端中删除该存储库：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: More Kubernetes Scheduling Constraints
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多 Kubernetes 调度约束
- en: Kubernetes supports additional mechanisms for providing hints to its scheduler
    about Pod placement. One of the simplest is [NodeSelectors](https://oreil.ly/05hSU),
    which is very similar to node affinity, but with a less expressive syntax that
    can match on one or more labels by using AND logic. Since you may or may not have
    the required privileges to attach labels to Worker Nodes in your cluster, Pod
    affinity is often a better option. [Taints and tolerations](https://oreil.ly/fbkTB)
    are another mechanism that can be used to configure Worker Nodes to repel specific
    Pods from being scheduled on those nodes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 支持额外的机制来向其调度器提供有关 Pod 放置的提示。其中最简单的之一是 [NodeSelectors](https://oreil.ly/05hSU)，它与节点亲和力非常相似，但语法更少表达性，可以使用
    AND 逻辑匹配一个或多个标签。由于您可能没有必要的权限将标签附加到集群中的 Worker 节点，Pod 亲和性通常是更好的选择。 [污点和容忍](https://oreil.ly/fbkTB)
    是另一种机制，用于配置 Worker 节点以排斥特定的 Pods，以防它们被调度到这些节点上。
- en: In general, you want to be careful to understand all of the constraints you’re
    putting on the Kubernetes scheduler from various workloads so as not to overly
    constrain its ability to place Pods. See the Kubernetes documentation for more
    information on [scheduling constraints](https://oreil.ly/aUWsi). We’ll also look
    at how Kubernetes allows you to plug in different schedulers in [“Alternative
    Schedulers for Kubernetes”](ch09.html#alternative_schedulers_for_kubernetes).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，您需要小心理解对 Kubernetes 调度器的各种工作负载施加的所有约束，以免过度限制其放置 Pod 的能力。有关 [调度约束](https://oreil.ly/aUWsi)
    的更多信息，请参阅 Kubernetes 文档。我们还将查看 Kubernetes 允许您在 [“Kubernetes 的替代调度器”](ch09.html#alternative_schedulers_for_kubernetes)
    中插入不同的调度器。
- en: Helm, CI/CD, and Operations
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Helm、CI/CD 和运维
- en: 'Helm is a powerful tool focused on one primary task: deploying complex applications
    to Kubernetes clusters. To get the most benefit from Helm, you’ll want to consider
    how it fits into your larger CI/CD toolset:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Helm 是一个专注于一个主要任务的强大工具：将复杂应用部署到 Kubernetes 集群。要从 Helm 中获得最大的利益，您需要考虑它如何融入您更大的
    CI/CD 工具集中：
- en: Automation servers such as [Jenkins](https://www.jenkins.io) automatically build,
    test, and deploy software according to scripts known as *jobs*. These jobs are
    typically run based on predefined triggers, such as a commit to a source repository.
    Helm charts can be referenced in jobs to install an application under test and
    its supporting infrastructure in a Kubernetes cluster.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化服务器（如 [Jenkins](https://www.jenkins.io)）根据称为 *jobs* 的脚本自动构建、测试和部署软件。这些 jobs
    通常基于预定义的触发器运行，例如提交到源代码库。可以在 jobs 中引用 Helm 图表，以在 Kubernetes 集群中安装应用程序及其支持基础设施。
- en: IaC automation tools such as [Terraform](https://www.terraform.io) allow you
    to define templates and scripts that describe how to create infrastructure in
    a variety of cloud environments. For example, you could write a Terraform script
    that automates the creation of a new VPC within a specific cloud provider and
    the creation of a new Kubernetes cluster within that VPC. The script could then
    use Helm to install applications within the Kubernetes cluster.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IaC 自动化工具（如[Terraform](https://www.terraform.io)）允许您定义模板和脚本，描述如何在各种云环境中创建基础架构。例如，您可以编写一个
    Terraform 脚本，自动创建特定云提供商中的新 VPC，并在该 VPC 内创建新的 Kubernetes 集群。然后，该脚本可以使用 Helm 在 Kubernetes
    集群内安装应用程序。
- en: While overlaps certainly occur in the capabilities these tools provide, you’ll
    want to consider the strengths and limitations of each as you construct your toolset.
    For this reason, we want to make sure to note that Helm has limitations when it
    comes to managing the operations of applications that it deploys. To get a good
    picture of the challenges involved, we spoke to a practitioner who has built assemblies
    of Helm charts to manage a complex database deployment. This discussion begins
    to introduce concepts like Kubernetes Custom Resource Definitions (CRDs) and the
    operator pattern, both of which we’ll cover in depth in [Chapter 5](ch05.html#automating_database_management_on_kuber).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些工具提供的功能存在重叠，但在构建工具集时，您需要考虑每个工具的优势和限制。因此，我们希望强调一下 Helm 在管理其部署的应用程序操作时存在的限制。为了全面了解涉及的挑战，我们与一位使用
    Helm chart 构建复杂数据库部署的实践者进行了交流。这次讨论开始介绍 Kubernetes Custom Resource Definitions
    (CRDs) 和 operator 模式等概念，我们将在第[5章](ch05.html#automating_database_management_on_kuber)中对其进行深入讨论。
- en: As John Sanda notes in his commentary, Helm is a powerful tool for scripting
    the deployment of applications consisting of multiple Kubernetes resources, but
    can be less effective at managing more complex operational tasks. As you’ll see
    in the chapters to come, a common pattern used for data infrastructure and other
    complex applications is to use a Helm chart to deploy an operator, which can then
    in turn manage both the deployment and lifecycle of the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 John Sanda 在他的评论中指出的那样，Helm 是一个强大的工具，用于脚本化部署由多个 Kubernetes 资源组成的应用程序，但在管理更复杂的操作任务时可能效果不佳。正如您将在接下来的章节中看到的，用于数据基础设施和其他复杂应用的常见模式是使用
    Helm chart 来部署 operator，后者可以管理应用程序的部署和生命周期。
- en: Summary
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: In this chapter, you’ve learned how a package management tool like Helm can
    help you manage the deployment of applications on Kubernetes, including your database
    infrastructure. Along the way, you’ve also learned how to use some additional
    Kubernetes resources like ServiceAccounts, Secrets, and ConfigMaps. Now it’s time
    to round out our discussion of running databases on Kubernetes. In the next chapter,
    we’ll take a deeper dive into managing database operations on Kubernetes by using
    the operator pattern.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您已经学习了像 Helm 这样的包管理工具如何帮助您管理在 Kubernetes 上部署应用程序，包括数据库基础架构。在这过程中，您还学习了如何使用一些额外的
    Kubernetes 资源，如 ServiceAccounts、Secrets 和 ConfigMaps。现在是时候进一步讨论在 Kubernetes 上运行数据库了。在下一章中，我们将深入探讨通过使用
    operator 模式在 Kubernetes 上管理数据库操作。
