<html><head></head><body><section data-pdf-bookmark="Chapter 18. GitOps and Deployment" data-type="chapter" epub:type="chapter"><div class="chapter" id="gitops">&#13;
<h1><span class="label">Chapter 18. </span>GitOps and Deployment</h1>&#13;
&#13;
&#13;
<p>In this chapter, we will discuss GitOps and how it can be used to deploy and manage applications on Kubernetes. We will deep dive into best practices of setting up a GitOps workflow and how to utilize the different tools available to achieve this.</p>&#13;
&#13;
<p>GitOps is<a data-primary="GitOps" data-secondary="purpose of" data-type="indexterm" id="gitops-purpose"/> a way to do Kubernetes application deployment. It works by utilizing Git as a single source of truth for your Kubernetes resources. With Git at the center of your deployment pipelines, developers and operators can make pull requests to accelerate and simplify application deployments and operations tasks in Kubernetes. This allows you to utilize the same practices for managing Kubernetes resources as you do for managing application code. Developers will be very familiar with the workflow, as they can utilize the same tools they use to work with application code.</p>&#13;
&#13;
<p>We cover the following topics in this chapter:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>What is GitOps?</p>&#13;
</li>&#13;
<li>&#13;
<p>Why utilize GitOps?</p>&#13;
</li>&#13;
<li>&#13;
<p>GitOps compared to other deployment methods</p>&#13;
</li>&#13;
<li>&#13;
<p>Patterns and best practices</p>&#13;
</li>&#13;
<li>&#13;
<p>GitOps tooling</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We also go through an example GitOps workflow consisting of the following tasks:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Setting up a GitOps agent with Flux</p>&#13;
</li>&#13;
<li>&#13;
<p>Connecting Flux agent to a Git repository</p>&#13;
</li>&#13;
<li>&#13;
<p>Syncing resources to a Kubernetes cluster</p>&#13;
</li>&#13;
<li>&#13;
<p>Deploying an application to the cluster</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What Is GitOps?" data-type="sect1"><div class="sect1" id="id249">&#13;
<h1>What Is GitOps?</h1>&#13;
&#13;
<p>GitOps was popularized by the folks at Weaveworks, and the idea and fundamentals were based on their experience of running Kubernetes in production. GitOps takes the concepts of the software development life cycle and applies them to operations. With GitOps, your Git repository becomes your source of truth, and your cluster is synchronized to the configured Git repository. For example, if you update a Kubernetes Deployment manifest, those configuration changes are&#13;
automatically reflected in the cluster state in Git.</p>&#13;
&#13;
<p>By using this method, you can make it easier to maintain multiclusters that are consistent and avoid configuration drift across the fleet. GitOps allows you to declaratively describe your clusters for multiple environments and drives to maintain that state for the cluster. The practice of GitOps can apply to both application delivery and operations and provides developers with a common toolchain.</p>&#13;
&#13;
<p>Weaveworks Flux was one of the first tools to enable the GitOps approach, and it’s the tool we will use throughout the rest of the chapter. Many new tools that have been released into the cloud native ecosystem are worth a look, such as Argo CD, from the folks at Intuit, which has also been widely adopted for the GitOps approach. We will dive more into the tooling available for GitOps later in the <a data-primary="GitOps" data-secondary="purpose of" data-startref="gitops-purpose" data-type="indexterm" id="id1064"/>chapter.</p>&#13;
&#13;
<p><a data-type="xref" href="#GitOps-Workflow">Figure 18-1</a> provides<a data-primary="GitOps" data-secondary="workflow" data-type="indexterm" id="gitops-workflow"/> a representation of a GitOps workflow. We have a Git repository that contains the application code and Kubernetes manifests for our application. The Flux agent is configured to watch the repo for any changes. When a developer commits a code change, the Flux agent will sync any new changes to the Kubernetes clusters.</p>&#13;
&#13;
<figure><div class="figure" id="GitOps-Workflow">&#13;
<img alt="GitOps Workflow" src="assets/kbp2_1801.png"/>&#13;
<h6><span class="label">Figure 18-1. </span>GitOps workflow</h6>&#13;
</div></figure>&#13;
&#13;
<p>When building your GitOps workflow, you should consider the&#13;
four core principals of GitOps defined by the <a href="https://oreil.ly/3Rz55">OpenGitOps Project</a>:</p>&#13;
<dl>&#13;
<dt>Declarative configuration</dt>&#13;
<dd>&#13;
<p>All configuration is stored in Git as declarative YAML files. This allows for a single source of truth for your cluster configuration.</p>&#13;
</dd>&#13;
<dt>Versioned configuration</dt>&#13;
<dd>&#13;
<p>All configuration is stored in Git, and all changes are tracked and versioned. This allows for easy auditing of changes and rollbacks.</p>&#13;
</dd>&#13;
<dt>Immutable configuration</dt>&#13;
<dd>&#13;
<p>All configuration is immutable. This means that once a change is made, it cannot be modified. This allows for a consistent state of the cluster.</p>&#13;
</dd>&#13;
<dt>Continuous state reconciliation</dt>&#13;
<dd>&#13;
<p>The cluster state is continuously reconciled with the state defined in Git. This allows for the cluster to be in a consistent <a data-primary="GitOps" data-secondary="workflow" data-startref="gitops-workflow" data-type="indexterm" id="id1065"/>state.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Why GitOps?" data-type="sect1"><div class="sect1" id="id149">&#13;
<h1>Why GitOps?</h1>&#13;
&#13;
<p>GitOps is <a data-primary="GitOps" data-secondary="benefits of" data-type="indexterm" id="gitops-benefits"/>a excellent way to manage your Kubernetes clusters, and it can be used to deploy applications to your cluster as well as manage cluster and application configuration. Before we talk about all the benefits, let’s first look at how we traditionally deployed and configured applications on Kubernetes.</p>&#13;
&#13;
<p><a data-type="xref" href="#Traditional-Deployment-Workflow">Figure 18-2</a> shows a traditional deployment workflow. We have a developer who is working on a new feature for an application. The developer will make changes to the application code and then build a new container image. Next, the developer will push the new container image to a container registry. The developer will then update the Kubernetes manifest to use the new container image, and then apply the changes to the cluster. This is a very manual process, and it can be very time consuming. Some of these steps can be automated with tools, but this can become complex as the number of applications and clusters <a data-primary="traditional deployment workflow" data-type="indexterm" id="id1066"/><a data-primary="deployments" data-secondary="traditional workflow" data-type="indexterm" id="id1067"/>grow.</p>&#13;
&#13;
<figure><div class="figure" id="Traditional-Deployment-Workflow">&#13;
<img alt="Traditional Deployment Workflow" src="assets/kbp2_1802.png"/>&#13;
<h6><span class="label">Figure 18-2. </span>Traditional deployment workflow</h6>&#13;
</div></figure>&#13;
&#13;
<p>This workflow can be very error prone, and it can be difficult to track down the source of the issue. It can also be difficult to roll back changes, as you will need to manually revert the changes to the Kubernetes manifest. It can also cause configuration drift, as users may make direct changes to the resources in Kubernetes. Controlling security access to the environment can also become complex with multiple pipelines and users needing access. Auditing of each interaction from change to deployment can also be difficult with multiple pipelines.</p>&#13;
&#13;
<p>We can solve these problems with the following benefits GitOps provides:</p>&#13;
<dl>&#13;
<dt>Declarative configuration</dt>&#13;
<dd>&#13;
<p>All configuration is stored in Git as declarative YAML files. This allows for a single source of truth. It also allows for easy auditing of changes using Git history. Developers will be accustomed to working with Git, so they will be familiar with the workflow.</p>&#13;
</dd>&#13;
<dt>Version controlled</dt>&#13;
<dd>&#13;
<p>Git repository supports immutability and version history. For example, using Git for the previously mentioned configuration will give you a single source from which everything for your application is driven. This allows you to easily track any changes made at any time. It allows you to look at all changes found in Git history and compare those changes.</p>&#13;
</dd>&#13;
<dt>Continuous reconciliation</dt>&#13;
<dd>&#13;
<p>The cluster state is continuously reconciled with the state defined in Git. It also allows for easy rollbacks, as you can simply revert the changes in Git. The system can automatically sync the same state in Git to your cluster. This allows for the cluster to be in a consistent state.</p>&#13;
</dd>&#13;
<dt>Security</dt>&#13;
<dd>&#13;
<p>When you use Git to manage applications deployed to Kubernetes, you gain a complete audit log of all changes to the cluster. All changes are made to the Git repository, and the GitOps agent can automatically reconcile any changes made directly to a Kubernetes resource. This provides a full audit trail of who changed what. It enables consistent operations and enhances security of the environment.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>While you may have a very automated CI/CD pipeline, you may still have some manual steps in your workflow. GitOps aims to solve these challenges by automating the workflow and providing a developer-centric<a data-primary="GitOps" data-secondary="benefits of" data-startref="gitops-benefits" data-type="indexterm" id="id1068"/> workflow.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="GitOps Repo Structure" data-type="sect1"><div class="sect1" id="Kubernetes-Deployment-Workflow">&#13;
<h1>GitOps Repo Structure</h1>&#13;
&#13;
<p>One of the<a data-primary="GitOps" data-secondary="repo structure" data-type="indexterm" id="gitops-repo-structure"/><a data-primary="repositories" data-secondary="GitOps structure" data-type="indexterm" id="repo-gitops-structure"/> first questions about GitOps is how to structure your Git repository. There are many different ways to structure your Git repository, but all come with their own pros and cons.</p>&#13;
&#13;
<p>Four common  strategies for structuring your Git repository are:</p>&#13;
<dl>&#13;
<dt>Single monorepo</dt>&#13;
<dd>&#13;
<p>All Kubernetes manifests and application code are stored in a single repository. This is the simple approach, but it becomes much more difficult as the company scales. This approach also does not allow for separation of concerns, as all teams’ source code and Kubernetes manifests will live in a single repository. This can work well for a smaller company, but you’ll quickly outgrow this approach as your company grows. Following is a sample of this type of repo layout structure:</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">├──<code class="w"> </code>app-x<code class="w"/>&#13;
│<code class="w">   </code>├──<code class="w"> </code>common<code class="w"/>&#13;
│<code class="w">   </code>└──<code class="w"> </code>deploy<code class="w"/>&#13;
│<code class="w">       </code>└──<code class="w"> </code>manifest<code class="w"/>&#13;
├──<code class="w"> </code>app-y<code class="w"/>&#13;
│<code class="w">   </code>├──<code class="w"> </code>prod<code class="w"/>&#13;
│<code class="w">   </code>└──<code class="w"> </code>staging<code class="w"/>&#13;
├──<code class="w"> </code>app-z<code class="w"/>&#13;
└──<code class="w"> </code>ops-team<code class="w"/>&#13;
<code class="w">    </code>├──<code class="w"> </code>flux<code class="w"/>&#13;
<code class="w">    </code>├──<code class="w"> </code>ingress<code class="w"/>&#13;
<code class="w">    </code>└──<code class="w"> </code>prometheus<code class="w"/></pre>&#13;
<dl>&#13;
<dt>Repo per team</dt>&#13;
<dd>&#13;
<p>Each team has its own repository, and the Kubernetes manifests are stored in the same repository. This approach allows for better organization and separation of concerns but becomes more difficult to manage as your application portfolio grows over time. Following is a sample of this type of repo layout structure:</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">├──<code class="w"> </code>ops-team<code class="w"/>&#13;
│<code class="w">   </code>├──<code class="w"> </code>elk<code class="w"/>&#13;
│<code class="w">   </code>├──<code class="w"> </code>flux<code class="w"/>&#13;
│<code class="w">   </code>└──<code class="w"> </code>prometheus<code class="w"/>&#13;
├──<code class="w"> </code>team-x<code class="w"/>&#13;
│<code class="w">   </code>└──<code class="w"> </code>app-x<code class="w"/>&#13;
│<code class="w">       </code>└──<code class="w"> </code>deploy<code class="w"/>&#13;
│<code class="w">           </code>└──<code class="w"> </code>manifest<code class="w"/>&#13;
└──<code class="w"> </code>team-y<code class="w"/>&#13;
<code class="w">    </code>├──<code class="w"> </code>prod<code class="w"/>&#13;
<code class="w">    </code>└──<code class="w"> </code>staging<code class="w"/></pre>&#13;
<dl>&#13;
<dt>Repo per application</dt>&#13;
<dd>&#13;
<p>Each application has its own repository, and the Kubernetes manifests are stored in the same repository. This approach allows for better organization and separation of concerns, as it can be locked down to read-only access for the team. The con of using this structure is not everything can be seen in one place. Following is a sample of this type of repo layout structure:</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">──<code class="w"> </code>ops-team-repo<code class="w"/>&#13;
│<code class="w">   </code>├──<code class="w"> </code>elk<code class="w"/>&#13;
│<code class="w">   </code>├──<code class="w"> </code>flux<code class="w"/>&#13;
│<code class="w">   </code>└──<code class="w"> </code>prometheus<code class="w"/></pre>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">──<code class="w"> </code>team-x-repo<code class="w"/>&#13;
│<code class="w">   </code>└──<code class="w"> </code>app-x<code class="w"/>&#13;
│<code class="w">       </code>└──<code class="w"> </code>deploy<code class="w"/>&#13;
│<code class="w">           </code>└──<code class="w"> </code>manifest<code class="w"/></pre>&#13;
<dl>&#13;
<dt>Branch per environment</dt>&#13;
<dd>&#13;
<p>Each environment has its own branch in the same repository. This approach allows you to promote environments with a simple Git merge. Promoting via a simple Git merge can lead to unwanted changes between environments and merge conflicts between environments. The downside to this is you will typically have a lot of branches, and it can be difficult to manage. This approach also doesn’t fit with templating tools such as Kustomize and Helm. Following is a sample of this type of repo layout structure:</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">--<code class="w"> </code>main<code class="w"/>&#13;
--<code class="w"> </code>staging<code class="w"/>&#13;
--<code class="w"> </code>QA<code class="w"/>&#13;
--<code class="w"> </code>dev<code class="w"/></pre>&#13;
&#13;
<p>Typically, you will want to assess your organization and team layout to decide which structure works best for you. Starting with a repo per team is a excellent starting point, as it’s a good middle ground that provides clear separation of concerns and easy<a data-primary="GitOps" data-secondary="repo structure" data-startref="gitops-repo-structure" data-type="indexterm" id="id1069"/><a data-primary="repositories" data-secondary="GitOps structure" data-startref="repo-gitops-structure" data-type="indexterm" id="id1070"/> repo management.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Managing Secrets" data-type="sect1"><div class="sect1" id="id150">&#13;
<h1>Managing Secrets</h1>&#13;
&#13;
<p>Secrets management <a data-primary="GitOps" data-secondary="secrets management" data-type="indexterm" id="gitops-secrets"/><a data-primary="secrets management" data-secondary="in GitOps" data-secondary-sortas="GitOps" data-type="indexterm" id="secret-mgmt-gitops"/>is a common challenge when implementing a GitOps workflow. There are many different ways to manage secrets, and the best approach will depend on your organization. Next we will dive into the five common approaches you can take with managing secrets in a GitOps way:</p>&#13;
<dl>&#13;
<dt>Store secrets directly in Git</dt>&#13;
<dd>&#13;
<p>This approach is the simplest, but it is not recommended. The problem with this approach is that you are storing plain text secrets in a repository that may be public. Even if your repository is internal and private, your are still storing the secrets in plain text. Multiple users may have access to this repo and will then have access to the secrets.</p>&#13;
</dd>&#13;
<dt>Bake secrets into container image</dt>&#13;
<dd>&#13;
<p>This approach is a little better than storing secrets in plain text in Git. The problem with this approach is baking secrets into the image will require you to rebuild the image each time secrets are rotated. It also doesn’t address the security concerns as multiple users may be able to pull the image and run it. This approach is also not recommended due to security concerns.</p>&#13;
</dd>&#13;
<dt>Use Kubernetes Secrets</dt>&#13;
<dd>&#13;
<p>This approach is<a data-primary="Kubernetes Secrets" data-type="indexterm" id="id1071"/> available directly in Kubernetes and provides an easy way to get started. The problem with this approach is that Kubernetes Secrets are not really secret. What we mean here is that Kubernetes Secrets look encrypted, but are actually just base64 encoded. This approach is also not recommended due to security concerns.</p>&#13;
</dd>&#13;
<dt>Use Sealed Secrets</dt>&#13;
<dd>&#13;
<p>Sealed Secrets is<a data-primary="Sealed Secrets" data-type="indexterm" id="id1072"/> a project by Bitnami. It has two components: a cluster controller and a client-side tool call kubeseal. The kubeseal utility uses asymmetric crypto to encrypt secrets that only the controller can decrypt. These secrets can then be stored in Git encrypted and can only be decrypted by the controller in your cluster. This is a recommended approach for managing secrets in a GitOps way.</p>&#13;
</dd>&#13;
<dt>Store secrets in a secret management tool</dt>&#13;
<dd>&#13;
<p>This approach allows you to store secrets in a secure location and then access them from your cluster. These secrets can be stored in an external secret management solution like HashiCorp Vault, Azure Keyvault, Google KMS, etc. This approach allows you to use existing solutions you may already have in place and continue with the same workflow. This approach is also a recommended approach for managing secrets in a GitOps way.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>While there are lot of different ways to manage secrets, the best approach will depend on your organization. As we discussed, Sealed Secrets and external secret management are the recommended approaches for managing<a data-primary="GitOps" data-secondary="secrets management" data-startref="gitops-secrets" data-type="indexterm" id="id1073"/><a data-primary="secrets management" data-secondary="in GitOps" data-secondary-sortas="GitOps" data-startref="secret-mgmt-gitops" data-type="indexterm" id="id1074"/> secrets.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up Flux" data-type="sect1"><div class="sect1" id="id151">&#13;
<h1>Setting Up Flux</h1>&#13;
&#13;
<p>Flux is a <a data-primary="GitOps" data-secondary="Flux configuration" data-type="indexterm" id="gitops-flux"/><a data-primary="Flux" data-secondary="configuring" data-type="indexterm" id="flux-config"/><a data-primary="configuring" data-secondary="Flux" data-type="indexterm" id="config-flux"/>Kubernetes operator that watches your Git repository for changes and automatically applies those changes to your cluster. Flux is a mature tool for implementing GitOps in your cluster, and it is the tool we will use throughout the rest of the chapter.</p>&#13;
&#13;
<p>First, we’ll start by getting<a data-primary="minikube, installing" data-type="indexterm" id="id1075"/><a data-primary="installing" data-secondary="minikube" data-type="indexterm" id="id1076"/> minikube set up to deploy Flux. You can install minikube from the <a href="https://oreil.ly/GMPMl">minikube website</a>. We are using Macs so we’ll use <code>brew</code> to install minikube:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">brew<code class="w"> </code>install<code class="w"> </code>minikube<code class="w"/></pre>&#13;
&#13;
<p>Now we’ll install Flux and prepare our cluster to sync to a Git repository. We’ll use the <code>flux</code> CLI to install Flux. You can install the <code>flux</code> CLI from the <a href="https://oreil.ly/h2_hQ">flux website</a>.</p>&#13;
&#13;
<p>Install Flux CLI:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">brew<code class="w"> </code>install<code class="w"> </code>fluxcd/tap/flux<code class="w"/></pre>&#13;
&#13;
<p>Export your GitHub token:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="nb">export</code><code class="w"> </code><code class="nv">GITHUB_TOKEN</code><code class="o">=</code>&lt;your-token&gt;<code class="w"/>&#13;
<code class="nb">export</code><code class="w"> </code><code class="nv">GITHUB_USER</code><code class="o">=</code>&lt;your-username&gt;<code class="w"/></pre>&#13;
&#13;
<p class="pagebreak-before">Check that your cluster can install Flux:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">flux<code class="w"> </code>check<code class="w"> </code>--pre<code class="w"/></pre>&#13;
&#13;
<p>Bootstrap Flux:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">flux<code class="w"> </code>bootstrap<code class="w"> </code>github<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--owner<code class="o">=</code><code class="nv">$GITHUB_USER</code><code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--repository<code class="o">=</code>kbp-flux<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--branch<code class="o">=</code>main<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--path<code class="o">=</code>./clusters/prod<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--personal<code class="w"/></pre>&#13;
&#13;
<p>The preceding <code>bootstrap</code> command will create a Git repo called kbp-flux in your GitHub account. It will also create a <code>main</code> branch and a <em>clusters/prod</em> directory. The <em>clusters/prod</em> directory will contain the Flux components that will be deployed to your cluster. The <em>clusters/prod</em> directory will also contain a <em>gotk-components.yaml</em> file that will be used to deploy the Flux components to your cluster. This also installs the Flux components into the <code>flux-system</code> namespace.</p>&#13;
&#13;
<p>Now let’s check the <code>flux-system</code> namespace to see if the Flux components are deployed:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">kubectl<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>-n<code class="w"> </code>flux-system<code class="w"/></pre>&#13;
&#13;
<p>You should see the following output:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">NAME<code class="w">                                      </code>READY<code class="w">   </code>STATUS<code class="w">    </code>RESTARTS<code class="w">   </code>AGE<code class="w"/>&#13;
helm-controller-8664d9dcfc-4gd2h<code class="w">          </code><code class="m">1</code>/1<code class="w">     </code>Running<code class="w">   </code><code class="m">0</code><code class="w">          </code>6m30s<code class="w"/>&#13;
kustomize-controller-9888f965-ld5g6<code class="w">       </code><code class="m">1</code>/1<code class="w">     </code>Running<code class="w">   </code><code class="m">0</code><code class="w">          </code>6m30s<code class="w"/>&#13;
notification-controller-b6d8458c7-vjb86<code class="w">   </code><code class="m">1</code>/1<code class="w">     </code>Running<code class="w">   </code><code class="m">0</code><code class="w">          </code>6m30s<code class="w"/>&#13;
source-controller-5b68b64c65-pj2tn<code class="w">        </code><code class="m">1</code>/1<code class="w">     </code>Running<code class="w">   </code><code class="m">0</code><code class="w">          </code>6m30s<code class="w"/></pre>&#13;
&#13;
<p>Now let’s clone the repo it created to our local machine:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">git<code class="w"> </code>clone<code class="w"> </code>https://github.com/<code class="nv">$GITHUB_USER</code>/kbp-flux<code class="w"/></pre>&#13;
&#13;
<p>Next we’ll add a Flux configuration to our repo and use a public repository on GitHub. We’ll use a sample application created by Stefan Prodan from Weaveworks.</p>&#13;
&#13;
<p>Let’s create a Git repository manifest pointing to the apps repository’s main branch:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">flux<code class="w"> </code>create<code class="w"> </code><code class="nb">source</code><code class="w"> </code>git<code class="w"> </code>podinfo<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--url<code class="o">=</code>https://github.com/stefanprodan/podinfo<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--branch<code class="o">=</code>master<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--interval<code class="o">=</code>30s<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--export<code class="w"> </code>&gt;<code class="w"> </code>./clusters/prod/podinfo-source.yaml<code class="w"/></pre>&#13;
&#13;
<p>Then we’ll configure Flux to deploy the application and apply a Kustomize configuration to the application:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">flux<code class="w"> </code>create<code class="w"> </code>kustomization<code class="w"> </code>podinfo<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--target-namespace<code class="o">=</code>default<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--source<code class="o">=</code>podinfo<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--path<code class="o">=</code><code class="s2">"./kustomize"</code><code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--prune<code class="o">=</code><code class="nb">true</code><code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--interval<code class="o">=</code>5m<code class="w"> </code><code class="se">\</code>&#13;
<code class="w">  </code>--export<code class="w"> </code>&gt;<code class="w"> </code>./clusters/prod/podinfo-kustomization.yaml<code class="w"/></pre>&#13;
&#13;
<p>Now we’ll push the changes to our repo:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="w">    </code>git<code class="w"> </code>add<code class="w"> </code>-A<code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code>git<code class="w"> </code>commit<code class="w"> </code>-m<code class="w"> </code><code class="s2">"Add podinfo Kustomization"</code><code class="w"/>&#13;
&#13;
<code class="w">    </code>git<code class="w"> </code>push<code class="w"/></pre>&#13;
&#13;
<p>We can seeing this being applied by using the Flux CLI:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">flux<code class="w"> </code>get<code class="w"> </code>kustomizations<code class="w"/></pre>&#13;
&#13;
<p>You should see the following output:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">flux<code class="w"> </code>get<code class="w"> </code>kustomizations<code class="w"> </code>--watch<code class="w"/>&#13;
NAME<code class="w">         </code>REVISION<code class="w">              </code>SUSPENDED<code class="w">  </code>READY<code class="w">  </code>MESSAGE<code class="w"/>&#13;
flux-system<code class="w">  </code>main@sha1:9c3fb6f1<code class="w">    </code>False<code class="w">      </code>True<code class="w">   </code>Applied<code class="w"> </code>revision:<code class="w"> </code>main@sh...<code class="w"/>&#13;
podinfo<code class="w">      </code>master@sha1:1abc44f0<code class="w">  </code>False<code class="w">      </code>True<code class="w">   </code>Applied<code class="w"> </code>revision:<code class="w"> </code>master@...<code class="w"/></pre>&#13;
&#13;
<p>We can see the resources have been deployed to our cluster:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">kubectl<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>-n<code class="w"> </code>default<code class="w"/></pre>&#13;
&#13;
<p>Any changes made to the podinfo Kubernetes manifests in the main branch are now reflected in your cluster automatically.</p>&#13;
&#13;
<p>We have now set up Flux in our cluster, bootstrapped it to a Git repository, and configured Flux to deploy an application. We can now start to use Flux to manage our cluster.</p>&#13;
&#13;
<p>This is a very basic example of how to get Flux set up, and if you want a deeper dive into Flux, you <a data-primary="GitOps" data-secondary="Flux configuration" data-startref="gitops-flux" data-type="indexterm" id="id1077"/><a data-primary="Flux" data-secondary="configuring" data-startref="flux-config" data-type="indexterm" id="id1078"/><a data-primary="configuring" data-secondary="Flux" data-startref="config-flux" data-type="indexterm" id="id1079"/>can check out the <a href="https://oreil.ly/F5D2p">Flux documentation</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="GitOps Tooling" data-type="sect1"><div class="sect1" id="id152">&#13;
<h1>GitOps Tooling</h1>&#13;
&#13;
<p>Many<a data-primary="GitOps" data-secondary="tools for" data-type="indexterm" id="gitops-tools"/> different tools can be used to implement GitOps in your cluster. In this section, we will go over some of the most popular.</p>&#13;
&#13;
<p>When evaluating tools for GitOps, you should consider ease of use, enterprise features, and extensibility. Listed next are both open source and commercial tools that can be used to implement GitOps in your cluster:</p>&#13;
<dl>&#13;
<dt>Flux</dt>&#13;
<dd>&#13;
<p>Flux is <a data-primary="Flux" data-secondary="purpose of" data-type="indexterm" id="id1080"/>a Kubernetes operator that watches your Git repository for changes and automatically applies those changes to your cluster. Flux is a mature tool for implementing GitOps in your cluster. Weaveworks also provides a hosted version of Flux. Flux is currently a CNCF graduated project.</p>&#13;
</dd>&#13;
<dt>ArgoCD</dt>&#13;
<dd>&#13;
<p>Argo CD is<a data-primary="ArgoCD" data-type="indexterm" id="id1081"/> an open source GitOps continuous delivery tool. It monitors your cluster and your declaratively defined infrastructure stored in a Git repository and resolves differences between the two—effectively automating an application deployment. ArgoCD is currently a CNCF graduated project.</p>&#13;
</dd>&#13;
<dt>Codefresh</dt>&#13;
<dd>&#13;
<p>Codefresh is<a data-primary="Codefresh" data-type="indexterm" id="id1082"/> a CI/CD platform that can be used to implement GitOps in your cluster. Codefresh provides a hosted platform that provides ArgoCD as a service.</p>&#13;
</dd>&#13;
<dt>Harness</dt>&#13;
<dd>&#13;
<p>Harness <a data-primary="Harness" data-type="indexterm" id="id1083"/>is a CI/CD platform that can be used to implement GitOps in your cluster. Harness is a mature tool for implementing GitOps in your cluster and provides a hosted version. Harness is geared toward enterprise customers and provides a full suite of continuous delivery features.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="GitOps Best Practices" data-type="sect1"><div class="sect1" id="id251">&#13;
<h1>GitOps Best Practices</h1>&#13;
&#13;
<p>Consider <a data-primary="GitOps" data-secondary="best practices" data-type="indexterm" id="id1084"/><a data-primary="best practices" data-secondary="GitOps" data-type="indexterm" id="id1085"/>the following best practices when using GitOps with Kubernetes:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Start with a small application and then scale your efforts for managing everything with a GitOps model. This will allow you to build confidence in your GitOps implementation.</p>&#13;
</li>&#13;
<li>&#13;
<p>Evaluate tools that fit your requirements or start with proven OSS tools like Flux or ArgoCD.</p>&#13;
</li>&#13;
<li>&#13;
<p>Avoid using branches for your repository layout, as this is the most complex and error-prone repository layout.</p>&#13;
</li>&#13;
<li>&#13;
<p>Start with a folder per environment, as this provides flexibility and allows you to use tools like Kustomize or Helm for templating.</p>&#13;
</li>&#13;
<li>&#13;
<p>Utilize Sealed Secrets or an external secrets provider to manage secrets in your cluster.</p>&#13;
</li>&#13;
<li>&#13;
<p>Remember GitOps is a process and not a tool, and your existing tool set may fit your needs.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id387">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter, we went over what GitOps is and how it can be used to manage your Kubernetes cluster. We also went over some of the tools that can be used to implement GitOps in your cluster. When looking to see if GitOps is right for you, you should consider what problems you are trying to solve and what your requirements are. If GitOps help solves these problems for you, then looking at a tool like Flux or ArgoCD is a good place to start.</p>&#13;
</div></section>&#13;
</div></section></body></html>