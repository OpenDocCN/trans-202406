["```\n    orders.insert_one({\"sku\": \"abc123\", \"qty\": 100}, session=session)\n    inventory.update_one({\"sku\": \"abc123\", \"qty\": {\"$gte\": 100}},\n                         {\"$inc\": {\"qty\": -100}}, session=session)\n```", "```\n# Define the uriString using the DNS Seedlist Connection Format \n# for the connection\nuri = 'mongodb+srv://server.example.com/'\nclient = MongoClient(uriString)\n\nmy_wc_majority = WriteConcern('majority', wtimeout=1000)\n\n# Prerequisite / Step 0: Create collections, if they don't already exist. \n# CRUD operations in transactions must be on existing collections.\n\nclient.get_database( \"webshop\",\n                     write_concern=my_wc_majority).orders.insert_one({\"sku\":\n                     \"abc123\", \"qty\":0})\nclient.get_database( \"webshop\",\n                     write_concern=my_wc_majority).inventory.insert_one(\n                     {\"sku\": \"abc123\", \"qty\": 1000})\n\n# Step 1: Define the operations and their sequence within the transaction\ndef update_orders_and_inventory(my_session):\n    orders = session.client.webshop.orders\n    inventory = session.client.webshop.inventory\n\n    with session.start_transaction(\n            read_concern=ReadConcern(\"snapshot\"),\n            write_concern=WriteConcern(w=\"majority\"),\n            read_preference=ReadPreference.PRIMARY):\n\n        orders.insert_one({\"sku\": \"abc123\", \"qty\": 100}, session=my_session)\n        inventory.update_one({\"sku\": \"abc123\", \"qty\": {\"$gte\": 100}},\n                             {\"$inc\": {\"qty\": -100}}, session=my_session)\n        commit_with_retry(my_session)\n\n# Step 2: Attempt to run and commit transaction with retry logic\ndef commit_with_retry(session):\n    while True:\n        try:\n            # Commit uses write concern set at transaction start.\n            session.commit_transaction()\n            print(\"Transaction committed.\")\n            break\n        except (ConnectionFailure, OperationFailure) as exc:\n            # Can retry commit\n            if exc.has_error_label(\"UnknownTransactionCommitResult\"):\n                print(\"UnknownTransactionCommitResult, retrying \"\n                      \"commit operation ...\")\n                continue\n            else:\n                print(\"Error during commit ...\")\n                raise\n\n# Step 3: Attempt with retry logic to run the transaction function txn_func\ndef run_transaction_with_retry(txn_func, session):\n    while True:\n        try:\n            txn_func(session)  # performs transaction\n            break\n        except (ConnectionFailure, OperationFailure) as exc:\n            # If transient error, retry the whole transaction\n            if exc.has_error_label(\"TransientTransactionError\"):\n                print(\"TransientTransactionError, retrying transaction ...\")\n                continue\n            else:\n                raise\n\n# Step 4: Start a session.\nwith client.start_session() as my_session:\n\n# Step 5: Call the function 'run_transaction_with_retry' passing it the function\n# to call 'update_orders_and_inventory' and the session 'my_session' to associate\n# with this transaction.\n\n    try:\n        run_transaction_with_retry(update_orders_and_inventory, my_session)\n    except Exception as exc:\n        # Do something with error. The error handling code is not\n        # implemented for you with the Core API.\n        raise\n```", "```\n# Define the uriString using the DNS Seedlist Connection Format \n# for the connection\nuriString = 'mongodb+srv://server.example.com/'\nclient = MongoClient(uriString)\n\nmy_wc_majority = WriteConcern('majority', wtimeout=1000)\n\n# Prerequisite / Step 0: Create collections, if they don't already exist.\n# CRUD operations in transactions must be on existing collections.\n\nclient.get_database( \"webshop\",\n                     write_concern=my_wc_majority).orders.insert_one({\"sku\":\n                     \"abc123\", \"qty\":0})\nclient.get_database( \"webshop\",\n                     write_concern=my_wc_majority).inventory.insert_one(\n                     {\"sku\": \"abc123\", \"qty\": 1000})\n\n# Step 1: Define the callback that specifies the sequence of operations to\n# perform inside the transactions.\n\ndef callback(my_session):\n    orders = my_session.client.webshop.orders\n    inventory = my_session.client.webshop.inventory\n\n    # Important:: You must pass the session variable 'my_session' to \n    # the operations.\n\n    orders.insert_one({\"sku\": \"abc123\", \"qty\": 100}, session=my_session)\n    inventory.update_one({\"sku\": \"abc123\", \"qty\": {\"$gte\": 100}},\n                         {\"$inc\": {\"qty\": -100}}, session=my_session)\n\n#. Step 2: Start a client session.\n\nwith client.start_session() as session:\n\n# Step 3: Use with_transaction to start a transaction, execute the callback,\n# and commit (or abort on error).\n\n    session.with_transaction(callback,\n                             read_concern=ReadConcern('local'),\n                             write_concern=my_write_concern_majority,\n                             read_preference=ReadPreference.PRIMARY)\n}\n```"]