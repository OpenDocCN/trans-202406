<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Type Modifiers"><div class="chapter" id="type_modifiers_chapter">
<h1><span class="label">Chapter 9. </span>Type Modifiers</h1>

<blockquote>
<p>Types of types from types.</p>

<p>“It’s turtles all the way down,”</p>

<p>Anders likes to say.</p></blockquote>

<p>By now you’ve read all about how the TypeScript type system works with existing JavaScript constructs such as arrays, classes, and objects.
For this chapter and <a data-type="xref" data-xrefstyle="chap-num-title" href="ch10.xhtml#generics_chapter">Chapter 10, “Generics”</a>, I’m going to take a step further into the type system itself and show features that focus on writing more precise types, as well as types based on other types.</p>






<section data-type="sect1" data-pdf-bookmark="Top Types"><div class="sect1" id="idm45584680398240">
<h1>Top Types</h1>

<p>I <a data-type="indexterm" data-primary="types" data-secondary="top types" id="type-top"/><a data-type="indexterm" data-primary="top types" id="top-type"/>mentioned the concept of a <em>bottom type</em> back in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.xhtml#objects">Chapter 4, “Objects”</a> to describe a type that can have no possible values and can’t be reached.
It stands to reason that the opposite might also exist in type theory.
It does!</p>

<p>A <em>top type</em>, or universal type, is a type that can represent any possible value in a system.
Values of all other types can be provided to a location whose type is a top type.
In other words, all types are assignable to a top type.</p>








<section data-type="sect2" data-pdf-bookmark="any, Again"><div class="sect2" id="idm45584680391568">
<h2>any, Again</h2>

<p>The<a data-type="indexterm" data-primary="any type" data-secondary="described" id="any-type"/> <code>any</code> type can act as a top type, in that any type can be provided to a location of type <code>any</code>.
<code>any</code> is generally used when a location is allowed to accept data of any type, such as the parameters to <code>console.log</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">anyValue</code>: <code class="nx">any</code><code class="p">;</code>
<code class="nx">anyValue</code> <code class="o">=</code> <code class="s2">"Lucille Ball"</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="nx">anyValue</code> <code class="o">=</code> <code class="mi">123</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">anyValue</code><code class="p">);</code> <code class="c1">// Ok</code></pre>

<p>The problem with <code>any</code> is that it explicitly tells TypeScript not to perform type checking on that value’s assignability or members.
That lack of safety is useful if you’d like to quickly bypass TypeScript’s type checker, but the disabling of type checking reduces TypeScript’s usefulness for that value.</p>

<p>For example, the <code>name.toUpperCase()</code> call below definitely will crash, but because <code>name</code> is declared as <code>any</code>, TypeScript does not report a type complaint:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">greetComedian</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">any</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// No type error...</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Announcing </code><code class="si">${</code><code class="nx">name</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">greetComedian</code><code class="p">({</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Bea Arthur"</code> <code class="p">});</code>
    <code class="c1">// Runtime error: name.toUpperCase is not a function</code></pre>

<p>If you want to indicate that a value can be anything, the <code>unknown</code> type is much<a data-type="indexterm" data-primary="any type" data-secondary="described" data-startref="any-type" id="idm45584680306720"/> safer.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="unknown"><div class="sect2" id="idm45584680305312">
<h2>unknown</h2>

<p>The<a data-type="indexterm" data-primary="unknown type" data-secondary="described" id="unknown-type"/> <code>unknown</code> type in TypeScript is its true top type.
<code>unknown</code> is similar to <code>any</code> in that all objects may be passed to locations of type <code>unknown</code>.
The key difference with <code>unknown</code> is that TypeScript is much more restrictive about values of type <code>unknown</code>:</p>

<ul>
<li>
<p>TypeScript does not allow directly accessing properties of <code>unknown</code> typed values.</p>
</li>
<li>
<p><code>unknown</code> is not assignable to types that are not a top type (<code>any</code> or <code>unknown</code>).</p>
</li>
</ul>

<p>Attempting to access a property of an <code>unknown</code> typed value, as in the following snippet, will cause TypeScript to report a type error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">greetComedian</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Announcing </code><code class="si">${</code><code class="nx">name</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
    <code class="c1">//                        ~~~~</code>
    <code class="c1">// Error: Object is of type 'unknown'.</code>
<code class="p">}</code></pre>

<p>The only way TypeScript will allow code to access members on a name of type <code>unknown</code> is if the value’s type is narrowed, such as using <code>instanceof</code> or <code>typeof</code>, or with a type assertion.</p>

<p>This code snippet uses <code>typeof</code> to narrow <code>name</code> from <code>unknown</code> to <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">greetComedianSafety</code><code class="p">(</code><code class="nx">name</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Announcing </code><code class="si">${</code><code class="nx">name</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code> <code class="c1">// Ok</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Well, I'm off."</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="nx">greetComedianSafety</code><code class="p">(</code><code class="s2">"Betty White"</code><code class="p">);</code> <code class="c1">// Logs: 4</code>
<code class="nx">greetComedianSafety</code><code class="p">({});</code> <code class="c1">// Does not log</code></pre>

<p>Those two restrictions make <code>unknown</code> a much safer type to use than <code>any</code>.
You should generally prefer using <code>unknown</code> instead of <code>any</code> when<a data-type="indexterm" data-primary="types" data-secondary="top types" data-startref="type-top" id="idm45584680184176"/><a data-type="indexterm" data-primary="top types" data-startref="top-type" id="idm45584680182896"/><a data-type="indexterm" data-primary="unknown type" data-secondary="described" data-startref="unknown-type" id="idm45584680181952"/> possible.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Type Predicates"><div class="sect1" id="idm45584680129168">
<h1>Type Predicates</h1>

<p>I’ve <a data-type="indexterm" data-primary="type predicates" id="type-predicate"/><a data-type="indexterm" data-primary="functions" data-secondary="type predicates" id="function-type-predicate"/>previously shown you how JavaScript constructs such as <code>instanceof</code> and <code>typeof</code> can be used to narrow types.
That’s all fine and good for directly using that limited set of checks, but it gets lost if you wrap the logic with a function.</p>

<p>For example, this <code>isNumberOrString</code> function takes in a value and returns a boolean indicating whether the value is a <code>number</code> or <code>string</code>.
We as humans can infer that the <code>value</code> inside the <code>if</code> statement must therefore be one of those two types since <code>isNumberOrString(value)</code> returned true, but TypeScript does not.
All it knows is that <code>isNumberOrString</code> returns a boolean—not that it’s meant to narrow the type of an argument:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">isNumberOrString</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">unknown</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="s1">'number'</code><code class="p">,</code> <code class="s1">'string'</code><code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logValueIfExists</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">number</code> <code class="o">|</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">null</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">isNumberOrString</code><code class="p">(</code><code class="nx">value</code><code class="p">))</code> <code class="p">{</code>
        <code class="c1">// Type of value: number | string | null | undefined</code>
        <code class="nx">value</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>
        <code class="c1">// Error: Object is possibly undefined.</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Value does not exist:"</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>TypeScript has a special syntax for functions that return a boolean meant to indicate whether an argument is a particular type.
This is referred to as a <em>type predicate</em>, also sometimes called a “user-defined type guard”: you the developer are creating your own type guard akin to <code>instanceof</code> or <code>typeof</code>.
Type predicates are commonly used to indicate whether an argument passed in as a parameter is a more specific type than the parameter’s.</p>

<p>Type predicate’s return types can be declared as the name of a parameter, the <code>is</code> keyword, and some type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">typePredicate</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">WideType</code><code class="p">)</code><code class="o">:</code> <code class="nx">input</code> <code class="nx">is</code> <code class="nx">NarrowType</code><code class="p">;</code></pre>

<p>We can change the previous example’s helper function to have an explicit return type that explicitly states <code>value is number | string</code>.
TypeScript will then be able to infer that blocks of code only reachable if <code>value is number | string</code> is <code>true</code> must have a <code>value</code> of type <code>number | string</code>.
Additionally, blocks of code only reachable if <code>value is number | string</code> is <code>false</code> must have a <code>value</code> of type <code>null | undefined</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">isNumberOrString</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">unknown</code><code class="p">)</code><code class="o">:</code> <code class="nx">value</code> <code class="nx">is</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code> <code class="p">{</code>
    <code class="k">return</code> <code class="p">[</code><code class="s1">'number'</code><code class="p">,</code> <code class="s1">'string'</code><code class="p">].</code><code class="nx">includes</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">logValueIfExists</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">number</code> <code class="o">|</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">null</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">isNumberOrString</code><code class="p">(</code><code class="nx">value</code><code class="p">))</code> <code class="p">{</code>
        <code class="c1">// Type of value: number | string</code>
        <code class="nx">value</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code> <code class="c1">// Ok</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="c1">// Type of value: null | undefined</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"value does not exist:"</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>You can think of a type predicate as returning not just a boolean, but also an indication that the argument was that more specific type.</p>

<p>Type predicates are often used to check whether an object already known to be an instance of one interface is an instance of a more specific interface.</p>

<p>Here, the <code>StandupComedian</code> interface contains additional information on top of 
<span class="keep-together"><code>Comedian</code></span>.
The <code>isStandupComedian</code> type guard can be used to check whether a general <code>Comedian</code> is specifically a <code>StandupComedian</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Comedian</code> <code class="p">{</code>
    <code class="nx">funny</code>: <code class="nx">boolean</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">StandupComedian</code> <code class="kr">extends</code> <code class="nx">Comedian</code> <code class="p">{</code>
    <code class="nx">routine</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">isStandupComedian</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">Comedian</code><code class="p">)</code><code class="o">:</code> <code class="nx">value</code> <code class="nx">is</code> <code class="nx">StandupComedian</code> <code class="p">{</code>
    <code class="k">return</code> <code class="s1">'routine'</code> <code class="k">in</code> <code class="nx">value</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">workWithComedian</code><code class="p">(</code><code class="nx">value</code>: <code class="nx">Comedian</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">isStandupComedian</code><code class="p">(</code><code class="nx">value</code><code class="p">))</code> <code class="p">{</code>
        <code class="c1">// Type of value: StandupComedian</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">.</code><code class="nx">routine</code><code class="p">);</code> <code class="c1">// Ok</code>
    <code class="p">}</code>

    <code class="c1">// Type of value: Comedian</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">value</code><code class="p">.</code><code class="nx">routine</code><code class="p">);</code>
    <code class="c1">//                ~~~~~~~</code>
    <code class="c1">// Error: Property 'routine' does not exist on type 'Comedian'.</code>
<code class="p">}</code></pre>

<p>Be warned: because type predicates also narrow types in the false case, you might get surprising results if a type predicate checks more than just the type of its input.</p>

<p>This <code>isLongString</code> type predicate returns <code>false</code> if its <code>input</code> parameter is <code>undefined</code> or a <code>string</code> with a length less than <code>7</code>.
As a result, the <code>else</code> statement (its false case) is narrowed to thinking <code>text</code> must be <a data-type="indexterm" data-primary="type predicates" data-startref="type-predicate" id="idm45584679777344"/><a data-type="indexterm" data-primary="functions" data-secondary="type predicates" data-startref="function-type-predicate" id="idm45584679776336"/>type <code>undefined</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">isLongString</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">)</code><code class="o">:</code> <code class="nx">input</code> <code class="nx">is</code> <code class="kt">string</code> <code class="p">{</code>
    <code class="k">return</code> <code class="o">!!</code><code class="p">(</code><code class="nx">input</code> <code class="o">&amp;&amp;</code> <code class="nx">input</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;=</code> <code class="mi">7</code><code class="p">);</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">workWithText</code><code class="p">(</code><code class="nx">text</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">isLongString</code><code class="p">(</code><code class="nx">text</code><code class="p">))</code> <code class="p">{</code>
        <code class="c1">// Type of text: string</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Long text:"</code><code class="p">,</code> <code class="nx">text</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="c1">// Type of text: undefined</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Short text:"</code><code class="p">,</code> <code class="nx">text</code><code class="o">?</code><code class="p">.</code><code class="nx">length</code><code class="p">);</code>
        <code class="c1">//                               ~~~~~~</code>
        <code class="c1">// Error: Property 'length' does not exist on type 'never'.</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Type predicates that do more than verify the type of a property or value are easy to misuse.
I generally recommend avoiding them when possible.
Simpler type predicates are sufficient for most cases.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Type Operators"><div class="sect1" id="idm45584680128576">
<h1>Type Operators</h1>

<p>Not <a data-type="indexterm" data-primary="type operators" data-secondary="purpose of" id="idm45584679663072"/>all types can be represented using only a keyword or a name of an existing type.
It can sometimes be necessary to create a new type that combines both, performing some transformation on the properties of an existing type.</p>








<section data-type="sect2" data-pdf-bookmark="keyof"><div class="sect2" id="idm45584679661808">
<h2>keyof</h2>

<p>JavaScript <a data-type="indexterm" data-primary="type operators" data-secondary="keyof" id="type-operator-keyof"/><a data-type="indexterm" data-primary="keyof type operator" data-secondary="described" id="keyof"/>objects can have members retrieved using dynamic values, which are commonly (but not necessarily) <code>string</code> typed.
Representing these keys in the type system can be tricky.
Using a catchall primitive such as <code>string</code> would allow invalid keys for the container value.</p>

<p>That’s why TypeScript when using stricter configuration settings—covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>—would report an error on the <code>ratings[key]</code> as seen in the next example.
Type <code>string</code> allows values not allowed as properties on the <code>Ratings</code> interface, and <code>Ratings</code> doesn’t declare an index signature to allow any <code>string</code> keys:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Ratings</code> <code class="p">{</code>
    <code class="nx">audience</code>: <code class="nx">number</code><code class="p">;</code>
    <code class="nx">critics</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">getRating</code><code class="p">(</code><code class="nx">ratings</code>: <code class="nx">Ratings</code><code class="p">,</code> <code class="nx">key</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">ratings</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>
    <code class="c1">//     ~~~~~~~~~~~</code>
    <code class="c1">// Error: Element implicitly has an 'any' type because expression</code>
    <code class="c1">// of type 'string' can't be used to index type 'Ratings'.</code>
    <code class="c1">//   No index signature with a parameter of</code>
    <code class="c1">//   type 'string' was found on type 'Ratings'.</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">ratings</code>: <code class="nx">Ratings</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">audience</code>: <code class="nx">66</code><code class="p">,</code> <code class="nx">critic</code>: <code class="nx">84</code> <code class="p">};</code>

<code class="nx">getRating</code><code class="p">(</code><code class="nx">ratings</code><code class="p">,</code> <code class="s1">'audience'</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">getRating</code><code class="p">(</code><code class="nx">ratings</code><code class="p">,</code> <code class="s1">'not valid'</code><code class="p">);</code> <code class="c1">// Ok, but shouldn't be</code></pre>

<p>Another option would be to use a type union of literals for the allowed keys.
That would be more accurate in properly restricting to only the keys that exist on the container value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">getRating</code><code class="p">(</code><code class="nx">ratings</code>: <code class="nx">Ratings</code><code class="p">,</code> <code class="nx">key</code><code class="o">:</code> <code class="s1">'audience'</code> <code class="o">|</code> <code class="s1">'critic'</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">ratings</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code> <code class="c1">// Ok</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">ratings</code>: <code class="nx">Ratings</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">audience</code>: <code class="nx">66</code><code class="p">,</code> <code class="nx">critic</code>: <code class="nx">84</code> <code class="p">};</code>

<code class="nx">getCountLiteral</code><code class="p">(</code><code class="nx">ratings</code><code class="p">,</code> <code class="s1">'audience'</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">getCountLiteral</code><code class="p">(</code><code class="nx">ratings</code><code class="p">,</code> <code class="s1">'not valid'</code><code class="p">);</code>
<code class="c1">//                       ~~~~~~~~~~~</code>
<code class="c1">// Error: Argument of type '"not valid"' is not</code>
<code class="c1">// assignable to parameter of type '"audience" | "critic"'.</code></pre>

<p>However, what if the interface has dozens or more members?
You would have to type out each of those members’ keys into the union type and keep them up-to-date.
What a pain.</p>

<p>TypeScript instead provides a <code>keyof</code> operator that takes in an existing type and gives back a union of all the keys allowed on that type.
Place it in front of the name of a type wherever you might use a type, such as a type annotation.</p>

<p>Here, <code>keyof Ratings</code> is equivalent to <code>'audience' | 'critic'</code> but is much quicker to write out and won’t need to be manually updated if the <code>Ratings</code> interface ever <a data-type="indexterm" data-primary="type operators" data-secondary="keyof" data-startref="type-operator-keyof" id="idm45584679487056"/><a data-type="indexterm" data-primary="keyof type operator" data-secondary="described" data-startref="keyof" id="idm45584679485776"/>changes:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">getCountKeyof</code><code class="p">(</code><code class="nx">ratings</code>: <code class="nx">Ratings</code><code class="p">,</code> <code class="nx">key</code>: <code class="nx">keyof</code> <code class="nx">Ratings</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nx">ratings</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code> <code class="c1">// Ok</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">ratings</code>: <code class="nx">Ratings</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">audience</code>: <code class="nx">66</code><code class="p">,</code> <code class="nx">critic</code>: <code class="nx">84</code> <code class="p">};</code>

<code class="nx">getCountKeyof</code><code class="p">(</code><code class="nx">ratings</code><code class="p">,</code> <code class="s1">'audience'</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">getCountKeyof</code><code class="p">(</code><code class="nx">ratings</code><code class="p">,</code> <code class="s1">'not valid'</code><code class="p">);</code>
<code class="c1">//                     ~~~~~~~~~~~</code>
<code class="c1">// Error: Argument of type '"not valid"' is not</code>
<code class="c1">// assignable to parameter of type 'keyof Ratings'.</code></pre>

<p><code>keyof</code> is a great feature for creating union types based on the keys of existing types.
It also combines well with other type operators in TypeScript, allowing for some very nifty patterns you’ll see later in this chapter and <a data-type="xref" data-xrefstyle="chap-num-title" href="ch15.xhtml#type_operations">Chapter 15, “Type Operations”</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="typeof"><div class="sect2" id="idm45584679661216">
<h2>typeof</h2>

<p>Another<a data-type="indexterm" data-primary="type operators" data-secondary="typeof" id="type-operator-typeof"/><a data-type="indexterm" data-primary="typeof operator" data-secondary="described" id="typeof"/> type operator provided by TypeScript is <code>typeof</code>.
It gives back the type of a provided value.
This can be useful if the value’s type would be annoyingly complex to write manually.</p>

<p>Here, the <code>adaptation</code> variable is declared as being the same type as <code>original</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">original</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">medium</code><code class="o">:</code> <code class="s2">"movie"</code><code class="p">,</code>
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Mean Girls"</code><code class="p">,</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">adaptation</code>: <code class="nx">typeof</code> <code class="nx">original</code><code class="p">;</code>

<code class="k">if</code> <code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">adaptation</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">original</code><code class="p">,</code> <code class="nx">medium</code><code class="o">:</code> <code class="s2">"play"</code> <code class="p">};</code> <code class="c1">// Ok</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="nx">adaptation</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">original</code><code class="p">,</code> <code class="nx">medium</code>: <code class="nx">2</code> <code class="p">};</code>
    <code class="c1">//                          ~~~~~~</code>
    <code class="c1">// Error: Type 'number' is not assignable to type 'string'.</code>
<code class="p">}</code></pre>

<p>Although the <code>typeof</code> <em>type</em> operator visually looks like the <em>runtime</em> <code>typeof</code> operator used to return a string description of a value’s type, the two are different.
They only coincidentally use the same word.
Remember: the JavaScript operator is a runtime operator that returns the string name of a type.
The TypeScript version, because it’s a type operator, can only be used in types and won’t appear in compiled code.</p>










<section data-type="sect3" data-pdf-bookmark="keyof typeof"><div class="sect3" id="idm45584679303440">
<h3>keyof typeof</h3>

<p><code>typeof</code> retrieves<a data-type="indexterm" data-primary="type operators" data-secondary="keyof typeof" id="idm45584679301360"/><a data-type="indexterm" data-primary="keyof typeof type operator" id="idm45584679300352"/> the type of a value, and <code>keyof</code> retrieves the allowed keys on a type.
TypeScript allows the two keywords to be chained together to succinctly retrieve the allowed keys on a value’s type.
Putting them together, the <code>typeof</code> type operator becomes wonderfully useful for working with <code>keyof</code> type operations.</p>

<p>In this example, the <code>logRating</code> function is meant to take in one of the keys of the <code>ratings</code> value.
Instead of creating an interface, the code uses <code>keyof typeof</code> to indicate <code>key</code> must be one of the keys on the type of the <code>ratings</code> value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">ratings</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">imdb</code>: <code class="nx">8.4</code><code class="p">,</code>
    <code class="nx">metacritic</code>: <code class="nx">82</code><code class="p">,</code>
<code class="p">};</code>

<code class="kd">function</code> <code class="nx">logRating</code><code class="p">(</code><code class="nx">key</code>: <code class="nx">keyof</code> <code class="k">typeof</code> <code class="nx">ratings</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ratings</code><code class="p">[</code><code class="nx">key</code><code class="p">]);</code>
<code class="p">}</code>

<code class="nx">logRating</code><code class="p">(</code><code class="s2">"imdb"</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">logRating</code><code class="p">(</code><code class="s2">"invalid"</code><code class="p">);</code>
<code class="c1">//        ~~~~~~~~~</code>
<code class="c1">// Error: Argument of type '"missing"' is not assignable</code>
<code class="c1">// to parameter of type '"imdb" | "metacritic"'.</code></pre>

<p>By combining <code>keyof</code> and <code>typeof</code>, we get to save ourselves the pain of writing out—and having to update—types representing the allowed keys on objects that don’t have an explicit interface type.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Type Assertions"><div class="sect1" id="idm45584679210320">
<h1>Type Assertions</h1>

<p>TypeScript <a data-type="indexterm" data-primary="type assertions" data-secondary="purpose of" id="type-assert-purpose"/><a data-type="indexterm" data-primary="type casts" data-see="type assertions" id="idm45584679207312"/>works best when your code is “strongly typed”: all the values in your code have precisely known types.
Features such as top types and type guards provide ways to wrangle complex code into being understood by TypeScript’s type checker.
However, sometimes it’s not reasonably possible to be 100% accurate in telling the type system how your code is meant to work.</p>

<p>For example, <code>JSON.parse</code> intentionally returns the top type <code>any</code>.
There’s no way to safely inform the type system that a particular string value given to <code>JSON.parse</code> should return any particular value type.
(As we will see in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch10.xhtml#generics_chapter">Chapter 10, “Generics”</a>, adding a generic type to <code>parse</code> that is only used once for a return type would violate a best practice known as The Golden Rule of Generics.)</p>

<p>TypeScript provides a syntax for overriding the type system’s understanding of a value’s type: a “type assertion,” also known as a “type cast.”
On a value that is meant to be a different type, you can place<a data-type="indexterm" data-primary="as keyword" id="idm45584679202176"/> the <code>as</code> keyword followed by a type.
TypeScript will defer to your assertion and treat the value as that type.</p>

<p>In this snippet, it is possible that the returned result from <code>JSON.parse</code> is meant to be a type such as <code>string[]</code>, <code>[string, string]</code>, or <code>["grace", "frankie"]</code>.
The snippet uses type assertions for three of the lines of code to switch the type from <code>any</code> to one of those:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">rawData</code> <code class="o">=</code> <code class="sb">`["grace", "frankie"]`</code><code class="p">;</code>

<code class="c1">// Type: any</code>
<code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">rawData</code><code class="p">);</code>

<code class="c1">// Type: string[]</code>
<code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">rawData</code><code class="p">)</code> <code class="kr">as</code> <code class="kt">string</code><code class="p">[];</code>

<code class="c1">// Type: [string, string]</code>
<code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">rawData</code><code class="p">)</code> <code class="kr">as</code> <code class="p">[</code><code class="kt">string</code><code class="p">,</code> <code class="kt">string</code><code class="p">];</code>

<code class="c1">// Type: ["grace", "frankie"]</code>
<code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">rawData</code><code class="p">)</code> <code class="kr">as</code> <code class="p">[</code><code class="s2">"grace"</code><code class="p">,</code> <code class="s2">"frankie"</code><code class="p">];</code></pre>

<p>Type assertions exist only in the TypeScript type system.
They’re removed along with all other pieces of type system syntax when compiled to JavaScript.
The previous code would look like this when compiled to JavaScript:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">rawData</code> <code class="o">=</code> <code class="sb">`["grace", "frankie"]`</code><code class="p">;</code>

<code class="c1">// Type: any</code>
<code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">rawData</code><code class="p">);</code>

<code class="c1">// Type: string[]</code>
<code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">rawData</code><code class="p">);</code>

<code class="c1">// Type: [string, string]</code>
<code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">rawData</code><code class="p">);</code>

<code class="c1">// Type: ["grace", "frankie"]</code>
<code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">rawData</code><code class="p">);</code></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you’re working with older libraries or code, you may see a different casting syntax that looks like <code>&lt;type&gt;item</code> instead of <code>item as type</code>.
Because this syntax is incompatible with JSX syntax and therefore does not work in <em>.tsx</em> files, it is<a data-type="indexterm" data-primary="type assertions" data-secondary="purpose of" data-startref="type-assert-purpose" id="idm45584679061072"/> discouraged.</p>
</div>

<p>TypeScript best practice is generally to avoid using type assertions when possible.
It’s best for your code to be fully typed and to not need to interfere with TypeScript’s understanding of its types using assertions.
But occasionally there will be cases where type assertions are useful, even necessary.</p>








<section data-type="sect2" data-pdf-bookmark="Asserting Caught Error Types"><div class="sect2" id="idm45584679058992">
<h2>Asserting Caught Error Types</h2>

<p>Error handling <a data-type="indexterm" data-primary="type assertions" data-secondary="error handling with" id="idm45584679057696"/><a data-type="indexterm" data-primary="error handling" data-secondary="with type assertions" data-secondary-sortas="type assertions" id="idm45584679056688"/>is another place where type assertions may come in handy.
It is generally impossible to know what type a caught error in a <code>catch</code> block will be because the code in the <code>try</code> block may unexpectedly throw any object different from what you expect.
Furthermore, although JavaScript best practice is to always throw an instance of the <code>Error</code> class, some projects instead throw string literals or other surprising values.</p>

<p>If you are absolutely confident that an area of code will only throw an instance of the <code>Error</code> class, you can use a type assertion to treat a caught assertion as an <code>Error</code>.
This snippet accesses the <code>message</code> property of a caught <code>error</code> that it assumes is an instance of the <code>Error</code> class:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="k">try</code> <code class="p">{</code>
    <code class="c1">// (code that may throw an error)</code>
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">warn</code><code class="p">(</code><code class="s2">"Oh no!"</code><code class="p">,</code> <code class="p">(</code><code class="nx">error</code> <code class="kr">as</code> <code class="nb">Error</code><code class="p">).</code><code class="nx">message</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>It is generally safer to use a form of type narrowing such as an <code>instanceof</code> check to ensure the thrown error is the expected error type.
This snippet checks whether the thrown error is an instance of the <code>Error</code> class to know whether to log that message or the error itself:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="k">try</code> <code class="p">{</code>
    <code class="c1">// (code that may throw an error)</code>
<code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="nx">error</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">warn</code><code class="p">(</code><code class="s2">"Oh no!"</code><code class="p">,</code> <code class="nx">error</code> <code class="k">instanceof</code> <code class="nb">Error</code> <code class="o">?</code> <code class="nx">error.message</code> : <code class="nx">error</code><code class="p">);</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Non-Null Assertions"><div class="sect2" id="idm45584679001392">
<h2>Non-Null Assertions</h2>

<p>Another<a data-type="indexterm" data-primary="type assertions" data-secondary="non-null" id="type-assert-nonnull"/><a data-type="indexterm" data-primary="non-null type assertions" id="nonnull-assert"/> common use case for type assertions is to remove <code>null</code> and/or <code>defined</code> from a variable that only theoretically, not practically, might include them.
That situation is so common that TypeScript includes a shorthand for it.
Instead of writing out <code>as</code> and the full type of whatever a value is excluding <code>null</code> and <code>undefined</code>, you can<a data-type="indexterm" data-primary="! (exclamation point)" data-secondary="non-null type assertions" id="idm45584678902576"/><a data-type="indexterm" data-primary="exclamation point (!)" data-secondary="non-null type assertions" id="idm45584678901600"/> use a <code>!</code> to signify the same thing.
In other words, the <code>!</code> non-null assertion asserts that the type is not <code>null</code> or <code>undefined</code>.</p>

<p>The following two type assertions are identical in that they both result in <code>Date</code> and not <code>Date | undefined</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Inferred type: Date | undefined</code>
<code class="kd">let</code> <code class="nx">maybeDate</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&gt;</code> <code class="mf">0.5</code>
    <code class="o">?</code> <code class="kc">undefined</code>
    <code class="o">:</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">();</code>

<code class="c1">// Asserted type: Date</code>
<code class="nx">maybeDate</code> <code class="kr">as</code> <code class="nb">Date</code><code class="p">;</code>

<code class="c1">// Asserted type: Date</code>
<code class="nx">maybeDate</code><code class="o">!</code><code class="p">;</code></pre>

<p>Non-null assertions are particularly useful with APIs such as <code>Map.get</code> that return a value or <code>undefined</code> if it doesn’t exist.</p>

<p>Here, <code>seasonCounts</code> is a general <code>Map&lt;string, number&gt;</code>.
We know that it contains an <code>"I Love Lucy"</code> key so the <code>knownValue</code> variable can use a <code>!</code> to remove <code>| undefined</code> from its <a data-type="indexterm" data-primary="type assertions" data-secondary="non-null" data-startref="type-assert-nonnull" id="idm45584678845216"/><a data-type="indexterm" data-primary="non-null type assertions" data-startref="nonnull-assert" id="idm45584678874656"/>type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">seasonCounts</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">([</code>
    <code class="p">[</code><code class="s2">"I Love Lucy"</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code>
    <code class="p">[</code><code class="s2">"The Golden Girls"</code><code class="p">,</code> <code class="mi">7</code><code class="p">],</code>
<code class="p">]);</code>

<code class="c1">// Type: string | undefined</code>
<code class="kr">const</code> <code class="nx">maybeValue</code> <code class="o">=</code> <code class="nx">seasonCounts</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"I Love Lucy"</code><code class="p">);</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">maybeValue</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">());</code>
<code class="c1">//          ~~~~~~~~~~</code>
<code class="c1">// Error: Object is possibly 'undefined'.</code>

<code class="c1">// Type: string</code>
<code class="kr">const</code> <code class="nx">knownValue</code> <code class="o">=</code> <code class="nx">seasonCounts</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"I Love Lucy"</code><code class="p">)</code><code class="o">!</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">knownValue</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">());</code> <code class="c1">// Ok</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Type Assertion Caveats"><div class="sect2" id="idm45584678737424">
<h2>Type Assertion Caveats</h2>

<p>Type assertions, <a data-type="indexterm" data-primary="type assertions" data-secondary="when to use" id="type-assert-usage"/><a data-type="indexterm" data-primary="assertions" data-see="const assertions; type assertions" id="idm45584678797504"/>like the <code>any</code> type, are a necessary escape hatch for TypeScript’s type system.
Therefore, also like the <code>any</code> type, they should be avoided whenever reasonably possible.
It is often better to have more accurate types representing your code 
<span class="keep-together">than it</span> is to make it easier to assert on a value’s type.
Those assertions are often wrong—either already so at the time of writing, or they become wrong later on as the codebase changes.</p>

<p>For example, suppose the <code>seasonCounts</code> example were to change over time to have different values in the map.
Its non-null assertion might still make the code pass TypeScript type checking, but there might be a runtime error:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">seasonCounts</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">([</code>
    <code class="p">[</code><code class="s2">"Broad City"</code><code class="p">,</code> <code class="mi">5</code><code class="p">],</code>
    <code class="p">[</code><code class="s2">"Community"</code><code class="p">,</code> <code class="mi">6</code><code class="p">],</code>
<code class="p">]);</code>

<code class="c1">// Type: string</code>
<code class="kr">const</code> <code class="nx">knownValue</code> <code class="o">=</code> <code class="nx">seasonCounts</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"I Love Lucy"</code><code class="p">)</code><code class="o">!</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">knownValue</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">());</code> <code class="c1">// No type error, but...</code>
<code class="c1">// Runtime TypeError: Cannot read property 'toUpperCase' of undefined.</code></pre>

<p>Type assertions should generally be used sparingly, and only when you’re absolutely certain it is safe to do so.</p>










<section data-type="sect3" data-pdf-bookmark="Assertions versus declarations"><div class="sect3" id="idm45584678723952">
<h3>Assertions versus declarations</h3>

<p>There is <a data-type="indexterm" data-primary="type assertions" data-secondary="type annotations vs." id="type-assert-notate"/><a data-type="indexterm" data-primary="type annotations" data-secondary="type assertions vs." id="type-notations-assert"/>a difference between using a type annotation to declare a variable’s type versus using a type assertion to change the type of a variable with an initial value.
TypeScript’s type checker performs assignability checking on a variable’s initial value against the variable’s type annotation when both exist.
A type assertion, however, explicitly tells TypeScript to skip some of its type checking.</p>

<p>The following code creates two objects of type <code>Entertainer</code> with the same flaw: a missing <code>acts</code> member.
TypeScript is able to catch the error in the <code>declared</code> variable because of its <code>: Entertainer</code> type annotation.
It is not able to catch the error on the <code>asserted</code> variable because of the type assertion:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Entertainer</code> <code class="p">{</code>
    <code class="nx">acts</code>: <code class="nx">string</code><code class="p">[];</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">declared</code>: <code class="nx">Entertainer</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Moms Mabley"</code><code class="p">,</code>
<code class="p">};</code>
<code class="c1">// Error: Property 'acts' is missing in type</code>
<code class="c1">// '{ one: number; }' but required in type 'Entertainer'.</code>

<code class="kr">const</code> <code class="nx">asserted</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"Moms Mabley"</code><code class="p">,</code>
<code class="p">}</code> <code class="kr">as</code> <code class="nx">Entertainer</code><code class="p">;</code> <code class="c1">// Ok, but...</code>

<code class="c1">// Both of these statements would fail at runtime with:</code>
<code class="c1">// Runtime TypeError: Cannot read properties of undefined (reading 'toPrecision')</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">declared</code><code class="p">.</code><code class="nx">acts</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">", "</code><code class="p">));</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">asserted</code><code class="p">.</code><code class="nx">acts</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">", "</code><code class="p">));</code></pre>

<p>It is therefore strongly preferable to either use a type annotation or allow TypeScript to infer a variable’s type from its initial value.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Assertion assignability"><div class="sect3" id="idm45584678635440">
<h3>Assertion assignability</h3>

<p>Type assertions<a data-type="indexterm" data-primary="type assertions" data-secondary="assignability" id="idm45584678565328"/><a data-type="indexterm" data-primary="assignability" data-secondary="of type assertions" data-secondary-sortas="type assertions" id="idm45584678564320"/> are meant to be only a small escape hatch, for situations where some value’s type is slightly incorrect.
TypeScript will only allow type assertions between two types if one of the types is assignable to the other.
If the type assertion is between two completely unrelated types, then TypeScript will notice and report a type error.</p>

<p>For example, switching from one primitive to another is not allowed, as primitives have nothing to do with each other:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kd">let</code> <code class="nx">myValue</code> <code class="o">=</code> <code class="s2">"Stella!"</code> <code class="kr">as</code> <code class="kt">number</code><code class="p">;</code>
<code class="c1">//            ~~~~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Conversion of type 'string' to type 'number'</code>
<code class="c1">// may be a mistake because neither type sufficiently</code>
<code class="c1">// overlaps with the other. If this was intentional,</code>
<code class="c1">// convert the expression to 'unknown' first.</code></pre>

<p>If you absolutely must switch a value from one type to a totally unrelated type, you can use a <a data-type="indexterm" data-primary="double type assertions" id="idm45584678547280"/>double type assertion.
First cast the value to a top type—<code>any</code> or <code>unknown</code>—and then cast that result to the unrelated type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">myValueDouble</code> <code class="o">=</code> <code class="s2">"1337"</code> <code class="kr">as</code> <code class="nx">unknown</code> <code class="kr">as</code> <code class="kt">number</code><code class="p">;</code> <code class="c1">// Ok, but... eww.</code></pre>

<p><code>as unknown as...</code> double type assertions are dangerous and almost always a sign of something incorrect in the types of the surrounding code.
Using them as an escape hatch from the type system means the type system may not be able to save you when changes to surrounding code would cause an issue with previously working code.
I teach double type assertions only as a precautionary tale to help explain the type system, not to encourage their use.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Const Assertions"><div class="sect1" id="idm45584679209696">
<h1>Const Assertions</h1>

<p>Back in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.xhtml#objects">Chapter 4, “Objects”</a>, I <a data-type="indexterm" data-primary="const assertions" data-secondary="purpose of" id="const-assert-purpose"/>introduced an <code>as const</code> syntax for changing a mutable array type to a read-only tuple type and promised to use it more later in the book.
That time is now!</p>

<p>Const assertions can generally be used to indicate that any value—array, primitive, value, you name it—should be treated as the constant, immutable version of itself.
Specifically, <code>as const</code> applies the following three rules to whatever type it receives:</p>

<ul>
<li>
<p>Arrays are treated as <code>readonly</code> tuples, not mutable arrays.</p>
</li>
<li>
<p>Literals are treated as literals, not their general primitive equivalents.</p>
</li>
<li>
<p>Properties on objects are considered <code>readonly</code>.</p>
</li>
</ul>

<p>You’ve already seen arrays become tuples, as with this array being asserted as a tuple:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: (number | string)[]</code>
<code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="s1">''</code><code class="p">];</code>

<code class="c1">// Type: readonly [0, '']</code>
<code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="s1">''</code><code class="p">]</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code></pre>

<p>Let’s dig into the other two changes <code>as const</code> produces.</p>








<section data-type="sect2" data-pdf-bookmark="Literals to Primitives"><div class="sect2" id="idm45584678484672">
<h2>Literals to Primitives</h2>

<p>It <a data-type="indexterm" data-primary="const assertions" data-secondary="literals as literals" id="idm45584678453872"/><a data-type="indexterm" data-primary="literals" data-secondary="as literals" data-secondary-sortas="literals" id="idm45584678452864"/><a data-type="indexterm" data-primary="primitives" data-secondary="literals" data-tertiary="as literals" data-tertiary-sortas="literals" id="idm45584678451648"/>can be useful for the type system to understand a literal value to be that specific literal, rather than widening it to its general primitive.</p>

<p>For example, similar to functions that return tuples, it might be useful for a function to be known to produce a specific literal instead of a general primitive.
These functions also return values that can be made more specific—here, <code>getNameConst</code>’s return type is the more specific <code>"Maria Bamford"</code> instead of the general <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: () =&gt; string</code>
<code class="kr">const</code> <code class="nx">getName</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"Maria Bamford"</code><code class="p">;</code>

<code class="c1">// Type: () =&gt; "Maria Bamford"</code>
<code class="kr">const</code> <code class="nx">getNameConst</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">"Maria Bamford"</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code></pre>

<p>It may also be useful to have specific fields on a value be more specific literals.
Many popular libraries ask that a discriminant field on a value be a specific literal so the types of their code can more specifically make inferences on the value.
Here, the <code>narrowJoke</code> variable has a <code>style</code> of type <code>"one-liner"</code> instead of <code>string</code>, so it can be provided in a location that needs type <code>Joke</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Joke</code> <code class="p">{</code>
    <code class="nx">quote</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">style</code><code class="o">:</code> <code class="s2">"story"</code> <code class="o">|</code> <code class="s2">"one-liner"</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">tellJoke</code><code class="p">(</code><code class="nx">joke</code>: <code class="nx">Joke</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">joke</code><code class="p">.</code><code class="nx">style</code> <code class="o">===</code> <code class="s2">"one-liner"</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">joke</code><code class="p">.</code><code class="nx">quote</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">joke</code><code class="p">.</code><code class="nx">quote</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">));</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Type: { quote: string; style: "one-liner" }</code>
<code class="kr">const</code> <code class="nx">narrowJoke</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">quote</code><code class="o">:</code> <code class="s2">"If you stay alive for no other reason do it for spite."</code><code class="p">,</code>
    <code class="nx">style</code><code class="o">:</code> <code class="s2">"one-liner"</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">,</code>
<code class="p">};</code>

<code class="nx">tellJoke</code><code class="p">(</code><code class="nx">narrowJoke</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="c1">// Type: { quote: string; style: string }</code>
<code class="kr">const</code> <code class="nx">wideObject</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">quote</code><code class="o">:</code> <code class="s2">"Time flies when you are anxious!"</code><code class="p">,</code>
    <code class="nx">style</code><code class="o">:</code> <code class="s2">"one-liner"</code><code class="p">,</code>
<code class="p">};</code>

<code class="nx">tellJoke</code><code class="p">(</code><code class="nx">wideObject</code><code class="p">);</code>
<code class="c1">// Error: Argument of type '{ quote: string; style: string; }'</code>
<code class="c1">// is not assignable to parameter of type 'LogAction'.</code>
<code class="c1">//   Types of property 'style' are incompatible.</code>
<code class="c1">//     Type 'string' is not assignable to type '"story" | "one-liner"'.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Read-Only Objects"><div class="sect2" id="idm45584678357376">
<h2>Read-Only Objects</h2>

<p>Object literals<a data-type="indexterm" data-primary="const assertions" data-secondary="read-only objects" id="idm45584678270160"/><a data-type="indexterm" data-primary="objects" data-secondary="read-only" id="idm45584678269152"/><a data-type="indexterm" data-primary="read-only objects" id="idm45584678268208"/> such as those used as the initial value of a variable generally widen the types of properties the same way the initial values of <code>let</code> variables widen.
String values such as <code>'apple'</code> become primitives such as <code>string</code>, arrays are typed as arrays instead of tuples, and so on.
This can be inconvenient when some or all of those values are meant to later be used in a place that requires their specific literal type.</p>

<p>Asserting a value literal with <code>as const</code>, however, switches the inferred type to be as specific as possible.
All member properties become <code>readonly</code>, literals are considered their own literal type instead of their general primitive type, arrays become read-only tuples, and so on.
In other words, applying a const assertion to a value literal makes that value literal immutable and recursively applies the same const assertion logic to all its members.</p>

<p>As an example, the <code>preferencesMutable</code> value that follows is declared without an <code>as const</code>, so its names are the primitive type <code>string</code> and it’s allowed to be modified.
<code>favoritesConst</code>, however, is declared with an <code>as const</code>, so its member values are literals and not allowed to be modified:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">function</code> <code class="nx">describePreference</code><code class="p">(</code><code class="nx">preference</code><code class="o">:</code> <code class="s2">"maybe"</code> <code class="o">|</code> <code class="s2">"no"</code> <code class="o">|</code> <code class="s2">"yes"</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">switch</code> <code class="p">(</code><code class="nx">preference</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">case</code> <code class="s2">"maybe"</code><code class="o">:</code>
            <code class="k">return</code> <code class="s2">"I suppose..."</code><code class="p">;</code>
        <code class="k">case</code> <code class="s2">"no"</code><code class="o">:</code>
            <code class="k">return</code> <code class="s2">"No thanks."</code><code class="p">;</code>
        <code class="k">case</code> <code class="s2">"yes"</code><code class="o">:</code>
            <code class="k">return</code> <code class="s2">"Yes please!"</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Type: { movie: string, standup: string }</code>
<code class="kr">const</code> <code class="nx">preferencesMutable</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">movie</code><code class="o">:</code> <code class="s2">"maybe"</code>
    <code class="nx">standup</code><code class="o">:</code> <code class="s2">"yes"</code><code class="p">,</code>
<code class="p">};</code>

<code class="nx">describePreference</code><code class="p">(</code><code class="nx">preferencesMutable</code><code class="p">.</code><code class="nx">movie</code><code class="p">);</code>
<code class="c1">//                 ~~~~~~~~~~~~~~~~~~~~~~~~</code>
<code class="c1">// Error: Argument of type 'string' is not assignable</code>
<code class="c1">// to parameter of type '"maybe" | "no" | "yes"'.</code>

<code class="nx">preferencesMutable</code><code class="p">.</code><code class="nx">movie</code> <code class="o">=</code> <code class="s2">"no"</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="c1">// Type: readonly { readonly movie: "maybe", readonly standup: "yes" }</code>
<code class="kr">const</code> <code class="nx">preferencesReadonly</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">movie</code><code class="o">:</code> <code class="s2">"maybe"</code>
    <code class="nx">standup</code><code class="o">:</code> <code class="s2">"yes"</code><code class="p">,</code>
<code class="p">}</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>

<code class="nx">describePreference</code><code class="p">(</code><code class="nx">preferencesReadonly</code><code class="p">.</code><code class="nx">movie</code><code class="p">);</code> <code class="c1">// Ok</code>

<code class="nx">preferencesReadonly</code><code class="p">.</code><code class="nx">movie</code> <code class="o">=</code> <code class="s2">"no"</code><code class="p">;</code>
<code class="c1">//                  ~~~~~</code>
<code class="c1">// Error: Cannot assign to 'movie' because it is a read-only property.</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584678213264">
<h1>Summary</h1>

<p>In this chapter, you used type modifiers to take existing objects and/or types and turn them into new types:</p>

<ul>
<li>
<p>Top types: the highly permissive <code>any</code> and the highly restrictive <code>unknown</code></p>
</li>
<li>
<p>Type operators: using <code>keyof</code> to grab the keys of a type and/or <code>typeof</code> to grab the type of a value</p>
</li>
<li>
<p>Using—and when not to use—type assertions to sneakily change the type of a value</p>
</li>
<li>
<p>Narrowing types using <code>as const</code> assertions</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/type-modifiers"><em class="hyperlink">https://learningtypescript.com/type-modifiers</em></a>.</p>
</div>
<blockquote class="joke">
<p>Why was the literal type being stubborn?</p>

<p>It had a narrow mind.</p></blockquote>
</div></section>







</div></section></div></body></html>