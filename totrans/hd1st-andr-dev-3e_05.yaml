- en: 'Chapter 3\. Layouts: *Being a layout*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章。布局：*成为一个布局*
- en: '![image](Images/f0081-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0081-01.png)'
- en: '**We’ve only scratched the surface of using layouts**.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**我们仅仅触及到了布局的表面**。'
- en: So far, you’ve seen how to arrange views in a simple linear layout, but there’s
    so much more that layouts can do. In this chapter we’ll **go a little deeper**
    and show you how layouts really work. You’ll learn **how to fine-tune your linear
    layouts**. You’ll discover how to use **frame layouts** and **scroll views**.
    And by the end of the chapter, you’ll learn that even though they might look a
    little different, all layouts—and the views you add to them—have **more in common
    than you might think**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经看到如何在一个简单的线性布局中排列视图，但是布局还能做更多。在本章中，我们将**深入一点**，向你展示布局的真正工作方式。你将学会**如何微调你的线性布局**。你将了解如何使用**帧布局**和**滚动视图**。到本章结束时，你会发现，尽管它们可能看起来有点不同，但所有的布局及其添加的视图**有更多的共同点**。
- en: It all starts with a layout
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一切从布局开始
- en: As you already know, layout files are written in XML, and they let you define
    what your app looks like.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经知道的，布局文件是用XML编写的，它们让你定义应用的外观。
- en: 'Each time you write a layout, you need to do three things:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你编写布局，你需要做三件事：
- en: '**Specify the type of layout.**'
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指定布局类型。**'
- en: You tell Android how you want any views (such as buttons and text views) to
    be arranged by specifying a type of layout. A linear layout, for example, arranges
    views in a linear column or row, one after another.
  id: totrans-8
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你通过指定一种布局类型来告诉Android如何排列任何视图（如按钮和文本视图）。例如，线性布局将视图按照线性列或行依次排列。
- en: '[PRE0]'
  id: totrans-9
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**Specify the views.**'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指定视图。**'
- en: Each layout contains one or more views, which your app uses to display information
    or interact with the user.
  id: totrans-11
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个布局包含一个或多个视图，你的应用程序用它们来显示信息或与用户交互。
- en: '[PRE1]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**Tell an activity to use the layout.**'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**告诉活动使用布局。**'
- en: You tell Android which activity uses the layout you’ve just defined by adding
    Kotlin code like this to the activity.
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过向活动添加类似这样的Kotlin代码，告诉Android哪个活动使用你刚刚定义的布局。
- en: '[PRE2]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![image](Images/f0082-01.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0082-01.png)'
- en: Android has different types of layout
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android有不同类型的布局
- en: Android has different types of layout, and each one has its own policy about
    how its views are arranged. A linear layout, for example, will always lay views
    out in a linear row or column, while a frame layout stacks its views, one on top
    of another. Which type of layout you use depends on how you want views to be arranged
    on the device screen.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Android有不同类型的布局，每种布局对其视图的排列方式都有自己的规则。例如，线性布局总是按照线性行或列排列视图，而帧布局则将其视图堆叠在一起。你使用哪种类型的布局取决于你想要在设备屏幕上如何排列视图。
- en: '![image](Images/f0083-01.png)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0083-01.png)'
- en: Use the best layout for your screen design
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的屏幕设计选择最佳布局
- en: 'All the apps you’ve seen so far have used linear layouts to arrange views in
    a single column. In this chapter, we’re going to take a deeper look at linear
    layouts, and introduce you to two other types: a frame layout and a scroll view.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你所见过的所有应用程序都使用线性布局将视图按单列排列。在本章中，我们将深入研究线性布局，并向你介绍另外两种类型：帧布局和滚动视图。
- en: Let’s start with linear layouts.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从线性布局开始。
- en: Let’s build a linear layout
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 让我们构建一个线性布局
- en: '![image](Images/f0084-01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0084-01.png)'
- en: We’re going to use a linear layout to build the layout shown below. A linear
    layout is a good choice here, because the views are arranged in a single column.
    As you already know, a linear layout arranges views one after another in a vertical
    column or a horizontal row.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用线性布局来构建下面显示的布局。在这里选择线性布局是个不错的选择，因为视图是在单列中排列的。正如你已经知道的，线性布局将视图按照垂直列或水平行依次排列。
- en: 'The layout is composed of two editable text views (text views that allow you
    to enter text) and a button. Here’s what we want the layout to look like:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 布局由两个可编辑的文本视图（允许输入文本的文本视图）和一个按钮组成。这是我们想要布局看起来的样子：
- en: '![image](Images/f0084-02.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0084-02.png)'
- en: Create a new project
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: We’ll use a new Android Studio project for the linear layout app.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个新的Android Studio项目来创建线性布局应用。
- en: Create a new project using the same steps you used in the previous chapters.
    Choose the Empty Activity option, enter a name of “Linear Layout Example” and
    a package name of “com.hfad.linearlayoutexample”, and accept the default save
    location. Make sure the language is set to Kotlin and the minimum SDK is API 21
    so that it will run on most Android devices.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与前几章相同的步骤创建新项目。选择空活动选项，输入名称“线性布局示例”和包名称“com.hfad.linearlayoutexample”，并接受默认保存位置。确保语言设置为Kotlin，并且最低SDK为API
    21，以便在大多数Android设备上运行。
- en: How to define a linear layout
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何定义线性布局
- en: 'As you already know, you define a linear layout using a `<LinearLayout>` element.
    The code looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所知，使用`<LinearLayout>`元素来定义线性布局。代码如下所示：
- en: '![image](Images/f0085-02.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0085-02.png)'
- en: The `<LinearLayout>` element contains various different attributes that it needs
    to specify its appearance and behavior.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`<LinearLayout>`元素包含各种不同的属性，用于指定其外观和行为。'
- en: The first is `**xmlns:android**`. This defines a namespace named `android`,
    and it needs to be set to `"[http://schemas.android.com/apk/res/android](http://schemas.android.com/apk/res/android)"`
    as above. Defining this namespace gives your layout access to the elements and
    attributes that your layout needs, and you need to define it in every layout file
    you create.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`**xmlns:android**`。这定义了一个名为`android`的命名空间，其值需要设置为`"[http://schemas.android.com/apk/res/android](http://schemas.android.com/apk/res/android)"`，如上所述。定义此命名空间使您的布局能够访问其需要的元素和属性，并且您需要在创建的每个布局文件中定义它。
- en: The next two attributes are `**android:layout_width**` and `**android:layout_height**`,
    and these specify how wide and high you want the layout to be. These attributes
    are mandatory for *all* types of layout and view.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个属性是`**android:layout_width**`和`**android:layout_height**`，用于指定布局的宽度和高度。这些属性对于*所有*类型的布局和视图都是必需的。
- en: You can set `android:layout_width` and `android:layout_height` to `"wrap_content"`,
    `"match_parent",` or a specific size such as 8dp—that’s 8 density-independent
    pixels. `"wrap_content"` means that you want the layout to be just big enough
    to hold all of the views inside it, and `"match_parent"` means that you want the
    layout to be as big as its parent—in this case, as big as the device screen minus
    any padding (there’s more about padding a few pages ahead). You will usually set
    the layout width and height to `"match_parent"`.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将`android:layout_width`和`android:layout_height`设置为`"wrap_content"`、`"match_parent"`或特定大小，如8dp——即8个密度无关像素。`"wrap_content"`表示您希望布局仅大到足以容纳其中的所有视图，而`"match_parent"`表示您希望布局与其父级一样大——在本例中，就是设备屏幕的大小减去任何填充（关于填充的更多信息请参阅几页后面的内容）。通常将布局的宽度和高度设置为`"match_parent"`。
- en: The next attribute sets the linear layout’s orientation. We’ll look at options
    for this attribute next.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的属性设置了线性布局的方向。接下来我们将看看此属性的选项。
- en: Orientation can be vertical or horizontal
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方向可以是垂直或水平的
- en: You specify the direction in which you wish to arrange views using the `**android:orientation**`
    attribute.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`**android:orientation**`属性指定希望排列视图的方向。
- en: 'You arrange views vertically in a single column using:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下方式将视图垂直排列在单列中：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'and you arrange views horizontally in a single row with:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下内容将视图水平排列在单行中：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: If the orientation is horizontal, the order in which the views are arranged
    depends on the device language settings.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方向是水平的，视图的排列顺序取决于设备的语言设置。
- en: 'If the device language is set to one that is read from left to right, such
    as English, the views are displayed in a horizontal row from left to right like
    this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备的语言设置为从左到右阅读的语言，比如英语，视图将水平排列，从左到右显示，如下所示：
- en: '![image](Images/f0086-02.png)![image](Images/f0086-03.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0086-02.png)![image](Images/f0086-03.png)'
- en: 'If the language on the device is set to one that’s read from right to left
    instead, like Arabic, you can choose to display the views from right to left,
    so that the first view appears against the rightmost edge of the layout. You enable
    this feature by including a property named `**supportsRtl**` in a file named *AndroidManifest.xml*
    file, and setting it to `"true"`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备的语言设置为从右到左阅读的语言，比如阿拉伯语，您可以选择从右到左显示视图，使第一个视图出现在布局的最右边。您可以通过在名为*AndroidManifest.xml*文件中包含名为`**supportsRtl**`的属性，并将其设置为`"true"`来启用此功能：
- en: Note
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: supportsRtl means “supports right to left”.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: supportsRtl意味着“支持从右到左”。
- en: '![image](Images/f0086-05.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0086-05.png)'
- en: Before we look at what other attributes you can use with linear layouts, let’s
    take a quick detour to find out more about *AndroidManifest.xml*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看线性布局可以使用的其他属性之前，让我们快速了解一下*AndroidManifest.xml*的更多信息。
- en: Use padding to add space to the layout’s edges
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用填充来增加布局边缘的空间
- en: 'Once you’ve specified the type of layout you want to use, you can optionally
    use one or more **padding** attributes to add some extra space between each of
    the layout’s edges and its contents. The following code, for example, uses the
    `android:padding` attribute to add 16dp to each edge:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您指定了要使用的布局类型，您可以选择使用一个或多个**padding**属性来在布局边缘和其内容之间添加额外的空间。例如，以下代码使用`android:padding`属性为每个边缘添加了16dp：
- en: '![image](Images/f0088-03.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0088-03.png)'
- en: 'If you want to add different amounts of padding to different edges, you can
    specify the edges individually. The following code, for example, adds padding
    of 32dp to the top of the layout, and 16dp to the other edges:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在不同的边缘添加不同量的填充，您可以单独指定这些边缘。例如，以下代码在布局顶部添加了32dp的填充，并在其他边缘添加了16dp：
- en: '![image](Images/f0088-04.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0088-04.png)'
- en: The `android:paddingStart` attribute adds padding to the start edge of the layout.
    For left-to-right languages (such as English), the start edge is on the left,
    while if the device language is set to one that’s read from right to left—and
    the app supports right-to-left languages—the start edge is on the right.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:paddingStart`属性向布局的起始边缘添加填充。对于从左到右的语言（如英语），起始边缘在左侧；而如果设备语言设置为从右到左阅读，并且应用程序支持从右到左的语言，则起始边缘在右侧。'
- en: The `android:paddingEnd` attribute adds padding to the end edge of the layout.
    This is on the right for left-to-right languages, and on the left for right-to-left
    languages (where the app supports this feature).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:paddingEnd`属性向布局的结束边缘添加填充。对于从左到右的语言，此处为右侧；对于从右到左的语言（如果应用程序支持此功能），此处为左侧。'
- en: If you want to apply the same amount of padding to the horizontal or vertical
    edges, you can also use `android:paddingHorizontal` and `android:paddingVertical`.
    These attributes add padding to the horizontal and vertical edges of the layout,
    respectively.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想要在水平或垂直边缘上应用相同数量的填充，您也可以使用`android:paddingHorizontal`和`android:paddingVertical`。这些属性分别在布局的水平和垂直边缘添加填充。
- en: '![image](Images/f0088-05.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0088-05.png)'
- en: Now that you’ve learned how to add padding to a linear layout, let’s add some
    to the layout we’re building.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经学会了如何为线性布局添加填充，请为我们正在构建的布局添加一些填充。
- en: The layout code so far
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到目前为止的布局代码
- en: In the app, we’re going to use a linear layout with a vertical orientation,
    and add padding of 16dp to each edge so that there’s a bit of space between the
    layout’s edges and its contents.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中，我们将使用一个垂直方向的线性布局，并在每个边缘添加16dp的填充，以便在布局的边缘和其内容之间留有一些空间。
- en: 'Open *activity_main.xml*, and replace its code so that it matches the code
    below:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 打开*activity_main.xml*，并替换其代码以匹配下面的代码：
- en: '![image](Images/f0089-02.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0089-02.png)'
- en: We’ve now defined an empty linear layout; let’s go ahead and add some views
    to it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了一个空的线性布局；现在让我们继续为其添加一些视图。
- en: '**Padding puts extra space between the layout’s edges and its contents.**'
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**填充在布局的边缘和其内容之间增加了额外的空间。**'
- en: ''
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**You can also use padding with views. This adds extra space between the view’s
    edges and its contents**'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**您还可以在视图中使用填充。这将在视图边缘和其内容之间添加额外的空间**'
- en: An edit text lets you enter text
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可编辑文本框让您输入文本
- en: The linear layout needs to display a button and two editable text views (which
    are used to enter text). You already know how to use buttons, so before we update
    the layout, let’s find out how to include an editable text view.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 线性布局需要显示一个按钮和两个可编辑文本视图（用于输入文本）。您已经知道如何使用按钮，在我们更新布局之前，让我们先了解如何包含可编辑文本视图。
- en: '![image](Images/f0090-01.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0090-01.png)'
- en: 'An editable text view is a type of text view that lets you input text. You
    add one to your layout using an `**<EditText>**` element, and the code looks like
    this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 可编辑文本视图是一种允许您输入文本的文本视图类型。您可以使用`**<EditText>**`元素将其添加到布局中，代码如下：
- en: '[PRE5]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![image](Images/f0090-02.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0090-02.png)'
- en: The above code creates an editable text view that’s as wide as its parent, and
    just high enough to hold its contents.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码创建了一个宽度与其父级相同、仅高到足以容纳其内容的可编辑文本视图。
- en: The `**android:hint**` attribute is used to define hint text. This is displayed
    when the editable text view is empty, and it gives users a hint as to what sort
    of text they should enter. In the above example, we’ve hardcoded the hint text,
    but in the real world you’d want to include this as a `String` resource instead.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`**android:hint**` 属性用于定义提示文本。当可编辑文本视图为空时显示这些文本，并向用户提供输入的提示。在上述示例中，我们已经硬编码了提示文本，但在实际应用中，你应该将其作为字符串资源包含。'
- en: 'The `android:inputType` attribute specifies what type of data you expect the
    user to enter so that Android can provide the correct keyboard type. In the above
    example, we’re using:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:inputType` 属性指定用户预计输入的数据类型，以便安卓可以提供正确的键盘类型。在上述示例中，我们使用了：'
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'which lets user enter a single line of text. Here are some more useful input
    types you might want to use:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户输入单行文本。以下是您可能想要使用的一些更有用的输入类型：
- en: '| **Value** | **What it does** |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| **值** | **作用** |'
- en: '| **text** | Lets the user enter a single line of text. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **文本** | 允许用户输入单行文本。 |'
- en: '| **textMultiLine** | Lets the user enter multiple lines of text. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| **多行文本** | 允许用户输入多行文本。 |'
- en: '| **phone** | Provides a phone number keypad. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **电话** | 提供电话号码键盘。 |'
- en: '| **textPassword** | Displays a text entry keypad, and your input is concealed.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '| **密码文本** | 显示文本输入键盘，并且您的输入内容是隐藏的。'
- en: You can find out more in the online Android developer documentation at [https://developer.android.com/training/keyboard-input/style](https://developer.android.com/training/keyboard-input/style).
    |
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在在线的安卓开发者文档中找到更多信息，网址是[https://developer.android.com/training/keyboard-input/style](https://developer.android.com/training/keyboard-input/style)。
- en: '| **textCapSentences** | Capitalizes the first word of a sentence. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| **首字母大写** | 将句子的第一个字母大写。 |'
- en: Now that you’ve learned how to use editable text views, let’s add views to the
    layout code in the app we’re building.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会了如何使用可编辑文本视图，让我们将视图添加到我们正在构建的应用程序中的布局代码中。
- en: Add views to the layout XML
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在布局的 XML 文件中添加视图。
- en: When you define a linear layout, you list views in the layout in the order you
    want them to display.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义线性布局时，你按照希望它们显示的顺序列出布局中的视图。
- en: 'In the app we’re building, we want to show two editable text views with a button
    underneath. The layout code looks like this, so update the code for *activity_main.xml*
    to include these changes (in bold):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们正在构建的应用中，我们想要显示两个可编辑文本视图，下面是一个按钮。布局代码如下，因此请更新 *activity_main.xml* 的代码以包含这些更改（用粗体标出）：
- en: '![image](Images/f0091-02.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0091-02.png)'
- en: Those are all the views the layout needs. So what’s next?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这些就是布局所需的所有视图。接下来做什么呢？
- en: Make a view streeeeetch by adding weight
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过增加权重使视图拉伸
- en: 'All of the views in the current layout take up just as much vertical space
    as they need for their content. But what we *really* want is to make the Message
    edit text stretch to take up any vertical space in the layout that’s not being
    used by the other views like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当前布局中的所有视图都只占用它们内容所需的垂直空间。但是我们*真正*想要的是使消息编辑框拉伸，占用布局中未被其他视图使用的任何垂直空间，就像这样：
- en: '![image](Images/f0092-02.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0092-02.png)'
- en: To do this, we need to allocate some **weight** to the Message area. Allocating
    weight to a view is a way of telling it to stretch to take up extra space in the
    layout.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要为“消息区域”分配一些**权重**。为视图分配权重是告诉它在布局中拉伸以占用额外空间的一种方法。
- en: 'You assign weight to a view using:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下方式为视图分配权重：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: where `number` is some number greater than 0.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 `number` 是一个大于 0 的数字。
- en: 'When you allocate weight to a view, the layout first makes sure that each view
    has enough space for its content: each button has space for its text, each edit
    text has space for its hint, and so on. Once it’s done that, the layout takes
    any extra space and divides it proportionally between the views with a weight
    of 1 or greater.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为一个视图分配权重时，布局首先确保每个视图有足够的空间来容纳其内容：每个按钮有足够的空间来显示其文本，每个编辑框有足够的空间来显示其提示文本，依此类推。完成这些操作后，布局会将额外的空间按权重大于等于
    1 的视图进行比例分配。
- en: Let’s see how to apply this to the layout we’re building.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何将其应用到正在构建的布局中。
- en: How to add weight to one view
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何为一个视图增加权重
- en: We need the Message edit text to take up any extra space in the layout that’s
    not used by either of the other two views. To do this, we’ll set its `android:layout_weight`
    attribute to `1`. As this is the only view in the layout with a weight value,
    this will make the text field stretch vertically to fill the remainder of the
    screen.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要 Message 编辑文本占用布局中其他两个视图未使用的任何额外空间。为此，我们将其 `android:layout_weight` 属性设置为
    `1`。因为这是布局中唯一具有权重值的视图，这将使文本字段在垂直方向上拉伸以填充屏幕的剩余部分。
- en: 'Here’s the code; update *activity_main.xml* to include the changes (in bold):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码；更新 *activity_main.xml* 以包含更改（**加粗部分**）：
- en: '![image](Images/f0093-02.png)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0093-02.png)'
- en: Giving the Message edit text a weight of `1` means that it takes up all of the
    extra space that’s not used by the other views in the layout. This is because
    neither of the other two views has been allocated any weight in the layout XML.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 给 Message 编辑文本设置权重为 `1` 意味着它会占用布局中其他视图未使用的所有额外空间。这是因为布局 XML 中的其他两个视图均未分配权重。
- en: '![image](Images/f0093-03.png)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0093-03.png)'
- en: In this example, we only need to give a weight to a single view. Before we update
    the layout further, let’s see what happens when we need to assign weight to multiple
    views.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只需要为单个视图分配权重。在进一步更新布局之前，让我们看看当需要为多个视图分配权重时会发生什么。
- en: How to add weight to multiple views
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何为多个视图添加权重
- en: When you assign weight to multiple views, the linear layout uses the weight
    you assign to each view to work out what proportion of the remaining space each
    view should take up.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你为多个视图分配权重时，线性布局使用你为每个视图分配的权重来确定每个视图应占用的剩余空间的比例。
- en: 'As an example, suppose we give the To edit text a weight of `1`, and the Message
    edit text a weight of `2`, like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设我们给 To 编辑文本设置权重为 `1`，并给 Message 编辑文本设置权重为 `2`，如下所示：
- en: '[PRE8]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The linear layout spots that the To and Message editable text views have weights,
    and it uses these to work out how much space each view should take up.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 线性布局中，To 和 Message 可编辑文本视图具有权重，并使用它们来确定每个视图应占用的空间量。
- en: It starts by adding together the `android:layout_weight` attributes for each
    view. In this example, the To and Message views have weights of 1 and 2 respectively,
    giving a total of 3.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 它首先将每个视图的 `android:layout_weight` 属性相加。在这个例子中，To 和 Message 视图的权重分别为 1 和 2，总计为
    3。
- en: The proportion of extra space taken up by each view is the view’s weight divided
    by the total weight. The To view has a weight of `1`, so this means it will take
    up 1/3 of the remaining space in the layout. The Message view has a weight of
    `2`, so it will take up 2/3 of the remaining space.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 每个视图占用的额外空间比例是视图的权重除以总权重。To 视图的权重为 `1`，这意味着它将占用布局中剩余空间的 1/3。Message 视图的权重为 `2`，因此它将占用剩余空间的
    2/3。
- en: Now that you’ve learned how to use weight, let’s continue to update the layout.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学会如何使用权重，让我们继续更新布局。
- en: '![image](Images/f0094-02.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0094-02.png)'
- en: The gravity attribute controls the position of a view’s contents
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: gravity 属性控制视图内容的位置
- en: The next thing we’ll do is move the hint text that’s displayed inside the Message
    edit text. At the moment, it’s centered vertically inside the view. We want to
    change it so that the text appears at the top of the edit text field, and we can
    achieve this using the `**android:gravity**` attribute.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将移动显示在 Message 编辑文本内的提示文本。目前，它在视图内垂直居中显示。我们想要改变它，使文本显示在编辑文本字段的顶部，我们可以使用
    `**android:gravity**` 属性来实现这一点。
- en: 'The `android:gravity` attribute lets you specify how you want to position the
    contents of a view inside the view—for example, how you want to position text
    inside a text view. If you want a view’s contents to appear at the top of the
    view, as we do here, we can set its `android:gravity` attribute to `"top"` like
    this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:gravity` 属性允许你指定如何在视图内部定位视图内容，例如如何在文本视图内部定位文本。如果你希望视图内容显示在视图顶部，就像我们在这里做的一样，我们可以将其
    `android:gravity` 属性设置为 `"top"`，如下所示：'
- en: '[PRE9]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We’ll add an `android:gravity` attribute to the Message edit text so that the
    hint text moves to the top of the view. Here’s the code; update *activity_main.xml*
    to include the change (in bold):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为 Message 编辑文本添加一个 `android:gravity` 属性，以便提示文本移动到视图顶部。这里是代码；更新 *activity_main.xml*
    以包含更改（**加粗部分**）：
- en: '![image](Images/f0095-02.png)![image](Images/f0095-03.png)![image](Images/f0095-04.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0095-02.png)![image](Images/f0095-03.png)![image](Images/f0095-04.png)'
- en: You’ll find a list of other values you can use with the `android:gravity` attribute
    on the next page.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在下一页上找到可以在 android:gravity 属性中使用的其他值的列表。
- en: Values you can use with the android:gravity attribute
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您可以在 android:gravity 属性中使用的值
- en: 'Here are some more of the values you can use with the `android:gravity` attribute.
    Add the attribute to your view, and set its value to one of the values below:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是您可以在 android:gravity 属性中使用的更多值。将属性添加到您的视图中，并将其值设置为以下值之一：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '| **`top`** | Puts the view’s contents at the top of the view. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| **`top`** | 将视图内容放在视图的顶部。 |'
- en: '| **`bottom`** | Puts the view’s contents at the bottom of the view. |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **`bottom`** | 将视图内容放在视图的底部。 |'
- en: '| **`start`** | Puts the view’s contents at the start of the view. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **`start`** | 将视图内容放在视图的开头。 |'
- en: '| **`end`** | Puts the view’s contents at the end of the view. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **`end`** | 将视图内容放在视图的末尾。 |'
- en: '| **`center_vertical`** | Centers the view’s contents vertically. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **`center_vertical`** | 将视图内容垂直居中。 |'
- en: '| **`center_horizontal`** | Centers the view’s contents horizontally. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **`center_horizontal`** | 将视图内容水平居中。 |'
- en: '| **`center`** | Centers the view’s contents vertically and horizontally. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **`center`** | 将视图内容垂直和水平居中。 |'
- en: '| **`fill_vertical`** | Makes the view’s contents fill the view vertically.
    |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| **`fill_vertical`** | 使视图内容垂直填充视图。 |'
- en: '| **`fill_horizontal`** | Makes the view’s contents fill the view horizontally.
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| **`fill_horizontal`** | 使视图内容水平填充视图。 |'
- en: '| **`fill`** | Makes the view’s contents fill the view vertically and horizontally.
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **`fill`** | 使视图内容在垂直和水平方向填充视图。 |'
- en: 'You can also apply multiple gravities to a view by separating each value with
    a “|”. To sink a view’s contents to the bottom-end corner, for example, you’d
    use:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以通过用“|”分隔每个值来将多个重力应用于视图。例如，要将视图内容沉入底端角落，您可以使用：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now that you know how to position a view’s contents using gravity, have a go
    at the following exercise on the next page.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何使用重力来定位视图的内容，请尝试下一页的练习。
- en: '**android:gravity lets you say where you want the view’s contents to appear
    inside the view.**'
  id: totrans-143
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**android:gravity 可让你指定视图内容在视图内的位置。**'
- en: Layout Magnets
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局磁铁
- en: '![image](Images/common02.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/common02.png)'
- en: Somebody used fridge magnets to create a linear layout that, when run, produces
    the output below. Unfortunately, a passing sharknado has dislodged some of the
    magnets. Can you piece the code back together again?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有人用冰箱磁铁创建了一个线性布局，运行时生成下面的输出。不幸的是，一场过境的鲨龙飓风使一些磁铁脱落了。你能把代码重新拼凑起来吗？
- en: Note
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Hint: You won’t need to use all of the magnets.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：你不需要使用所有的磁铁。
- en: '![image](Images/f0097-01.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0097-01.png)'
- en: Layout Magnets Solution
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局磁铁解决方案
- en: '![image](Images/common02.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/common02.png)'
- en: Somebody used fridge magnets to create a linear layout that, when run, produces
    the output below. Unfortunately, a passing sharknado has dislodged some of the
    magnets. Can you piece the code back together again?
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 有人用冰箱磁铁创建了一个线性布局，运行时生成下面的输出。不幸的是，一场过境的鲨龙飓风使一些磁铁脱落了。你能把代码重新拼凑起来吗？
- en: '![image](Images/f0098-01.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0098-01.png)'
- en: The story so far
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 到目前为止的故事
- en: 'So far, we’ve added three views to the linear layout, and adjusted their position
    by adding `layout_weight` and `gravity` attributes to the Message edit text. These
    attributes mean that the edit text uses up any extra space that’s not being used
    by either of the other views, and its hint text is displayed at the top of the
    view:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经向线性布局添加了三个视图，并通过将 `layout_weight` 和 `gravity` 属性添加到消息编辑文本来调整它们的位置。这些属性意味着编辑文本会使用未被其他视图使用的任何额外空间，并且其提示文本显示在视图的顶部：
- en: '![image](Images/f0099-02.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图像](Images/f0099-02.png)'
- en: Our linear layout is nearly complete, but there are just two more changes we’re
    going to make.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的线性布局几乎完成了，但我们还要做两个更改。
- en: '**Move the Send button to the end edge.**'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**将发送按钮移动到末端边缘。**'
- en: For left-to-right languages, this will move the button over to the right.
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于从左到右的语言，这将使按钮移到右侧。
- en: '**Add more space between the Message edit text and the top of the button.**'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**在消息编辑文本和按钮顶部之间添加更多的空间。**'
- en: Let’s see how to do this, starting with moving the button to the end.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何做到这一点，首先将按钮移动到末尾。
- en: layout-gravity controls the position of a view within a layout
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局重力控制视图在布局内的位置
- en: To move the button to the end edge of the layout, we’ll add an `**android:layout_gravity**`
    attribute to the button.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要将按钮移到布局的末端，我们将在按钮上添加一个 `**android:layout_gravity**` 属性。
- en: The `android:layout_gravity` attribute lets you specify where you want a view
    in a linear layout to appear in its enclosing space. You can use it to push a
    view to the right, for instance, or center the view horizontally.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:layout_gravity` 属性允许你指定线性布局中视图的位置，使其出现在其封闭空间的右侧，例如，或者在水平方向上居中视图。'
- en: 'To move the Send button to the end edge of the layout, we’ll set the `android:layout_gravity`
    attribute to `"end"` using code like this:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要将发送按钮移到布局的末尾边缘，我们将使用以下代码将 `android:layout_gravity` 属性设置为`"end"`：
- en: '![image](Images/f0100-02.png)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0100-02.png)'
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '**Linear layouts have two attributes that sound similar to one another, gravity
    and layout_gravity.**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性布局有两个听起来相似的属性，gravity 和 layout_gravity。**'
- en: Previously, we used the `android:gravity` attribute to position the Message
    hint text inside an edit text. This is because the `android:gravity` attribute
    lets you say where you want a view’s **contents** to appear.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用 `android:gravity` 属性来定位编辑文本内部的消息提示文本。这是因为 `android:gravity` 属性让你指定视图的**内容**出现在哪里。
- en: '`android:layout_gravity` deals with the **placement of the view itself**, and
    lets you control where views appear in their available space. In our case, we
    want the view to move to the end of its available space, so we’re using:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:layout_gravity` 处理**视图本身的放置**，让你控制视图出现在它们可用空间的位置。在我们的情况下，我们希望视图移到其可用空间的末尾，所以我们正在使用：'
- en: '![image](Images/f0100-03.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0100-03.png)'
- en: '[PRE13]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Take a look at the next page, and you’ll see a list of some of the other values
    you can use with the `android:layout_gravity` attribute.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下一页，你会看到一些你可以与 `android:layout_gravity` 属性一起使用的其他值的列表。
- en: More values you can use with the android:layout-gravity attribute
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你可以使用 android:layout-gravity 属性的更多值
- en: 'Here are some of the values you can use with the `android:layout_gravity` attribute.
    Add the attribute to your view, and set its value to one of the values below:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是你可以与 `android:layout_gravity` 属性一起使用的一些值。将该属性添加到你的视图中，并将其值设置为以下值之一：
- en: '[PRE14]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '| **Value** | **What it does** |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| **Value** | **它的作用** |'
- en: '| **`top, bottom, start, end`** | Puts the view at the top, bottom, start,
    or end of its available space. |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| **`top, bottom, start, end`** | 将视图放置在其可用空间的顶部、底部、开始或结束位置。 |'
- en: '| **`center_vertical, center_horizontal`** | Centers the view vertically or
    horizontally in its available space. |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| **`center_vertical, center_horizontal`** | 在其可用空间中垂直或水平居中视图。 |'
- en: '| **`center`** | Centers the view vertically and horizontally in its available
    space. |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| **`center`** | 在其可用空间中垂直和水平居中视图。 |'
- en: '| **`fill_vertical, fill_horizontal`** | Grows the view so that it fills its
    available space vertically or horizontally. |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| **`fill_vertical, fill_horizontal`** | 使视图增长，以便在其垂直或水平的可用空间中填满。 |'
- en: '| **`fill`** | Grows the view so that it fills its available space vertically
    and horizontally. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **`fill`** | 使视图增长以充满其垂直和水平的可用空间。 |'
- en: 'You can assign multiple values to a view’s `android:layout_gravity` attribute
    by separating each value with a “`|`”. To move a view to the bottom-end corner
    of its available space, for example, you’d use the code:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过用“`|`”分隔每个值来为视图的 `android:layout_gravity` 属性指定多个值。例如，要将视图移动到其可用空间的底端结束角，你可以使用以下代码：
- en: '[PRE15]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that you know how change a view’s position using the `android:layout_gravity`
    attribute, let’s find out how to add more space between views.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何使用 `android:layout_gravity` 属性改变视图的位置了，接下来让我们看看如何在视图之间添加更多的空间。
- en: '**android:layout_gravity lets you say where you want views to appear in their
    available space.**'
  id: totrans-186
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**android:layout_gravity 让你指定你希望视图出现在它们可用空间中的位置。**'
- en: ''
  id: totrans-187
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**android:layout_gravity deals with the placement of the view itself, whereas
    android:gravity controls the view’s contents**.'
  id: totrans-188
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**android:layout_gravity 处理视图本身的放置，而android:gravity 控制视图的内容**。'
- en: Use margins to add space between views
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用margins来在视图之间添加空间
- en: When you position views using a linear layout, the layout doesn’t leave much
    space between them. You can increase the amount of space around a view by adding
    one or more **margins** to it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用线性布局来定位视图时，布局不会在它们之间留下太多空间。通过给视图添加一个或多个**margins**，你可以增加视图周围的空间。
- en: 'Suppose you have two views in a linear layout—an edit text that’s positioned
    above a button. If you wanted to increase the space between the two views, you
    could add a margin of 40dp to the top of the button using the `android:layout_marginTop`
    attribute like this:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个线性布局中有两个视图——一个位于按钮上方的编辑文本。如果你想增加两个视图之间的空间，你可以使用`android:layout_marginTop`
    属性给按钮顶部添加40dp的margin，就像这样：
- en: '![image](Images/f0102-02.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0102-02.png)'
- en: 'Here’s a list of the types of margin you can use to give your views extra space.
    Add the attribute to the view, and set its value to the size of margin you want:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这里列出了你可以使用的边距类型，以给视图添加额外空间。将属性添加到视图中，并将其值设置为你想要的边距大小：
- en: '[PRE16]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '| **Attribute** | **What it does** |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **作用** |'
- en: '| **`layout_marginTop`** | Adds extra space to the top of the view. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| **`layout_marginTop`** | 在视图顶部添加额外空间。 |'
- en: '| **`layout_marginBottom`** | Adds extra space to the bottom of the view. |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| **`layout_marginBottom`** | 在视图底部添加额外空间。 |'
- en: '| **`layout_marginStart`** | Adds extra space to the start of the view. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| **`layout_marginStart`** | 在视图的开始位置添加额外空间。 |'
- en: '| **`layout_marginEnd`** | Adds extra space to the end of the view. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| **`layout_marginEnd`** | 在视图的结束位置添加额外空间。 |'
- en: '| **`layout_margin`** | Adds equal space to each side of the view. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| **`layout_margin`** | 在视图的每一侧添加相等的空间。 |'
- en: '| **`layout_marginVertical, layout_marginHorizontal`** | Adds equal space to
    the vertical (top and bottom) or horizontal (start and end) edges of the view.
    |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **`layout_marginVertical, layout_marginHorizontal`** | 在视图的垂直（顶部和底部）或水平（开始和结束）边缘添加相等的空间。
    |'
- en: The full linear layout code
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完整的线性布局代码
- en: 'Now that you know a view’s `layout_gravity` and `margin` attributes, let’s
    use them in the linear layout code to reposition the button and add some space
    to its top edge. Here’s the full code for *activity_main.xml*; update the code
    to include the changes below (in bold):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了视图的`layout_gravity`和`margin`属性，让我们在线性布局代码中使用它们来重新定位按钮并在其顶部边缘添加一些空间。以下是*activity_main.xml*的完整代码；更新代码以包含以下更改（用粗体标出）：
- en: '![image](Images/f0103-02.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0103-02.png)'
- en: We’ve now finished writing the linear layout code, so let’s take it for a test
    drive.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了线性布局代码的编写，现在让我们来测试一下。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![图片](Images/car.png) 测试驾驶'
- en: Once you’ve made the changes to your app, go ahead and run it.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对应用进行更改后，继续运行它。
- en: 'The app displays a linear layout featuring three views: two editable text views
    and a button. The views are displayed in a vertical column. The To view appears
    at the top, the Send button is displayed in the bottom end corner, and the Message
    view takes up any extra space, allowing for a margin of 40dp at the top edge of
    the button.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用显示了一个线性布局，包含三个视图：两个可编辑文本视图和一个按钮。这些视图以垂直列的方式显示。To 视图显示在顶部，Send 按钮显示在底部的结束角，Message
    视图占据任何额外空间，允许按钮顶部边缘有 40dp 的边距。
- en: Now that you know how to create a linear layout, and control how its views are
    displayed, have a go at the exercise on the next page.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道如何创建线性布局，并控制其视图的显示方式，试试下一页的练习吧。
- en: '![image](Images/f0104-02.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0104-02.png)'
- en: BE the Layout
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为布局
- en: '![image](Images/common04.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common04.png)'
- en: '**The code below describes a complete linear layout. Your job is to play like
    you’re the layout, and say which screen (A or B) the layout will produce when
    run.**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**下面的代码描述了一个完整的线性布局。你的任务是扮演布局，说出当运行时该布局会产生哪个屏幕（A 或 B）。**'
- en: '[PRE17]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![image](Images/f0105-01.png)![image](Images/f0105-02.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0105-01.png)![图片](Images/f0105-02.png)'
- en: BE the Layout Solution
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为布局解决方案
- en: '![image](Images/common04.png)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/common04.png)'
- en: '**The code below describes a complete linear layout. Your job is to play like
    you’re the layout, and say which screen (A or B) the layout will produce when
    run.**'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '**下面的代码描述了一个完整的线性布局。你的任务是扮演布局，说出当运行时该布局会产生哪个屏幕（A 或 B）。**'
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '![image](Images/f0106-02.png)![image](Images/f0106-03.png)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0106-02.png)![图片](Images/f0106-03.png)'
- en: Your activity code tells Android which layout it uses
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的活动代码告诉 Android 使用哪个布局
- en: So far in this chapter, you’ve learned how to use a linear layout and fine-tune
    the way in which its views are displayed. Before we introduce you to another type
    of layout, let’s go behind the scenes and look at what happens to the layout when
    the app runs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，你已经学会了如何使用线性布局，并微调其视图的显示方式。在介绍另一种布局类型之前，让我们来看看应用运行时布局发生了什么。
- en: As you already know, when Android runs an app, it launches the app’s main activity.
    In the current app, this is an activity named `MainActivity`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经知道的，当 Android 运行一个应用时，它会启动应用的主活动。在当前应用中，这是一个名为`MainActivity`的活动。
- en: 'When the activity launches, its `onCreate()` method runs. This method includes
    the following code that specifies which layout the activity should use:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动启动时，它的`onCreate()`方法运行。该方法包括以下代码，指定活动应该使用哪个布局：
- en: '![image](Images/f0107-01.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0107-01.png)'
- en: As you can see, the above code tells Android which layout to use by passing
    the name of a layout to a method named `setContentView()`. The method then displays
    the layout on the screen.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可以看到的，上述代码通过将布局的名称传递给名为`setContentView()`的方法来告诉Android使用哪个布局。然后，该方法在屏幕上显示布局。
- en: The layout’s views are inflated into objects
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局的视图被膨胀为对象
- en: 'As well as displaying the layout on the device screen, the `setContentView()`
    method converts the views in the layout’s XML into objects. This process is called
    **layout inflation** because it *inflates* each view into an object:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在设备屏幕上显示布局之外，`setContentView()`方法还将布局中的视图转换为对象。这个过程称为**布局膨胀**，因为它*膨胀*每个视图为一个对象：
- en: '![image](Images/f0107-02.png)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0107-02.png)'
- en: Layout inflation is important because it’s what allows your activity code to
    manipulate the views in your layout. Behind the scenes, each view is rendered
    to an object, which you can interact with using activity code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 布局膨胀非常重要，因为它允许您的活动代码操作布局中的视图。在幕后，每个视图都被渲染为一个对象，您可以使用活动代码与之交互。
- en: Let’s see how layout inflation works with the linear layout code we’ve built.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看布局膨胀如何与我们构建的线性布局代码一起工作。
- en: '**When you run your app, Android instantiates the layout XML by converting
    each of the layout’s items into an object. This is known as layout inflation.**'
  id: totrans-232
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**当你运行应用程序时，Android通过将布局中的每个项目转换为对象来实例化布局XML。这称为布局膨胀。**'
- en: 'Layout inflation: an example'
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局膨胀：一个示例
- en: 'As you already know, the linear layout code displays two editable text views
    and a button inside a linear layout:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，线性布局代码在线性布局内显示了两个可编辑文本视图和一个按钮：
- en: '![image](Images/f0108-02.png)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0108-02.png)'
- en: 'When the app runs, the views in the layout get inflated into objects. The linear
    layout is inflated to a `LinearLayout` object, the editable text views are inflated
    to `EditText` objects, and the button is inflated to a `Button`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时，布局中的视图被膨胀为对象。线性布局被膨胀为`LinearLayout`对象，可编辑文本视图被膨胀为`EditText`对象，按钮被膨胀为`Button`：
- en: '![image](Images/f0108-03.png)![image](Images/f0108-04.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0108-03.png)![图片](Images/f0108-04.png)'
- en: 'Now that you know how layout inflation works, let’s find out how to use a new
    type of layout: a **frame layout**.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您了解了布局膨胀的工作原理，让我们看看如何使用一种新类型的布局：**帧布局**。
- en: A frame layout stacks its views
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧布局堆叠其视图
- en: '![image](Images/f0109-01.png)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0109-01.png)'
- en: As you already know, a linear layout arranges its views in a single row or column.
    Each view is allocated its own space on the screen, and they don’t overlap one
    another.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，线性布局将其视图排列在单行或单列中。每个视图在屏幕上都被分配了自己的空间，它们不会彼此重叠。
- en: Sometimes, however, you *want* your views to overlap. As an example, suppose
    you want to display an image with some text overlaid on top of it. You wouldn’t
    be able to achieve this just using a linear layout.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候你*希望*你的视图重叠。例如，假设你想显示一张图片，并在其上覆盖一些文本。你不能仅仅使用线性布局来实现这一点。
- en: If you want a layout whose views can overlap, a simple option is to use a frame
    layout. Instead of displaying its views in a single row or column, it stacks them,
    one on top of another. It’s often used to hold just a single view.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要一个视图可以重叠的布局，一个简单的选择是使用帧布局。它不是将其视图显示在单行或单列中，而是将它们堆叠在一起，一层叠一层地。通常用于仅包含单个视图的情况。
- en: We’ll examine how frame layouts work by creating a useful app which displays
    some text on top of a duck image. We’ll start by creating a new project.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过创建一个显示一些文本覆盖在鸭子图片上的有用应用程序来研究帧布局的工作原理。我们将从创建一个新项目开始。
- en: '![image](Images/f0109-02.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0109-02.png)'
- en: Create a new project
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新项目
- en: Create a new Android Studio project using the same steps you used earlier. Choose
    the Empty Activity option, enter a name of “Frame Layout Example” and a package
    name of “com.hfad.framelayoutexample”, and accept the default save location. Make
    sure the language is set to Kotlin, and that the minimum SDK is API 21 so that
    it will run on most Android devices.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用与之前相同的步骤创建一个新的Android Studio项目。选择空活动选项，输入名称“Frame Layout Example”和包名称“com.hfad.framelayoutexample”，接受默认保存位置。确保语言设置为Kotlin，并且最低SDK为API
    21，以便它能在大多数Android设备上运行。
- en: Now that we’ve created the project, let’s define a frame layout.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了项目，让我们来定义一个帧布局。
- en: How to define a frame layout
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何定义一个帧布局
- en: 'You define a frame layout using the `<FrameLayout>` element like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`<FrameLayout>`元素来定义一个帧布局，如下所示：
- en: '![image](Images/f0109-03.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0109-03.png)'
- en: Just like a linear layout and any other type of view or view group, the `android:layout_width`
    and `android:layout_height` attributes specify the layout’s width and height,
    and are mandatory. You can optionally add `padding` attributes too, although we’ve
    not done so here.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 就像线性布局和任何其他类型的视图或视图组一样，`android:layout_width`和`android:layout_height`属性指定布局的宽度和高度，是必需的。您也可以选择添加`padding`属性，但在这里我们没有这样做。
- en: The above code creates an empty frame layout, so let’s go ahead and add a duck
    image to it.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码创建了一个空的帧布局，让我们继续向其中添加一只鸭子图像。
- en: Add an image to your project
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将图像添加到您的项目
- en: We’re going to display an image called *duck.webp* in the frame layout, but
    first, we need to add the file to the project.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在帧布局中显示一个名为*duck.webp*的图像，但首先需要将文件添加到项目中。
- en: To do this, you need to create a *drawable* resource folder (if Android Studio
    hasn’t already created one for you). This is the default folder for storing image
    resources in your app. Switch to the Project view of Android Studio’s explorer,
    select the *app/src/main/res* folder, go to the File menu, choose the New… option,
    then click on the option to create a new Android resource directory. When prompted,
    choose a resource type of “drawable”, name the folder “drawable”, and click on
    OK.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此操作，您需要创建一个*drawable*资源文件夹（如果Android Studio尚未为您创建）。这是存储应用中图像资源的默认文件夹。切换到Android
    Studio资源管理器的项目视图，选择*app/src/main/res*文件夹，转到文件菜单，选择“新建…”选项，然后点击创建新的Android资源目录选项。当提示时，选择资源类型为“drawable”，命名文件夹为“drawable”，然后点击确定。
- en: Next, download the file *duck.webp* from *tinyurl.com/hfad3*, then add it to
    the *app/src/main/res/drawable* folder.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从*tinyurl.com/hfad3*下载文件*duck.webp*，然后将其添加到*app/src/main/res/drawable*文件夹中。
- en: 'We’re going to display *duck.webp* in an image view (a view that displays an
    image) that we’ll add to the frame layout. An image view is defined using the
    `<ImageView>` element like this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在图像视图中显示*duck.webp*（显示图像的视图），这将添加到帧布局中。图像视图的定义如下，使用`<ImageView>`元素：
- en: '![image](Images/f0110-02.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0110-02.png)'
- en: The `<ImageView>` element includes the `android:layout_width` and `android:layout_height`
    attributes, which you’re already familiar with, along with three new ones.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '`<ImageView>`元素包括`android:layout_width`和`android:layout_height`属性，这些您已经很熟悉，还有三个新属性。'
- en: The `android:src` attribute specifies what image should be displayed in the
    image view. We’ve set this to `"@drawable/duck"` so that it uses *duck.webp* in
    the *drawable* folder.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:src`属性指定图像视图中应显示的图像。我们将其设置为`"@drawable/duck"`，以便使用*drawable*文件夹中的*duck.webp*。'
- en: The `android:contentDescription` attribute provides a text description of the
    image for accessibility.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:contentDescription`属性为无障碍提供了图像的文本描述。'
- en: Finally, the `android:scaleType` attribute describes how you want to scale the
    image. We’ve used `"centerCrop"`, which crops the edges of the image.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`android:scaleType`属性描述了您希望如何缩放图像。我们使用了`"centerCrop"`，它裁剪图像的边缘。
- en: That’s everything that you need to know in order to display the duck image in
    a frame layout. Before we find out how to display some text on top of it, let’s
    take a closer look at how you use image—or *drawable*—resources.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您在帧布局中显示鸭子图像所需的全部信息。在弄清如何在其上显示文本之前，让我们更仔细地看看如何使用图像——或*drawable*资源。
- en: A frame layout stacks views in the order they appear in the layout XML
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 帧布局按照在布局XML中出现的顺序堆叠视图
- en: When you define a frame layout, you list views in the order you want them to
    be stacked. The first view is displayed first, the second is stacked on top of
    it, and so on.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 定义帧布局时，按您希望它们叠放的顺序列出视图。首先显示第一个视图，然后将第二个视图叠加在其上，依此类推。
- en: 'Here, we’re going to display a text view on top of the image view, so we’ll
    add it below the image view in the XML. Update the *activity_main.xml* code so
    that it matches the code shown here:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在图像视图的顶部显示一个文本视图，因此我们将在XML中的图像视图下方添加它。更新*activity_main.xml*代码，使其与此处显示的代码匹配：
- en: '![image](Images/f0112-02.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0112-02.png)'
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: When we run the app, an image of a duck appears on the device with the text
    “It’s a duck!” in the top corner.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用时，设备上将显示一只鸭子的图像，并在左上角显示“这是一只鸭子！”的文本。
- en: '![image](Images/f0112-03.png)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0112-03.png)'
- en: All layouts are a type of ViewGroup…
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 所有布局都是ViewGroup的一种类型...
- en: Even though they display their views in different ways, you may have noticed
    that linear layouts and frame layouts have a lot in common with one another. They
    can each hold views, for example, and they also have their own policy that determines
    how views are displayed.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管它们以不同的方式显示它们的视图，但您可能已经注意到线性布局和帧布局在很多方面都有相似之处。例如，它们都可以容纳视图，并且它们还有自己的策略来确定如何显示视图。
- en: 'There’s a good reason for this commonality. Behind the scenes, all layouts—including
    linear layouts and frame layouts—are subclasses of the `android.view.ViewGroup`
    superclass:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这种共性背后有一个很好的原因。幕后，所有布局——包括线性布局和帧布局——都是 `android.view.ViewGroup` 超类的子类：
- en: '![image](Images/f0113-02.png)'
  id: totrans-275
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0113-02.png)'
- en: …and a ViewGroup is a type of View
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: …而 ViewGroup 是 View 的一种类型
- en: The `ViewGroup` class is a subclass of `View` that can hold other views. Behind
    the scenes, every layout is a subclass of `ViewGroup`, which means that **every
    layout is also a type of** `**View**`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewGroup` 类是 `View` 的一个子类，可以容纳其他视图。在幕后，每个布局都是 `ViewGroup` 的一个子类，这意味着 **每个布局也是**
    `**View**` 的一种类型。'
- en: This class hierarchy means that all views and layouts share common attributes
    and behavior. They can all be displayed on the screen, for instance, and you get
    to say how tall or wide they should be. It’s why you need to specify values for
    each view and layout’s `android:layout_height` and `android:layout_width` attributes.
    These attributes are mandatory for all views, and as a layout is a type of view,
    they are also mandatory for all layouts.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类层次结构意味着所有视图和布局都共享公共属性和行为。例如，它们都可以显示在屏幕上，并且您可以指定它们的高度或宽度。这就是为什么您需要为每个视图和布局的
    `android:layout_height` 和 `android:layout_width` 属性指定值的原因。这些属性对所有视图都是强制性的，因为布局也是视图的一种类型，所以对所有布局也是强制性的。
- en: '**Every UI component you add to a layout is a type of View: an object that
    takes up space on the screen.**'
  id: totrans-279
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**您向布局添加的每个 UI 组件都是一种 View 类型：一种占据屏幕空间的对象。**'
- en: ''
  id: totrans-280
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**Every layout is a type of ViewGroup: a type of View that can contain other
    Views.**'
  id: totrans-281
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**每个布局都是 ViewGroup 的一种类型：一种可以容纳其他视图的 View 类型。**'
- en: '**She’s right.**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**她说的对。**'
- en: As you already know, a layout is a type of view that can hold other views. As
    every layout is also a type of view, this means that **layouts can hold other
    layouts**.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经了解的那样，布局是一种可以容纳其他视图的视图类型。由于每个布局也是视图的一种类型，这意味着 **布局可以容纳其他布局**。
- en: Being able to nest layouts inside other layouts is useful because it lets you
    design more complex user interfaces. You can, for example, add horizontal rows
    to a vertical linear layout by nesting horizontal linear layouts inside the root
    linear layout. And if you want to arrange text vertically on top of an image,
    you can do so by nesting a vertical linear layout inside a frame layout.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 能够将布局嵌套在其他布局中是有用的，因为它允许您设计更复杂的用户界面。例如，您可以通过将水平线性布局嵌套在根线性布局中，在垂直线性布局的顶部嵌套一个水平行，如果您想要在图像的顶部垂直排列文本，您可以通过在帧布局中嵌套一个垂直线性布局来实现。
- en: 'Let’s take a closer look at how this works using a new type of layout: a scroll
    view.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这是如何通过一种新类型的布局——滚动视图来实现的。
- en: '![image](Images/f0114-02.png)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0114-02.png)'
- en: A scroll view inserts a vertical scrollbar
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 滚动视图插入了一个垂直滚动条
- en: '![image](Images/f0115-01.png)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0115-01.png)'
- en: A **scroll view** is a type of frame layout that has a vertical scrollbar. It’s
    useful for layouts that are too big for the device they’re running on, as it means
    that you can use it to scroll to any views that don’t fit on the screen.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动视图是一种带有垂直滚动条的帧布局。它对于比设备显示区域大的布局很有用，因为这样你可以使用它滚动到屏幕上放不下的任何视图。
- en: '![image](Images/f0115-02.png)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0115-02.png)'
- en: 'We’re going to create an app that uses a scroll view. Create a new project
    named “Scroll View Example”, choosing the Empty Activity option. Make sure that
    the language is set to Kotlin, and that the minimum SDK is API 21 so that it will
    run on most Android devices. Then replace the code in *activity_main.xml* with
    the code below:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个使用滚动视图的应用程序。创建一个名为“滚动视图示例”的新项目，选择空活动选项。确保语言设置为 Kotlin，并且最低 SDK 版本是 API
    21，以便在大多数 Android 设备上运行。然后用下面的代码替换 *activity_main.xml* 中的代码：
- en: '![image](Images/f0115-03.png)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0115-03.png)'
- en: As you can see, the above layout consists of a simple linear layout that contains
    a Message edit text and a Send button.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，上述布局包含一个简单的线性布局，其中包含消息编辑文本和发送按钮。
- en: Try running the app, and type lots of text into the edit text. The view expands
    to fit the content, and it eventually pushes the Send button off the edge of the
    screen. As there’s no scrollbar, you can no longer access the button.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行应用程序，并在编辑框中输入大量文本。视图会扩展以适应内容，并最终将发送按钮推到屏幕边缘之外。由于没有滚动条，你无法再访问按钮。
- en: To fix this problem, we’ll add a scroll view to the layout. This will give us
    a scrollbar we can use to access the Send button if it’s not visible on the screen.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将向布局中添加一个滚动视图。这将为我们提供一个滚动条，以便在屏幕上看不到发送按钮时可以使用它。
- en: '![image](Images/f0115-04.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0115-04.png)'
- en: How to add a scroll view
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何添加滚动视图
- en: You add a scroll view to your layout using the `**<ScrollView>**` element. The
    `<ScrollView>` element is used in the same way as `<FrameLayout>` except that
    it includes an extra attribute, `**fillViewport**`, which is used to specify whether
    the scroll view should fill the device screen.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `**<ScrollView>**` 元素向布局中添加滚动视图。`<ScrollView>` 元素的使用方式与 `<FrameLayout>` 相同，只是它包含一个额外的属性，`**fillViewport**`，用于指定滚动视图是否应填充设备屏幕。
- en: Note
  id: totrans-299
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: ScrollView is a subclass of FrameLayout, which means it can do everything a
    FrameLayout can, and more.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '**ScrollView** 是 FrameLayout 的一个子类，这意味着它可以做 FrameLayout 能做的一切，而且还能做更多。'
- en: 'In the code below, we’ve added a scroll view to the layout code so that it
    encloses the original linear layout. Update the *activity_main.xml* code to include
    the changes shown here (in bold):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们已经向布局代码中添加了滚动视图，以便它包围原始的线性布局。更新 *activity_main.xml* 代码以包含这里显示的更改（用粗体显示）：
- en: '![image](Images/f0116-02.png)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0116-02.png)'
- en: We’ll take the code for a test drive after you’ve had a go at the following
    exercise.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成以下练习后，我们将对代码进行测试。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: Once you’ve added a scroll view to your layout code, go ahead and run the app.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你在布局代码中添加了滚动视图，就可以运行应用程序。
- en: When you enter lots of text into the Message edit text, the Send button gets
    pushed off the edge of the screen as before. This time, however, we can scroll
    the device screen to reach the button.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在消息编辑框中输入大量文本时，发送按钮会像之前一样被推到屏幕边缘之外。但是这次，我们可以滚动设备屏幕以达到按钮。
- en: Congratulations! You’ve now learned how to use different types of layout to
    control the appearance of your app’s UI. You’ll build on this knowledge in the
    next chapter.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！现在你已经学会了如何使用不同类型的布局来控制你的应用界面的外观。在下一章中，你将在这些知识的基础上继续学习。
- en: '![image](Images/f0119-02.png)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0119-02.png)'
- en: '**All layouts (including linear layouts, frame layouts, and scroll views) can
    hold other layouts.**'
  id: totrans-309
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**所有布局（包括线性布局、帧布局和滚动视图）都可以容纳其他布局。**'
- en: ''
  id: totrans-310
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '**You can build complex layouts by nesting one type of layout inside another.**'
  id: totrans-311
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**你可以通过将一个类型的布局嵌套到另一个布局中来构建复杂的布局。**'
- en: Your Android Toolbox
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的 Android 工具箱
- en: '![image](Images/f0120-01.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0120-01.png)'
- en: '**You’ve got [Chapter 3](#layoutscolon_being_a_layout) under your belt and
    now you’ve added building layouts to your toolbox.**'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '**你已经掌握了[第三章](#layoutscolon_being_a_layout)，现在你已经将构建布局加入到你的工具箱中。**'
- en: '![image](Images/f0120-02.png)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0120-02.png)'
