<html><head></head><body><section data-pdf-bookmark="Chapter 4. Functions" data-type="chapter" epub:type="chapter"><div class="chapter" id="functions">&#13;
<h1><span class="label">Chapter 4. </span>Functions</h1>&#13;
&#13;
&#13;
<p>In the last chapter we covered the basics of TypeScript’s type system: primitive types, objects, arrays, tuples, and enums, as well as the basics of TypeScript’s type inference and how type assignability works. You are now ready for TypeScript’s pièce de résistance (or raison d’être, if you’re a functional programmer): functions.<a data-primary="functions" data-type="indexterm" id="ix_func"/> A few of the topics we’ll cover in this chapter are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The different ways to declare and invoke functions in TypeScript</p>&#13;
</li>&#13;
<li>&#13;
<p>Signature overloading</p>&#13;
</li>&#13;
<li>&#13;
<p>Polymorphic functions</p>&#13;
</li>&#13;
<li>&#13;
<p>Polymorphic type aliases</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Declaring and Invoking Functions" data-type="sect1"><div class="sect1" id="idm46304980234616">&#13;
<h1>Declaring and Invoking Functions</h1>&#13;
&#13;
<p>In JavaScript, functions are first-class objects. That means you can use them exactly like you would <a data-primary="functions" data-secondary="declaring and invoking" data-type="indexterm" id="ix_funcdec"/>any other object: assign them to variables, pass them to other functions, return them from functions, assign them to objects and prototypes, write properties to them, read those properties back, and so on. There is a lot you can do with functions in JavaScript, and TypeScript models all of those things with its rich type system.</p>&#13;
&#13;
<p>Here’s what a function looks like in TypeScript (this should look familiar from the last chapter):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="kt">number</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You will usually explicitly annotate function parameters (<code>a</code> and <code>b</code> in this example)—TypeScript will always infer types throughout the body of your function, but in most cases it won’t infer types for your parameters, except for a few special cases where it can infer types from context (more on that in <a data-type="xref" href="#contextual-typing">“Contextual Typing”</a>). <a data-primary="return types" data-secondary="annotations of" data-type="indexterm" id="idm46304980197160"/>The return type <em>is</em> inferred, but you can explicitly annotate it too if you want:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Throughout this book I’ll explicitly annotate return types where it helps you, the reader, understand what the function does. Otherwise I’ll leave the annotations off because TypeScript already infers them for us, and why would we want to repeat work?</p>&#13;
</div>&#13;
&#13;
<p>The last example used <em>named function syntax</em> to declare <a data-primary="named function syntax" data-type="indexterm" id="idm46304980175176"/><a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="declaring with named function syntax" data-type="indexterm" id="idm46304980174440"/>the function, but JavaScript and TypeScript support at least five ways to do this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Named function</code>&#13;
<code class="kd">function</code> <code class="nx">greet</code><code class="p">(</code><code class="nx">name</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="s1">'hello '</code> <code class="o">+</code> <code class="nx">name</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Function expression</code>&#13;
<code class="kd">let</code> <code class="nx">greet2</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">name</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="s1">'hello '</code> <code class="o">+</code> <code class="nx">name</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Arrow function expression</code>&#13;
<code class="kd">let</code> <code class="nx">greet3</code> <code class="o">=</code> <code class="p">(</code><code class="nx">name</code>: <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="s1">'hello '</code> <code class="o">+</code> <code class="nx">name</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Shorthand arrow function expression</code>&#13;
<code class="kd">let</code> <code class="nx">greet4</code> <code class="o">=</code> <code class="p">(</code><code class="nx">name</code>: <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
  <code class="s1">'hello '</code> <code class="o">+</code> <code class="nx">name</code>&#13;
&#13;
<code class="c1">// Function constructor</code>&#13;
<code class="kd">let</code> <code class="nx">greet5</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Function</code><code class="p">(</code><code class="s1">'name'</code><code class="p">,</code> <code class="s1">'return "hello " + name'</code><code class="p">)</code></pre>&#13;
&#13;
<p>Besides<a data-primary="constructors" data-secondary="safety issues with function constructors" data-type="indexterm" id="idm46304980140520"/> function constructors (which you shouldn’t use unless you are being chased by bees because they are totally unsafe),<sup><a data-type="noteref" href="ch04.html#idm46304980032968" id="idm46304980032968-marker">1</a></sup> all of these syntaxes are supported by TypeScript in a typesafe way, and they all follow the same rules around usually mandatory type annotations for parameters and optional annotations for return types.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A quick refresher on terminology:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A parameter is a piece of data that a function needs to run, declared as part of a function declaration.<a data-primary="formal parameters" data-see="parameters" data-type="indexterm" id="idm46304980027880"/><a data-primary="parameters" data-secondary="defined" data-type="indexterm" id="idm46304980026904"/> Also called a <em>formal parameter</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>An argument is a piece of data that you passed to a function when invoking it. Also called an <em>actual parameter</em>.<a data-primary="actual parameters" data-see="arguments" data-type="indexterm" id="idm46304980023992"/><a data-primary="arguments" data-secondary="defined" data-type="indexterm" id="idm46304980022984"/></p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<p>When you invoke a function in TypeScript, you don’t need to provide any additional type information—just pass in some arguments,<a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="invoking functions" data-type="indexterm" id="idm46304980021128"/><a data-primary="arguments" data-secondary="passing in function calls" data-type="indexterm" id="idm46304980019880"/><a data-primary="parameters" data-secondary="compatibility of arguments with" data-type="indexterm" id="idm46304980018968"/> and TypeScript will go to work checking that your arguments are compatible with the types of your function’s parameters:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>         <code class="c1">// evaluates to 3</code>&#13;
<code class="nx">greet</code><code class="p">(</code><code class="s1">'Crystal'</code><code class="p">)</code>  <code class="c1">// evaluates to 'hello Crystal'</code></pre>&#13;
&#13;
<p>Of course, if you forgot an argument, or passed an argument of the wrong type, TypeScript will be quick <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2345" data-type="indexterm" id="idm46304980008568"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2554" data-type="indexterm" id="idm46304980007480"/>to point it out:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>            <code class="c1">// Error TS2554: Expected 2 arguments, but got 1.</code>&#13;
<code class="nx">add</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">)</code>       <code class="c1">// Error TS2345: Argument of type '"a"' is not assignable</code>&#13;
                  <code class="c1">// to parameter of type 'number'.</code></pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Optional and Default Parameters" data-type="sect2"><div class="sect2" id="optional-function-params">&#13;
<h2>Optional and Default Parameters</h2>&#13;
&#13;
<p>Like in object and tuple types, you can use <code>?</code> to mark parameters as optional.<a data-primary="? (question mark)" data-secondary="for optional function parameters" data-type="indexterm" id="idm46304979994168"/><a data-primary="parameters" data-secondary="optional and default" data-type="indexterm" id="idm46304979993176"/><a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="optional and default parameters" data-type="indexterm" id="idm46304979992232"/> When declaring your function’s parameters, required parameters have to come first, followed by optional parameters:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">log</code><code class="p">(</code><code class="nx">message</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">userId?</code>: <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">time</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">().</code><code class="nx">toLocaleTimeString</code><code class="p">()</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">time</code><code class="p">,</code> <code class="nx">message</code><code class="p">,</code> <code class="nx">userId</code> <code class="o">||</code> <code class="s1">'Not signed in'</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">log</code><code class="p">(</code><code class="s1">'Page loaded'</code><code class="p">)</code> <code class="c1">// Logs "12:38:31 PM Page loaded Not signed in"</code>&#13;
<code class="nx">log</code><code class="p">(</code><code class="s1">'User signed in'</code><code class="p">,</code> <code class="s1">'da763be'</code><code class="p">)</code> <code class="c1">// Logs "12:38:31 PM User signed in da763be"</code></pre>&#13;
&#13;
<p>Like in JavaScript, you can provide default values for optional parameters.<a data-primary="defaults" data-secondary="for function parameters" data-type="indexterm" id="idm46304979889208"/> Semantically it’s similar to making a parameter optional, in that callers no longer have to pass it in (a difference is that default parameters don’t have to be at the end of your list of parameters, while optional parameters do).</p>&#13;
&#13;
<p class="pagebreak-before">For example, we can rewrite <code>log</code> as:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code><code> </code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code>: </code><code class="kt">string</code><code class="p">,</code><code> </code><code class="nx">userId</code><code> </code><strong><code class="o">=</code><code> </code><code class="s1">'Not signed in'</code></strong><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">time</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nb">Date</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">time</code><code class="p">,</code><code> </code><code class="nx">message</code><code class="p">,</code><code> </code><code class="nx">userId</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="nx">log</code><code class="p">(</code><code class="s1">'User clicked on a button'</code><code class="p">,</code><code> </code><code class="s1">'da763be'</code><code class="p">)</code><code>&#13;
</code><code class="nx">log</code><code class="p">(</code><code class="s1">'User signed out'</code><code class="p">)</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Notice how when we give <code>userId</code> a default value, we remove its optional annotation, <code>?</code>.  We also don’t have to type it anymore. TypeScript is smart enough to infer the parameter’s type from its default value, keeping our code terse and easy to read.</p>&#13;
&#13;
<p>Of course, you can also add explicit type annotations to your default parameters, the same way you can for parameters without defaults:</p>&#13;
<pre data-type="programlisting">&#13;
<strong><code class="nx">type</code><code> </code><code class="nx">Context</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">appId?</code><code>: </code><code class="kt">string</code><code>&#13;
  </code><code class="nx">userId?</code><code>: </code><code class="kt">string</code><code>&#13;
</code><code class="p">}</code></strong><code>&#13;
&#13;
</code><code class="kd noBold">function</code><code> </code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code>: </code><code class="kt noBold">string</code><code class="p">,</code><code> </code><strong><code class="nx">context</code><code>: </code><code class="kt">Context</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="p">}</code></strong><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd noBold">let</code><code> </code><code class="nx">time</code><code> </code><code class="o">=</code><code> </code><code class="k noBold">new</code><code> </code><code class="nb">Date</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">time</code><code class="p">,</code><code> </code><code class="nx">message</code><code class="p">,</code><code> </code><strong><code class="nx">context</code><code class="p">.</code></strong><code class="nx">userId</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>You’ll find yourself using default parameters over optional parameters often.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rest Parameters" data-type="sect2"><div class="sect2" id="idm46304979981320">&#13;
<h2>Rest Parameters</h2>&#13;
&#13;
<p>If a function takes a list of arguments,<a data-primary="rest parameters" data-type="indexterm" id="idm46304979710312"/><a data-primary="parameters" data-secondary="rest" data-type="indexterm" id="idm46304979709608"/><a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="rest parameters" data-type="indexterm" id="idm46304979708664"/> you can of course simply<a data-primary="arrays" data-secondary="lists of function parameters passed in as" data-type="indexterm" id="idm46304979707320"/> pass the list in as an array:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting" id="unary-sum"><code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">numbers</code>: <code class="kt">number</code><code class="p">[])</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">numbers</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">total</code><code class="p">,</code> <code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">total</code> <code class="o">+</code> <code class="nx">n</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">sum</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code> <code class="c1">// evaluates to 6</code></pre>&#13;
&#13;
<p>Sometimes, you might opt for a <em>variadic</em> function API—one that takes a variable number of<a data-primary="variadic functions" data-type="indexterm" id="idm46304979668472"/><a data-primary="fixed-arity functions" data-type="indexterm" id="idm46304979667864"/> arguments—instead of a <em>fixed-arity</em> API that takes a fixed number of arguments.<a data-primary="arguments" data-secondary="variable or fixed number of" data-type="indexterm" id="idm46304979666648"/><a data-primary="arity" data-secondary="variadic versus fixed-arity functons" data-type="indexterm" id="idm46304979665704"/> Traditionally, that required using JavaScript’s magic <code>arguments</code> object.</p>&#13;
&#13;
<p><code>arguments</code> is “magic” because your JavaScript runtime automatically defines it for you in functions, and assigns to it the list of arguments you passed to your function. Because <code>arguments</code> is only array-like, and not a true array, you first have to convert it to an array before you can call the built-in <code>.reduce</code> on it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">sumVariadic</code><code class="p">()</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nb">Array</code>&#13;
    <code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">arguments</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">total</code><code class="p">,</code> <code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">total</code> <code class="o">+</code> <code class="nx">n</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">sumVariadic</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code> <code class="c1">// evaluates to 6</code></pre>&#13;
&#13;
<p>But there’s one big problem with using <code>arguments</code>: it’s totally unsafe! If you hover over <code>total</code> or <code>n</code> in your text editor, you’ll see output similar to that shown in <a data-type="xref" href="#fig-arg-unsafe">Figure 4-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="fig-arg-unsafe">&#13;
<img alt="prts 0401" src="assets/prts_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>arguments is unsafe</h6>&#13;
</div></figure>&#13;
&#13;
<p>This means TypeScript inferred that both <code>n</code> and <code>total</code> are of type <code>any</code>, and silently <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2554" data-type="indexterm" id="idm46304979600888"/>let it pass—that is, until you try to use <code>sumVariadic</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">sumVariadic</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code> <code class="c1">// Error TS2554: Expected 0 arguments, but got 3.</code></pre>&#13;
&#13;
<p>Since we didn’t declare that <code>sumVariadic</code> takes arguments, from TypeScript’s point of view it doesn’t take any arguments, so we get a <code>TypeError</code> when we try to use it.</p>&#13;
&#13;
<p>So, how can we safely type variadic functions?</p>&#13;
&#13;
<p>Rest parameters to the rescue! Instead of resorting to the unsafe <code>arguments</code> magic variable, we can instead use rest parameters to safely make our <code>sum</code> function accept any number of arguments:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">sumVariadicSafe</code><code class="p">(...</code><code class="nx">numbers</code>: <code class="kt">number</code><code class="p">[])</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">numbers</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">total</code><code class="p">,</code> <code class="nx">n</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">total</code> <code class="o">+</code> <code class="nx">n</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">sumVariadicSafe</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code> <code class="c1">// evaluates to 6</code></pre>&#13;
&#13;
<p>That’s it! Notice that the only change between this variadic <code>sum</code> and our original single-parameter <code>sum</code> function is the extra <code>...</code> in the parameter list—nothing else has to change, and it’s totally typesafe.<a data-primary="… (ellipsis) in variadic function parameters list" data-type="indexterm" id="idm46304979484392"/></p>&#13;
&#13;
<p>A function can have at most one rest parameter, and that parameter has to be the last one in the function’s parameter list. For example, take a look at TypeScript’s built-in declaration for <code>console.log</code> (if you don’t know what an <code>interface</code> is, don’t worry—we’ll cover it in <a data-type="xref" href="ch05.html#classes">Chapter 5</a>). <code>console.log</code> takes an optional <code>message</code>, and any number of additional arguments to log:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting" id="rest-param-last"><code class="kr">interface</code> <code class="nx">Console</code> <code class="p">{</code>&#13;
  <code class="nx">log</code><code class="p">(</code><code class="nx">message?</code>: <code class="kt">any</code><code class="p">,</code> <code class="p">...</code><code class="nx">optionalParams</code>: <code class="kt">any</code><code class="p">[])</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="call, apply, and bind" data-type="sect2"><div class="sect2" id="call-apply-bind">&#13;
<h2>call, apply, and bind</h2>&#13;
&#13;
<p>In addition to invoking a function with parentheses <code>()</code>, JavaScript supports at least two other ways to call a function.<a data-primary="() (parentheses), invoking functions with" data-type="indexterm" id="idm46304979408920"/><a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="invoking with call, apply, and bind" data-type="indexterm" id="idm46304979408120"/> Take <code>add</code> from earlier in the chapter:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">add</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">)</code>                <code class="c1">// evaluates to 30</code>&#13;
<code class="nx">add</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">])</code>  <code class="c1">// evaluates to 30</code>&#13;
<code class="nx">add</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">)</code>     <code class="c1">// evaluates to 30</code>&#13;
<code class="nx">add</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">20</code><code class="p">)()</code>   <code class="c1">// evaluates to 30</code></pre>&#13;
&#13;
<p><code>apply</code> binds a value to <code>this</code> within your function (in this example, we bind <code>this</code> to <code>null</code>), and spreads its second argument over your function’s parameters. <code>call</code> does the same, but applies its arguments in order instead of spreading.<a data-primary="call function" data-type="indexterm" id="idm46304979330936"/><a data-primary="this variable" data-type="indexterm" id="idm46304979330232"/><a data-primary="apply function" data-type="indexterm" id="idm46304979329560"/></p>&#13;
&#13;
<p><code>bind()</code> is similar, in that it <em>binds</em> a <code>this</code>-argument and a list of arguments to your function. <a data-primary="bind function" data-type="indexterm" id="idm46304979327256"/>The difference is that <code>bind</code> does not invoke your function; instead, it returns a new function that you can then invoke with <code>()</code>, <code>.call</code>, or <code>.apply</code>, passing more arguments in to be bound to the so far unbound parameters if you want.</p>&#13;
<div data-type="tip"><h1>TSC Flag: strictBindCallApply</h1>&#13;
<p>To safely use <code>.call</code>, <code>.apply</code>, and <code>.bind</code> in your code, be sure to enable the <code>strictBindCallApply</code> option in your <em>tsconfig.json</em> (it’s automatically enabled if you already enabled <code>strict</code> mode).<a data-primary="strictBindCallApply option" data-type="indexterm" id="idm46304979320536"/><a data-primary="TSC compiler" data-secondary="strictBindCallApply option" data-type="indexterm" id="idm46304979319832"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Typing this" data-type="sect2"><div class="sect2" id="typing-this">&#13;
<h2>Typing this</h2>&#13;
&#13;
<p>If you’re not coming from JavaScript, you may be surprised to learn that in JavaScript the <code>this</code> variable is defined for every function, not just for those functions that live as methods on classes. <code>this</code> has a different value depending on how you called your function, which can make it notoriously fragile and hard to reason about.<a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="typing this variable" data-type="indexterm" id="idm46304979315368"/><a data-primary="this variable" data-secondary="typing" data-type="indexterm" id="idm46304979314120"/></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>For this reason, a lot of teams ban <code>this</code> everywhere except in class methods—to do this for your codebase too, enable the <code>no-invalid-this</code> TSLint rule.<a data-primary="TSLint" data-secondary="no-invalid-this rule" data-type="indexterm" id="idm46304979311368"/><a data-primary="no-invalid-this TSLint rule" data-type="indexterm" id="idm46304979310360"/></p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">The reason that <code>this</code> is fragile has to do with the way it’s assigned. The general rule is that <code>this</code> will take the value of the thing to the left of the dot when invoking a method.<a data-primary="assignment, this variable" data-type="indexterm" id="idm46304979308072"/> For example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">a() {</code>&#13;
    <code class="k">return</code> <code class="k">this</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">x</code><code class="p">.</code><code class="nx">a</code><code class="p">()</code> <code class="c1">// this is the object x in the body of a()</code></pre>&#13;
&#13;
<p>But if at some point you reassign <code>a</code> before calling it, the result will change!</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">x</code><code class="p">.</code><code class="nx">a</code>&#13;
<code class="nx">a</code><code class="p">()</code> <code class="c1">// now, this is undefined in the body of a()</code></pre>&#13;
&#13;
<p>Say you have a utility function for formatting dates that looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">fancyDate() {</code>&#13;
  <code class="k">return</code> <code class="nx">$</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">getDate</code><code class="p">()}</code><code class="o">/</code><code class="nx">$</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">getMonth</code><code class="p">()}</code><code class="o">/</code><code class="nx">$</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">getFullYear</code><code class="p">()}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You designed this API in your early days as a programmer (before you learned about function parameters). To use <code>fancyDate</code>, you have to call it with a <code>Date</code> bound to <code>this</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">fancyDate</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">)</code> <code class="c1">// evaluates to "4/14/2005"</code></pre>&#13;
&#13;
<p>If you forget to bind a <code>Date</code> to <code>this</code>, you’ll get a runtime exception!</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">fancyDate</code><code class="p">()</code> <code class="c1">// Uncaught TypeError: this.getDate is not a function</code></pre>&#13;
&#13;
<p>Though exploring all of the semantics of <code>this</code> is beyond the scope of this book,<sup><a data-type="noteref" href="ch04.html#idm46304979137208" id="idm46304979137208-marker">2</a></sup> this behavior—that <code>this</code> depends on the way you called a function, and not on the way that you declared it—can be surprising to say the least.</p>&#13;
&#13;
<p>Thankfully, TypeScript has your back. <a data-primary="types" data-secondary="declaring type this variable" data-type="indexterm" id="idm46304979178840"/>If your function uses <code>this</code>, be sure to declare your expected <code>this</code> type as your function’s first parameter (before any additional parameters), and TypeScript will enforce that <code>this</code> really is what you say it is at every call site. <code>this</code> isn’t treated like other parameters—it’s a reserved word when used as part of a function signature:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code><code> </code><code class="nx">fancyDate</code><code class="p">(</code><strong><code class="k">this</code><code class="o">:</code><code> </code><code class="nb">Date</code></strong><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">$</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">getDate</code><code class="p">(</code><code class="p">)</code><code class="p">}</code><code class="o">/</code><code class="nx">$</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">getMonth</code><code class="p">(</code><code class="p">)</code><code class="p">}</code><code class="o">/</code><code class="nx">$</code><code class="p">{</code><code class="k">this</code><code class="p">.</code><code class="nx">getFullYear</code><code class="p">(</code><code class="p">)</code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p class="pagebreak-before">Now here’s what happens when we call <code>fancyDate</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">fancyDate</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">)</code> <code class="c1">// evaluates to "6/13/2008"</code>&#13;
&#13;
<code class="nx">fancyDate</code><code class="p">()</code> <code class="c1">// Error TS2684: The 'this' context of type 'void' is</code>&#13;
            <code class="c1">// not assignable to method's 'this' of type 'Date'.</code></pre>&#13;
&#13;
<p>We took a runtime error,<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2684" data-type="indexterm" id="idm46304979067928"/> and gave TypeScript enough information to warn about the error at compile time instead.</p>&#13;
<div data-type="tip"><h1>TSC Flag: noImplicitThis</h1>&#13;
<p>To enforce that <code>this</code> types are always explicitly annotated in functions, enable the <code>noImplicitThis</code> setting in your <em>tsconfig.json</em>. <code>strict</code> mode includes <code>noImplicitThis</code>, so if you already have that enabled you’re good to go.<a data-primary="noImplicitThis TSC option" data-type="indexterm" id="idm46304979027064"/><a data-primary="TSC compiler" data-secondary="noImplicitThis option" data-type="indexterm" id="idm46304979026392"/></p>&#13;
&#13;
<p>Note that <code>noImplicitThis</code> doesn’t enforce <code>this</code>-annotations for classes, or for functions on objects. </p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generator Functions" data-type="sect2"><div class="sect2" id="generators">&#13;
<h2>Generator Functions</h2>&#13;
&#13;
<p>Generator functions (<em>generators</em> for short) are a convenient way to, well, <em>generate</em> a bunch of values. They give <a data-primary="generator functions" data-type="indexterm" id="idm46304979021608"/><a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="generator functions" data-type="indexterm" id="idm46304979020904"/>the generator’s consumer fine control over the pace at which values are produced. Because they’re lazy—that is, they only compute the next value when a consumer asks for it—they can do things that can be hard to do otherwise, like generate infinite lists.</p>&#13;
&#13;
<p>They work like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code><code class="o">*</code><code> </code><code class="nx">createFibonacciGenerator() {</code><code> </code><a class="co" href="#callout_functions_CO1-1" id="co_functions_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">a</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">b</code><code> </code><code class="o">=</code><code> </code><code class="mi">1</code><code>&#13;
  </code><code class="k">while</code><code> </code><code class="p">(</code><code class="kc">true</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO1-2" id="co_functions_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
    </code><code class="nx">yield</code><code> </code><code class="nx">a</code><code class="p">;</code><code> </code><a class="co" href="#callout_functions_CO1-3" id="co_functions_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="p">[</code><code class="nx">a</code><code class="p">,</code><code> </code><code class="nx">b</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="nx">b</code><code class="p">,</code><code> </code><code class="nx">a</code><code> </code><code class="o">+</code><code> </code><code class="nx">b</code><code class="p">]</code><code> </code><a class="co" href="#callout_functions_CO1-4" id="co_functions_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">fibonacciGenerator</code><code> </code><code class="o">=</code><code> </code><code class="nx">createFibonacciGenerator</code><code class="p">(</code><code class="p">)</code><code> </code><code class="c1">// IterableIterator&lt;number&gt;&#13;
</code><code class="nx">fibonacciGenerator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="p">)</code><code>   </code><code class="c1">// evaluates to {value: 0, done: false}&#13;
</code><code class="nx">fibonacciGenerator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="p">)</code><code>   </code><code class="c1">// evaluates to {value: 1, done: false}&#13;
</code><code class="nx">fibonacciGenerator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="p">)</code><code>   </code><code class="c1">// evaluates to {value: 1, done: false}&#13;
</code><code class="nx">fibonacciGenerator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="p">)</code><code>   </code><code class="c1">// evaluates to {value: 2, done: false}&#13;
</code><code class="nx">fibonacciGenerator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="p">)</code><code>   </code><code class="c1">// evaluates to {value: 3, done: false}&#13;
</code><code class="nx">fibonacciGenerator</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code><code class="p">)</code><code>   </code><code class="c1">// evaluates to {value: 5, done: false}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_functions_CO1-1" id="callout_functions_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The asterisk (<code>*</code>) before a function’s name makes that function a generator.<a data-primary="* (asterisk), before function names" data-type="indexterm" id="idm46304978884344"/> Calling a generator returns an iterable iterator.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO1-2" id="callout_functions_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Our generator can generate values forever.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO1-3" id="callout_functions_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Generators use the <code>yield</code> keyword to, well, <em>yield</em> values.<a data-primary="yield keyword" data-type="indexterm" id="idm46304978896312"/> When a consumer asks for the generator’s next value (for example, by calling <code>next</code>), <code>yield</code> sends a result back to the consumer and pauses execution until the consumer asks for the next value. In this way the <code>while(true)</code> loop doesn’t immediately cause the program to run forever and crash.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO1-4" id="callout_functions_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>To compute the next Fibonacci number, we reassign <code>a</code> to <code>b</code> and <code>b</code> to <code>a + b</code> in a single step.</p></dd>&#13;
</dl>&#13;
&#13;
<p>We called <code>createFibonacciGenerator</code>, and that returned an <code>IterableIterator</code>. <a data-primary="IterableIterator type" data-type="indexterm" id="idm46304978897848"/>Every time we call <code>next</code>, the iterator computes the next Fibonacci number and <code>yield</code>s it back to us. Notice how TypeScript is able to infer the type of our iterator from the type of the value we <code>yield</code>ed.</p>&#13;
&#13;
<p>You can also explicitly annotate a generator, wrapping the type it yields in an <code>IterableIterator</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code><code class="o">*</code> <code class="nx">createNumbers</code><code class="p">()</code><code class="o">:</code> <code class="nx">IterableIterator</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code>&#13;
  <code class="k">while</code> <code class="p">(</code><code class="mi">1</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">yield</code> <code class="nx">n</code><code class="o">++</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="nx">createNumbers</code><code class="p">()</code>&#13;
<code class="nx">numbers</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>              <code class="c1">// evaluates to {value: 0, done: false}</code>&#13;
<code class="nx">numbers</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>              <code class="c1">// evaluates to {value: 1, done: false}</code>&#13;
<code class="nx">numbers</code><code class="p">.</code><code class="nx">next</code><code class="p">()</code>              <code class="c1">// evaluates to {value: 2, done: false}</code></pre>&#13;
&#13;
<p>We won’t delve deeper into generators in this book—they’re a big topic, and since this book is about TypeScript, I don’t want to get sidetracked with JavaScript features. The short of it is they’re a super cool JavaScript language feature that TypeScript supports too. To learn more about generators, head to their page on <a href="https://mzl.la/2UitIk4">MDN</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterators" data-type="sect2"><div class="sect2" id="idm46304979023912">&#13;
<h2>Iterators</h2>&#13;
&#13;
<p>Iterators are the flip side to generators: while generators are a way to produce a stream of values, iterators are a way to consume those values.<a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="iterators" data-type="indexterm" id="ix_funcdeciter"/><a data-primary="iterators" data-type="indexterm" id="ix_iter"/> The terminology can get pretty confusing, so let’s start with a couple of definitions.</p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304978766456">&#13;
<h5>Iterable</h5>&#13;
<p>Any object that contains a property called <code>Symbol.iterator</code>, whose value is a function that returns an iterator.<a data-primary="iterables" data-type="indexterm" id="idm46304978764472"/></p>&#13;
</div></aside>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304978763512">&#13;
<h5>Iterator</h5>&#13;
<p>Any object that defines a method called <code>next</code>, which returns an object with the properties <code>value</code> and <code>done</code>.<a data-primary="iterators" data-secondary="defined" data-type="indexterm" id="idm46304978760536"/></p>&#13;
</div></aside>&#13;
&#13;
<p>When you create a generator (say, by calling <code>createFibonacciGenerator</code>), you get a value back that’s <em>both</em> an iterable and an iterator—an <em>iterable iterator</em>—because it defines both a <code>Symbol.iterator</code> property and a <code>next</code> method.<a data-primary="Symbol.iterator" data-type="indexterm" id="idm46304978756712"/><a data-primary="next method" data-type="indexterm" id="idm46304978755976"/><a data-primary="iterable iterators" data-type="indexterm" id="idm46304978755304"/></p>&#13;
&#13;
<p>You can manually define an iterator or an iterable by creating an object (or a class) that implements <code>Symbol.iterator</code> or <code>next</code>, respectively. For example, let’s define an iterator that returns the numbers 1 through 10:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">n</code> <code class="o">&lt;=</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">n</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">yield</code> <code class="nx">n</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If you type that iterator into your code editor and hover over it, you’ll see what TypeScript infers as its type (<a data-type="xref" href="#fig-manual-define">Figure 4-2</a>).</p>&#13;
&#13;
<figure class="width-50"><div class="figure" id="fig-manual-define">&#13;
<img alt="prts 0402" src="assets/prts_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Manually defining an iterator</h6>&#13;
</div></figure>&#13;
&#13;
<p>In other words, <code>numbers</code> is an iterator, and calling the generator function <code>numbers[Symbol.iterator]()</code> returns an iterable iterator.</p>&#13;
&#13;
<p>Not only can you define your own iterators, but you can use JavaScript’s built-in iterators <a data-primary="JavaScript" data-secondary="built-in iterators for collection types" data-type="indexterm" id="idm46304978704728"/><a data-primary="iterators" data-secondary="built-in, for common collection types" data-type="indexterm" id="idm46304978703784"/>for common collection types—<code>Array</code>, <code>Map</code>, <code>Set</code>, <code>String</code>,<sup><a data-type="noteref" href="ch04.html#idm46304978700968" id="idm46304978700968-marker">3</a></sup> and so on—to do things like:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Iterate over an iterator with for-of</code>&#13;
<code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">a</code> <code class="nx">of</code> <code class="nx">numbers</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="c1">// 1, 2, 3, etc.</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Spread an iterator</code>&#13;
<code class="kd">let</code> <code class="nx">allNumbers</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">numbers</code><code class="p">]</code> <code class="c1">// number[]</code>&#13;
&#13;
<code class="c1">// Destructure an iterator</code>&#13;
<code class="kd">let</code> <code class="p">[</code><code class="nx">one</code><code class="p">,</code> <code class="nx">two</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="nx">numbers</code> <code class="c1">// [number, number, number[]]</code></pre>&#13;
&#13;
<p>Again, we won’t go more deeply into iterators in this book. You can read more about iterators and async iterators on <a href="https://mzl.la/2OAoy1o">MDN</a>.</p>&#13;
<div data-type="tip"><h1>TSC Flag: downlevelIteration</h1>&#13;
<p>If you’re compiling your TypeScript to a JavaScript version older than <code>ES2015</code>, you can enable custom iterators with the <code><span class="keep-together">downlevel</span>Iteration</code> flag in your <em>tsconfig.json</em>.<a data-primary="downlevelIteration TSC flag" data-type="indexterm" id="idm46304978618872"/><a data-primary="TSC compiler" data-secondary="downlevelIteration flag" data-type="indexterm" id="idm46304978618072"/></p>&#13;
&#13;
<p>You may want to keep <code>downlevelIteration</code> disabled if your application is especially sensitive to bundle size: it takes a lot of code to get custom iterators working in older environments. For example, the previous <code>numbers</code> example generates nearly 1 KB of code <span class="keep-together">(gzipped)</span>.<a data-primary="functions" data-secondary="declaring and invoking" data-startref="ix_funcdeciter" data-tertiary="iterators" data-type="indexterm" id="idm46304978615000"/><a data-primary="iterators" data-startref="ix_iter" data-type="indexterm" id="idm46304978613448"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Call Signatures" data-type="sect2"><div class="sect2" id="idm46304978770552">&#13;
<h2>Call Signatures</h2>&#13;
&#13;
<p>So far, we’ve learned to type functions’ parameters and return types. <a data-primary="call signatures" data-type="indexterm" id="ix_callsig"/><a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="call signatures" data-type="indexterm" id="ix_funcdeccall"/>Now, let’s switch gears and talk about how we can express the full types of functions themselves.</p>&#13;
&#13;
<p>Let’s revisit <code>sum</code> from the top of this chapter. As a reminder, it looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What is the type of <code>sum</code>? Well, <code>sum</code> is a function, so its type is:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nb">Function</code></pre>&#13;
&#13;
<p>The <code>Function</code> type, as you may have guessed, is not what you want to use most of the time. Like <code>object</code> describes all objects, <code>Function</code> is a catchall type for all functions, and doesn’t tell you anything about the specific function that it types.<a data-primary="Function type" data-type="indexterm" id="idm46304978565784"/></p>&#13;
&#13;
<p>How else can we type <code>sum</code>? <code>sum</code> is a function that takes two <code>numbers</code> and returns a <code>number</code>. In TypeScript we can express its type as:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="p">(</code><code class="nx">a</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">b</code>: <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code></pre>&#13;
&#13;
<p>This is TypeScript’s syntax for a function’s type, or <em>call signature</em> (also called a <em>type signature</em>). You’ll notice it looks remarkably similar to an arrow function—this is intentional! When you pass functions around as arguments, or return them from other functions, this is the syntax you’ll use to type them.<a data-primary="type signatures" data-see="call signatures" data-type="indexterm" id="idm46304978560392"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The parameter names <code>a</code> and <code>b</code> just serve as documentation, and don’t affect the assignability of a function with that type.</p>&#13;
</div>&#13;
&#13;
<p>Function call <a data-primary="type-level code" data-type="indexterm" id="idm46304978557064"/>signatures only contain <em>type-level</em> code—that is, types only, no values. That means function call signatures can express parameter types, <code>this</code> types (see <a data-type="xref" href="#typing-this">“Typing this”</a>), return types, rest types, and optional types, and they cannot express default values (since a default value is a value, not a type). And because they have no body for TypeScript to infer from, call signatures require explicit return type annotations.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304978505000">&#13;
<h5>Type Level and Value Level Code</h5>&#13;
<p>People use the terms “type-level” and “value-level” a lot when talking about programming with static types, and it helps to have a common vocabulary.</p>&#13;
&#13;
<p>Throughout this book, when I use the term <em>type-level code</em>, what I’m referring to is code that consists exclusively of types and type operators. Contrast that with <em>value-level code</em>, which is everything else.<a data-primary="value-level code" data-type="indexterm" id="idm46304978501944"/> A rule of thumb is: if it’s valid JavaScript code, then it’s value-level; if it’s valid TypeScript but not valid JavaScript, then it’s type-level.<sup><a data-type="noteref" href="ch04.html#idm46304978500936" id="idm46304978500936-marker">4</a></sup></p>&#13;
&#13;
<p>To be extra sure that we’re on the same page, let’s look at an example—the bold terms here are type-level, and everything else is value-level:</p>&#13;
<pre data-type="programlisting">&#13;
<code class="kd noBold">function</code><code> </code><code class="nx">area</code><code class="p">(</code><code class="nx">radius</code><strong><code>: </code><code class="kt">number</code></strong><code class="p">)</code><strong><code class="o">:</code><code> </code><code class="kt">number</code><code> </code><code class="o">|</code><code> </code><code class="kc">null</code></strong><code> </code><code class="p">{</code><code>&#13;
  </code><code class="k noBold">if</code><code> </code><code class="p">(</code><code class="nx">radius</code><code> </code><code class="o">&lt;</code><code> </code><code class="mi">0</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k noBold">return</code><code> </code><code class="kc noBold">null</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="k noBold">return</code><code> </code><code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code><code> </code><code class="o">*</code><code> </code><code class="p">(</code><code class="nx">radius</code><code> </code><code class="o">*</code><code class="o">*</code><code> </code><code class="mi">2</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd noBold">let</code><code> </code><code class="nx">r</code><strong><code>: </code><code class="kt">number</code></strong><code> </code><code class="o">=</code><code> </code><code class="mi">3</code><code>&#13;
</code><code class="kd noBold">let</code><code> </code><code class="nx">a</code><code> </code><code class="o">=</code><code> </code><code class="nx">area</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code><code>&#13;
</code><code class="k noBold">if</code><code> </code><code class="p">(</code><code class="nx">a</code><code> </code><code class="o">!==</code><code> </code><code class="kc noBold">null</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">info</code><code class="p">(</code><code class="s1">'result:'</code><code class="p">,</code><code> </code><code class="nx">a</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>The bold type-level terms are type annotations and the union type operator, <code>|</code>; everything else is a value-level term.</p>&#13;
</div></aside>&#13;
&#13;
<p>Let’s go through a few of the examples of functions we’ve seen so far in this chapter, and pull out their types into standalone call signatures that we’ll bind to type aliases:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// function greet(name: string)</code>&#13;
<code class="nx">type</code> <code class="nx">Greet</code> <code class="o">=</code> <code class="p">(</code><code class="nx">name</code>: <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code>&#13;
&#13;
<code class="c1">// function log(message: string, userId?: string)</code>&#13;
<code class="nx">type</code> <code class="nx">Log</code> <code class="o">=</code> <code class="p">(</code><code class="nx">message</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">userId?</code>: <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
&#13;
<code class="c1">// function sumVariadicSafe(...numbers: number[]): number</code>&#13;
<code class="nx">type</code> <code class="nx">SumVariadicSafe</code> <code class="o">=</code> <code class="p">(...</code><code class="nx">numbers</code>: <code class="kt">number</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="kt">number</code></pre>&#13;
&#13;
<p>Getting the hang of it? The functions’ call signatures look remarkably similar to their implementations. This is intentional, and is a language design choice that makes call signatures easier to reason about.</p>&#13;
&#13;
<p>Let’s make the relationship between call signatures and their implementations more concrete.<a data-primary="call signatures" data-secondary="implementing, example" data-type="indexterm" id="idm46304978396200"/> If you have a call signature, how can you declare a function that implements that signature? You simply combine the call signature with a function expression that implements it. For example, let’s rewrite <code>Log</code> to use its shiny new signature:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Log</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="nx">message</code><code>: </code><code class="kt">string</code><code class="p">,</code><code> </code><code class="nx">userId?</code><code>: </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="k">void</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">log</code><code>: </code><code class="kt">Log</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code> </code><a class="co" href="#callout_functions_CO2-1" id="co_functions_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">message</code><code class="p">,</code><code> </code><a class="co" href="#callout_functions_CO2-2" id="co_functions_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">userId</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Not signed in'</code><code> </code><a class="co" href="#callout_functions_CO2-3" id="co_functions_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO2-4" id="co_functions_CO2-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">time</code><code> </code><code class="o">=</code><code> </code><code class="k">new</code><code> </code><code class="nb">Date</code><code class="p">(</code><code class="p">)</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">(</code><code class="p">)</code><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">time</code><code class="p">,</code><code> </code><code class="nx">message</code><code class="p">,</code><code> </code><code class="nx">userId</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_functions_CO2-1" id="callout_functions_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We declare a function expression <code>log</code>, and explicitly type it as type <code>Log</code>.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO2-2" id="callout_functions_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We don’t need to annotate our parameters twice. Since <code>message</code> is already annotated as a <code>string</code> as part of the definition for <code>Log</code>, we don’t need to type it again here. Instead, we let TypeScript infer it for us from <code>Log</code>.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO2-3" id="callout_functions_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>We add a default value for <code>userId</code>, since we captured <code>userId</code>’s type in our signature for <code>Log</code>, but we couldn’t capture the default value as part of <code>Log</code> because <code>Log</code> is a type and can’t contain values.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO2-4" id="callout_functions_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>We don’t need to annotate our return type again, since we already declared it as <code>void</code> in our <code>Log</code> type.<a data-primary="functions" data-secondary="declaring and invoking" data-startref="ix_funcdeccall" data-tertiary="call signatures" data-type="indexterm" id="idm46304978245496"/><a data-primary="call signatures" data-startref="ix_callsig" data-type="indexterm" id="idm46304978244168"/></p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Contextual Typing" data-type="sect2"><div class="sect2" id="contextual-typing">&#13;
<h2>Contextual Typing</h2>&#13;
&#13;
<p>Notice that the last example was the first example we’ve seen where we didn’t have to explicitly annotate our function parameter types. Because we already declared that <code>log</code> is of type <code>Log</code>, TypeScript is able to infer from context that <code>message</code> has to be of type <code>string</code>. This is a powerful feature of TypeScript’s type inference called <em>contextual typing</em>.<a data-primary="contextual typing" data-type="indexterm" id="idm46304978239288"/><a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="contextual typing" data-type="indexterm" id="idm46304978238680"/></p>&#13;
&#13;
<p>Earlier in this chapter, we touched on one other place where contextual typing comes up: callback functions.<sup><a data-type="noteref" href="ch04.html#idm46304978237208" id="idm46304978237208-marker">5</a></sup></p>&#13;
&#13;
<p>Let’s declare a function <code>times</code> that calls its callback <code>f</code> some number of times <code>n</code>, passing the current index to <code>f</code> each time:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">times</code><code class="p">(</code>&#13;
  <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">index</code>: <code class="kt">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">,</code>&#13;
  <code class="nx">n</code>: <code class="kt">number</code>&#13;
<code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">n</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">f</code><code class="p">(</code><code class="nx">i</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When you call <code>times</code>, you don’t have to explicitly annotate the function you pass to <code>times</code> if you declare that function inline:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">times</code><code class="p">(</code><code class="nx">n</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">),</code> <code class="mi">4</code><code class="p">)</code></pre>&#13;
&#13;
<p>TypeScript infers from context that <code>n</code> is a <code>number</code>—we declared that <code>f</code>’s argument <code>index</code> is a <code>number</code> in <code>times</code>’s signature, and TypeScript is smart enough to infer that <code>n</code> is that argument, so it must be a <code>number</code>.</p>&#13;
&#13;
<p>Note that if <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS7006" data-type="indexterm" id="idm46304978181368"/>we didn’t declare <code>f</code> inline, TypeScript wouldn’t have been able to infer its type:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Error TS7006: Parameter 'n' implicitly has an 'any' type.</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">times</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="mi">4</code><code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Overloaded Function Types" data-type="sect2"><div class="sect2" id="function-overloads">&#13;
<h2>Overloaded Function Types</h2>&#13;
&#13;
<p>The function type syntax we used in the last section—<code>type Fn = (...) =&gt; ...</code>—is a <em>shorthand call signature</em>. <a data-primary="overloaded function types" data-type="indexterm" id="ix_ovrfunc"/><a data-primary="functions" data-secondary="declaring and invoking" data-tertiary="overloaded function types" data-type="indexterm" id="ix_funcdecovr"/><a data-primary="shorthand call signatures" data-type="indexterm" id="idm46304978091304"/><a data-primary="call signatures" data-secondary="shorthand  versus written out fully" data-type="indexterm" id="idm46304978090664"/>We can instead write it out more explicitly. Again taking the example of <code>Log</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Shorthand call signature</code>&#13;
<code class="nx">type</code> <code class="nx">Log</code> <code class="o">=</code> <code class="p">(</code><code class="nx">message</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">userId?</code>: <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code>&#13;
&#13;
<code class="c1">// Full call signature</code>&#13;
<code class="nx">type</code> <code class="nx">Log</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">message</code>: <code class="kt">string</code><code class="p">,</code> <code class="nx">userId?</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The two are completely equivalent in every way, and differ only in syntax.</p>&#13;
&#13;
<p>Would you ever want to use a full call signature over the shorthand? For simple cases like our <code>Log</code> function, you should prefer the shorthand; but for more complicated functions, there are a few good use cases for full signatures.<a data-primary="call signatures" data-secondary="overloaded" data-type="indexterm" id="ix_callsigovr"/></p>&#13;
&#13;
<p>The first of these is <em>overloading</em> a function type. But first, what does it even mean to overload a function?</p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304978027688">&#13;
<h5>Overloaded function</h5>&#13;
<p>A function with multiple call signatures.</p>&#13;
</div></aside>&#13;
&#13;
<p>In most programming languages, once you declare a function that takes some set of parameters and yields some return type, you can call that function with exactly that set of parameters, and you will always get that same return type back. Not so in JavaScript. Because JavaScript is such a dynamic language, it’s a common pattern for there to be multiple ways to call a given function; not only that, but sometimes the output type will actually depend on the input type for an argument!</p>&#13;
&#13;
<p>TypeScript models this dynamism—overloaded function declarations, and a function’s output type depending on its input type—with its static type system. We might take this language feature for granted, but it’s a really advanced feature for a type system to have!</p>&#13;
&#13;
<p>You can use overloaded function signatures to design really expressive APIs. For example, let’s design an API to book a vacation—we’ll call it <code>Reserve</code>. Let’s start by sketching out its types (with a full type signature this time):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Reserve</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">from</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">to</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">destination</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Reservation</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s then stub out an implementation for <code>Reserve</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">reserve</code>: <code class="kt">Reserve</code> <code class="o">=</code> <code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">,</code> <code class="nx">destination</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>So a user who wants to book a trip to Bali has to call our <code>reserve</code> API with a <code>from</code> date, a <code>to</code> date, and <code>"Bali"</code> as a destination.</p>&#13;
&#13;
<p>We might repurpose our API to support one-way trips too:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Reserve</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">from</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">to</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">destination</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Reservation</code>&#13;
  <code class="p">(</code><code class="nx">from</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">destination</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Reservation</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You’ll notice that when you try to run this code, TypeScript will give you an error at the point where you implement <code>Reserve</code> (see <a data-type="xref" href="#fig-typeerror">Figure 4-3</a>).</p>&#13;
&#13;
<figure class="width-50"><div class="figure" id="fig-typeerror">&#13;
<img alt="prts 0403" src="assets/prts_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>TypeError when missing a combined overload signature</h6>&#13;
</div></figure>&#13;
&#13;
<p>This is because of the way call signature overloading works in TypeScript. If you declare a set of overload signatures for a function <code>f</code>, from a caller’s point of view <code>f</code>’s type is the union of those overload signatures. But from <code>f</code>’s <em>implementation’s</em> point of view, there needs to be a single, combined type that can actually be implemented. You need to manually declare this combined call signature when implementing <code>f</code>—it won’t be inferred for you. For our <code>Reserve</code> example, we can update our <code>reserve</code> function like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Reserve</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">(</code><code class="nx">from</code><code>: </code><code class="kt">Date</code><code class="p">,</code><code> </code><code class="nx">to</code><code>: </code><code class="kt">Date</code><code class="p">,</code><code> </code><code class="nx">destination</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Reservation</code><code>&#13;
  </code><code class="p">(</code><code class="nx">from</code><code>: </code><code class="kt">Date</code><code class="p">,</code><code> </code><code class="nx">destination</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Reservation</code><code>&#13;
</code><code class="p">}</code><code> </code><a class="co" href="#callout_functions_CO3-1" id="co_functions_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">reserve</code><code>: </code><code class="kt">Reserve</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code>&#13;
  </code><code class="nx">from</code><code>: </code><code class="kt">Date</code><code class="p">,</code><code>&#13;
  </code><code class="nx">toOrDestination</code><code>: </code><code class="kt">Date</code><code> </code><code class="o">|</code><code> </code><code class="kt">string</code><code class="p">,</code><code>&#13;
  </code><code class="nx">destination?</code><code>: </code><code class="kt">string</code><code>&#13;
</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO3-2" id="co_functions_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="c1">// ...&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_functions_CO3-1" id="callout_functions_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We declare two overloaded function signatures.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO3-2" id="callout_functions_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The implementation’s signature is the result of us manually combining the two overload signatures (in other words, we computed <code>Signature1 | Signature2</code> by hand). Note that the combined signature isn’t visible to functions that call <code>reserve</code>; from a consumer’s point of view, <code>Reserve</code>’s signature is:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Reserve</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">from</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">to</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">destination</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Reservation</code>&#13;
  <code class="p">(</code><code class="nx">from</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">destination</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Reservation</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notably, this doesn’t include the combined signature we created:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Wrong!</code>&#13;
<code class="nx">type</code> <code class="nx">Reserve</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">from</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">to</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">destination</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Reservation</code>&#13;
  <code class="p">(</code><code class="nx">from</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">destination</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Reservation</code>&#13;
  <code class="p">(</code><code class="nx">from</code>: <code class="kt">Date</code><code class="p">,</code> <code class="nx">toOrDestination</code>: <code class="kt">Date</code> <code class="o">|</code> <code class="kt">string</code><code class="p">,</code>&#13;
    <code class="nx">destination?</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">Reservation</code>&#13;
<code class="p">}</code></pre></dd>&#13;
</dl>&#13;
&#13;
<p>Since <code>reserve</code> might be called in either of two ways, when you implement <code>reserve</code> you have to prove to TypeScript that you checked how it was called:<sup><a data-type="noteref" href="ch04.html#idm46304977663240" id="idm46304977663240-marker">6</a></sup></p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">let</code> <code class="nx">reserve</code><code class="o">:</code> <code class="nx">Reserve</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="nx">from</code><code class="o">:</code> <code class="nb">Date</code><code class="p">,</code>&#13;
  <code class="nx">toOrDestination</code><code class="o">:</code> <code class="nb">Date</code> <code class="o">|</code> <code class="nx">string</code><code class="p">,</code>&#13;
  <code class="nx">destination</code><code class="o">?:</code> <code class="nx">string</code>&#13;
<code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">toOrDestination</code> <code class="k">instanceof</code> <code class="nb">Date</code> <code class="o">&amp;&amp;</code> <code class="nx">destination</code> <code class="o">!==</code> <code class="kc">undefined</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Book a one-way trip</code>&#13;
  <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">toOrDestination</code> <code class="o">===</code> <code class="s1">'string'</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="c1">// Book a round trip</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304977636184">&#13;
<h5>Keeping Overload Signatures Specific</h5>&#13;
<p>In general, each overload signature (e.g., <code>Reserve</code>) has to be assignable to the implementation’s signature (e.g., <code>reserve</code>) when declaring an overloaded function type.<a data-primary="overloaded function types" data-secondary="keeping overload signatures specific" data-type="indexterm" id="idm46304977580728"/> That means you can be overly general when declaring the implementation’s signature, so long as all of your overloads are assignable to it. For example, this works:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">reserve</code>: <code class="kt">Reserve</code> <code class="o">=</code> <code class="p">(</code>&#13;
  <code class="nx">from</code>: <code class="kt">any</code><code class="p">,</code>&#13;
  <code class="nx">toOrDestination</code>: <code class="kt">any</code><code class="p">,</code>&#13;
  <code class="nx">destination?</code>: <code class="kt">any</code>&#13;
<code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When using overloads, try to keep your implementation’s signature as specific as possible to make it easier to implement the function. That means preferring <code>Date</code> over <code>any</code>, and a union of <code>Date | string</code> over <code>any</code> in our example.</p>&#13;
&#13;
<p>Why does keeping types narrow make it easier to implement a function with a given signature?<a data-primary="any type" data-secondary="as overloaded function parameter type" data-type="indexterm" id="idm46304977499128"/> If you type a parameter as <code>any</code> and want to use it as a <code>Date</code>, you have to prove to TypeScript that it’s actually a date:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">getMonth</code><code class="p">(</code><code class="nx">date</code>: <code class="kt">any</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kc">undefined</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">date</code> <code class="k">instanceof</code> <code class="nb">Date</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">date</code><code class="p">.</code><code class="nx">getMonth</code><code class="p">()</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>But if you typed the parameter as a <code>Date</code> upfront, you don’t need to do extra work in the implementation:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">getMonth</code><code class="p">(</code><code class="nx">date</code>: <code class="kt">Date</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">date</code><code class="p">.</code><code class="nx">getMonth</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Overloads come up naturally in browser DOM APIs. <a data-primary="DOM (Document Object Model)" data-secondary="overloads in browser DOM APIs" data-type="indexterm" id="idm46304977460376"/><a data-primary="browsers" data-secondary="overloads in browser DOM APIs" data-type="indexterm" id="idm46304977459528"/><a data-primary="createElement DOM API" data-type="indexterm" id="idm46304977458680"/>The <code>createElement</code> DOM API, for example, is used to create a new HTML element. It takes a string corresponding to an HTML tag and returns a new HTML element of that tag’s type. TypeScript comes with built-in types for each HTML element. These include:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>HTMLAnchorElement</code> for <code>&lt;a&gt;</code> elements</p>&#13;
</li>&#13;
<li>&#13;
<p><code>HTMLCanvasElement</code> for <code>&lt;canvas&gt;</code> elements</p>&#13;
</li>&#13;
<li>&#13;
<p><code>HTMLTableElement</code> for <code>&lt;table&gt;</code> elements</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Overloaded call signatures are a natural way to model how <code>createElement</code> works. Think about how you might type <code>createElement</code> (try to answer this by yourself before you read on!).</p>&#13;
&#13;
<p>The answer:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">CreateElement</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">(</code><code class="nx">tag</code><code class="o">:</code><code> </code><code class="s1">'a'</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">HTMLAnchorElement</code><code> </code><a class="co" href="#callout_functions_CO4-1" id="co_functions_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="p">(</code><code class="nx">tag</code><code class="o">:</code><code> </code><code class="s1">'canvas'</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">HTMLCanvasElement</code><code>&#13;
  </code><code class="p">(</code><code class="nx">tag</code><code class="o">:</code><code> </code><code class="s1">'table'</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">HTMLTableElement</code><code>&#13;
  </code><code class="p">(</code><code class="nx">tag</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">HTMLElement</code><code> </code><a class="co" href="#callout_functions_CO4-2" id="co_functions_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">createElement</code><code>: </code><code class="kt">CreateElement</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="nx">tag</code><code>: </code><code class="kt">string</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">HTMLElement</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO4-3" id="co_functions_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="c1">// ...&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_functions_CO4-1" id="callout_functions_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We overload on the parameter’s type, matching on it with string literal types.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO4-2" id="callout_functions_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We add a catchall case: if the user passed a custom tag name, or a cutting-edge experimental tag name that hasn’t made its way into TypeScript’s built-in type declarations yet, we return a generic <code>HTMLElement</code>. Since TypeScript resolves overloads in the order they were declared,<sup><a data-type="noteref" href="ch04.html#idm46304977328888" id="idm46304977328888-marker">7</a></sup> when you call <code>createElement</code> with a string that doesn’t have a specific overload defined (e.g., <code>createElement('foo')</code>), TypeScript will fall back to <code>HTMLElement</code>.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO4-3" id="callout_functions_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>To type the implementation’s parameter, we combine all the types that parameter might have in <code>createElement</code>’s overload signatures, resulting in <code>'a' | 'canvas' | 'table' | string</code>. Since the three string literal types are all subtypes of <code>string</code>, the type reduces to just <code>string</code>.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In all of the examples in this section we overloaded function expressions. But what if we want to overload a function declaration? As always, TypeScript has your back, with an equivalent syntax for function declarations. Let’s rewrite our <code>createElement</code> overloads:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">createElement</code><code class="p">(</code><code class="nx">tag</code><code class="o">:</code> <code class="s1">'a'</code><code class="p">)</code><code class="o">:</code> <code class="nx">HTMLAnchorElement</code>&#13;
<code class="kd">function</code> <code class="nx">createElement</code><code class="p">(</code><code class="nx">tag</code><code class="o">:</code> <code class="s1">'canvas'</code><code class="p">)</code><code class="o">:</code> <code class="nx">HTMLCanvasElement</code>&#13;
<code class="kd">function</code> <code class="nx">createElement</code><code class="p">(</code><code class="nx">tag</code><code class="o">:</code> <code class="s1">'table'</code><code class="p">)</code><code class="o">:</code> <code class="nx">HTMLTableElement</code>&#13;
<code class="kd">function</code> <code class="nx">createElement</code><code class="p">(</code><code class="nx">tag</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">HTMLElement</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Which syntax you use is up to you, and depends on what kind of function you’re overloading (function expression or function <span class="keep-together">declarations</span>).</p>&#13;
</div>&#13;
&#13;
<p>Full type signatures aren’t limited to overloading how you call a function. You can also use them to model properties on functions.<a data-primary="properties" data-secondary="function, modeling with full call signatures" data-type="indexterm" id="idm46304977246968"/> Since JavaScript functions are just callable objects, you can assign properties to them to do things like:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting" id="warnUser-in-JavaScript"><code class="kd">function</code> <code class="nx">warnUser</code><code class="p">(</code><code class="nx">warning</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">warnUser</code><code class="p">.</code><code class="nx">wasCalled</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">warnUser</code><code class="p">.</code><code class="nx">wasCalled</code> <code class="o">=</code> <code class="kc">true</code>&#13;
  <code class="nx">alert</code><code class="p">(</code><code class="nx">warning</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">warnUser</code><code class="p">.</code><code class="nx">wasCalled</code> <code class="o">=</code> <code class="kc">false</code></pre>&#13;
&#13;
<p>That is, we show the user a warning, and we don’t show a warning more than once. Let’s use TypeScript to type <code>warnUser</code>’s full signature:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">WarnUser</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">warning</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
  <code class="nx">wasCalled</code>: <code class="kt">boolean</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We can then rewrite <code>warnUser</code> as a function expression that implements that signature:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">warnUser</code>: <code class="kt">WarnUser</code> <code class="o">=</code> <code class="p">(</code><code class="nx">warning</code>: <code class="kt">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">warnUser</code><code class="p">.</code><code class="nx">wasCalled</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code>&#13;
  <code class="p">}</code>&#13;
  <code class="nx">warnUser</code><code class="p">.</code><code class="nx">wasCalled</code> <code class="o">=</code> <code class="kc">true</code>&#13;
  <code class="nx">alert</code><code class="p">(</code><code class="nx">warning</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">warnUser</code><code class="p">.</code><code class="nx">wasCalled</code> <code class="o">=</code> <code class="kc">false</code></pre>&#13;
&#13;
<p>Note that TypeScript is smart enough to realize that though we didn’t assign <code><span class="keep-together">wasCalled</span></code> to <code>warnUser</code> when we declared the <code>warnUser</code> function, we did assign <code><span class="keep-together">wasCalled</span></code> to it right after.<a data-primary="overloaded function types" data-startref="ix_ovrfunc" data-type="indexterm" id="idm46304977069816"/><a data-primary="call signatures" data-secondary="overloaded" data-startref="ix_callsigovr" data-type="indexterm" id="idm46304977068872"/><a data-primary="functions" data-secondary="declaring and invoking" data-startref="ix_funcdecovr" data-tertiary="overloaded function types" data-type="indexterm" id="idm46304977067656"/><a data-primary="functions" data-secondary="declaring and invoking" data-startref="ix_funcdec" data-type="indexterm" id="idm46304977066200"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Polymorphism" data-type="sect1"><div class="sect1" id="polymorphism">&#13;
<h1>Polymorphism</h1>&#13;
&#13;
<p>So far in this book, we’ve been talking about the hows and whys of concrete types, and functions that use concrete types.<a data-primary="polymorphism" data-type="indexterm" id="ix_poly"/><a data-primary="functions" data-secondary="polymorphism" data-type="indexterm" id="ix_funcpoly"/> What’s a <em>concrete type</em>? <a data-primary="concrete types" data-type="indexterm" id="idm46304977060232"/>It so happens that every type we’ve seen so far is concrete:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>boolean</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>string</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>Date[]</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>{a: number} | {b: string}</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>(numbers: number[]) =&gt; number</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Concrete types are useful when you know precisely what type you’re expecting, and want to verify that type was actually passed. But sometimes, you don’t know what type to expect beforehand, and you don’t want to restrict your function’s behavior to a specific type!</p>&#13;
&#13;
<p>As an example of what I mean, let’s implement <code>filter</code>. You use <code>filter</code> to iterate over an array and refine it; in JavaScript, it might look like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kd">function</code> <code class="nx">filter</code><code class="p">(</code><code class="nx">array</code><code class="p">,</code> <code class="nx">f</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">[]</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nx">item</code> <code class="o">=</code> <code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">f</code><code class="p">(</code><code class="nx">item</code><code class="p">))</code> <code class="p">{</code>&#13;
      <code class="nx">result</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">item</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">result</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">filter</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">)</code> <code class="c1">// evaluates to [1, 2]</code></pre>&#13;
&#13;
<p>Let’s start by pulling out <code>filter</code>’s full type signature, and adding some placeholder <code>unknown</code>s for the types:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Filter</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">(</code><code class="nx">array</code>: <code class="kt">unknown</code><code class="p">,</code> <code class="nx">f</code>: <code class="kt">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">unknown</code><code class="p">[]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, let’s try to fill in the types with, say, <code>number</code>:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">Filter</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">(</code><code class="nx">array</code><code>: </code><strong><code class="kt">number</code><code class="p">[</code><code class="p">]</code></strong><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><strong><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">number</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code></strong><code class="p">)</code><code class="o">:</code><code> </code><strong><code class="kt">number</code><code class="p">[</code><code class="p">]</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Typing the array’s<a data-primary="arrays" data-secondary="filtering" data-type="indexterm" id="idm46304976947336"/> elements as <code>number</code> works well for this example, but <code>filter</code> is meant to be a generic function—you can filter arrays of numbers, strings, objects, other arrays, anything. The signature we wrote works for arrays of numbers, but it doesn’t work for arrays of other types of elements.<a data-primary="strings" data-secondary="filtering arrays of" data-type="indexterm" id="idm46304976839464"/><a data-primary="overloaded function types" data-secondary="filter function" data-type="indexterm" id="idm46304976838488"/> Let’s try to use an overload to extend it to work on arrays of strings too:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">Filter</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">number</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">number</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kt">number</code><code class="p">[</code><code class="p">]</code><code>&#13;
  </code><strong><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">string</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kt">string</code><code class="p">[</code><code class="p">]</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>So far so good (though it might get messy to write out an overload for every type). <a data-primary="objects" data-secondary="filtering arrays of" data-type="indexterm" id="idm46304976759576"/>What about arrays of objects?</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">Filter</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">number</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">number</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kt">number</code><code class="p">[</code><code class="p">]</code><code>&#13;
  </code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">string</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="kt">string</code><code class="p">[</code><code class="p">]</code><code>&#13;
  </code><strong><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">object</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">object</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">object</code><code class="p">[</code><code class="p">]</code></strong><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>This might look fine at first glance, but let’s try to use it to see where it breaks down. If you implement a <code>filter</code> function with that signature (that is, <code>filter: Filter</code>), and try to use it, you’ll get:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code><code class="nx">firstName</code><code class="o">:</code> <code class="s1">'beth'</code><code class="p">},</code>&#13;
  <code class="p">{</code><code class="nx">firstName</code><code class="o">:</code> <code class="s1">'caitlyn'</code><code class="p">},</code>&#13;
  <code class="p">{</code><code class="nx">firstName</code><code class="o">:</code> <code class="s1">'xin'</code><code class="p">}</code>&#13;
<code class="p">]</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">filter</code><code class="p">(</code>&#13;
  <code class="nx">names</code><code class="p">,</code>&#13;
  <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">firstName</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s1">'b'</code><code class="p">)</code>&#13;
<code class="p">)</code> <code class="c1">// Error TS2339: Property 'firstName' does not exist on type 'object'.</code>&#13;
&#13;
<code class="nx">result</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">firstName</code> <code class="c1">// Error TS2339: Property 'firstName' does not exist</code>&#13;
                    <code class="c1">// on type 'object'.</code></pre>&#13;
&#13;
<p>At this point, it should make sense why TypeScript is throwing this error. We told TypeScript <a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2339" data-type="indexterm" id="idm46304976656952"/>that we might pass an array of numbers, strings, or objects to <code>filter</code>. We passed an array of objects, but remember that <code>object</code> doesn’t tell you anything about the shape of the object. So each time we try to access a property on an object in the array, TypeScript throws an error, because we didn’t tell it what specific shape the object has.</p>&#13;
&#13;
<p>What to do?</p>&#13;
&#13;
<p>If you come from a language that supports generic types, then by now you are rolling your eyes and shouting, “THAT’S WHAT GENERICS ARE FOR!” The good news is, you’re spot on (the bad news is, you just woke up the neighbors’ kid with your <span class="keep-together">shouting</span>).<a data-primary="polymorphism" data-secondary="generic type parameters" data-type="indexterm" id="idm46304976574504"/></p>&#13;
&#13;
<p>In case you haven’t worked with generic types before, I’ll define them first, then give an example with our <code>filter</code> function.</p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304976572440">&#13;
<h5>Generic type parameter</h5>&#13;
<p>A placeholder type used to enforce a type-level constraint in multiple places. Also known as <em>polymorphic type parameter</em>.<a data-primary="generic type parameters" data-seealso="generic types; generics" data-type="indexterm" id="idm46304976570280"/><a data-primary="parameters" data-secondary="generic type" data-type="indexterm" id="idm46304976569304"/></p>&#13;
</div></aside>&#13;
&#13;
<p>Going back to our <code>filter</code> example, here is what its type looks like when we rewrite it with a generic type parameter <code>T</code>:</p>&#13;
<pre data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">Filter</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><strong><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code></strong><code class="p">(</code><code class="nx">array</code><code>: </code><strong><code class="kt">T</code></strong><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><strong><code class="kt">T</code></strong><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kt noBold">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><strong><code class="nx">T</code></strong><code class="p">[</code><code class="p">]</code><code>&#13;
</code><code class="p">}</code>&#13;
</pre>&#13;
&#13;
<p>What we’ve done here is say: “This function <code>filter</code> uses a generic type parameter <code>T</code>; we don’t know what this type will be ahead of time, so TypeScript if you can infer what it is each time we call <code>filter</code> that would be swell.” TypeScript infers <code>T</code> from the type we pass in for <code>array</code>. Once TypeScript infers what <code>T</code> is for a given call to <code>filter</code>, it substitutes that type in for every <code>T</code> it sees. <code>T</code> is like a placeholder type, to be filled in by the typechecker from context; it <em>parameterizes</em> <code>Filter</code>’s type, which is why we call it a generic type <em>parameter</em>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Because it’s such a mouthful to say “generic type parameter” every time, people often shorten it to just “generic type,” or simply “generic.” I’ll use the terms interchangeably throughout this book.<a data-primary="generics" data-type="indexterm" id="idm46304976539096"/><a data-primary="generic types" data-type="indexterm" id="idm46304976538392"/></p>&#13;
</div>&#13;
&#13;
<p>The funny-looking <a data-primary="&lt; &gt; (angle brackets)" data-secondary="enclosing generic type parameters" data-type="indexterm" id="idm46304976536984"/>angle brackets, <code>&lt;&gt;</code>, are how you declare generic type parameters (think of them like the <code>type</code> keyword, but for generic types); where you place the angle brackets scopes the generics (there are just a few places you can put them), and TypeScript makes sure that within their scope, all instances of the generic type parameters are eventually bound to the same concrete types.<a data-primary="concrete types" data-secondary="binding to generic type parameters" data-type="indexterm" id="idm46304976534744"/> Because of where the angle brackets are in this example, TypeScript will bind concrete types to our generic <code>T</code> when we call <code>filter</code>. And it will decide which concrete type to bind to <code>T</code> depending on what we called <code>filter</code> with. You can declare as many comma-separated generic type parameters as you want between a pair of angle brackets.<a data-primary="generic type parameters" data-secondary="comma-separated list within angle brackets" data-type="indexterm" id="idm46304976531688"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>T</code> is just a type name, and we could have used any other name instead: <code>A</code>, <code>Zebra</code>, or <code>l33t</code>. By convention, people use uppercase single-letter names starting with the letter <code>T</code> and continuing to <code>U</code>, <code>V</code>, <code>W</code>, and so on depending on how many generics they need.<a data-primary="generic type parameters" data-secondary="naming conventions" data-type="indexterm" id="idm46304976502792"/></p>&#13;
&#13;
<p>If you’re declaring a lot of generics in a row or are using them in a complicated way, consider deviating from this convention and using more descriptive names like <code>Value</code> or <code>WidgetType</code> instead.</p>&#13;
&#13;
<p>Some people prefer to start at <code>A</code> instead of <code>T</code>. Different programming language communities prefer one or the other, depending on their heritage: functional language users prefer <code>A</code>, <code>B</code>, <code>C</code>, and so on because of their likeness to the Greek letters α, β, and γ that you might find in math proofs; object-oriented language users tend to use <code>T</code> for “Type.” TypeScript, though it supports both programming styles, uses the latter convention.</p>&#13;
</div>&#13;
&#13;
<p>Like a function’s parameter gets re-bound every time you call that function, so each call to <code>filter</code> gets its<a data-primary="binding" data-secondary="for generic type parameters" data-type="indexterm" id="idm46304976495880"/> own binding for <code>T</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Filter</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code>: <code class="kt">T</code><code class="p">[],</code> <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code>: <code class="kt">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">boolean</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">filter</code>: <code class="kt">Filter</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">,</code> <code class="nx">f</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="c1">// ...</code>&#13;
&#13;
<code class="c1">// (a) T is bound to number</code>&#13;
<code class="nx">filter</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">],</code> <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code> <code class="o">&gt;</code> <code class="mi">2</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// (b) T is bound to string</code>&#13;
<code class="nx">filter</code><code class="p">([</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">],</code> <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code> <code class="o">!==</code> <code class="s1">'b'</code><code class="p">)</code>&#13;
&#13;
<code class="c1">// (c) T is bound to {firstName: string}</code>&#13;
<code class="kd">let</code> <code class="nx">names</code> <code class="o">=</code> <code class="p">[</code>&#13;
  <code class="p">{</code><code class="nx">firstName</code><code class="o">:</code> <code class="s1">'beth'</code><code class="p">},</code>&#13;
  <code class="p">{</code><code class="nx">firstName</code><code class="o">:</code> <code class="s1">'caitlyn'</code><code class="p">},</code>&#13;
  <code class="p">{</code><code class="nx">firstName</code><code class="o">:</code> <code class="s1">'xin'</code><code class="p">}</code>&#13;
<code class="p">]</code>&#13;
<code class="nx">filter</code><code class="p">(</code><code class="nx">names</code><code class="p">,</code> <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">firstName</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s1">'b'</code><code class="p">))</code></pre>&#13;
&#13;
<p>TypeScript infers these generic bindings from the types of the arguments we passed in. Let’s walk through how TypeScript binds <code>T</code> for (a):</p>&#13;
<ol>&#13;
<li>&#13;
<p>From the type signature for <code>filter</code>, TypeScript knows that <code>array</code> is an array of elements of some type <code>T</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>TypeScript notices that we passed in the array <code>[1, 2, 3]</code>, so <code>T</code> must be <code>number</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Wherever TypeScript sees a <code>T</code>, it substitutes in the <code>number</code> type. So the parameter <code>f: (item: T) =&gt; boolean</code> becomes <code>f: (item: number) =&gt; boolean</code>, and the return type <code>T[]</code> becomes <code>number[]</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>TypeScript checks that the types all satisfy assignability, and that the function we passed in as <code>f</code> is assignable to its freshly inferred signature.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Generics are a powerful way to say what your function does in a more general way than what concrete types allow.<a data-primary="constraints" data-secondary="generics as" data-type="indexterm" id="idm46304976384088"/><a data-primary="generic type parameters" data-secondary="as constraints" data-type="indexterm" id="idm46304976382728"/> The way to think about generics is as <em>constraints</em>. Just like annotating a function parameter as <code>n: number</code> constrains the <em>value</em> of the parameter <code>n</code> to the type <code>number</code>, so using a generic <code>T</code> constrains the <em>type</em> of whatever type you bind to <code>T</code> to be the same type everywhere that <code>T</code> shows up.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Generic types can also be used in type aliases, classes, and interfaces—we’ll use them copiously throughout this book. I’ll introduce them in context as we cover more topics.</p>&#13;
&#13;
<p>Use generics whenever you can. They will help keep your code general, reusable, and terse.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When Are Generics Bound?" data-type="sect2"><div class="sect2" id="idm46304976376024">&#13;
<h2>When Are Generics Bound?</h2>&#13;
&#13;
<p>The place where you declare a generic type doesn’t just scope the type, but also dictates when TypeScript will bind a concrete type to your generic.<a data-primary="call signatures" data-secondary="declaring generics as part of" data-type="indexterm" id="idm46304976374328"/><a data-primary="generics" data-secondary="binding, when it happens" data-type="indexterm" id="ix_genbind"/><a data-primary="binding" data-secondary="of generics, when it happens" data-type="indexterm" id="ix_bindgen"/><a data-primary="polymorphism" data-secondary="binding of generics" data-type="indexterm" id="ix_polybind"/> From the last <span class="keep-together">example</span>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">Filter</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code>: <code class="kt">T</code><code class="p">[],</code> <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code>: <code class="kt">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kr">boolean</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[]</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">filter</code>: <code class="kt">Filter</code> <code class="o">=</code> <code class="p">(</code><code class="nx">array</code><code class="p">,</code> <code class="nx">f</code><code class="p">)</code> <code class="o">=&gt;</code>&#13;
  <code class="c1">// ...</code></pre>&#13;
&#13;
<p>Because we declared <code>&lt;T&gt;</code> as part of a call signature (right before the signature’s opening parenthesis, <code>()</code>, TypeScript will bind a concrete type to <code>T</code> when we actually call a function of type <code>Filter</code>.</p>&#13;
&#13;
<p>If we’d instead scoped <code>T</code> to the type alias <code>Filter</code>, TypeScript would have required us to bind a type explicitly<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2314" data-type="indexterm" id="idm46304976326648"/> when we used <code>Filter</code>:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">Filter</code><strong><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code></strong><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">T</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">let</code><code> </code><code class="nx">filter</code><code>: </code><code class="kt">Filter</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="nx">array</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><em><code class="c1">// Error TS2314: Generic type 'Filter'</code></em><code class="c1">&#13;
</code><code>  </code><code class="c1">// ...                           </code><em><code class="c1">// requires 1 type argument(s).</code></em><code class="c1">&#13;
</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">OtherFilter</code><code> </code><code class="o">=</code><code> </code><code class="nx">Filter</code><code>          </code><em><code class="c1">// Error TS2314: Generic type 'Filter'</code></em><code class="c1">&#13;
</code><code>                                   </code><em><code class="c1">// requires 1 type argument(s).</code></em><code class="c1">&#13;
</code><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">filter</code><code>: </code><code class="kt">Filter</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="nx">array</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code>&#13;
  </code><code class="c1">// ...&#13;
</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">StringFilter</code><code> </code><code class="o">=</code><code> </code><code class="nx">Filter</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">stringFilter</code><code>: </code><code class="kt">StringFilter</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="nx">array</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code>&#13;
  </code><code class="c1">// ...&#13;
</code></pre>&#13;
&#13;
<p>Generally, TypeScript will bind concrete types to your generic when you use the generic: for functions, it’s when you call them; for classes, it’s when you instantiate them (more on that in <a data-type="xref" href="ch05.html#class-generics">“Polymorphism”</a>); and for type aliases and interfaces (see <a data-type="xref" href="ch05.html#interfaces">“Interfaces”</a>), it’s when you use or implement them.<a data-primary="classes" data-secondary="binding of generics" data-type="indexterm" id="idm46304976109176"/><a data-primary="interfaces" data-secondary="binding of generics" data-type="indexterm" id="idm46304976108328"/><a data-primary="type aliases" data-secondary="binding of generics" data-type="indexterm" id="idm46304976128296"/><a data-primary="functions" data-secondary="binding generics" data-type="indexterm" id="idm46304976127352"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Where Can You Declare Generics?" data-type="sect2"><div class="sect2" id="idm46304976126280">&#13;
<h2>Where Can You Declare Generics?</h2>&#13;
&#13;
<p>For each of TypeScript’s ways to declare a call signature, there’s a way to add a generic type to it:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">Filter</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO5-1" id="co_functions_CO5-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">T</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">filter</code><code>: </code><code class="kt">Filter</code><code> </code><code class="o">=</code><code> </code><code class="c1">// ...&#13;
</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Filter</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO5-2" id="co_functions_CO5-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">T</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">filter</code><code>: </code><code class="kt">Filter</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="c1">// ...&#13;
</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Filter</code><code> </code><code class="o">=</code><code> </code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">T</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code> </code><a class="co" href="#callout_functions_CO5-3" id="co_functions_CO5-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">filter</code><code>: </code><code class="kt">Filter</code><code> </code><code class="o">=</code><code> </code><code class="c1">// ...&#13;
</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Filter</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">T</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code> </code><a class="co" href="#callout_functions_CO5-4" id="co_functions_CO5-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">filter</code><code>: </code><code class="kt">Filter</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="c1">// ...&#13;
</code><code>&#13;
</code><code class="kd">function</code><code> </code><code class="nx">filter</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code><code>: </code><code class="kt">T</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><code class="kt">T</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kr">boolean</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code class="p">[</code><code class="p">]</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO5-5" id="co_functions_CO5-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
  </code><code class="c1">// ...&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_functions_CO5-1" id="callout_functions_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>A full call signature, with <code>T</code> scoped to an individual signature. Because <code>T</code> is scoped to a single signature, TypeScript will bind the <code>T</code> in this signature to a concrete type when you call a function of type <code>filter</code>. Each call to <code>filter</code> will get its own binding for <code>T</code>.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO5-2" id="callout_functions_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>A full call signature, with <code>T</code> scoped to <em>all</em> of the signatures. Because <code>T</code> is declared as part of <code>Filter</code>’s type (and not part of a specific signature’s type), TypeScript will bind <code>T</code> when you declare a function of type <code>Filter</code>.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO5-3" id="callout_functions_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Like <a class="co" href="#co_functions_CO5-1"><img alt="1" src="assets/1.png"/></a>, but a shorthand call signature instead of a full one.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO5-4" id="callout_functions_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Like <a class="co" href="#co_functions_CO5-2"><img alt="2" src="assets/2.png"/></a>, but a shorthand call signature instead of a full one.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO5-5" id="callout_functions_CO5-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>A named function call signature, with <code>T</code> scoped to the signature. TypeScript will bind a concrete type to <code>T</code> when you call <code>filter</code>, and each call to <code>filter</code> will get its own binding for <code>T</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>As a second example, let’s write a <code>map</code> function. <code>map</code> is pretty similar to <code>filter</code>, but instead of removing items from an array, it transforms each item with a mapping function. We’ll start by sketching out the implementation:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">map</code><code class="p">(</code><code class="nx">array</code>: <code class="kt">unknown</code><code class="p">[],</code> <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code>: <code class="kt">unknown</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">unknown</code><code class="p">)</code><code class="o">:</code> <code class="nx">unknown</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="p">[]</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">result</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">f</code><code class="p">(</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">])</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">result</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Before you go on, try to think through how you’d make <code>map</code> generic, replacing each <code>unknown</code> with some type. How many generics do you need? How do you declare your generics, and scope them to the <code>map</code> function? What should the types of <code>array</code>, <code>f</code>, and the return value be?</p>&#13;
&#13;
<p>Ready? If you didn’t try to do it yourself first, I encourage you to give it a shot. You can do it. Really!</p>&#13;
&#13;
<p>OK, no more nagging. Here’s the answer:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code><code> </code><code class="nx">map</code><strong><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code><code> </code><code class="nx">U</code><code class="o">&gt;</code></strong><code class="p">(</code><code class="nx">array</code><code>: </code><strong><code class="kt">T</code></strong><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">item</code><code>: </code><strong><code class="kt">T</code></strong><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><strong><code class="nx">U</code></strong><code class="p">)</code><code class="o">:</code><code> </code><strong><code class="nx">U</code></strong><code class="p">[</code><code class="p">]</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="kd">let</code><code> </code><code class="nx">result</code><code> </code><code class="o">=</code><code> </code><code class="p">[</code><code class="p">]</code><code>&#13;
  </code><code class="k">for</code><code> </code><code class="p">(</code><code class="kd">let</code><code> </code><code class="nx">i</code><code> </code><code class="o">=</code><code> </code><code class="mi">0</code><code class="p">;</code><code> </code><code class="nx">i</code><code> </code><code class="o">&lt;</code><code> </code><code class="nx">array</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code><code> </code><code class="nx">i</code><code class="o">++</code><code class="p">)</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="nx">result</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code> </code><code class="o">=</code><code> </code><code class="nx">f</code><code class="p">(</code><code class="nx">array</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">result</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>We need exactly two generic types: <code>T</code> for the type of the array members going in, and <code>U</code> for the type of the array members going out. We pass in an array of <code>T</code>s, and a mapping function that takes a <code>T</code> and maps it to a <code>U</code>. Finally, we return an array of <code>U</code>s.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304975622392">&#13;
<h5>filter and map in the Standard Library</h5>&#13;
<p>Our definitions for <code>filter</code> and <code>map</code> are awfully similar to the ones that ship with TypeScript:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">interface</code> <code class="nb">Array</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">filter</code><code class="p">(</code>&#13;
    <code class="nx">callbackfn</code><code class="o">:</code> <code class="p">(</code><code class="nx">value</code>: <code class="kt">T</code><code class="p">,</code> <code class="nx">index</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">array</code>: <code class="kt">T</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">any</code><code class="p">,</code>&#13;
    <code class="nx">thisArg?</code>: <code class="kt">any</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="nx">T</code><code class="p">[]</code>&#13;
  <code class="nx">map</code><code class="o">&lt;</code><code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code>&#13;
    <code class="nx">callbackfn</code><code class="o">:</code> <code class="p">(</code><code class="nx">value</code>: <code class="kt">T</code><code class="p">,</code> <code class="nx">index</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">array</code>: <code class="kt">T</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">U</code><code class="p">,</code>&#13;
    <code class="nx">thisArg?</code>: <code class="kt">any</code>&#13;
  <code class="p">)</code><code class="o">:</code> <code class="nx">U</code><code class="p">[]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We haven’t covered interfaces yet, but this definition says that <code>filter</code> and <code>map</code> are functions on an array of type <code>T</code>. They both take a function <code>callbackfn</code>, and a type for <code>this</code> inside of the function.</p>&#13;
&#13;
<p><code>filter</code> uses the generic <code>T</code> that’s scoped to the entire <code>Array</code> interface. <code>map</code> uses <code>T</code> too, and adds a second generic <code>U</code> that’s scoped just to the <code>map</code> function.<a data-primary="arrays" data-secondary="generic functions on Array type" data-type="indexterm" id="idm46304975531272"/> That means TypeScript will bind  a concrete type to <code>T</code> when you create an array, and every call to <code>filter</code> and <code>map</code> on that array will share that concrete type. Every time you call <code>map</code>, that call will get its own binding for <code>U</code>, in addition to having access to the already-bound <code>T</code>.</p>&#13;
&#13;
<p>Many functions in the JavaScript standard library are generic, especially those on <code>Array</code>’s prototype. Arrays can contain values of any type, so we call that type <code>T</code> and can say things like "<code>.push</code> takes an argument of type <code>T</code>,” or "<code>.map</code> maps from an array of <code>T</code>s to an array of <code>U</code>s”.<a data-primary="generics" data-secondary="binding, when it happens" data-startref="ix_genbind" data-type="indexterm" id="idm46304975524040"/><a data-primary="binding" data-secondary="of generics, when it happens" data-startref="ix_bindgen" data-type="indexterm" id="idm46304975522744"/><a data-primary="polymorphism" data-secondary="binding of generics" data-startref="ix_polybind" data-type="indexterm" id="idm46304975521512"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generic Type Inference" data-type="sect2"><div class="sect2" id="idm46304976125688">&#13;
<h2>Generic Type Inference</h2>&#13;
&#13;
<p>In most cases, TypeScript does a great job of inferring generic types for you. When you call the <code>map</code> function we wrote earlier, <a data-primary="polymorphism" data-secondary="generic type inference" data-type="indexterm" id="ix_polygentypin"/><a data-primary="generics" data-secondary="type inference" data-type="indexterm" id="ix_gentypinf"/>TypeScript infers that <code>T</code> is <code>string</code> and <code>U</code> is <code>boolean</code>:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code> <code class="nx">map</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code>: <code class="kt">T</code><code class="p">[],</code> <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code>: <code class="kt">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">U</code><code class="p">)</code><code class="o">:</code> <code class="nx">U</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">map</code><code class="p">(</code>&#13;
  <code class="p">[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">],</code>  <code class="c1">// An array of T</code>&#13;
  <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code> <code class="o">===</code> <code class="s1">'a'</code>    <code class="c1">// A function that returns a U</code>&#13;
<code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>You can, however, explicitly annotate your generics too. Explicit annotations for generics are all-or-nothing; either annotate every required generic type,<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2558" data-type="indexterm" id="idm46304975453784"/> or none of them:</p>&#13;
<pre class="c_less_space" data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">map</code>	<code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">boolean</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="p">[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">],</code>&#13;
  <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code> <code class="o">===</code> <code class="s1">'a'</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="nx">map</code>	<code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code> <code class="c1">// Error TS2558: Expected 2 type arguments, but got 1.</code>&#13;
  <code class="p">[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">],</code>&#13;
  <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code> <code class="o">===</code> <code class="s1">'a'</code>&#13;
<code class="p">)</code>&#13;
</pre>&#13;
&#13;
<p>TypeScript will check that each inferred generic type is assignable to its corresponding explicitly bound generic;<a data-primary="assignability" data-secondary="inferred generic types to explicitly bound generic" data-type="indexterm" id="idm46304975376776"/><a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2322" data-type="indexterm" id="idm46304975360232"/> if it’s not assignable, you’ll get an error:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// OK, because boolean is assignable to boolean | string</code>&#13;
<code class="nx">map</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">boolean</code> <code class="o">|</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="p">[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">],</code>&#13;
  <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code> <code class="o">===</code> <code class="s1">'a'</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="nx">map</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="p">[</code><code class="s1">'a'</code><code class="p">,</code> <code class="s1">'b'</code><code class="p">,</code> <code class="s1">'c'</code><code class="p">],</code>&#13;
  <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code> <code class="o">===</code> <code class="s1">'a'</code>  <code class="c1">// Error TS2322: Type 'boolean' is not assignable</code>&#13;
<code class="p">)</code>                 <code class="c1">// to type 'number'.</code></pre>&#13;
&#13;
<p>Since TypeScript infers concrete types for your generics from the arguments you pass into your generic function, sometimes you’ll hit a case like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">resolve</code><code class="p">(</code><code class="mi">45</code><code class="p">)</code>&#13;
<code class="p">)</code>&#13;
<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">result</code> <code class="o">=&gt;</code> <code class="c1">// Inferred as {}</code>&#13;
  <code class="nx">result</code> <code class="o">*</code> <code class="mi">4</code> <code class="c1">// Error TS2362: The left-hand side of an arithmetic operation must</code>&#13;
<code class="p">)</code>            <code class="c1">// be of type 'any', 'number', 'bigint', or an enum type.</code></pre>&#13;
&#13;
<p>What gives? Why did TypeScript infer <code>result</code> to be <code>{}</code>?<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2362" data-type="indexterm" id="idm46304975198376"/> Because we didn’t give it enough information to work with—since TypeScript only uses the types of a generic function’s arguments to infer a generic’s type, it defaulted <code>T</code> to <code>{}</code>!</p>&#13;
&#13;
<p>To fix this, we have to explicitly annotate <code>Promise</code>s generic type parameter:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">promise</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Promise</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code>&#13;
  <code class="nx">resolve</code><code class="p">(</code><code class="mi">45</code><code class="p">)</code>&#13;
<code class="p">)</code>&#13;
<code class="nx">promise</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">result</code> <code class="o">=&gt;</code> <code class="c1">// number</code>&#13;
  <code class="nx">result</code> <code class="o">*</code> <code class="mi">4</code>&#13;
<code class="p">)</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generic Type Aliases" data-type="sect2"><div class="sect2" id="generic-type-aliases">&#13;
<h2>Generic Type Aliases</h2>&#13;
&#13;
<p>We already touched on generic type aliases with our <code>Filter</code> example from earlier in the chapter.<a data-primary="polymorphism" data-secondary="generic type inference" data-startref="ix_polygentypin" data-type="indexterm" id="idm46304975167624"/><a data-primary="generics" data-secondary="type inference" data-startref="ix_gentypinf" data-type="indexterm" id="idm46304975166376"/> And if you recall the <code>Array</code> and <code>ReadonlyArray</code> types from the last chapter (see <a data-type="xref" href="ch03.html#readonly-array">“Read-only arrays and tuples”</a>), those are generic type aliases too! Let’s take a deeper dive into using generics in type aliases by working through a brief example.<a data-primary="polymorphism" data-secondary="generic type aliases" data-type="indexterm" id="idm46304975163176"/><a data-primary="type aliases" data-secondary="generic" data-type="indexterm" id="idm46304975162232"/><a data-primary="generics" data-secondary="type aliases" data-type="indexterm" id="idm46304975161288"/></p>&#13;
&#13;
<p>Let’s define a <code>MyEvent</code> type that describes a DOM event, like a <code>click</code> or a <code>mousedown</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">MyEvent</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">target</code>: <code class="kt">T</code>&#13;
  <code class="nx">type</code>: <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that this is the only valid place to declare a generic type in a type alias: right after the type alias’s name, before its assignment (<code>=</code>).</p>&#13;
&#13;
<p><code>MyEvent</code>’s <code>target</code> property points to the element the event happened on: a <code>&lt;button /&gt;</code>, a <code>&lt;div /&gt;</code>, and so on. For example, you might describe a button event like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">ButtonEvent</code> <code class="o">=</code> <code class="nx">MyEvent</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code></pre>&#13;
&#13;
<p>When you use a generic type like <code>MyEvent</code>, you have to explicitly bind its type parameters when you use the type; they won’t be inferred for you:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">myEvent</code>: <code class="kt">Event</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code> <code class="o">|</code> <code class="kc">null</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">target</code>: <code class="kt">document.querySelector</code><code class="p">(</code><code class="s1">'#myButton'</code><code class="p">),</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s1">'click'</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can use <code>MyEvent</code> to build another type—say, <code>TimedEvent</code>. When the generic <code>T</code> in <span class="keep-together"><code>TimedEvent</code></span> is bound, TypeScript will also bind it to <code>MyEvent</code>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">TimedEvent</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">event</code>: <code class="kt">MyEvent</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code>&#13;
  <code class="nx">from</code>: <code class="kt">Date</code>&#13;
  <code class="nx">to</code>: <code class="kt">Date</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>You can use a generic type alias in a function’s signature, too. When TypeScript binds a type to <code>T</code>, it’ll also bind it to <code>MyEvent</code> for you:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">triggerEvent</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">event</code>: <code class="kt">MyEvent</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">triggerEvent</code><code class="p">({</code> <code class="c1">// T is Element | null</code>&#13;
  <code class="nx">target</code>: <code class="kt">document.querySelector</code><code class="p">(</code><code class="s1">'#myButton'</code><code class="p">),</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s1">'mouseover'</code>&#13;
<code class="p">})</code></pre>&#13;
&#13;
<p>Let’s walk through what’s happening here step by step:</p>&#13;
<ol>&#13;
<li>&#13;
<p>We call <code>triggerEvent</code> with an object.</p>&#13;
</li>&#13;
<li>&#13;
<p>TypeScript sees that according to our function’s signature, the argument we passed has to have the type <code>MyEvent&lt;T&gt;</code>. It also notices that we defined <code>MyEvent&lt;T&gt;</code> as <code>{target: T, type: string}</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>TypeScript notices that the <code>target</code> field of the object we passed is <code><span class="keep-together">document.querySelector</span>('#myButton')</code>. That implies that <code>T</code> must be whatever type <code>document.querySelector('#myButton')</code> is: <code>Element | null</code>. So <code>T</code> is now bound to <code>Element | null</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>TypeScript goes through and replaces every occurrence of <code>T</code> with <code>Element | null</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>TypeScript checks that all of our types satisfy assignability. They do, so our code typechecks.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bounded Polymorphism" data-type="sect2"><div class="sect2" id="idm46304975168984">&#13;
<h2>Bounded Polymorphism</h2>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In this section I’m going to use a binary tree as an example. If you haven’t worked with binary trees before, don’t worry.<a data-primary="generics" data-secondary="bounded polymorphism" data-type="indexterm" id="ix_genbound"/><a data-primary="binary trees" data-type="indexterm" id="idm46304974935832"/><a data-primary="functions" data-secondary="polymorphism" data-tertiary="bounded" data-type="indexterm" id="ix_funcpolybnd"/><a data-primary="polymorphism" data-secondary="bounded" data-type="indexterm" id="ix_polybound"/><a data-primary="bounded polymorphism" data-type="indexterm" id="ix_boundply"/> For our purposes, the basics are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A binary tree is a kind of data structure.</p>&#13;
</li>&#13;
<li>&#13;
<p>A binary tree consists of nodes.</p>&#13;
</li>&#13;
<li>&#13;
<p>A node holds a value, and can point to up to two child nodes.</p>&#13;
</li>&#13;
<li>&#13;
<p>A node can be one of two types: a <em>leaf node</em> (meaning it has no children) or an <em>inner node</em> (meaning it has at least one child).</p>&#13;
</li>&#13;
</ul>&#13;
</div>&#13;
&#13;
<p>Sometimes,<a data-primary="nodes (binary tree)" data-type="indexterm" id="idm46304974925720"/><a data-primary="leaf nodes" data-type="indexterm" id="idm46304974924984"/><a data-primary="inner nodes" data-type="indexterm" id="idm46304974924312"/> saying “this thing is of some generic type <code>T</code> and that thing has to have the same type <code>T</code>" just isn’t enough. Sometimes you also want to say “the type <code>U</code> should be <em>at least <code>T</code></em>.” We call this putting an <em>upper bound</em> on <code>U</code>.</p>&#13;
&#13;
<p>Why might we want to do this? Let’s say we’re implementing a binary tree, and have three types of nodes:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Regular <code>TreeNode</code>s</p>&#13;
</li>&#13;
<li>&#13;
<p><code>LeafNode</code>s, which are <code>TreeNode</code>s that don’t have children</p>&#13;
</li>&#13;
<li>&#13;
<p><code>InnerNode</code>s, which are <code>TreeNode</code>s that do have children</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Let’s start by declaring types for our nodes:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">TreeNode</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">value</code>: <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">LeafNode</code> <code class="o">=</code> <code class="nx">TreeNode</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">isLeaf</code>: <code class="kt">true</code>&#13;
<code class="p">}</code>&#13;
<code class="nx">type</code> <code class="nx">InnerNode</code> <code class="o">=</code> <code class="nx">TreeNode</code> <code class="o">&amp;</code> <code class="p">{</code>&#13;
  <code class="nx">children</code><code class="o">:</code> <code class="p">[</code><code class="nx">TreeNode</code><code class="p">]</code> <code class="o">|</code> <code class="p">[</code><code class="nx">TreeNode</code><code class="p">,</code> <code class="nx">TreeNode</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>What we’re saying is: a <code>TreeNode</code> is an object with a single property, <code>value</code>. The <span class="keep-together"><code>LeafNode</code></span> type has all the properties <code>TreeNode</code> has, plus a property <code>isLeaf</code> that’s always <code>true</code>. <code>InnerNode</code> also has all of <code>TreeNode</code>’s properties, plus a <code>children</code> property that points to either one or two children.</p>&#13;
&#13;
<p>Next, let’s write a <code>mapNode</code> function that takes a <code>TreeNode</code> and maps over its value, returning a new <code>TreeNode</code>. We want to come up with a <code>mapNode</code> function that we can use like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code>: <code class="kt">TreeNode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="s1">'a'</code><code class="p">}</code>&#13;
<code class="kd">let</code> <code class="nx">b</code>: <code class="kt">LeafNode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="s1">'b'</code><code class="p">,</code> <code class="nx">isLeaf</code>: <code class="kt">true</code><code class="p">}</code>&#13;
<code class="kd">let</code> <code class="nx">c</code>: <code class="kt">InnerNode</code> <code class="o">=</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="s1">'c'</code><code class="p">,</code> <code class="nx">children</code><code class="o">:</code> <code class="p">[</code><code class="nx">b</code><code class="p">]}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nx">a1</code> <code class="o">=</code> <code class="nx">mapNode</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">())</code> <code class="c1">// TreeNode</code>&#13;
<code class="kd">let</code> <code class="nx">b1</code> <code class="o">=</code> <code class="nx">mapNode</code><code class="p">(</code><code class="nx">b</code><code class="p">,</code> <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">())</code> <code class="c1">// LeafNode</code>&#13;
<code class="kd">let</code> <code class="nx">c1</code> <code class="o">=</code> <code class="nx">mapNode</code><code class="p">(</code><code class="nx">c</code><code class="p">,</code> <code class="nx">_</code> <code class="o">=&gt;</code> <code class="nx">_</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">())</code> <code class="c1">// InnerNode</code></pre>&#13;
&#13;
<p>Now pause, and think about how you might write a <code>mapNode</code> function that takes a subtype of <code>TreeNode</code> and returns <em>that same subtype</em>. Passing in a <code>LeafNode</code> should return a <code>LeafNode</code>, an <code>InnerNode</code> should return an <code>InnerNode</code>, and a <code>TreeNode</code> should return a <code>TreeNode</code>. Consider how you’d do this before you move on. Is it possible?</p>&#13;
&#13;
<p>Here’s the answer:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code><code> </code><code class="nx">mapNode</code><code class="o">&lt;</code><code class="nx">T</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">TreeNode</code><code class="o">&gt;</code><code class="p">(</code><code> </code><a class="co" href="#callout_functions_CO6-1" id="co_functions_CO6-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">node</code><code>: </code><code class="kt">T</code><code class="p">,</code><code> </code><a class="co" href="#callout_functions_CO6-2" id="co_functions_CO6-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="nx">value</code><code>: </code><code class="kt">string</code><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><code class="kt">string</code><code>&#13;
</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">T</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO6-3" id="co_functions_CO6-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="k">return</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">node</code><code class="p">,</code><code>&#13;
    </code><code class="nx">value</code><code>: </code><code class="kt">f</code><code class="p">(</code><code class="nx">node</code><code class="p">.</code><code class="nx">value</code><code class="p">)</code><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_functions_CO6-1" id="callout_functions_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>mapNode</code> is a function that defines a single generic type parameter, <code>T</code>. <code>T</code> has an upper bound of <code>TreeNode</code>. That is, <code>T</code> can be either a <code>TreeNode</code>, or a subtype of <code>TreeNode</code>.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO6-2" id="callout_functions_CO6-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>mapNode</code> takes two parameters, the first of which is a <code>node</code> of type <code>T</code>. Because in <a class="co" href="#co_functions_CO6-1"><img alt="1" src="assets/1.png"/></a> we said <code>node extends TreeNode</code>, if we passed in something that’s not a <code><span class="keep-together">TreeNode</span></code>—say, an empty object <code>{}</code>, <code>null</code>, or an array of <code>TreeNode</code>s—that would be an instant red squiggly. <code>node</code> has to be either a <code>TreeNode</code> or a subtype of <code>TreeNode</code>.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO6-3" id="callout_functions_CO6-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>mapNode</code> returns a value of type <code>T</code>. Remember that <code>T</code> might be a <code>TreeNode</code>, or any subtype of <code>TreeNode</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Why did we have to declare <code>T</code> that way?</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If we had typed <code>T</code> as just <code>T</code> (leaving off <code>extends TreeNode</code>), then <code>mapNode</code> would have thrown a compile-time error, because you can’t safely read <code>node.value</code> on an unbounded <code>node</code> of type <code>T</code> (what if a user passes in a number?).</p>&#13;
</li>&#13;
<li>&#13;
<p>If we had left off the <code>T</code> entirely and declared <code>mapNode</code> as <code>(node: TreeNode, f: (value: string) =&gt; string) =&gt; TreeNode</code>, then we would have lost information after mapping a node: <code>a1</code>, <code>b1</code>, and <code>c1</code> would all just be <code>TreeNode</code>s.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>By saying that <code>T extends TreeNode</code>, we get to preserve the input node’s specific type (<code>TreeNode</code>, <code>LeafNode</code>, or <code>InnerNode</code>), even after mapping it.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bounded polymorphism with multiple constraints" data-type="sect3"><div class="sect3" id="idm46304974568040">&#13;
<h3>Bounded polymorphism with multiple constraints</h3>&#13;
&#13;
<p>In the last example, we put a single type constraint on <code>T</code>: <code>T</code> has to be at least a <code><span class="keep-together">TreeNode</span></code>. But what if you want multiple type constraints?<a data-primary="bounded polymorphism" data-secondary="with multiple constraints" data-type="indexterm" id="idm46304974564664"/><a data-primary="polymorphism" data-secondary="bounded" data-tertiary="with multiple constraints" data-type="indexterm" id="idm46304974563752"/></p>&#13;
&#13;
<p>Just extend the intersection (<code>&amp;</code>) of those constraints:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code><code> </code><code class="nx">HasSides</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="nx">numberOfSides</code><code>: </code><code class="kt">number</code><code class="p">}</code><code>&#13;
</code><code class="nx">type</code><code> </code><code class="nx">SidesHaveLength</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="nx">sideLength</code><code>: </code><code class="kt">number</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="kd">function</code><code> </code><code class="nx">logPerimeter</code><code class="o">&lt;</code><code> </code><a class="co" href="#callout_functions_CO7-1" id="co_functions_CO7-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">Shape</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">HasSides</code><code> </code><code class="o">&amp;</code><code> </code><code class="nx">SidesHaveLength</code><code> </code><a class="co" href="#callout_functions_CO7-2" id="co_functions_CO7-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">s</code><code>: </code><code class="kt">Shape</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">Shape</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_CO7-3" id="co_functions_CO7-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">numberOfSides</code><code> </code><code class="o">*</code><code> </code><code class="nx">s</code><code class="p">.</code><code class="nx">sideLength</code><code class="p">)</code><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">s</code><code>&#13;
</code><code class="p">}</code><code>&#13;
&#13;
</code><code class="nx">type</code><code> </code><code class="nx">Square</code><code> </code><code class="o">=</code><code> </code><code class="nx">HasSides</code><code> </code><code class="o">&amp;</code><code> </code><code class="nx">SidesHaveLength</code><code>&#13;
</code><code class="kd">let</code><code> </code><code class="nx">square</code><code>: </code><code class="kt">Square</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code class="nx">numberOfSides</code><code>: </code><code class="kt">4</code><code class="p">,</code><code> </code><code class="nx">sideLength</code><code>: </code><code class="kt">3</code><code class="p">}</code><code>&#13;
</code><code class="nx">logPerimeter</code><code class="p">(</code><code class="nx">square</code><code class="p">)</code><code> </code><code class="c1">// Square, logs "12"</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_functions_CO7-1" id="callout_functions_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p><code>logPerimeter</code> is a function that takes a single argument <code>s</code> of type <code>Shape</code>.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO7-2" id="callout_functions_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p><code>Shape</code> is a generic type that extends both the <code>HasSides</code> type and the <code><span class="keep-together">SidesHaveLength</span></code> type. In other words, a <code>Shape</code> has to at least have sides with lengths.</p></dd>&#13;
<dt><a class="co" href="#co_functions_CO7-3" id="callout_functions_CO7-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>logPerimeter</code> returns a value of the exact same type you gave it.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using bounded polymorphism to model arity" data-type="sect3"><div class="sect3" id="modelling-arity">&#13;
<h3>Using bounded polymorphism to model arity</h3>&#13;
&#13;
<p>Another place where you’ll find yourself using bounded polymorphism is to model variadic functions (functions that take any number of arguments).<a data-primary="bounded polymorphism" data-secondary="using to model arity" data-type="indexterm" id="idm46304974435880"/><a data-primary="arity" data-secondary="modeling using bounded polymorphism" data-type="indexterm" id="idm46304974418424"/><a data-primary="polymorphism" data-secondary="bounded" data-tertiary="using to model arity" data-type="indexterm" id="idm46304974417576"/> For example, let’s implement our own version of JavaScript’s built-in <code>call</code> function (as a reminder, <code>call</code> is a function that takes a function and a variable number of arguments, and applies those arguments to the function).<sup><a data-type="noteref" href="ch04.html#idm46304974415464" id="idm46304974415464-marker">8</a></sup> We’ll define and use it like this, using <code>unknown</code> for the types we’ll fill in later:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">call</code><code class="p">(</code>&#13;
  <code class="nx">f</code><code class="o">:</code> <code class="p">(...</code><code class="nx">args</code>: <code class="kt">unknown</code><code class="p">[])</code> <code class="o">=&gt;</code> <code class="nx">unknown</code><code class="p">,</code>&#13;
  <code class="p">...</code><code class="nx">args</code>: <code class="kt">unknown</code><code class="p">[]</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="nx">unknown</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">f</code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">fill</code><code class="p">(</code><code class="nx">length</code>: <code class="kt">number</code><code class="p">,</code> <code class="nx">value</code>: <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">({</code><code class="nx">length</code><code class="p">},</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">value</code><code class="p">)</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">call</code><code class="p">(</code><code class="nx">fill</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">)</code> <code class="c1">// evaluates to an array of 10 'a's</code></pre>&#13;
&#13;
<p>Now let’s fill in the <code>unknown</code>s. The constraints we want to express are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>f</code> should be a function that takes some set of arguments <code>T</code>, and returns some type <code>R</code>. We don’t know how many arguments it’ll have ahead of time.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>call</code> takes <code>f</code>, along with the same set of arguments <code>T</code> that <code>f</code> itself takes. Again, we don’t know exactly how many arguments to expect ahead of time.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>call</code> returns the same type <code>R</code> that <code>f</code> returns.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>We’ll need two type parameters: <code>T</code>, which is an array of arguments, and <code>R</code>, which is an arbitrary return value. Let’s fill in the types:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="kd">function</code><code> </code><code class="nx">call</code><strong><code class="o">&lt;</code><code class="nx">T</code><code> </code><code class="kr">extends</code><code> </code><code class="nx">unknown</code><code class="p">[</code><code class="p">]</code><code class="p">,</code><code> </code><code class="nx">R</code><code class="o">&gt;</code></strong><code class="p">(</code><code> </code><a class="co" href="#callout_functions_1" id="co_functions_1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">f</code><code class="o">:</code><code> </code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code>: </code><strong><code class="kt">T</code></strong><code class="p">)</code><code> </code><code class="o">=</code><code class="o">&gt;</code><code> </code><strong><code class="nx">R</code></strong><code class="p">,</code><code> </code><a class="co" href="#callout_functions_2" id="co_functions_2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code>: </code><strong><code class="kt">T</code></strong><code> </code><a class="co" href="#callout_functions_3" id="co_functions_3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">)</code><code class="o">:</code><code> </code><strong><code class="nx">R</code></strong><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_functions_4" id="co_functions_4"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">f</code><code class="p">(</code><code class="p">.</code><code class="p">.</code><code class="p">.</code><code class="nx">args</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
<p>How exactly does this work? Let’s walk through it step by step:</p>&#13;
&#13;
<dl class="calloutlist">&#13;
<dt>&#13;
<a class="co" href="#co_functions_1" id="callout_functions_1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd>&#13;
<p><code>call</code> is a variadic function (as a reminder, a variadic function is a function that accepts any number of arguments) that has two type parameters: <code>T</code> and <code>R</code>. <code>T</code> is a subtype of <code>unknown[]</code>; that is, <code>T</code> is an array or tuple of any type.</p></dd>&#13;
<dt>&#13;
<a class="co" href="#co_functions_2" id="callout_functions_2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd>&#13;
<p><code>call</code>’s first parameter is a function <code>f</code>. <code>f</code> is also variadic, and its arguments share a type with <code>args</code>: whatever type <code>args</code> is, <code>f</code> arguments have the same exact type.</p></dd>&#13;
<dt>&#13;
<a class="co" href="#co_functions_3" id="callout_functions_3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd>&#13;
<p>In addition to a function <code>f</code>, <code>call</code> has a variable number of additional parameters <code>...args</code>. <code>args</code> is a rest parameter—that is, a parameter that describes a variable number of arguments. <code>args</code>’s type is <code>T</code>, and <code>T</code> has to be an array type (in fact, if we forgot to say that <code>T</code> extends an array type, TypeScript would throw a squiggly at us), so TypeScript will infer a <em>tuple type</em> for <code>T</code> based on the specific arguments we passed in for <code>args</code>.</p></dd>&#13;
<dt>&#13;
<a class="co" href="#co_functions_4" id="callout_functions_4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd>&#13;
<p><code>call</code> returns a value of type <code>R</code> (<code>R</code> is bound to whatever type <code>f</code> returns).</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now when we call <code>call</code>, TypeScript will know exactly what the return type is, and it will complain when we<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2554" data-type="indexterm" id="idm46304974194696"/> pass the wrong number of arguments:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">call</code><code class="p">(</code><code class="nx">fill</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">)</code>      <code class="c1">// string[]</code>&#13;
<code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">call</code><code class="p">(</code><code class="nx">fill</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code>           <code class="c1">// Error TS2554: Expected 3 arguments; got 2.</code>&#13;
<code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">call</code><code class="p">(</code><code class="nx">fill</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="s1">'a'</code><code class="p">,</code> <code class="s1">'z'</code><code class="p">)</code> <code class="c1">// Error TS2554: Expected 3 arguments; got 4.</code></pre>&#13;
&#13;
<p>We use a similar technique to take advantage of the way TypeScript infers tuple types for rest parameters to improve<a data-primary="generics" data-secondary="bounded polymorphism" data-startref="ix_genbound" data-type="indexterm" id="idm46304974113432"/><a data-primary="functions" data-secondary="polymorphism" data-startref="ix_funcpolybnd" data-tertiary="bounded" data-type="indexterm" id="idm46304974154712"/><a data-primary="bounded polymorphism" data-startref="ix_boundply" data-type="indexterm" id="idm46304974153256"/><a data-primary="polymorphism" data-secondary="bounded" data-startref="ix_polybound" data-type="indexterm" id="idm46304974152312"/> type inference for tuples in <a data-type="xref" href="ch06.html#improving-type-inference-for-tuples">“Improving Type Inference for Tuples”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Generic Type Defaults" data-type="sect2"><div class="sect2" id="generic-type-defaults">&#13;
<h2>Generic Type Defaults</h2>&#13;
&#13;
<p>Just like you can give function parameters default values, you can give generic type parameters default types.<a data-primary="generics" data-secondary="type defaults" data-type="indexterm" id="idm46304974148216"/><a data-primary="polymorphism" data-secondary="generic type defaults" data-type="indexterm" id="idm46304974147240"/><a data-primary="functions" data-secondary="polymorphism" data-tertiary="generic type defaults" data-type="indexterm" id="idm46304974146296"/><a data-primary="defaults" data-secondary="generic type" data-type="indexterm" id="idm46304974145080"/> For example, let’s revisit the <code>MyEvent</code> type from <a data-type="xref" href="#generic-type-aliases">“Generic Type Aliases”</a>. As a reminder, we used the type to model DOM events, and it looks like this:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="nx">type</code> <code class="nx">MyEvent</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">target</code>: <code class="kt">T</code>&#13;
  <code class="nx">type</code>: <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To create a new event, we have to explicitly bind a generic type to <code>MyEvent</code>, representing the type of HTML element that the event was dispatched on:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">buttonEvent</code>: <code class="kt">MyEvent</code><code class="o">&lt;</code><code class="nx">HTMLButtonElement</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">target</code>: <code class="kt">myButton</code><code class="p">,</code>&#13;
  <code class="nx">type</code>: <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As a convenience for when we don’t know the specific element type that <code>MyEvent</code> will be bound to beforehand, we can add a default for <code>MyEvent</code>’s generic:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">MyEvent</code><code class="o">&lt;</code><code class="nx">T</code><code> </code><strong><code class="o">=</code><code> </code><code class="nx">HTMLElement</code></strong><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">target</code><code>: </code><code class="kt">T</code><code>&#13;
  </code><code class="nx">type</code><code>: </code><code class="kt">string</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>We can also use this opportunity to apply what we learned in the last few sections and add a bound to <code>T</code>, to make sure that <code>T</code> is an HTML element:</p>&#13;
<pre data-code-language="ts" data-type="programlisting">&#13;
<code class="nx">type</code><code> </code><code class="nx">MyEvent</code><code class="o">&lt;</code><code class="nx">T</code><code> </code><strong><code class="kr">extends</code><code> </code><code class="nx">HTMLElement</code></strong><code> </code><code class="o">=</code><code> </code><code class="nx">HTMLElement</code><code class="o">&gt;</code><code> </code><code class="o">=</code><code> </code><code class="p">{</code><code>&#13;
  </code><code class="nx">target</code><code>: </code><code class="kt">T</code><code>&#13;
  </code><code class="nx">type</code><code>: </code><code class="kt">string</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Now, we can easily create an event that’s not specific to a particular HTML element type, and we don’t have to manually bind <code>MyEvent</code>s <code>T</code> to <code>HTMLElement</code> when we create the event:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">myEvent</code>: <code class="kt">MyEvent</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">target</code>: <code class="kt">myElement</code><code class="p">,</code>&#13;
  <code class="nx">type</code>: <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that like optional parameters in functions, generic types with defaults have to appear after generic<a data-primary="errors" data-secondary="TypeScript errors" data-tertiary="TS2706" data-type="indexterm" id="idm46304973943784"/> types without defaults:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Good</code>&#13;
<code class="nx">type</code> <code class="nx">MyEvent2</code><code class="o">&lt;</code>&#13;
  <code class="nx">Type</code> <code class="kr">extends</code> <code class="kt">string</code><code class="p">,</code>&#13;
  <code class="nx">Target</code> <code class="kr">extends</code> <code class="nx">HTMLElement</code> <code class="o">=</code> <code class="nx">HTMLElement</code><code class="p">,</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">target</code>: <code class="kt">Target</code>&#13;
  <code class="nx">type</code>: <code class="kt">Type</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Bad</code>&#13;
<code class="nx">type</code> <code class="nx">MyEvent3</code><code class="o">&lt;</code>&#13;
  <code class="nx">Target</code> <code class="kr">extends</code> <code class="nx">HTMLElement</code> <code class="o">=</code> <code class="nx">HTMLElement</code><code class="p">,</code>&#13;
  <code class="nx">Type</code> <code class="kr">extends</code> <code class="kt">string</code>  <code class="c1">// Error TS2706: Required type parameters may</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>                  <code class="c1">// not follow optional type parameters.</code>&#13;
  <code class="nx">target</code>: <code class="kt">Target</code>&#13;
  <code class="nx">type</code>: <code class="kt">Type</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Type-Driven Development" data-type="sect1"><div class="sect1" id="idm46304977064984">&#13;
<h1>Type-Driven Development</h1>&#13;
&#13;
<p>With a powerful type system comes great power.<a data-primary="functions" data-secondary="polymorphism" data-startref="ix_funcpoly" data-type="indexterm" id="idm46304973892104"/><a data-primary="polymorphism" data-startref="ix_poly" data-type="indexterm" id="idm46304973855992"/> When you write in TypeScript, you will often find yourself “leading with the types.” This, of course, refers to <em>type-driven development</em>.<a data-primary="type-driven development" data-type="indexterm" id="idm46304973854408"/><a data-primary="functions" data-secondary="type-driven development" data-type="indexterm" id="idm46304973853672"/></p>&#13;
<aside class="keyTerm" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46304973852600">&#13;
<h5>Type-driven development</h5>&#13;
<p>A style of programming where you sketch out type signatures first, and fill in values later.<a data-primary="call signatures" data-secondary="in type-driven development" data-type="indexterm" id="idm46304973850920"/></p>&#13;
</div></aside>&#13;
&#13;
<p>The point of static type systems is to constrain the types of values an expression can hold. The more expressive the type system, the more it tells you about the value contained in that expression. When you apply an expressive type system to a function, the function’s type signature might end up telling you most of what you need to know about that function.</p>&#13;
&#13;
<p>Let’s look at the type signature for the <code>map</code> function from earlier in this chapter:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">function</code> <code class="nx">map</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">,</code> <code class="nx">U</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">array</code>: <code class="kt">T</code><code class="p">[],</code> <code class="nx">f</code><code class="o">:</code> <code class="p">(</code><code class="nx">item</code>: <code class="kt">T</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">U</code><code class="p">)</code><code class="o">:</code> <code class="nx">U</code><code class="p">[]</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Just looking at that signature—even if you’ve never seen <code>map</code> before—you should have some intuition for what <code>map</code> does: it takes an array of <code>T</code> and a function that maps from a <code>T</code> to a <code>U</code>, and returns an array of <code>U</code>. Notice that you didn’t have to see the function’s implementation to know that!<sup><a data-type="noteref" href="ch04.html#idm46304973820040" id="idm46304973820040-marker">9</a></sup></p>&#13;
&#13;
<p>When you write a TypeScript program, start by defining your functions’ type signatures—in other words, <em>lead with the types</em>—filling in the implementations later. <a data-primary="leading with the types" data-type="indexterm" id="idm46304973818056"/>By sketching out your program out at the type level first, you make sure that everything makes sense at a high level before you get down to your implementations.</p>&#13;
&#13;
<p>You’ll notice that so far, we’ve been doing the opposite: leading with the implementation, then deducing the types. Now that you have a grasp of writing and typing functions in TypeScript, we’re going to switch modes, sketching out the types first, and filling in the details later.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46304973816232">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this chapter we talked about how to declare and call functions, how to type parameters, and how to express common JavaScript function features like default parameters, rest parameters, generator functions, and iterators in TypeScript. We talked about the difference between functions’ call signatures and implementations, contextual typing, and the different ways to overload functions. Finally, we covered polymorphism for functions and type aliases in depth: why it’s useful, how and where to declare generic types, how TypeScript infers generic types, and how to declare and add bounds and defaults to your generics. We finished off with a short note on type-driven development: what it is, and how you can use your newfound knowledge of function types to do it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercises" data-type="sect1"><div class="sect1" id="idm46304973789592">&#13;
<h1>Exercises</h1>&#13;
<ol>&#13;
<li>&#13;
<p>Which parts of a function’s type signature does TypeScript infer: the parameters, the return type, or both?</p>&#13;
</li>&#13;
<li>&#13;
<p>Is JavaScript’s <code>arguments</code> object typesafe? If not, what can you use instead?</p>&#13;
</li>&#13;
<li>&#13;
<p>You want the ability to book a vacation that starts immediately. Update the overloaded <code>reserve</code> function from earlier in this chapter (<a data-type="xref" href="#function-overloads">“Overloaded Function Types”</a>) with a third call signature that takes just a destination, without an explicit start date. Update <code>reserve</code>’s implementation to support this new overloaded signature.</p>&#13;
</li>&#13;
<li>&#13;
<p>[Hard] Update our <code>call</code> implementation from earlier in the chapter (<a data-type="xref" href="#modelling-arity">“Using bounded polymorphism to model arity”</a>) to <em>only</em> work for functions whose second argument is a <code>string</code>. For all other functions, your implementation should fail at compile time.</p>&#13;
</li>&#13;
<li>&#13;
<p>Implement a small typesafe assertion library, <code>is</code>. Start by sketching out your types.<a data-primary="functions" data-startref="ix_func" data-type="indexterm" id="idm46304973778680"/> When you’re done, you should be able to use it like this:</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Compare a string and a string</code>&#13;
<code class="nx">is</code><code class="p">(</code><code class="s1">'string'</code><code class="p">,</code> <code class="s1">'otherstring'</code><code class="p">)</code> <code class="c1">// false</code>&#13;
&#13;
<code class="c1">// Compare a boolean and a boolean</code>&#13;
<code class="nx">is</code><code class="p">(</code><code class="kc">true</code><code class="p">,</code> <code class="kc">false</code><code class="p">)</code> <code class="c1">// false</code>&#13;
&#13;
<code class="c1">// Compare a number and a number</code>&#13;
<code class="nx">is</code><code class="p">(</code><code class="mi">42</code><code class="p">,</code> <code class="mi">42</code><code class="p">)</code> <code class="c1">// true</code>&#13;
&#13;
<code class="c1">// Comparing two different types should give a compile-time error</code>&#13;
<code class="nx">is</code><code class="p">(</code><code class="mi">10</code><code class="p">,</code> <code class="s1">'foo'</code><code class="p">)</code> <code class="c1">// Error TS2345: Argument of type '"foo"' is not assignable</code>&#13;
              <code class="c1">// to parameter of type 'number'.</code>&#13;
&#13;
<code class="c1">// [Hard] I should be able to pass any number of arguments</code>&#13;
<code class="nx">is</code><code class="p">([</code><code class="mi">1</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">])</code> <code class="c1">// false</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46304980032968"><sup><a href="ch04.html#idm46304980032968-marker">1</a></sup> Why are they unsafe? If you enter that last example into your code editor, you’ll see that its type is <code>Function</code>. What is this <code>Function</code> type? It’s an object that is callable (you know, by putting <code>()</code> after it) and has all the prototype methods from <code>Function.prototype</code>. But its parameters and return type are untyped, so you can call the function with any arguments you want, and TypeScript will stand idly by, watching you do something that by all means should be illegal in whatever town you live in.</p><p data-type="footnote" id="idm46304979137208"><sup><a href="ch04.html#idm46304979137208-marker">2</a></sup> For a deep dive into <code>this</code>, check out Kyle Simpson’s <a href="http://shop.oreilly.com/product/0636920033738.do">You Don’t Know JS</a> series from O’Reilly.</p><p data-type="footnote" id="idm46304978700968"><sup><a href="ch04.html#idm46304978700968-marker">3</a></sup> Notably, <code>Object</code> and <code>Number</code> are not iterators.</p><p data-type="footnote" id="idm46304978500936"><sup><a href="ch04.html#idm46304978500936-marker">4</a></sup> The exceptions to this rule of thumb are enums and namespaces. Enums generate both a type and a value, and namespaces exist just at the value level. See <a data-type="xref" href="app03.html#types-and-values">Appendix C</a> for a complete reference.</p><p data-type="footnote" id="idm46304978237208"><sup><a href="ch04.html#idm46304978237208-marker">5</a></sup> If you haven’t heard the term “callback” before, all it is is a function that you passed as an argument to another function.</p><p data-type="footnote" id="idm46304977663240"><sup><a href="ch04.html#idm46304977663240-marker">6</a></sup> To learn more, jump ahead to <a data-type="xref" href="ch06.html#refinement">“Refinement”</a>.</p><p data-type="footnote" id="idm46304977328888"><sup><a href="ch04.html#idm46304977328888-marker">7</a></sup> Mostly—TypeScript hoists literal overloads above nonliteral ones, before resolving them in order. You might not want to depend on this feature, though, since it can make your overloads hard to understand for other engineers who aren’t familiar with this behavior.</p><p data-type="footnote" id="idm46304974415464"><sup><a href="ch04.html#idm46304974415464-marker">8</a></sup> To simplify our implementation a little, we’re going to design our <code>call</code> function to not take <code>this</code> into account.</p><p data-type="footnote" id="idm46304973820040"><sup><a href="ch04.html#idm46304973820040-marker">9</a></sup> There are a few programming languages (like the Haskell-like language Idris) that have built-in constraint solvers with the ability to <em>automatically</em> implement function bodies for you from the signatures you write!</p></div></div></section></body></html>