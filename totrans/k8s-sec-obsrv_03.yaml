- en: Chapter 3\. Workload Deployment Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章. 工作负载部署控制
- en: With contributions from Manoj Ahuje,
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Manoj Ahuje 的贡献下，
- en: Senior Threat Intelligence Research Engineer at Tigera
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Tigera 的高级威胁情报研究工程师
- en: Once you decide on a strategy for infrastructure security, next in line is workload
    deployment controls. In this chapter we will look at image building and scanning
    strategy, CI/CD (integrating image scanning into builds), and Kubernetes role-based
    access control (RBAC), which is a widely used authorization system that allows
    you to define access control based on user roles, and secrets management for your
    applications.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您决定了基础设施安全策略，下一个步骤是工作负载部署控制。在本章中，我们将探讨镜像构建和扫描策略，CI/CD（将镜像扫描集成到构建中），以及 Kubernetes
    基于角色的访问控制（RBAC），这是一种广泛使用的授权系统，允许您根据用户角色定义访问控制，以及应用程序的密钥管理。
- en: Image Building and Scanning
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 镜像构建和扫描
- en: In this section we will explore best practices for image building and scanning.
    These include choosing a base image to reduce attack surface and using scratch
    images and image hardening best practices to deter adversaries. Image scanning
    dives into the nuances of choosing an image scanning solution, privacy concerns,
    and an overview of container threat analysis solutions.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨镜像构建和扫描的最佳实践。这些包括选择基础映像以减少攻击面，使用 scratch 映像和镜像硬化最佳实践以防止对手入侵。镜像扫描涉及选择镜像扫描解决方案的细节，隐私问题，以及容器威胁分析解决方案的概述。
- en: Choice of a Base Image
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础映像的选择
- en: As discussed in the previous chapter, you can choose modern Linux distributions
    like Bottlerocket as base images for containers. The minimal version of traditional
    Linux distributions, like Ubuntu, Red Hat, and Alpine, are available too.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如在前一章节讨论的，您可以选择像 Bottlerocket 这样的现代 Linux 发行版作为容器的基础映像。传统 Linux 发行版的最小版本，如 Ubuntu、Red
    Hat 和 Alpine，也是可用的。
- en: Though it’s a good starting point to begin with a minimal image, the minimal
    image approach doesn’t stop vulnerabilities being discovered in OS packages that
    are present in the OS. In this case distroless or scratch images turn out to be
    a better option. These types of images only contain the application and its specific
    runtime dependencies.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用最小映像作为起点是个不错的开始，但是最小映像方法并不能阻止发现存在于操作系统中的 OS 包的漏洞。在这种情况下，distroless 或 scratch
    映像会是更好的选择。这些类型的映像仅包含应用程序及其特定的运行时依赖项。
- en: 'Here are the benefits of distroless or scratch images:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 distroless 或 scratch 映像的好处：
- en: This strategy reduces size, attack surface, and vulnerabilities significantly,
    which results in better security posture.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种策略显著减少了大小、攻击面和漏洞，从而提高了安全性。
- en: Distroless images are production ready. Kubernetes itself uses distroless images
    for various components like kublet, scheduler, etc.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Distroless 映像已经可以用于生产环境。Kubernetes 本身就使用 distroless 映像来构建各种组件，如 kublet、scheduler
    等。
- en: In case you are going for a scratch base image for your application, a multistage
    Dockerfile can be used to build a scratch image. The first stage involves building
    your application. The second stage involves moving runtime dependencies and applications
    to scratch.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果您要为应用程序选择一个基础映像，可以使用多阶段 Dockerfile 来构建一个基础映像。第一阶段涉及构建您的应用程序。第二阶段涉及将运行时依赖和应用程序移到基础映像。
- en: The most popular example of a distroless image project is [distroless from Google](https://oreil.ly/UIzu0),
    which provides images for various runtimes like Java, Python, or C++.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: distroless 映像项目的最受欢迎的例子是来自 Google 的 [distroless](https://oreil.ly/UIzu0)，它为
    Java、Python 或 C++ 等各种运行时提供映像。
- en: A scratch image starts with the Dockerfile instruction FROM:scratch, which signifies
    an empty filesystem. The following instruction in Dockerfile creates the first
    filesystem layer of the container image. Here, the first filesystem layer needs
    to be compiled with the application and dependencies. Since it’s nonproductive
    and nonintuitive to build applications outside of the container, Docker introduced
    [multistage builds](https://oreil.ly/K161o). With a multistage build, multiple
    FROM instructions are allowed in a Dockerfile. Each FROM instruction creates a
    separate stage, and the filesystem artifact from a previous stage can be copied
    in a later stage of the build. This mechanism enabled developers to build and
    compile applications in an earlier stage (builder image) with all dependencies
    available, and eventually only copy the filesystem artifacts required to run the
    production application in a later stage. The last stage of the build can be a
    scratch image where only application binaries and dependencies are required to
    be present on the resulting image.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空白镜像从 Dockerfile 指令 FROM:scratch 开始，表示一个空文件系统。在 Dockerfile 中的下一条指令创建了容器镜像的第一个文件系统层。在这里，第一个文件系统层需要与应用程序和依赖项一起编译。因为在容器外部构建应用程序是不生产和不直观的，Docker
    引入了[多阶段构建](https://oreil.ly/K161o)。通过多阶段构建，Dockerfile 允许多个 FROM 指令。每个 FROM 指令创建一个独立的阶段，之前阶段的文件系统产物可以在后续阶段的构建中复制。这个机制使开发者能够在较早的阶段（构建器镜像）中构建和编译应用程序，所有依赖项都可用，并最终仅复制运行生产应用程序所需的文件系统产物到后续阶段。构建的最后阶段可以是一个空白镜像，只需要在结果镜像中存在应用程序二进制文件和依赖项。
- en: Following is an example of a scratch-based image for a bash script, where the
    goal is to run a script within a container. Here you can create a two-stage Dockerfile
    where the second stage is a scratch image containing only the dependencies for
    the script.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个基于空白镜像的 bash 脚本示例，目标是在容器内运行一个脚本。在这里，你可以创建一个两阶段 Dockerfile，其中第二阶段是一个仅包含脚本依赖项的空白镜像。
- en: 'You can use this template to containerize even complex applications built with
    Node.js, Python, and Go. Go additionally provides an option to compile all the
    runtime libraries into the binary. In the following example, you can use Alpine
    as the base image to construct a scratch image for a container that runs a script:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用这个模板来容器化甚至是使用 Node.js、Python 和 Go 构建的复杂应用程序。Go 还提供了一个选项，可以将所有的运行时库编译到二进制文件中。在下面的示例中，你可以使用
    Alpine 作为基础镜像，为运行脚本的容器构建一个空白镜像：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that we have reviewed how to choose a base image for your container, let’s
    explore container image hardening.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经回顾了如何为你的容器选择基础镜像，让我们探讨一下容器镜像的强化。
- en: Container Image Hardening
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器镜像强化
- en: Container image hardening is the process of building images to reduce security
    weaknesses and attack surface. At the same time, it is used to add defensive layers
    to run applications securely within the container.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像强化是构建镜像以减少安全弱点和攻击面的过程。同时，它被用来为容器内的应用程序添加防御层，以确保安全运行。
- en: 'If you use a nonhardened container image, it can be prone to abuse, information
    disclosure, or easier privilege escalation to the container host. You should leverage
    the following tools and best practices to build hardened container images for
    your applications:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用一个未强化的容器镜像，可能会容易受到滥用、信息泄露或者更容易提升到容器主机的特权攻击。你应该利用以下工具和最佳实践来为你的应用程序构建强化的容器镜像：
- en: Only use base images from trusted sources, such as official Ubuntu and Red Hat
    release channels, and double-check the image hash with released information, as
    it’s relatively easy to embed malicious code like cryptominers into an image and
    make that image available on a repository like Docker Hub.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只使用来自受信任来源的基础镜像，比如官方 Ubuntu 和 Red Hat 发行渠道，并且使用发布信息双重检查镜像哈希，因为很容易在镜像中嵌入恶意代码，比如加密货币挖矿程序，并将这些镜像发布在像
    Docker Hub 这样的仓库中。
- en: Minimize your base images to only contain runtime dependencies for your application.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将基础镜像最小化，仅包含应用程序的运行时依赖项。
- en: Follow the principle of least privilege access and run containers with the minimum
    required permissions. For example, run containers as nonroot unless root privileges
    are necessary. This makes it difficult for the attackers to escape the container
    and provides protection from vulnerabilities like *[CVE-2020-15257](https://oreil.ly/txXJL)*,
    where the root user was able to escape the container.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遵循最小权限访问原则，并以最低所需权限运行容器。例如，除非需要 root 权限，否则应将容器作为非 root 用户运行。这使得攻击者难以逃离容器，并提供了对漏洞的保护，例如
    *[CVE-2020-15257](https://oreil.ly/txXJL)*，其中 root 用户能够逃离容器。
- en: Do not use tags for Docker images; rather, pin the base image version in the
    Dockerfile (i.e., ubuntu:20.08). Mutable tags like *latest* or *master* are updated
    constantly with features and fixes, which can cause issues while scanning images
    as a part of your CI/CD pipeline. Additionally, they can cause stability issues
    for an application (where the underlying dependant library is updated/removed
    or changed).
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用 Docker 镜像的标签；而是在 Dockerfile 中固定基础镜像版本（例如，ubuntu:20.08）。可变的标签如 *latest*
    或 *master* 不断更新以增加功能和修复问题，这可能导致在 CI/CD 流水线的镜像扫描中出现问题。此外，它们可能导致应用程序稳定性问题（其中底层依赖库被更新/移除或更改）。
- en: Compress Docker image layers into one single layer. Container images built with
    tools like Docker or buildah often have multiple layers. These layers show a development
    history and sometimes end up leaking sensitive information. The best way to compress
    existing layers is to use a multistage build; there is also an experimental Docker
    feature (i.e., option [`--squash`](https://oreil.ly/U5RaL) available in Docker
    API 1.25+).
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Docker 镜像层压缩为单个层。使用 Docker 或 buildah 等工具构建的容器镜像通常具有多个层。这些层显示了开发历史，有时会泄露敏感信息。压缩现有层的最佳方法是使用多阶段构建；还有一个实验性的
    Docker 功能（即 Docker API 1.25+ 中提供的选项 [`--squash`](https://oreil.ly/U5RaL)）。
- en: Use container image signing to trust the image. Natively, Kubernetes doesn’t
    have container image verification. Docker Notary can be used to sign images, and
    by using the Kubernetes admission controller, it is possible to verify an image
    signature and determine if an image was tampered with by a malicious actor (e.g.,
    if the image is changed while it is seated at the registry).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器镜像签名来信任该镜像。原生的 Kubernetes 并不具备容器镜像验证功能。可以使用 Docker Notary 对镜像进行签名，并通过 Kubernetes
    准入控制器验证镜像签名，以确定镜像是否被恶意行为者篡改（例如，在镜像位于注册表时对其进行更改）。
- en: In the next section, we will review container image scanning.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将审查容器镜像扫描。
- en: Container Image Scanning Solution
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器镜像扫描解决方案
- en: 'Container image scanning tools examine the container filesystem to get the
    metadata to know if there are vulnerable components present in the image. There
    are many open source and commercial enterprise solutions available in the market
    that you can use for this purpose. They come with CI/CD integrations and a rich
    set of scanning features. The solution you choose should answer some of these
    basic questions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像扫描工具检查容器文件系统以获取元数据，了解镜像中是否存在易受攻击的组件。市场上有许多开源和商业企业解决方案可供选择，用于此目的。它们具有 CI/CD
    集成和丰富的扫描功能。您选择的解决方案应该能够回答一些基本问题：
- en: Can the image scanner scan OS packages present in a container image for your
    selected base image?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像扫描器能否为您选择的基础镜像中的操作系统包进行扫描？
- en: Can it scan your application dependencies (does it understand languages used
    by your application, e.g., Go, Python, Node.js)?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它能否扫描您的应用程序依赖项（是否理解应用程序使用的语言，如 Go、Python、Node.js）？
- en: Can the image scanner detect sensitive files present in the filesystem (certificates,
    passwords)?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像扫描器能否检测文件系统中存在的敏感文件（如证书、密码）？
- en: What is the false positive rate?
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 误报率是多少？
- en: Can it scan binaries (.elf or .exe)?
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它可以扫描二进制文件（.elf 或 .exe）吗？
- en: What data will be collected by the scanning solution? Does the scanning solution
    upload your image to its SaaS service, or does the solution only collect package
    metadata? It is important to understand this due to the risk of data exposure.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描解决方案将收集哪些数据？扫描解决方案是否将您的镜像上传到其 SaaS 服务，还是仅收集包元数据？由于数据暴露风险，了解这一点非常重要。
- en: Where will the collected data be stored? On-prem or cloud SaaS? Please review
    this and choose the option that works with the guidelines set by your security/compliance
    teams.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集的数据将存储在哪里？在本地还是云端 SaaS？请查阅并选择符合安全/合规团队指南的选项。
- en: Does the image scanner have an integration with your CI/CD system?
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像扫描器是否与您的 CI/CD 系统集成？
- en: Most scanners collect metadata from filesystems and try to match it with vulnerability
    information gathered from sources such as the National Vulnerability Database
    or private intelligence sources to determine the presence of vulnerability. Please
    note that you should expect both false positives and negatives as a part of scanning.
    For images with confirmed vulnerabilities, the application and the security team
    need to work together to analyze the impact and the risk of the CVE to your operation.
    Remediation steps involve implementing workarounds and patching the image when
    an update is available.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数扫描器从文件系统收集元数据，并尝试与从国家漏洞数据库或私人情报来源收集的漏洞信息匹配，以确定漏洞的存在。请注意，扫描中可能会出现假阳性和假阴性。对于已确认存在漏洞的镜像，应用程序和安全团队需要共同分析CVE对运营的影响和风险。修复步骤涉及在更新可用时实施解决方法和修补镜像。
- en: Many public cloud providers and container registry service providers offer container
    scanning services. However, there are limitations to the OS versions they support,
    and most of them don’t scan application dependencies. Here the open source world
    has more to offer. Notable examples of open source tools that can scan application
    dependencies are [Anchore](https://oreil.ly/QNdyU), which lets users define policy,
    and [Trivy](https://oreil.ly/CYP4B), which is easy to integrate in CI.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 许多公共云提供商和容器注册服务提供商提供容器扫描服务。然而，它们支持的操作系统版本有限，并且大多数不扫描应用程序依赖关系。在这方面，开源世界提供了更多选择。一些可以扫描应用程序依赖关系的著名开源工具包括[Anchore](https://oreil.ly/QNdyU)，允许用户定义策略，以及[Trivy](https://oreil.ly/CYP4B)，易于集成到CI中。
- en: Privacy Concerns
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隐私问题
- en: Security vulnerabilities and associated information in your product is highly
    classified data, and in the wrong hands it could be a big liability to the organization.
    That’s why before you choose any solution, it’s good practice to verify what data
    is being collected by a scanning solution and where that data is stored (e.g.,
    within the enterprise on-premise or in the cloud as a part of an SaaS service).
    If you are buying a commercial solution, it is important to check the contract
    to know the clauses for damages in case of data breach. Often these clauses can
    help you understand how serious an organization is about data security. In case
    you are using an open source solution, please review the documentation to understand
    the risks of data leakage.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 产品中的安全漏洞及相关信息是高度机密的数据，如果落入错误的手中，可能对组织构成重大责任。因此，在选择任何解决方案之前，最好验证扫描解决方案收集了哪些数据以及这些数据存储在哪里（例如，在企业内部的本地或作为SaaS服务的一部分在云端）。如果购买商业解决方案，请检查合同以了解在数据泄露情况下的损害条款。通常，这些条款可以帮助您了解组织对数据安全的严肃态度。如果使用开源解决方案，请阅读文档以了解数据泄露风险。
- en: Container Threat Analysis
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器威胁分析
- en: In addition to traditional image scanning, the area of container threat analysis
    using sandbox-based solutions is gaining popularity. It is a relatively new area,
    and we recommend you watch it. These sandbox-based solutions can run Docker images
    and monitor for container system calls, processes, memory, network traffic (HTTP,
    DNS, SSL, TCP), and overall behavior of the container, using machine learning
    and other techniques to determine any malicious activity. Additionally, they can
    scan container filesystems to check for vulnerabilities as well as malicious binaries.
    These can be used to detect advanced persistent threats (APTs) and malware.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的镜像扫描，使用基于沙箱的解决方案进行容器威胁分析的领域正在日益流行。这是一个相对较新的领域，我们建议您关注。这些基于沙箱的解决方案可以运行Docker镜像，并监视容器系统调用、进程、内存、网络流量（HTTP、DNS、SSL、TCP）以及容器的整体行为，利用机器学习和其他技术来检测任何恶意活动。此外，它们还可以扫描容器文件系统以检查漏洞和恶意二进制文件。这些技术可用于检测高级持续性威胁（APTs）和恶意软件。
- en: CI/CD
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CI/CD
- en: In this section we will cover various strategies to integrate image scanning
    solutions into your CI/CD pipeline, best practices to secure your CI/CD pipelines,
    and techniques to implement organizational policies for CI/CD and vulnerability
    scanning.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论将镜像扫描解决方案集成到您的CI/CD流水线中的各种策略，保护CI/CD流水线的最佳实践，以及实施CI/CD和漏洞扫描的组织政策技术。
- en: Continuous integration (CI) is a development practice in which each developer’s
    check-in is verified by an automated build, allowing teams to detect problems
    early. And continuous deployment (CD) is the extension of CI where changes are
    released for downstream consumers once they pass all release checks.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 连续集成（CI）是一种开发实践，每个开发者的检入都会通过自动化构建进行验证，使团队能够早期检测问题。而连续部署（CD）是CI的延伸，一旦通过所有发布检查，变更就会发布给下游消费者。
- en: Integrating security at each step of the development and release process is
    the goal of CI/CD, which is an integral part of shift-left strategy in DevOps
    processes. By integrating image scanning into your CI/CD pipeline (see [Figure 3-1](#integrating_image_scanning_into_the_cis)),
    development teams can have a verdict available as soon as a check-in from a developer
    is committed to the repository. The main advantage of this approach is that new
    security vulnerabilities or threats can be detected at build time. Once an issue
    is found, all stakeholders and DevOps teams can be notified, typically by failing
    the CI job. Then respective teams can start working on remediation immediately.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在CI/CD的目标中，将安全性集成到开发和发布过程的每个步骤中是关键，这是DevOps流程中左移策略的一个重要部分。通过将图像扫描集成到您的CI/CD流水线中（见[图3-1](#integrating_image_scanning_into_the_cis)），开发团队可以在开发者提交到代码库后立即获得检查结果。这种方法的主要优势在于可以在构建时检测到新的安全漏洞或威胁。一旦发现问题，所有利益相关者和DevOps团队通常会通过CI作业失败收到通知。然后各团队可以立即开始进行修复工作。
- en: '![](Images/ksao_0301.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ksao_0301.png)'
- en: Figure 3-1\. Integrating image scanning into the CI/CD process
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 3-1\. 将图像扫描集成到CI/CD过程中
- en: As shown in [Figure 3-1](#integrating_image_scanning_into_the_cis), the scanning
    should be integrated at each step of the development cycle, from the developer
    check-in to continuous delivery to production. The rest of this section will be
    focused on the CI part of the integration to show the granularity of the image
    scanning process. The following strategies can be applied to each step shown in
    [Figure 3-1](#integrating_image_scanning_into_the_cis) (i.e., code, build [CI],
    and CD pipeline).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3-1](#integrating_image_scanning_into_the_cis)所示，扫描应该在开发周期的每个步骤中进行集成，从开发者检入到持续交付到生产。本节的其余部分将专注于集成中的CI部分，以展示图像扫描过程的细粒度。可以将以下策略应用于[图3-1](#integrating_image_scanning_into_the_cis)中显示的每个步骤（即代码、构建[CI]和CD流水线）。
- en: The choice of the specific CI/CD build infrastructure is secondary and can be
    chosen according to wider requirements. Popular CI/CD providers include but are
    not limited to [Jenkins](https://oreil.ly/ge9Q1), [Semaphore](https://oreil.ly/xpiFH),
    and [CircleCI](https://circleci.com). There are four main ways to integrate image
    scanning into your CI/CD pipeline and build infrastructure, as shown in [Figure 3-2](#image_scanning_integrated_as_a_part_of).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 选择特定的CI/CD构建基础设施是次要的，可以根据更广泛的需求进行选择。流行的CI/CD提供者包括但不限于[Jenkins](https://oreil.ly/ge9Q1)，[Semaphore](https://oreil.ly/xpiFH)，和[CircleCI](https://circleci.com)。有四种主要方式将图像扫描集成到您的CI/CD流水线和构建基础设施中，如[图3-2](#image_scanning_integrated_as_a_part_of)所示。
- en: '![](Images/ksao_0302.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ksao_0302.png)'
- en: Figure 3-2\. Image scanning integrated as a part of the image registry
  id: totrans-54
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 3-2\. 将图像扫描集成为图像注册表的一部分
- en: Scan Images by Registry Scanning Services
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过注册表扫描服务扫描图像
- en: As illustrated in [Figure 3-2](#image_scanning_integrated_as_a_part_of), in
    this approach as soon as a check-in is available from the developer, CI builds
    and pushes images to the registry. Then images are periodically scanned by the
    services integrated within the registry. There are many downsides to this approach;
    registry providers usually limit themselves to scanning the operating system package
    layer (e.g., GCR and Quay). Since they show limited information, using vulnerability
    whitelisting, classification, and tracking timelines to fix various issues can
    be really cumbersome. Also, most of the time there is no option to write policy
    tailored to your organization’s needs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图3-2](#image_scanning_integrated_as_a_part_of)所示，在这种方法中，一旦开发者提交了检入，CI即构建并将图像推送到注册表。然后图像会定期被注册表内集成的服务扫描。这种方法有许多缺点；注册表提供商通常仅限于扫描操作系统软件包层（例如GCR和Quay）。由于它们显示的信息有限，使用漏洞白名单、分类和跟踪时间表来解决各种问题可能非常麻烦。此外，大多数情况下没有选项可以编写符合您组织需求的策略。
- en: When the image scanner finds an issue, the image may have already been consumed
    or delivered using CD. The registry doesn’t keep track of which consumed images
    consumed and who deployed them. Users using those images may be at risk of compromise
    and not even know about the vulnerabilities identified by the registry scanning
    service. Vulnerability remediation only comes after notification, which can be
    an alert or email to the development team and other stakeholders. It can be anything
    from a simple update from the upstream provider to complex code and a configuration
    fix. This kind of remediation effort tends to lag behind the development process.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当镜像扫描器发现问题时，可能已经使用CD消耗了镜像。注册表不会跟踪消耗了哪些镜像及其部署者。使用这些镜像的用户可能面临妥协风险，却不知道注册表扫描服务识别出的漏洞。漏洞修复仅在通知后进行，可以是向开发团队和其他利益相关者发出的警报或电子邮件。修复可能是从上游提供商的简单更新到复杂的代码和配置修复。这种修复工作往往滞后于开发过程。
- en: '[Figure 3-3](#image_scanning_as_a_part_of_the_build_p) shows how images are
    built and scanned as a part of the CI process, but images are pushed to the internal
    registry without considering a verdict from the scanner. If you are an agile DevOps
    team, you may be building and pushing images to your internal registry every day
    or every hour as soon as a check-in is available on multiple branches. In this
    case, you don’t want every build to be failing as a part of CI if there is a vulnerability
    present in the image. Rather, you would get a notification for a vulnerability,
    and the developer can fix that vulnerability before CD kicks in.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-3](#image_scanning_as_a_part_of_the_build_p)显示了镜像作为CI过程的一部分进行构建和扫描的方式，但无视扫描器的判定将镜像推送到内部注册表。如果您是一个敏捷的DevOps团队，您可能每天或每小时在多个分支上提交检查后立即构建和推送镜像至内部注册表。在这种情况下，如果镜像中存在漏洞，您不希望每个构建都作为CI的一部分失败。相反，您会收到有关漏洞的通知，开发人员可以在CD启动之前修复该漏洞。'
- en: '![](Images/ksao_0303.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ksao_0303.png)'
- en: Figure 3-3\. Image scanning as a part of the build process
  id: totrans-60
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-3\. 镜像作为构建过程的一部分进行扫描
- en: Scan Images After Builds
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建后扫描镜像
- en: The drawback of the approach is that even though every image is scanned right
    after it is built, there is no mechanism to force developers to fix found issues
    immediately. Additionally, images are available for internal consumption from
    the registry even if vulnerability is detected, and therefore it could be a weak
    link in the organization, which can lead to the compromise.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于，即使每个镜像在构建后立即进行扫描，也没有机制强制开发人员立即修复发现的问题。此外，即使检测到漏洞，镜像也可从注册表内提供给内部使用，因此可能成为组织中的薄弱环节，可能导致妥协。
- en: As illustrated in [Figure 3-4](#image_scanning_inline_as_a_part_of_the), a CI
    job kicks in with a check-in from the developer, which builds and subsequently
    scans the images. Once the scan is complete, a verdict from the image scanner
    is evaluated. If it passes, then images are pushed to the registry for internal
    consumption. If it fails, the developer needs to remediate the issue immediately,
    as they won’t have the latest build available with their changes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 3-4](#image_scanning_inline_as_a_part_of_the)所示，开发人员提交检查时会启动CI作业，构建并随后扫描镜像。扫描完成后，会评估镜像扫描器的判定。若通过，则将镜像推送至内部注册表以供使用。若未通过，则开发人员需立即修复问题，因为他们无法使用包含更改的最新构建。
- en: '![](Images/ksao_0304.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ksao_0304.png)'
- en: Figure 3-4\. Image scanning inline as a part of the CI/CD process
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-4\. 镜像内联扫描作为CI/CD过程的一部分
- en: Inline Image Scanning
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联镜像扫描
- en: This pipeline can be difficult to manage initially, depending on the size and
    velocity of your organization, but once it is mastered, the organization gets
    much better control over its security posture. The same pipeline design can be
    utilized in your CD jobs so that your applications are the most secure at the
    time of release/deployment.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最初阶段，这种管道可能难以管理，这取决于您组织的规模和速度，但一旦掌握，组织就能更好地控制其安全姿态。同样的管道设计可以应用于您的CD作业，以确保在发布/部署时您的应用程序最为安全。
- en: Kubernetes admission controllers can intercept pod creation requests from the
    Kubernetes API (see [Figure 3-5](#_image_scanning_as_a_part_of_pod_creati)). This
    mechanism can be used as a last-minute check by triggering a CI job to scan an
    image that is being deployed on the cluster. Depending on the verdict of the scan,
    the admission controller can admit or kick out the pod.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes准入控制器可以拦截来自Kubernetes API的Pod创建请求（参见[图3-5](#_image_scanning_as_a_part_of_pod_creati)）。该机制可以作为最后一分钟的检查，通过触发CI作业来扫描正在部署到集群上的镜像。根据扫描的结果，准入控制器可以允许或驳回该Pod。
- en: '![](Images/ksao_0305.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ksao_0305.png)'
- en: Figure 3-5\. Image scanning as a part of pod creation
  id: totrans-70
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图3-5\. 作为Pod创建的一部分的镜像扫描
- en: Kubernetes Admission Controller
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes准入控制器
- en: This method usually needs a custom or off-the-shelf admission controller that
    is able to talk to admission servers that respond with a verdict for the scan
    performed. From a fault tolerance point of view, it’s worth noting that if the
    admission server fails for some reason, then it can impact pod creation in the
    entire cluster. Whether you want the admission controller to “fail open” (i.e.,
    go ahead with pod creation) or “fail close” (i.e., prevent all pod creation) in
    the event of admission server failure is the organization’s decision; weigh the
    security risks against the fault tolerance risks.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通常需要自定义或现成的准入控制器，它能够与准入服务器通信，并对执行的扫描给出判断。从容错的角度来看，值得注意的是，如果准入服务器因某些原因失败，则可能影响整个集群中的Pod创建。在准入服务器失败的情况下，您希望准入控制器“故障开放”（即继续进行Pod创建）还是“故障关闭”（即阻止所有Pod创建）是组织的决定；权衡安全风险与容错风险。
- en: Since admission controllers are a last-minute check, usually development teams
    are unaware of the found security vulnerabilities until they look at what is being
    scanned and rejected at the moment. So it is recommended that this approach be
    used in combination with earlier methods as a part of your defense strategy.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于准入控制器是最后一分钟的检查，通常开发团队在查看正在扫描和拒绝的内容之前是不知道发现的安全漏洞的。因此建议将此方法与早期方法结合使用，作为您防御策略的一部分。
- en: Securing the CI/CD Pipeline
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护CI/CD流水线
- en: CI/CD pipelines’ autonomous nature and minimum human interaction makes CI/CD
    an attractive target for attackers. Additionally, the development environment
    can be overly permissive with a minimum focus on security. Following are the best
    practices to secure your CI/CD pipelines.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD流水线的自主性质和最少人为干预使得CI/CD成为攻击者的一个吸引目标。此外，开发环境可能过于宽容，对安全关注不足。以下是保护您的CI/CD流水线的最佳实践。
- en: Zero-trust policy for CI/CD environment
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CI/CD环境的零信任策略
- en: Every connection to and from your CI/CD pipeline needs to be scrutinized with
    a zero-trust policy in place for underlying hosts, infrastructure, and any supporting
    processes according to your threat model. This will ensure that egress and ingress
    access to the CI/CD pipeline is managed through a secure policy.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有与您的CI/CD流水线的连接，无论是入站还是出站，都需要根据您的威胁模型进行零信任策略的严格审查。这将确保对CI/CD流水线的出站和入站访问通过安全策略进行管理。
- en: Secure secrets
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全的机密管理
- en: Review each secret required by your CI/CD pipeline and make sure passwords,
    access tokens, and encryption keys are called only when required. The design of
    secrets management needs to consider fine-grained access to secrets, secret usage
    and changelog capabilities, automated secret rotation, and deactivation and deprecation.
    We will discuss more about secrets management in the upcoming section of this
    chapter to help you choose the right strategy.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 审查您的CI/CD流水线所需的每个机密，并确保仅在需要时调用密码、访问令牌和加密密钥。机密管理的设计需要考虑对机密的细粒度访问、机密使用和更改日志功能、自动机密轮换以及停用和废弃。我们将在本章的后续部分详细讨论机密管理，以帮助您选择合适的策略。
- en: Access control
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问控制
- en: Tight access control to CI/CD resources and the separation of user responsibilities
    is the key to a secure CI/CD pipeline, whether you have a role-based, time-based,
    or task-based approach. Access control needs to segment the access to the pipeline
    so that in case of compromise, the blast radius is reduced significantly. Also,
    use a strong authentication mechanism with two-factor authentication enabled by
    default.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 对CI/CD资源的严格访问控制和用户责任的分离是确保安全的关键，无论是基于角色、时间还是任务的方法。访问控制需要对流水线的访问进行分段，以便在受到威胁时大幅减少爆炸半径。此外，使用默认启用的两因素认证机制。
- en: Audit and monitoring
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审计和监控
- en: Access to CI/CD resources needs continuous auditing and monitoring to determine
    excessive access, access deprecation in case a user leaves the organization or
    changes job roles, abuse, or suspicious user behavior.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 对 CI/CD 资源的访问需要持续审核和监控，以确定过度访问、用户离开组织或更改工作角色时的访问停用、滥用或可疑用户行为。
- en: Organization Policy
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组织策略
- en: To tackle challenges presented by CI/CD pipelines and scanning, a global organization
    policy is required. The policy needs to call out access requirements to CI/CD
    resources, separation of user responsibilities, secret management, logging and
    monitoring requirements, and audit policy.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 解决 CI/CD 流水线和扫描带来的挑战，需要全局组织策略。该策略需指出对 CI/CD 资源的访问要求、用户职责的分离、秘密管理、日志记录和监控要求以及审计策略。
- en: Vulnerability scans can overwhelm teams initially. Hence, development, DevOps,
    and security teams need clear directives on product vulnerability discovery and
    assessment, risk, remediation, and timelines to close the issues based on the
    organization’s threat model.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，漏洞扫描可能会使团队不堪重负。因此，开发、DevOps 和安全团队需要明确的指导方针，用于产品漏洞发现和评估、风险、修复和根据组织的威胁模型关闭问题的时间表。
- en: Vulnerability scanning solutions can have codified policies where images can
    be admitted or rejected based on scan results and the risk tolerance of the organization.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 漏洞扫描解决方案可以具有 codified 策略，根据扫描结果和组织的风险容忍度，可以接受或拒绝镜像。
- en: The process to build an effective policy needs to be iterative and based on
    continuous feedback to achieve a tailored policy, balancing security and performance
    according to your industry, size, workflows, and compliance requirements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 构建有效策略的过程需要迭代，并基于持续反馈以实现量身定制的策略，根据您的行业、规模、工作流程和合规要求，平衡安全性和性能。
- en: Secrets Management
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秘密管理
- en: A secret can be anything that is used to authenticate and authorize users, groups,
    or entities. It can be a username/passwords, API token, or TLS certificate. When
    an application or microservice is moved to Kubernetes, the early design choice
    developers need to make is where to store these secrets and how to retrieve them
    and make them available in an application as needed without compromising the security
    posture of the application. Following are the top methods to achieve this objective.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一个秘密可以是用于认证和授权用户、组或实体的任何内容。它可以是用户名/密码、API 令牌或TLS 证书。当应用程序或微服务迁移到 Kubernetes
    时，开发人员需要做出的早期设计选择是在哪里存储这些秘密，以及如何检索并在应用程序中根据需要使其可用，而不会 compromis 安全性。以下是实现此目标的主要方法。
- en: etcd to Store Secrets
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: etcd 用于存储秘密
- en: A common scenario for an application moving to Kubernetes is to store a secret
    in a Base64-encoded format in etcd as a key-value pair. Etcd is a supported datastore
    in Kubernetes deployments. These secrets can be made available inside the container
    as a volume mount or an environment variable from within Kubernetes deployment
    specs. Since environment variables are stored in memory, it’s hard to extract
    secrets, compared with volume mounts, which store secrets on a container filesystem.
    The access to etcd is backed by Kubernetes RBAC, which brings needed security
    and flexibility.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序迁移到 Kubernetes 的常见情景是将秘密以 Base64 编码格式存储在 etcd 中作为键值对。Etcd 是 Kubernetes 部署中支持的数据存储。这些秘密可以作为卷挂载或来自
    Kubernetes 部署规范中的环境变量在容器内部提供。由于环境变量存储在内存中，与存储在容器文件系统上的卷挂载相比，提取秘密更加困难。对 etcd 的访问由
    Kubernetes RBAC 支持，带来了所需的安全性和灵活性。
- en: Etcd provides strong concurrency primitives, linearizable reads, and APIs to
    manage secrets at scale. The downside of this approach is secrets are stored in
    plain text (Base64 encoding) and are retrieved and sent in plain text unless etcd
    is configured to encrypt communication using TLS. In [Chapter 2](ch02.xhtml#infrastructure_security),
    you learned the strategy to encrypt data at rest, where secrets can be encrypted
    while they are stored in etcd.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Etcd 提供了强大的并发原语、可线性读取和用于规模化管理秘密的 API。这种方法的缺点是秘密以明文（Base64 编码）存储，并且在没有配置 etcd
    使用 TLS 加密通信的情况下，检索和发送也是以明文进行的。在 [第二章](ch02.xhtml#infrastructure_security) 中，您学习了在数据静止状态下加密数据的策略，其中秘密可以在存储在
    etcd 中时进行加密。
- en: Additionally, secrets stored in etcd are not versioned or recoverable once deleted,
    and access to etcd is not audited, so anyone who has access to etcd can access
    all secrets. Since etcd is a Kubernetes datastore, the broader secrets management
    requirements of the organization are not fulfilled.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在etcd中存储的秘密既不是有版本控制的，也不能在删除后恢复，而且etcd的访问没有经过审计，因此任何有权限访问etcd的人都可以访问所有的秘密。由于etcd是Kubernetes的数据存储，因此无法满足组织更广泛的秘密管理需求。
- en: Secrets Management Service
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秘密管理服务
- en: To solve the organization’s encryption and secrets management requirement, secrets
    management services can be utilized from cloud providers. All major public cloud
    providers provide secrets management services.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决组织的加密和秘密管理需求，可以利用云提供商的秘密管理服务。所有主要的公共云提供商都提供秘密管理服务。
- en: The most popular cloud providers’ secrets management services are [AWS Secrets
    Manager](https://oreil.ly/7tuNL), [Google Secret Manager](https://oreil.ly/JnfOA),
    and [Azure Key Vault](https://oreil.ly/MaMgd).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最流行的云提供商的秘密管理服务有[AWS Secrets Manager](https://oreil.ly/7tuNL)、[Google Secret
    Manager](https://oreil.ly/JnfOA)和[Azure Key Vault](https://oreil.ly/MaMgd)。
- en: A notable third-party example is [HashiCorp Vault](https://oreil.ly/xDMd3),
    which can be used as a centralized secrets manager. It provides many features
    to fulfill an organization’s end-to-end secrets management requirements (key management,
    encryption, rotation, PKI, storage, replication, revocation, logging, monitoring,
    audit, etc.). This tool can be used in conjunction with a cloud provider’s secrets
    management services—for example, when the vault is initialized, initial keys can
    be encrypted and stored into Cloud KMS so that the operator won’t have to handle
    plain-text keys.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一个显著的第三方示例是[HashiCorp Vault](https://oreil.ly/xDMd3)，可以用作集中式秘密管理器。它提供了许多功能来满足组织的端到端秘密管理需求（密钥管理、加密、轮换、PKI、存储、复制、吊销、日志记录、监控、审计等）。例如，当Vault初始化时，初始密钥可以被加密并存储到Cloud
    KMS中，这样操作员就不必处理明文密钥。
- en: Kubernetes Secrets Store CSI Driver
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes秘密存储CSI驱动程序
- en: The secret store [Container Storage Interface (CSI) driver](https://oreil.ly/kOio7)
    integrates external secret stores like Azure, GCP, AWS, and Vault from HashiCorp
    into Kubernetes using CSI, which is generally available since version 1.13.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '[容器存储接口（CSI）驱动程序](https://oreil.ly/kOio7)整合了外部秘密存储，如Azure、GCP、AWS和HashiCorp
    Vault，通过CSI将它们集成到Kubernetes中，自版本1.13以来已普遍可用。'
- en: In a nutshell, the CSI driver authenticates with your secret store service using
    volume attributes and mounts needed secrets into the pod seamlessly. This approach
    avoids the use of the Kubernetes etcd datastore and allows you to scale and manage
    the organization’s secrets effectively.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，CSI驱动程序使用卷属性与您的秘密存储服务进行身份验证，并无缝地将所需的秘密挂载到Pod中。这种方法避免了使用Kubernetes etcd数据存储，并允许您有效地扩展和管理组织的秘密。
- en: Secrets Management Best Practices
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秘密管理最佳实践
- en: Following are the best practices to consider when managing secrets in Kubernetes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在管理Kubernetes中的秘密时，以下是需要考虑的最佳实践。
- en: Avoid secrets sprawl
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 避免秘密扩散
- en: The main motive of secrets management is to avoid secrets sprawl, where your
    application secrets are spread across places like config files, yamls, and Git
    repositories. This is usually a sign of the lack of a secrets management workflow
    in the organization. The only way to mitigate secrets sprawl is to have a centralized
    secrets management strategy in place, one where credentials can be stored and
    retrieved securely from a single point and used by the entire organization with
    proper authorization, logging, and monitoring mechanisms in place.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 秘密管理的主要目标是避免秘密扩散，即应用程序的秘密分散在配置文件、YAML和Git存储库等地方。这通常表明组织缺乏秘密管理工作流程。减少秘密扩散的唯一方法是建立一个集中式秘密管理策略，其中凭证可以安全地存储和检索，并由整个组织在适当的授权、日志记录和监控机制下使用。
- en: Use anti-affinity rules
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用反亲和性规则
- en: Ideally, a secrets management solution should be a single process on a small
    number of dedicated VMs or dedicated hosts. Since you may need to run this solution
    on Kubernetes as a microservice, it will be a process running in a dedicated pod.
    But the issue becomes on which nodes these pods should be running. Here anti-affinity
    helps by distributing pods on required nodes, which are classified to run a secrets
    management solution.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，秘密管理解决方案应该是少量专用虚拟机或专用主机上的单一进程。由于可能需要在Kubernetes上作为微服务运行此解决方案，因此它将作为运行在专用Pod中的进程。但问题在于这些Pod应该在哪些节点上运行。在此，反亲和性有助于将Pod分布在所需节点上，这些节点被分类为运行秘密管理解决方案。
- en: Data encryption (transit and rest)
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据加密（传输和静态）
- en: By default, Kubernetes insecurely stores and transmits secrets. It is paramount
    to configure or have a solution that can use end-to-end TLS encryption where secrets
    are encrypted in transit. At the same time, have a mechanism in place to store
    secrets in encrypted form. See [Chapter 2](ch02.xhtml#infrastructure_security)
    for options on how to achieve this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes不安全地存储和传输秘密。配置或使用能够在传输中使用端到端TLS加密的解决方案至关重要。同时，要有机制来以加密形式存储秘密。请参阅[第2章](ch02.xhtml#infrastructure_security)了解如何实现此目标的选项。
- en: Use automated secret rotation
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用自动化秘密轮换
- en: Organizations follow different time frames for different secrets for rotation,
    but with the advent of automated secret rotation, you can do it daily or even
    on an hourly basis. Cloud secrets management services and external third-party
    solutions both can help to rotate and manage secrets in an automated fashion.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 组织对于不同秘密的轮换采用不同的时间框架，但随着自动化秘密轮换的出现，您可以每天甚至每小时进行轮换。云秘密管理服务和外部第三方解决方案都可以帮助实现自动化的秘密轮换和管理。
- en: Ephemeral or dynamic secret
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 临时或动态秘密
- en: Ephemeral or dynamic secrets are temporary, on-demand generated secrets that
    typically have a short time to live and are destroyed after that time interval.
    These secrets can be made available to the class of the application or to the
    operations team as needed. If a secret is discovered by an attacker (for example,
    if leaked via debug logs, application code, or accidentally exposed via GitHub),
    the secrets would have been changed in a short window of time, protecting applications.
    Additionally, they can help trace the attacker’s footsteps in the infrastructure,
    since it becomes easy to determine the time frame in which the secret was discovered
    by the attacker. HashiCorp Vault and CyberArk Conjur are some of the third-party
    secrets providers that provide such features.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 临时或动态秘密是临时生成的、按需生成的秘密，通常有短暂的生命周期，并在该时间间隔后被销毁。这些秘密可以根据应用程序的类别或运维团队的需要提供。如果攻击者发现秘密（例如通过调试日志、应用程序代码泄露或意外在GitHub上公开），这些秘密将在短时间窗口内被更改，从而保护应用程序。此外，它们还可以帮助追踪基础设施中的攻击者行踪，因为很容易确定攻击者发现秘密的时间范围。HashiCorp
    Vault和CyberArk Conjur是一些提供此类功能的第三方秘密提供者。
- en: Enable audit log
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 启用审计日志
- en: Having an audit log in your secrets management solution provides visibility
    into secrets and their uses by the organization. An audit log can be critical
    for determining intentional or unintentional compromises, the blast radius of
    the attack, and related forensic steps.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的秘密管理解决方案中具有审计日志，可以查看组织中秘密及其使用的可见性。审计日志对于确定意图或无意中的妥协、攻击的影响范围以及相关的取证步骤至关重要。
- en: Store secrets in container memory
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将秘密存储在容器内存中
- en: When a containerized application receives a secret, don’t store the secret on
    disk (or in volumeMount available in the host). Rather, store it in memory so
    that in case of a compromise, those secrets are not easily available to the attacker.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器化应用程序接收到秘密时，不要将秘密存储在磁盘上（或在主机中可用的volumeMount中）。相反，将其存储在内存中，以便在妥协的情况下，这些秘密不易于攻击者获取。
- en: Secret zero problem
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零秘密问题
- en: Many secrets management solutions follow envelope encryption where DEKs are
    protected by a KEK. The KEK is considered secret zero. If an attacker compromises
    the KEK, then they can decrypt the DEK and subsequently the data encrypted by
    the DEK. The combination of cloud providers’ IAM and KMS can be used to help protect
    secret zero. (Though, of course, these in turn effectively have their own secret
    zero further up the trust chain, which you must treat as highly sensitive.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 许多机密管理解决方案采用信封加密，其中 DEK 受 KEK 保护。KEK 被视为零号秘密。如果攻击者破坏了 KEK，则可以解密 DEK，并随后解密 DEK
    加密的数据。云提供商的 IAM 和 KMS 的组合可用于帮助保护零号秘密。（当然，这些实际上也有自己的零号秘密链，必须视为高度敏感。）
- en: Use your Certificate Authority
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用您的证书颁发机构
- en: As part of defense-in-depth, end-to-end TLS implementation can be done using
    a custom Certificate Authority (CA). Here an organization can choose to sign its
    certificate using its own CA. In this case, the service can only be accessed by
    presenting a certificate signed by the organization.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 作为深度防御的一部分，可以使用自定义证书颁发机构 (CA) 实施端到端的 TLS 实现。在这里，组织可以选择使用自己的 CA 签署其证书。在这种情况下，服务只能通过提交组织签署的证书进行访问。
- en: Authentication
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证
- en: Once you are ready with your hardened images, CI/CD pipeline, and secrets management
    strategy, it’s time for Kubernetes’ authentication and authorization strategy.
    Kubernetes allows numerous authentication mechanisms; in simplest form; authentication
    is done with certificates, tokens, or basic authentication (username and password).
    Additionally, webhooks can be used to verify bearer tokens, and external OpenID
    providers can be integrated.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您准备好强化您的镜像、CI/CD 管道和机密管理策略，就是 Kubernetes 的认证和授权策略的时候了。Kubernetes 允许多种身份验证机制；在最简单的形式中，认证可以使用证书、令牌或基本身份验证（用户名和密码）完成。此外，可以使用
    Webhook 验证持有者令牌，并集成外部 OpenID 提供商。
- en: Let’s take a closer look at each authentication method available in Kubernetes.
    Configuration for authentication methods is out of scope for this book.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看 Kubernetes 中可用的每种身份验证方法。身份验证方法的配置超出本书的范围。
- en: X509 Client Certificates
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: X509 客户端证书
- en: There are two ways to sign a client certificate so that it can be used to authenticate
    with the Kubernetes API. First is internally signing the certificate using the
    Kubernetes API. It involves the creation of a certificate signing request (CSR)
    by a client. Administrators can approve or deny the CSR. Once approved, the administrator
    can extract and provide a signed certificate to the requesting client or user.
    This method cannot be scaled for large organizations as it requires manual intervention.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种签署客户端证书的方法，以便用于与 Kubernetes API 进行身份验证。首先是通过 Kubernetes API 内部签署证书。这涉及客户端创建证书签署请求
    (CSR)。管理员可以批准或拒绝 CSR。一旦批准，管理员可以提取并提供签署后的证书给请求的客户端或用户。由于这种方法需要手动干预，无法为大型组织提供规模化支持。
- en: The second method is to use enterprise PKI, which can sign the client-submitted
    CSR. Additionally, the signing authority can send signed certificates back to
    clients. This approach requires the private key to be managed by an external solution.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用企业 PKI，它可以签署客户端提交的 CSR。此外，签署授权机构可以将签署后的证书发送回客户端。这种方法要求外部解决方案管理私钥。
- en: Bearer Token
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持有者令牌
- en: Kubernetes service accounts use bearer tokens to authenticate with Kubernetes
    API. The simplest way to use a bearer token is to create a new service account.
    Kubernetes API automatically issues a random token associated with the service
    account, which can be retrieved and used to authenticate that account.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 服务账户使用持有者令牌与 Kubernetes API 进行身份验证。使用持有者令牌的最简单方式是创建一个新的服务账户。Kubernetes
    API 自动分配与服务账户关联的随机令牌，可以检索并用于验证该账户。
- en: Bearer tokens can be verified using a webhook, which involves API configuration
    with option `--authentication-token-webhook-config-file`, which includes the details
    of the remote webhook service.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 Webhook 验证持有者令牌，这涉及使用选项 `--authentication-token-webhook-config-file` 配置
    API，并包含远程 Webhook 服务的详细信息。
- en: Kubernetes internally uses Bootstrap and Node authentication tokens to initialize
    the cluster. Also, there'’s a less secure option available using a static token
    file that can be provided using the `--token-auth-file` option while configuring
    Kubernetes API.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 内部使用引导和节点认证令牌初始化集群。此外，还可以使用静态令牌文件的较不安全选项，在配置 Kubernetes API 时使用 `--token-auth-file`
    选项提供。
- en: OIDC Tokens
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OIDC 令牌
- en: The [OpenID Connect protocol](https://oreil.ly/8t476) is built by expanding
    the existing OAuth2 protocol. Kubernetes does not provide an OpenID Connect identity
    provider. You can use identity providers like Google or Azure or run your own
    identity provider using [dex](https://oreil.ly/Rd2sg), [keycloak](https://oreil.ly/ah3IY),
    or [UAA](https://oreil.ly/oMhzC). These external identity providers can easily
    be integrated with your authentication workflows as required, as well as support
    native identity provider capabilities (e.g., enterprise using lightweight directory
    access protocol).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[OpenID Connect 协议](https://oreil.ly/8t476) 是通过扩展现有的 OAuth2 协议构建的。Kubernetes
    不提供 OpenID Connect 身份提供者。您可以使用 Google 或 Azure 等身份提供者，或者使用 [dex](https://oreil.ly/Rd2sg)、[keycloak](https://oreil.ly/ah3IY)
    或 [UAA](https://oreil.ly/oMhzC) 运行自己的身份提供者。这些外部身份提供者可以根据需要轻松集成到您的认证工作流中，并支持原生身份提供者功能（例如，使用轻量目录访问协议的企业）。'
- en: Authentication Proxy
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证代理
- en: A proxy can be used to establish a trust connection with Kubernetes API. Kubernetes
    API can identify users from request headers such as X-Remote-User, which is set
    by authentication proxy as it authenticates users on behalf of the Kubernetes
    API. Authentication proxy can authenticate users as needed according to your workflow.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用代理与 Kubernetes API 建立信任连接。Kubernetes API 可以通过请求头（如由认证代理设置的 X-Remote-User）识别用户，认证代理会代表
    Kubernetes API 对用户进行身份验证。认证代理可以根据工作流程需要进行用户身份验证。
- en: Anonymous Requests
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名请求
- en: If a request to Kubernetes API is not rejected by any configured authentication
    method, then it is treated as an anonymous request (i.e., a request without a
    bearer token).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对 Kubernetes API 的请求未被任何配置的认证方法拒绝，则将其视为匿名请求（即没有承载令牌的请求）。
- en: It is important to note that for Kubernetes version 1.6 and above, anonymous
    access is enabled by default for an authorization mode other than `AlwaysAllow`.
    It can be disabled by adding the option `--anonymous-auth=false` while configuring
    Kubernetes API.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Kubernetes 版本 1.6 及以上，需要注意，默认情况下启用了匿名访问，但不包括 `AlwaysAllow` 授权模式。在配置 Kubernetes
    API 时，可以通过添加选项 `--anonymous-auth=false` 来禁用匿名访问。
- en: User Impersonation
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户冒充
- en: This is a subtle authentication mechanism where a user with certain access to
    Kubernetes can impersonate another user by setting additional headers in the request
    to Kubernetes API with the details of the impersonated user.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种微妙的认证机制，通过在请求到 Kubernetes API 中设置额外的头部信息，具有对 Kubernetes 的某些访问权限的用户可以冒充另一个用户。
- en: This mechanism allows Kubernetes API to process requests as per the impersonated
    user’s privileges and context. Additionally, Kubernetes API can log who has impersonated
    whom and other relevant details from a request as necessary, which can be useful
    during monitoring and audit.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此机制允许 Kubernetes API 根据被冒充用户的权限和上下文处理请求。此外，Kubernetes API 还可以记录谁冒充了谁以及来自请求的其他相关细节，这在监控和审计过程中可能很有用。
- en: Authorization
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 授权
- en: In this section we will cover available authorization methods, RBAC in Kubernetes,
    namespaced RBAC, and caveats.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖可用的授权方法、Kubernetes 中的 RBAC、命名空间 RBAC 和注意事项。
- en: Kubernetes has multiple authorization mechanisms such as Node, ABAC, RBAC, and
    AlwaysDeny/AlwaysAllow, though RBAC is the industry standard in Kubernetes.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 具有多种授权机制，如节点、ABAC、RBAC 和 AlwaysDeny/AlwaysAllow，其中 RBAC 是 Kubernetes
    的行业标准。
- en: Node
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 节点
- en: Node authorization is used by Kubernetes internally. It’s a special-purpose
    authorization mode that specifically authorizes API requests made by kubelets.
    It enables read, write, and auth-related operations by kubelet. In order to successfully
    make a request, kubelet must use a credential that identifies it as being in the
    system:nodes group.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 节点授权由 Kubernetes 在内部使用。它是一种专用授权模式，专门授权 kubelet 发出的 API 请求。它使 kubelet 可以进行读取、写入和与认证相关的操作。为了成功发出请求，kubelet
    必须使用标识其属于 system:nodes 组的凭据。
- en: ABAC
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ABAC
- en: Kubernetes defines attribute-based access control (ABAC) as “an access control
    paradigm whereby access rights are granted to users through the use of policies
    which combine attributes together.” ABAC can be enabled by providing a *.json*
    file to `--authorization-policy-file` and `--authorization-mode=ABAC` options
    in Kubernetes API configurations. The .*json* file needs to be present before
    Kubernetes API can be invoked.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 将属性基于访问控制（ABAC）定义为“一种通过将属性组合在一起来授予用户访问权限的访问控制范式”。可以通过在 Kubernetes
    API 配置中提供 *.json* 文件，并使用 `--authorization-policy-file` 和 `--authorization-mode=ABAC`
    选项来启用 ABAC。在调用 Kubernetes API 之前，需要存在 *.json* 文件。
- en: AlwaysDeny/AlwaysAllow
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: AlwaysDeny/AlwaysAllow
- en: The  AlwaysDeny  or  AlwaysAllow  authorization  mode  is  usually  used  in 
    development  environments  where  all  requests  to  the  Kubernetes  API  need 
    to  be  allowed  or denied. AlwaysDeny or AlwaysAllow mode can be enabled using
    option `--authorization-mode=AlwaysDeny/AlwaysAllow` while configuring Kubernetes
    API. This mode is considered insecure and hence is not recommended in production
    environments.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: AlwaysDeny 或 AlwaysAllow 授权模式通常用于开发环境，其中需要允许或拒绝对 Kubernetes API 的所有请求。在配置 Kubernetes
    API 时，可以使用选项 `--authorization-mode=AlwaysDeny/AlwaysAllow` 启用 AlwaysDeny 或 AlwaysAllow
    模式。这种模式被认为是不安全的，因此不建议在生产环境中使用。
- en: RBAC
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RBAC
- en: Role-based access control is the most secure and recommended authorization mechanism
    in Kubernetes. It is an approach to restrict system access based on the roles
    of users within your cluster. It allows organizations to enforce the principle
    of least privileges. Kubernetes RBAC follows a declarative nature with clear permissions
    (operations), API objects (resources), and subjects (users, groups, or ServiceAccounts)
    declared in authorization requests. Applying an RBAC in Kubernetes is a two-step
    process. First is to create a Role or ClusterRole. The latter is a global object
    where the former is a namespace object. A Role or ClusterRole is made up of verbs,
    resources, and subjects, which provide a capability (verb) on a resource, as shown
    in [Figure 3-6](#kubernetes_role_and_role_binding). The second step is to create
    a ClusterRoleBinding where the privileges defined in step 1 are assigned to the
    user or group.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 基于角色的访问控制是 Kubernetes 中最安全和推荐的授权机制。这是一种根据集群中用户角色限制系统访问的方法。它允许组织强制执行最小权限原则。Kubernetes
    RBAC 遵循声明性的性质，具有明确的权限（操作）、API 对象（资源）和主体（用户、组或 ServiceAccounts）在授权请求中声明。在 Kubernetes
    中应用 RBAC 是一个两步过程。第一步是创建一个 Role 或 ClusterRole。后者是一个全局对象，而前者是一个命名空间对象。一个 Role 或
    ClusterRole 由动词、资源和主体组成，提供了对资源的能力（动词），如 [图 3-6](#kubernetes_role_and_role_binding)
    所示。第二步是创建一个 ClusterRoleBinding，将第一步中定义的权限分配给用户或组。
- en: Let’s take an example where a dev-admins group needs to have read access to
    all the secrets in the cluster. Step 1 is to create a ClusterRole secret-reader,
    which allows the reading of the secrets via various operations (get, list), and
    step 2 is binding it to a subject (i.e., users, groups, or ServiceAccounts) to
    provide access. In this case the group dev-admins allows group users to read secrets
    globally.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子，假设一个 dev-admins 组需要对集群中的所有秘密进行读取访问。第一步是创建一个 ClusterRole secret-reader，允许通过各种操作（get、list）读取秘密，第二步是将其绑定到一个主体（即用户、组或
    ServiceAccounts）以提供访问权限。在这种情况下，组 dev-admins 允许组用户全局读取秘密。
- en: '[Figure 3-6](#kubernetes_role_and_role_binding) is an example of how you can
    create a ClusterRole that allows you to define access to resources. The example
    on the right shows how you can bind the ClusterRole to a group of users.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-6](#kubernetes_role_and_role_binding) 是一个示例，展示了如何创建一个允许您定义对资源访问权限的 ClusterRole。右侧的示例展示了如何将
    ClusterRole 绑定到一组用户。'
- en: '![](Images/ksao_0306.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ksao_0306.png)'
- en: Figure 3-6\. Kubernetes role and role binding
  id: totrans-156
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-6\. Kubernetes 角色和角色绑定
- en: '[Figure 3-7](#rbac_for_kubernetes_resources) shows an overview of RBAC; you
    can use any combination of operation, resource, or subject as required.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 3-7](#rbac_for_kubernetes_resources) 显示了 RBAC 的概述；您可以根据需要使用任何操作、资源或主体的组合。'
- en: Apart from these resources, there are Kubernetes nonresources like /healths
    or /version APIs that can be controlled using RBAC as well if needed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些资源外，还有 Kubernetes 的非资源，如 /healths 或 /version API，如果需要的话也可以使用 RBAC 进行控制。
- en: '![](Images/ksao_0307.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](Images/ksao_0307.png)'
- en: Figure 3-7\. RBAC for Kubernetes resources
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 3-7\. Kubernetes 资源的 RBAC
- en: Namespaced RBAC
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间 RBAC
- en: In earlier examples you saw an RBAC that was applied globally in the cluster.
    It is possible to apply a similar RBAC to namespaces where resources within a
    namespace can be subject to this RBAC policy. The namespaced resources Role and
    RoleBinding should be used for configuring a namespace policy.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，您看到了一个在集群中全局应用的 RBAC。可以将类似的 RBAC 应用于资源所在的命名空间，使命名空间内的资源受到此 RBAC 策略的约束。应使用命名空间资源
    Role 和 RoleBinding 来配置命名空间策略。
- en: 'There are few caveats you should be aware of while using namespaced RBAC:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用命名空间 RBAC 时，有一些注意事项需要注意：
- en: Roles and RoleBindings are the only namespaced resources.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色和角色绑定是唯一的命名空间资源。
- en: ClusterRoleBindings (global resource) cannot be used with Roles, which is a
    namespaced resource.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ClusterRoleBindings（全局资源）不能与 Role（命名空间资源）一起使用。
- en: RoleBindings (namespaced resource) cannot be used with ClusterRoles, which are
    global resources.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 角色绑定（命名空间资源）不能与全局资源集群角色一起使用。
- en: Only ClusterRoles can be aggregated.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有集群角色可以进行聚合。
- en: Privilege Escalation Mitigation
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提权缓解
- en: 'Kubernetes RBAC reduces an attacker’s ability to escalate their own privileges
    by editing roles or role bindings. This behavior is enforced at the API level
    in Kubernetes and even applies when the RBAC authorizer is not in use:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes RBAC 减少了攻击者通过编辑角色或角色绑定来提升自己权限的能力。这种行为在 Kubernetes 的 API 级别上强制执行，即使
    RBAC 授权器未被使用时也适用：
- en: If user user-no-secret doesn’t have the ability to list secrets cluster-wide,
    they cannot create a ClusterRole or ClusterRoleBinding containing that permission.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果用户 user-no-secret 没有能力在整个集群中列出秘密，他们将无法创建包含该权限的集群角色或集群角色绑定。
- en: 'For user user-no-secret to get a list of secret privileges, they will need
    one of the following:'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于用户 user-no-secret 要获取秘密权限列表，他们将需要以下其中一种：
- en: Grant them a role that allows them to create/update Roles, ClusterRoles, RoleBindinsg,
    or ClusterRoleBindings.
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予他们一个允许他们创建/更新角色、集群角色、角色绑定或集群角色绑定的角色。
- en: Provide them explicit permission with the verb escalate on these resources.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为他们在这些资源上提供显式的提权权限。
- en: Conclusion
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: 'In this chapter we covered the following key concepts that will help you understand
    security tools and best practices to build and deploy workloads:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了以下关键概念，这些概念将帮助您理解安全工具和构建部署工作负载的最佳实践：
- en: It is insufficient to use available base images from Docker as they are for
    your containers; you must spend time ensuring that your container images are hardened
    and built with security in mind. Just like in software development, finding vulnerabilities
    at build time is far cheaper than finding vulnerabilities after software is deployed.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用 Docker 提供的基础镜像是不够的，因为它们只是为您的容器提供。您必须花时间确保您的容器镜像经过硬化并考虑了安全性。就像在软件开发中一样，构建时发现漏洞比部署后发现漏洞要便宜得多。
- en: There are several ways to add image scanning to your CI/CD process. We explored
    various well-known approaches like registry scan, build time or inline scan, and
    using Kubernetes admission controller to help you add image scanning to your CI/CD
    pipelines. We also looked at securing CI/CD pipelines and adding organization
    policy to effectively craft a workflow for your organization.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有几种方法可以将图像扫描添加到您的 CI/CD 过程中。我们探讨了像注册表扫描、构建时或内联扫描以及使用 Kubernetes 准入控制器等多种知名方法，帮助您将图像扫描添加到您的
    CI/CD 流水线中。我们还讨论了保护 CI/CD 流水线并添加组织策略，有效地为您的组织制定工作流程。
- en: We covered the approaches and best practices to secret management.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了秘密管理的方法和最佳实践。
- en: Finally, we covered available Kubernetes authentication and authorization mechanisms.
    We recommend you use RBAC to mitigate privilege escalation.
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们涵盖了可用的 Kubernetes 认证和授权机制。我们建议您使用 RBAC 来减少提权风险。
