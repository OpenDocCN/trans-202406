- en: Chapter 3\. Workload Deployment Controls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With contributions from Manoj Ahuje,
  prefs: []
  type: TYPE_NORMAL
- en: Senior Threat Intelligence Research Engineer at Tigera
  prefs: []
  type: TYPE_NORMAL
- en: Once you decide on a strategy for infrastructure security, next in line is workload
    deployment controls. In this chapter we will look at image building and scanning
    strategy, CI/CD (integrating image scanning into builds), and Kubernetes role-based
    access control (RBAC), which is a widely used authorization system that allows
    you to define access control based on user roles, and secrets management for your
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Image Building and Scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will explore best practices for image building and scanning.
    These include choosing a base image to reduce attack surface and using scratch
    images and image hardening best practices to deter adversaries. Image scanning
    dives into the nuances of choosing an image scanning solution, privacy concerns,
    and an overview of container threat analysis solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Choice of a Base Image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in the previous chapter, you can choose modern Linux distributions
    like Bottlerocket as base images for containers. The minimal version of traditional
    Linux distributions, like Ubuntu, Red Hat, and Alpine, are available too.
  prefs: []
  type: TYPE_NORMAL
- en: Though it’s a good starting point to begin with a minimal image, the minimal
    image approach doesn’t stop vulnerabilities being discovered in OS packages that
    are present in the OS. In this case distroless or scratch images turn out to be
    a better option. These types of images only contain the application and its specific
    runtime dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the benefits of distroless or scratch images:'
  prefs: []
  type: TYPE_NORMAL
- en: This strategy reduces size, attack surface, and vulnerabilities significantly,
    which results in better security posture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distroless images are production ready. Kubernetes itself uses distroless images
    for various components like kublet, scheduler, etc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In case you are going for a scratch base image for your application, a multistage
    Dockerfile can be used to build a scratch image. The first stage involves building
    your application. The second stage involves moving runtime dependencies and applications
    to scratch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most popular example of a distroless image project is [distroless from Google](https://oreil.ly/UIzu0),
    which provides images for various runtimes like Java, Python, or C++.
  prefs: []
  type: TYPE_NORMAL
- en: A scratch image starts with the Dockerfile instruction FROM:scratch, which signifies
    an empty filesystem. The following instruction in Dockerfile creates the first
    filesystem layer of the container image. Here, the first filesystem layer needs
    to be compiled with the application and dependencies. Since it’s nonproductive
    and nonintuitive to build applications outside of the container, Docker introduced
    [multistage builds](https://oreil.ly/K161o). With a multistage build, multiple
    FROM instructions are allowed in a Dockerfile. Each FROM instruction creates a
    separate stage, and the filesystem artifact from a previous stage can be copied
    in a later stage of the build. This mechanism enabled developers to build and
    compile applications in an earlier stage (builder image) with all dependencies
    available, and eventually only copy the filesystem artifacts required to run the
    production application in a later stage. The last stage of the build can be a
    scratch image where only application binaries and dependencies are required to
    be present on the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: Following is an example of a scratch-based image for a bash script, where the
    goal is to run a script within a container. Here you can create a two-stage Dockerfile
    where the second stage is a scratch image containing only the dependencies for
    the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this template to containerize even complex applications built with
    Node.js, Python, and Go. Go additionally provides an option to compile all the
    runtime libraries into the binary. In the following example, you can use Alpine
    as the base image to construct a scratch image for a container that runs a script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have reviewed how to choose a base image for your container, let’s
    explore container image hardening.
  prefs: []
  type: TYPE_NORMAL
- en: Container Image Hardening
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Container image hardening is the process of building images to reduce security
    weaknesses and attack surface. At the same time, it is used to add defensive layers
    to run applications securely within the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a nonhardened container image, it can be prone to abuse, information
    disclosure, or easier privilege escalation to the container host. You should leverage
    the following tools and best practices to build hardened container images for
    your applications:'
  prefs: []
  type: TYPE_NORMAL
- en: Only use base images from trusted sources, such as official Ubuntu and Red Hat
    release channels, and double-check the image hash with released information, as
    it’s relatively easy to embed malicious code like cryptominers into an image and
    make that image available on a repository like Docker Hub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize your base images to only contain runtime dependencies for your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Follow the principle of least privilege access and run containers with the minimum
    required permissions. For example, run containers as nonroot unless root privileges
    are necessary. This makes it difficult for the attackers to escape the container
    and provides protection from vulnerabilities like *[CVE-2020-15257](https://oreil.ly/txXJL)*,
    where the root user was able to escape the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use tags for Docker images; rather, pin the base image version in the
    Dockerfile (i.e., ubuntu:20.08). Mutable tags like *latest* or *master* are updated
    constantly with features and fixes, which can cause issues while scanning images
    as a part of your CI/CD pipeline. Additionally, they can cause stability issues
    for an application (where the underlying dependant library is updated/removed
    or changed).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compress Docker image layers into one single layer. Container images built with
    tools like Docker or buildah often have multiple layers. These layers show a development
    history and sometimes end up leaking sensitive information. The best way to compress
    existing layers is to use a multistage build; there is also an experimental Docker
    feature (i.e., option [`--squash`](https://oreil.ly/U5RaL) available in Docker
    API 1.25+).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use container image signing to trust the image. Natively, Kubernetes doesn’t
    have container image verification. Docker Notary can be used to sign images, and
    by using the Kubernetes admission controller, it is possible to verify an image
    signature and determine if an image was tampered with by a malicious actor (e.g.,
    if the image is changed while it is seated at the registry).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will review container image scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Container Image Scanning Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Container image scanning tools examine the container filesystem to get the
    metadata to know if there are vulnerable components present in the image. There
    are many open source and commercial enterprise solutions available in the market
    that you can use for this purpose. They come with CI/CD integrations and a rich
    set of scanning features. The solution you choose should answer some of these
    basic questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Can the image scanner scan OS packages present in a container image for your
    selected base image?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can it scan your application dependencies (does it understand languages used
    by your application, e.g., Go, Python, Node.js)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can the image scanner detect sensitive files present in the filesystem (certificates,
    passwords)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is the false positive rate?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can it scan binaries (.elf or .exe)?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What data will be collected by the scanning solution? Does the scanning solution
    upload your image to its SaaS service, or does the solution only collect package
    metadata? It is important to understand this due to the risk of data exposure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where will the collected data be stored? On-prem or cloud SaaS? Please review
    this and choose the option that works with the guidelines set by your security/compliance
    teams.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does the image scanner have an integration with your CI/CD system?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most scanners collect metadata from filesystems and try to match it with vulnerability
    information gathered from sources such as the National Vulnerability Database
    or private intelligence sources to determine the presence of vulnerability. Please
    note that you should expect both false positives and negatives as a part of scanning.
    For images with confirmed vulnerabilities, the application and the security team
    need to work together to analyze the impact and the risk of the CVE to your operation.
    Remediation steps involve implementing workarounds and patching the image when
    an update is available.
  prefs: []
  type: TYPE_NORMAL
- en: Many public cloud providers and container registry service providers offer container
    scanning services. However, there are limitations to the OS versions they support,
    and most of them don’t scan application dependencies. Here the open source world
    has more to offer. Notable examples of open source tools that can scan application
    dependencies are [Anchore](https://oreil.ly/QNdyU), which lets users define policy,
    and [Trivy](https://oreil.ly/CYP4B), which is easy to integrate in CI.
  prefs: []
  type: TYPE_NORMAL
- en: Privacy Concerns
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Security vulnerabilities and associated information in your product is highly
    classified data, and in the wrong hands it could be a big liability to the organization.
    That’s why before you choose any solution, it’s good practice to verify what data
    is being collected by a scanning solution and where that data is stored (e.g.,
    within the enterprise on-premise or in the cloud as a part of an SaaS service).
    If you are buying a commercial solution, it is important to check the contract
    to know the clauses for damages in case of data breach. Often these clauses can
    help you understand how serious an organization is about data security. In case
    you are using an open source solution, please review the documentation to understand
    the risks of data leakage.
  prefs: []
  type: TYPE_NORMAL
- en: Container Threat Analysis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to traditional image scanning, the area of container threat analysis
    using sandbox-based solutions is gaining popularity. It is a relatively new area,
    and we recommend you watch it. These sandbox-based solutions can run Docker images
    and monitor for container system calls, processes, memory, network traffic (HTTP,
    DNS, SSL, TCP), and overall behavior of the container, using machine learning
    and other techniques to determine any malicious activity. Additionally, they can
    scan container filesystems to check for vulnerabilities as well as malicious binaries.
    These can be used to detect advanced persistent threats (APTs) and malware.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will cover various strategies to integrate image scanning
    solutions into your CI/CD pipeline, best practices to secure your CI/CD pipelines,
    and techniques to implement organizational policies for CI/CD and vulnerability
    scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration (CI) is a development practice in which each developer’s
    check-in is verified by an automated build, allowing teams to detect problems
    early. And continuous deployment (CD) is the extension of CI where changes are
    released for downstream consumers once they pass all release checks.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating security at each step of the development and release process is
    the goal of CI/CD, which is an integral part of shift-left strategy in DevOps
    processes. By integrating image scanning into your CI/CD pipeline (see [Figure 3-1](#integrating_image_scanning_into_the_cis)),
    development teams can have a verdict available as soon as a check-in from a developer
    is committed to the repository. The main advantage of this approach is that new
    security vulnerabilities or threats can be detected at build time. Once an issue
    is found, all stakeholders and DevOps teams can be notified, typically by failing
    the CI job. Then respective teams can start working on remediation immediately.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ksao_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Integrating image scanning into the CI/CD process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As shown in [Figure 3-1](#integrating_image_scanning_into_the_cis), the scanning
    should be integrated at each step of the development cycle, from the developer
    check-in to continuous delivery to production. The rest of this section will be
    focused on the CI part of the integration to show the granularity of the image
    scanning process. The following strategies can be applied to each step shown in
    [Figure 3-1](#integrating_image_scanning_into_the_cis) (i.e., code, build [CI],
    and CD pipeline).
  prefs: []
  type: TYPE_NORMAL
- en: The choice of the specific CI/CD build infrastructure is secondary and can be
    chosen according to wider requirements. Popular CI/CD providers include but are
    not limited to [Jenkins](https://oreil.ly/ge9Q1), [Semaphore](https://oreil.ly/xpiFH),
    and [CircleCI](https://circleci.com). There are four main ways to integrate image
    scanning into your CI/CD pipeline and build infrastructure, as shown in [Figure 3-2](#image_scanning_integrated_as_a_part_of).
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ksao_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Image scanning integrated as a part of the image registry
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Scan Images by Registry Scanning Services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As illustrated in [Figure 3-2](#image_scanning_integrated_as_a_part_of), in
    this approach as soon as a check-in is available from the developer, CI builds
    and pushes images to the registry. Then images are periodically scanned by the
    services integrated within the registry. There are many downsides to this approach;
    registry providers usually limit themselves to scanning the operating system package
    layer (e.g., GCR and Quay). Since they show limited information, using vulnerability
    whitelisting, classification, and tracking timelines to fix various issues can
    be really cumbersome. Also, most of the time there is no option to write policy
    tailored to your organization’s needs.
  prefs: []
  type: TYPE_NORMAL
- en: When the image scanner finds an issue, the image may have already been consumed
    or delivered using CD. The registry doesn’t keep track of which consumed images
    consumed and who deployed them. Users using those images may be at risk of compromise
    and not even know about the vulnerabilities identified by the registry scanning
    service. Vulnerability remediation only comes after notification, which can be
    an alert or email to the development team and other stakeholders. It can be anything
    from a simple update from the upstream provider to complex code and a configuration
    fix. This kind of remediation effort tends to lag behind the development process.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-3](#image_scanning_as_a_part_of_the_build_p) shows how images are
    built and scanned as a part of the CI process, but images are pushed to the internal
    registry without considering a verdict from the scanner. If you are an agile DevOps
    team, you may be building and pushing images to your internal registry every day
    or every hour as soon as a check-in is available on multiple branches. In this
    case, you don’t want every build to be failing as a part of CI if there is a vulnerability
    present in the image. Rather, you would get a notification for a vulnerability,
    and the developer can fix that vulnerability before CD kicks in.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ksao_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Image scanning as a part of the build process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Scan Images After Builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The drawback of the approach is that even though every image is scanned right
    after it is built, there is no mechanism to force developers to fix found issues
    immediately. Additionally, images are available for internal consumption from
    the registry even if vulnerability is detected, and therefore it could be a weak
    link in the organization, which can lead to the compromise.
  prefs: []
  type: TYPE_NORMAL
- en: As illustrated in [Figure 3-4](#image_scanning_inline_as_a_part_of_the), a CI
    job kicks in with a check-in from the developer, which builds and subsequently
    scans the images. Once the scan is complete, a verdict from the image scanner
    is evaluated. If it passes, then images are pushed to the registry for internal
    consumption. If it fails, the developer needs to remediate the issue immediately,
    as they won’t have the latest build available with their changes.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ksao_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Image scanning inline as a part of the CI/CD process
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Inline Image Scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pipeline can be difficult to manage initially, depending on the size and
    velocity of your organization, but once it is mastered, the organization gets
    much better control over its security posture. The same pipeline design can be
    utilized in your CD jobs so that your applications are the most secure at the
    time of release/deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes admission controllers can intercept pod creation requests from the
    Kubernetes API (see [Figure 3-5](#_image_scanning_as_a_part_of_pod_creati)). This
    mechanism can be used as a last-minute check by triggering a CI job to scan an
    image that is being deployed on the cluster. Depending on the verdict of the scan,
    the admission controller can admit or kick out the pod.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ksao_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Image scanning as a part of pod creation
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kubernetes Admission Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This method usually needs a custom or off-the-shelf admission controller that
    is able to talk to admission servers that respond with a verdict for the scan
    performed. From a fault tolerance point of view, it’s worth noting that if the
    admission server fails for some reason, then it can impact pod creation in the
    entire cluster. Whether you want the admission controller to “fail open” (i.e.,
    go ahead with pod creation) or “fail close” (i.e., prevent all pod creation) in
    the event of admission server failure is the organization’s decision; weigh the
    security risks against the fault tolerance risks.
  prefs: []
  type: TYPE_NORMAL
- en: Since admission controllers are a last-minute check, usually development teams
    are unaware of the found security vulnerabilities until they look at what is being
    scanned and rejected at the moment. So it is recommended that this approach be
    used in combination with earlier methods as a part of your defense strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the CI/CD Pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI/CD pipelines’ autonomous nature and minimum human interaction makes CI/CD
    an attractive target for attackers. Additionally, the development environment
    can be overly permissive with a minimum focus on security. Following are the best
    practices to secure your CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Zero-trust policy for CI/CD environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every connection to and from your CI/CD pipeline needs to be scrutinized with
    a zero-trust policy in place for underlying hosts, infrastructure, and any supporting
    processes according to your threat model. This will ensure that egress and ingress
    access to the CI/CD pipeline is managed through a secure policy.
  prefs: []
  type: TYPE_NORMAL
- en: Secure secrets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Review each secret required by your CI/CD pipeline and make sure passwords,
    access tokens, and encryption keys are called only when required. The design of
    secrets management needs to consider fine-grained access to secrets, secret usage
    and changelog capabilities, automated secret rotation, and deactivation and deprecation.
    We will discuss more about secrets management in the upcoming section of this
    chapter to help you choose the right strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Access control
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tight access control to CI/CD resources and the separation of user responsibilities
    is the key to a secure CI/CD pipeline, whether you have a role-based, time-based,
    or task-based approach. Access control needs to segment the access to the pipeline
    so that in case of compromise, the blast radius is reduced significantly. Also,
    use a strong authentication mechanism with two-factor authentication enabled by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: Audit and monitoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Access to CI/CD resources needs continuous auditing and monitoring to determine
    excessive access, access deprecation in case a user leaves the organization or
    changes job roles, abuse, or suspicious user behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Organization Policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To tackle challenges presented by CI/CD pipelines and scanning, a global organization
    policy is required. The policy needs to call out access requirements to CI/CD
    resources, separation of user responsibilities, secret management, logging and
    monitoring requirements, and audit policy.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability scans can overwhelm teams initially. Hence, development, DevOps,
    and security teams need clear directives on product vulnerability discovery and
    assessment, risk, remediation, and timelines to close the issues based on the
    organization’s threat model.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerability scanning solutions can have codified policies where images can
    be admitted or rejected based on scan results and the risk tolerance of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: The process to build an effective policy needs to be iterative and based on
    continuous feedback to achieve a tailored policy, balancing security and performance
    according to your industry, size, workflows, and compliance requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A secret can be anything that is used to authenticate and authorize users, groups,
    or entities. It can be a username/passwords, API token, or TLS certificate. When
    an application or microservice is moved to Kubernetes, the early design choice
    developers need to make is where to store these secrets and how to retrieve them
    and make them available in an application as needed without compromising the security
    posture of the application. Following are the top methods to achieve this objective.
  prefs: []
  type: TYPE_NORMAL
- en: etcd to Store Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common scenario for an application moving to Kubernetes is to store a secret
    in a Base64-encoded format in etcd as a key-value pair. Etcd is a supported datastore
    in Kubernetes deployments. These secrets can be made available inside the container
    as a volume mount or an environment variable from within Kubernetes deployment
    specs. Since environment variables are stored in memory, it’s hard to extract
    secrets, compared with volume mounts, which store secrets on a container filesystem.
    The access to etcd is backed by Kubernetes RBAC, which brings needed security
    and flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: Etcd provides strong concurrency primitives, linearizable reads, and APIs to
    manage secrets at scale. The downside of this approach is secrets are stored in
    plain text (Base64 encoding) and are retrieved and sent in plain text unless etcd
    is configured to encrypt communication using TLS. In [Chapter 2](ch02.xhtml#infrastructure_security),
    you learned the strategy to encrypt data at rest, where secrets can be encrypted
    while they are stored in etcd.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, secrets stored in etcd are not versioned or recoverable once deleted,
    and access to etcd is not audited, so anyone who has access to etcd can access
    all secrets. Since etcd is a Kubernetes datastore, the broader secrets management
    requirements of the organization are not fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets Management Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To solve the organization’s encryption and secrets management requirement, secrets
    management services can be utilized from cloud providers. All major public cloud
    providers provide secrets management services.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular cloud providers’ secrets management services are [AWS Secrets
    Manager](https://oreil.ly/7tuNL), [Google Secret Manager](https://oreil.ly/JnfOA),
    and [Azure Key Vault](https://oreil.ly/MaMgd).
  prefs: []
  type: TYPE_NORMAL
- en: A notable third-party example is [HashiCorp Vault](https://oreil.ly/xDMd3),
    which can be used as a centralized secrets manager. It provides many features
    to fulfill an organization’s end-to-end secrets management requirements (key management,
    encryption, rotation, PKI, storage, replication, revocation, logging, monitoring,
    audit, etc.). This tool can be used in conjunction with a cloud provider’s secrets
    management services—for example, when the vault is initialized, initial keys can
    be encrypted and stored into Cloud KMS so that the operator won’t have to handle
    plain-text keys.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets Store CSI Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The secret store [Container Storage Interface (CSI) driver](https://oreil.ly/kOio7)
    integrates external secret stores like Azure, GCP, AWS, and Vault from HashiCorp
    into Kubernetes using CSI, which is generally available since version 1.13.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, the CSI driver authenticates with your secret store service using
    volume attributes and mounts needed secrets into the pod seamlessly. This approach
    avoids the use of the Kubernetes etcd datastore and allows you to scale and manage
    the organization’s secrets effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets Management Best Practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following are the best practices to consider when managing secrets in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid secrets sprawl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The main motive of secrets management is to avoid secrets sprawl, where your
    application secrets are spread across places like config files, yamls, and Git
    repositories. This is usually a sign of the lack of a secrets management workflow
    in the organization. The only way to mitigate secrets sprawl is to have a centralized
    secrets management strategy in place, one where credentials can be stored and
    retrieved securely from a single point and used by the entire organization with
    proper authorization, logging, and monitoring mechanisms in place.
  prefs: []
  type: TYPE_NORMAL
- en: Use anti-affinity rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ideally, a secrets management solution should be a single process on a small
    number of dedicated VMs or dedicated hosts. Since you may need to run this solution
    on Kubernetes as a microservice, it will be a process running in a dedicated pod.
    But the issue becomes on which nodes these pods should be running. Here anti-affinity
    helps by distributing pods on required nodes, which are classified to run a secrets
    management solution.
  prefs: []
  type: TYPE_NORMAL
- en: Data encryption (transit and rest)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By default, Kubernetes insecurely stores and transmits secrets. It is paramount
    to configure or have a solution that can use end-to-end TLS encryption where secrets
    are encrypted in transit. At the same time, have a mechanism in place to store
    secrets in encrypted form. See [Chapter 2](ch02.xhtml#infrastructure_security)
    for options on how to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Use automated secret rotation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Organizations follow different time frames for different secrets for rotation,
    but with the advent of automated secret rotation, you can do it daily or even
    on an hourly basis. Cloud secrets management services and external third-party
    solutions both can help to rotate and manage secrets in an automated fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Ephemeral or dynamic secret
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ephemeral or dynamic secrets are temporary, on-demand generated secrets that
    typically have a short time to live and are destroyed after that time interval.
    These secrets can be made available to the class of the application or to the
    operations team as needed. If a secret is discovered by an attacker (for example,
    if leaked via debug logs, application code, or accidentally exposed via GitHub),
    the secrets would have been changed in a short window of time, protecting applications.
    Additionally, they can help trace the attacker’s footsteps in the infrastructure,
    since it becomes easy to determine the time frame in which the secret was discovered
    by the attacker. HashiCorp Vault and CyberArk Conjur are some of the third-party
    secrets providers that provide such features.
  prefs: []
  type: TYPE_NORMAL
- en: Enable audit log
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having an audit log in your secrets management solution provides visibility
    into secrets and their uses by the organization. An audit log can be critical
    for determining intentional or unintentional compromises, the blast radius of
    the attack, and related forensic steps.
  prefs: []
  type: TYPE_NORMAL
- en: Store secrets in container memory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a containerized application receives a secret, don’t store the secret on
    disk (or in volumeMount available in the host). Rather, store it in memory so
    that in case of a compromise, those secrets are not easily available to the attacker.
  prefs: []
  type: TYPE_NORMAL
- en: Secret zero problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many secrets management solutions follow envelope encryption where DEKs are
    protected by a KEK. The KEK is considered secret zero. If an attacker compromises
    the KEK, then they can decrypt the DEK and subsequently the data encrypted by
    the DEK. The combination of cloud providers’ IAM and KMS can be used to help protect
    secret zero. (Though, of course, these in turn effectively have their own secret
    zero further up the trust chain, which you must treat as highly sensitive.)
  prefs: []
  type: TYPE_NORMAL
- en: Use your Certificate Authority
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As part of defense-in-depth, end-to-end TLS implementation can be done using
    a custom Certificate Authority (CA). Here an organization can choose to sign its
    certificate using its own CA. In this case, the service can only be accessed by
    presenting a certificate signed by the organization.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you are ready with your hardened images, CI/CD pipeline, and secrets management
    strategy, it’s time for Kubernetes’ authentication and authorization strategy.
    Kubernetes allows numerous authentication mechanisms; in simplest form; authentication
    is done with certificates, tokens, or basic authentication (username and password).
    Additionally, webhooks can be used to verify bearer tokens, and external OpenID
    providers can be integrated.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at each authentication method available in Kubernetes.
    Configuration for authentication methods is out of scope for this book.
  prefs: []
  type: TYPE_NORMAL
- en: X509 Client Certificates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two ways to sign a client certificate so that it can be used to authenticate
    with the Kubernetes API. First is internally signing the certificate using the
    Kubernetes API. It involves the creation of a certificate signing request (CSR)
    by a client. Administrators can approve or deny the CSR. Once approved, the administrator
    can extract and provide a signed certificate to the requesting client or user.
    This method cannot be scaled for large organizations as it requires manual intervention.
  prefs: []
  type: TYPE_NORMAL
- en: The second method is to use enterprise PKI, which can sign the client-submitted
    CSR. Additionally, the signing authority can send signed certificates back to
    clients. This approach requires the private key to be managed by an external solution.
  prefs: []
  type: TYPE_NORMAL
- en: Bearer Token
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes service accounts use bearer tokens to authenticate with Kubernetes
    API. The simplest way to use a bearer token is to create a new service account.
    Kubernetes API automatically issues a random token associated with the service
    account, which can be retrieved and used to authenticate that account.
  prefs: []
  type: TYPE_NORMAL
- en: Bearer tokens can be verified using a webhook, which involves API configuration
    with option `--authentication-token-webhook-config-file`, which includes the details
    of the remote webhook service.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes internally uses Bootstrap and Node authentication tokens to initialize
    the cluster. Also, there'’s a less secure option available using a static token
    file that can be provided using the `--token-auth-file` option while configuring
    Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: OIDC Tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The [OpenID Connect protocol](https://oreil.ly/8t476) is built by expanding
    the existing OAuth2 protocol. Kubernetes does not provide an OpenID Connect identity
    provider. You can use identity providers like Google or Azure or run your own
    identity provider using [dex](https://oreil.ly/Rd2sg), [keycloak](https://oreil.ly/ah3IY),
    or [UAA](https://oreil.ly/oMhzC). These external identity providers can easily
    be integrated with your authentication workflows as required, as well as support
    native identity provider capabilities (e.g., enterprise using lightweight directory
    access protocol).
  prefs: []
  type: TYPE_NORMAL
- en: Authentication Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A proxy can be used to establish a trust connection with Kubernetes API. Kubernetes
    API can identify users from request headers such as X-Remote-User, which is set
    by authentication proxy as it authenticates users on behalf of the Kubernetes
    API. Authentication proxy can authenticate users as needed according to your workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If a request to Kubernetes API is not rejected by any configured authentication
    method, then it is treated as an anonymous request (i.e., a request without a
    bearer token).
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that for Kubernetes version 1.6 and above, anonymous
    access is enabled by default for an authorization mode other than `AlwaysAllow`.
    It can be disabled by adding the option `--anonymous-auth=false` while configuring
    Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: User Impersonation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a subtle authentication mechanism where a user with certain access to
    Kubernetes can impersonate another user by setting additional headers in the request
    to Kubernetes API with the details of the impersonated user.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism allows Kubernetes API to process requests as per the impersonated
    user’s privileges and context. Additionally, Kubernetes API can log who has impersonated
    whom and other relevant details from a request as necessary, which can be useful
    during monitoring and audit.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we will cover available authorization methods, RBAC in Kubernetes,
    namespaced RBAC, and caveats.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes has multiple authorization mechanisms such as Node, ABAC, RBAC, and
    AlwaysDeny/AlwaysAllow, though RBAC is the industry standard in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node authorization is used by Kubernetes internally. It’s a special-purpose
    authorization mode that specifically authorizes API requests made by kubelets.
    It enables read, write, and auth-related operations by kubelet. In order to successfully
    make a request, kubelet must use a credential that identifies it as being in the
    system:nodes group.
  prefs: []
  type: TYPE_NORMAL
- en: ABAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes defines attribute-based access control (ABAC) as “an access control
    paradigm whereby access rights are granted to users through the use of policies
    which combine attributes together.” ABAC can be enabled by providing a *.json*
    file to `--authorization-policy-file` and `--authorization-mode=ABAC` options
    in Kubernetes API configurations. The .*json* file needs to be present before
    Kubernetes API can be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: AlwaysDeny/AlwaysAllow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The  AlwaysDeny  or  AlwaysAllow  authorization  mode  is  usually  used  in 
    development  environments  where  all  requests  to  the  Kubernetes  API  need 
    to  be  allowed  or denied. AlwaysDeny or AlwaysAllow mode can be enabled using
    option `--authorization-mode=AlwaysDeny/AlwaysAllow` while configuring Kubernetes
    API. This mode is considered insecure and hence is not recommended in production
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Role-based access control is the most secure and recommended authorization mechanism
    in Kubernetes. It is an approach to restrict system access based on the roles
    of users within your cluster. It allows organizations to enforce the principle
    of least privileges. Kubernetes RBAC follows a declarative nature with clear permissions
    (operations), API objects (resources), and subjects (users, groups, or ServiceAccounts)
    declared in authorization requests. Applying an RBAC in Kubernetes is a two-step
    process. First is to create a Role or ClusterRole. The latter is a global object
    where the former is a namespace object. A Role or ClusterRole is made up of verbs,
    resources, and subjects, which provide a capability (verb) on a resource, as shown
    in [Figure 3-6](#kubernetes_role_and_role_binding). The second step is to create
    a ClusterRoleBinding where the privileges defined in step 1 are assigned to the
    user or group.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take an example where a dev-admins group needs to have read access to
    all the secrets in the cluster. Step 1 is to create a ClusterRole secret-reader,
    which allows the reading of the secrets via various operations (get, list), and
    step 2 is binding it to a subject (i.e., users, groups, or ServiceAccounts) to
    provide access. In this case the group dev-admins allows group users to read secrets
    globally.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 3-6](#kubernetes_role_and_role_binding) is an example of how you can
    create a ClusterRole that allows you to define access to resources. The example
    on the right shows how you can bind the ClusterRole to a group of users.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ksao_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. Kubernetes role and role binding
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 3-7](#rbac_for_kubernetes_resources) shows an overview of RBAC; you
    can use any combination of operation, resource, or subject as required.'
  prefs: []
  type: TYPE_NORMAL
- en: Apart from these resources, there are Kubernetes nonresources like /healths
    or /version APIs that can be controlled using RBAC as well if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![](Images/ksao_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. RBAC for Kubernetes resources
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Namespaced RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In earlier examples you saw an RBAC that was applied globally in the cluster.
    It is possible to apply a similar RBAC to namespaces where resources within a
    namespace can be subject to this RBAC policy. The namespaced resources Role and
    RoleBinding should be used for configuring a namespace policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are few caveats you should be aware of while using namespaced RBAC:'
  prefs: []
  type: TYPE_NORMAL
- en: Roles and RoleBindings are the only namespaced resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ClusterRoleBindings (global resource) cannot be used with Roles, which is a
    namespaced resource.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RoleBindings (namespaced resource) cannot be used with ClusterRoles, which are
    global resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only ClusterRoles can be aggregated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Privilege Escalation Mitigation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes RBAC reduces an attacker’s ability to escalate their own privileges
    by editing roles or role bindings. This behavior is enforced at the API level
    in Kubernetes and even applies when the RBAC authorizer is not in use:'
  prefs: []
  type: TYPE_NORMAL
- en: If user user-no-secret doesn’t have the ability to list secrets cluster-wide,
    they cannot create a ClusterRole or ClusterRoleBinding containing that permission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For user user-no-secret to get a list of secret privileges, they will need
    one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grant them a role that allows them to create/update Roles, ClusterRoles, RoleBindinsg,
    or ClusterRoleBindings.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide them explicit permission with the verb escalate on these resources.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we covered the following key concepts that will help you understand
    security tools and best practices to build and deploy workloads:'
  prefs: []
  type: TYPE_NORMAL
- en: It is insufficient to use available base images from Docker as they are for
    your containers; you must spend time ensuring that your container images are hardened
    and built with security in mind. Just like in software development, finding vulnerabilities
    at build time is far cheaper than finding vulnerabilities after software is deployed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are several ways to add image scanning to your CI/CD process. We explored
    various well-known approaches like registry scan, build time or inline scan, and
    using Kubernetes admission controller to help you add image scanning to your CI/CD
    pipelines. We also looked at securing CI/CD pipelines and adding organization
    policy to effectively craft a workflow for your organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered the approaches and best practices to secret management.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we covered available Kubernetes authentication and authorization mechanisms.
    We recommend you use RBAC to mitigate privilege escalation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
