<html><head></head><body><section data-pdf-bookmark="Chapter 6. String Template Literal Types" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch06">&#13;
<h1><span class="label">Chapter 6. </span>String Template Literal Types</h1>&#13;
&#13;
&#13;
<p><a data-primary="string template literal types" data-type="indexterm" id="id689"/>In TypeScript’s type system, every value is also a type. We call them literal types, and in union with other literal types, you can define a type that is very clear about which values it can accept. Let’s take subsets of <code>string</code> as an example. You can define exactly which strings should be part of your set and rule out a ton of errors. The other end of the spectrum would be the entire set of strings again.</p>&#13;
&#13;
<p>But what if there is something between? What if we can define types that check if certain string patterns are available, and let the rest be more flexible? <em>String template literal types</em> do exactly that. They allow us to define types where certain parts of a string are predefined; the rest is open and flexible for a variety of uses.</p>&#13;
&#13;
<p>But even more, in conjunction with conditional types, it’s possible to split strings into bits and pieces and reuse the same bits for new types. This is an incredibly powerful tool, especially if you think about how much code in JavaScript relies on patterns within strings.</p>&#13;
&#13;
<p>In this chapter, we look at a variety of use cases for <em>string template literal types</em>. From following simple string patterns to extracting parameters and types based on format strings, you will see the enabling power of parsing strings as types.</p>&#13;
&#13;
<p>But we keep it real. Everything you see here comes from real-world examples. What you can accomplish with string template literal types seems endless. People push the usage of string template literal types to the extreme by writing <a href="https://oreil.ly/63z2Y">spell checkers</a> or implementing <a href="https://oreil.ly/foSvx">SQL parsers</a>; there seems to be no limit to what you can do with this mind-blowing feature.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="6.1 Defining a Custom Event System" data-type="sect1"><div class="sect1" id="ch06_custom_events">&#13;
<h1>6.1 Defining a Custom Event System</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id94">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="custom event system" data-type="indexterm" id="ix_06-01-asciidoc0"/><a data-primary="event system, custom" data-type="indexterm" id="ix_06-01-asciidoc1"/><a data-primary="string patterns, custom event system for" data-type="indexterm" id="ix_06-01-asciidoc2"/><a data-primary="string template literal types" data-secondary="defining a custom event system" data-type="indexterm" id="ix_06-01-asciidoc3"/><a data-primary="template literal types" data-secondary="defining a custom event system" data-type="indexterm" id="ix_06-01-asciidoc4"/>You are creating a custom event system and want to make sure every event name follows a convention and starts with <code>"on"</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id95">&#13;
<h2>Solution</h2>&#13;
&#13;
<p><a data-primary="template literal types" data-seealso="string template literal types" data-type="indexterm" id="id690"/>Use string template literal types to describe string patterns.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id96">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>It’s common in JavaScript event systems to have some sort of prefix that indicates a particular string is an event. Usually, event or event handler strings start with <code>on</code>, but depending on the implementation, this can be different.</p>&#13;
&#13;
<p>You want to create your own event system and want to honor this convention. With TypeScript’s string types it is possible to either accept all possible strings or subset to a union type of string literal types. While one is too broad, the other one is not flexible enough for our needs. We don’t want to define every possible event name up front; we want to adhere to a pattern.</p>&#13;
&#13;
<p>Thankfully, a type called <em>string template literal type</em> or just <em>template literal type</em> is exactly what we are looking for. Template literal types allow us to define string literals but leave certain parts flexible.</p>&#13;
&#13;
<p>For example, a type that accepts all strings that start with <code>on</code> could look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">EventName</code> <code class="o">=</code> <code class="sb">`on</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code></pre>&#13;
&#13;
<p>Syntactically, template literal types borrow from JavaScript’s <em>template strings</em>. They start and end with a backtick, followed by any string.</p>&#13;
&#13;
<p>Using the specific syntax <code>${}</code> allows adding JavaScript expressions, like variables, function calls, and the like to strings:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">greet</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="sb">`Hi, </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">!`</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">greet</code><code class="p">(</code><code class="s2">"Stefan"</code><code class="p">);</code> <code class="c1">// "Hi, Stefan!"</code></pre>&#13;
&#13;
<p class="pagebreak-before">Template literal types in TypeScript are very similar. Instead of JavaScript expressions, they allow us to add a set of values in the form of types. A type defining the string representation of all available heading elements in HTML could look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Levels</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">|</code> <code class="mi">2</code> <code class="o">|</code> <code class="mi">3</code> <code class="o">|</code> <code class="mi">4</code> <code class="o">|</code> <code class="mi">5</code> <code class="o">|</code> <code class="mi">6</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// resolves to "H1" | "H2" | "H3" | "H4" | "H5" | "H6"</code>&#13;
<code class="kr">type</code> <code class="nx">Headings</code> <code class="o">=</code> <code class="sb">`H</code><code class="si">${</code><code class="nx">Levels</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code></pre>&#13;
&#13;
<p><code>Levels</code> is a subset of <code>number</code>, and <code>Headings</code> reads as “starts with H, followed by a value compatible with <code>Levels</code>.” You can’t put every type in here, only ones that have a string representation.</p>&#13;
&#13;
<p>Let’s go back to <code>EventName</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">EventName</code> <code class="o">=</code> <code class="sb">`on</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code></pre>&#13;
&#13;
<p>Defined like this, <code>EventName</code> reads like “starts with <code>"on"</code>, followed by any string.” This includes the empty string. Let’s use <code>EventName</code> to create a simple event system. In the first step, we only want to collect callback functions.</p>&#13;
&#13;
<p>For that, we define a <code>Callback</code> type that is a function type with one parameter: an <code>EventObject</code>. The <code>EventObject</code> is a generic type that contains the value with the event information:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">EventObject</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">val</code><code class="o">:</code> <code class="nx">T</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Callback</code><code class="o">&lt;</code><code class="nx">T</code> <code class="o">=</code> <code class="kr">any</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">(</code><code class="nx">ev</code><code class="o">:</code> <code class="nx">EventObject</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code></pre>&#13;
&#13;
<p>Furthermore, we need a type to store all registered event callbacks, <code>Events</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Events</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">x</code><code class="o">:</code> <code class="nx">EventName</code><code class="p">]</code><code class="o">:</code> <code class="nx">Callback</code><code class="p">[]</code> <code class="o">|</code> <code class="kc">undefined</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>We use <code>EventName</code> as index access as it is a valid subtype of <code>string</code>. Each index points to an array of callbacks. With our types defined, we set up an <code>EventSystem</code> class:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">EventSystem</code> <code class="p">{</code>&#13;
  <code class="nx">events</code><code class="o">:</code> <code class="nx">Events</code><code class="p">;</code>&#13;
  <code class="kr">constructor</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">events</code> <code class="o">=</code> <code class="p">{};</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">defineEventHandler</code><code class="p">(</code><code class="nx">ev</code><code class="o">:</code> <code class="nx">EventName</code><code class="p">,</code> <code class="nx">cb</code><code class="o">:</code> <code class="nx">Callback</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code> <code class="p">{</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">events</code><code class="p">[</code><code class="nx">ev</code><code class="p">]</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">events</code><code class="p">[</code><code class="nx">ev</code><code class="p">]</code> <code class="o">??</code> <code class="p">[];</code>&#13;
    <code class="k">this</code><code class="p">.</code><code class="nx">events</code><code class="p">[</code><code class="nx">ev</code><code class="p">]</code><code class="o">?</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">cb</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="nx">trigger</code><code class="p">(</code><code class="nx">ev</code><code class="o">:</code> <code class="nx">EventName</code><code class="p">,</code> <code class="nx">value</code><code class="o">:</code> <code class="kr">any</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nx">callbacks</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">events</code><code class="p">[</code><code class="nx">ev</code><code class="p">];</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">callbacks</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="nx">callbacks</code><code class="p">.</code><code class="nx">forEach</code><code class="p">((</code><code class="nx">cb</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
        <code class="nx">cb</code><code class="p">({</code> <code class="nx">val</code><code class="o">:</code> <code class="nx">value</code> <code class="p">});</code>&#13;
      <code class="p">});</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The constructor creates a new events storage, and <code>defineEventHandler</code> takes an <code>Ev⁠en⁠t​Na⁠me</code> and <code>Callback</code> and stores them in said events storage. Also, <code>trigger</code> takes an <code>Ev⁠ent​Na⁠me</code> and, if callbacks are registered, executes every registered callback with an <code>Ev⁠ent​Obj⁠ect</code>.</p>&#13;
&#13;
<p>The first step is done. We now have type safety when defining events:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">const</code> <code class="nx">system</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">EventSystem</code><code class="p">();</code>&#13;
<code class="nx">system</code><code class="p">.</code><code class="nx">defineEventHandler</code><code class="p">(</code><code class="s2">"click"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{});</code>&#13;
<code class="c1">// ^ Argument of type '"click"' is not assignable to parameter</code>&#13;
<code class="c1">//.  of type '`on${string}`'.(2345)</code>&#13;
<code class="nx">system</code><code class="p">.</code><code class="nx">defineEventHandler</code><code class="p">(</code><code class="s2">"onClick"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{});</code>&#13;
<code class="nx">system</code><code class="p">.</code><code class="nx">defineEventHandler</code><code class="p">(</code><code class="s2">"onchange"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{});</code></pre>&#13;
&#13;
<p>In <a data-type="xref" href="#ch06_string_manipulation_types">Recipe 6.2</a> we will look at how we can use string manipulation types and key remapping to enhance our system.<a data-startref="ix_06-01-asciidoc4" data-type="indexterm" id="id691"/><a data-startref="ix_06-01-asciidoc3" data-type="indexterm" id="id692"/><a data-startref="ix_06-01-asciidoc2" data-type="indexterm" id="id693"/><a data-startref="ix_06-01-asciidoc1" data-type="indexterm" id="id694"/><a data-startref="ix_06-01-asciidoc0" data-type="indexterm" id="id695"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="6.2 Creating Event Callbacks with &#10;String Manipulation Types and Key Remapping" data-type="sect1"><div class="sect1" id="ch06_string_manipulation_types">&#13;
<h1>6.2 Creating Event Callbacks with &#13;
<span class="keep-together">String Manipulation Types and Key Remapping</span></h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id97">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="event callbacks, creating" data-type="indexterm" id="ix_06-02-asciidoc0"/><a data-primary="key remapping" data-type="indexterm" id="ix_06-02-asciidoc1"/><a data-primary="string manipulation types" data-type="indexterm" id="ix_06-02-asciidoc2"/><a data-primary="string template literal types" data-secondary="creating event callbacks with string manipulation types and key remapping" data-type="indexterm" id="ix_06-02-asciidoc3"/><a data-primary="watch function" data-type="indexterm" id="ix_06-02-asciidoc4"/>You want to provide a <code>watch</code> function that takes any object and adds watcher functions for each property, allowing you to define event callbacks.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id696">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use <em>key remapping</em> to create new string property keys. Use <em>string manipulation types</em> to have proper camel casing for watcher functions.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id98">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Our event system from <a data-type="xref" href="#ch06_custom_events">Recipe 6.1</a> is taking shape. We are able to register event handlers and trigger events. Now we want to add watch functionality. The idea is to extend valid objects with methods for registering callbacks that are executed every time a property changes. For example, when we define a <code>person</code> object, we should be able to listen to <code>onAgeChanged</code> and <code>onNameChanged</code> events:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">watchedPerson</code> <code class="o">=</code> <code class="nx">system</code><code class="p">.</code><code class="nx">watch</code><code class="p">(</code><code class="nx">person</code><code class="p">);</code>&#13;
&#13;
<code class="nx">watchedPerson</code><code class="p">.</code><code class="nx">onAgeChanged</code><code class="p">((</code><code class="nx">ev</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ev</code><code class="p">.</code><code class="nx">val</code><code class="p">,</code> <code class="s2">"changed!!"</code><code class="p">);</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">watchedPerson</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="mi">41</code><code class="p">;</code> <code class="c1">// triggers callbacks</code></pre>&#13;
&#13;
<p>So for each property, there will be a method that starts with <code>on</code>, ends with <code>Changed</code>, and accepts callback functions with event object parameters.</p>&#13;
&#13;
<p>To define the new event handler methods, we create a helper type called <code>Wa⁠tch⁠ed​Ob⁠jec⁠t&lt;T&gt;</code>, where we add bespoke methods:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">WatchedObject</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kt">string</code> <code class="o">&amp;</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="kr">as</code> <code class="sb">`on</code><code class="si">${</code><code class="nx">K</code><code class="si">}</code><code class="sb">Changed`</code><code class="p">]</code><code class="o">:</code> <code class="p">(</code>&#13;
    <code class="nx">ev</code><code class="o">:</code> <code class="nx">Callback</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code>&#13;
  <code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>There’s a lot to unpack. Let’s go through it step by step:</p>&#13;
<ol>&#13;
<li>&#13;
<p>We define a <em>mapped type</em> by iterating over all keys from <code>T</code>. Since we care only about <code>string</code> property keys, we use the intersection <code>string &amp; keyof T</code> to get rid of potential symbols or numbers.</p>&#13;
</li>&#13;
<li>&#13;
<p>Next, we <em>remap</em> this key to a new string, defined by a <em>string template literal type</em>. It starts with <code>on</code>, then takes the key <code>K</code> from our mapping process, and appends <code>Changed</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>The property key points to a function that accepts a callback. The callback itself has an event object as an argument, and by correctly substituting its generics, we can make sure this event object contains the original type of our watched object. This means when we call <code>onAgeChanged</code>, the event object will actually contain a <code>number</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This is already fantastic but lacks significant detail. When we use <code>WatchedObject</code> on <code>person</code> like that, all generated event handler methods lack an uppercase character after <code>on</code>. To solve this, we can use one of the built-in <em>string manipulation types</em> to &#13;
<span class="keep-together">capitalize</span> string types:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">WatchedObject</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="kt">string</code> <code class="o">&amp;</code> <code class="kr">keyof</code> <code class="nx">T</code> <code class="kr">as</code> <code class="sb">`on</code><code class="si">${</code><code class="nx">Capitalize</code><code class="o">&lt;</code><code class="nx">K</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">Changed`</code><code class="p">]</code><code class="o">:</code> <code class="p">(</code>&#13;
    <code class="nx">ev</code><code class="o">:</code> <code class="nx">Callback</code><code class="o">&lt;</code><code class="nx">T</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code>&#13;
  <code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>Next to <code>Capitalize</code>, <code>Lowercase</code>, <code>Uppercase</code>, and <code>Uncapitalize</code> are also available. If we hover over <code>WatchedObject&lt;typeof person&gt;</code>, we can see what the generated type looks like:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">WatchedPerson</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">onNameChanged</code><code class="o">:</code> <code class="p">(</code><code class="nx">ev</code><code class="o">:</code> <code class="nx">Callback</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
  <code class="nx">onAgeChanged</code><code class="o">:</code> <code class="p">(</code><code class="nx">ev</code><code class="o">:</code> <code class="nx">Callback</code><code class="o">&lt;</code><code class="kt">number</code><code class="o">&gt;</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="k">void</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>With our types set up, we start with the implementation. First, we create two helper functions:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">capitalize</code><code class="p">(</code><code class="nx">inp</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">inp</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="mi">0</code><code class="p">).</code><code class="nx">toUpperCase</code><code class="p">()</code> <code class="o">+</code> <code class="nx">inp</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">handlerName</code><code class="p">(</code><code class="nx">name</code><code class="o">:</code> <code class="kt">string</code><code class="p">)</code><code class="o">:</code> <code class="nx">EventName</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="sb">`on</code><code class="si">${</code><code class="nx">capitalize</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code><code class="si">}</code><code class="sb">Changed`</code> <code class="kr">as</code> <code class="nx">EventName</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We need both helper functions to mimic TypeScript’s behavior of remapping and manipulating strings. <code>capitalize</code> changes the first letter of a string to its uppercase equivalent, and <code>handlerName</code> adds a prefix and suffix to it. With <code>handlerName</code> we need a little type assertion to signal TypeScript that the type has changed. With the many ways we can transform strings in JavaScript, TypeScript can’t figure out that this will result in a capitalized version.</p>&#13;
&#13;
<p>Next, we implement the <code>watch</code> functionality in the event system. We create a generic function that accepts any object and returns an object that contains both the original properties and the watcher properties.</p>&#13;
&#13;
<p>To successfully implement triggering of event handlers on property change, we use <code>Proxy</code> objects to intercept <code>get</code> and <code>set</code> calls:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">EventSystem</code> <code class="p">{</code>&#13;
  <code class="c1">// cut for brevity</code>&#13;
  <code class="nx">watch</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="nx">WatchedObject</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Proxy</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="p">{</code>&#13;
      <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="c1">// (1)</code>&#13;
        <code class="k">if</code> <code class="p">(</code>&#13;
          <code class="k">typeof</code> <code class="nx">property</code> <code class="o">===</code> <code class="s2">"string"</code> <code class="o">&amp;&amp;</code>&#13;
          <code class="nx">property</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s2">"on"</code><code class="p">)</code> <code class="o">&amp;&amp;</code>&#13;
          <code class="nx">property</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s2">"Changed"</code><code class="p">)</code>&#13;
        <code class="p">)</code> <code class="p">{</code>&#13;
          <code class="c1">// (2)</code>&#13;
          <code class="k">return</code> <code class="p">(</code><code class="nx">cb</code><code class="o">:</code> <code class="nx">Callback</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
            <code class="nx">self</code><code class="p">.</code><code class="nx">defineEventHandler</code><code class="p">(</code><code class="nx">property</code> <code class="kr">as</code> <code class="nx">EventName</code><code class="p">,</code> <code class="nx">cb</code><code class="p">);</code>&#13;
          <code class="p">};</code>&#13;
        <code class="p">}</code>&#13;
        <code class="c1">// (3)</code>&#13;
        <code class="k">return</code> <code class="nx">target</code><code class="p">[</code><code class="nx">property</code> <code class="kr">as</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">];</code>&#13;
      <code class="p">},</code>&#13;
      <code class="c1">// set to be done ...</code>&#13;
    <code class="p">})</code> <code class="kr">as</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="nx">WatchedObject</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>get</code> calls we want to intercept are whenever we access the properties of &#13;
<span class="keep-together"><code>WatchedObject&lt;T&gt;</code>:</span></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>They start with <code>on</code> and end with <code>Changed</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If that’s the case, we return a function that accepts callbacks. The function itself adds callbacks to the event storage via <code>defineEventHandler</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>In all other cases we do regular property access.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Now, every time we set a value of the original object, we want to trigger stored events. This is why we modify all <code>set</code> calls:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">class</code> <code class="nx">EventSystem</code> <code class="p">{</code>&#13;
  <code class="c1">// ... cut for brevity</code>&#13;
  <code class="nx">watch</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="nx">object</code><code class="o">&gt;</code><code class="p">(</code><code class="nx">obj</code><code class="o">:</code> <code class="nx">T</code><code class="p">)</code><code class="o">:</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="nx">WatchedObject</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="nx">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>&#13;
    <code class="k">return</code> <code class="k">new</code> <code class="nx">Proxy</code><code class="p">(</code><code class="nx">obj</code><code class="p">,</code> <code class="p">{</code>&#13;
      <code class="c1">// get from above ...</code>&#13;
      <code class="nx">set</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="k">if</code> <code class="p">(</code><code class="nx">property</code> <code class="k">in</code> <code class="nx">target</code> <code class="o">&amp;&amp;</code> <code class="k">typeof</code> <code class="nx">property</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>&#13;
          <code class="c1">// (1)</code>&#13;
          <code class="nx">target</code><code class="p">[</code><code class="nx">property</code> <code class="kr">as</code> <code class="kr">keyof</code> <code class="nx">T</code><code class="p">]</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code>&#13;
          <code class="c1">// (2)</code>&#13;
          <code class="nx">self</code><code class="p">.</code><code class="nx">trigger</code><code class="p">(</code><code class="nx">handlerName</code><code class="p">(</code><code class="nx">property</code><code class="p">),</code> <code class="nx">value</code><code class="p">);</code>&#13;
          <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>&#13;
        <code class="p">}</code>&#13;
        <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>&#13;
      <code class="p">},</code>&#13;
    <code class="p">})</code> <code class="kr">as</code> <code class="nx">T</code> <code class="o">&amp;</code> <code class="nx">WatchedObject</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The process is as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Set the value. We need to update the object anyway.</p>&#13;
</li>&#13;
<li>&#13;
<p>Call the <code>trigger</code> function to execute all registered callbacks.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Please note that we need a couple of type assertions to nudge TypeScript in the right direction. We are creating new objects, after all.</p>&#13;
&#13;
<p>And that’s it! Try the example from the beginning to see your event system in action:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">let</code> <code class="nx">person</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">name</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">watchedPerson</code> <code class="o">=</code> <code class="nx">system</code><code class="p">.</code><code class="nx">watch</code><code class="p">(</code><code class="nx">person</code><code class="p">);</code>&#13;
&#13;
<code class="nx">watchedPerson</code><code class="p">.</code><code class="nx">onAgeChanged</code><code class="p">((</code><code class="nx">ev</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">ev</code><code class="p">.</code><code class="nx">val</code><code class="p">,</code> <code class="s2">"changed!!"</code><code class="p">);</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">watchedPerson</code><code class="p">.</code><code class="nx">age</code> <code class="o">=</code> <code class="mi">41</code><code class="p">;</code> <code class="c1">// logs "41 changed!!"</code></pre>&#13;
&#13;
<p>String template literal types along with string manipulation types and key remapping allow us to create types for new objects on the fly. These powerful tools make the use of advanced JavaScript object creation more robust.<a data-startref="ix_06-02-asciidoc4" data-type="indexterm" id="id697"/><a data-startref="ix_06-02-asciidoc3" data-type="indexterm" id="id698"/><a data-startref="ix_06-02-asciidoc2" data-type="indexterm" id="id699"/><a data-startref="ix_06-02-asciidoc1" data-type="indexterm" id="id700"/><a data-startref="ix_06-02-asciidoc0" data-type="indexterm" id="id701"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="6.3 Writing a Formatter Function" data-type="sect1"><div class="sect1" id="ch06_formatter_function">&#13;
<h1>6.3 Writing a Formatter Function</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id221">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="conditional types" data-secondary="writing a formatter function" data-type="indexterm" id="ix_06-03-asciidoc0"/><a data-primary="formatter function" data-secondary="writing" data-type="indexterm" id="ix_06-03-asciidoc1"/><a data-primary="string template literal types" data-secondary="writing a formatter function" data-type="indexterm" id="ix_06-03-asciidoc2"/>You want to create typings for a function that takes a format string and substitutes placeholders with actual values.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id702">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a conditional type that infers the placeholder name from a string template &#13;
<span class="keep-together">literal</span> type.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id99">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Your application has a way of defining format strings by defining placeholders with curly braces. A second parameter takes an object with substitutions, so for each placeholder defined in the format string, there is one property key with the respective value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">format</code><code class="p">(</code><code class="s2">"Hello {world}. My name is {you}."</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">world</code><code class="o">:</code> <code class="s2">"World"</code><code class="p">,</code>&#13;
  <code class="nx">you</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Let’s create typings for this function, where we make sure that your users don’t forget to add the required properties. As a first step, we define the function interface with some very broad types. The format string is of type <code>string</code>, and the formatting parameters are in a <code>Record</code> of <code>string</code> keys and literally any value. We focus on the types first; the function body’s implementation comes later:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">format</code><code class="p">(</code><code class="nx">fmtString</code><code class="o">:</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="k">throw</code> <code class="s2">"unimplemented"</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As a next step, we want to lock function arguments to concrete values or literal types by adding generics. We change the type of <code>fmtString</code> to be of a generic type <code>T</code>, which is a subtype of <code>string</code>. This allows us to still pass strings to the function, but the moment we pass a literal string, we can analyze the literal type and look for patterns (see <a data-type="xref" href="ch04.html#ch04_no_any">Recipe 4.3</a> for more details):</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">format</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fmtString</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="kt">string</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="k">throw</code> <code class="s2">"unimplemented"</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now that we locked in <code>T</code>, we can pass it as a type parameter to a generic type <code>FormatKeys</code>. This is a conditional type that will scan our format string for curly braces:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">T</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>Here, we check if the format string:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Starts with a string; this can also be an empty string</p>&#13;
</li>&#13;
<li>&#13;
<p>Contains a <code>{</code>, followed by any string, followed by a <code>}</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Is followed again by any string</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This effectively means that we check if there is exactly one placeholder in the format string. If so, we return the entire format string, and if not, we return <code>never</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="s2">"Hello {world}"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// "Hello {world}"</code>&#13;
<code class="kr">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="s2">"Hello"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// never</code></pre>&#13;
&#13;
<p><code>FormatKeys</code> can tell us if the strings we pass in are format strings or not, but we are actually much more interested in a specific part of the format string: the piece between the curly braces. Using TypeScript’s <code>infer</code> keyword, we can tell TypeScript that, if the format string matches this pattern, then grab whatever literal type you find between the curly braces and put it in a type variable:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Key</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">Key</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p>That way, we can extract substrings and reuse them for our needs:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="s2">"Hello {world}"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// "world"</code>&#13;
<code class="kr">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="s2">"Hello"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// never</code></pre>&#13;
&#13;
<p>Fantastic! We extracted the first placeholder name. Now on to the rest. Since there might be placeholders following, we take everything <em>after</em> the first placeholder and store it in a type variable called <code>Rest</code>. This condition will be always true, because either <code>Rest</code> is the empty string or it contains an actual string that we can analyze again.</p>&#13;
&#13;
<p>We take the <code>Rest</code> and in the <code>true</code> branch call <code>FormatKeys&lt;Rest&gt;</code> in a union type of <code>Key</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Key</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">Key</code> <code class="o">|</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-primary="recursive conditional types" data-secondary="formatter function and" data-type="indexterm" id="id703"/>This is a <em>recursive conditional type</em>. The result will be a union of placeholders, which we can use as keys for the formatting object:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="s2">"Hello {world}"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// "world"</code>&#13;
<code class="kr">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="s2">"Hello {world}. I'm {you}."</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// "world" | "you"</code>&#13;
<code class="kr">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="s2">"Hello"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// never</code></pre>&#13;
&#13;
<p>Now it’s time to wire up <code>FormatKeys</code>. Since we already locked in <code>T</code>, we can pass it as an argument to <code>FormatKeys</code>, which we can use as an argument for <code>Record</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">format</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fmtString</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="k">throw</code> <code class="s2">"unimplemented"</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>And with that, our typings are all ready. On to the implementation! The implementation is beautifully inverted to how we defined our types. We go over all keys from <code>params</code> and replace all occurrences within curly braces with the respective value:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">format</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fmtString</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">ret</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="nx">fmtString</code><code class="p">;</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">params</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">ret</code> <code class="o">=</code> <code class="nx">ret</code><code class="p">.</code><code class="nx">replaceAll</code><code class="p">(</code><code class="sb">`{</code><code class="si">${</code><code class="nx">k</code><code class="si">}</code><code class="sb">}`</code><code class="p">,</code> <code class="nx">params</code><code class="p">[</code><code class="nx">k</code> <code class="kr">as</code> <code class="kr">keyof</code> <code class="k">typeof</code> <code class="nx">params</code><code class="p">]);</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">ret</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Notice two particular typings:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We need to annotate <code>ret</code> with <code>string</code>. <code>fmtString</code> is with <code>T</code>, a subtype of <code>string</code>; thus <code>ret</code> would also be <code>T</code>. This would mean we couldn’t change values because the type of <code>T</code> would change. Annotating it to a broader <code>string</code> type helps us modify <code>ret</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>We also need to assert that the object key <code>k</code> is actually a key of <code>params</code>. This is an unfortunate workaround that is due to some fail-safe mechanisms of TypeScript. Read more on this topic in <a data-type="xref" href="ch09.html#ch09_working_with_object_keys">Recipe 9.1</a>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>With the information from <a data-type="xref" href="ch09.html#ch09_working_with_object_keys">Recipe 9.1</a>, we can redefine <code>format</code> to get rid of some type assertions to reach our final version of the <code>format</code> function:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">format</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fmtString</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">K</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">ret</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="nx">fmtString</code><code class="p">;</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">params</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">ret</code> <code class="o">=</code> <code class="nx">ret</code><code class="p">.</code><code class="nx">replaceAll</code><code class="p">(</code><code class="sb">`{</code><code class="si">${</code><code class="nx">k</code><code class="si">}</code><code class="sb">}`</code><code class="p">,</code> <code class="nx">params</code><code class="p">[</code><code class="nx">k</code><code class="p">]);</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">ret</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Being able to split strings and extract property keys is extremely powerful. TypeScript developers all over the world use this pattern to strengthen types, for example, for web servers like <a href="https://expressjs.com">Express</a>. We will see more examples of how we can use this tool to get better types.<a data-startref="ix_06-03-asciidoc2" data-type="indexterm" id="id704"/><a data-startref="ix_06-03-asciidoc1" data-type="indexterm" id="id705"/><a data-startref="ix_06-03-asciidoc0" data-type="indexterm" id="id706"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="6.4 Extracting Format Parameter Types" data-type="sect1"><div class="sect1" id="ch06_extracting_url_parameters">&#13;
<h1>6.4 Extracting Format Parameter Types</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id100">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="format parameter types" data-type="indexterm" id="ix_06-04-asciidoc0"/><a data-primary="formatter function" data-secondary="extracting format parameter types" data-type="indexterm" id="ix_06-04-asciidoc1"/><a data-primary="nested conditional types" data-type="indexterm" id="ix_06-04-asciidoc2"/><a data-primary="string template literal types" data-secondary="extracting format parameter types" data-type="indexterm" id="ix_06-04-asciidoc3"/>You want to extend the formatting function from <a data-type="xref" href="#ch06_formatter_function">Recipe 6.3</a> with the ability to define types for your placeholders.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id707">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Create a nested conditional type and look up types with a type map.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id101">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>Let’s extend the example from the previous lesson. We now want to not only know all placeholders but also be able to define a certain set of types with the placeholders. Types should be optional, be indicated with a colon after the placeholder name, and be one of JavaScript’s primitive types. We expect to get type errors when we pass in a value that is of the wrong type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="nx">format</code><code class="p">(</code><code class="s2">"Hello {world:string}. I'm {you}, {age:number} years old."</code><code class="p">,</code> <code class="p">{</code>&#13;
  <code class="nx">world</code><code class="o">:</code> <code class="s2">"World"</code><code class="p">,</code>&#13;
  <code class="nx">age</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code>&#13;
  <code class="nx">you</code><code class="o">:</code> <code class="s2">"Stefan"</code><code class="p">,</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>For reference, let’s look at the original implementation from <a data-type="xref" href="#ch06_formatter_function">Recipe 6.3</a>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Key</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">Key</code> <code class="o">|</code> <code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
&#13;
<code class="kd">function</code> <code class="nx">format</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fmtString</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">Record</code><code class="o">&lt;</code><code class="nx">FormatKeys</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code><code class="p">,</code> <code class="kr">any</code><code class="o">&gt;</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">ret</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="nx">fmtString</code><code class="p">;</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">params</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">ret</code> <code class="o">=</code> <code class="nx">ret</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="sb">`{</code><code class="si">${</code><code class="nx">k</code><code class="si">}</code><code class="sb">}`</code><code class="p">,</code> <code class="nx">params</code><code class="p">[</code><code class="nx">k</code> <code class="kr">as</code> <code class="kr">keyof</code> <code class="k">typeof</code> <code class="nx">params</code><code class="p">]);</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">ret</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To achieve this, we need to do two things:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Change the type of <code>params</code> from <code>Record&lt;FormatKeys&lt;T&gt;, any&gt;</code> to an actual object type that has proper types associated with each property key.</p>&#13;
</li>&#13;
<li>&#13;
<p>Adapt the string template literal type within <code>FormatKeys</code> to be able to extract primitive JavaScript types.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>For the first step, we introduce a new type called <code>FormatObj&lt;T&gt;</code>. It works just as <code>FormatKeys</code> did, but instead of simply returning string keys, it maps out the same keys to a new object type. This requires us to chain the recursion using intersection types instead of a union type (we add more properties with each recursion) and to change the breaking condition from <code>never</code> to <code>{}</code>. If we did an intersection with <code>never</code>, the entire return type becomes <code>never</code>. This way, we don’t add any new properties to the return type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatObj</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Key</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Key</code><code class="p">]</code><code class="o">:</code> <code class="kr">any</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="nx">FormatObj</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="p">{};</code></pre>&#13;
&#13;
<p><code>FormatObj&lt;T&gt;</code> works the same way as <code>Record&lt;FormatKeys&lt;T&gt;, any&gt;</code>. We still didn’t extract any placeholder type, but we made it easy to set the type for each placeholder now that we are in control of the entire object type.</p>&#13;
&#13;
<p>As a next step, we change the parsing condition in <code>FormatObj&lt;T&gt;</code> to also look out for colon delimiters. If we find a <code>:</code> character, we infer the subsequent string literal type in <code>Type</code> and use it as the type for the mapped-out key:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatObj</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Key</code><code class="si">}</code><code class="sb">:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Type</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Key</code><code class="p">]</code><code class="o">:</code> <code class="nx">Type</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="nx">FormatObj</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="p">{};</code></pre>&#13;
&#13;
<p>We are very close; there’s just one caveat. We infer a <em>string</em> literal type. This means that if we, for example, parse <code>{age:number}</code>, the type of <code>age</code> would be the literal string <code>"number"</code>. We need to convert this string to an actual type. We could do another conditional type or use a map type as a lookup:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">MapFormatType</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="kt">string</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
  <code class="kt">number</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>&#13;
  <code class="kr">boolean</code><code class="o">:</code> <code class="kr">boolean</code><code class="p">;</code>&#13;
  <code class="p">[</code><code class="nx">x</code><code class="o">:</code> <code class="kt">string</code><code class="p">]</code><code class="o">:</code> <code class="kr">any</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>That way, we can simply check which type is associated with which key and have a fantastic fallback for all other strings:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">A</code> <code class="o">=</code> <code class="nx">MapFormatType</code><code class="p">[</code><code class="s2">"string"</code><code class="p">];</code> <code class="c1">// string</code>&#13;
<code class="kr">type</code> <code class="nx">B</code> <code class="o">=</code> <code class="nx">MapFormatType</code><code class="p">[</code><code class="s2">"number"</code><code class="p">];</code> <code class="c1">// number</code>&#13;
<code class="kr">type</code> <code class="nx">C</code> <code class="o">=</code> <code class="nx">MapFormatType</code><code class="p">[</code><code class="s2">"notavailable"</code><code class="p">];</code> <code class="c1">// any</code></pre>&#13;
&#13;
<p>Let’s wire <code>MapFormatType</code> up to <code>FormatObj&lt;T&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatObj</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Key</code><code class="si">}</code><code class="sb">:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Type</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Key</code><code class="p">]</code><code class="o">:</code> <code class="nx">MapFormatType</code><code class="p">[</code><code class="nx">Type</code><code class="p">]</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="nx">FormatObj</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="p">{};</code></pre>&#13;
&#13;
<p>We are almost there! The problem now is that we expect every placeholder to also define a type. We want to make types optional. But our parsing condition explicitly asks for <code>:</code> delimiters, so every placeholder that doesn’t define a type doesn’t produce a property, either.</p>&#13;
&#13;
<p>The solution is to do the check for types <em>after</em> we check for placeholder:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatObj</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Key</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">Key</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">KeyPart</code><code class="si">}</code><code class="sb">:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">TypePart</code><code class="si">}</code><code class="sb">`</code>&#13;
    <code class="o">?</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">KeyPart</code><code class="p">]</code><code class="o">:</code> <code class="nx">MapFormatType</code><code class="p">[</code><code class="nx">TypePart</code><code class="p">]</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="nx">FormatObj</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
    <code class="o">:</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Key</code><code class="p">]</code><code class="o">:</code> <code class="kr">any</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="nx">FormatObj</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="p">{};</code></pre>&#13;
&#13;
<p>The type reads as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Check if there is a placeholder available.</p>&#13;
</li>&#13;
<li>&#13;
<p>If a placeholder is available, check if there is a type annotation. If so, map the key to a format type; otherwise, map the original key to <code>any</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>In all other cases, return the empty object.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>And that’s it. There is one fail-safe guard that we can add. Instead of allowing <code>any</code> type for placeholders without a type definition, we can at least expect that the type implements <code>toString()</code>. This ensures we always get a string representation:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">FormatObj</code><code class="o">&lt;</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code>&#13;
<code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kt">string</code><code class="si">}</code><code class="sb">{</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Key</code><code class="si">}</code><code class="sb">}</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">Key</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">KeyPart</code><code class="si">}</code><code class="sb">:</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">TypePart</code><code class="si">}</code><code class="sb">`</code>&#13;
    <code class="o">?</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">KeyPart</code><code class="p">]</code><code class="o">:</code> <code class="nx">MapFormatType</code><code class="p">[</code><code class="nx">TypePart</code><code class="p">]</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="nx">FormatObj</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
    <code class="o">:</code> <code class="p">{</code> <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">Key</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code> <code class="nx">toString</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code> <code class="p">}</code> <code class="p">}</code> <code class="o">&amp;</code> <code class="nx">FormatObj</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="p">{};</code></pre>&#13;
&#13;
<p>And with that, let’s apply the new type to <code>format</code> and change the implementation:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">format</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">K</code> <code class="kr">extends</code> <code class="nx">FormatObj</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;&gt;</code><code class="p">(</code>&#13;
  <code class="nx">fmtString</code><code class="o">:</code> <code class="nx">T</code><code class="p">,</code>&#13;
  <code class="nx">params</code><code class="o">:</code> <code class="nx">K</code>&#13;
<code class="p">)</code><code class="o">:</code> <code class="kt">string</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">ret</code><code class="o">:</code> <code class="kt">string</code> <code class="o">=</code> <code class="nx">fmtString</code><code class="p">;</code>&#13;
  <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">in</code> <code class="nx">params</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kd">let</code> <code class="nx">val</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">params</code><code class="p">[</code><code class="nx">k</code><code class="p">]</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>&#13;
    <code class="kd">let</code> <code class="nx">searchPattern</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="sb">`{</code><code class="si">${</code><code class="nx">k</code><code class="si">}</code><code class="sb">:?.*?}`</code><code class="p">,</code> <code class="s2">"g"</code><code class="p">);</code>&#13;
    <code class="nx">ret</code> <code class="o">=</code> <code class="nx">ret</code><code class="p">.</code><code class="nx">replaceAll</code><code class="p">(</code><code class="nx">searchPattern</code><code class="p">,</code> <code class="nx">val</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">ret</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We help ourselves with a regular expression to replace names with potential type annotations. There is no need to check types within the function. TypeScript should be enough to help in this case.</p>&#13;
&#13;
<p>What we’ve seen is that conditional types in combination with string template literal types and other tools like recursion and type lookups allow us to specify complex relationships with a couple of lines of code. Our types get better, our code gets more robust, and it’s a joy for developers to use APIs like this.<a data-startref="ix_06-04-asciidoc3" data-type="indexterm" id="id708"/><a data-startref="ix_06-04-asciidoc2" data-type="indexterm" id="id709"/><a data-startref="ix_06-04-asciidoc1" data-type="indexterm" id="id710"/><a data-startref="ix_06-04-asciidoc0" data-type="indexterm" id="id711"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="6.5 Dealing with Recursion Limits" data-type="sect1"><div class="sect1" id="ch06_recursion_limits">&#13;
<h1>6.5 Dealing with Recursion Limits</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id102">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="accumulation technique" data-type="indexterm" id="ix_06-05-asciidoc0"/><a data-primary="helper types" data-secondary="dealing with recursion limits" data-type="indexterm" id="ix_06-05-asciidoc1"/><a data-primary="recursion limits" data-type="indexterm" id="ix_06-05-asciidoc2"/><a data-primary="string template literal types" data-secondary="dealing with recursion limits" data-type="indexterm" id="ix_06-05-asciidoc3"/><a data-primary="tail-call optimization" data-type="indexterm" id="ix_06-05-asciidoc4"/>You craft an elaborate string template literal type that converts any string to a valid property key. With your setup of helper types, you run into recursion limits.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id712">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use the accumulation technique to enable tail-call optimization.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id103">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>TypeScript’s string template literal types in combination with conditional types allow you to create new string types on the fly, which can serve as property keys or check your program for valid strings.</p>&#13;
&#13;
<p>They work using recursion, which means that just like a function, you can call the same type over and over again, up to a certain limit.</p>&#13;
&#13;
<p><a data-primary="whitespaces, removing" data-type="indexterm" id="ix_06-05-asciidoc5"/>For example, this type <code>Trim&lt;T&gt;</code> removes whitespaces at the start and end of your string type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Trim</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">` </code><code class="si">${</code><code class="kr">infer</code> <code class="nx">X</code><code class="si">}</code><code class="sb">`</code> <code class="o">?</code> <code class="nx">Trim</code><code class="o">&lt;</code><code class="nx">X</code><code class="o">&gt;</code> <code class="o">:</code>&#13;
  <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">X</code><code class="si">}</code><code class="sb"> `</code> <code class="o">?</code> <code class="nx">Trim</code><code class="o">&lt;</code><code class="nx">X</code><code class="o">&gt;</code> <code class="o">:</code>&#13;
  <code class="nx">T</code><code class="p">;</code></pre>&#13;
&#13;
<p>It checks if there’s a whitespace at the beginning, infers the rest, and does the same check over again. Once all whitespaces at the beginning are gone, the same checks happen for whitespaces at the end. Once all whitespaces at the beginning and end are gone, it is finished and hops into the last branch—returning the remaining string:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Trimmed</code> <code class="o">=</code> <code class="nx">Trim</code><code class="o">&lt;</code><code class="s2">"     key   "</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// "key"</code></pre>&#13;
&#13;
<p>Calling the type over and over is recursion, and writing it like that works reasonably well. TypeScript can see from the type that the recursive calls stand on their own, and it can evaluate them as tail-call optimized, which means it can evaluate the next step of the recursion within the same call stack frame.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you want to know more about the call stack in JavaScript, &#13;
<span class="keep-together">Thomas</span> Hunter’s book <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/distributed-systems-with/9781492077282"><em>Distributed Systems with Node.js</em></a> (O’Reilly) gives a great introduction.</p>&#13;
</div>&#13;
&#13;
<p>We want to use TypeScript’s feature to recursively call conditional types to create a valid string identifier out of any string, by removing whitespace and invalid &#13;
<span class="keep-together">characters.</span></p>&#13;
&#13;
<p>First, we write a helper type similar to <code>Trim&lt;T&gt;</code> that gets rid of any whitespace it finds:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">RemoveWhiteSpace</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">A</code><code class="si">}</code><code class="sb"> </code><code class="si">${</code><code class="kr">infer</code> <code class="nx">B</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">RemoveWhiteSpace</code><code class="o">&lt;</code><code class="sb">`</code><code class="si">${</code><code class="nx">Uncapitalize</code><code class="o">&lt;</code><code class="nx">A</code><code class="o">&gt;</code><code class="si">}${</code><code class="nx">Capitalize</code><code class="o">&lt;</code><code class="nx">B</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">`</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="nx">T</code><code class="p">;</code></pre>&#13;
&#13;
<p>It checks if there is a whitespace, infers the strings in front of the whitespace and after the whitespace (which can be empty strings), and calls the same type again with a newly formed string type. It also uncapitalizes the first inference and capitalizes the second inference to create a camel-case-like string identifier.</p>&#13;
&#13;
<p>It does so until all whitespaces are gone:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Identifier</code> <code class="o">=</code> <code class="nx">RemoveWhiteSpace</code><code class="o">&lt;</code><code class="s2">"Hello World!"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// "helloWorld!"</code></pre>&#13;
&#13;
<p>Next, we want to check if the remaining characters are valid. We again use recursion to take a string of valid characters, split them into single string types with only one character, and create a capitalized and uncapitalized version:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">StringSplit</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code> <code class="nx">T</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">Char</code><code class="si">}${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">Capitalize</code><code class="o">&lt;</code><code class="nx">Char</code><code class="o">&gt;</code> <code class="o">|</code> <code class="nx">Uncapitalize</code><code class="o">&lt;</code><code class="nx">Char</code><code class="o">&gt;</code> <code class="o">|</code> <code class="nx">StringSplit</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="kr">never</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Chars</code> <code class="o">=</code> <code class="nx">StringSplit</code><code class="o">&lt;</code><code class="s2">"abcdefghijklmnopqrstuvwxyz"</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="c1">//  "a" | "A" | "b" | "B" | "c" | "C" | "d" | "D" | "e" | "E" |</code>&#13;
<code class="c1">//  "f" | "F" | "g" | "G" | "h" | "H" | "i" | "I" | "j" | "J" |</code>&#13;
<code class="c1">//  "k" | "K" | "l" | "L" | "m" | "M" | "n" | "N" | "o" | "O" |</code>&#13;
<code class="c1">//  "p" | "P" | "q" | "Q" | "r" | "R" | "s" | "S" | "t" | "T" |</code>&#13;
<code class="c1">//  "u" | "U" | "v" | "V" | "w" | "W" | "x" | "X" | "y" | "Y" |</code>&#13;
<code class="c1">//  "z" | "Z"</code></pre>&#13;
&#13;
<p>We shave off the first character we find, capitalize it, uncapitalize it, and do the same with the rest until no more strings are left. Note that this recursion can’t be tail-call optimized, as we put the recursive call in a union type with the results from each recursion step. Here we would reach a recursion limit when we hit 50 characters (a hard limit from the TypeScript compiler). With basic characters, we are fine!</p>&#13;
&#13;
<p>But we hit the first limits when we are doing the next step, the creation of the <code>Identifier</code>. Here we check for valid characters. First, we call the <code>RemoveWhiteSpace&lt;T&gt;</code> type, which allows us to get rid of whitespaces and camel-cases the rest. Then we check the result against valid characters.</p>&#13;
&#13;
<p>Just like in <code>StringSplit&lt;T&gt;</code>, we shave off the first character but do another type-check within inference. We see if the character we just shaved off is one of the valid characters. Then we get the rest. We combine the same string again but do a recursive check with the remaining string. If the first character isn’t valid, then we call <code>Cr⁠ea⁠te​Id⁠en⁠ti⁠fie⁠r&lt;T&gt;</code> with the rest:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CreateIdentifier</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">RemoveWhiteSpace</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">A</code> <code class="kr">extends</code> <code class="nx">Chars</code><code class="si">}${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="sb">`</code><code class="si">${</code><code class="nx">A</code><code class="si">}${</code><code class="nx">CreateIdentifier</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">`</code>&#13;
<code class="c1">//  ^ Type instantiation is excessively deep and possibly infinite.(2589)_.</code>&#13;
  <code class="o">:</code> <code class="nx">RemoveWhiteSpace</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">A</code><code class="si">}${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">CreateIdentifier</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="nx">T</code><code class="p">;</code></pre>&#13;
&#13;
<p>And here we hit the first recursion limit. TypeScript warns us—with an error—that this type instantiation is possibly infinite and excessively deep. It seems that if we use the recursive call within a string template literal type, this might result in call stack errors and blow up. So TypeScript breaks. It can’t do tail-call optimization here.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><code>CreateIdentifier&lt;T&gt;</code> might still produce correct results, even though TypeScript errors when you write your type. Those are hard-to-spot bugs because they might hit you when you don’t expect them. Be sure to not let TypeScript produce any results when errors happen.</p>&#13;
</div>&#13;
&#13;
<p>There’s one way to work around it. To activate tail-call optimization, the recursive call needs to stand alone. We can achieve this by using the so-called <em>accumulator technique</em>. Here, we pass a second type parameter called <code>Acc</code>, which is of a type <code>string</code> and is instantiated with the empty string. We use this as an accumulator where we store the intermediate result, passing it over and over again to the next call:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">CreateIdentifier</code><code class="o">&lt;</code><code class="nx">T</code> <code class="kr">extends</code> <code class="kt">string</code><code class="p">,</code> <code class="nx">Acc</code> <code class="kr">extends</code> <code class="kt">string</code> <code class="o">=</code> <code class="s2">""</code><code class="o">&gt;</code> <code class="o">=</code>&#13;
  <code class="nx">RemoveWhiteSpace</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">A</code> <code class="kr">extends</code> <code class="nx">Chars</code><code class="si">}${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">CreateIdentifier</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="p">,</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Acc</code><code class="si">}${</code><code class="nx">A</code><code class="si">}</code><code class="sb">`</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="nx">RemoveWhiteSpace</code><code class="o">&lt;</code><code class="nx">T</code><code class="o">&gt;</code> <code class="kr">extends</code> <code class="sb">`</code><code class="si">${</code><code class="kr">infer</code> <code class="nx">A</code><code class="si">}${</code><code class="kr">infer</code> <code class="nx">Rest</code><code class="si">}</code><code class="sb">`</code>&#13;
  <code class="o">?</code> <code class="nx">CreateIdentifier</code><code class="o">&lt;</code><code class="nx">Rest</code><code class="p">,</code> <code class="nx">Acc</code><code class="o">&gt;</code>&#13;
  <code class="o">:</code> <code class="nx">Acc</code><code class="p">;</code></pre>&#13;
&#13;
<p>This way, the recursive call is standing on its own again, and the result is the second parameter. When we are done with recursive calls, the recursion-breaking branch, we return the accumulator, as it is our finished result:<a data-startref="ix_06-05-asciidoc5" data-type="indexterm" id="id713"/></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Identifier</code> <code class="o">=</code> <code class="nx">CreateIdentifier</code><code class="o">&lt;</code><code class="s2">"Hello Wor!ld!"</code><code class="o">&gt;</code><code class="p">;</code> <code class="c1">// "helloWorld"</code></pre>&#13;
&#13;
<p>There might be more clever ways to produce identifiers from any string, but note that the same thing can hit you deep down in any elaborate conditional type where you use recursion. The accumulator technique is a good way to mitigate problems like this.<a data-startref="ix_06-05-asciidoc4" data-type="indexterm" id="id714"/><a data-startref="ix_06-05-asciidoc3" data-type="indexterm" id="id715"/><a data-startref="ix_06-05-asciidoc2" data-type="indexterm" id="id716"/><a data-startref="ix_06-05-asciidoc1" data-type="indexterm" id="id717"/><a data-startref="ix_06-05-asciidoc0" data-type="indexterm" id="id718"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="6.6 Using Template Literals as Discriminants" data-type="sect1"><div class="sect1" id="ch06_template_literals_as_discriminants">&#13;
<h1>6.6 Using Template Literals as Discriminants</h1>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="id104">&#13;
<h2>Problem</h2>&#13;
&#13;
<p><a data-primary="backend requests" data-type="indexterm" id="ix_06-06-asciidoc0"/><a data-primary="discriminated union types" data-secondary="template literals as discriminants" data-type="indexterm" id="ix_06-06-asciidoc1"/><a data-primary="string template literal types" data-secondary="template literals as discriminants" data-type="indexterm" id="ix_06-06-asciidoc2"/><a data-primary="template literal types" data-secondary="as discriminants" data-type="indexterm" id="ix_06-06-asciidoc3"/>You model requests to a backend as a state machine, going from <em>pending</em> to either <em>error</em> or <em>success</em>. Those states should work for different backend requests, but the underlying types should be the same.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="id719">&#13;
<h2>Solution</h2>&#13;
&#13;
<p>Use string template literals as discriminants for a discriminated union.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="id105">&#13;
<h2>Discussion</h2>&#13;
&#13;
<p>The way you fetch data from a backend always follows the same structure. You do a request, and it’s pending to be either fulfilled and return some data—success—or rejected and return with an error. For example, to log in a user, all possible states can look like this:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">UserRequest</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">state</code><code class="o">:</code> <code class="s2">"USER_PENDING"</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">state</code><code class="o">:</code> <code class="s2">"USER_ERROR"</code><code class="p">;</code>&#13;
      <code class="nx">message</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">state</code><code class="o">:</code> <code class="s2">"USER_SUCCESS"</code><code class="p">;</code>&#13;
      <code class="nx">data</code><code class="o">:</code> <code class="nx">User</code><code class="p">;</code>&#13;
    <code class="p">};</code></pre>&#13;
&#13;
<p>When we fetch a user’s order, we have the same states available. The only difference is in the success payload and in the names of each state, which are tailored to the type of request:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">OrderRequest</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">state</code><code class="o">:</code> <code class="s2">"ORDER_PENDING"</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">state</code><code class="o">:</code> <code class="s2">"ORDER_ERROR"</code><code class="p">;</code>&#13;
      <code class="nx">message</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code>&#13;
      <code class="nx">state</code><code class="o">:</code> <code class="s2">"ORDER_SUCCESS"</code><code class="p">;</code>&#13;
      <code class="nx">data</code><code class="o">:</code> <code class="nx">Order</code><code class="p">;</code>&#13;
    <code class="p">};</code></pre>&#13;
&#13;
<p>When we deal with a global state handling mechanism, such as <a href="https://redux.js.org">Redux</a>, we want to differentiate by using identifiers like this. We still want to narrow it to the respective state types!</p>&#13;
&#13;
<p>TypeScript allows you to create discriminated union types where the discriminant is a string template literal type. So we can sum up all possible backend requests using the same pattern:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Pending</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_PENDING`</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Err</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_ERROR`</code><code class="p">;</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Success</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="kt">string</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_SUCCESS`</code><code class="p">;</code>&#13;
  <code class="nx">data</code><code class="o">:</code> <code class="kr">any</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">BackendRequest</code> <code class="o">=</code> <code class="nx">Pending</code> <code class="o">|</code> <code class="nx">Err</code> <code class="o">|</code> <code class="nx">Success</code><code class="p">;</code></pre>&#13;
&#13;
<p>This already gives us an edge. We know that the state property of each union type member needs to start with an uppercase string, followed by an underscore and &#13;
<span class="keep-together">the respective</span> state as a string. And we can narrow it to the subtypes just as we are &#13;
<span class="keep-together">used to:</span></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kd">function</code> <code class="nx">execute</code><code class="p">(</code><code class="nx">req</code><code class="o">:</code> <code class="nx">BackendRequest</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="k">switch</code> <code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">case</code> <code class="s2">"USER_PENDING"</code><code class="o">:</code>&#13;
      <code class="c1">// req: Pending</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Login pending..."</code><code class="p">);</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"USER_ERROR"</code><code class="o">:</code>&#13;
      <code class="c1">// req: Err</code>&#13;
      <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`Login failed: </code><code class="si">${</code><code class="nx">req</code><code class="p">.</code><code class="nx">message</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="k">case</code> <code class="s2">"USER_SUCCESS"</code><code class="o">:</code>&#13;
      <code class="c1">// req: Success</code>&#13;
      <code class="nx">login</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">data</code><code class="p">);</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"ORDER_PENDING"</code><code class="o">:</code>&#13;
      <code class="c1">// req: Pending</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Fetching orders pending"</code><code class="p">);</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
    <code class="k">case</code> <code class="s2">"ORDER_ERROR"</code><code class="o">:</code>&#13;
      <code class="c1">// req: Err</code>&#13;
      <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`Fetching orders failed: </code><code class="si">${</code><code class="nx">req</code><code class="p">.</code><code class="nx">message</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>&#13;
    <code class="k">case</code> <code class="s2">"ORDER_SUCCESS"</code><code class="o">:</code>&#13;
      <code class="c1">// req: Success</code>&#13;
      <code class="nx">displayOrder</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">data</code><code class="p">);</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Having the entire set of strings as the first part of the discriminant might be a bit too much. We can subset to a variety of known requests and use string manipulation types to get the right subtypes:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">RequestConstants</code> <code class="o">=</code> <code class="s2">"user"</code> <code class="o">|</code> <code class="s2">"order"</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Pending</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="nx">RequestConstants</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_PENDING`</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Err</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="nx">RequestConstants</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_ERROR`</code><code class="p">;</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Success</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="nx">RequestConstants</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_SUCCESS`</code><code class="p">;</code>&#13;
  <code class="nx">data</code><code class="o">:</code> <code class="kr">any</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>That’s how to get rid of typos! Even better, let’s say we store all data in a global state object of type <code>Data</code>. We can derive all possible <code>BackendRequest</code> types from here. By using <code>keyof Data</code>, we get the string keys that make up the <code>BackendRequest</code> state:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Data</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">user</code><code class="o">:</code> <code class="nx">User</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code>&#13;
  <code class="nx">order</code><code class="o">:</code> <code class="nx">Order</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">RequestConstants</code> <code class="o">=</code> <code class="kr">keyof</code> <code class="nx">Data</code><code class="p">;</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Pending</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="nx">RequestConstants</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_PENDING`</code><code class="p">;</code>&#13;
<code class="p">};</code>&#13;
&#13;
<code class="kr">type</code> <code class="nx">Err</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="nx">RequestConstants</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_ERROR`</code><code class="p">;</code>&#13;
  <code class="nx">message</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
&#13;
<p>This already works well for <code>Pending</code> and <code>Err</code>, but in the <code>Success</code> case we want to have the actual data type associated with <code>"user"</code> or <code>"order"</code>.</p>&#13;
&#13;
<p>A first option would be to use index access to get the correct types for the <code>data</code> property from <code>Data</code>:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Success</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="nx">RequestConstants</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_SUCCESS`</code><code class="p">;</code>&#13;
  <code class="nx">data</code><code class="o">:</code> <code class="nx">NonNullable</code><code class="o">&lt;</code><code class="nx">Data</code><code class="p">[</code><code class="nx">RequestConstants</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p><a data-primary="NonNullable&lt;T&gt;" data-type="indexterm" id="id720"/><code>NonNullable&lt;T&gt;</code> gets rid of <code>null</code> and <code>undefined</code> in a union type. With the compiler flag <code>strictNullChecks</code> on, both <code>null</code> and &#13;
<span class="keep-together"><code>undefined</code></span> are excluded from all types. This means you need to manually add them if you have nullish states and manually exclude them when you want to make sure that they don’t.</p>&#13;
</div>&#13;
&#13;
<p class="pagebreak-before">But this would mean that <code>data</code> can be both <code>User</code> or <code>Order</code> for all backend requests, and more if we add new ones. To avoid breaking the connection between the identifier and its associated data type, we map through all <code>RequestConstants</code>, create state objects, and then use index access of <code>RequestConstants</code> again to produce a union type:</p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Success</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="p">[</code><code class="nx">K</code> <code class="k">in</code> <code class="nx">RequestConstants</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code>&#13;
    <code class="nx">state</code><code class="o">:</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Uppercase</code><code class="o">&lt;</code><code class="nx">K</code><code class="o">&gt;</code><code class="si">}</code><code class="sb">_SUCCESS`</code><code class="p">;</code>&#13;
    <code class="nx">data</code><code class="o">:</code> <code class="nx">NonNullable</code><code class="o">&lt;</code><code class="nx">Data</code><code class="p">[</code><code class="nx">K</code><code class="p">]</code><code class="o">&gt;</code><code class="p">;</code>&#13;
  <code class="p">};</code>&#13;
<code class="p">}[</code><code class="nx">RequestConstants</code><code class="p">];</code></pre>&#13;
&#13;
<p><code>Success</code> is now equal to the manually created union type:<a data-startref="ix_06-06-asciidoc3" data-type="indexterm" id="id721"/><a data-startref="ix_06-06-asciidoc2" data-type="indexterm" id="id722"/><a data-startref="ix_06-06-asciidoc1" data-type="indexterm" id="id723"/><a data-startref="ix_06-06-asciidoc0" data-type="indexterm" id="id724"/></p>&#13;
&#13;
<pre data-code-language="typescript" data-type="programlisting"><code class="kr">type</code> <code class="nx">Success</code> <code class="o">=</code> <code class="p">{</code>&#13;
    <code class="nx">state</code><code class="o">:</code> <code class="s2">"USER_SUCCESS"</code><code class="p">;</code>&#13;
    <code class="nx">data</code><code class="o">:</code> <code class="nx">User</code><code class="p">;</code>&#13;
<code class="p">}</code> <code class="o">|</code> <code class="p">{</code>&#13;
    <code class="nx">state</code><code class="o">:</code> <code class="s2">"ORDER_SUCCESS"</code><code class="p">;</code>&#13;
    <code class="nx">data</code><code class="o">:</code> <code class="nx">Order</code><code class="p">;</code>&#13;
<code class="p">};</code></pre>&#13;
</div></section>&#13;
</div></section>&#13;
</div></section></body></html>