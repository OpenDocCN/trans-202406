["```\n// There is only one navigation performance entry.\nconst [navigation] = window.performance.getEntriesByType('navigation');\n```", "```\nconst entries = window.performance.getEntriesByType('resource');\n```", "```\nconst slowestResources = window.performance.getEntriesByType('resource')\n  .sort((a, b) =>\n    (b.responseEnd - b.startTime) - (a.responseEnd - a.startTime))\n  .slice(0, 5);\n```", "```\nconst fastestResources = window.performance.getEntriesByType('resource')\n  .sort((a, b) =>\n    (a.responseEnd - a.startTime) - (b.responseEnd - b.startTime))\n  .slice(0, 5);\n```", "```\n// Look up all requests to the /api/users API\nconst entries = window.performance.getEntriesByName('https://localhost/api/users',\n'resource');\n```", "```\n// Create the initial performance mark just before rendering.\nwindow.performance.mark('render-start');\n\n// Create the component and render the data.\nconst dataView = new DataView();\ndataView.render(data);\n\n// When rendering is done, create the ending performance mark.\nwindow.performance.mark('render-end');\n\n// Create a measure between the two marks.\nconst measure = window.performance.measure('render', 'render-start', 'render-end');\n```", "```\n// There is only one 'render' measure, so you can use\n// array destructuring to get the first (and only) entry.\nconst [renderMeasure] = window.performance.getEntriesByName('render');\n```", "```\n// Create the initial performance mark just before rendering.\nwindow.performance.mark('render-start');\n\n// Create the component and render the data.\nconst dataView = new DataView();\ndataView.render(data);\n\n// When rendering is done, create the ending performance mark.\nwindow.performance.mark('render-end');\n\n// Create a measure between the two marks, passing the\n// data being rendered as the measure detail.\nconst measure = window.performance.measure('render', {\n  start: 'render-start',\n  end: 'render-end',\n  detail: data\n});\n```", "```\nwindow.performance.mark('transactions-start');\nconst transactions = await fetch('/api/users/123/transactions');\nwindow.performance.mark('transactions-end');\nwindow.performance.mark('process-start');\nconst analytics = processAnalytics(transactions);\nwindow.performance.mark('process-end');\nwindow.performance.mark('upload-start');\nawait fetch('/api/analytics', {\n  method: 'POST',\n  body: JSON.stringify(analytics),\n  headers: {\n    'Content-Type': 'application/json'\n  }\n});\nwindow.performance.mark('upload-end');\n```", "```\nconsole.log('Download transactions:',\n  window.performance.measure(\n    'transactions', 'transactions-start', 'transactions-end'\n  ).duration\n);\n\nconsole.log('Process analytics:',\n  window.performance.measure(\n    'analytics', 'process-start', 'process-end'\n  ).duration\n);\n\nconsole.log('Upload analytics:',\n  window.performance.measure(\n    'upload', 'upload-start', 'upload-end'\n  ).duration\n);\n\nconsole.log('Total time:',\n  window.performance.measure(\n    'total', 'transactions-start', 'upload-end'\n  ).duration\n);\n```", "```\nconst analyticsEndpoint = 'https://example.com/api/analytics';\n\nconst observer = new PerformanceObserver(entries => {\n  for (let entry of entries.getEntries()) {\n    // Only interested in 'fetch' entries.\n    // Use the Beacon API to send a quick request containing the performance\n    // entry data.\n    if (entry.initiatorType === 'fetch') {\n      navigator.sendBeacon(analyticsEndpoint, entry);\n    }\n  }\n});\n\nobserver.observe({ type: 'resource' });\n```", "```\nconst analyticsEndpoint = 'https://example.com/api/analytics';\n\n// An array to hold buffered entries. Once the buffer reaches the desired size,\n// all entries are sent in a single request.\nconst BUFFER_SIZE = 10;\nlet buffer = [];\n\nconst observer = new PerformanceObserver(entries => {\n  for (let entry of entries.getEntries()) {\n    if (entry.initiatorType === 'fetch' && entry.name !== analyticsEndpoint) {\n      buffer.push(entry);\n    }\n\n    // If the buffer has reached its target size, send the analytics request.\n    if (buffer.length === BUFFER_SIZE) {\n      fetch(analyticsEndpoint, {\n        method: 'POST',\n        body: JSON.stringify(buffer),\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n\n      // Reset the buffer now that the batched entries have been sent.\n      buffer = [];\n    }\n  }\n});\n\nobserver.observe({ type: 'resource' });\n```"]