- en: Chapter 13\. Rendering Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we moved to more interactive websites, the number of events handled and the
    amount of content rendered on the client side grew, resulting in SPAs rendered
    primarily on the client, as in the case of React.js.
  prefs: []
  type: TYPE_NORMAL
- en: However, web pages can be as static or dynamic as the function they serve. We
    continue to serve a lot of static content on the web, for example, blog/news pages
    that you can generate on the server and push as-is to the clients. Static content
    is stateless, does not fire events, and does not need rehydration after rendering.
    Conversely, dynamic content (buttons, filters, search bar) has to be rewired to
    its events after rendering. The DOM has to be regenerated on the client side (virtual
    DOM). This regeneration, rehydration, and event handling functions contribute
    to the JavaScript sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Rendering pattern provides the ideal solution for rendering content for a
    given use case. The Rendering patterns in this table are popular:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Rendering patterns** |  |'
  prefs: []
  type: TYPE_TB
- en: '| *Client-side rendering (CSR)* | HTML is rendered completely on the client
    |'
  prefs: []
  type: TYPE_TB
- en: '| *Server-side rendering (SSR)* | Dynamically rendering HTML content on the
    server before rehydrating it on the client |'
  prefs: []
  type: TYPE_TB
- en: '| *Static rendering* | Building a static site to render pages on the server
    at build time |'
  prefs: []
  type: TYPE_TB
- en: '| *Incremental static generation* | Being able to dynamically augment or modify
    a static site even after the initial build (Next.js ISR, Gatsby DSG) |'
  prefs: []
  type: TYPE_TB
- en: '| *Streaming SSR* | Breaking down server-rendered content into smaller streamed
    chunks |'
  prefs: []
  type: TYPE_TB
- en: '| *Edge rendering* | Altering rendered HTML at the edge before sending it on
    to the client |'
  prefs: []
  type: TYPE_TB
- en: '| *Hybrid rendering* | Combines build-time, server, and client rendering to
    create a more flexible approach to web development (e.g., React Server Components
    and Next.js App Router) |'
  prefs: []
  type: TYPE_TB
- en: '| *Partial hydration* | Only hydrating some of your components on the client
    (e.g., React Server Components and Gatsby) |'
  prefs: []
  type: TYPE_TB
- en: '| *Progressive hydration* | Controlling the order of component hydration on
    the client |'
  prefs: []
  type: TYPE_TB
- en: '| *Islands architecture* | Isolated islands of dynamic behavior with multiple
    entry points in an otherwise static site (Astro, Eleventy) |'
  prefs: []
  type: TYPE_TB
- en: '| *Progressive enhancement* | Making sure an app is functional even without
    JavaScript |'
  prefs: []
  type: TYPE_TB
- en: 'This chapter introduces some of these Rendering patterns and will help you
    decide which pattern is most suitable for your needs. It will help you make foundational
    decisions such as:'
  prefs: []
  type: TYPE_NORMAL
- en: How and where do I want to render content?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should content be rendered on the web server, on the build server, on an edge
    network, or directly on the client?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should content be rendered all at once, partially, or progressively?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importance of Rendering Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Choosing the most suitable Rendering pattern for a given use case can make a
    world of difference to the developer experience (DX) you create for the engineering
    team and the UX you design for your end users. Choosing the correct pattern could
    lead to faster builds and excellent loading performance at low processing costs.
    On the other hand, a wrong choice of pattern can kill an app that could have brought
    to life a great business idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create great UX, we must optimize our apps for user-centric metrics, such
    as the [Core Web Vitals (CWV)](https://oreil.ly/R20lq):'
  prefs: []
  type: TYPE_NORMAL
- en: Time to First Byte (TTFB)
  prefs: []
  type: TYPE_NORMAL
- en: Time it takes for a client to receive the first byte of page content
  prefs: []
  type: TYPE_NORMAL
- en: First Contentful Paint(FCP)
  prefs: []
  type: TYPE_NORMAL
- en: Time it takes the browser to render the first piece of content after navigation
  prefs: []
  type: TYPE_NORMAL
- en: Time to Interactive (TTI)
  prefs: []
  type: TYPE_NORMAL
- en: Time from when the page starts loading to when it responds quickly to user input
  prefs: []
  type: TYPE_NORMAL
- en: Largest Contentful Paint (LCP)
  prefs: []
  type: TYPE_NORMAL
- en: Time it takes to load and render the page’s main content
  prefs: []
  type: TYPE_NORMAL
- en: Cumulative Layout Shift (CLS)
  prefs: []
  type: TYPE_NORMAL
- en: Measures visual stability to avoid unexpected layout shift
  prefs: []
  type: TYPE_NORMAL
- en: First Input Delay (FID)
  prefs: []
  type: TYPE_NORMAL
- en: Time from when the user interacts with the page to the time when the event handlers
    can run
  prefs: []
  type: TYPE_NORMAL
- en: The CWV metrics measure parameters most relevant to UX. Optimizing the CWV can
    ensure a great UX and optimal search engine optimization (SEO) for our apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a great DX for our product/engineering teams, we have to optimize
    our development environments by ensuring faster build times, easy rollbacks, scalable
    infrastructure, and many other features that help developers succeed:'
  prefs: []
  type: TYPE_NORMAL
- en: Fast build times
  prefs: []
  type: TYPE_NORMAL
- en: The project should build fast for quick iteration and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Low server costs
  prefs: []
  type: TYPE_NORMAL
- en: The website should limit and optimize the server execution time to reduce execution
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic content
  prefs: []
  type: TYPE_NORMAL
- en: The page should be able to load dynamic content performantly.
  prefs: []
  type: TYPE_NORMAL
- en: Easy rollbacks
  prefs: []
  type: TYPE_NORMAL
- en: You can quickly revert to a previous build version and deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Reliable uptime
  prefs: []
  type: TYPE_NORMAL
- en: Users should always be able to visit your website through operational servers.
  prefs: []
  type: TYPE_NORMAL
- en: Scalable infrastructure
  prefs: []
  type: TYPE_NORMAL
- en: Your project may grow or shrink without facing performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a development environment based on these principles enables our development
    teams to build a great product efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: We have now built quite a long list of expectations. But, if you choose the
    correct Rendering pattern, you can get most of these benefits automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering patterns have come a long way, from SSR and CSR to highly nuanced
    patterns discussed and judged today on different forums. While this can get overwhelming,
    it’s important to remember that every pattern was designed to address specific
    use cases. A pattern characteristic beneficial for one use case can be detrimental
    in the case of another. It is also quite likely that different types of pages
    require different Rendering patterns on the same website.
  prefs: []
  type: TYPE_NORMAL
- en: The Chrome team has encouraged developers to consider static or SSR over a full
    rehydration approach. Over time, progressive loading and rendering techniques
    may help strike a good balance of performance and feature delivery when using
    a modern framework.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections cover different patterns in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Client-Side Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already discussed CSR with React in the previous chapter. Here is a
    brief overview to help us relate it to the other Rendering patterns.
  prefs: []
  type: TYPE_NORMAL
- en: With React CSR, most of the application logic is executed on the client, and
    it interacts with the server through API calls to fetch or save data. Almost all
    of the UI is thus generated on the client. The entire web application is loaded
    on the first request. As the user navigates by clicking on links, no new request
    is generated to the server for rendering the pages. The code runs on the client
    to change the view/data.
  prefs: []
  type: TYPE_NORMAL
- en: CSR allows us to have an SPA that supports navigation without page refresh and
    provides a great UX. As the data processed to change the view is limited, routing
    between pages is generally faster, making the CSR application seem more responsive.
  prefs: []
  type: TYPE_NORMAL
- en: As the complexity of the page increases to show images, display data from a
    data store, and include event handling, the complexity and size of the JavaScript
    code required to render the page will also increase. CSR resulted in large JavaScript
    bundles, which increased the FCP and TTI of the page. Large payloads and a waterfall
    of network requests (e.g., for API responses) may also result in meaningful content
    not being rendered fast enough for a crawler to index it. This can affect the
    SEO of the website.
  prefs: []
  type: TYPE_NORMAL
- en: 'Loading and processing excess JavaScript can hurt performance. However, some
    interactivity and JavaScript are often required, even on primarily static websites.
    The rendering techniques discussed in the following sections try to find a balance
    between:'
  prefs: []
  type: TYPE_NORMAL
- en: Interactivity comparable to CSR applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SEO and performance benefits that are comparable to SSR applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-Side Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With SSR, we generate the HTML for every request. This approach is most suitable
    for pages containing highly personalized data, for example, data based on the
    user cookie or generally any data obtained from the user’s request. It’s also
    suitable for pages that should be render-blocking, perhaps based on the authentication
    state.
  prefs: []
  type: TYPE_NORMAL
- en: SSR is one of the oldest methods of rendering web content. SSR generates the
    complete HTML for the page content to be rendered in response to a user request.
    The content may include data from a data store or external API.
  prefs: []
  type: TYPE_NORMAL
- en: The connect and fetch operations are handled on the server. HTML required to
    format the content is also generated on the server. Thus, with SSR, we can avoid
    making additional round trips for data fetching and templating. As such, rendering
    code is not required on the client and the JavaScript corresponding to this need
    not be sent to the client.
  prefs: []
  type: TYPE_NORMAL
- en: With SSR, every request is treated independently and processed as a new request
    by the server. Even if the output of two consecutive requests is not very different,
    the server will process and generate it from scratch. Since the server is common
    to multiple users, the processing capability is shared by all active users at
    a given time.
  prefs: []
  type: TYPE_NORMAL
- en: A personalized dashboard is an excellent example of highly dynamic content on
    a page. Most of the content is based on the user’s identity or authorization level
    that may be contained in a user cookie. This dashboard shows only when a user
    is authenticated and possibly shows user-specific sensitive data that should not
    be visible to others.
  prefs: []
  type: TYPE_NORMAL
- en: The core principle for SSR is that HTML is rendered on the server and shipped
    with the necessary JavaScript to rehydrate it on the client. Rehydration is regenerating
    the state of UI components on the client side after the server renders it. Since
    rehydration comes at a cost, each variation of SSR tries to optimize the rehydration
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Static Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With static rendering, the HTML for the entire page gets generated at build
    time and does not change until the next build. The HTML content is static and
    easily cacheable on a content delivery network (CDN) or an edge network. CDNs
    can quickly serve the prerendered cached HTML to clients when they request a specific
    page. This considerably cuts down the time it would otherwise take to process
    the request, render HTML content, and respond to a request in a typical SSR setup.
  prefs: []
  type: TYPE_NORMAL
- en: This process is most suitable for pages that do not change often and display
    the same data no matter who requests them. Static pages like the “About us,” “Contact
    us,” and “Blog” pages for websites, or product pages for ecommerce apps are ideal
    candidates for static rendering. Frameworks like Next.js, Gatsby, and VuePress
    support static generation.
  prefs: []
  type: TYPE_NORMAL
- en: 'At its core, plain static rendering does not involve any dynamic data. Let
    us understand it using a Next.js example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When the site is built (using `next build`), this page will be prerendered into
    an HTML file *about.html* accessible at the route */about*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can have several variations of static rendering as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Static generation of a listing page with dynamic data from a database
  prefs: []
  type: TYPE_NORMAL
- en: The listing page is generated on the server with the data. This is suitable
    for pages where the listing itself is not very dynamic. In Next.js, you can export
    the function [`getStaticProps()`](https://oreil.ly/QcNhk) in the page component
    for this.
  prefs: []
  type: TYPE_NORMAL
- en: Static generation of detail pages with dynamic routes
  prefs: []
  type: TYPE_NORMAL
- en: Product pages or blog pages usually follow a fixed template with data populated
    in placeholders. In this case, individual pages can be generated on the server
    by merging the template with the dynamic data giving us several individual routes
    for each detailed page. The Next.js [dynamic routes](https://oreil.ly/2Bugb) feature
    helps to achieve this using the `getStaticPaths()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Static rendering with client-side fetch
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is helpful for a reasonably dynamic listing page that should display
    fresh listings always. You can still use static rendering for the website to render
    the UI with a skeleton component where you want to place the dynamic listing data.
    Then, after the page has loaded, we can fetch the data using SWR. SWR (inspired
    by the Stale-While-Revalidate pattern) are React Hooks for data fetching. A custom
    API route is used to fetch the data from the CMS and return this data. The pregenerated
    HTML file is sent to the client when the user requests the page. The user initially
    sees the skeleton UI without any data. The client fetches the data from the API
    route, receives the response, and shows the listings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key highlights of static rendering include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML gets generated at build time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily cacheable by CDN/Vercel Edge Network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plain static rendering is best for pages that do not require request-based data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static with client-side fetch is best for pages that contain data that should
    refresh on every page load and is contained in stable placeholder components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incremental Static Regeneration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: ISR is a hybrid of static and SSR because it allows us to prerender only certain
    static pages and render the dynamic pages on-demand when the user requests them.
    This results in shorter build times and allows automatic invalidation of the cache
    and regeneration of the page after a specific interval.
  prefs: []
  type: TYPE_NORMAL
- en: 'ISR works on two fronts to incrementally introduce updates to an existing static
    site after it has been built:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows addition of new pages
  prefs: []
  type: TYPE_NORMAL
- en: The lazy-loading concept is used to include new pages on the website after the
    build. This means that the new page is generated immediately on the first request.
    While the generation takes place, a fallback page or a loading indicator can be
    shown to the user on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: Update existing pages
  prefs: []
  type: TYPE_NORMAL
- en: A suitable timeout is defined for every page. This will ensure that the page
    is revalidated whenever the defined timeout period has elapsed. The timeout could
    be set to as low as 1 second. The user will continue to see the previous version
    of the page until the page has finished revalidation. Thus, ISR uses the stale-while-revalidate
    strategy, where the user receives the cached or stale version while the revalidation
    takes place. The revalidation occurs entirely in the background and does not need
    a full rebuild.
  prefs: []
  type: TYPE_NORMAL
- en: On-Demand ISR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this variation of ISR, the regeneration occurs on certain events rather than
    at fixed intervals. With regular ISR, the updated page is cached only at the edge
    nodes that have handled user requests for the page. On-demand ISR regenerates
    and redistributes the page across the edge network so that users worldwide will
    automatically see the most recent version of the page from the edge cache without
    seeing stale content. We also avoid unnecessary regenerations and serverless function
    calls, reducing operational costs compared to regular ISR. Thus on-demand ISR
    gives us performance benefits and a great DX. On-demand ISR is best for pages
    that should be regenerated based on specific events. It allows us to have fast
    and dynamic websites that are always online at a reasonable cost.
  prefs: []
  type: TYPE_NORMAL
- en: Summary of Static Rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Static rendering is an excellent pattern for websites where HTML can be generated
    at build time. We have now covered different variations of static generation,
    each of which is suitable for different use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Plain static rendering
  prefs: []
  type: TYPE_NORMAL
- en: Best for pages that do not contain dynamic data
  prefs: []
  type: TYPE_NORMAL
- en: Static with client-side fetch
  prefs: []
  type: TYPE_NORMAL
- en: Best for pages where data should refresh on every page load and which have stable
    placeholder components
  prefs: []
  type: TYPE_NORMAL
- en: Incremental static regeneration
  prefs: []
  type: TYPE_NORMAL
- en: Best for pages that should be regenerated on a certain interval or on-demand
  prefs: []
  type: TYPE_NORMAL
- en: On-demand ISR
  prefs: []
  type: TYPE_NORMAL
- en: Best for pages that should be regenerated based on certain events
  prefs: []
  type: TYPE_NORMAL
- en: There are use cases where static isn’t the best option. For example, SSR is
    ideal for highly dynamic, personalized pages that are different for every user.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming SSR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With SSR or static rendering, you can reduce the amount of JavaScript so that
    the time taken for the page to become interactive (TTI) is closer to the time
    for FCP. Streaming the contents can reduce the TTI/FCP further while still server-rendering
    the application. Instead of generating one large HTML file containing the necessary
    markup for the current navigation, we can split it into smaller chunks. Node streams
    allow us to stream data into the response object, which means we can continuously
    send data down to the client. When the client receives the chunks of data, it
    can start rendering the contents.
  prefs: []
  type: TYPE_NORMAL
- en: React’s built-in `renderToNodeStream` allows us to send our application in smaller
    chunks. As the client can start painting the UI when it’s still receiving data,
    we can create a very performant first-load experience. Calling the `hydrate` method
    on the received DOM nodes will attach the corresponding event handlers, which
    makes the UI interactive.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming responds well to network backpressure. If the network is clogged and
    unable to transfer any more bytes, the renderer gets a signal and stops streaming
    until the network is cleared up. Thus, the server uses less memory and is more
    responsive to I/O conditions. This enables your Node.js server to render multiple
    requests simultaneously and prevents heavier requests from blocking lighter requests
    for a long time. As a result, the site stays responsive even in challenging conditions.
  prefs: []
  type: TYPE_NORMAL
- en: 'React introduced support for streaming in React 16, released in 2016\. It included
    the following APIs in the `ReactDOMServer` to support streaming:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactDOMServer.renderToNodeStream(element)`'
  prefs: []
  type: TYPE_NORMAL
- en: The output HTML from this function is the same as `ReactDOMServer.renderToString(element)`
    but is in a Node.js `ReadableStream` format instead of a string. The function
    will only work on the server to render HTML as a stream. The client receiving
    this stream can call `ReactDOM.hydrate()` to hydrate the page and make it interactive.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReactDOMServer.renderToStaticNodeStream(element)`'
  prefs: []
  type: TYPE_NORMAL
- en: This corresponds to `ReactDOMServer.renderToStaticMarkup(element)`. The HTML
    output is the same but in a stream format. You can use it to render static, noninteractive
    pages on the server and then stream them to the client.
  prefs: []
  type: TYPE_NORMAL
- en: The readable stream output by both functions can emit bytes once you start reading
    from it. You can achieve this by piping the readable stream to a writable stream,
    such as the response object. The response object progressively sends chunks of
    data to the client while waiting for new chunks to be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Edge SSR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Edge SSR enables you to server-render from all regions of a CDN and experience
    a near-zero cold boot.
  prefs: []
  type: TYPE_NORMAL
- en: Serverless functions can be used to generate the entire page server-side. The
    edge runtime also allows HTTP streaming so that you can stream parts of the document
    as soon as they are ready and hydrate these components granularly. This reduces
    the time to FCP.
  prefs: []
  type: TYPE_NORMAL
- en: A use case for this pattern is building region-specific listing pages for users.
    The majority of the page contains only static data; it’s just the listings that
    require request-based data. Instead of server-rendering the entire page, we can
    now choose to render only the listing component server-side and the rest edge-side.
    Whereas we initially had to server-render the whole page to achieve this behavior,
    we can now get the excellent performance of static rendering on the edge with
    the dynamic benefits of SSR.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, hybrid rendering combines different approaches to focus
    on delivering an optimal result. It represents a mental shift in how developers
    approach web development, moving from a client-only starting point to a more versatile
    combination of rendering strategies. Pages that can be served statically will
    be prerendered. A dynamic strategy may be chosen for other pages in the app (e.g.,
    ISR or SSR or CSR and streaming for subsequent navigations).
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid rendering conceptually challenges traditional terminology (SPA, MPA,
    SSR, SSG) and emphasizes the need for new verbiage to describe modern web development
    practices better. A web app need not be classified as an SPA or MPA anymore. It
    can easily transition from one to the other based on the function served. Thus,
    it provides the benefits of SPAs (no server needed) while avoiding issues with
    static rendering (navigation without page reloads).
  prefs: []
  type: TYPE_NORMAL
- en: The shift in focus is not from writing SPAs to not writing SPAs but rather from
    being locked into SPAs to using whatever rendering mode makes sense for each page,
    thus entering the hybrid era. This shift is primarily mental, where developers
    start with build-time and client rendering and add server rendering as needed
    on a per-page basis.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the web development landscape converges toward hybrid rendering, we see
    that many frameworks, both within and outside the React universe, have started
    supporting it. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: Next.js 13 combines React Server Components and the [Next.js App Router](https://oreil.ly/UEnVf)
    to demonstrate the potential of hybrid rendering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Astro 2.0](https://oreil.ly/Sbfu8) brings the best of both static and dynamic
    rendering instead of choosing between SSG and SSR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Angular Universal 11.1](https://oreil.ly/g076-) has native hybrid rendering
    support. It can perform prerendering (SSG) for static routes and SSR for dynamic
    routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Nuxt 3.0](https://oreil.ly/gCriy) lets you configure route rules for hybrid
    rendering support.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progressive Hydration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Progressive hydration implies you can individually hydrate nodes over time so
    that you request only the minimum necessary JavaScript at any time. By progressively
    hydrating the application, we can delay the hydration of less critical parts of
    the page.
  prefs: []
  type: TYPE_NORMAL
- en: This way, we reduce the amount of JavaScript requested to make the page interactive
    and only hydrate the nodes once the user needs them, for example, when a component
    is visible in the viewport. Progressive hydration also helps avoid the most common
    SSR rehydration pitfalls, where a server-rendered DOM tree is destroyed and immediately
    rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea behind progressive hydration is to provide excellent performance by
    activating your app in chunks. Any progressive hydration solution should also
    consider how it will impact the overall UX. You cannot have chunks of the screen
    popping up one after the other and blocking any activity or user input on the
    chunks that have already loaded. Thus, the requirements for a holistic progressive
    hydration implementation are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Allows usage of SSR for all components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports splitting of code into individual components or chunks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supports client-side hydration of these chunks in a developer-defined sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does not block user input on chunks that are already hydrated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows usage of some loading indicator for chunks with deferred hydration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: React concurrent mode will address all these requirements once it is available.
    It allows React to work on different tasks simultaneously and switch between them
    based on the given priority. When switching, a partially rendered tree need not
    be committed so that the rendering task can continue once React switches back
    to the same task.
  prefs: []
  type: TYPE_NORMAL
- en: Concurrent mode can be used to implement progressive hydration. In this case,
    the hydration of each chunk on the page becomes a task for React concurrent mode.
    If a task of higher priority, like user input, needs to be performed, React will
    pause the hydration task and switch to accepting the user input. Features like
    `lazy()` and `Suspense()` allow you to use declarative loading states. These can
    be used to show the loading indicator while chunks are lazy-loaded. `SuspenseList()`
    can be used to define the priority for lazy-loading components. Dan Abramov has
    shared a great [demo](https://oreil.ly/JHhPm) that shows the concurrent mode in
    action and implements progressive hydration.
  prefs: []
  type: TYPE_NORMAL
- en: Islands Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Katie Sylor-Miller and Jason Miller popularized the term [Islands architecture](https://oreil.ly/CYhom)
    to describe a paradigm that aims to reduce the volume of JavaScript shipped through
    “islands” of interactivity that can be independently delivered on top of otherwise
    static HTML. Islands are a component-based architecture that suggests a compartmentalized
    page view with static and dynamic islands. Most pages are a combination of static
    and dynamic content. Usually, a page consists of static content with sprinkles
    of interactive regions that you can demarcate. The static regions of the page
    are pure noninteractive HTML and do not need hydration. The dynamic regions are
    a combination of HTML and scripts capable of rehydrating themselves after rendering.
  prefs: []
  type: TYPE_NORMAL
- en: The Islands architecture facilitates SSR of pages with all of their static content.
    However, in this case, the rendered HTML will include placeholders for dynamic
    content. The dynamic content placeholders contain self-contained component widgets.
    Each widget is similar to an app and combines server-rendered output and JavaScript
    to hydrate the app on the client.
  prefs: []
  type: TYPE_NORMAL
- en: Islands architecture may be confused with progressive hydration, but there are
    pretty distinct. In progressive hydration, the hydration architecture of the page
    is top-down. The page controls the scheduling and hydration of individual components.
    Each component has its hydration script in the Islands architecture that executes
    asynchronously, independent of any other script on the page. A performance issue
    in one component should not affect the other.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Islands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Island architecture borrows concepts from different sources and aims to
    combine them optimally. Template-based static site generators such as [Jekyll](https://oreil.ly/dlxdC)
    and [Hugo](https://oreil.ly/WOKTz) support rendering static components to pages.
    Most modern JavaScript frameworks also support [isomorphic rendering](https://oreil.ly/mre3v),
    which allows you to use the same code to render elements on the server and client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jason Miller’s post suggests using [`requestIdleCallback()`](https://oreil.ly/x7dpf)
    to implement a scheduling approach for hydrating components. A framework that
    supports Islands architecture should do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Support static rendering of pages on the server with zero JavaScript.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support embedding independent dynamic components via placeholders in static
    content. Each dynamic component contains its scripts and can hydrate itself using
    `requestIdleCallback()` as soon as the main thread is free.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow isomorphic rendering of components on the server with hydration on the
    client to recognize the same component at both ends.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following frameworks support this to some extent at present:'
  prefs: []
  type: TYPE_NORMAL
- en: Marko
  prefs: []
  type: TYPE_NORMAL
- en: '[Marko](https://oreil.ly/-l3QP) is an open source framework developed and maintained
    by eBay to improve server rendering performance. It supports Islands architecture
    by combining streaming rendering with automatic partial hydration. HTML and other
    static assets are streamed to the client as soon as they are ready. Automatic
    partial hydration allows interactive components to hydrate themselves. Hydration
    code is only shipped for interactive components, which can change state on the
    browser. It is isomorphic, and the Marko compiler generates optimized code depending
    on where it will run (client or server).'
  prefs: []
  type: TYPE_NORMAL
- en: Astro
  prefs: []
  type: TYPE_NORMAL
- en: '[Astro](https://oreil.ly/QT77v) is a static site builder that can generate
    lightweight static HTML pages from UI components built in other frameworks such
    as React, Preact, Svelte, Vue, and others. Components that need client-side JavaScript
    are loaded individually with their dependencies. Thus it provides built-in partial
    hydration. Astro can also lazy-load components depending on when they become visible.'
  prefs: []
  type: TYPE_NORMAL
- en: Eleventy + Preact
  prefs: []
  type: TYPE_NORMAL
- en: '[Markus Oberlehner](https://oreil.ly/PBckZ) demonstrates the use of Eleventy
    (11ty), a static site generator with isomorphic Preact components that can be
    partially hydrated. It also supports lazy hydration. The component itself declaratively
    controls its hydration. Interactive components use a `WithHydration` wrapper so
    that they are hydrated on the client.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that Marko and Eleventy predate the definition of Islands provided by Jason
    but contain some of the features required to support it. Astro, however, was built
    based on the definition and inherently supports the Islands architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Pros and Cons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the potential benefits of implementing islands are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs: []
  type: TYPE_NORMAL
- en: Reduces the amount of JavaScript code shipped to the client. The code sent consists
    only of the script required for interactive components. This is considerably less
    than the script needed to re-create the virtual DOM for the entire page and rehydrate
    all the elements. The smaller size of JavaScript automatically corresponds to
    faster page loads.
  prefs: []
  type: TYPE_NORMAL
- en: SEO
  prefs: []
  type: TYPE_NORMAL
- en: Since all the static content is rendered on the server, pages are SEO-friendly.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritization of important content
  prefs: []
  type: TYPE_NORMAL
- en: Key content (especially for blogs, news articles, and product pages) is available
    almost immediately to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Accessibility
  prefs: []
  type: TYPE_NORMAL
- en: Using standard static HTML links to access other pages helps to improve the
    accessibility of the website.
  prefs: []
  type: TYPE_NORMAL
- en: Component-based
  prefs: []
  type: TYPE_NORMAL
- en: The design offers all advantages of component-based architecture, such as reusability
    and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: Despite the advantages, the concept is still in a nascent stage. The only options
    for developers to implement Islands are to use one of the few available frameworks
    or develop the architecture yourself. Migrating existing sites to Astro or Marko
    would require additional efforts. The architecture is also unsuitable for highly
    interactive pages like social media apps that would probably require thousands
    of islands.
  prefs: []
  type: TYPE_NORMAL
- en: React Server Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[React Server Components (RSC)](https://oreil.ly/nYygy) are stateless React
    components designed to run on the server. They aim to enable modern UX with a
    server-driven mental model. These zero-bundle-size components facilitate a seamless
    code transition experience, or “knitting”, between server and client components.
    This differs from the SSR of components and could result in significantly smaller
    client-side JavaScript bundles.'
  prefs: []
  type: TYPE_NORMAL
- en: RSC uses `async`/`await` as the primary way to fetch data from Server Components.
    They let you incorporate data fetching as an integral part of the component tree,
    allowing for top-level `await` and server-side data serialization. Components
    can thus be refetched regularly. An application with components that re-render
    when there is new data can be run on the server, limiting how much code needs
    to be sent to the client. This combines the rich interactivity of client-side
    apps with the improved performance of traditional server rendering.
  prefs: []
  type: TYPE_NORMAL
- en: RSC protocol enables the server to expose a special endpoint for the client
    to request parts of the component tree, allowing for SPA-like routing with MPA-like
    architecture. This allows merging the server component tree with the client-side
    tree without a loss of state and enables scaling up to more components.
  prefs: []
  type: TYPE_NORMAL
- en: Server Components are not a replacement for SSR. When paired together, they
    support quickly rendering in an intermediate format, then having SSR infrastructure
    rendering this into HTML, enabling early paints to still be fast. We SSR the Client
    Components, which the Server Components emit, similar to how SSR is used with
    other data-fetching mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: RSC provides the specification for components. Adoption of RSC depends on frameworks
    implementing the feature. It is technically possible to use RSC with any React
    framework, enabling React’s own flavor of [partial hydration](https://oreil.ly/CTvSX)
    with an end-state of hybrid rendering. Next.js has already introduced support
    through its App Router feature. The React team believes RSC will eventually be
    widely adopted and change the ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Hybrid Rendering with RSC and the Next.js App Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next.js 13 introduced the [App Router](https://oreil.ly/2fkjH) with new features,
    conventions, and support for RSC. Components in the app directory are RSC by default,
    promoting automatic adoption and improved performance.
  prefs: []
  type: TYPE_NORMAL
- en: RSC provide benefits such as leveraging server infrastructure and keeping large
    dependencies server-side, leading to better performance and reduced client-side
    bundle size. The Next.js App Router combines server rendering and client-side
    interactivity, progressively enhancing the application for a seamless user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Client Components can be added to introduce client-side interactivity, similar
    to the functionality in Next.js 12 and earlier versions. The “use client” directive
    can mark components as Client Components. Components without the “use client”
    directive are automatically rendered as Server Components if not imported by another
    Client Component.
  prefs: []
  type: TYPE_NORMAL
- en: Server and Client Components can be interleaved in the same component tree,
    with React handling the merge of both environments. Next.js users have seen [performance
    improvements](https://oreil.ly/sfKEC) after adopting RSC and the app directory
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter introduced many patterns that attempt to balance the capabilities
    of CSR and SSR. Depending on the type of the application or the page type, some
    of the patterns may be more suitable than others. The chart in [Figure 13-1](#renderingpatterns)
    compares the highlights of different patterns and provides use cases for each.
  prefs: []
  type: TYPE_NORMAL
- en: '![ljd2 1301](Images/ljd2_1301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13-1\. Rendering patterns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following table from [Patterns for Building JavaScript Websites in 2022](https://oreil.ly/Qg_h6)
    offers another view pivoted by key application characteristics. It should be helpful
    for anyone looking for a suitable pattern for common [application holotypes](https://oreil.ly/qgaKE).
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Portfolio** | **Content** | **Storefront** | **Social network** | **Immersive**
    |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Holotype** | Personal blog | CNN | Amazon | Social network | Figma |'
  prefs: []
  type: TYPE_TB
- en: '| **Interactivity** | Minimal | Linked articles | Purchase | Multipoint, real
    time | Everything |'
  prefs: []
  type: TYPE_TB
- en: '| **Session depth** | Shallow | Shallow | Shallow to medium | Extended | Deep
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Values** | Simplicity | Discover-ability | Load performance | Dynamicism
    | Immersiveness |'
  prefs: []
  type: TYPE_TB
- en: '| **Routing** | Server | Server, hybrid | Hybrid, transitional | Transitional,
    client | Client |'
  prefs: []
  type: TYPE_TB
- en: '| **Rendering** | Static | Static, SSR | Static, SSR | SSR | CSR |'
  prefs: []
  type: TYPE_TB
- en: '| **Hydration** | None | Progressive, partial | Partial, resumable | Any |
    None (CSR) |'
  prefs: []
  type: TYPE_TB
- en: '| **Example framework** | 11ty | Astro, Elder | Marko, Qwik, Hydrogen | Next,
    Remix | Create React App |'
  prefs: []
  type: TYPE_TB
- en: We have now discussed some interesting React patterns for components, state
    management, rendering, and others. Libraries like React do not enforce a specific
    application structure, but there are recommended best practices for organizing
    your React projects. Let’s explore this in the next chapter.
  prefs: []
  type: TYPE_NORMAL
