- en: Chapter 5\. React with JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, we dove deep into how React works, breaking down our React
    applications into small reusable pieces called components. These components render
    trees of elements and other components. Using the `createElement` function is
    a good way to see how React works, but as React developers, that’s not what we
    do. We don’t go around composing complex, barely readable trees of JavaScript
    syntax and call it fun. In order to work efficiently with React, we need one more
    thing: JSX.'
  prefs: []
  type: TYPE_NORMAL
- en: JSX combines the *JS* from JavaScript and the *X* from XML. It is a JavaScript
    extension that allows us to define React elements using a tag-based syntax directly
    within our JavaScript code. Sometimes JSX is confused with HTML because they look
    similar. JSX is just another way of creating React elements, so you don’t have
    to pull your hair out looking for the missing comma in a complex `createElement`
    call.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to discuss how to use JSX to construct a React
    application.
  prefs: []
  type: TYPE_NORMAL
- en: React Elements as JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Facebook’s React team released JSX when they released React to provide a concise
    syntax for creating complex DOM trees with attributes. They also hoped to make
    React more readable like HTML and XML. In JSX, an element’s type is specified
    with a tag. The tag’s attributes represent the properties. The element’s children
    can be added between the opening and closing tags.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add other JSX elements as children. If you have an unordered list,
    you can add child list item elements to it with JSX tags. It looks very similar
    to HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: JSX works with components as well. Simply define the component using the class
    name. We pass an array of ingredients to the `IngredientsList` as a property with
    JSX, as shown in [Figure 5-1](#ingredients_jsx).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/lrc2_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Creating the IngredientsList with JSX
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When we pass the array of ingredients to this component, we need to surround
    it with curly braces. This is called a JavaScript *expression*, and we must use
    these when passing JavaScript values to components as properties. Component properties
    will take two types: either a string or a JavaScript expression. JavaScript expressions
    can include arrays, objects, and even functions. In order to include them, you
    must surround them in curly braces.'
  prefs: []
  type: TYPE_NORMAL
- en: JSX Tips
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JSX might look familiar, and most of the rules result in syntax that’s similar
    to HTML. However, there are a few considerations you should understand when working
    with JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Nested components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JSX allows you to add components as children of other components. For example,
    inside the `IngredientsList`, we can render another component called `Ingredient`
    multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: className
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since `class` is a reserved word in JavaScript, `className` is used to define
    the `class` attribute instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript expressions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript expressions are wrapped in curly braces and indicate where variables
    will be evaluated and their resulting values returned. For example, if we want
    to display the value of the `title` property in an element, we can insert that
    value using a JavaScript expression. The variable will be evaluated and its value
    returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Values of types other than string should also appear as JavaScript expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Evaluation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The JavaScript that’s added in between the curly braces will get evaluated.
    This means that operations such as concatenation or addition will occur. This
    also means that functions found in JavaScript expressions will be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Mapping Arrays with JSX
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JSX is JavaScript, so you can incorporate JSX directly inside of JavaScript
    functions. For example, you can map an array to JSX elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'JSX looks clean and readable, but it can’t be interpreted with a browser. All
    JSX must be converted into `createElement` calls. Luckily, there’s an excellent
    tool for this task: Babel.'
  prefs: []
  type: TYPE_NORMAL
- en: Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many software languages require you to compile your source code. JavaScript
    is an interpreted language: the browser interprets the code as text, so there’s
    no need to compile JavaScript. However, not all browsers support the latest JavaScript
    syntax, and no browser supports JSX syntax. Since we want to use the latest features
    of JavaScript along with JSX, we’re going to need a way to convert our fancy source
    code into something that the browser can interpret. This process is called compiling,
    and it’s what [Babel](https://babeljs.io) is designed to do.'
  prefs: []
  type: TYPE_NORMAL
- en: The first version of the project was called 6to5, and it was released in September
    2014\. 6to5 was a tool that could be used to convert ES6 syntax to ES5 syntax,
    which was more widely supported by web browsers. As the project grew, it aimed
    to be a platform to support all of the latest changes in ECMAScript. It also grew
    to support converting JSX into JavaScript. The project was renamed Babel in February
    2015.
  prefs: []
  type: TYPE_NORMAL
- en: Babel is used in production at Facebook, Netflix, PayPal, Airbnb, and more.
    Previously, Facebook had created a JSX transformer that was their standard, but
    it was soon retired in favor of Babel.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways of working with Babel. The easiest way to get started is
    to include a link to the Babel CDN directly in your HTML, which will compile any
    code in script blocks that have a type of “text/babel.” Babel will compile the
    source code on the client before running it. Although this may not be the best
    solution for production, it’s a great way to get started with JSX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Console Warning in the Browser with In-Browser Babel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using the in-browser transformer, you’ll see a warning that says to precompile
    scripts for production. Don’t worry about that warning for the purposes of this
    and any other small demos. We’ll upgrade to production-ready Babel later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Recipes as JSX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JSX provides us with a nice, clean way to express React elements in our code
    that makes sense to us and is immediately readable by developers. The drawback
    of JSX is that it’s not readable by the browser. Before our code can be interpreted
    by the browser, it needs to be converted from JSX into JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'This data array contains two recipes, and this represents our application’s
    current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The data is expressed in an array of two JavaScript objects. Each object contains
    the name of the recipe, a list of the ingredients required, and a list of steps
    necessary to cook the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a UI for these recipes with two components: a `Menu` component
    for listing the recipes and a `Recipe` component that describes the UI for each
    recipe. It’s the `Menu` component that we’ll render to the DOM. We’ll pass our
    data to the `Menu` component as a property called `recipes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The React elements within the `Menu` component are expressed as JSX. Everything
    is contained within an `article` element. A `header` element, an `h1` element,
    and a `div.recipes` element are used to describe the DOM for our menu. The value
    for the `title` property will be displayed as text within the `h1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside of the `div.recipes` element, we add a component for each recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In order to list the recipes within the `div.recipes` element, we use curly
    braces to add a JavaScript expression that will return an array of children. We
    can use the `map` function on the `props.recipes` array to return a component
    for each object within the array. As mentioned previously, each recipe contains
    a name, some ingredients, and cooking instructions (steps). We’ll need to pass
    this data to each `Recipe` as props. Also remember that we should use the `key`
    property to uniquely identify each element.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could also refactor this to use spread syntax. The JSX spread operator
    works like the object spread operator. It will add each field of the `recipe`
    object as a property of the `Recipe` component. The syntax here will supply all
    properties to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Remember that this shortcut will provide all the properties to the `Recipe`
    component. This could be a good thing but might also add too many properties to
    the component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another place we can make a syntax improvement to our `Menu` component is where
    we take in the `props` argument. We can use object destructuring to scope the
    variables to this function. This allows us to access the `title` and `recipes`
    variables directly, no longer having to prefix them with `props`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s code the component for each individual recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Each recipe has a string for the name, an array of objects for ingredients,
    and an array of strings for the steps. Using object destructuring, we can tell
    this component to locally scope those fields by name so we can access them directly
    without having to use `props.name`, `props.ingredients`, or `props.steps`.
  prefs: []
  type: TYPE_NORMAL
- en: The first JavaScript expression we see is being used to set the `id` attribute
    for the root `section` element. It’s converting the recipe’s name to a lowercase
    string and globally replacing spaces with dashes. The result is that “Baked Salmon”
    will be converted to “baked-salmon” (and likewise, if we had a recipe with the
    name “Boston Baked Beans,” it would be converted to “boston-baked-beans”) before
    it’s used as the `id` attribute in our UI. The value for `name` is also being
    displayed in an `h1` as a text node.
  prefs: []
  type: TYPE_NORMAL
- en: Inside of the unordered list, a JavaScript expression is mapping each ingredient
    to an `li` element that displays the name of the ingredient. Within our instructions
    section, we see the same pattern being used to return a paragraph element where
    each step is displayed. These `map` functions are returning arrays of child elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The complete code for the application should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: When we run this code in the browser, React will construct a UI using our instructions
    with the recipe data as shown in [Figure 5-2](#delicious_recipes).
  prefs: []
  type: TYPE_NORMAL
- en: If you’re using Google Chrome and have the React Developer Tools Extension installed,
    you can take a look at the present state of the component tree. To do this, open
    the developer tools and select the Components tab, as shown in [Figure 5-3](#react_tab5).
  prefs: []
  type: TYPE_NORMAL
- en: Here we can see the `Menu` and its child elements. The `data` array contains
    two objects for recipes, and we have two `Recipe` elements. Each `Recipe` element
    has properties for the recipe name, ingredients, and steps. The ingredients and
    steps are passed down to their own components as `data`.
  prefs: []
  type: TYPE_NORMAL
- en: The components are constructed based on the application’s data being passed
    to the `Menu` component as a property. If we change the `recipes` array and rerender
    our `Menu` component, React will change this DOM as efficiently as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/lrc2_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Delicious Recipes output
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![image](assets/lrc2_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Resulting virtual DOM in React Developer Tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: React Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we rendered the `Menu` component, a parent component
    that rendered the `Recipe` component. We want to take a moment to look at a small
    example of rendering two sibling components using a React fragment. Let’s start
    by creating a new component called `Cat` that we’ll render to the DOM at the `root`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This will render the `h1` as expected, but what might happen if we added a `p`
    tag to the `Cat` component at the same level as the `h1`?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Immediately, we’ll see an error in the console that reads `Adjacent JSX elements
    must be wrapped in an enclosing tag` and recommends using a fragment. This is
    where fragments come into play! React will not render two or more adjacent or
    sibling elements as a component, so we used to have to wrap these in an enclosing
    tag like a `div`. This led to a lot of unnecessary tags being created, though,
    and a bunch of wrappers without much purpose. If we use a React fragment, we can
    mimic the behavior of a wrapper without actually creating a new tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by wrapping the adjacent tags, the `h1` and `p`, with a `React.Fragment`
    tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding this clears the warning. You also can use a fragment shorthand to make
    this look even cleaner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you look at the DOM, the fragment is not visible in the resulting tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Fragments are a relatively new feature of React and do away with the need for
    extra wrapper tags that can pollute the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Intro to webpack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once we start working with React in real projects, there are a lot of questions
    to consider: How do we want to deal with JSX and ESNext transformation? How can
    we manage our dependencies? How can we optimize our images and CSS?'
  prefs: []
  type: TYPE_NORMAL
- en: Many different tools have emerged to answer these questions, including Browserify,
    gulp, Grunt, Prepack, and more. Due to its features and widespread adoption by
    large companies, *webpack* has also emerged as one of the leading tools for bundling.
  prefs: []
  type: TYPE_NORMAL
- en: The React ecosystem has matured to include tools like create-react-app, Gatsby,
    and Code Sandbox. When you use these tools, a lot of the details about how the
    code gets compiled are abstracted away. For the remainder of this chapter, we
    are going to set up our own webpack build. This day in age, understanding that
    your JavaScript/React code is being compiled by something like webpack is vital,
    but knowing *how* to compile your JavaScript/React with something like webpack
    is not as important. We understand if you want to skip ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack is billed as a module bundler. A module bundler takes all of our different
    files (JavaScript, LESS, CSS, JSX, ESNext, and so on) and turns them into a single
    file. The two main benefits of bundling are *modularity* and *network performance*.
  prefs: []
  type: TYPE_NORMAL
- en: Modularity will allow you to break down your source code into parts, or modules,
    that are easier to work with, especially in a team environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Network performance is gained by only needing to load one dependency in the
    browser: the bundle. Each `script` tag makes an HTTP request, and there’s a latency
    penalty for each HTTP request. Bundling all the dependencies into a single file
    allows you to load everything with one HTTP request, thereby avoiding additional
    latency.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from code compilation, webpack also can handle:'
  prefs: []
  type: TYPE_NORMAL
- en: Code splitting
  prefs: []
  type: TYPE_NORMAL
- en: Splits up your code into different chunks that can be loaded when you need them.
    Sometimes these are called *rollups* or *layers*; the aim is to break up code
    as needed for different pages or devices.
  prefs: []
  type: TYPE_NORMAL
- en: Minification
  prefs: []
  type: TYPE_NORMAL
- en: Removes whitespace, line breaks, lengthy variable names, and unnecessary code
    to reduce the file size.
  prefs: []
  type: TYPE_NORMAL
- en: Feature Flagging
  prefs: []
  type: TYPE_NORMAL
- en: Sends code to one or more—but not all—environments when testing out features.
  prefs: []
  type: TYPE_NORMAL
- en: Hot Module Replacement (HMR)
  prefs: []
  type: TYPE_NORMAL
- en: Watches for changes in source code. Changes only the updated modules immediately.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Recipes app we built earlier in this chapter has some limitations that
    webpack will help us alleviate. Using a tool like webpack to statically build
    client JavaScript makes it possible for teams to work together on large-scale
    web applications. We can also gain the following benefits by incorporating the
    webpack module bundler:'
  prefs: []
  type: TYPE_NORMAL
- en: Modularity
  prefs: []
  type: TYPE_NORMAL
- en: Using the module pattern to export modules that will later be imported or required
    by another part of the application makes source code more approachable. It allows
    development teams to work together, by allowing them to create and work with separate
    files that will be statically combined into a single file before sending to production.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs: []
  type: TYPE_NORMAL
- en: With modules, we can build small, simple, reusable React components that we
    can compose efficiently into applications. Smaller components are easier to comprehend,
    test, and reuse. They’re also easier to replace down the line when enhancing applications.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs: []
  type: TYPE_NORMAL
- en: Packaging all the application’s modules and dependencies into a single client
    bundle will reduce the load time of an application because there’s latency associated
    with each HTTP request. Packaging everything together in a single file means that
    the client will only need to make a single request. Minifying the code in the
    bundle will improve load time as well.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency
  prefs: []
  type: TYPE_NORMAL
- en: Since webpack will compile JSX and JavaScript, we can start using tomorrow’s
    JavaScript syntax today. Babel supports a wide range of ESNext syntax, which means
    we don’t have to worry about whether the browser supports our code. It allows
    developers to consistently use cutting-edge JavaScript syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To demonstrate how we might set up a React project from scratch, let’s go ahead
    and create a new folder on our computer called *recipes-app*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'For this project, we’re going to go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Break down the recipe app into components that live in different files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a webpack build that incorporates Babel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: create-react-app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s a tool called Create React App that can be used to autogenerate a React
    project with all of this preconfigured. We’re going to take a closer look at what’s
    happening behind the scenes before abstracting these steps away with a tool.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Create the project
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, we’ll create the project and *package.json* file with npm, sending the
    `-y` flag to use all of the defaults. We’ll also install webpack, webpack-cli,
    react, and react-dom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If we’re using npm 5, we don’t need to send the `--save` flag when installing.
    Next, we’ll create the following directory structure to house the components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: File Organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There’s no one way to organize the files in a React project. This is just one
    possible strategy.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Break components into modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Currently, the `Recipe` component is doing quite a bit. We’re displaying the
    name of the recipe, constructing an unordered list of ingredients, and displaying
    the instructions, with each step getting its own paragraph element. This component
    should be placed in the *Recipe.js* file. In any file where we’re using JSX, we’ll
    need to import React at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A more functional approach to the `Recipe` component would be to break it down
    into smaller, more focused function components and compose them together. We can
    start by pulling the instructions out into their own component and creating a
    module in a separate file we can use for any set of instructions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In that new file called *Instructions.js*, create the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’ve created a new component called `Instructions`. We’ll pass the title
    of the instructions and the steps to this component. This way, we can reuse this
    component for “Cooking Instructions,” “Baking Instructions,” “Prep Instructions,”
    or a “Pre-cook Checklist”—anything that has steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now think about the ingredients. In the `Recipe` component, we’re only displaying
    the ingredient names, but each ingredient in the data for the recipe has an amount
    and measurement as well. We’ll create a component called `Ingredient` for this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, we assume each ingredient has an amount, a measurement, and a name. We
    destructure those values from our `props` object and display them each in independent
    classed `span` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `Ingredient` component, we can construct an `IngredientsList` component
    that can be used any time we need to display a list of ingredients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we first import the `Ingredient` component because we’re going
    to use it for each ingredient. The ingredients are passed to this component as
    an array in a property called `list`. Each ingredient in the `list` array will
    be mapped to the `Ingredient` component. The JSX spread operator is used to pass
    all the data to the `Ingredient` component as props.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'is another way of expressing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'So, given an ingredient with these fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have components for ingredients and instructions, we can compose
    recipes using these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the components we’re going to use: `IngredientsList` and `Instructions`.
    Now we can use them to create the `Recipe` component. Instead of a bunch of complicated
    code building out the entire recipe in one place, we’ve expressed our recipe more
    declaratively by composing smaller components. Not only is the code nice and simple,
    but it also reads well. This shows us that a recipe should display the name of
    the recipe, a list of ingredients, and some cooking instructions. We’ve abstracted
    away what it means to display ingredients and instructions into smaller, simple
    components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a modular approach, the `Menu` component would look pretty similar. The
    key difference is that it would live in its own file, import the modules it needs
    to use, and export itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We still need to use ReactDOM to render the `Menu` component. The main file
    for the project is *index.js*. This will be responsible for rendering the component
    to the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create this file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first four statements import the necessary modules for our app to work.
    Instead of loading `react` and `react-dom` via the `script` tag, we import them
    so webpack can add them to our bundle. We also need the `Menu` component and a
    sample data array that has been moved to a separate module. It still contains
    two recipes: Baked Salmon and Fish Tacos.'
  prefs: []
  type: TYPE_NORMAL
- en: All of our imported variables are local to the *index.js* file. When we render
    the `Menu` component, we pass the array of recipe data to this component as a
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'The data is being pulled from the *recipes.json* file. This is the same data
    we used earlier in the chapter, but now it’s following valid JSON formatting rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now that we’ve pulled our code apart into separate modules and files, let’s
    create a build process with webpack that will put everything back together into
    a single file. You may be thinking, “Wait, we just did all of that work to break
    everything apart, and now we’re going to use a tool to put it back together? Why
    on Earth…?” Splitting projects into separate files typically makes larger projects
    easier to manage because team members can work on separate components without
    overlap. It also means that files can be easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Creating the webpack build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to create a static build process with webpack, we’ll need to install
    a few things. Everything we need can be installed with npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Remember that we’ve already installed React and ReactDOM.
  prefs: []
  type: TYPE_NORMAL
- en: For this modular Recipes app to work, we’re going to need to tell webpack how
    to bundle our source code into a single file. As of version 4.0.0, webpack does
    not require a configuration file to bundle a project. If we don’t include a config
    file, webpack will run the defaults to package our code. Using a config file,
    though, means we’ll be able to customize our setup. Plus, this shows us some of
    the magic of webpack instead of hiding it away. The default webpack configuration
    file is always *webpack.config.js*.
  prefs: []
  type: TYPE_NORMAL
- en: The starting file for our Recipes app is *index.js*. It imports React, ReactDOM,
    and the *Menu.js* file. This is what we want to run in the browser first. Wherever
    webpack finds an `import` statement, it will find the associated module in the
    filesystem and include it in the bundle. *index.js* imports *Menu.js*, *Menu.js*
    imports *Recipe.js*, *Recipe.js* imports *Instructions.js* and *IngredientsList.js*,
    and *IngredientsList.js* imports *Ingredient.js*. Webpack will follow this import
    tree and include all of these necessary modules in our bundle. Traversal through
    all these files creates what’s called a *dependency graph*. A dependency is just
    something our app needs, like a component file, a library file like React, or
    an image. Picture each file we need as a circle on the graph, with webpack drawing
    all the lines between the circles to create the graph. That graph is the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Import Statements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re using `import` statements, which are not presently supported by most browsers
    or by Node.js. The reason `import` statements work is that Babel will convert
    them into `require('module/path');` statements in our final code. The `require`
    function is how CommonJS modules are typically loaded.
  prefs: []
  type: TYPE_NORMAL
- en: As webpack builds our bundle, we need to tell it to transform JSX to React elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *webpack.config.js* file is just another module that exports a JavaScript
    literal object that describes the actions webpack should take. The configuration
    file should be saved to the root folder of the project, right next to the *index.js*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: First, we tell webpack that our client entry file is *./src/index.js*. It will
    automatically build the dependency graph based on `import` statements starting
    in that file. Next, we specify that we want to output a bundled JavaScript file
    to *./dist/bundle.js*. This is where webpack will place the final packaged JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s install the necessary Babel dependencies. We’ll need `babel-loader`
    and `@babel/core`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next set of instructions for webpack consists of a list of loaders to run
    on specified modules. This will be added to the config file under the `module`
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `rules` field is an array because there are many types of loaders you can
    incorporate with webpack. In this example, we’re only incorporating the `babel-loader`.
    Each loader is a JavaScript object. The `test` field is a regular expression that
    matches the file path of each module that the loader should operate on. In this
    case, we’re running the `babel-loader` on all imported JavaScript files except
    those found in the *node_modules* folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we need to specify presets for running Babel. When we set a
    preset, we tell Babel which transforms to perform. In other words, we can say,
    “Hey Babel. If you see some ESNext syntax here, go ahead and transform that code
    into syntax we’re sure the browser understands. If you see some JSX, transform
    that too.” Start by installing the presets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create one more file at the root of the project: `.babelrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'All right! We’ve created something pretty cool: a project that resembles a
    real React app! Let’s go ahead and run webpack to make sure this works.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Webpack is run statically. Typically, bundles are created before the app is
    deployed to the server. You can run it from the command line using npx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Webpack will either succeed and create a bundle or fail and show you an error.
    Most errors have to do with broken import references. When debugging webpack errors,
    look closely at the filenames and file paths used in `import` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add an npm script to your *package.json* file to create a shortcut:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you can run the shortcut to generate the bundle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Loading the Bundle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have a bundle, so now what? We exported the bundle to the *dist* folder.
    This folder contains the files we want to run on the web server. The *dist* folder
    is where the *index.html* file should be placed. This file needs to include a
    target `div` element where the React `Menu` component will be mounted. It also
    requires a single `script` tag that will load our bundled JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the home page for your app. It will load everything it needs from one
    file, one HTTP request: *bundle.js*. You’ll need to deploy these files to your
    web server or build a web server application that will serve these files with
    something like Node.js or Ruby on Rails.'
  prefs: []
  type: TYPE_NORMAL
- en: Source Mapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bundling our code into a single file can cause some setbacks when it comes time
    to debug the application in the browser. We can eliminate this problem by providing
    a *source map*. A source map is a file that maps a bundle to the original source
    files. With webpack, all we have to do is add a couple lines to our *webpack.config.js*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting the `devtool` property to `''#source-map''` tells webpack that you
    want to use source mapping. The next time you run webpack, you’ll see that two
    output files are generated and added to the *dist* folder: the original *bundle.js*
    and *bundle.js.map*.'
  prefs: []
  type: TYPE_NORMAL
- en: The source map is going to let you debug using your original source files. In
    the Sources tab of your browser’s developer tools, you should find a folder named
    *webpack://*. Inside of this folder, you’ll see all the source files in your bundle,
    as shown in [Figure 5-4](#sources_panel).
  prefs: []
  type: TYPE_NORMAL
- en: '![image](assets/lrc2_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Sources panel of Chrome Developer Tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can debug from these files using the browser step-through debugger. Clicking
    on any line number adds a breakpoint. Refreshing the browser will pause JavaScript
    processing when any breakpoints are reached in your source file. You can inspect
    scoped variables in the Scope panel or add variables to watch in the Watch panel.
  prefs: []
  type: TYPE_NORMAL
- en: Create React App
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A pretty amazing tool to have at your disposal as a React developer is Create
    React App, a command-line tool that autogenerates a React project. Create React
    App was inspired by the [Ember CLI project](https://ember-cli.com), and it lets
    developers get started with React projects quickly without the manual configuration
    of webpack, Babel, ESLint, and associated tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with Create React App, install the package globally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the command and the name of the folder where you’d like the app to
    be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: npx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can also use npx to run Create React App without the need for a global install.
    Simply run `npx create-react-app my-project`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create a React project in that directory with just three dependencies:
    React, ReactDOM, and `react-scripts`. `react-scripts` was also created by Facebook
    and is where the real magic happens. It installs Babel, ESLint, webpack, and more
    so that you don’t have to configure them manually. Within the generated project
    folder, you’ll also find a *src* folder containing an *App.js* file. Here, you
    can edit the root component and import other component files.'
  prefs: []
  type: TYPE_NORMAL
- en: From within the *my-react-project* folder, you can run `npm start`. If you prefer,
    you can also run `yarn start`. This will start your application on port 3000.
  prefs: []
  type: TYPE_NORMAL
- en: You can run tests with `npm test` or `yarn test`. This runs all of the test
    files in the project in an interactive mode.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run the `npm run build` command. Using yarn, run `yarn build`.
  prefs: []
  type: TYPE_NORMAL
- en: This will create a production-ready bundle that has been transformed and minified.
  prefs: []
  type: TYPE_NORMAL
- en: Create React App is a great tool for beginners and experienced React developers
    alike. As the tool evolves, more functionality will likely be added, so you can
    keep an eye on the changes on [GitHub](https://github.com/facebook/create-react-app).
    Another way to get started with React without having to worry about setting up
    your own customized webpack build is to use CodeSandbox. CodeSandbox is an IDE
    that runs online at [*https://codesandbox.io*](https://codesandbox.io).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we leveled up our React skills by learning about JSX. We created
    components. We broke those components into a project structure, and we learned
    more about Babel and webpack. Now we’re ready to take our knowledge of components
    to the next level. It’s time to talk about Hooks.
  prefs: []
  type: TYPE_NORMAL
