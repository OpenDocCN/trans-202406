- en: Appendix. Building Your Own Kubernetes Cluster
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Kubernetes is often experienced through the virtual world of public cloud
    computing, where the closest you get to your cluster is a web browser or a terminal,
    it can be a very rewarding experience to physically build a Kubernetes cluster
    on bare metal. Likewise, nothing compares to physically pulling the power or network
    on a node and watching how Kubernetes reacts to heal your application to convince
    you of its utility.
  prefs: []
  type: TYPE_NORMAL
- en: Building your own cluster might seem like both a challenging and an expensive
    effort, but fortunately it is neither. The ability to purchase low-cost, system-on-chip
    computer boards, as well as a great deal of work by the community to make Kubernetes
    easier to install, means that it is possible to build a small Kubernetes cluster
    in a few hours.
  prefs: []
  type: TYPE_NORMAL
- en: In the following instructions, we focus on building a cluster of Raspberry Pi
    machines, but with slight adaptations, the same instructions could be made to
    work with a variety of different single-board machines or any other computers
    you may have around.
  prefs: []
  type: TYPE_NORMAL
- en: Parts List
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing you need to do is assemble the pieces for your cluster. In all
    the examples here, we assume a four-node cluster. You could build a cluster of
    three nodes, or even a cluster of a hundred nodes if you wanted to, but four is
    a pretty good number. To start, you’ll need to purchase (or scrounge) the various
    pieces needed to build the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the shopping list, with some approximate prices as of the time of writing:'
  prefs: []
  type: TYPE_NORMAL
- en: Four Raspberry Pi 4 machines with at least 2 GB of memory—$180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Four SDHC memory cards, at least 8 GB (buy high-quality ones!)—$30–50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Four 12-inch Cat. 6 Ethernet cables—$10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Four 12-inch USB-A to USB-C cables—$10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One 5-port 10/100 fast Ethernet switch—$10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One 5-port USB charger—$25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One Raspberry Pi stackable case capable of holding four Pis—$40 (or build your
    own)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One USB-to-barrel plug for powering the Ethernet switch (optional)—$5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The total for the cluster comes to about $300, which you can drop down to $200
    by building a three-node cluster and skipping the case and the USB power cable
    for the switch (though the case and the cable really clean up the whole cluster).
  prefs: []
  type: TYPE_NORMAL
- en: 'One other note on memory cards: do not scrimp here. Low-end memory cards behave
    unpredictably and make your cluster really unstable. If you want to save some
    money, buy a smaller, high-quality card. High-quality 8 GB cards can be had for
    around $7 each online.'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have your parts, you’re ready to move on to building the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: These instructions also assume that you have a device capable of flashing an
    SDHC card. If you do not, you will need to purchase a USB memory card reader/writer.
  prefs: []
  type: TYPE_NORMAL
- en: Flashing Images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The default Ubuntu 20.04 image supports Raspberry Pi 4 and also is a common
    operating system used by many Kubernetes clusters. The easiest way to install
    that is using the Raspberry Pi Imager provided by the [Raspberry Pi project](https://oreil.ly/4s8Wa):'
  prefs: []
  type: TYPE_NORMAL
- en: '[macOS](https://oreil.ly/g7Lzw)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Windows](https://oreil.ly/Y7CD3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Linux](https://oreil.ly/u4YvC)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the imager to write the Ubuntu 20.04 image onto each of your memory cards.
    Ubuntu may not be the default image choice in the imager, but you can select it
    as an option.
  prefs: []
  type: TYPE_NORMAL
- en: First Boot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing to do is to boot just your API server node. Assemble your cluster,
    and decide which is going to be the API server node. Insert the memory card, plug
    the board into an HDMI output, and plug a keyboard into the USB port.
  prefs: []
  type: TYPE_NORMAL
- en: Next, attach the power to boot the board.
  prefs: []
  type: TYPE_NORMAL
- en: Log in at the prompt using the username **`ubuntu`** and the password **`ubuntu`**.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The very first thing you should do with your Raspberry Pi (or any new device)
    is to change the default password. The default password for every type of install
    everywhere is well known by people who will misbehave given a default login to
    a system. This makes the internet less safe for everyone. Please change your default
    passwords!
  prefs: []
  type: TYPE_NORMAL
- en: Repeat these steps for each of the nodes in your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Up Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next step is to set up networking on the API server. Setting up networking
    for a Kubernetes cluster can be complicated. In the following example, we are
    setting up a network where a single machine is attached to the internet using
    wireless networking; this machine is also connected to a cluster network over
    wired Ethernet and provides a DHCP (Dynamic Host Configuration Protocol) server
    to provide a network address to the remaining nodes in the cluster. An illustration
    of this network is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![kur3 aain01](assets/kur3_aain01.png)'
  prefs: []
  type: TYPE_IMG
- en: Decide which of your boards will host the API server and `etcd`. It’s often
    easiest to remember which one this is by making it the top or bottom node in your
    stack, but some sort of label also works.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, edit the file */etc/netplan/50-cloud-init.yaml*. If this file doesn’t
    exist, you can create it. The contents of the file should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This sets the main Ethernet interface to have the statically allocated address
    10.0.0.1 and sets up the WiFi interface to connect to your local WiFi. You should
    then run `sudo netplan apply` to pick up these new changes.
  prefs: []
  type: TYPE_NORMAL
- en: Reboot the machine to claim the 10.0.0.1 address. You can validate that this
    is set correctly by running `ip addr` and looking at the address for the `eth0`
    interface. Also validate that the connection to the internet works correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’re going to install DHCP on this API server so it will allocate addresses
    to the worker nodes. Run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then configure the DHCP server as follows (*/etc/dhcp/dhcpd.conf*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may also need to edit */etc/default/isc-dhcp-server* to set the `INTERFACES`
    environment variable to `eth0`. Restart the DHCP server with `sudo systemctl restart
    isc-dhcp-server`. Now your machine should be handing out IP addresses. You can
    test this by hooking up a second machine to the switch via Ethernet. This second
    machine should get the address 10.0.0.2 from the DHCP server.
  prefs: []
  type: TYPE_NORMAL
- en: Remember to edit the */etc/hostname* file to rename this machine to `node-1`.
    To help Kubernetes do its networking, you also need to set up `iptables` so that
    it can see bridged network traffic. Create a file at */etc/modules-load.d/k8s.conf*
    that just contains `br_netfilter`. This will load the `br_netfilter` module into
    your kernel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next you need to enable some `systemctl` settings for network bridging and
    address translation (NAT) so that Kubernetes networking will work, and your nodes
    can reach the public internet. Create a file named */etc/sysctl.d/k8s.conf* and
    add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Then edit */etc/rc.local* (or the equivalent) and add `iptables` rules for
    forwarding from `eth0` to `wlan0` (and back):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: At this point, the basic networking setup should be complete. Plug in and power
    up the remaining two boards (you should see them assigned the addresses 10.0.0.3
    and 10.0.0.4). Edit the */etc/hostname* file on each machine to name them `node-2`
    and `node-3`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Validate this by first looking at */var/lib/dhcp/dhcpd.leases*, and then SSH
    to the nodes (remember again to change the default password first thing). Validate
    that the nodes can connect to the external internet.
  prefs: []
  type: TYPE_NORMAL
- en: Installing a Container Runtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can install Kubernetes, you need to install a container runtime.
    There are several possible runtimes you can use, but the most broadly adopted
    is `containerd` from Docker. `containerd` is provided by the standard Ubuntu package
    manager, but its version tends to lag a little bit. It’s a little more work, but
    we recommend installing it from the Docker project itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to set up Docker as a repository for installing packages
    on your system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As a final step, create the file */etc/apt/sources.list.d/docker.list* with
    the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that you have installed the Docker package repository, you can install
    `containerd.io` by running the following command. It is important to install `containerd.io`,
    not `containerd`, to get the Docker package instead of the default Ubuntu package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, `containerd` is installed, but you need to configure it since
    the configuration supplied by the package won’t work with Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have a container runtime installed, you can move on to installing
    Kubernetes itself.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point you should have all nodes up with IP addresses and capable of
    accessing the internet. Now it’s time to install Kubernetes on all of the nodes.
    Using SSH, run the following commands on all nodes to install the `kubelet` and
    `kubeadm` tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, add the encryption key for the packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the repository to your list of repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, update and install the Kubernetes tools. This will also update all
    packages on your system for good measure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Setting Up the Cluster
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On the API server node (the one running DHCP and connected to the internet),
    run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note that you are advertising your internal-facing IP address, not your external
    address.
  prefs: []
  type: TYPE_NORMAL
- en: 'Eventually, this will print out a command for joining nodes to your cluster.
    It will look something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: SSH onto each of the worker nodes in your cluster and run that command.
  prefs: []
  type: TYPE_NORMAL
- en: 'When all of that is done, you should be able to run this command and see your
    working cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Setting Up Cluster Networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have your node-level networking set up, but you still need to set up the
    Pod-to-Pod networking. Since all of the nodes in your cluster are running on the
    same physical Ethernet network, you can simply set up the correct routing rules
    in the host kernels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to manage this is to use the [Flannel tool](https://oreil.ly/ltaOv)
    created by CoreOS and now supported by the [Flannel project](https://oreil.ly/RHfMH).
    Flannel supports a number of different routing modes; we will use the `host-gw`
    mode. You can download an example configuration from the [Flannel project page](https://github.com/coreos/flannel):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The default configuration that Flannel supplies uses `vxlan` mode instead. To
    fix this, open up that configuration file in your favorite editor; replace `vxlan`
    with `host-gw`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also do this with the `sed` tool in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have your updated *kube-flannel.yaml* file, you can create the Flannel
    networking setup with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create two objects, a ConfigMap used to configure Flannel and a DaemonSet
    that runs the actual Flannel daemon. You can inspect these with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you should have a working Kubernetes cluster operating on your
    Raspberry Pis. This can be great for exploring Kubernetes. Schedule some jobs,
    open up the UI, and try breaking your cluster by rebooting machines or disconnecting
    the network.
  prefs: []
  type: TYPE_NORMAL
