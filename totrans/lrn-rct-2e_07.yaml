- en: Chapter 7\. Enhancing Components with Hooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rendering is the heartbeat of a React application. When something changes (props,
    state), the component tree rerenders, reflecting the latest data as a user interface.
    So far, `useState` has been our workhorse for describing how our components should
    be rendering. But we can do more. There are more Hooks that define rules about
    why and when rendering should happen. There are more Hooks that enhance rendering
    performance. There are always more Hooks to help us out.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last chapter, we introduced `useState`, `useRef`, and `useContext`,
    and we saw that we could compose these Hooks into our own custom Hooks: `useInput`
    and `useColors`. There’s more where that came from, though. React comes with more
    Hooks out of the box. In this chapter, we’re going to take a closer look at `useEffect`,
    `useLayoutEffect`, and `useReducer`. All of these are vital when building applications.
    We’ll also look at `useCallback` and `useMemo`, which can help optimize our components
    for performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing useEffect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a good sense of what happens when we render a component. A component
    is simply a function that renders a user interface. Renders occur when the app
    first loads and when props and state values change. But what happens when we need
    to do something after a render? Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a simple component, the `Checkbox`. We’re using `useState` to set
    a `checked` value and a function to change the value of `checked`: `setChecked`.
    A user can check and uncheck the box, but how might we alert the user that the
    box has been checked? Let’s try this with an `alert`, as it’s a great way to block
    the thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We’ve added the `alert` before the render to block the render. The component
    will not render until the user clicks the OK button on the alert box. Because
    the alert is blocking, we don’t see the next state of the checkbox rendered until
    clicking OK.
  prefs: []
  type: TYPE_NORMAL
- en: That isn’t the goal, so maybe we should place the alert after the return?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Scratch that. We can’t call `alert` after the render because the code will
    never be reached. To ensure that we see the `alert` as expected, we can use `useEffect`.
    Placing the `alert` inside of the `useEffect` function means that the function
    will be called after the render, as a side effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We use `useEffect` when a render needs to cause side effects. Think of a side
    effect as something that a function does that isn’t part of the return. The function
    is the `Checkbox`. The `Checkbox` function renders UI. But we might want the component
    to do more than that. Those things we want the component to do other than return
    UI are called *effects*.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `alert`, a `console.log`, or an interaction with a browser or native API
    is not part of the render. It’s not part of the return. In a React app, though,
    the render affects the results of one of these events. We can use `useEffect`
    to wait for the render, then provide the values to an `alert` or a `console.log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we could check in with the value of `checked` on render and then
    set that to a value in `localStorage`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We might also use `useEffect` to focus on a specific text input that has been
    added to the DOM. React will render the output, then call `useEffect` to focus
    the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'On `render`, the `txtInputRef` will have a value. We can access that value
    in the effect to apply the focus. Every time we render, `useEffect` has access
    to the latest values from that render: props, state, refs, etc.'
  prefs: []
  type: TYPE_NORMAL
- en: Think of `useEffect` as being a function that happens after a render. When a
    render fires, we can access the current state values within our component and
    use them to do something else. Then, once we render again, the whole thing starts
    over. New values, new renders, new effects.
  prefs: []
  type: TYPE_NORMAL
- en: The Dependency Array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useEffect` is designed to work in conjunction with other stateful Hooks like
    `useState` and the heretofore unmentioned `useReducer`, which we promise to discuss
    later in the chapter. React will rerender the component tree when the state changes.
    As we’ve learned, `useEffect` will be called after these renders.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following, where the `App` component has two separate state values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '`val` is a state variable that represents the value of the input field. The
    `val` changes every time the value of the input field changes. It causes the component
    to render every time the user types a new character. When the user clicks the
    Send button, the `val` of the text area is saved as the phrase, and the `val`
    is reset to `""`, which empties the text field.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This works as expected, but the `useEffect` hook is invoked more times than
    it should be. After every render, both `useEffect` Hooks are called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We don’t want every effect to be invoked on every render. We need to associate
    `useEffect` hooks with specific data changes. To solve this problem, we can incorporate
    the dependency array. The dependency array can be used to control when an effect
    is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ve added the dependency array to both effects to control when they’re invoked.
    The first effect is only invoked when the `val` value has changed. The second
    effect is only invoked when the `phrase` value has changed. Now, when we run the
    app and take a look at the console, we’ll see more efficient updates occurring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Changing the `val` value by typing into the input only causes the first effect
    to fire. When we click the button, the `phrase` is saved and the `val` is reset
    to `""`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s an array after all, so it’s possible to check multiple values in the dependency
    array. Let’s say we wanted to run a specific effect any time either the `val`
    or `phrase` has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If either of those values changes, the effect will be called again. It’s also
    possible to supply an empty array as the second argument to a `useEffect` function.
    An empty dependency array causes the effect to be invoked only once after the
    initial render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Since there are no dependencies in the array, the effect is invoked for the
    initial render. No dependencies means no changes, so the effect will never be
    invoked again. Effects that are only invoked on the first render are extremely
    useful for initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you return a function from the effect, the function will be invoked when
    the component is removed from the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This means that you can use `useEffect` for setup and teardown. The empty array
    means that the welcome chime will play once on first render. Then, we’ll return
    a function as a cleanup function to play a goodbye chime when the component is
    removed from the tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern is useful in many situations. Perhaps we’ll subscribe to a news
    feed on first render. Then we’ll unsubscribe from the news feed with the cleanup
    function. More specifically, we’ll start by creating a state value for `posts`
    and a function to change that value, called `setPosts`. Then we’ll create a function,
    `addPosts`, that will take in the newest post and add it to the array. Then we
    can use `useEffect` to subscribe to the news feed and play the chime. Plus, we
    can return the cleanup functions, unsubscribing and playing the goodbye chime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a lot going on in `useEffect`, though. We might want to use a separate
    `useEffect` for the news feed events and another `useEffect` for the chime events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Splitting functionality into multiple `useEffect` calls is typically a good
    idea. But let’s enhance this even further. What we’re trying to create here is
    functionality for subscribing to a news feed that plays different jazzy sounds
    for subscribing, unsubscribing, and whenever there’s a new post. Everyone loves
    lots of loud sounds right? This is a case for a custom hook. Maybe we should call
    it `useJazzyNews`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Our custom hook contains all of the functionality to handle a jazzy news feed,
    which means that we can easily share this functionality with our components. In
    a new component called `NewsFeed`, we’ll use the custom hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Deep Checking Dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the dependencies we’ve added to the array have been strings. JavaScript
    primitives like strings, booleans, numbers, etc., are comparable. A string would
    equal a string as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when we start to compare objects, arrays, and functions, the comparison
    is different. For example, if we compared two arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'These arrays `[1,2,3]` and `[1,2,3]` are not equal, even though they look identical
    in length and in entries. This is because they are two different instances of
    a similar-looking array. If we create a variable to hold this array value and
    then compare, we’ll see the expected output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, arrays, objects, and functions are the same only when they’re
    the exact same instance. So how does this relate to the `useEffect` dependency
    array? To demonstrate this, we’re going to need a component we can force to render
    as much as we want. Let’s build a hook that causes a component to render whenever
    a key is pressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'At minimum, all we need to do to force a render is invoke a state change function.
    We don’t care about the state value. We only want the state function: `forceRender`.
    (That’s why we added the comma using array destructuring. Remember, from [Chapter 2](ch02.html#javascript-for-react)?)
    When the component first renders, we’ll listen for keydown events. When a key
    is pressed, we’ll force the component to render by invoking `forceRender`. As
    we’ve done before, we’ll return a cleanup function where we stop listening to
    keydown events. By adding this hook to a component, we can force it to rerender
    simply by pressing a key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the custom hook built, we can use it in the `App` component (and any other
    component for that matter! Hooks are cool.):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time we press a key, the `App` component is rendered. `useEffect` demonstrates
    this by logging “fresh render” to the console every time the `App` is rendered.
    Let’s adjust `useEffect` in the `App` component to reference the `word` value.
    If `word` changes, we’ll rerender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Instead of calling `useEffect` on every keydown event, we would only call this
    after first render and any time the `word` value changes. It doesn’t change, so
    subsequent rerenders don’t occur. Adding a primitive or a number to the dependency
    array works as expected. The effect is invoked once.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if instead of a single word, we use an array of words?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The variable `words` is an array. Because a new array is declared with each
    render, JavaScript assumes that `words` has changed, thus invoking the “fresh
    render” effect every time. The array is a new instance each time, and this registers
    as an update that should trigger a rerender.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring `words` outside of the scope of the `App` would solve the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The dependency array in this case refers to one instance of `words` that’s
    declared outside of the function. The “fresh render” effect does not get called
    again after the first render because `words` is the same instance as the last
    render. This is a good solution for this example, but it’s not always possible
    (or advisable) to have a variable defined outside of the scope of the function.
    Sometimes the value passed to the dependency array requires variables in scope.
    For example, we might need to create the `words` array from a React property like
    `children`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `App` component contains some words that are children of the `WordCount`
    component. The `WordCount` component takes in `children` as a property. Then we
    set `words` in the component equal to an array of those words that we’ve called
    `.split` on. We would hope that the component will rerender only if `words` changes,
    but as soon as we press a key, we see the dreaded “fresh render” words appearing
    in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s replace that feeling of dread with one of calm, because the React team
    has provided us a way to avoid these extra renders. They wouldn’t hang us out
    to dry like that. The solution to this problem is, as you might expect, another
    hook: `useMemo`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`useMemo` invokes a function to calculate a memoized value. In computer science
    in general, memoization is a technique that’s used to improve performance. In
    a memoized function, the result of a function call is saved and cached. Then,
    when the function is called again with the same inputs, the cached value is returned.
    In React, `useMemo` allows us to compare the cached value against itself to see
    if it has actually changed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The way `useMemo` works is that we pass it a function that’s used to calculate
    and create a memoized value. `useMemo` will only recalculate that value when one
    of the dependencies has changed. First, let’s import the `useMemo` hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll use the function to set `words`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '`useMemo` invokes the function sent to it and sets `words` to the return value
    of that function. Like `useEffect`, `useMemo` relies on a dependency array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'When we don’t include the dependency array with `useMemo`, the words are calculated
    with every render. The dependency array controls when the callback function should
    be invoked. The second argument sent to the `useMemo` function is the dependency
    array and should contain the `children` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `words` array depends on the `children` property. If `children` changes,
    we should calculate a new value for `words` that reflects that change. At that
    point, `useMemo` will calculate a new value for `words` when the component initially
    renders and if the `children` property changes.
  prefs: []
  type: TYPE_NORMAL
- en: The `useMemo` hook is a great function to understand when you’re creating React
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: '`useCallback` can be used like `useMemo`, but it memoizes functions instead
    of values. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`fn` is a function that logs “Hello” then “World.” It is a dependency of `useEffect`,
    but just like `words`, JavaScript assumes `fn` is different every render. Therefore,
    it triggers the effect every render. This yields a “fresh render” for every key
    press. It’s not ideal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by wrapping the function with `useCallback`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`useCallback` memoizes the function value for `fn`. Just like `useMemo` and
    `useEffect`, it also expects a dependency array as the second argument. In this
    case, we create the memoized callback once because the dependency array is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have an understanding of the uses and differences between `useMemo`
    and `useCallback`, let’s improve our `useJazzyNews` hook. Every time there’s a
    new post, we’ll call `newPostChime.play()`. In this hook, `posts` are an array,
    so we’ll need to use `useMemo` to memoize the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, the useJazzyNews hook plays a chime every time there’s a new post. We made
    this happen with a few changes to the hook. First, `const [posts, setPosts]` was
    renamed to `const [_posts, setPosts]`. We’ll calculate a new value for `posts`
    every time `_posts` change.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we added the effect that plays the chime every time the `post` array changes.
    We’re listening to the news feed for new posts. When a new post is added, this
    hook is reinvoked with `_posts` reflecting that new post. Then, a new value for
    `post` is memoized because `_posts` have changed. Then the chime plays because
    this effect is dependent on `posts`. It only plays when the posts change, and
    the list of posts only changes when a new one is added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in the chapter, we’ll discuss the React Profiler, a browser extension
    for testing performance and rendering of React components. There, we’ll dig into
    more detail about when to use `useMemo` and `useCallback`. (Spoiler alert: sparingly!)'
  prefs: []
  type: TYPE_NORMAL
- en: When to useLayoutEffect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We understand that the render always comes before `useEffect`. The render happens
    first, then all effects run in order with full access to all of the values from
    the render. A quick look at the React docs will point out that there’s another
    type of effect hook: `useLayoutEffect`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'useLayoutEffect is called at a specific moment in the render cycle. The series
    of events is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Render
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`useLayoutEffect` is called'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Browser paint: the time when the component’s elements are actually added to
    the DOM'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`useEffect` is called'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This can be observed by adding some simple console messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `App` component, `useEffect` is the first hook, followed by `useLayoutEffect`.
    We see that `useLayoutEffect` is invoked before `useEffect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`useLayoutEffect` is invoked after the render but before the browser paints
    the change. In most circumstances, `useEffect` is the right tool for the job,
    but if your effect is essential to the browser paint (the appearance or placement
    of the UI elements on the screen), you may want to use `useLayoutEffect`. For
    instance, you may want to obtain the width and height of an element when the window
    is resized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `width` and `height` of the window is information that your component may
    need before the browser paints. `useLayoutEffect` is used to calculate the window’s
    `width` and `height` before the paint. Another example of when to use `useLayoutEffect`
    is when tracking the position of the mouse:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: It’s highly likely that the `x` and `y` position of the mouse will be used when
    painting the screen. `useLayoutEffect` is available to help calculate those positions
    accurately before the paint.
  prefs: []
  type: TYPE_NORMAL
- en: Rules to Follow with Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you’re working with Hooks, there are a few guidelines to keep in mind that
    can help avoid bugs and unusual behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooks only run in the scope of a component
  prefs: []
  type: TYPE_NORMAL
- en: Hooks should only be called from React components. They can also be added to
    custom Hooks, which are eventually added to components. Hooks are not regular
    JavaScript—they’re a React pattern, but they’re starting to be modeled and incorporated
    in other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good idea to break functionality out into multiple Hooks
  prefs: []
  type: TYPE_NORMAL
- en: 'In our earlier example with the Jazzy News component, we split everything related
    to subscriptions into one effect and everything related to sound effects into
    another effect. This immediately made the code easier to read, but there was another
    benefit to doing this. Since Hooks are invoked in order, it’s a good idea to keep
    them small. Once invoked, React saves the values of Hooks in an array so the values
    can be tracked. Consider the following component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The order of Hook calls is the same for each and every render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Hooks should only be called at the top level
  prefs: []
  type: TYPE_NORMAL
- en: 'Hooks should be used at the top level of a React function. They cannot be placed
    into conditional statements, loops, or nested functions. Let’s adjust the counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: "When we use `useState` within the `if` statement, we’re saying that the hook\
    \ should only be called when the `count` value is greater than 5\\. That will\
    \ throw off the array values. Sometimes the array will be: `[count, checked, DependencyArray,\
    \ \x960\x97, DependencyArray]`. Other times: `[count, DependencyArray, \x961\x97\
    ]`. The index of the effect in that array matters to React. It’s how values are\
    \ saved."
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait, so are we saying that we can never use conditional logic in React applications
    anymore? Of course not! We just have to organize these conditionals differently.
    We can nest `if` statements, loops, and other conditionals within the hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the value for `checked` is based on the condition that the `count` is
    greater than 5\. When `count` is less than 5, the value for `checked` is `undefined`.
    Nesting this conditional inside the hook means that the hook remains on the top
    level, but the result is similar. The second effect enforces the same rules. If
    the `count` is less than 5, the return statement will prevent the effect from
    continuing to execute. This keeps the hook values array intact: `[countValue,
    checkedValue, DependencyArray, DependencyArray, DependencyArray]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Like conditional logic, you need to nest asynchronous behavior inside of a
    hook. `useEffect` takes a function as the first argument, not a promise. So you
    can’t use an async function as the first argument: `useEffect(async () => {})`.
    You can, however, create an async function inside of the nested function like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a variable, `fn`, to handle the async/await, then we called the
    function as the return. You can give this function a name, or you can use async
    effects as an anonymous function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If you follow these rules, you can avoid some common gotchas with React Hooks.
    If you’re using Create React App, there’s an ESLint plug-in included called eslint-plugin-react-hooks
    that provides warning hints if you’re in violation of these rules.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Code with useReducer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider the `Checkbox` component. This component is a perfect example of a
    component that holds simple state. The box is either checked or not checked. `checked`
    is the state value, and `setChecked` is a function that will be used to change
    the state. When the component first renders, the value of `checked` will be `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This works well, but one area of this function could be cause for alarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Look at it closely. It feels OK at first glance, but are we stirring up trouble
    here? We’re sending a function that takes in the current value of `checked` and
    returns the opposite, `!checked`. This is probably more complex than it needs
    to be. Developers could easily send the wrong information and break the whole
    thing. Instead of handling it this way, why not provide a function as a toggle?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a function called `toggle` that will do the same thing: call `setChecked`
    and return the opposite of the current value of `checked`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This is better. `onChange` is set to a predictable value: the `toggle` function.
    We know what that function is going to do every time, everywhere it’s used. We
    can still take this one step farther to yield even more predictable results each
    time we use the `checkbox` component. Remember the function we sent to `setChecked`
    in the `toggle` function?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We’re going to refer to this function, `checked => !checked`, by a different
    name now: a *reducer*. A reducer function’s most simple definition is that it
    takes in the current state and returns a new state. If `checked` is `false`, it
    should return the opposite, `true`. Instead of hardcoding this behavior into `onChange`
    events, we can abstract the logic into a reducer function that will always produce
    the same results. Instead of `useState` in the component, we’ll use `useReducer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '`useReducer` takes in the reducer function and the initial state, `false`.
    Then, we’ll set the `onChange` function to `setChecked`, which will call the reducer
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our earlier reducer, `checked => !checked`, is a prime example of this. If
    the same input is provided to a function, the same output should be expected.
    This concept originates with `Array.reduce` in JavaScript. `reduce` fundamentally
    does the same thing as a reducer: it takes in a function (to reduce all of the
    values into a single value) and an initial value and returns one value.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Array.reduce` takes in a reducer function and an initial value. For each value
    in the `numbers` array, the reducer is called until one value is returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The reducer sent to `Array.reduce` takes in two arguments. You can also send
    multiple arguments to a reducer function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Every time we click on the `h1`, we’ll add 30 to the total.
  prefs: []
  type: TYPE_NORMAL
- en: useReducer to Handle Complex State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`useReducer` can help us handle state updates more predictably as state becomes
    more complex. Consider an object that contains user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have a component called `User` that sets the `firstUser` as the initial
    state, and the component displays the appropriate data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A common error when managing state is to overwrite the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this would overwrite state from `firstUser` and replace it with just
    what we sent to the `setUser` function: `{admin: true}`. This can be fixed by
    spreading the current values from user, then overwriting the `admin` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take the initial state and push in the new key/values: `{admin: true}`.
    We need to rewrite this logic in every `onClick`, making it prone to error (we
    might forget to do this when we come back to the app tomorrow):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we’ll send the new state value, `newDetails`, to the reducer, and it will
    be pushed into the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: This pattern is useful when state has multiple subvalues or when the next state
    depends on a previous state. Teach everyone to spread, they’ll spread for a day.
    Teach everyone to `useReducer` and they’ll spread for life.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Component Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a React application, components are rendered…usually a lot. Improving performance
    includes preventing unnecessary renders and reducing the time a render takes to
    propagate. React comes with tools to help us prevent unnecessary renders: `memo`,
    `useMemo`, and `useCallback`. We looked at `useMemo` and `useCallback` earlier
    in the chapter, but in this section, we’ll go into more detail about how to use
    these Hooks to make your websites perform better.'
  prefs: []
  type: TYPE_NORMAL
- en: The `memo` function is used to create pure components. As discussed in [Chapter 3](ch03.html#functional-programming-with-javascript),
    we know that, given the same parameters, a pure function will always return the
    same result. A pure component works the same way. In React, a pure component is
    a component that always renders the same output, given the same properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a component called `Cat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`Cat` is a pure component. The output is always a paragraph that displays the
    name property. If the name provided as a property is the same, the output will
    be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This app uses the `Cat` component. After the initial render, the console reads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When the “Add a Cat” button is clicked, the user is prompted to add a cat.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add a cat named “Ripple,” we see that all `Cat` components are rerendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This code works because `prompt` is blocking. This is just an example. Don’t
    use `prompt` in a real app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every time we add a cat, every `Cat` component is rendered, but the `Cat` component
    is a pure component. Nothing changes about the output given the same prop, so
    there shouldn’t be a render for each of these. We don’t want to rerender a pure
    component if the properties haven’t changed. The `memo` function can be used to
    create a component that will only render when its properties change. Start by
    importing it from the React library and use it to wrap the current `Cat` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we’ve created a new component called `PureCat`. `PureCat` will only cause
    the `Cat` to render when the properties change. Then we can replace the `Cat`
    component with `PureCat` in the `App` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every time we add a new cat name, like “Pancake,” we see only one render
    in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Because the names of the other cats have not changed, we don’t render those
    `Cat` components. This is working well for a `name` property, but what if we introduce
    a function property to the `Cat` component?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time a cat is clicked on, we can use this property to log a `meow` to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: When we add this change, `PureCat` no longer works as expected. It’s always
    rendering every `Cat` component even though the `name` property remains the same.
    This is because of the added `meow` property. Unfortunately, every time we define
    the `meow` property as a function, it’s always new function. To React, the `meow`
    property has changed, and the component is rerendered.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `memo` function will allow us to define more specific rules around when
    this component should rerender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The second argument sent to the `memo` function is a *predicate*. A predicate
    is a function that only returns `true` or `false`. This function decides whether
    to rerender a cat or not. When it returns `false`, the `Cat` is rerendered. When
    this function returns `true`, the `Cat` will not be rerendered. No matter what,
    the `Cat` is always rendered at least once. This is why, with `RenderCatOnce`,
    it will render once and then never again. Typically, this function is used to
    check actual values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We can use the second argument to compare properties and decide if `Cat` should
    be rerendered. The predicate receives the previous properties and the next properties.
    These objects are used to compare the `name` property. If the `name` changes,
    the component will be re-rendered. If the `name` is the same, it will be rerendered
    regardless of what React thinks about the `meow` property.
  prefs: []
  type: TYPE_NORMAL
- en: shouldComponentUpdate and PureComponent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The concepts we’re discussing are not new to React. The `memo` function is
    a new solution to a common problem. In previous versions of React, there was a
    method called `shouldComponentUpdate`. If present in the component, it was used
    to let React know under which circumstances the component should update. `shouldComponentUpdate`
    described which props or state would need to change for the component to rerender.
    Once `shouldComponentUpdate` was part of the React library, it was embraced as
    a useful feature by many. So useful that the React team decided to create an alternate
    way of creating a component as a class. A class component would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A `PureComponent` would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '`PureComponent` is the same as `React.memo`, but `PureComponent` is only for
    class components; `React.memo` is only for function components.'
  prefs: []
  type: TYPE_NORMAL
- en: '`useCallback` and `useMemo` can be used to memoize object and function properties.
    Let’s use `useCallback` in the `Cat` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we did not provide a property-checking predicate to `memo(Cat)`.
    Instead, we used `useCallback` to ensure that the `meow` function had not changed.
    Using these functions can be helpful when dealing with too many rerenders in your
    component tree.
  prefs: []
  type: TYPE_NORMAL
- en: When to Refactor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last Hooks we discussed, `useMemo` and `useCallback`, along with the `memo`
    function, are commonly overused. React is designed to be fast. It’s designed to
    have components render a lot. The process of optimizing for performance began
    when you decided to use React in the first place. It’s fast. Any further refactoring
    should be a last step.
  prefs: []
  type: TYPE_NORMAL
- en: There are trade-offs to refactoring. Using `useCallback` and `useMemo` everywhere
    because it seems like a good idea might actually make your app less performant.
    You’re adding more lines of code and developer hours to your application. When
    you refactor for performance, it’s important to have a goal. Perhaps you want
    to stop the screen from freezing or flickering. Maybe you know there are some
    costly functions that are slowing the speed of your app unreasonably.
  prefs: []
  type: TYPE_NORMAL
- en: The React Profiler can be used to measure the performance of each of your components.
    The profiler ships with the React Developer Tools that you’ve likely installed
    already (available for [Chrome](https://oreil.ly/1UNct) and [Firefox](https://oreil.ly/0NYbR)).
  prefs: []
  type: TYPE_NORMAL
- en: Always make sure your app works and you’re satisfied with the codebase before
    refactoring. Over-refactoring, or refactoring before your app works, can introduce
    weird bugs that are hard to spot, and it might not be worth your time and focus
    to introduce these optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two chapters, we’ve introduced many of the Hooks that ship with
    React. You’ve seen use cases for each hook, and you’ve created your own custom
    Hooks by composing other Hooks. Next, we’ll build on these foundational skills
    by incorporating additional libraries and advanced patterns.
  prefs: []
  type: TYPE_NORMAL
