<html><head></head><body><section data-pdf-bookmark="Chapter 6. Server-Side React" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch06">&#13;
<h1><span class="label">Chapter 6. </span>Server-Side React</h1>&#13;
&#13;
&#13;
<p>React has evolved considerably since its inception. Although it started&#13;
as a client-side library, the demand for server-side<a data-primary="server-side rendering (SSR)" data-type="indexterm" id="ix_serversiderenderingSSR.06.5.53"/> rendering (SSR) has&#13;
grown over time for reasons we will come to understand in this chapter.&#13;
Together, we will explore server-side React and understand how it&#13;
differs from client-only React, and how it can be used to level up our&#13;
React applications.</p>&#13;
&#13;
<p>As we’ve discussed in earlier chapters, React was initially developed by&#13;
Meta to address the need for efficient and scalable UIs. In <a data-type="xref" href="ch03.html#ch03">Chapter 3</a> we looked at how it does this through the virtual DOM, which enables developers to create and manage UI components&#13;
with ease. React’s client-side approach unlocked fast, responsive user&#13;
experiences across the web. However, as the web continued to evolve, the&#13;
limitations of client-side rendering became more apparent.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Limitations of Client-Side Rendering" data-type="sect1"><div class="sect1" id="id238">&#13;
<h1>Limitations of Client-Side Rendering</h1>&#13;
&#13;
<p>user interfaces with React since it was first released as open source software in 2013.&#13;
Eventually, a number of limitations with this approach started to appear. These limitations eventually led&#13;
to us moving more and more concerns to the server side.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SEO" data-type="sect2"><div class="sect2" id="id83">&#13;
<h2>SEO</h2>&#13;
&#13;
<p>One of the significant limitations of client-side rendering is that&#13;
search engine<a data-primary="search engine optimization (SEO)" data-type="indexterm" id="id772"/> crawlers may not correctly index the content, as some of&#13;
them do not execute JavaScript<a data-primary="JavaScript" data-secondary="and CSR versus SSR" data-secondary-sortas="CSR versus SSR" data-type="indexterm" id="id773"/>, or those that do execute JavaScript may&#13;
not execute it as we expect.</p>&#13;
&#13;
<p>Given the wide variety of search engine crawler implementations, along&#13;
with the fact that a lot of them are proprietary and unknowable to the&#13;
public, this makes client-only rendering somewhat questionable with&#13;
regard to the reach of a given website or application.</p>&#13;
&#13;
<p>That said, an article from <a href="https://oreil.ly/r5hF2">Search Engine Land in 2015</a> described some experiments to test how various search engines work with client-only applications, and this is what they mentioned:</p>&#13;
<blockquote>&#13;
<p>We ran a series of tests that verified Google is able to execute and&#13;
index JavaScript with a multitude of implementations. We also confirmed&#13;
Google is able to render the entire page and read the DOM, thereby&#13;
indexing dynamically generated content.</p></blockquote>&#13;
&#13;
<p>This article found that at the time of&#13;
writing, Google and Bing were advanced enough to index client-only websites, but&#13;
ultimately this is just one research project in an otherwise vast and&#13;
unknowable proprietary ocean.</p>&#13;
&#13;
<p>Thus, while client-only applications may work well with modern search&#13;
engines, there is an inherent risk in not having a server-based&#13;
counterpart. In traditional web applications, when a user or a search&#13;
engine crawler requests a page, the server renders the HTML for the page&#13;
and sends it back. The HTML contains all the content, links, and data,&#13;
making it easy for search engine crawlers to read and index the content&#13;
for search engine results since all the content of the page is nothing&#13;
more than text, i.e., markup.</p>&#13;
&#13;
<p>However, in a client-side rendered application, often built with&#13;
libraries or frameworks like React, the server sends back a near-empty&#13;
HTML file whose sole job is to load JavaScript from a separate&#13;
JavaScript file on the same or an alternate server. The JavaScript file&#13;
then downloads and executes in the browser, rendering the page content&#13;
dynamically. This approach provides a smooth user experience, resembling&#13;
that of a native application, but it has a downside when it comes to&#13;
search engine optimization (SEO) and performance: we don’t download&#13;
anything useful for human readers on the first request, but instead have&#13;
to do another request immediately after the page loads for the&#13;
JavaScript that will power the entire site. This is known as a network&#13;
waterfall<a data-primary="network waterfalls" data-type="indexterm" id="id774"/>.</p>&#13;
&#13;
<p>Thus, another downside of client-only rendering is performance. Let’s talk about that.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Performance" data-type="sect2"><div class="sect2" id="id84">&#13;
<h2>Performance</h2>&#13;
&#13;
<p>Client-side rendered applications may suffer from performance<a data-primary="performance" data-secondary="CSR issues" data-type="indexterm" id="ix_performanceCSRissues.06.77.62"/> issues,&#13;
especially on slow networks or less powerful devices. The need to&#13;
download, parse, and execute JavaScript before rendering the content can&#13;
lead to significant delays in content rendering. This “time to&#13;
interactive” is a crucial metric as it directly impacts user engagement&#13;
and bounce rates (bounce as in the rate at which users abandon a page).&#13;
Users might leave a page if it takes too long to load, and this behavior&#13;
can further negatively impact the SEO ranking of the page.</p>&#13;
&#13;
<p>Additionally, if a device is low-powered with minimal CPU availability,&#13;
client-only rendering also creates a poor user experience. This is&#13;
because the device may not have enough processing power to execute the&#13;
JavaScript quickly, resulting in a slow and unresponsive application.&#13;
This can lead to frustrated users and a poor user experience. If we&#13;
executed this JavaScript on the server and sent minimal data or markup&#13;
to the client, low-power clients don’t have to do much work and thus&#13;
the user experience is better.</p>&#13;
&#13;
<p>On a broader spectrum, the issues of SEO and performance in client-side&#13;
rendered applications highlight the importance of adhering to web&#13;
standards and best practices. They also underline the need for&#13;
server-side rendering or static site generation as more reliable&#13;
alternatives for delivering content in a performant and accessible&#13;
manner, especially for content-heavy sites or applications.</p>&#13;
&#13;
<p>The principle of progressive enhancement<a data-primary="progressive enhancement, and SSR versus CSR" data-type="indexterm" id="id775"/>, where basic content and&#13;
functionality are delivered to all browsers, while advanced features are&#13;
considered as an enhancement, aligns well with these alternatives. By&#13;
rendering the core content server-side, you ensure that all users and&#13;
search engines have access to the fundamental content and functionality,&#13;
regardless of JavaScript execution. Then, client-side JavaScript can&#13;
enhance the user &#13;
<span class="keep-together">experience</span> by adding interactivity, richer animations,&#13;
and other advanced features for the browsers and devices that can&#13;
support them. It does not make any sense to have <em>the entire experience</em>&#13;
be client-side JavaScript<a data-primary="JavaScript" data-secondary="and CSR versus SSR" data-secondary-sortas="CSR versus SSR" data-type="indexterm" id="ix_JavaScriptandCSRversusSSR.06.111.26"/> only, as this is not the original design of&#13;
the web. JavaScript’s role is to <em>enhance</em> a web page, not <em>be</em> a&#13;
web page.</p>&#13;
&#13;
<p>Consider the following example:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useEffect</code><code class="p">,</code><code class="w"> </code><code class="nx">useState</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">Home</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">data</code><code class="p">,</code><code class="w"> </code><code class="nx">setData</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">([]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="nx">useEffect</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">fetch</code><code class="p">(</code><code class="s2">"https://api.example.com/data"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">response</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">data</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">setData</code><code class="p">(</code><code class="nx">data</code><code class="p">));</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">},</code><code class="w"> </code><code class="p">[]);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">{</code><code class="nx">data</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">item</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">div</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">item</code><code class="p">.</code><code class="nx">id</code><code class="p">}&gt;{</code><code class="nx">item</code><code class="p">.</code><code class="nx">title</code><code class="p">}&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="nx">Home</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we are fetching data from an API and rendering it on&#13;
the client side. We can tell it’s the client side because we are using&#13;
the <code>useEffect</code> hook<a data-primary="useEffect hook" data-type="indexterm" id="id776"/><a data-primary="useState hook" data-type="indexterm" id="id777"/><a data-primary="state management" data-secondary="useState hook" data-type="indexterm" id="id778"/> to fetch the data, and the <code>useState</code> hook to store&#13;
the data in state. The <code>useEffect</code> hook executes inside a browser (a&#13;
client) only.</p>&#13;
&#13;
<p>A serious limitation with this is that some search engine crawlers may&#13;
not be able to see this content unless we implement server-side&#13;
rendering. Instead, there is a risk that they see a blank screen or a&#13;
fallback message, which can result in poor SEO.</p>&#13;
&#13;
<p>Another common problem with client-only applications is network&#13;
waterfalls<a data-primary="network waterfalls" data-type="indexterm" id="id779"/>, wherein the initial page load is blocked by the amount of&#13;
JavaScript that needs to be downloaded, parsed, and executed by the&#13;
browser before the website or web app becomes visible. In cases where&#13;
network connectivity is a limited resource, this would render a website&#13;
or application completely unresponsive for significant amounts of time<a data-startref="ix_JavaScriptandCSRversusSSR.06.111.26" data-type="indexterm" id="id780"/><a data-primary="hydration" data-type="indexterm" id="id781"/><a data-primary="server-side rendering (SSR)" data-secondary="hydration" data-type="indexterm" id="id782"/>.</p>&#13;
&#13;
<p>In the example, we’re initiating a data fetch request to an&#13;
external API endpoint (<code>https://api.example.com/data</code>) to retrieve some&#13;
data. This fetch happens <em>after</em> our initial JavaScript bundle is&#13;
downloaded, parsed, and executed, and that happens only <em>after</em> the&#13;
initial HTML loads. This is a network waterfall and leads to&#13;
less-than-optimal performance. If we visualize it, it would look like <a data-type="xref" href="#figure6-1">Figure 6-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure6-1">&#13;
<img alt="frea 0601" src="assets/frea_0601.png"/>&#13;
<h6><span class="label">Figure 6-1. </span>Data fetch request</h6>&#13;
</div></figure>&#13;
&#13;
<p>Yuck. With server-side rendering, we can do better and enable our users&#13;
to see useful content immediately, altering the diagram to look&#13;
like this:</p>&#13;
<pre>Load HTML (full UI, with data fetched on the server)</pre>&#13;
&#13;
<p>Indeed, the first load is already packed with information that is useful&#13;
to the user because we fetched our data and rendered our component on&#13;
the server. There is no waterfall here, and the user gets all their&#13;
information immediately. This is the value of server-side rendering.</p>&#13;
&#13;
<p>As of React 18, the bundle sizes of React and React DOM are 6.4 kB and 130.2 kB, respectively. These sizes are for the latest version of React at the time of writing&#13;
and may vary depending on the version and configuration of React that&#13;
you are using today. This means that even in production environments,&#13;
our users have to download around 136 kB of JavaScript just for React&#13;
alone (i.e., React + React DOM), before downloading, parsing, and&#13;
executing the rest of our application’s code. This can result in a&#13;
slower initial page load, especially on slower devices and networks, and&#13;
potentially frustrated users. Moreover, because React essentially owns&#13;
the DOM<a data-primary="Document Object Model (DOM)" data-secondary="and CSR processing" data-secondary-sortas="CSR processing" data-type="indexterm" id="id783"/> and we have no user interface without React in client-only&#13;
applications, our users have no choice but to wait for React and React&#13;
DOM to load <em>first</em> before the rest of our application does.</p>&#13;
&#13;
<p>In contrast, a server rendered application would stream rendered HTML to&#13;
the client before any JavaScript downloads, enabling users to get&#13;
meaningful content immediately. It would then load relevant JavaScript&#13;
after the initial page renders, probably while the user is still&#13;
orienting themselves with a user interface through a process called&#13;
“hydration.” More on this in the coming sections.</p>&#13;
&#13;
<p>Initially streaming rendered HTML and then hydrating the DOM with&#13;
JavaScript allows users to interact with the application sooner,&#13;
resulting in a better user experience: it is immediately available to&#13;
the user without them having to wait for any extras—that they may or may&#13;
not even need—to load<a data-startref="ix_performanceCSRissues.06.77.62" data-type="indexterm" id="id784"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Security" data-type="sect2"><div class="sect2" id="id85">&#13;
<h2>Security</h2>&#13;
&#13;
<p>Client-only rendering can also have security<a data-primary="security" data-secondary="CSR’s vulnerabilities" data-type="indexterm" id="ix_securityCSRsvulnerabilities.06.217.45"/> issues, especially when&#13;
dealing with sensitive data. This is because all of the application’s&#13;
code is downloaded to the client’s browser, making it vulnerable to&#13;
attacks such as cross-site request forgery (CSRF)<a data-primary="cross-site request forgery (CSRF)" data-type="indexterm" id="ix_crosssiterequestforgeryCSRF.06.220.50"/>.</p>&#13;
&#13;
<p>Without getting too much into the weeds about CSRF, a common way to&#13;
mitigate against it is to have control of the server that serves the&#13;
website or web app to your users. If we have control of this server, we&#13;
can send appropriate anti-CSRF tokens from the server as a trusted&#13;
source to the client, and then the client submits the tokens via a form&#13;
or similar back to the server, which can verify that the request is coming&#13;
from the correct client. This is a common way to mitigate against CSRF.</p>&#13;
&#13;
<p>While it is technically possible to serve client-only applications from&#13;
a static site server we control, and mitigate against CSRF that way, it’s&#13;
still not the best way to serve a website in general because of the&#13;
other trade-offs we’ve discussed so far. If we do have control of a&#13;
server, then why not add SSR to it from there?</p>&#13;
&#13;
<p>Ultimately, here’s what we’re saying:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If we don’t have access to the server side but work in a team where&#13;
it’s just <code>git push</code> frontend client-only code and then it’s magically&#13;
deployed somewhere, there are inherent CSRF risks here.</p>&#13;
</li>&#13;
<li>&#13;
<p>If we have access to the server side and if our website or web app is&#13;
still client only, we can mitigate against CSRF quite well already and&#13;
the security risks around it go away.</p>&#13;
</li>&#13;
<li>&#13;
<p>If we have access to the server side and if our website or web app is&#13;
still client only, there’s a strong argument to be made to add&#13;
server-side rendering to it, since we have access to the server, enabling&#13;
the other benefits around SEO and performance that we’ve already covered.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Let’s get a little bit practical and consider the following example:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">useState</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">Account</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">[</code><code class="nx">balance</code><code class="p">,</code><code class="w"> </code><code class="nx">setBalance</code><code class="p">]</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">useState</code><code class="p">(</code><code class="mf">100</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">handleWithdrawal</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">async</code><code class="w"> </code><code class="p">(</code><code class="nx">amount</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="c1">// Assume this request goes to a server to process the withdrawal</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">const</code><code class="w"> </code><code class="nx">response</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">await</code><code class="w"> </code><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/withdraw"</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">method</code><code class="o">:</code><code class="w"> </code><code class="s2">"POST"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">headers</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="s2">"Content-Type"</code><code class="o">:</code><code class="w"> </code><code class="s2">"application/json"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">credentials</code><code class="o">:</code><code class="w"> </code><code class="s2">"include"</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">body</code><code class="o">:</code><code class="w"> </code><code class="nb">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">({</code><code class="w"> </code><code class="nx">amount</code><code class="w"> </code><code class="p">}),</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="kd">const</code><code class="w"> </code><code class="nx">updatedBalance</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="k">await</code><code class="w"> </code><code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">setBalance</code><code class="p">(</code><code class="nx">updatedBalance</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">Account</code><code class="w"> </code><code class="nx">Balance</code><code class="o">:</code><code class="w"> </code><code class="p">{</code><code class="nx">balance</code><code class="p">}&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">handleWithdrawal</code><code class="p">(</code><code class="mf">10</code><code class="p">)}&gt;</code><code class="nx">Withdraw</code><code class="w"> </code><code class="nx">$10</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">handleWithdrawal</code><code class="p">(</code><code class="mf">50</code><code class="p">)}&gt;</code><code class="nx">Withdraw</code><code class="w"> </code><code class="nx">$50</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">button</code> <code class="na">onClick</code><code class="o">=</code><code class="p">{()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">handleWithdrawal</code><code class="p">(</code><code class="mf">100</code><code class="p">)}&gt;</code><code class="nx">Withdraw</code><code class="w"> </code><code class="nx">$100</code><code class="p">&lt;/</code><code class="nt">button</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">};</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="nx">Account</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>In this code, <code>handleWithdrawal</code> sends a <code>POST</code> request to a&#13;
hypothetical server-side endpoint <code>/withdraw</code> to process the withdrawal.&#13;
A CSRF risk could occur if this endpoint does not properly validate the&#13;
origin of the request and doesn’t require any form of anti-CSRF token.</p>&#13;
&#13;
<p>An attacker could create a malicious webpage that tricks a user into&#13;
clicking a button, which then sends a <code>POST</code> request to the <code>/withdraw</code>&#13;
endpoint on the user’s behalf, possibly leading to unauthorized&#13;
withdrawals from the user’s account. This is because the browser&#13;
automatically includes cookies in the request, which the server uses to&#13;
authenticate the user. If the server does not validate the origin of the&#13;
request, it could be tricked into processing the request and sending the&#13;
funds to the attacker’s account.</p>&#13;
&#13;
<p>If this component is rendered on the client side, it could be vulnerable&#13;
to CSRF attacks because the server and client do not have a shared&#13;
common secret or contract between them. To speak poetically, the client&#13;
and server don’t know each other. This could allow an attacker to steal&#13;
funds or manipulate the application’s data.</p>&#13;
&#13;
<p>If we used server rendering, we could mitigate these security issues by&#13;
rendering the component on the server with a special secret token&#13;
generated by the server, and then sending HTML containing the secret&#13;
token to the client. The client would then send this token back to the&#13;
server that issued it, establishing a secure bidirectional contract.&#13;
This would allow the server to verify that the request is coming from&#13;
the correct client that it has preauthorized and not an unknown one,&#13;
which could possibly be a malicious attacker<a data-startref="ix_clientsiderenderingCSR.06.20.28" data-type="indexterm" id="id785"/><a data-startref="ix_securityCSRsvulnerabilities.06.217.45" data-type="indexterm" id="id786"/><a data-startref="ix_crosssiterequestforgeryCSRF.06.220.50" data-type="indexterm" id="id787"/><a data-startref="ix_serversiderenderingSSRversusCSR.06.20.28" data-type="indexterm" id="id788"/><a data-startref="ix_CSRclientsiderendering.06.20.28" data-type="indexterm" id="id789"/><a data-startref="ix_renderingclientside.06.20.28" data-type="indexterm" id="id790"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Rise of Server Rendering" data-type="sect1"><div class="sect1" id="id239">&#13;
<h1>The Rise of Server Rendering</h1>&#13;
&#13;
<p>For these reasons, server-side rendering has emerged as an arguably&#13;
superior technique for improving the performance and user experience of&#13;
web applications. With server rendering, applications can be optimized&#13;
for speed and accessibility, resulting in faster load times, better SEO,&#13;
and improved user engagement.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Benefits of Server Rendering" data-type="sect2"><div class="sect2" id="id86">&#13;
<h2>Benefits of Server Rendering</h2>&#13;
&#13;
<p>Let’s dive deeper into the benefits<a data-primary="server-side rendering (SSR)" data-secondary="benefits" data-type="indexterm" id="id791"/> of server rendering. These should&#13;
become immediately clear as we further understand the limitations of&#13;
client-only rendering:</p>&#13;
<dl>&#13;
<dt>The time to first meaningful paint is faster with server rendering.</dt>&#13;
<dd>&#13;
<p>This is because the server can render the initial HTML markup and send&#13;
it to the client, which can then be displayed<a data-primary="performance" data-secondary="SSR versus CSR" data-type="indexterm" id="id792"/><a data-primary="performance" data-secondary="CSR issues" data-type="indexterm" id="id793"/> immediately. This is in&#13;
contrast to client-only rendering, where the client must wait for the&#13;
JavaScript to be downloaded, parsed, and executed before the application&#13;
can be rendered.</p>&#13;
</dd>&#13;
<dt>Server rendering improves the accessibility of web applications.</dt>&#13;
<dd>&#13;
<p>Users with slow internet connections or low-power devices may have a better experience if they receive fully rendered HTML instead of waiting for client-side JavaScript to load and render the page.</p>&#13;
</dd>&#13;
<dt>Server rendering can improve the SEO<a data-primary="search engine optimization (SEO)" data-type="indexterm" id="id794"/> of web applications.</dt>&#13;
<dd>&#13;
<p>When search engine crawlers index your site, they can&#13;
see the fully rendered HTML, making it easier for them to understand the&#13;
content and structure of your site.</p>&#13;
</dd>&#13;
<dt>Server rendering can also improve the security of web applications.</dt>&#13;
<dd>&#13;
<p>By rendering<a data-primary="security" data-secondary="SSR benefits" data-type="indexterm" id="id795"/> the core content server-side, you ensure that all users and&#13;
search engines have access to the fundamental content and functionality,&#13;
regardless of JavaScript execution. Then, client-side JavaScript can&#13;
enhance the user experience by adding interactivity, richer animations,&#13;
and other advanced features for the browsers and devices that can&#13;
support them.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>However, server rendered HTML is static and lacks interactivity as it&#13;
does not have any JavaScript initially loaded. It includes no event&#13;
listeners or other dynamic functionality attached. To enable user&#13;
interactions and other dynamic features, the static HTML must be&#13;
“hydrated” with the necessary JavaScript code. Let’s understand the&#13;
concept of hydration a little better.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hydration" data-type="sect1"><div class="sect1" id="id87">&#13;
<h1>Hydration</h1>&#13;
&#13;
<p><em>Hydration</em> is a term used to describe the process of attaching event&#13;
listeners and other JavaScript functionality to static HTML that is&#13;
generated on the server and sent to the client. The goal of hydration<a data-primary="hydration" data-type="indexterm" id="ix_hydration.06.363.70"/><a data-primary="server-side rendering (SSR)" data-secondary="hydration" data-type="indexterm" id="ix_serversiderenderingSSRhydration.06.363.70"/> is&#13;
to enable a server rendered application to become fully interactive&#13;
after being loaded in the browser, providing users with a fast and&#13;
smooth experience.</p>&#13;
&#13;
<p>In a React application, hydration happens after a client downloads a&#13;
server rendered React application. Then, the following steps occur:</p>&#13;
<dl>&#13;
<dt>Loading the client bundle</dt>&#13;
<dd>&#13;
<p>While the browser is rendering the static HTML, it also downloads and parses the JavaScript bundle that contains the application’s code. This bundle includes the React components and&#13;
any other code that is necessary for the application’s &#13;
<span class="keep-together">functionality.</span></p>&#13;
</dd>&#13;
<dt>Attaching event listener</dt>&#13;
<dd>&#13;
<p>Once the JavaScript bundle is loaded, React “hydrates” the static HTML by attaching event listeners<a data-primary="event listeners" data-type="indexterm" id="id796"/> and other dynamic functionality to the DOM elements. This is typically done using the <code>hydrateRoot</code> function from <code>react-dom</code>, which takes the root&#13;
React component and the DOM container as arguments. Hydration&#13;
essentially transforms the static HTML into a fully interactive React&#13;
&#13;
<span class="keep-together">application.</span></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>After the hydration process is complete, the application is fully&#13;
interactive and can respond to user input, fetch data, and update the&#13;
DOM, as necessary.</p>&#13;
&#13;
<p>During hydration, React matches the structure of the DOM<a data-primary="Document Object Model (DOM)" data-secondary="during hydration" data-type="indexterm" id="id797"/> elements in the&#13;
static HTML to the structure defined by the React components via JSX. It&#13;
is crucial that the structure generated by the React components matches&#13;
the structure of the static HTML. If there is a mismatch, React will not&#13;
be able to correctly attach event listeners and will not be aware of&#13;
what React element directly maps to what DOM element, which results&#13;
in the application not behaving as expected.</p>&#13;
&#13;
<p>By combining server-side rendering and hydration, developers can create&#13;
web applications that load quickly and provide a smooth, interactive&#13;
user experience.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hydration Considered Harmful" data-type="sect2"><div class="sect2" id="id88">&#13;
<h2>Hydration Considered Harmful</h2>&#13;
&#13;
<p>While hydration is a great way to take server rendered HTML and make it&#13;
interactive, some criticize hydration for being slower than necessary,&#13;
often citing resumability<a data-primary="resumability" data-type="indexterm" id="ix_resumability.06.400.26"/> as a superior alternative (see <a data-type="xref" href="#figure6-2">Figure 6-2</a>). Let’s explore this a little bit.</p>&#13;
&#13;
<figure><div class="figure" id="figure6-2">&#13;
<img alt="Hydration" src="assets/frea_0602.png"/>&#13;
<h6><span class="label">Figure 6-2. </span>Hydration</h6>&#13;
</div></figure>&#13;
&#13;
<p>With hydration, we render a React application on the server and then&#13;
pass the rendered output to a client. However, at this point in time,&#13;
nothing is interactive. From here, our browser needs to download the&#13;
client bundle, attach event listeners, and effectively “rerender” the&#13;
client. This is a lot of work, and sometimes presents a delay between&#13;
when content appears to a user and when the user can actually use the&#13;
site.</p>&#13;
&#13;
<p>Alternatively, resumability works slightly differently, as shown in <a data-type="xref" href="#figure6-3">Figure 6-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="figure6-3">&#13;
<img alt="Resumability" src="assets/frea_0603.png"/>&#13;
<h6><span class="label">Figure 6-3. </span>Resumability</h6>&#13;
</div></figure>&#13;
&#13;
<p>With resumability, the entire application is rendered on the server and&#13;
streamed to a browser. Along with the initial markup, all interactive&#13;
behavior is serialized and also sent to the client. From there, the&#13;
client already has all the information on how to become interactive&#13;
on demand and thus <em>resume</em> where the server left off. It does not need&#13;
to hydrate (that is, attach event listeners and render the page on the&#13;
client side), but instead can deserialize the stuff the server gave it&#13;
and react accordingly. Skipping the hydration step can result in a&#13;
faster time to interactive (TTI)<a data-primary="time to interactive (TTI)" data-type="indexterm" id="id798"/><a data-primary="TTI (time to interactive)" data-type="indexterm" id="id799"/> and a better user experience.</p>&#13;
&#13;
<p>While there is measurable benefit to resumability, the engineering&#13;
community questions whether the complexity of implementing it is worth&#13;
the benefit. Indeed, it is a more complex approach than hydration, and&#13;
it is not yet clear whether the benefits outweigh the costs: yes, time&#13;
to interactive is faster by a few milliseconds, but is it worth the&#13;
complexity of implementing resumability? This is a question that is&#13;
still being debated in the React community<a data-startref="ix_hydration.06.363.70" data-type="indexterm" id="id800"/><a data-startref="ix_resumability.06.400.26" data-type="indexterm" id="id801"/><a data-startref="ix_serversiderenderingSSRhydration.06.363.70" data-type="indexterm" id="id802"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating Server Rendering" data-type="sect1"><div class="sect1" id="id89">&#13;
<h1>Creating Server Rendering</h1>&#13;
&#13;
<p>If you have an existing client-only React app, you may be wondering how&#13;
to add server rendering<a data-primary="server-side rendering (SSR)" data-secondary="creating with React" data-type="indexterm" id="ix_serversiderenderingSSRcreatingwithReact.06.441.24"/> to it. Fortunately, it’s relatively&#13;
straightforward to add server rendering to an existing React app. One&#13;
approach is to use a server rendering framework, such as <a data-primary="Next.js" data-type="indexterm" id="id803"/><a data-primary="Remix" data-type="indexterm" id="id804"/><a data-primary="frameworks" data-secondary="Remix" data-type="indexterm" id="id805"/>Next.js or&#13;
Remix. While these frameworks are indeed the best way to server rendered&#13;
React applications, abstractions like this can leave the more curious of&#13;
us hungry to understand the underlying mechanisms used to&#13;
accomplish this.</p>&#13;
&#13;
<p>If you’re a curious person and are interested in how you would add&#13;
server rendering to a client-only React app manually, or if you’re&#13;
interested in how frameworks do it, read on. Once again, this is stuff&#13;
you’d probably not use in production, but is more for educational&#13;
purposes for the curious.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Manually Adding Server Rendering to a Client-Only React App" data-type="sect2"><div class="sect2" id="id240">&#13;
<h2>Manually Adding Server Rendering to a Client-Only React App</h2>&#13;
&#13;
<p>If you’ve got a client-only application, this is how you’d add server&#13;
rendering to it. First, you’d create a <em>server.js</em> file in the root of&#13;
your project. This file will contain the code for your server:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// server.js</code>&#13;
&#13;
<code class="c1">// Importing necessary modules</code>&#13;
<code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"express"</code><code class="p">);</code> <code class="c1">// Importing Express.js library</code>&#13;
<code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"path"</code><code class="p">);</code> <code class="c1">// Importing Path module to handle file paths</code>&#13;
<code class="kr">const</code> <code class="nx">React</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"react"</code><code class="p">);</code> <code class="c1">// Importing React library</code>&#13;
<code class="c1">// Importing ReactDOMServer for server-side rendering</code>&#13;
<code class="kr">const</code> <code class="nx">ReactDOMServer</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"react-dom/server"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Importing the main App component from the src directory</code>&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"./src/App"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Initializing an Express application</code>&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Serving static files from the 'build' directory</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">express</code><code class="p">.</code><code class="kr">static</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s2">"build"</code><code class="p">)));</code>&#13;
&#13;
<code class="c1">// Handling all GET requests</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"*"</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// Rendering the App component to an HTML string</code>&#13;
  <code class="kr">const</code> <code class="nx">html</code> <code class="o">=</code> <code class="nx">ReactDOMServer</code><code class="p">.</code><code class="nx">renderToString</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">App</code> <code class="o">/&gt;</code><code class="p">);</code>&#13;
&#13;
  <code class="c1">// Sending an HTML response that includes the rendered App component</code>&#13;
  <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="sb">`</code>&#13;
<code class="sb">    &lt;!DOCTYPE html&gt;</code>&#13;
<code class="sb">    &lt;html&gt;</code>&#13;
<code class="sb">      &lt;head&gt;</code>&#13;
<code class="sb">        &lt;title&gt;My React App&lt;/title&gt;</code>&#13;
<code class="sb">      &lt;/head&gt;</code>&#13;
<code class="sb">      &lt;body&gt;</code>&#13;
<code class="sb">        &lt;!-- Injecting the rendered App component --&gt;</code>&#13;
<code class="sb">        &lt;div id="root"&gt;</code><code class="si">${</code><code class="nx">html</code><code class="si">}</code><code class="sb">&lt;/div&gt;</code>&#13;
<code class="sb">        &lt;!-- Linking to the main JavaScript bundle --&gt;</code>&#13;
<code class="sb">        &lt;script src="/static/js/main.js"&gt;&lt;/script&gt;</code>&#13;
<code class="sb">      &lt;/body&gt;</code>&#13;
<code class="sb">    &lt;/html&gt;</code>&#13;
<code class="sb">  `</code><code class="p">);</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// Starting the server on port 3000</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="mi">3000</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// Logging a message to the console once the server is running</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Server listening on port 3000"</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>In this example, we’re using Express to create a server that serves&#13;
static files from the <em>./build</em> directory and then renders our React app&#13;
on the server. We’re also using <code>ReactDOMServer</code> to render our React app&#13;
to an HTML string and then inject it into the response sent to the&#13;
client.</p>&#13;
&#13;
<p>In this scenario, we’re assuming our client-only React app has some type&#13;
of <code>build</code> script that would output a client-only JavaScript bundle into&#13;
a directory called <em>build</em> that we reference in the snippet. This&#13;
is important for hydration. With all these pieces in order, let’s go&#13;
ahead and start our server:</p>&#13;
&#13;
<pre data-code-language="shell" data-type="programlisting">node<code class="w"> </code>server.js<code class="w"/></pre>&#13;
&#13;
<p>Running this command should start our server on port 3000 and should&#13;
output <code>Server listening on port 3000</code>.</p>&#13;
&#13;
<p>With these steps, we now have a server rendered React app. By taking&#13;
this “peek under the hood” approach to server rendering, we gain a&#13;
deeper understanding of how server rendering works and how it can&#13;
benefit our React applications.</p>&#13;
&#13;
<p>If we open a browser and visit <em><a class="bare" href="http://localhost:3000"><em class="hyperlink">http://localhost:3000</em></a></em>, we should see a&#13;
server rendered application. We can confirm that it is in fact server&#13;
rendered by viewing the source code of this page, which should reveal&#13;
actual HTML markup instead of a blank &#13;
<span class="keep-together">document.</span></p>&#13;
&#13;
<p>For the sake of completion, this is what the HTML markup should look like:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>My React App<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">div</code> <code class="na">id</code><code class="o">=</code><code class="s">"root"</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>Hello, world!<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>This is a simple React app.<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">script</code> <code class="na">src</code><code class="o">=</code><code class="s">"/static/js/main.js"</code><code class="p">&gt;&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>This is the HTML markup that is sent to the client. It contains the&#13;
fully rendered HTML for our React app, which can be indexed by search&#13;
engines and more efficiently accessed by users with slow or unreliable internet&#13;
connections. This can result in better SEO and improved&#13;
accessibility for our React app.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hydrating" data-type="sect2"><div class="sect2" id="id90">&#13;
<h2>Hydrating</h2>&#13;
&#13;
<p>With server rendered output making it to users, hydration<a data-primary="hydration" data-type="indexterm" id="id806"/><a data-primary="server-side rendering (SSR)" data-secondary="hydration" data-type="indexterm" id="id807"/> happens when&#13;
we load our client bundle with the <code>&lt;script&gt;</code> tag toward the end of the&#13;
file. As discussed, hydration is the process of attaching event&#13;
listeners and other JavaScript functionality to static HTML that is&#13;
generated on the server and sent to the client. The goal of hydration is&#13;
to enable a server rendered application to become fully interactive&#13;
after being loaded in the browser.</p>&#13;
&#13;
<p>If we want to explore the hydration step of the client-side bundle of&#13;
our app, it would look like this:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Import necessary libraries</code>&#13;
<code class="kr">import</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s2">"react"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">hydrateRoot</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react-dom/client"</code><code class="p">;</code>&#13;
<code class="c1">// Assuming App is the main component of your application</code>&#13;
<code class="kr">import</code> <code class="nx">App</code> <code class="nx">from</code> <code class="s2">"./App"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Hydrate the app on the client side</code>&#13;
<code class="nx">hydrateRoot</code><code class="p">(</code><code class="nb">document</code><code class="p">,</code> <code class="o">&lt;</code><code class="nx">App</code> <code class="o">/&gt;</code><code class="p">);</code></pre>&#13;
&#13;
<p>With server rendering and client hydration, our app is fully interactive&#13;
and can respond to user input, fetch data, and update the DOM, as&#13;
necessary<a data-startref="ix_serversiderenderingSSRcreatingwithReact.06.441.24" data-type="indexterm" id="id808"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Server Rendering APIs in React" data-type="sect1"><div class="sect1" id="id91">&#13;
<h1>Server Rendering APIs in React</h1>&#13;
&#13;
<p>In the previous section<a data-primary="server-side rendering (SSR)" data-secondary="server rendering APIs" data-type="indexterm" id="ix_serversiderenderingSSRserverrenderingAPIs.06.598.24"/>, we manually added server rendering to a&#13;
client-only React app using Express and <code>ReactDOMServer</code>.&#13;
Specifically, we <a data-primary="ReactDOMServer" data-type="indexterm" id="id809"/>used <code>ReactDOMServer.renderToString()</code> to render our&#13;
React app to an HTML string. This is the most basic way to add server&#13;
rendering to a React app. However, there are other ways to add server&#13;
rendering to React apps. Let’s take a deeper look at server rendering&#13;
APIs exposed by React and understand when and how to use them.</p>&#13;
&#13;
<p>Let’s consider the <code>renderToString</code> API<a data-primary="renderToString API" data-type="indexterm" id="ix_renderToStringAPI.06.606.40"/><a data-primary="synchronous rendering" data-secondary="renderToString API" data-type="indexterm" id="ix_synchronousrenderingrenderToStringAPI.06.606.40"/> in detail, exploring its usage,&#13;
advantages, disadvantages, and when it is appropriate to use it in a&#13;
React application. Specifically, let’s look into:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>What it is</p>&#13;
</li>&#13;
<li>&#13;
<p>How it works</p>&#13;
</li>&#13;
<li>&#13;
<p>How it fits into our everyday usage of React</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To start with this, let’s talk about what it is.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="renderToString" data-type="sect2"><div class="sect2" id="id241">&#13;
<h2>renderToString</h2>&#13;
&#13;
<p><code>renderToString</code> is a server-side rendering API provided by React that&#13;
enables you to render a React component into an HTML string on the&#13;
server. This API is synchronous and returns a fully rendered HTML&#13;
string, which can then be sent to the client as a response.&#13;
<code>renderToString</code> is commonly used in server rendered React applications&#13;
to improve performance, SEO, and accessibility.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Usage" data-type="sect3"><div class="sect3" id="id92">&#13;
<h3>Usage</h3>&#13;
&#13;
<p>To use <code>renderToString</code>, you’d need to import the <code>renderToString</code>&#13;
function from the <code>react-dom/server</code> package<a data-primary="react-dom package" data-type="indexterm" id="id810"/><a data-primary="react-server package" data-type="indexterm" id="id811"/>. Then, you can call the&#13;
function with a React component as its argument. It will then return the&#13;
fully rendered HTML as a string. Here’s an example of using&#13;
<code>renderToString</code> to render a simple React component:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">renderToString</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react-dom/server"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">Hello</code><code class="p">,</code><code class="w"> </code><code class="nx">world</code><code class="o">!</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code><code class="nx">This</code><code class="w"> </code><code class="nx">is</code><code class="w"> </code><code class="nx">a</code><code class="w"> </code><code class="nx">simple</code><code class="w"> </code><code class="nx">React</code><code class="w"> </code><code class="nx">app</code><code class="p">.&lt;/</code><code class="nt">p</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">html</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">renderToString</code><code class="p">(&lt;</code><code class="nt">App</code> <code class="p">/&gt;);</code><code class="w"/>&#13;
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">html</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>In this example, we create a simple App component and call&#13;
<code>renderToString</code> with the component as its argument. The function&#13;
returns the fully rendered HTML, which can be sent to the client.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How it works" data-type="sect3"><div class="sect3" id="id178">&#13;
<h3>How it works</h3>&#13;
&#13;
<p>This function traverses the tree of React elements, converts them to a&#13;
string representation of real DOM elements, and finally outputs a&#13;
string.</p>&#13;
&#13;
<p>It’s worth recalling here that in React, <code>&lt;div&gt;</code> is converted to:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"div"</code><code class="p">,</code> <code class="p">{},</code> <code class="s2">"Hello, world!"</code><code class="p">);</code></pre>&#13;
&#13;
<p>whose output is:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="p">{</code>&#13;
  <code class="nx">type</code><code class="o">:</code> <code class="s2">"div"</code><code class="p">,</code>&#13;
  <code class="nx">props</code><code class="o">:</code> <code class="p">{},</code>&#13;
  <code class="nx">children</code><code class="o">:</code> <code class="p">[</code><code class="s2">"Hello, world!"</code><code class="p">]</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We’ve covered this in prior chapters, but it’s worth recalling here for&#13;
the discussion we’re about to have. Fundamentally, JSX <a data-primary="JSX (JavaScript Syntax eXtension)" data-secondary="with renderToString API" data-secondary-sortas="renderToString API" data-type="indexterm" id="id812"/>turns into HTML&#13;
with the following flow:</p>&#13;
<pre class="no-indent" data-type="programlisting">&#13;
JSX -&gt; React.createElement -&gt; React element -&gt; renderToString(React element) -&gt; HTML&#13;
</pre>&#13;
&#13;
<p><code>renderToString</code> as an API is synchronous and blocking, meaning it&#13;
cannot be interrupted or paused. If a component tree from the root is&#13;
many levels deep, it can require quite a bit of processing. Since a&#13;
server typically services multiple clients, &#13;
<span class="keep-together"><code>renderToString</code></span> could be&#13;
called for each client unless there’s some type of cache preventing&#13;
this, and quickly block the event loop and overload the system.</p>&#13;
&#13;
<p>In terms of code, <code>renderToString</code> converts this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
  <code class="s2">"section"</code><code class="p">,</code>&#13;
  <code class="p">{</code> <code class="nx">id</code><code class="o">:</code> <code class="s2">"list"</code> <code class="p">},</code>&#13;
  <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"h1"</code><code class="p">,</code> <code class="p">{},</code> <code class="s2">"This is my list!"</code><code class="p">),</code>&#13;
  <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
    <code class="s2">"p"</code><code class="p">,</code>&#13;
    <code class="p">{},</code>&#13;
    <code class="s2">"Isn't my list amazing? It contains amazing things!"</code>&#13;
  <code class="p">),</code>&#13;
  <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code>&#13;
    <code class="s2">"ul"</code><code class="p">,</code>&#13;
    <code class="p">{},</code>&#13;
    <code class="nx">amazingThings</code><code class="p">.</code><code class="nx">map</code><code class="p">((</code><code class="nx">t</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">React</code><code class="p">.</code><code class="nx">createElement</code><code class="p">(</code><code class="s2">"li"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">key</code><code class="o">:</code> <code class="nx">t</code><code class="p">.</code><code class="nx">id</code> <code class="p">},</code> <code class="nx">t</code><code class="p">.</code><code class="nx">label</code><code class="p">))</code>&#13;
  <code class="p">)</code>&#13;
<code class="p">);</code></pre>&#13;
&#13;
<p>to this:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">section</code> <code class="na">id</code><code class="o">=</code><code class="s">"list"</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>This is my list!<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">p</code><code class="p">&gt;</code>Isn't my list amazing? It contains amazing things!<code class="p">&lt;/</code><code class="nt">p</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Thing 1<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Thing 2<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>Thing 3<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">section</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Because React is declarative<a data-primary="declarative programming" data-secondary="in server-side rendering" data-secondary-sortas="server-side rendering" data-type="indexterm" id="id813"/><a data-primary="React" data-secondary="and declarative programming" data-secondary-sortas="declarative programming" data-type="indexterm" id="id814"/> and React elements are declarative&#13;
abstractions, a tree<a data-primary="tree of React elements" data-secondary="into string-representation" data-secondary-sortas="string-representation" data-type="indexterm" id="id815"/><a data-primary="HTML" data-secondary="React elements into string or stream" data-type="indexterm" id="id816"/> of them can be turned into a tree of anything&#13;
else—in this case, a tree of React elements is turned into a&#13;
string-representation of a tree of HTML elements.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Disadvantages" data-type="sect3"><div class="sect3" id="id93">&#13;
<h3>Disadvantages</h3>&#13;
&#13;
<p>While <code>renderToString</code> offers several advantages, it also has some&#13;
downsides:</p>&#13;
<dl>&#13;
<dt>Performance</dt>&#13;
<dd>&#13;
<p>One of the main disadvantages of <code>renderToString</code> is&#13;
that it can be slow<a data-primary="performance" data-secondary="renderToString disadvantage in" data-type="indexterm" id="id817"/> for large React applications. Because it is&#13;
synchronous, it can block the event loop and make the server&#13;
unresponsive. This can be especially problematic if you have a&#13;
high-traffic application with many concurrent users.</p>&#13;
&#13;
<p>Moreover, <code>renderToString</code> returns a fully rendered HTML string, which&#13;
can be memory intensive for large applications. This can lead to&#13;
increased memory usage on your server and potentially slower response&#13;
times, or a panic that kills the server process under heavy load.</p>&#13;
</dd>&#13;
<dt>Lack of streaming support</dt>&#13;
<dd>&#13;
<p><code>renderToString</code> does not support&#13;
streaming<a data-primary="streaming" data-secondary="renderToString API’s lack of support for" data-type="indexterm" id="id818"/>, which means that the entire HTML string must be generated&#13;
before it can be sent to the client. This can result in a slower time to&#13;
first byte (TTFB) and a longer time for the client to start receiving&#13;
the HTML. This limitation can be particularly problematic for large&#13;
applications with lots of content, as the client must wait for the&#13;
entire HTML string to be generated before any content can be displayed.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>For larger applications or situations where the downsides of&#13;
<code>renderToString</code> become problematic, React offers alternative APIs for&#13;
server-side rendering, such as <code>renderToPipeableStream</code> and&#13;
<code>renderToReadableStream</code>. These APIs return a Node.js stream and a&#13;
browser stream, respectively, instead of a fully rendered HTML string,&#13;
which can provide better performance and support for streaming. We will&#13;
cover these more in the next section<a data-startref="ix_renderToStringAPI.06.606.40" data-type="indexterm" id="id819"/><a data-startref="ix_synchronousrenderingrenderToStringAPI.06.606.40" data-type="indexterm" id="id820"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="renderToPipeableStream" data-type="sect2"><div class="sect2" id="id94">&#13;
<h2>renderToPipeableStream</h2>&#13;
&#13;
<p><code>renderToPipeableStream</code> is a server-side<a data-primary="renderToPipeableStream API" data-type="indexterm" id="ix_renderToPipeableStreamAPI.06.773.42"/><a data-primary="asynchronous rendering" data-secondary="renderToPipeableStream" data-type="indexterm" id="ix_asynchronousrenderingrenderToPipeableStream.06.773.42"/> rendering API introduced in&#13;
React 18. It provides a more efficient and flexible way to render large&#13;
React applications to a <a data-primary="Node.js" data-type="indexterm" id="id821"/>Node.js stream. It returns a stream that can be&#13;
piped to a response object. <code>renderTo​Pi⁠peableStream</code> provides more&#13;
control over how the HTML is rendered and allows for better integration&#13;
with other Node.js streams<a data-primary="streaming" data-secondary="renderToPipeableStream" data-type="indexterm" id="ix_streamingrenderToPipeableStream.06.778.27"/>.</p>&#13;
&#13;
<p>In addition, it fully supports React’s concurrent features, including&#13;
Suspense, which unlocks better handling of asynchronous data fetching&#13;
during server-side rendering. Because it is a stream, it is also&#13;
streamable over the network, where chunks of HTML can be asynchronously&#13;
and cumulatively sent to clients over the network without blocking. This&#13;
leads to faster TTFB<a data-primary="time to first byte (TTFB)" data-type="indexterm" id="id822"/><a data-primary="TTFB (time to first byte)" data-type="indexterm" id="id823"/> measures and generally better&#13;
performance.</p>&#13;
&#13;
<p>To rewrite our earlier server using <code>renderToPipeableStream</code>, we’d do&#13;
the following:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// server.js</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"express"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"path"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">React</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"react"</code><code class="p">);</code>&#13;
<code class="kr">const</code> <code class="nx">ReactDOMServer</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"react-dom/server"</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">App</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"./src/App"</code><code class="p">);</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">express</code><code class="p">.</code><code class="kr">static</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s2">"build"</code><code class="p">)));</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"*"</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// Changes begin here</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">pipe</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">ReactDOMServer</code><code class="p">.</code><code class="nx">renderToPipeableStream</code><code class="p">(</code><code class="o">&lt;</code><code class="nx">App</code> <code class="o">/&gt;</code><code class="p">,</code> <code class="p">{</code>&#13;
    <code class="c1">// When our app is ready before fetching its own data,</code>&#13;
    <code class="nx">onShellReady</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="c1">// Tell the client we're sending HTML</code>&#13;
      <code class="nx">res</code><code class="p">.</code><code class="nx">setHeader</code><code class="p">(</code><code class="s2">"Content-Type"</code><code class="p">,</code> <code class="s2">"text/html"</code><code class="p">);</code>&#13;
      <code class="nx">pipe</code><code class="p">(</code><code class="nx">res</code><code class="p">);</code> <code class="c1">// pipe the output of the React stream to the response stream</code>&#13;
    <code class="p">},</code>&#13;
  <code class="p">});</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="mi">3000</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Server listening on port 3000"</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>Let’s dive deep into <code>renderToPipeableStream</code>, discussing its features,&#13;
advantages, and use cases. We’ll also provide code snippets and examples&#13;
to help you better understand how to implement this API in your React&#13;
applications.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How it works" data-type="sect3"><div class="sect3" id="id179">&#13;
<h3>How it works</h3>&#13;
&#13;
<p>Similar to <code>renderToString</code>, <code>renderToPipeableStream</code> takes a&#13;
declaratively<a data-primary="declarative programming" data-secondary="in server-side rendering" data-secondary-sortas="server-side rendering" data-type="indexterm" id="id824"/><a data-primary="React" data-secondary="and declarative programming" data-secondary-sortas="declarative programming" data-type="indexterm" id="id825"/> described tree of React elements and, instead of turning&#13;
them into a string of HTML, turns the tree into a Node.js stream. A&#13;
Node.js stream is a fundamental concept in the Node.js runtime&#13;
environment that enables efficient data processing and manipulation.&#13;
Streams provide a way to handle data incrementally in chunks, rather&#13;
than loading the entire data set into memory at once. This approach is&#13;
particularly useful when dealing with large strings or data streams that&#13;
cannot fit entirely in memory or over the network.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Node.js streams" data-type="sect4"><div class="sect4" id="id95">&#13;
<h4>Node.js streams</h4>&#13;
&#13;
<p>At its core, a Node.js stream<a data-primary="renderToPipeableStream API" data-secondary="Node.js streams" data-type="indexterm" id="ix_renderToPipeableStreamAPINodejsstreams.06.842.30"/><a data-primary="Node.js" data-type="indexterm" id="ix_Nodejs.06.842.30"/> represents a flow of data between a source&#13;
and a destination. It can be thought of as a pipeline through which data&#13;
flows, with various operations applied to transform or process the data&#13;
along the way.</p>&#13;
&#13;
<p>Node.js streams are categorized into four types based on their nature&#13;
and direction of data flow:</p>&#13;
<dl>&#13;
<dt>Readable streams</dt>&#13;
<dd>&#13;
<p>A readable stream<a data-primary="readable streams, Node.js" data-type="indexterm" id="id826"/> represents a source of data from&#13;
which you can read. It emits events like <code>data</code>, <code>end</code>, and&#13;
<code>error</code>. Examples of readable streams include reading data from a&#13;
file, receiving data from an HTTP request, or generating data using a&#13;
custom generator.</p>&#13;
&#13;
<p>React’s <code>renderToPipeableStream</code> function returns a readable stream&#13;
where you can read a stream of HTML and output it to a writable stream&#13;
like the <code>res</code> response object from Express.</p>&#13;
</dd>&#13;
<dt>Writable streams</dt>&#13;
<dd>&#13;
<p>A writable stream<a data-primary="writable streams, Node.js" data-type="indexterm" id="id827"/> represents a destination where&#13;
you can write data. It provides methods like <code>write()</code> and <code>end()</code> to&#13;
send data into the stream. Writable streams emit events like <code>drain</code>&#13;
when the destination can handle more data, and <code>error</code> when an error&#13;
occurs during writing. Examples of writable streams include the Express&#13;
<code>res</code> response object.</p>&#13;
</dd>&#13;
<dt>Duplex streams</dt>&#13;
<dd>&#13;
<p>A duplex stream<a data-primary="duplex streams, Node.js" data-type="indexterm" id="id828"/> represents both a readable and&#13;
writable stream simultaneously. It allows bidirectional data flow,&#13;
meaning you can both read from and write to the stream. Duplex streams&#13;
are commonly used for network sockets or communication channels where&#13;
data needs to flow in both directions.</p>&#13;
</dd>&#13;
<dt>Transform streams</dt>&#13;
<dd>&#13;
<p>A transform stream<a data-primary="transform streams, Node.js" data-type="indexterm" id="id829"/> is a special type of duplex&#13;
stream that performs data transformations while data flows through it.&#13;
It reads input data, processes it, and provides the processed data as&#13;
output. Transform streams can be used to perform tasks such as&#13;
compression, encryption, decompression, or data parsing.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>One of the powerful features of Node.js streams is the ability to <a data-primary="piping data between streams" data-type="indexterm" id="id830"/>pipe&#13;
data between streams. Piping allows you to connect the output of a&#13;
readable stream directly to the input of a writable stream, creating a&#13;
seamless flow of data. This greatly simplifies the process of handling&#13;
data and reduces memory usage. Indeed, this is how streaming server-side&#13;
rendering in React works.</p>&#13;
&#13;
<p>Streams in Node.js also support backpressure handling<a data-primary="backpressure handling, Node.js streams" data-type="indexterm" id="id831"/>. Backpressure is a&#13;
problem that occurs during data handling and describes a buildup of data&#13;
behind a buffer during data transfer. When the writable stream is unable&#13;
to handle data quickly enough, the readable stream will pause emitting&#13;
<code>data</code> events, preventing data loss. Once the writable stream is ready&#13;
to consume more data, it emits a <code>drain</code> event, signaling the readable&#13;
stream to resume emitting data.</p>&#13;
&#13;
<p>Without diving too deep and digressing too much here, Node.js streams&#13;
are a powerful abstraction for handling data in a scalable and&#13;
memory-efficient manner. By breaking data into manageable chunks and&#13;
allowing incremental processing, streams enable efficient handling of&#13;
large data sets, file I/O operations, network communication, and much&#13;
more<a data-startref="ix_renderToPipeableStreamAPINodejsstreams.06.842.30" data-type="indexterm" id="id832"/><a data-startref="ix_Nodejs.06.842.30" data-type="indexterm" id="id833"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="React’s renderToPipeableStream" data-type="sect4"><div class="sect4" id="id96">&#13;
<h4>React’s renderToPipeableStream</h4>&#13;
&#13;
<p>In React<a data-primary="renderToPipeableStream API" data-secondary="in React" data-secondary-sortas="React" data-type="indexterm" id="ix_renderToPipeableStreamAPIinReact.06.904.9"/>, the purpose of streaming React components to a writable stream&#13;
is to enhance the TTFB<a data-primary="time to first byte (TTFB)" data-type="indexterm" id="id834"/><a data-primary="TTFB (time to first byte)" data-type="indexterm" id="id835"/> performance of&#13;
server rendered applications. Instead of waiting for the entire HTML&#13;
markup to be generated before sending it to the client, these methods&#13;
enable the server to start sending chunks of the HTML response as they&#13;
are ready, thus reducing the overall latency.</p>&#13;
&#13;
<p>The <code>renderToPipeableStream</code> function is a part of React’s server&#13;
renderer, which is designed to support streaming rendering of a React&#13;
application to a Node.js stream. It’s a part of the server renderer&#13;
architecture<a data-primary="Fizz" data-type="indexterm" id="id836"/> called “Fizz.”</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We’re about to dive super deep into React implementation details that&#13;
are prone to change over time. Once again, this is for educational&#13;
purposes and to satisfy the curiosity of the reader. It may not&#13;
perfectly match the implementation details of React at the time of&#13;
reading, but it’s close enough to get a good idea of how this works at&#13;
the time of writing. This stuff is probably not something you’d use in&#13;
production and is nonessential to knowing how to use React, but is just&#13;
for education and curiosity.</p>&#13;
</div>&#13;
&#13;
<p>Without distracting from our context of server rendering too much,&#13;
here’s a simplified explanation of the flow of how server rendering&#13;
works:</p>&#13;
<dl>&#13;
<dt>Creating a request</dt>&#13;
<dd>&#13;
<p>The function <code>renderToPipeableStream</code> takes as&#13;
input the React elements to be rendered and an optional options object.&#13;
It then creates a request object using a <code>createRequestImpl</code> function<a data-primary="createRequestImpl function" data-type="indexterm" id="id837"/>.&#13;
This request object encapsulates the React elements, resources, response&#13;
state, and format context.</p>&#13;
</dd>&#13;
<dt>Starting the work</dt>&#13;
<dd>&#13;
<p>After creating the request, the <code>startWork</code>&#13;
function<a data-primary="startWork function, renderToPipeableStream" data-type="indexterm" id="id838"/> is called with the request as an argument. This function&#13;
initiates the rendering process. The rendering process is asynchronous&#13;
and can be paused and resumed as needed, which is where React Suspense<a data-primary="React Suspense" data-type="indexterm" id="id839"/><a data-primary="Suspense" data-type="indexterm" id="id840"/> comes&#13;
in. If a component is wrapped in a Suspense boundary and it initiates&#13;
some asynchronous operation (like data fetching), the rendering of that&#13;
component (and possibly its siblings) can be “suspended” until the&#13;
operation &#13;
<span class="keep-together">finishes.</span></p>&#13;
&#13;
<p>While a component is suspended, it can be rendered in a “fallback”&#13;
state, which is typically a loading indicator or a placeholder. Once the&#13;
operation finishes, the component is “resumed” and rendered in its&#13;
final state. Suspense is a powerful feature that enables React to handle&#13;
asynchronous data fetching and lazy loading more effectively during&#13;
server-side rendering.</p>&#13;
&#13;
<p>The benefits are that we are able to serve the user a meaningful&#13;
page immediately, and then progressively enhance it with more data as it&#13;
becomes available. This is a powerful technique that can be used to&#13;
improve the user experience of React applications.</p>&#13;
</dd>&#13;
<dt>Returning a pipeable stream</dt>&#13;
<dd>&#13;
<p><code>renderToPipeableStream</code> then returns&#13;
an object that includes a <code>pipe</code> method and an <code>abort</code> method. The&#13;
<code>pipe</code> method<a data-primary="pipe method, renderToPipeableStream" data-type="indexterm" id="id841"/> is used to pipe the rendered output to a writable stream&#13;
(like an HTTP response object in Node.js). The <code>abort</code> method<a data-primary="abort method, renderToPipeableStream" data-type="indexterm" id="id842"/> can be&#13;
used to cancel any pending I/O and put anything remaining into&#13;
client-rendered mode.</p>&#13;
</dd>&#13;
<dt>Piping to a destination</dt>&#13;
<dd>&#13;
<p>When the <code>pipe</code> method is called with a&#13;
destination stream, it checks if the data has already started flowing.&#13;
If not, it sets <code>hasStartedFlowing</code> to <code>true</code> and calls the&#13;
<code>startFlowing</code> function<a data-primary="startFlowing function, renderToPipeableStream" data-type="indexterm" id="id843"/> with the request and the destination. It also&#13;
sets up handlers for the <code>drain</code>, <code>error</code>, and <code>close</code> events of the&#13;
destination stream.</p>&#13;
</dd>&#13;
<dt>Handling stream events</dt>&#13;
<dd>&#13;
<p>The <code>drain</code> event handler calls <code>startFlowing</code> again to resume the flow of data when the destination&#13;
stream is ready to receive more data. The <code>error</code> and <code>close</code> event&#13;
handlers call the <code>abort</code> function to stop the rendering process if an&#13;
error occurs in the destination stream or if the stream is closed&#13;
prematurely.</p>&#13;
</dd>&#13;
<dt>Aborting the rendering</dt>&#13;
<dd>&#13;
<p>The <code>abort</code> method on the returned object&#13;
can be called with a reason to stop the rendering process. It calls the&#13;
<code>abort</code> function from the <code>react-server</code> module<a data-primary="react-server package" data-type="indexterm" id="id844"/> with the request and the&#13;
reason.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The actual implementation of these functions involves more complex logic&#13;
to handle things like progressive rendering, error handling, and&#13;
integration with the rest of the React server renderer. The code for&#13;
these functions can be found<a data-primary="react-dom package" data-type="indexterm" id="id845"/> in the <code>react-server</code> and <code>react-dom</code>&#13;
packages of the React source code<a data-startref="ix_renderToPipeableStreamAPIinReact.06.904.9" data-type="indexterm" id="id846"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Features of renderToPipeableStream" data-type="sect3"><div class="sect3" id="id180">&#13;
<h3>Features of renderToPipeableStream</h3>&#13;
&#13;
<p><code>renderToPipeableStream</code> features<a data-primary="renderToPipeableStream API" data-secondary="features" data-type="indexterm" id="id847"/> include:</p>&#13;
<dl>&#13;
<dt>Streaming</dt>&#13;
<dd>&#13;
<p><code>renderToPipeableStream</code> returns a pipeable Node.js&#13;
stream, which can be piped to a response object. This allows the server&#13;
to start sending the HTML to the client before the entire page is&#13;
rendered, providing a faster user experience and better performance for&#13;
large applications.</p>&#13;
</dd>&#13;
<dt>Flexibility</dt>&#13;
<dd>&#13;
<p><code>renderToPipeableStream</code> offers more control over how&#13;
the HTML is rendered. It can be easily integrated with other Node.js&#13;
streams, allowing developers to customize the rendering pipeline and&#13;
create more efficient server-side rendering &#13;
<span class="keep-together">solutions.</span></p>&#13;
</dd>&#13;
<dt>Suspense support</dt>&#13;
<dd>&#13;
<p><code>renderToPipeableStream</code> fully supports React’s&#13;
concurrent features, including Suspense. This allows developers to&#13;
manage asynchronous data fetching and lazy loading more effectively&#13;
during server-side rendering, ensuring that data-dependent components&#13;
are only rendered once the necessary data is available.</p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How it fits" data-type="sect3"><div class="sect3" id="id97">&#13;
<h3>How it fits</h3>&#13;
&#13;
<p>Let’s take a look at some code that illustrates<a data-primary="renderToPipeableStream API" data-secondary="illustration of process" data-type="indexterm" id="ix_renderToPipeableStreamAPIillustrationofprocess.06.1015.48"/> the benefits of this&#13;
API. We have an application that displays a list of dog breeds. The list&#13;
is populated by fetching data from an API endpoint. The application is&#13;
rendered on the server using <code>renderTo​Pi⁠peableStream</code> and then sent to&#13;
the client. Let’s start by looking at our dog list &#13;
<span class="keep-together">component:</span></p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="c1">// ./src/DogBreeds.jsx</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">dogResource</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">createResource</code><code class="p">(</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">fetch</code><code class="p">(</code><code class="s2">"https://dog.ceo/api/breeds/list/all"</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">r</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nx">r</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">.</code><code class="nx">then</code><code class="p">((</code><code class="nx">r</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">r</code><code class="p">.</code><code class="nx">message</code><code class="p">))</code><code class="w"/>&#13;
<code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">DogBreeds</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">Suspense</code> <code class="na">fallback</code><code class="o">=</code><code class="s">"Loading..."</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">{</code><code class="nx">dogResource</code><code class="p">.</code><code class="nx">read</code><code class="p">().</code><code class="nx">map</code><code class="p">((</code><code class="nx">profile</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">&lt;</code><code class="nt">li</code> <code class="na">key</code><code class="o">=</code><code class="p">{</code><code class="nx">profile</code><code class="p">}&gt;{</code><code class="nx">profile</code><code class="p">}&lt;/</code><code class="nt">li</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">))}</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">Suspense</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="nx">DogBreeds</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>Now, let’s look at our overall <code>App</code> that contains the <code>DogBreeds</code>&#13;
component:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="c1">// src/App.js</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="p">,</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">Suspense</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">ListOfBreeds</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">React</code><code class="p">.</code><code class="nx">lazy</code><code class="p">(()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="k">import</code><code class="p">(</code><code class="s2">"./DogBreeds"</code><code class="p">));</code><code class="w"/>&#13;
&#13;
<code class="kd">function</code><code class="w"> </code><code class="nx">App</code><code class="p">()</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="k">return</code><code class="w"> </code><code class="p">(</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code><code class="nx">Dog</code><code class="w"> </code><code class="nx">Breeds</code><code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;</code><code class="nt">Suspense</code> <code class="na">fallback</code><code class="o">=</code><code class="p">{&lt;</code><code class="nt">div</code><code class="p">&gt;</code><code class="nx">Loading</code><code class="w"> </code><code class="nx">Dog</code><code class="w"> </code><code class="nx">Breeds</code><code class="p">...&lt;/</code><code class="nt">div</code><code class="p">&gt;}&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">&lt;</code><code class="nt">ListOfBreeds</code> <code class="p">/&gt;</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">Suspense</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">);</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="k">export</code><code class="w"> </code><code class="k">default</code><code class="w"> </code><code class="nx">App</code><code class="p">;</code><code class="w"/></pre>&#13;
&#13;
<p>Notice, we’re using <code>React.lazy</code> here as mentioned in prior chapters,&#13;
just so we have another Suspense boundary to demonstrate how&#13;
<code>renderToPipeableStream</code> handles Suspense. OK, let’s tie this all&#13;
together with an Express server:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="c1">// server.js</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">express</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"express"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">React</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">renderToPipeableStream</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"react-dom/server"</code><code class="p">;</code><code class="w"/>&#13;
<code class="k">import</code><code class="w"> </code><code class="nx">App</code><code class="w"> </code><code class="kr">from</code><code class="w"> </code><code class="s2">"./App.jsx"</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="kd">const</code><code class="w"> </code><code class="nx">app</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">express</code><code class="p">();</code><code class="w"/>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">express</code><code class="p">.</code><code class="k">static</code><code class="p">(</code><code class="s2">"build"</code><code class="p">));</code><code class="w"/>&#13;
&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/"</code><code class="p">,</code><code class="w"> </code><code class="k">async</code><code class="w"> </code><code class="p">(</code><code class="nx">req</code><code class="p">,</code><code class="w"> </code><code class="nx">res</code><code class="p">)</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// Define the starting HTML structure</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="nx">htmlStart</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="sb">`</code>&#13;
<code class="sb">    &lt;!DOCTYPE html&gt;</code>&#13;
<code class="sb">    &lt;html lang="en"&gt;</code>&#13;
<code class="sb">      &lt;head&gt;</code>&#13;
<code class="sb">        &lt;meta charset="UTF-8" /&gt;</code>&#13;
<code class="sb">        &lt;meta name="viewport" content="width=device-width, initial-scale=1.0" /&gt;</code>&#13;
<code class="sb">        &lt;title&gt;React Suspense with renderToPipeableStream&lt;/title&gt;</code>&#13;
<code class="sb">      &lt;/head&gt;</code>&#13;
<code class="sb">      &lt;body&gt;</code>&#13;
<code class="sb">        &lt;div id="root"&gt;</code>&#13;
<code class="sb">  `</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="c1">// Write the starting HTML to the response</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">res</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">htmlStart</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="c1">// Call renderToPipeableStream with the React App component</code><code class="w"/>&#13;
<code class="w">  </code><code class="c1">// and an options object to handle shell readiness</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">const</code><code class="w"> </code><code class="p">{</code><code class="w"> </code><code class="nx">pipe</code><code class="w"> </code><code class="p">}</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">renderToPipeableStream</code><code class="p">(&lt;</code><code class="nt">App</code> <code class="p">/&gt;,</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">onShellReady</code><code class="o">:</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="c1">// Pipe the rendered output to the response when the shell is ready</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">pipe</code><code class="p">(</code><code class="nx">res</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">},</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">});</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/>&#13;
&#13;
<code class="c1">// Start the server on port 3000 and log a message to the console</code><code class="w"/>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="mf">3000</code><code class="p">,</code><code class="w"> </code><code class="p">()</code><code class="w"> </code><code class="p">=&gt;</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Server is listening on port 3000"</code><code class="p">);</code><code class="w"/>&#13;
<code class="p">});</code><code class="w"/></pre>&#13;
&#13;
<p>What we’re doing in this code snippet is responding to a request&#13;
with a stream of HTML. We’re using <code>renderToPipeableStream</code> to render&#13;
our <code>App</code> component to a stream, and then piping that stream to our&#13;
response object. We’re also using the <code>onShellReady</code> option to pipe the&#13;
stream to the response object once the shell is ready. The shell is the&#13;
HTML that is rendered before the React application is hydrated, and&#13;
before data dependencies wrapped in Suspense boundaries are resolved. In&#13;
our case, the shell is the HTML that is rendered before the dog breeds&#13;
are fetched from the API. Let’s take a look at what happens when we run&#13;
this code.</p>&#13;
&#13;
<p>If we visit <em><a class="bare" href="http://localhost:3000"><em class="hyperlink">http://localhost:3000</em></a></em>, we get a page with a heading “Dog&#13;
Breeds,” and our Suspense fallback “Loading Dog Breeds….” This is the&#13;
shell that is rendered before the dog breeds are fetched from the API.&#13;
The really cool thing is that even if we don’t include React on the client&#13;
side in our HTML and hydrate the page, the Suspense fallback is replaced&#13;
with the actual dog breeds once they are fetched from the API. This&#13;
swapping of DOM when data becomes available happens entirely from the&#13;
server side, without client-side React!</p>&#13;
&#13;
<p>Let’s understand how this works in a bit more detail.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Once again, we are about to dive deep into React implementation details&#13;
here that are quite likely to change over time. The point of this&#13;
exercise (and this book) is not to obsess over single implementation&#13;
details, but instead to understand the underlying mechanism so we can&#13;
learn and reason about React better. This isn’t required to <em>use</em> React,&#13;
but understanding the mechanism can give us hints and practical tools to&#13;
use in our day-to-day working with React. With that, let’s move forward.</p>&#13;
</div>&#13;
&#13;
<p>When we visit <em><a class="bare" href="http://localhost:3000"><em class="hyperlink">http://localhost:3000</em></a></em>, the server responds with the HTML&#13;
shell, which includes the heading “Dog Breeds” and the Suspense&#13;
fallback “Loading Dog Breeds….” This HTML looks like this:</p>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="cp">&lt;!DOCTYPE html&gt;</code>&#13;
<code class="p">&lt;</code><code class="nt">html</code> <code class="na">lang</code><code class="o">=</code><code class="s">"en"</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">meta</code> <code class="na">charset</code><code class="o">=</code><code class="s">"UTF-8"</code> <code class="p">/&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">meta</code> <code class="na">name</code><code class="o">=</code><code class="s">"viewport"</code> <code class="na">content</code><code class="o">=</code><code class="s">"width=device-width, initial-scale=1.0"</code> <code class="p">/&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>React Suspense with renderToPipeableStream<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;</code><code class="nt">div</code> <code class="na">id</code><code class="o">=</code><code class="s">"root"</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>User Profiles<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>&#13;
        <code class="cm">&lt;!--$?--&gt;</code><code class="p">&lt;</code><code class="nt">template</code> <code class="na">id</code><code class="o">=</code><code class="s">"B:0"</code><code class="p">&gt;&lt;/</code><code class="nt">template</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">div</code><code class="p">&gt;</code>Loading user profiles...<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
        <code class="cm">&lt;!--/$--&gt;</code>&#13;
      <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">div</code> <code class="na">hidden</code> <code class="na">id</code><code class="o">=</code><code class="s">"S:0"</code><code class="p">&gt;</code>&#13;
        <code class="p">&lt;</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
          <code class="cm">&lt;!--$--&gt;</code>&#13;
          <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>affenpinscher<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
          <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>african<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
          <code class="p">&lt;</code><code class="nt">li</code><code class="p">&gt;</code>airedale<code class="p">&lt;/</code><code class="nt">li</code><code class="p">&gt;</code>&#13;
          [...]&#13;
          <code class="cm">&lt;!--/$--&gt;</code>&#13;
        <code class="p">&lt;/</code><code class="nt">ul</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
      <code class="p">&lt;</code><code class="nt">script</code><code class="p">&gt;</code><code class="w"/>&#13;
<code class="w">        </code><code class="kd">function</code><code class="w"> </code><code class="nx">$RC</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="w"> </code><code class="nx">b</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">a</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">b</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">b</code><code class="p">.</code><code class="nx">parentNode</code><code class="p">.</code><code class="nx">removeChild</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">          </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">a</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="nx">a</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">a</code><code class="p">.</code><code class="nx">previousSibling</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">            </code><code class="kd">var</code><code class="w"> </code><code class="nx">f</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">a</code><code class="p">.</code><code class="nx">parentNode</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">              </code><code class="nx">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">a</code><code class="p">.</code><code class="nx">nextSibling</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">              </code><code class="nx">e</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">do</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">              </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">c</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="mf">8</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">nodeType</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">                </code><code class="kd">var</code><code class="w"> </code><code class="nx">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">data</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">                </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="s2">"/$"</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">d</code><code class="p">)</code><code class="w"/>&#13;
<code class="w">                  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="mf">0</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">e</code><code class="p">)</code><code class="w"> </code><code class="k">break</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">                  </code><code class="k">else</code><code class="w"> </code><code class="nx">e</code><code class="o">--</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">                </code><code class="k">else</code><code class="w"> </code><code class="p">(</code><code class="s2">"$"</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="nx">d</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="s2">"$?"</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="nx">d</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="s2">"$!"</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="nx">d</code><code class="p">)</code><code class="w"> </code><code class="o">||</code><code class="w"> </code><code class="nx">e</code><code class="o">++</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">              </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">              </code><code class="nx">d</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">c</code><code class="p">.</code><code class="nx">nextSibling</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">              </code><code class="nx">f</code><code class="p">.</code><code class="nx">removeChild</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">              </code><code class="nx">c</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">d</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">            </code><code class="p">}</code><code class="w"> </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nx">c</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">for</code><code class="w"> </code><code class="p">(;</code><code class="w"> </code><code class="nx">b</code><code class="p">.</code><code class="nx">firstChild</code><code class="p">;</code><code class="w"> </code><code class="p">)</code><code class="w"> </code><code class="nx">f</code><code class="p">.</code><code class="nx">insertBefore</code><code class="p">(</code><code class="nx">b</code><code class="p">.</code><code class="nx">firstChild</code><code class="p">,</code><code class="w"> </code><code class="nx">c</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">            </code><code class="nx">a</code><code class="p">.</code><code class="nx">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"$"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">            </code><code class="nx">a</code><code class="p">.</code><code class="nx">_reactRetry</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">a</code><code class="p">.</code><code class="nx">_reactRetry</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">        </code><code class="nx">$RC</code><code class="p">(</code><code class="s2">"B:0"</code><code class="p">,</code><code class="w"> </code><code class="s2">"S:0"</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">&lt;/</code><code class="nt">script</code><code class="p">&gt;</code>&#13;
    <code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code>&#13;
  <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>&#13;
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>What we see here is quite interesting. There’s a <code>&lt;template&gt;</code> element with a generated ID (<code>B:0</code> in this&#13;
case), and some HTML comments. The HTML comments are used to mark the&#13;
start and end of the shell. These are markers or “holes” where&#13;
resolved data will go once Suspense is resolved. <code>&lt;template&gt;</code> elements<a data-primary="&lt;template&gt; element, HTML, in renderToPipeableStream" data-type="indexterm" id="id848"/>&#13;
in HTML provide a way to construct document subtrees and hold nodes&#13;
without introducing an additional wrapping level of the DOM hierarchy.&#13;
They serve as lightweight containers for managing groups of nodes,&#13;
improving performance by reducing the amount of work done during DOM&#13;
manipulation.</p>&#13;
&#13;
<p>There’s also a <code>&lt;script&gt;</code> element<a data-primary="&lt;script&gt; element, HTML, in renderToPipeableStream" data-type="indexterm" id="id849"/>. This <code>&lt;script&gt;</code> tag contains a&#13;
function<a data-primary="$RC function" data-type="indexterm" id="id850"/> called <code>$RC</code> that is used to replace the shell with the actual&#13;
content. The <code>$RC</code> function takes two arguments: the ID of the&#13;
<code>&lt;template&gt;</code> element that contains the marker, and the ID of the <code>&lt;div&gt;</code>&#13;
element that contains the fallback. The function then fills the marker&#13;
with rendered UI after data is available, while removing the fallback.</p>&#13;
&#13;
<p>It’s pretty unfortunate that this function is minified, but let’s try to&#13;
unminify it and understand what it does. If we do, this is what we&#13;
observe:</p>&#13;
&#13;
<pre data-code-language="jsx" data-type="programlisting"><code class="kd">function</code><code class="w"> </code><code class="nx">reactComponentCleanup</code><code class="p">(</code><code class="nx">reactMarkerId</code><code class="p">,</code><code class="w"> </code><code class="nx">siblingId</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">let</code><code class="w"> </code><code class="nx">reactMarker</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">reactMarkerId</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="kd">let</code><code class="w"> </code><code class="nx">sibling</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nb">document</code><code class="p">.</code><code class="nx">getElementById</code><code class="p">(</code><code class="nx">siblingId</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">  </code><code class="nx">sibling</code><code class="p">.</code><code class="nx">parentNode</code><code class="p">.</code><code class="nx">removeChild</code><code class="p">(</code><code class="nx">sibling</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">  </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">reactMarker</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">reactMarker</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">reactMarker</code><code class="p">.</code><code class="nx">previousSibling</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="kd">let</code><code class="w"> </code><code class="nx">parentNode</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">reactMarker</code><code class="p">.</code><code class="nx">parentNode</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">nextSibling</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">reactMarker</code><code class="p">.</code><code class="nx">nextSibling</code><code class="p">,</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">nestedLevel</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="mf">0</code><code class="p">;</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">do</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="nx">nextSibling</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="mf">8</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">nextSibling</code><code class="p">.</code><code class="nx">nodeType</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">        </code><code class="kd">let</code><code class="w"> </code><code class="nx">nodeData</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">nextSibling</code><code class="p">.</code><code class="nx">data</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">        </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="s2">"/$"</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">nodeData</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">          </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="mf">0</code><code class="w"> </code><code class="o">===</code><code class="w"> </code><code class="nx">nestedLevel</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="k">break</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">            </code><code class="nx">nestedLevel</code><code class="o">--</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">          </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}</code><code class="w"> </code><code class="k">else</code><code class="w"> </code><code class="k">if</code><code class="w"> </code><code class="p">(</code><code class="s2">"$"</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="nx">nodeData</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="s2">"$?"</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="nx">nodeData</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="s2">"$!"</code><code class="w"> </code><code class="o">!==</code><code class="w"> </code><code class="nx">nodeData</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">          </code><code class="nx">nestedLevel</code><code class="o">++</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">        </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">      </code><code class="p">}</code><code class="w"/>&#13;
<code class="w">      </code><code class="kd">let</code><code class="w"> </code><code class="nx">nextNode</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">nextSibling</code><code class="p">.</code><code class="nx">nextSibling</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">parentNode</code><code class="p">.</code><code class="nx">removeChild</code><code class="p">(</code><code class="nx">nextSibling</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">nextSibling</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="nx">nextNode</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"> </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nx">nextSibling</code><code class="p">);</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="k">while</code><code class="w"> </code><code class="p">(</code><code class="nx">sibling</code><code class="p">.</code><code class="nx">firstChild</code><code class="p">)</code><code class="w"> </code><code class="p">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="nx">parentNode</code><code class="p">.</code><code class="nx">insertBefore</code><code class="p">(</code><code class="nx">sibling</code><code class="p">.</code><code class="nx">firstChild</code><code class="p">,</code><code class="w"> </code><code class="nx">nextSibling</code><code class="p">);</code><code class="w"/>&#13;
<code class="w">    </code><code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="w">    </code><code class="nx">reactMarker</code><code class="p">.</code><code class="nx">data</code><code class="w"> </code><code class="o">=</code><code class="w"> </code><code class="s2">"$"</code><code class="p">;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nx">reactMarker</code><code class="p">.</code><code class="nx">_reactRetry</code><code class="w"> </code><code class="o">&amp;&amp;</code><code class="w"> </code><code class="nx">reactMarker</code><code class="p">.</code><code class="nx">_reactRetry</code><code class="p">();</code><code class="w"/>&#13;
<code class="w">  </code><code class="p">}</code><code class="w"/>&#13;
<code class="p">}</code><code class="w"/>&#13;
&#13;
<code class="nx">reactComponentCleanup</code><code class="p">(</code><code class="s2">"B:0"</code><code class="p">,</code><code class="w"> </code><code class="s2">"S:0"</code><code class="p">);</code><code class="w"/></pre>&#13;
&#13;
<p>Let’s break this down further.</p>&#13;
&#13;
<p>The function takes two arguments: <code>reactMarkerId</code> and <code>siblingId</code>.&#13;
Effectively, the marker is a hole where rendered components will go once&#13;
they’re available, and the sibling is the Suspense fallback.</p>&#13;
&#13;
<p>The function then removes the sibling element (the fallback) from the&#13;
DOM using the <code>removeChild</code> method on its parent node when data is&#13;
available.</p>&#13;
&#13;
<p>If the <code>reactMarker</code> element exists, the function runs. It sets the&#13;
<code>reactMarker</code> variable to the previous sibling of the current&#13;
<code>reactMarker</code> element. The function also initializes the variables&#13;
<code>parentNode</code>, <code>nextSibling</code>, and <code>nestedLevel</code>.</p>&#13;
&#13;
<p>A <code>do...while</code> loop is used to traverse the DOM tree, starting with the&#13;
<code>nextSibling</code> element. The loop continues as long as the <code>nextSibling</code>&#13;
element exists. Inside the loop, the function checks whether the&#13;
<code>nextSibling</code> element is a comment node (indicated by a <code>nodeType</code> value&#13;
of <code>8</code>):</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the <code>nextSibling</code> element is a comment node, the function inspects&#13;
its data (i.e., the text content of the comment). It checks whether the&#13;
data is equal to <code>"/$"</code>, which signifies the end of a nested structure.&#13;
If the <code>nestedLevel</code> value is <code>0</code>, the loop breaks, indicating that the&#13;
desired end of the structure has been reached. If the <code>nestedLevel</code> value&#13;
is not <code>0</code>, it means that the current <code>"/$"</code> comment node is part of a&#13;
nested structure, and the <code>nestedLevel</code> value is decremented.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the comment node data is not equal to <code>"/$"</code>, the function checks&#13;
whether it is equal to <code>"$"</code>, <code>"$?"</code>, or <code>"$!"</code>. These values indicate&#13;
the beginning of a new nested structure. If any of these values are&#13;
encountered, the <code>nestedLevel</code> value is &#13;
<span class="keep-together">incremented.</span></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>During each iteration of the loop, the <code>nextSibling</code> element (that is,&#13;
the Suspense boundary) is removed from the DOM using the <code>removeChild</code>&#13;
method on its parent node. The loop continues with the next sibling&#13;
element in the DOM tree.</p>&#13;
&#13;
<p>Once the loop has completed, the function moves all child elements of&#13;
the sibling element to the location immediately before the <code>nextSibling</code>&#13;
element in the DOM tree using the <code>insertBefore</code> method. This process&#13;
effectively restructures the DOM around the <code>reactMarker</code> element and&#13;
replaces a Suspense fallback with the component it wraps.</p>&#13;
&#13;
<p>The function then sets the data of the <code>reactMarker</code> element to <code>"$"</code>,&#13;
which is likely used to mark the component for future processing or&#13;
reference. If a <code>reactRetry</code> property exists on the <code>reactMarker</code>&#13;
element and it is a function, the function invokes this method.</p>&#13;
&#13;
<p>If some of this was difficult to follow, don’t worry about it. We can&#13;
summarize all of this here: essentially, this function waits for&#13;
data-dependent React components to be ready, and when they are, swaps&#13;
out Suspense fallbacks for the server rendered components. It uses&#13;
comment nodes with specific data values to determine the structure of&#13;
the components, and manipulates the DOM accordingly. Since this is&#13;
inlined in our HTML from the server, we can stream data like this using&#13;
<code>renderToPipeableStream</code> and have the browser render the UI as it&#13;
becomes available without even including React in the browser bundle or&#13;
hydrating.</p>&#13;
&#13;
<p>Thus, <code>renderToPipeableStream</code> gives us quite a bit more control and&#13;
power compared to <code>renderToString</code> when server rendering<a data-startref="ix_renderToPipeableStreamAPI.06.773.42" data-type="indexterm" id="id851"/><a data-startref="ix_streamingrenderToPipeableStream.06.778.27" data-type="indexterm" id="id852"/><a data-startref="ix_renderToPipeableStreamAPIillustrationofprocess.06.1015.48" data-type="indexterm" id="id853"/><a data-startref="ix_asynchronousrenderingrenderToPipeableStream.06.773.42" data-type="indexterm" id="id854"/>.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="renderToReadableStream" data-type="sect2"><div class="sect2" id="id98">&#13;
<h2>renderToReadableStream</h2>&#13;
&#13;
<p>The previous API<a data-primary="renderToReadableStream API" data-type="indexterm" id="ix_renderToReadableStreamAPI.06.1348.17"/><a data-primary="browser streams" data-type="indexterm" id="ix_browserstreams.06.1348.17"/><a data-primary="asynchronous rendering" data-secondary="renderToReadableStream" data-type="indexterm" id="ix_asynchronousrenderingrenderToReadableStream.06.1348.17"/><a data-primary="streaming" data-secondary="browser streams" data-type="indexterm" id="ix_streamingbrowserstreams.06.1348.17"/> we covered, <code>renderToPipeableStream</code>, makes use of&#13;
Node.js streams under the hood. However, browsers also have support for&#13;
streams and browser streams slightly differ from Node.js<a data-primary="Node.js" data-type="indexterm" id="ix_Nodejs.06.1350.57"/> streams.&#13;
Node.js streams are primarily designed to operate in a server-side&#13;
environment, where they deal with file I/O, network I/O, or any kind of&#13;
end-to-end streaming. They follow a custom API defined by the Node.js&#13;
environment and have been a core part of Node.js for a long time.&#13;
Node.js streams have distinct classes for readable, writable, duplex,&#13;
and transform streams, and utilize events like <code>data</code>, <code>end</code>, and&#13;
<code>error</code> to manage stream flow and handle data.</p>&#13;
&#13;
<p>Browser streams are designed to operate in a client-side environment&#13;
within web browsers. They often deal with streaming data from network&#13;
requests, media streaming, or other data-processing tasks in the&#13;
browser. Browser streams follow the Streams standard defined by the&#13;
WHATWG (Web Hypertext Application Technology Working Group), aiming to&#13;
standardize APIs across the web. Unlike Node.js streams, browser streams&#13;
use methods like <code>read()</code>, <code>write()</code>, and <code>pipeThrough()</code> to control the&#13;
flow of data and then process that streamed data. They provide a more&#13;
standardized and promise-based API. Here is an example of a readable&#13;
stream in a browser environment:</p>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="kr">const</code> <code class="nx">readableStream</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ReadableStream</code><code class="p">({</code>&#13;
  <code class="nx">start</code><code class="p">(</code><code class="nx">controller</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="nx">controller</code><code class="p">.</code><code class="nx">enqueue</code><code class="p">(</code><code class="s2">"Hello, "</code><code class="p">);</code>&#13;
    <code class="nx">controller</code><code class="p">.</code><code class="nx">enqueue</code><code class="p">(</code><code class="s2">"world!"</code><code class="p">);</code>&#13;
    <code class="nx">controller</code><code class="p">.</code><code class="nx">close</code><code class="p">();</code>&#13;
  <code class="p">},</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="kr">const</code> <code class="nx">reader</code> <code class="o">=</code> <code class="nx">readableStream</code><code class="p">.</code><code class="nx">getReader</code><code class="p">();</code>&#13;
&#13;
<code class="nx">async</code> <code class="kd">function</code> <code class="nx">readAllChunks</code><code class="p">(</code><code class="nx">streamReader</code><code class="p">)</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>&#13;
  <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="kr">const</code> <code class="p">{</code> <code class="nx">done</code><code class="p">,</code> <code class="nx">value</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">streamReader</code><code class="p">.</code><code class="nx">read</code><code class="p">();</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">break</code><code class="p">;</code>&#13;
    <code class="p">}</code>&#13;
    <code class="nx">result</code> <code class="o">+=</code> <code class="nx">value</code><code class="p">;</code>&#13;
  <code class="p">}</code>&#13;
  <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">readAllChunks</code><code class="p">(</code><code class="nx">reader</code><code class="p">).</code><code class="nx">then</code><code class="p">((</code><code class="nx">text</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>While both Node.js streams and browser streams serve the purpose of&#13;
handling streaming data, they operate in different environments with&#13;
slightly different APIs and standards. Node.js streams are event<a data-primary="event-driven architecture" data-secondary="Node.js" data-type="indexterm" id="id855"/> driven&#13;
and are well suited for server-side operations, whereas browser streams&#13;
are promise based, aligning with modern web standards, and are tailored&#13;
for client-side operations<a data-startref="ix_Nodejs.06.1350.57" data-type="indexterm" id="id856"/>.</p>&#13;
&#13;
<p>To support both environments, React has <code>renderToPipeableStream</code> for&#13;
Node.js streams, and <code>renderToReadableStream</code> for browser streams. The&#13;
<code>renderToReadableStream</code> API is similar to <code>renderToPipeableStream</code>, but&#13;
it returns a readable stream for the browser instead of a Node.js-native&#13;
stream<a data-startref="ix_renderToReadableStreamAPI.06.1348.17" data-type="indexterm" id="id857"/><a data-startref="ix_browserstreams.06.1348.17" data-type="indexterm" id="id858"/><a data-startref="ix_asynchronousrenderingrenderToReadableStream.06.1348.17" data-type="indexterm" id="id859"/><a data-startref="ix_streamingbrowserstreams.06.1348.17" data-type="indexterm" id="id860"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="When to Use What" data-type="sect2"><div class="sect2" id="id99">&#13;
<h2>When to Use What</h2>&#13;
&#13;
<p><code>renderToString</code> isn’t ideal because it is synchronous. This is quite&#13;
problematic for a number of reasons:</p>&#13;
<dl>&#13;
<dt>Network I/O is asynchronous.</dt>&#13;
<dd>&#13;
<p>Any data <a data-primary="asynchronous rendering" data-secondary="and renderToString’s synchronous disadvantage" data-secondary-sortas="renderToString’s synchronous disadvantage" data-type="indexterm" id="id861"/>fetching we do depends on&#13;
retrieving data from somewhere: a database, a web service, the filesystem, etc. These operations are often asynchronous: meaning that they&#13;
start and end at discrete points in time, not at the same time. Because&#13;
<code>renderToString</code> is synchronous<a data-primary="renderToString API" data-type="indexterm" id="id862"/><a data-primary="synchronous rendering" data-secondary="renderToString API" data-type="indexterm" id="id863"/>, it cannot wait for asynchronous&#13;
requests to complete and <em>must</em> send a string instantly to the browser.&#13;
This means that the server cannot complete things, the client gets a&#13;
shell before any data has loaded, and the client ideally picks up where&#13;
the server left off after hydration. This presents performance problems&#13;
by way of network waterfalls.</p>&#13;
</dd>&#13;
<dt>Servers serve multiple clients.</dt>&#13;
<dd>&#13;
<p>If your server that calls&#13;
<code>renderToString</code> is busy rendering to a string and 30 clients have sent&#13;
new requests to it, those new clients will have to wait for it to finish&#13;
its current work. Because <code>renderToString</code> is synchronous, it blocks&#13;
until it’s done. In the one-to-many relationship between servers and&#13;
clients, blocking means your clients wait longer than they should.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Newer alternatives<a data-primary="renderToPipeableStream API" data-secondary="asynchronous approach" data-type="indexterm" id="id864"/><a data-primary="renderToReadableStream API" data-type="indexterm" id="id865"/><a data-primary="asynchronous rendering" data-secondary="renderToPipeableStream" data-type="indexterm" id="id866"/> like <code>renderToPipeableStream</code> and&#13;
<code>renderToReadableStream</code> are asynchronous stream-based approaches that&#13;
solve for both of these problems, with <code>renderToReadableStream</code> being&#13;
browser native and <code>renderToPipeableStream</code> being server native. Thus,&#13;
if the question is “what’s the best API to use on the server?” the&#13;
answer is clearly either <code>renderToPipeableStream</code> or&#13;
<code>renderToReadableStream</code>, depending on the environment.</p>&#13;
&#13;
<p>That said, while <code>renderTo*Stream</code> appears to be a superior set of APIs,&#13;
there is currently no “full user story” around these APIs at the time&#13;
of writing. Many third-party libraries that are currently around will&#13;
not work with them, especially considering data fetching or CSS&#13;
libraries. This is because they conceptually need a “full run” on the&#13;
server, then need to create data, and then rerender the application with&#13;
that data to actually stream from the server. They don’t support&#13;
scenarios where an app hasn’t finished rendering on the server yet, but&#13;
needs to start partially hydrating in the browser.</p>&#13;
&#13;
<p>This is a React problem: there are no APIs in React 18 (the latest&#13;
release at the time of writing) that would allow for support of any kind&#13;
of streaming or partial rehydration of third-party data. The React team has&#13;
recently added a bunch of new APIs<a data-primary="react-dom package" data-type="indexterm" id="id867"/> to <code>react-dom</code>, like <code>prefetchDNS</code>,&#13;
<code>preconnect</code>, <code>preload</code>, etc., to address that, but those will only ship&#13;
with React 19. Even with these APIs, there are still a few important&#13;
APIs missing to make <code>renderToPipeableStream</code> a viable option.</p>&#13;
&#13;
<p>The only really viable option to use <code>renderToPipeableStream</code> right now&#13;
would be to prefetch all required data (or in the case of a CSS library,&#13;
render the full application with <code>renderToString</code> to “prerecord” all&#13;
classes that need rendering) before calling <code>renderToPipeableStream</code> in&#13;
the first place—which would pretty much eliminate most of its benefits&#13;
over <code>renderToString</code>, essentially making it a synchronous API again.</p>&#13;
&#13;
<p>All things considered, these are complex topics that require a good&#13;
amount of forethought, careful planning, and further consideration around&#13;
which APIs to use that equally depend on your current projects and use&#13;
cases<a data-startref="ix_serversiderenderingSSRserverrenderingAPIs.06.598.24" data-type="indexterm" id="id868"/>. Thus, the answer is once again “it depends,” or “just use a&#13;
framework” and defer the decision to the broader &#13;
<span class="keep-together">community.</span></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Don’t Roll Your Own" data-type="sect1"><div class="sect1" id="id100">&#13;
<h1>Don’t Roll Your Own</h1>&#13;
&#13;
<p>Creating a custom server rendering implementation<a data-primary="server-side rendering (SSR)" data-secondary="custom implementation" data-type="indexterm" id="ix_serversiderenderingSSRcustomimplementation.06.1477.50"/><a data-primary="custom server rendering implementation" data-type="indexterm" id="ix_customserverrenderingimplementation.06.1477.50"/> for a React&#13;
application can be a challenging and time-consuming task. While React&#13;
does provide some APIs for server rendering, building a custom solution&#13;
from scratch can lead to various issues and inefficiencies. In this&#13;
section, we’ll explore the reasons why it’s better to rely on&#13;
established frameworks like Next.js and Remix<a data-primary="Next.js" data-type="indexterm" id="ix_Nextjs.06.1482.46"/><a data-primary="Remix" data-type="indexterm" id="ix_Remix.06.1482.46"/><a data-primary="frameworks" data-secondary="Remix" data-type="indexterm" id="ix_frameworksRemix.06.1482.46"/>, rather than building your&#13;
own server rendering solution:</p>&#13;
<dl>&#13;
<dt>Handling edge cases and complexities</dt>&#13;
<dd>&#13;
<p>React applications can become&#13;
quite complex, and implementing server rendering requires addressing&#13;
various edge cases and complexities. These can include handling&#13;
asynchronous data fetching, code splitting, and managing various React&#13;
lifecycle events. By using a framework like Next.js or Remix, you can&#13;
avoid the need to handle these complexities yourself, as these&#13;
frameworks have built-in solutions for many common edge cases.</p>&#13;
&#13;
<p>One such edge case is security<a data-primary="security" data-secondary="frameworks versus customizing" data-type="indexterm" id="ix_securityframeworksversuscustomizing.06.1494.31"/>. As the server processes numerous client&#13;
requests, it’s crucial to ensure that sensitive data from one client&#13;
doesn’t inadvertently leak to another. This is where frameworks like&#13;
Next.js, Remix, and Gatsby<a data-primary="Gatsby" data-type="indexterm" id="id869"/> can provide invaluable assistance in handling&#13;
these concerns. Imagine a scenario where client A accesses the server,&#13;
and their data is cached by the server. If the server accidentally&#13;
serves this cached data to client B, sensitive information could be&#13;
exposed.</p>&#13;
&#13;
<p>Consider the following example:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="c1">// server.js</code>&#13;
&#13;
<code class="c1">// Import the express module</code>&#13;
<code class="kr">const</code> <code class="nx">express</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"express"</code><code class="p">);</code>&#13;
&#13;
<code class="c1">// Create a new express application instance</code>&#13;
<code class="kr">const</code> <code class="nx">app</code> <code class="o">=</code> <code class="nx">express</code><code class="p">();</code>&#13;
&#13;
<code class="c1">// Declare a variable to hold cached user data</code>&#13;
<code class="c1">// Initially, it is null as there's no data cached yet</code>&#13;
<code class="kd">let</code> <code class="nx">cachedUserData</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Define a route handler for GET requests to "/user/:userId"</code>&#13;
<code class="c1">// This will respond with user data for the specified user ID</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"/user/:userId"</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="c1">// Extract the userId from the request parameters</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">userId</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// Check if there's cached user data</code>&#13;
  <code class="c1">// If so, respond with the cached data</code>&#13;
  <code class="k">if</code> <code class="p">(</code><code class="nx">cachedUserData</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">(</code><code class="nx">cachedUserData</code><code class="p">);</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="c1">// If not, fetch user data from a database or another source</code>&#13;
  <code class="c1">// The fetchUserData function is assumed to be defined elsewhere</code>&#13;
  <code class="kr">const</code> <code class="nx">userData</code> <code class="o">=</code> <code class="nx">fetchUserData</code><code class="p">(</code><code class="nx">userId</code><code class="p">);</code>&#13;
&#13;
  <code class="c1">// Update the cache with the fetched user data</code>&#13;
  <code class="nx">cachedUserData</code> <code class="o">=</code> <code class="nx">userData</code><code class="p">;</code>&#13;
&#13;
  <code class="c1">// Respond with the fetched user data</code>&#13;
  <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">(</code><code class="nx">userData</code><code class="p">);</code>&#13;
<code class="p">});</code>&#13;
&#13;
<code class="c1">// Start the server, listening on port 3000</code>&#13;
<code class="c1">// Log a message to the console once the server is ready</code>&#13;
<code class="nx">app</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="mi">3000</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Server listening on port 3000"</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>In the given code, <code>cachedUserData</code> is intended to cache the user data,&#13;
but it’s shared across all requests regardless of the <code>userId</code>. Every&#13;
time a request is made to <code>/user/:userId</code>, the server checks&#13;
<code>cachedUserData</code> to see if there’s cached data. If there is, it returns&#13;
the cached data regardless of whether the <code>userId</code> matches the <code>userId</code>&#13;
of the cached data. If there isn’t, it fetches the data, caches it, and&#13;
returns it. This means that if two requests are made in sequence to&#13;
<code>/user/1</code> and &#13;
<span class="keep-together"><code>/user/2</code>,</span> the second request would receive the data of&#13;
the first user, which is a significant security issue.</p>&#13;
&#13;
<p>A more secure caching strategy would be to cache the data in a way&#13;
that’s associated with the <code>userId</code> so that each user has their own&#13;
cache. One way to do this would be to use an object to hold the cached&#13;
data, with the <code>userId</code> as the key.</p>&#13;
&#13;
<p>If we roll our own, the risk of human error is ever present. If we lean&#13;
on frameworks built by large communities, this risk is mitigated. These&#13;
frameworks are designed with security in mind and ensure that sensitive&#13;
data is handled properly. They prevent potential data leakage scenarios&#13;
by using secure and isolated data-fetching methods<a data-startref="ix_securityframeworksversuscustomizing.06.1494.31" data-type="indexterm" id="id870"/>.</p>&#13;
</dd>&#13;
<dt>Performance optimizations</dt>&#13;
<dd>&#13;
<p>Frameworks come with numerous performance&#13;
optimizations<a data-primary="performance" data-secondary="frameworks for optimizing" data-type="indexterm" id="id871"/> out of the box. These optimizations can include automatic&#13;
code splitting, server rendering, and caching. Building a custom server&#13;
rendering solution might not include these optimizations by default, and&#13;
implementing them can be a challenging and time-consuming task.</p>&#13;
&#13;
<p>One such optimization Next.js makes, for example, is route-based code&#13;
splitting<a data-primary="route-based code splitting" data-type="indexterm" id="id872"/> for the pages router that was the default for Next.js&#13;
13 and earlier. Each page in this case is automatically code split into&#13;
its own bundle, which is then loaded only when the page is requested.&#13;
This can significantly improve performance by reducing the initial&#13;
bundle size and improving the TTFB.</p>&#13;
</dd>&#13;
<dt>Developer experience and productivity</dt>&#13;
<dd>&#13;
<p>Building a custom server&#13;
rendering implementation can be a complex and time-consuming endeavor.&#13;
By using a framework like Next.js or Remix, developers can focus on&#13;
building features and functionality for their application instead of&#13;
worrying about the underlying server rendering infrastructure. This can&#13;
lead to increased productivity and a better overall developer&#13;
experience.</p>&#13;
</dd>&#13;
<dt>Best practices and conventions</dt>&#13;
<dd>&#13;
<p>Using a framework like Next.js or&#13;
Remix can help enforce best practices and conventions in your project.&#13;
These frameworks have been designed with best practices in mind, and by&#13;
following their conventions, you can ensure that your application is&#13;
built on a solid foundation:</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<pre data-code-language="javascript" data-type="programlisting"><code class="c1">// Example of best practices with Remix</code>&#13;
<code class="c1">// File: routes/posts/$postId.tsx</code>&#13;
&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">useParams</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"react-router-dom"</code><code class="p">;</code>&#13;
<code class="kr">import</code> <code class="p">{</code> <code class="nx">useLoaderData</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"@remix-run/react"</code><code class="p">;</code>&#13;
&#13;
<code class="c1">// Best practice: data fetching as early as possible</code>&#13;
<code class="c1">// Best practice: colocating data with UI</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">loader</code><code class="p">({</code> <code class="nx">params</code> <code class="p">})</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">fetchPost</code><code class="p">(</code><code class="nx">params</code><code class="p">.</code><code class="nx">postId</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">function</code> <code class="nx">Post</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">postId</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">useParams</code><code class="p">();</code>&#13;
  <code class="kr">const</code> <code class="nx">post</code> <code class="o">=</code> <code class="nx">useLoaderData</code><code class="p">();</code>&#13;
&#13;
  <code class="k">return</code> <code class="p">(</code>&#13;
    <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">h1</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">post</code><code class="p">.</code><code class="nx">title</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/h1&gt;</code>&#13;
      <code class="o">&lt;</code><code class="nx">div</code><code class="o">&gt;</code><code class="p">{</code><code class="nx">post</code><code class="p">.</code><code class="nx">content</code><code class="p">}</code><code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
    <code class="o">&lt;</code><code class="err">/div&gt;</code>&#13;
  <code class="p">);</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">Post</code><code class="p">;</code></pre>&#13;
&#13;
<p>Considering the benefits and optimizations provided by established&#13;
frameworks like Next.js and Remix, it becomes evident that building a&#13;
custom server rendering solution for a React application is not an ideal&#13;
approach. By leveraging these frameworks, you can save development time,&#13;
ensure that best practices are followed, and benefit from the ongoing&#13;
improvements and support provided by their respective &#13;
<span class="keep-together">communities</span><a data-startref="ix_serversiderenderingSSR.06.5.53" data-type="indexterm" id="id873"/><a data-startref="ix_serversiderenderingSSRcustomimplementation.06.1477.50" data-type="indexterm" id="id874"/><a data-startref="ix_customserverrenderingimplementation.06.1477.50" data-type="indexterm" id="id875"/><a data-startref="ix_Nextjs.06.1482.46" data-type="indexterm" id="id876"/><a data-startref="ix_Remix.06.1482.46" data-type="indexterm" id="id877"/><a data-startref="ix_frameworksRemix.06.1482.46" data-type="indexterm" id="id878"/>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Chapter Review" data-type="sect1"><div class="sect1" id="id242">&#13;
<h1>Chapter Review</h1>&#13;
&#13;
<p>In conclusion, server-side rendering and hydration are powerful&#13;
techniques that can significantly improve the performance, user&#13;
experience, and SEO of web applications. React provides a rich set of&#13;
APIs for server rendering, such as <code>renderToString</code> and&#13;
<code>renderToPipeableStream</code>, each with its own strengths and trade-offs. By&#13;
understanding these APIs and selecting the right one based on factors&#13;
such as application size, server environment, and developer experience,&#13;
you can optimize your React application for both server- and client-side&#13;
performance.</p>&#13;
&#13;
<p>As we’ve seen throughout this chapter, <code>renderToString</code> is a simple and&#13;
straightforward API for server rendering that is suitable for smaller&#13;
applications. However, it may not be the most efficient option for&#13;
larger applications due to its synchronous nature and potential to block&#13;
the event loop. On the other hand, <code>renderToPipeableStream</code> is a more&#13;
advanced and flexible API that allows for better control over the&#13;
rendering process and improved integration with other Node.js streams,&#13;
making it a more suitable choice for larger applications.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Review Questions" data-type="sect1"><div class="sect1" id="id243">&#13;
<h1>Review Questions</h1>&#13;
&#13;
<p>Now that you’ve gained a solid understanding of server-side rendering&#13;
and hydration in React, it’s time to test your knowledge with some&#13;
review questions. If you can confidently answer these, it’s a good sign&#13;
that you’ve got a solid understanding of mechanism in React and can&#13;
comfortably move forward. If you cannot, we’d suggest reading through&#13;
things a little more, although this will not hurt your experience as you&#13;
continue through the book.</p>&#13;
<ol>&#13;
<li>&#13;
<p>What is the main advantage of using server-side rendering in a React&#13;
&#13;
<span class="keep-together">application?</span></p>&#13;
</li>&#13;
<li>&#13;
<p>How does hydration work in React, and why is it important?</p>&#13;
</li>&#13;
<li>&#13;
<p>What is resumability? How does it claim to be superior to hydration?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are the key benefits and weaknesses of client-only rendering?</p>&#13;
</li>&#13;
<li>&#13;
<p>What are the key differences between the <code>renderToReadableStream</code> and&#13;
<code>renderToPipeableStream</code> APIs in React?</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Up Next" data-type="sect1"><div class="sect1" id="id244">&#13;
<h1>Up Next</h1>&#13;
&#13;
<p>Once you’ve mastered server-side rendering and hydration, you’re ready&#13;
to explore even more advanced topics in React development. In the next&#13;
chapter, we’ll dive into concurrent React. As web applications&#13;
become more complex, handling asynchronous actions becomes increasingly&#13;
important for creating smooth user experiences.</p>&#13;
&#13;
<p>By learning how to leverage concurrent React, you’ll be able to create&#13;
highly performant, scalable, and user-friendly applications that can&#13;
handle complex data interactions with ease. So, stay tuned and get ready&#13;
to level up your React skills as we continue our journey into the world&#13;
of concurrent React!</p>&#13;
</div></section>&#13;
</div></section></body></html>