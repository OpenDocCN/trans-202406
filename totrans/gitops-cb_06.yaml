- en: Chapter 5\. Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 4](ch04.xhtml#ch_Kustomize), you learned about Kustomize, a simple
    yet powerful tool to manage Kubernetes resources. But another popular tool aims
    to simplify the Kubernetes resources management too: Helm.'
  prefs: []
  type: TYPE_NORMAL
- en: Helm works similarly to Kustomize, but it’s a template solution and acts more
    like a package manager, producing artifacts that are versionable, sharable, or
    deployable.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll introduce Helm, a package manager for Kubernetes that
    helps install and manage Kubernetes applications using the Go template language
    in YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a Helm project and deploy it to a Kubernetes cluster
    (see Recipes [5.1](#recipe_5_1) and [5.2](#recipe_5_2)). After the first deployment,
    the application is updated with a new container image, a new configuration value,
    or any other field, such as the replica number (see [Recipe 5.3](#recipe_5_3)).
  prefs: []
  type: TYPE_NORMAL
- en: One of the differences between Kustomize and Helm is the concept of a Chart.
    A Chart is a packaged artifact that can be shared and contains multiple elements
    like dependencies on other Charts (see Recipes [5.4](#recipe_5_4), [5.5](#recipe_5_5),
    and [5.6](#recipe_5_6)).
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration values are properties usually mapped as a Kubernetes
    `ConfigMap`. Any change (and its consequent update on the cluster) on a `ConfigMap`
    doesn’t trigger a rolling update of the application, which means that the application
    will run with the previous version until you manually restart it.
  prefs: []
  type: TYPE_NORMAL
- en: Helm provides some functions to automatically execute a rolling update when
    the `ConfigMap` of an application changes (see [Recipe 5.7](#recipe_5_7)).
  prefs: []
  type: TYPE_NORMAL
- en: 5.1 Creating a Helm Project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a simple Helm project.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the [Helm](https://helm.sh) CLI tool to create a new project.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast to Kustomize, which can be used either within the `kubectl` command
    or as a standalone CLI tool, Helm needs to be downloaded and installed in your
    local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Helm is a packager for Kubernetes that bundles related manifest files and packages
    them into a single logical deployment unit: a Chart. Thus simplified, for many
    engineers, Helm makes it easy to start using Kubernetes with real applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Helm Charts are useful for addressing the installation complexities and simple
    upgrades of applications.
  prefs: []
  type: TYPE_NORMAL
- en: For this book, we use Helm 3.7.2, which you can download from [GitHub](https://oreil.ly/AWfiO)
    and install in your PATH directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal and run the following commands to create a Helm Chart directory
    layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create three files: one that defines the Chart, another representing the
    deployment template using the Go template language and template functions from
    the Sprig library, and finally a file containing the default values for the Chart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A *Chart.yaml* file declares the Chart with information such as version or
    name. Create the file in the root directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Version of the Chart. This is updated when something in the Chart definition
    is changed.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Version of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s create a *deployment.yaml* and a *service.yaml* template file to deploy
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *deployment.yaml* file templatizes the deployment’s name, the application
    version, the replica count, the container image and tag, the pull policy, the
    security context, and the port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the name from the *Chart.yaml* file
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionally sets the version based on the presence of the `appVersion` in
    the *Chart.yaml* file
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_helm_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the `appVersion` value but quoting the property
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_helm_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Placeholder for the `replicaCount` property
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_helm_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Placeholder for the container image
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_helm_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Placeholder for the image tag if present and if not, defaults to the *Chart.yaml*
    property
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_helm_CO2-7)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the `securityContext` value as a YAML object and not as a string, indenting
    it 14 spaces
  prefs: []
  type: TYPE_NORMAL
- en: 'The *service.yaml* file templatizes the service name and the container port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The *values.yaml* file contains the default values for the Chart. These values
    can be overridden at runtime, but they provide good initial values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file in the root directory with some default values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the `image` section
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the `repository` property
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_helm_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Empty `securityContext`
  prefs: []
  type: TYPE_NORMAL
- en: Built-in properties are capitalized; for this reason, properties defined in
    the *Chart.yaml* file start with an uppercase letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `toYaml` function is used for the `securityContext` value, the expected
    value for the `securityContext` property in *values.yaml* should be a YAML object.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The relationship between all elements is shown in [Figure 5-1](#fig-511).
  prefs: []
  type: TYPE_NORMAL
- en: '![Relationship between Helm elements](assets/gocb_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Relationship between Helm elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At this point the Helm directory layout is created and should be similar to
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The *Chart.yaml* file is the Chart descriptor and contains metadata related
    to the Chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The *templates* directory contains all template files used for installing a
    Chart.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_helm_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: These files are Helm template files used to deploy the application.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_helm_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The *values.yaml* file contains the default values for a Chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the Helm Chart locally to YAML, run the following command in a terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name is injected from *Chart.yaml*
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Port is set in *values.yaml*
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_helm_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Version is taken from Chart version
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_helm_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Concatenates content from two attributes
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_helm_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Empty security context
  prefs: []
  type: TYPE_NORMAL
- en: 'You can override any default value by using the `--set` parameter in Helm.
    Let’s override the `replicaCount` value from one (defined in *values.yaml*) to
    three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `replicas` value is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Helm is a package manager for Kubernetes, and as such, it helps you with the
    task of versioning, sharing, and upgrading Kubernetes applications.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to install the Helm Chart to a Kubernetes cluster and upgrade
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Minikube up and running, execute the following command in a terminal window,
    and run the `install` command to deploy the application to the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Chart is installed in the running Kubernetes instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Get the list of current deployed pods, Deployments, and Services to validate
    that the Helm Chart is deployed in the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, it’s possible to get history information about the deployed Helm Chart
    using the `history` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To uninstall a Chart from the cluster, run `uninstall` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Helm is a package manager that lets you share the Chart (package) to other Charts
    as a dependency. For example, you can have a Chart defining the deployment of
    the application and another Chart as a dependency setting a database deployment.
    In this way, the installation process installs the application and the database
    Chart automatically.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll learn about the packaging process and adding dependencies in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use the `helm create <name>` command to let the Helm tool skaffold the
    project.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Helm](https://helm.sh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Go template package](https://oreil.ly/vYI40)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Sprig Function Documentation](https://oreil.ly/ngC2v)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.2 Reusing Statements Between Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to reuse template statements across several files.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use *_helpers.tpl* to define reusable statements.
  prefs: []
  type: TYPE_NORMAL
- en: We deployed a simple application to Kubernetes using Helm in the previous recipe.
    This simple application was composed of a Kubernetes Deployment file and a Kubernetes
    Service file where the `selector` field was defined with the same value.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you need to update this field—for example, adding a new label as a selector—you
    would need to update in three places, as shown in the previous snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Helm lets you create a *_helpers.tpl* file in the *templates* directory defining
    statements that can be called in templates to avoid this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s refactor the previous example to use the *_helpers.tpl* file to define
    the `selectorLabels`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the *_helpers.tpl* file in the *templates* directory with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the statement name
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the logic of the statement
  prefs: []
  type: TYPE_NORMAL
- en: 'Then replace the template placeholders shown in previous snippets with a call
    to the `podman.selectorLabels` helper statement using the `include` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls `pacman.selectorLabels` with indentation
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Calls `pacman.selectorLabels` with indentation
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the Helm Chart locally to YAML, run the following command in a terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Selector is updated with value set in *_helpers.tpl*
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Selector is updated with value set in *_helpers.tpl*
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_helm_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Selector is updated with value set in *_helpers.tpl*
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you want to update the selector labels, the only change you need to do is
    an update to the *_helpers.tpl* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a new attribute
  prefs: []
  type: TYPE_NORMAL
- en: 'To render the Helm Chart locally to YAML, run the following command in a terminal
    window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Label is added
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Label is added
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_helm_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Label is added
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although it’s common to use *__helpers.tpl* as the filename to define functions,
    you can name any file starting with `__`, and Helm will read the functions too.
  prefs: []
  type: TYPE_NORMAL
- en: 5.3 Updating a Container Image in Helm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to update the container image from a deployment file using Helm and
    upgrade the running instance.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `upgrade` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Minikube up and running, deploy version 1.0.0 of the `pacman` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: With the first revision deployed, let’s update the container image to a new
    version and deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check revision number by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the version, open *values.yaml* and update the `image.tag` field
    to the newer container image tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Updates to container tag to 1.1.0
  prefs: []
  type: TYPE_NORMAL
- en: 'Then update the `appVersion` field of the *Chart.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Version is updated accordingly
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use `appVersion` as the tag instead of having two separate fields. Using
    two fields or one might depend on your use case, versioning strategy, and lifecycle
    of your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'After these changes, upgrade the deployment by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output reflects that a new revision has been deployed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: New revision
  prefs: []
  type: TYPE_NORMAL
- en: 'The `history` command shows all changes between all versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`appVersion` is the application version, so every time you change the application
    version, you should update that field too. On the other side, `version` is the
    Chart version and should be updated when the definition of the Chart (i.e., templates)
    changes, so both fields are independent.'
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not only you can install or upgrade a version with Helm, but you can also roll
    back to a previous revision.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the terminal window, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `history` command reflects this change too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Finally, Helm offers a way to override values, not only using the `--set` argument
    as shown in [Recipe 5.1](#recipe_5_1), but by providing a YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new YAML file named *newvalues.yaml* in the root directory with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the `template` command, setting the new file as an override of *values.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting YAML document is using the values set in *values.yaml* but overriding
    the `images.tag` set in *newvalues.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 5.4 Packaging and Distributing a Helm Chart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to package and distribute a Helm Chart so it can be reused by others.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `package` command.
  prefs: []
  type: TYPE_NORMAL
- en: Helm is a package manager for Kubernetes. As we’ve seen in this chapter, the
    basic unit in Helm is a Chart containing the Kubernetes files required to deploy
    the application, the default values for the templates, etc.
  prefs: []
  type: TYPE_NORMAL
- en: But we’ve not yet seen how to package Helm Charts and distribute them to be
    available to other Charts as dependencies or deployed by other users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s package the `pacman` Chart into a *.tgz* file. In the *pacman* directory,
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'And you’ll get a message informing you where the archive is stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: A Chart then needs to be published into a Chart repository. A Chart repository
    is an HTTP server with an *index.yaml* file containing metadata information regarding
    Charts and *.tgz* Charts.
  prefs: []
  type: TYPE_NORMAL
- en: To publish them, update the *index.yaml* file with the new metadata information,
    and upload the artifact.
  prefs: []
  type: TYPE_NORMAL
- en: 'The directory layout of a repository might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The *index.yaml* file with information about each Chart present in the repository
    looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can run `helm repo index` in the root directory, where packaged Charts are
    stored, to generate the index file automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to packaging a Helm Chart, Helm can generate a signature file for
    the packaged Chart to verify its correctness later.
  prefs: []
  type: TYPE_NORMAL
- en: In this way, you can be sure it has not been modified, and it’s the correct
    Chart.
  prefs: []
  type: TYPE_NORMAL
- en: To sign/verify the package, you need a pair of GPG keys in the machine; we’re
    assuming you already have one pair created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need to call the `package` command but set the `-sign` argument with
    the required parameters to generate a signature file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, two files are created—the packaged Helm Chart (*.tgz*) and the signature
    file (*.tgz.prov*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Chart package
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Signature file
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember to upload both files in the Chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that a Chart is valid and has not been manipulated, use the `verify`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: It’s valid
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[The Chart Repository Guide](https://oreil.ly/pQ2Ab)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Helm Provenance and Integrity](https://oreil.ly/1Hql0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 5.5 Deploying a Chart from a Repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy a Helm Chart stored in Chart repository.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `repo add` command to add the remote repository and the `install` command
    to deploy it.
  prefs: []
  type: TYPE_NORMAL
- en: Public Helm Chart repositories like [Bitnami](https://oreil.ly/QJzWZ) are available
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Charts from a repository (either public or private), you need to
    register it using its URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: URL of Helm Chart repository where *index.yaml* is placed
  prefs: []
  type: TYPE_NORMAL
- en: 'List the registered repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Bitnami repo is registered
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Run `helm repo update` to get the latest list of Charts for each repo.
  prefs: []
  type: TYPE_NORMAL
- en: After registering a repository, you might want to find which Charts are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to deploy a PostgreSQL instance in the cluster, use the `search`
    command to search all repositories for a Chart that matches the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The outputs are the list of Charts that matches the name, the version of the
    Chart and PostgreSQL, and a description. Notice the name of the Chart is composed
    of the repository name and the Chart name, i.e., `bitnami/postgresql`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'To deploy the PostgreSQL Chart, run the `install` command but change the location
    of the Helm Chart from a local directory to the full name of the Chart (`<repo>/<chart>`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the name of the deployment
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Overrides default values to the ones set in the command line
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_helm_CO18-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the PostgreSQL Chart stored in the Bitnami repo
  prefs: []
  type: TYPE_NORMAL
- en: 'And a detailed output is shown in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the installation by listing pods, Services, StatefulSets, or Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a third party creates a Chart, there is no direct access to default values
    or the list of parameters to override. Helm provides a `show` command to check
    these values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'And shows all the possible values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 5.6 Deploying a Chart with a Dependency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy a Helm Chart that is a dependency of another Chart.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `dependencies` section in the *Chart.yaml* file to register other Charts.
    So far, we’ve seen how to deploy simple services to the cluster, but usually a
    service might have other dependencies like a database, mail server, distributed
    cache, etc.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we saw how to deploy a PostgreSQL server in a Kubernetes
    cluster. In this section, we’ll see how to deploy a service composed of a Java
    service returning a list of songs stored in a PostgreSQL database. The application
    is summarized in [Figure 5-2](#fig-561).
  prefs: []
  type: TYPE_NORMAL
- en: '![Music application overview](assets/gocb_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Music application overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s start creating the Chart layout shown in [Recipe 5.1](#recipe_5_1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Then create two template files to deploy the music service.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *templates/deployment.yaml* file contains the Kubernetes Deployment definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'The *templates/service.yaml* file contains the Kubernetes Service definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'After the creation of the templates, it’s time for the Chart metadata *Chart.yaml*
    file. In this case, we need to define the dependencies of this Chart too. Since
    the music service uses a PostgreSQL database, we can add the Chart used in [Recipe
    5.5](#recipe_5_5) as a dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies section
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Chart to add as dependency
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_helm_CO19-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Chart version
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_helm_CO19-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The final file is *Values.yaml* with default configuration values. In this
    case, a new section is added to configure music deployment with PostgreSQL instance
    parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL section
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Chart in place, the next thing to do is download the dependency Chart
    and store it in the *charts* directory. This process is automatically done by
    running the `dependency update` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The command output shows that one Chart has been downloaded and saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The directory layout looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL Chart is placed in the correct directory
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we deploy the Chart, setting configuration PostgreSQL deployment values
    from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation process shows information about the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspect the installation by listing pods, Services, StatefulSets, or Secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We can validate the access to the music service by using port forwarding to
    the Kubernetes Service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new terminal window and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The terminal is blocked and it’s normal until you stop the `kubectl port-forward`
    process. Thanks to port forwarding, we can access the music service using the
    `localhost` address and port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another terminal, `curl` the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'The request is sent to the music service deployed in Kubernetes and returns
    a list of songs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 5.7 Triggering a Rolling Update Automatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to trigger a rolling update of deployment when a `ConfigMap` object
    is changed.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `sha256sum` template function to generate a change on the deployment
    file.
  prefs: []
  type: TYPE_NORMAL
- en: In [Recipe 4.5](ch04.xhtml#recipe_4_5), we saw that Kustomize has a `ConfigMapGenerator`
    that automatically appends a hash to the `ConfigMap` metadata name and modifies
    the deployment file with the new hash when used. Any change on the `ConfigMap`
    triggers a rolling update of the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Helm doesn’t provide a direct way like Kustomize does to update a deployment
    file when the `ConfigMap` changes, but there is a template function to calculate
    a SHA-256 hash of any file and embed the result in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we’ve got a Node.js application that returns a greeting message. An
    environment variable configures this greeting message, and in the Kubernetes Deployment,
    this variable is injected from a Kubernetes `ConfigMap`.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-3](#fig-571) shows an overview of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Greetings application overview](assets/gocb_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Greetings application overview
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s create the Helm Chart for the Greetings application; note that we’re not
    covering the entire process of creating a Chart, but just the essential parts.
    You can refer to [Recipe 5.1](#recipe_5_1) to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a deployment template that injects a `ConfigMap` as an environment variable.
    The following listing shows the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfigMap` name'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO22-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Property key of the `ConfigMap`
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial `ConfigMap` file is shown in the following listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO23-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets `ConfigMap` name
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_helm_CO23-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Key/value
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Kubernetes Service template to access the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the *values.yaml* file with the template `configmap` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO24-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Refers to `ConfigMap` name
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, install the Chart using the `install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'When the Chart is deployed, use the `kubectl port-forward` command in one terminal
    to get access to the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'And `curl` the service in another terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO25-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Configured greeting is used
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s update the `ConfigMap` file to a new greeting message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO26-1)'
  prefs: []
  type: TYPE_NORMAL
- en: New greeting message
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `appVersion` field from the *Chart.yaml* file to `1.0.1` and upgrade
    the Chart by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the `kubectl port-forward` process and `curl` the service again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO27-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Greeting message isn’t updated
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ConfigMap` object is updated during the upgrade, but since there are no
    changes in the `Deployment` object, there is no restart of the pod; hence the
    environment variable is not set to the new value. Listing the pods shows no execution
    of the rolling update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO28-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Age value shows no rolling update
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-4](#fig-572) summarizes the change.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Greetings application with new configuration value](assets/gocb_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Greetings application with new configuration value
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s use the `sha256sum` function to calculate an SHA-256 value of the *configmap.yaml*
    file content and set it as a pod annotation, which effectively triggers a rolling
    update as the pod definition has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO29-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Includes the *configmap.yaml* file, calculates the SHA-256 value, and sets it
    as an annotation
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `ConfigMap` again with a new value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO30-1)'
  prefs: []
  type: TYPE_NORMAL
- en: New greeting message
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `appVersion` field from *Chart.yaml* to `1.0.1` and upgrade the
    Chart by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the `kubectl port-forward` process and `curl` the service again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO31-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Greeting message is the new one
  prefs: []
  type: TYPE_NORMAL
- en: 'List the pods deployed in the cluster again, and you’ll notice that a rolling
    update is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO32-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A rolling update is happening
  prefs: []
  type: TYPE_NORMAL
- en: 'Describe the pod to validate that the annotation with the SHA-256 value is
    present:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'The output shows all pod parameters. The important one is the `annotations`
    placed at the top of the output showing the `checksum/config` annotation containing
    the calculated SHA-256 value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_helm_CO33-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Calculated value
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 5-5](#fig-573) summarizes the elements that changed when the application
    was updated.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Final overview of the Greetings application](assets/gocb_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. Final overview of the Greetings application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 5.8 Final Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw Kustomize; in this chapter, we’ve seen another
    tool to help deploy Kubernetes applications.
  prefs: []
  type: TYPE_NORMAL
- en: When you need to choose between Kustomize or Helm, you might have questions
    on which one to use.
  prefs: []
  type: TYPE_NORMAL
- en: In our experience, the best way to proceed is with Kustomize for simple projects,
    where only simple changes might be required between new deployments.
  prefs: []
  type: TYPE_NORMAL
- en: If the project is complex with external dependencies, and several deployment
    parameters, then Helm is a better option.
  prefs: []
  type: TYPE_NORMAL
