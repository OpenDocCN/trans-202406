- en: Chapter 2\. Introducing the Shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you can run commands at a prompt. But what *is* that prompt? Where does
    it come from, how are your commands run, and why does it matter?
  prefs: []
  type: TYPE_NORMAL
- en: That little prompt is produced by a program called a *shell*. It’s a user interface
    that sits between you and the Linux operating system. Linux supplies several shells,
    and the most common (and the standard for this book) is called `bash`. (See [Appendix B](app02.xhtml#appendix_shells)
    for notes about other shells.)
  prefs: []
  type: TYPE_NORMAL
- en: '`bash` and other shells do much more than simply run commands. For example,
    when a command includes a wildcard (`*`) to refer to multiple files at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'the wildcard is handled entirely by the shell, not by the program `ls`. The
    shell evaluates the expression `*.py` and invisibly replaces it with a list of
    matching filenames *before* `ls` runs. In other words, `ls` *never sees the wildcard*.
    From the perspective of `ls`, you typed the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The shell also handles the pipes you saw in [Chapter 1](ch01.xhtml#ch_combining_commands).
    It redirects stdin and stdout transparently so the programs involved have no idea
    they are communicating with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Every time a command runs, some steps are the responsibility of the invoked
    program, such as `ls`, and some are the responsibility of the shell. Expert users
    understand which is which. That’s one reason they can create long, complex commands
    off the top of their head and run them successfully. They *already know what the
    command will do* before they press Enter, in part because they understand the
    separation between the shell and the programs it invokes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll launch your understanding of the Linux shell. I’ll take
    the same minimalist approach I used for commands and pipes in [Chapter 1](ch01.xhtml#ch_combining_commands).
    Rather than cover dozens of shell features, I’ll hand you just enough information
    to carry you to the next step of your learning journey:'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for filenames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables to store values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection of input and output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting and escaping to disable certain shell features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search path for locating programs to run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving changes to your shell environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell Vocabulary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word *shell* has two meanings. Sometimes it means the *concept* of the Linux
    shell in general, as in “The shell is a powerful tool” or “`bash` is a shell.”
    Other times it means a specific *instance* of a shell running on a given Linux
    computer, awaiting your next command.
  prefs: []
  type: TYPE_NORMAL
- en: In this book, the meaning of *shell* should be clear from the context most of
    the time. When necessary, I’ll refer to the second meaning as a *shell instance*,
    a *running shell*, or your *current shell*.
  prefs: []
  type: TYPE_NORMAL
- en: Some shell instances, but not all, present a prompt so you can interact with
    them. I’ll use the term *interactive shell* to refer to these instances. Other
    shell instances are noninteractive—they run a sequence of commands and exit.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern Matching for Filenames
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.xhtml#ch_combining_commands), you worked with several commands
    that accept filenames as arguments, such as `cut`, `sort`, and `grep`. These commands
    (and many others) accept multiple filenames as arguments. For example, you can
    search for the word *Linux* in one hundred files at once, named *chapter1* through
    *chapter100*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Listing multiple files by name is a tedious time-waster, so the shell provides
    special characters as a shorthand to refer to files or directories with similar
    names. Many folks call these characters wildcards, but the more general concept
    is called *pattern matching* or *globbing*. Pattern matching is one of the two
    most common techniques for speed that Linux users learn. (The other is pressing
    the up arrow key to recall the shell’s previous command, which I describe in [Chapter 3](ch03.xhtml#ch_history).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Linux users are familiar with the star or asterisk character (`*`), which
    matches any sequence of zero or more characters (except for a leading dot)^([1](ch02.xhtml#idm46586652391888))
    in file or directory paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, the shell (not `grep`!) expands the pattern `chapter*` into
    a list of 100 matching filenames. Then the shell runs `grep`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many users have also seen the question mark (`?`) special character, which
    matches any single character (except a leading dot). For example, you could search
    for the word *Linux* in chapters 1 through 9 only, by providing a single question
    mark to make the shell match single digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'or in chapters 10 through 99, with two question marks to match two digits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Fewer users are familiar with square brackets (`[]`), which request the shell
    to match a single character from a set. For example, you could search only the
    first five chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Equivalently, you could supply a range of characters with a dash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also search even-numbered chapters, combining the asterisk and the
    square brackets to make the shell match filenames ending in an even digit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Any characters, not just digits, may appear within the square brackets for
    matching. For example, filenames that begin with a capital letter, contain an
    underscore, and end with an `@` symbol would be matched by the shell in this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Terminology: Evaluating Expressions and Expanding Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings that you enter on the command line, such as `chapter*` or `Efficient
    Linux`, are called *expressions*. An entire command like `ls -l chapter*` is an
    expression too.
  prefs: []
  type: TYPE_NORMAL
- en: When the shell interprets and handles special characters in an expression, such
    as asterisks and pipe symbols, we say that the shell *evaluates* the expression.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching is one kind of evaluation. When the shell evaluates an expression
    that contains pattern-matching symbols, such as `chapter*`, and replaces it with
    filenames that match the pattern, we say that the shell *expands* the pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns are valid almost anywhere that you’d supply file or directory paths
    on the command line. For example, you can list all files in the directory */etc*
    with names ending in *.conf* using a pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful using a pattern with a command that accepts just one file or directory
    argument, such as `cd`. You might not get the behavior you expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If a pattern doesn’t match any files, the shell leaves it unchanged to be passed
    literally as a command argument. In the following command, the pattern `*.doc`
    matches nothing in the current directory, so `ls` looks for a filename literally
    named `*.doc` and fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When working with file patterns, two points are vitally important to remember.
    The first, as I’ve already emphasized, is that the shell, not the invoked program,
    performs the pattern matching. I know I keep repeating this, but I’m frequently
    surprised by how many Linux users don’t know it and develop superstitions about
    why certain commands succeed or fail.
  prefs: []
  type: TYPE_NORMAL
- en: The second important point is that shell pattern matching applies only to file
    and directory paths. It doesn’t work for usernames, hostnames, and other types
    of arguments that certain commands accept. You also cannot type (say) `s?rt` at
    the beginning of the command line and expect the shell to run the `sort` program.
    (Some Linux commands such as `grep`, `sed`, and `awk` perform their own brands
    of pattern matching, which we’ll explore in [Chapter 5](ch05.xhtml#ch_toolbox).)
  prefs: []
  type: TYPE_NORMAL
- en: Filename Pattern Matching and Your Own Programs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All programs that accept filenames as arguments automatically “work” with pattern
    matching, because the shell evaluates the patterns before the program runs. This
    is true even for programs and scripts you write yourself. For example, if you
    wrote a program `english2swedish` that translated files from English to Swedish
    and accepted multiple filenames on the command line, you could instantly run it
    with pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Evaluating Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A running shell can define variables and store values in them. A shell variable
    is a lot like a variable in algebra—it has a name and a value. An example is the
    shell variable `HOME`. Its value is the path to your Linux home directory, such
    as */home/smith*. Another example is `USER`, whose value is your Linux username,
    which I’ll assume is `smith` throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'To print the values of `HOME` and `USER` on stdout, run the command `printenv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: When the shell evaluates a variable, it replaces the variable name with its
    value. Simply place a dollar sign in front of the name to evaluate the variable.
    For example, `$HOME` evaluates to the string `/home/smith`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to watch the shell evaluate a command line is to run the `echo`
    command, which simply prints its arguments (after the shell is finished evaluating
    them):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Where Variables Come From
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables like `USER` and `HOME` are predefined by the shell. Their values are
    set automatically when you log in. (More on this process later.) Traditionally,
    such predefined variables have uppercase names.
  prefs: []
  type: TYPE_NORMAL
- en: 'You also may define or modify a variable anytime by assigning it a value using
    this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, if you work frequently in the directory */home/smith/Projects*,
    you could assign its name to a variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'and use it as a handy shortcut with `cd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You may supply `$work` to any command that expects a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When defining a variable, no spaces are permitted around the equals sign. If
    you forget, the shell will assume (wrongly) that the first word on the command
    line is a program to run, and the equals sign and value are its arguments, and
    you’ll see an error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: A user-defined variable like `work` is just as legitimate and usable as a system-defined
    variable like `HOME`. The only practical difference is that some Linux programs
    change their behavior internally based on the values of `HOME`, `USER`, and other
    system-defined variables. For example, a Linux program with a graphical interface
    might retrieve your username from the shell and display it. Such programs don’t
    pay attention to an invented variable like `work` because they weren’t programmed
    to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Superstition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you print the value of a variable with `echo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'you might think that the `echo` command examines the `HOME` variable and prints
    its value. That is *not* the case. `echo` knows nothing about variables. It just
    prints whatever arguments you hand it. What’s really happening is that the shell
    evaluates `$HOME` before running `echo`. From `echo`’s perspective, you typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This behavior is extremely important to understand, especially as we delve into
    more complicated commands. The shell evaluates the variables in a command—as well
    as patterns and other shell constructs—before executing the command.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns Versus Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s test your understanding of pattern and variable evaluation. Suppose you’re
    in a directory with two subdirectories, *mammals* and *reptiles*, and oddly, the
    *mammals* subdirectory contains files named *lizard.txt* and *snake.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the real world, lizards and snakes are not mammals, so the two files should
    be moved to the *reptiles* subdirectory. Here are two proposed ways to do it.
    One works, and one does not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Method 1 works because patterns match an entire file path. See how the directory
    name *mammals* is part of both matches for `mammals/*.txt`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'So, method 1 operates as if you’d typed the following correct command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Method 2 uses variables, which evaluate to their literal value only. They have
    no special handling for file paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'So, method 2 operates as if you’d typed the following problematic command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This command looks for the file *snake.txt* in the current directory, not in
    the *mammals* subdirectory, and fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a variable work in this situation, use a `for` loop that prepends the
    directory name *mammals* to each filename:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Shortening Commands with Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable is a name that stands in for a value. The shell also has names that
    stand in for commands. They’re called *aliases*. Define an alias by inventing
    a name and following it with a equals sign and a command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Run an alias by typing its name as a command. When aliases are shorter than
    the commands they invoke, you save typing time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Always define an alias on its own line, not as part of a combined command. (See
    `man bash` for the technical details.)
  prefs: []
  type: TYPE_NORMAL
- en: You can define an alias that has the same name as an existing command, effectively
    replacing that command in your shell. This practice is called *shadowing* the
    command. Suppose you like the `less` command for reading files, but you want it
    to clear the screen before displaying each page. This feature is enabled with
    the `-c` option, so define an alias called “less” that runs `less -c`:^([2](ch02.xhtml#idm46586653823824))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Aliases take precedence over commands of the same name, so you have now shadowed
    the `less` command in the current shell. I’ll explain what *precedence* means
    in [“Search Path and Aliases”](#search_path_aliases).
  prefs: []
  type: TYPE_NORMAL
- en: 'To list a shell’s aliases and their values, run `alias` with no arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the value of a single alias, run `alias` followed by its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete an alias from a shell, run `unalias`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Redirecting Input and Output
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The shell controls the input and output of the commands it runs. You’ve already
    seen one example: pipes, which direct the stdout of one command to the stdin of
    another. The pipe syntax, `|`, is a feature of the shell.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another shell feature is redirecting stdout to a file. For example, if you
    use `grep` to print matching lines from the *animals.txt* file from [Example 1-1](ch01.xhtml#example_animals.txt),
    the command writes to stdout by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can send that output to a file instead, using a shell feature called *output
    redirection*. Simply add the symbol `>` followed by the name of a file to receive
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You have just redirected stdout to the file *outfile* instead of the display.
    If the file *outfile* doesn’t exist, it’s created. If it does exist, redirection
    overwrites its contents. If you’d rather append to the output file rather than
    overwrite it, use the symbol `>>` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Output redirection has a partner, *input redirection*, that redirects stdin
    to come from a file instead of the keyboard. Use the symbol `<` followed by a
    filename to redirect stdin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many Linux commands that accept filenames as arguments, and read from those
    files, also read from stdin when run with no arguments. An example is `wc` for
    counting lines, words, and characters in a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s *very important* to understand how these two `wc` commands differ in behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, `wc` receives the filename *animals.txt* as an argument,
    so `wc` is aware that the file exists. `wc` deliberately opens the file on disk
    and reads its contents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second command, `wc` is invoked with no arguments, so it reads from stdin,
    which is usually the keyboard. The shell, however, sneakily redirects stdin to
    come from *animals.txt* instead. `wc` has no idea that the file *animals.txt*
    exists.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The shell can redirect input and output in the same command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'and can even use pipes at the same time. Here, `grep` reads from redirected
    stdin and pipes the results to `wc`, which writes to redirected stdout, producing
    the file *count*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: You’ll dive deeper into such combined commands in [Chapter 8](ch08.xhtml#ch_one_liner)
    and see many other examples of redirection throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Evaluation with Quotes and Escapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally the shell uses whitespace as a separator between words. The following
    command has four words—a program name followed by three arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, however, you need the shell to treat whitespace as significant,
    not as a separator. A common example is whitespace in a filename such as *Efficient
    Linux Tips.txt*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'If you refer to such a filename on the command line, your command may fail
    because the shell treats the space characters as separators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'To force the shell to treat spaces as part of a filename, you have three options—single
    quotes, double quotes, and backslashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Single quotes tell the shell to treat every character in a string literally,
    even if the character ordinarily has special meaning to the shell, such as spaces
    and dollar signs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Double quotes tell the shell to treat all characters literally except for certain
    dollar signs and a few others you’ll learn later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A backslash, also called the *escape character*, tells the shell to treat the
    next character literally. The following command includes an escaped dollar sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Backslashes act as escape characters even within double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'but not within single quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the backslash to escape a double quote character within double quotes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'A backslash at the end of a line disables the special nature of the invisible
    newline character, allowing shell commands to span multiple lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Final backslashes are great for making pipelines more readable, like this one
    from [“Command #6: uniq”](ch01.xhtml#section_uniq):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When used this way, the backslash is sometimes called a *line continuation character*.
  prefs: []
  type: TYPE_NORMAL
- en: 'A leading backslash before an alias escapes the alias, causing the shell to
    look for a command of the same name, ignoring any shadowing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Locating Programs to Be Run
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the shell first encounters a simple command, such as `ls *.py`, it’s just
    a string of meaningless characters. Quick as a flash, the shell splits the string
    into two words, “ls” and “*.py”. In this case, the first word is the name of a
    program on disk, and the shell must locate the program to run it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program `ls`, it turns out, is an executable file in the directory */bin*.
    You can verify its location with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'or you can change directories with `cd /bin` and run this lovely, cryptic-looking
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: which uses the command `ls` to list the executable file *ls*.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does the shell locate `ls` in the */bin* directory? Behind the scenes,
    the shell consults a prearranged list of directories that it holds in memory,
    called a *search path*. The list is stored as the value of the shell variable
    `PATH`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Directories in a search path are separated by colons (`:`). For a clearer view,
    convert the colons to newline characters by piping the output to the `tr` command,
    which translates one character into another (more details in [Chapter 5](ch05.xhtml#ch_toolbox)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The shell consults directories in your search path from first to last when locating
    a program like `ls`. “Does */home/smith/bin/ls* exist? No. Does */usr/local/bin/ls*
    exist? Nope. How about */usr/bin/ls*? No again! Maybe */bin/ls*? Yes, there it
    is! I’ll run */bin/ls*.” This search happens too quickly to notice.^([3](ch02.xhtml#idm46586642464768))
  prefs: []
  type: TYPE_NORMAL
- en: 'To locate a program in your search path, use the `which` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: or the more powerful (and verbose) `type` command, a shell builtin that also
    locates aliases, functions, and shell builtins:^([4](ch02.xhtml#idm46586642454096))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Your search path may contain the same-named command in different directories,
    such as */usr/bin/less* and */bin/less*. The shell runs whichever command appears
    in the earlier directory in the path. By leveraging this behavior, you can override
    a Linux command by placing a same-named command in an earlier directory in your
    search path, such as your personal *$HOME/bin* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Search Path and Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the shell searches for a command by name, it checks if that name is an
    alias before checking the search path. That’s why an alias can shadow (take precedence
    over) a command of the same name.
  prefs: []
  type: TYPE_NORMAL
- en: The search path is a great example of taking something mysterious about Linux
    and showing it has an ordinary explanation. The shell doesn’t pull commands out
    of thin air or locate them by magic. It methodically examines directories in a
    list until it finds the requested executable file.
  prefs: []
  type: TYPE_NORMAL
- en: Environments and Initialization Files, the Short Version
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A running shell holds a bunch of important information in variables: the search
    path, the current directory, your preferred text editor, your customized shell
    prompt, and more. The variables of a running shell are collectively called the
    shell’s *environment*. When the shell exits, its environment is destroyed.'
  prefs: []
  type: TYPE_NORMAL
- en: It would be extremely tedious to define every shell’s environment by hand. The
    solution is to define the environment once, in shell scripts called *startup files*
    and *initialization files*, and have every shell execute these scripts on startup.
    The effect is that certain information appears to be “global” or “known” to all
    of your running shells.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll dive into the gory details in [“Configuring Your Environment”](ch06.xhtml#section_bash_configs).
    For now, I’ll teach you about one initialization file so you can get through the
    next few chapters. It’s located in your home directory and named *.bashrc* (pronounced
    “dot bash R C”). Because its name begins with a dot, `ls` doesn’t list it by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If *$HOME/.bashrc* doesn’t exist, create it with a text editor. Commands you
    place in this file will execute automatically when a shell starts up,^([5](ch02.xhtml#idm46586642420864))
    so it’s a great place to define variables for the shell’s environment, and other
    things important to the shell, such as aliases. Here is a sample *.bashrc* file.
    Lines beginning with `#` are comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Any changes you make to *$HOME/.bashrc* do not affect any running shells, only
    future shells. You can force a running shell to reread and execute *$HOME/.bashrc*
    with either of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This process is known as *sourcing* the initialization file. If someone tells
    you to “source your dot-bash-R-C file,” they mean run one of the preceding commands.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In real life, do not put all of your shell configuration in *$HOME/.bashrc*.
    Once you’ve read the details in [“Configuring Your Environment”](ch06.xhtml#section_bash_configs),
    examine your *$HOME/.bashrc* and move commands to their proper files as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’ve covered only a tiny number of `bash` features and their most basic uses.
    You’ll see many more in the chapters that follow, particularly in [Chapter 6](ch06.xhtml#ch_parent_child).
    For right now, your most important job is to understand the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: The shell exists and has important responsibilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shell evaluates the command line before running any commands.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands can redirect stdin, stdout, and stderr.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting and escaping prevent special shell characters from being evaluated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shell locates programs using a search path of directories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change a shell’s default behavior by adding commands to the file *$HOME/.bashrc*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The better you understand the division between the shell and the programs it
    invokes, the more that the command line will make sense, and the better you can
    predict what will happen before you press Enter to run a command.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.xhtml#idm46586652391888-marker)) That’s why the command `ls *` doesn’t
    list filenames beginning with a dot, a.k.a. dot files.
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#idm46586653823824-marker)) `bash` prevents infinite recursion
    by not expanding the second `less` as an alias.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.xhtml#idm46586642464768-marker)) Some shells memorize (cache) the
    paths to programs as they’re located, cutting down on future searches.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.xhtml#idm46586642454096-marker)) Notice that the command `type which`
    produces output, but the command `which type` does not.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.xhtml#idm46586642420864-marker)) This statement is oversimplified;
    more details are in [Table 6-1](ch06.xhtml#table_config).
  prefs: []
  type: TYPE_NORMAL
