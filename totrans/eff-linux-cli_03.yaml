- en: Chapter 2\. Introducing the Shell
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, you can run commands at a prompt. But what *is* that prompt? Where does
    it come from, how are your commands run, and why does it matter?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: That little prompt is produced by a program called a *shell*. It’s a user interface
    that sits between you and the Linux operating system. Linux supplies several shells,
    and the most common (and the standard for this book) is called `bash`. (See [Appendix B](app02.xhtml#appendix_shells)
    for notes about other shells.)
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '`bash` and other shells do much more than simply run commands. For example,
    when a command includes a wildcard (`*`) to refer to multiple files at once:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-4
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'the wildcard is handled entirely by the shell, not by the program `ls`. The
    shell evaluates the expression `*.py` and invisibly replaces it with a list of
    matching filenames *before* `ls` runs. In other words, `ls` *never sees the wildcard*.
    From the perspective of `ls`, you typed the following command:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The shell also handles the pipes you saw in [Chapter 1](ch01.xhtml#ch_combining_commands).
    It redirects stdin and stdout transparently so the programs involved have no idea
    they are communicating with each other.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Every time a command runs, some steps are the responsibility of the invoked
    program, such as `ls`, and some are the responsibility of the shell. Expert users
    understand which is which. That’s one reason they can create long, complex commands
    off the top of their head and run them successfully. They *already know what the
    command will do* before they press Enter, in part because they understand the
    separation between the shell and the programs it invokes.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll launch your understanding of the Linux shell. I’ll take
    the same minimalist approach I used for commands and pipes in [Chapter 1](ch01.xhtml#ch_combining_commands).
    Rather than cover dozens of shell features, I’ll hand you just enough information
    to carry you to the next step of your learning journey:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching for filenames
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables to store values
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirection of input and output
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting and escaping to disable certain shell features
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The search path for locating programs to run
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving changes to your shell environment
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell Vocabulary
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The word *shell* has two meanings. Sometimes it means the *concept* of the Linux
    shell in general, as in “The shell is a powerful tool” or “`bash` is a shell.”
    Other times it means a specific *instance* of a shell running on a given Linux
    computer, awaiting your next command.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: In this book, the meaning of *shell* should be clear from the context most of
    the time. When necessary, I’ll refer to the second meaning as a *shell instance*,
    a *running shell*, or your *current shell*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Some shell instances, but not all, present a prompt so you can interact with
    them. I’ll use the term *interactive shell* to refer to these instances. Other
    shell instances are noninteractive—they run a sequence of commands and exit.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Pattern Matching for Filenames
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 1](ch01.xhtml#ch_combining_commands), you worked with several commands
    that accept filenames as arguments, such as `cut`, `sort`, and `grep`. These commands
    (and many others) accept multiple filenames as arguments. For example, you can
    search for the word *Linux* in one hundred files at once, named *chapter1* through
    *chapter100*:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Listing multiple files by name is a tedious time-waster, so the shell provides
    special characters as a shorthand to refer to files or directories with similar
    names. Many folks call these characters wildcards, but the more general concept
    is called *pattern matching* or *globbing*. Pattern matching is one of the two
    most common techniques for speed that Linux users learn. (The other is pressing
    the up arrow key to recall the shell’s previous command, which I describe in [Chapter 3](ch03.xhtml#ch_history).)
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'Most Linux users are familiar with the star or asterisk character (`*`), which
    matches any sequence of zero or more characters (except for a leading dot)^([1](ch02.xhtml#idm46586652391888))
    in file or directory paths:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Behind the scenes, the shell (not `grep`!) expands the pattern `chapter*` into
    a list of 100 matching filenames. Then the shell runs `grep`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'Many users have also seen the question mark (`?`) special character, which
    matches any single character (except a leading dot). For example, you could search
    for the word *Linux* in chapters 1 through 9 only, by providing a single question
    mark to make the shell match single digits:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'or in chapters 10 through 99, with two question marks to match two digits:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Fewer users are familiar with square brackets (`[]`), which request the shell
    to match a single character from a set. For example, you could search only the
    first five chapters:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Equivalently, you could supply a range of characters with a dash:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You could also search even-numbered chapters, combining the asterisk and the
    square brackets to make the shell match filenames ending in an even digit:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Any characters, not just digits, may appear within the square brackets for
    matching. For example, filenames that begin with a capital letter, contain an
    underscore, and end with an `@` symbol would be matched by the shell in this command:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Terminology: Evaluating Expressions and Expanding Patterns'
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Strings that you enter on the command line, such as `chapter*` or `Efficient
    Linux`, are called *expressions*. An entire command like `ls -l chapter*` is an
    expression too.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: When the shell interprets and handles special characters in an expression, such
    as asterisks and pipe symbols, we say that the shell *evaluates* the expression.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching is one kind of evaluation. When the shell evaluates an expression
    that contains pattern-matching symbols, such as `chapter*`, and replaces it with
    filenames that match the pattern, we say that the shell *expands* the pattern.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Patterns are valid almost anywhere that you’d supply file or directory paths
    on the command line. For example, you can list all files in the directory */etc*
    with names ending in *.conf* using a pattern:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 模式几乎可以应用于您在命令行上提供文件或目录路径的任何地方。例如，您可以使用模式列出目录*/etc*中以*.conf*结尾的所有文件：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Be careful using a pattern with a command that accepts just one file or directory
    argument, such as `cd`. You might not get the behavior you expect:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 谨慎使用仅接受一个文件或目录参数的命令与模式一起使用，例如`cd`。您可能得不到您期望的行为：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If a pattern doesn’t match any files, the shell leaves it unchanged to be passed
    literally as a command argument. In the following command, the pattern `*.doc`
    matches nothing in the current directory, so `ls` looks for a filename literally
    named `*.doc` and fails:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个模式不匹配任何文件，shell将其保留为未更改的命令参数文字传递。在以下命令中，模式`*.doc`在当前目录中找不到任何匹配项，因此`ls`寻找一个名为`*.doc`的文件名并失败：
- en: '[PRE12]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When working with file patterns, two points are vitally important to remember.
    The first, as I’ve already emphasized, is that the shell, not the invoked program,
    performs the pattern matching. I know I keep repeating this, but I’m frequently
    surprised by how many Linux users don’t know it and develop superstitions about
    why certain commands succeed or fail.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用文件模式时，有两个非常重要的要点需要记住。首先，正如我已经强调的，模式匹配由shell执行，而不是调用的程序。我知道我一直在重复这一点，但我经常对多少Linux用户不知道它并且会对某些命令成功或失败发展出迷信感到惊讶。
- en: The second important point is that shell pattern matching applies only to file
    and directory paths. It doesn’t work for usernames, hostnames, and other types
    of arguments that certain commands accept. You also cannot type (say) `s?rt` at
    the beginning of the command line and expect the shell to run the `sort` program.
    (Some Linux commands such as `grep`, `sed`, and `awk` perform their own brands
    of pattern matching, which we’ll explore in [Chapter 5](ch05.xhtml#ch_toolbox).)
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个重要点是shell模式匹配仅适用于文件和目录路径。它不适用于用户名、主机名和某些命令接受的其他类型的参数。您也不能在命令行开头键入（例如）`s?rt`并期望shell运行`sort`程序。（某些Linux命令如`grep`、`sed`和`awk`执行它们自己的模式匹配，我们将在[第5章](ch05.xhtml#ch_toolbox)中探讨。）
- en: Filename Pattern Matching and Your Own Programs
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件名模式匹配和您自己的程序
- en: 'All programs that accept filenames as arguments automatically “work” with pattern
    matching, because the shell evaluates the patterns before the program runs. This
    is true even for programs and scripts you write yourself. For example, if you
    wrote a program `english2swedish` that translated files from English to Swedish
    and accepted multiple filenames on the command line, you could instantly run it
    with pattern matching:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 所有接受文件名作为参数的程序都自动“使用”模式匹配，因为shell在程序运行之前评估模式。即使是您自己编写的程序和脚本也是如此。例如，如果您编写了一个程序`english2swedish`，它将文件从英语翻译成瑞典语并接受命令行上的多个文件名，您可以立即使用模式匹配运行它：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Evaluating Variables
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 变量评估
- en: A running shell can define variables and store values in them. A shell variable
    is a lot like a variable in algebra—it has a name and a value. An example is the
    shell variable `HOME`. Its value is the path to your Linux home directory, such
    as */home/smith*. Another example is `USER`, whose value is your Linux username,
    which I’ll assume is `smith` throughout this book.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 运行中的shell可以定义变量并将值存储在其中。shell变量与代数中的变量很像——它有一个名称和一个值。一个例子是shell变量`HOME`。它的值是您的Linux主目录路径，例如*/home/smith*。另一个例子是`USER`，其值是您的Linux用户名，我将在本书中假设为`smith`。
- en: 'To print the values of `HOME` and `USER` on stdout, run the command `printenv`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要在stdout上打印`HOME`和`USER`的值，请运行`printenv`命令：
- en: '[PRE14]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When the shell evaluates a variable, it replaces the variable name with its
    value. Simply place a dollar sign in front of the name to evaluate the variable.
    For example, `$HOME` evaluates to the string `/home/smith`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当shell评估一个变量时，它将变量名替换为其值。只需在名称前面放置一个美元符号来评估变量。例如，`$HOME`评估为字符串`/home/smith`。
- en: 'The easiest way to watch the shell evaluate a command line is to run the `echo`
    command, which simply prints its arguments (after the shell is finished evaluating
    them):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 观察shell评估命令行最简单的方法是运行`echo`命令，该命令简单地打印其参数（在shell完成评估后）：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Where Variables Come From
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量的来源
- en: Variables like `USER` and `HOME` are predefined by the shell. Their values are
    set automatically when you log in. (More on this process later.) Traditionally,
    such predefined variables have uppercase names.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'You also may define or modify a variable anytime by assigning it a value using
    this syntax:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'For example, if you work frequently in the directory */home/smith/Projects*,
    you could assign its name to a variable:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'and use it as a handy shortcut with `cd`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'You may supply `$work` to any command that expects a directory:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When defining a variable, no spaces are permitted around the equals sign. If
    you forget, the shell will assume (wrongly) that the first word on the command
    line is a program to run, and the equals sign and value are its arguments, and
    you’ll see an error message:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: A user-defined variable like `work` is just as legitimate and usable as a system-defined
    variable like `HOME`. The only practical difference is that some Linux programs
    change their behavior internally based on the values of `HOME`, `USER`, and other
    system-defined variables. For example, a Linux program with a graphical interface
    might retrieve your username from the shell and display it. Such programs don’t
    pay attention to an invented variable like `work` because they weren’t programmed
    to do so.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Variables and Superstition
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you print the value of a variable with `echo`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'you might think that the `echo` command examines the `HOME` variable and prints
    its value. That is *not* the case. `echo` knows nothing about variables. It just
    prints whatever arguments you hand it. What’s really happening is that the shell
    evaluates `$HOME` before running `echo`. From `echo`’s perspective, you typed:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This behavior is extremely important to understand, especially as we delve into
    more complicated commands. The shell evaluates the variables in a command—as well
    as patterns and other shell constructs—before executing the command.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Patterns Versus Variables
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s test your understanding of pattern and variable evaluation. Suppose you’re
    in a directory with two subdirectories, *mammals* and *reptiles*, and oddly, the
    *mammals* subdirectory contains files named *lizard.txt* and *snake.txt*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the real world, lizards and snakes are not mammals, so the two files should
    be moved to the *reptiles* subdirectory. Here are two proposed ways to do it.
    One works, and one does not:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Method 1 works because patterns match an entire file path. See how the directory
    name *mammals* is part of both matches for `mammals/*.txt`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'So, method 1 operates as if you’d typed the following correct command:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Method 2 uses variables, which evaluate to their literal value only. They have
    no special handling for file paths:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'So, method 2 operates as if you’d typed the following problematic command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This command looks for the file *snake.txt* in the current directory, not in
    the *mammals* subdirectory, and fails:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'To make a variable work in this situation, use a `for` loop that prepends the
    directory name *mammals* to each filename:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Shortening Commands with Aliases
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A variable is a name that stands in for a value. The shell also has names that
    stand in for commands. They’re called *aliases*. Define an alias by inventing
    a name and following it with a equals sign and a command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Run an alias by typing its name as a command. When aliases are shorter than
    the commands they invoke, you save typing time:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Tip
  id: totrans-102
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Always define an alias on its own line, not as part of a combined command. (See
    `man bash` for the technical details.)
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: You can define an alias that has the same name as an existing command, effectively
    replacing that command in your shell. This practice is called *shadowing* the
    command. Suppose you like the `less` command for reading files, but you want it
    to clear the screen before displaying each page. This feature is enabled with
    the `-c` option, so define an alias called “less” that runs `less -c`:^([2](ch02.xhtml#idm46586653823824))
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Aliases take precedence over commands of the same name, so you have now shadowed
    the `less` command in the current shell. I’ll explain what *precedence* means
    in [“Search Path and Aliases”](#search_path_aliases).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'To list a shell’s aliases and their values, run `alias` with no arguments:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To see the value of a single alias, run `alias` followed by its name:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'To delete an alias from a shell, run `unalias`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Redirecting Input and Output
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The shell controls the input and output of the commands it runs. You’ve already
    seen one example: pipes, which direct the stdout of one command to the stdin of
    another. The pipe syntax, `|`, is a feature of the shell.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'Another shell feature is redirecting stdout to a file. For example, if you
    use `grep` to print matching lines from the *animals.txt* file from [Example 1-1](ch01.xhtml#example_animals.txt),
    the command writes to stdout by default:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can send that output to a file instead, using a shell feature called *output
    redirection*. Simply add the symbol `>` followed by the name of a file to receive
    the output:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'You have just redirected stdout to the file *outfile* instead of the display.
    If the file *outfile* doesn’t exist, it’s created. If it does exist, redirection
    overwrites its contents. If you’d rather append to the output file rather than
    overwrite it, use the symbol `>>` instead:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Output redirection has a partner, *input redirection*, that redirects stdin
    to come from a file instead of the keyboard. Use the symbol `<` followed by a
    filename to redirect stdin.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Many Linux commands that accept filenames as arguments, and read from those
    files, also read from stdin when run with no arguments. An example is `wc` for
    counting lines, words, and characters in a file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It’s *very important* to understand how these two `wc` commands differ in behavior:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: In the first command, `wc` receives the filename *animals.txt* as an argument,
    so `wc` is aware that the file exists. `wc` deliberately opens the file on disk
    and reads its contents.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the second command, `wc` is invoked with no arguments, so it reads from stdin,
    which is usually the keyboard. The shell, however, sneakily redirects stdin to
    come from *animals.txt* instead. `wc` has no idea that the file *animals.txt*
    exists.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The shell can redirect input and output in the same command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'and can even use pipes at the same time. Here, `grep` reads from redirected
    stdin and pipes the results to `wc`, which writes to redirected stdout, producing
    the file *count*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: You’ll dive deeper into such combined commands in [Chapter 8](ch08.xhtml#ch_one_liner)
    and see many other examples of redirection throughout the book.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Evaluation with Quotes and Escapes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Normally the shell uses whitespace as a separator between words. The following
    command has four words—a program name followed by three arguments:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Sometimes, however, you need the shell to treat whitespace as significant,
    not as a separator. A common example is whitespace in a filename such as *Efficient
    Linux Tips.txt*:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If you refer to such a filename on the command line, your command may fail
    because the shell treats the space characters as separators:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'To force the shell to treat spaces as part of a filename, you have three options—single
    quotes, double quotes, and backslashes:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Single quotes tell the shell to treat every character in a string literally,
    even if the character ordinarily has special meaning to the shell, such as spaces
    and dollar signs:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Double quotes tell the shell to treat all characters literally except for certain
    dollar signs and a few others you’ll learn later:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A backslash, also called the *escape character*, tells the shell to treat the
    next character literally. The following command includes an escaped dollar sign:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Backslashes act as escape characters even within double quotes:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'but not within single quotes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Use the backslash to escape a double quote character within double quotes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A backslash at the end of a line disables the special nature of the invisible
    newline character, allowing shell commands to span multiple lines:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Final backslashes are great for making pipelines more readable, like this one
    from [“Command #6: uniq”](ch01.xhtml#section_uniq):'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When used this way, the backslash is sometimes called a *line continuation character*.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: 'A leading backslash before an alias escapes the alias, causing the shell to
    look for a command of the same name, ignoring any shadowing:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Locating Programs to Be Run
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the shell first encounters a simple command, such as `ls *.py`, it’s just
    a string of meaningless characters. Quick as a flash, the shell splits the string
    into two words, “ls” and “*.py”. In this case, the first word is the name of a
    program on disk, and the shell must locate the program to run it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'The program `ls`, it turns out, is an executable file in the directory */bin*.
    You can verify its location with this command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'or you can change directories with `cd /bin` and run this lovely, cryptic-looking
    command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: which uses the command `ls` to list the executable file *ls*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: 'How does the shell locate `ls` in the */bin* directory? Behind the scenes,
    the shell consults a prearranged list of directories that it holds in memory,
    called a *search path*. The list is stored as the value of the shell variable
    `PATH`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Directories in a search path are separated by colons (`:`). For a clearer view,
    convert the colons to newline characters by piping the output to the `tr` command,
    which translates one character into another (more details in [Chapter 5](ch05.xhtml#ch_toolbox)):'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: The shell consults directories in your search path from first to last when locating
    a program like `ls`. “Does */home/smith/bin/ls* exist? No. Does */usr/local/bin/ls*
    exist? Nope. How about */usr/bin/ls*? No again! Maybe */bin/ls*? Yes, there it
    is! I’ll run */bin/ls*.” This search happens too quickly to notice.^([3](ch02.xhtml#idm46586642464768))
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'To locate a program in your search path, use the `which` command:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: or the more powerful (and verbose) `type` command, a shell builtin that also
    locates aliases, functions, and shell builtins:^([4](ch02.xhtml#idm46586642454096))
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Your search path may contain the same-named command in different directories,
    such as */usr/bin/less* and */bin/less*. The shell runs whichever command appears
    in the earlier directory in the path. By leveraging this behavior, you can override
    a Linux command by placing a same-named command in an earlier directory in your
    search path, such as your personal *$HOME/bin* directory.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Search Path and Aliases
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the shell searches for a command by name, it checks if that name is an
    alias before checking the search path. That’s why an alias can shadow (take precedence
    over) a command of the same name.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The search path is a great example of taking something mysterious about Linux
    and showing it has an ordinary explanation. The shell doesn’t pull commands out
    of thin air or locate them by magic. It methodically examines directories in a
    list until it finds the requested executable file.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: Environments and Initialization Files, the Short Version
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A running shell holds a bunch of important information in variables: the search
    path, the current directory, your preferred text editor, your customized shell
    prompt, and more. The variables of a running shell are collectively called the
    shell’s *environment*. When the shell exits, its environment is destroyed.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: It would be extremely tedious to define every shell’s environment by hand. The
    solution is to define the environment once, in shell scripts called *startup files*
    and *initialization files*, and have every shell execute these scripts on startup.
    The effect is that certain information appears to be “global” or “known” to all
    of your running shells.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ll dive into the gory details in [“Configuring Your Environment”](ch06.xhtml#section_bash_configs).
    For now, I’ll teach you about one initialization file so you can get through the
    next few chapters. It’s located in your home directory and named *.bashrc* (pronounced
    “dot bash R C”). Because its name begins with a dot, `ls` doesn’t list it by default:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'If *$HOME/.bashrc* doesn’t exist, create it with a text editor. Commands you
    place in this file will execute automatically when a shell starts up,^([5](ch02.xhtml#idm46586642420864))
    so it’s a great place to define variables for the shell’s environment, and other
    things important to the shell, such as aliases. Here is a sample *.bashrc* file.
    Lines beginning with `#` are comments:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Any changes you make to *$HOME/.bashrc* do not affect any running shells, only
    future shells. You can force a running shell to reread and execute *$HOME/.bashrc*
    with either of the following commands:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: This process is known as *sourcing* the initialization file. If someone tells
    you to “source your dot-bash-R-C file,” they mean run one of the preceding commands.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In real life, do not put all of your shell configuration in *$HOME/.bashrc*.
    Once you’ve read the details in [“Configuring Your Environment”](ch06.xhtml#section_bash_configs),
    examine your *$HOME/.bashrc* and move commands to their proper files as needed.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’ve covered only a tiny number of `bash` features and their most basic uses.
    You’ll see many more in the chapters that follow, particularly in [Chapter 6](ch06.xhtml#ch_parent_child).
    For right now, your most important job is to understand the following concepts:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The shell exists and has important responsibilities.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shell evaluates the command line before running any commands.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commands can redirect stdin, stdout, and stderr.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quoting and escaping prevent special shell characters from being evaluated.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shell locates programs using a search path of directories.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can change a shell’s default behavior by adding commands to the file *$HOME/.bashrc*.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The better you understand the division between the shell and the programs it
    invokes, the more that the command line will make sense, and the better you can
    predict what will happen before you press Enter to run a command.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.xhtml#idm46586652391888-marker)) That’s why the command `ls *` doesn’t
    list filenames beginning with a dot, a.k.a. dot files.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch02.xhtml#idm46586653823824-marker)) `bash` prevents infinite recursion
    by not expanding the second `less` as an alias.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch02.xhtml#idm46586642464768-marker)) Some shells memorize (cache) the
    paths to programs as they’re located, cutting down on future searches.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch02.xhtml#idm46586642454096-marker)) Notice that the command `type which`
    produces output, but the command `which type` does not.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch02.xhtml#idm46586642420864-marker)) This statement is oversimplified;
    more details are in [Table 6-1](ch06.xhtml#table_config).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
