<html><head></head><body><section data-pdf-bookmark="Chapter 4. Configuration, Secrets, and RBAC" data-type="chapter" epub:type="chapter"><div class="chapter" id="configuration_secrets_and_rbac">&#13;
<h1><span class="label">Chapter 4. </span>Configuration, Secrets, and RBAC</h1>&#13;
&#13;
&#13;
<p>The composable nature of containers allows us as operators to introduce&#13;
configuration data into a container at runtime. This makes it possible for us to decouple an application’s function from the environment it&#13;
runs in. By means of the conventions allowed in the container runtime to&#13;
pass through either environment variables or mount external volumes into&#13;
a container at runtime, you can effectively change the configuration of&#13;
the application upon its instantiation. As a developer, it is important&#13;
to consider the dynamic nature of this behavior and allow for the use of environment variables or the reading of configuration data from a specific path available to the application runtime user.</p>&#13;
&#13;
<p>When moving sensitive data such as secrets into a native Kubernetes API&#13;
object, it is important to understand how Kubernetes secures access to&#13;
the API. The most commonly implemented security method in use in&#13;
Kubernetes is Role-Based Access Control (RBAC) to implement a&#13;
fine-grained permission structure around actions that can be taken&#13;
against the API by specific users or groups. This chapter covers&#13;
some of the best practices regarding RBAC and also provides a small primer.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuration Through ConfigMaps and Secrets" data-type="sect1"><div class="sect1" id="id349">&#13;
<h1>Configuration Through ConfigMaps and Secrets</h1>&#13;
&#13;
<p>Kubernetes allows you to natively provide configuration information to our applications through ConfigMaps or secret resources. The main differentiator between the two is the way a pod stores the receiving information and how the data is stored in the etcd data store.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="ConfigMaps" data-type="sect2"><div class="sect2" id="id29">&#13;
<h2>ConfigMaps</h2>&#13;
&#13;
<p>It <a data-primary="configuring" data-secondary="with ConfigMaps" data-secondary-sortas="ConfigMaps" data-type="indexterm" id="config-configmap2"/><a data-primary="ConfigMaps resource" data-type="indexterm" id="configmaps2"/>is very common to have applications consume configuration information&#13;
through some type of mechanism such as command-line arguments,&#13;
environment variables, or files that are available to the system.&#13;
Containers allow the developer to decouple this configuration&#13;
information from the application, which allows for true application&#13;
portability. The ConfigMap API allows for the injection of supplied&#13;
configuration information. ConfigMaps are very adaptable to the&#13;
application’s requirements and can provide key/value pairs or complex&#13;
bulk data such as JSON, XML, or proprietary configuration data.</p>&#13;
&#13;
<p>The ConfigMaps not only provide configuration information for pods,&#13;
but they can also provide information to be consumed for more complex system&#13;
services such as controllers, CRDs, operators, and so on. As mentioned earlier,&#13;
the ConfigMap API is meant more for string data that is not&#13;
really sensitive data. If your application requires more sensitive data, the Secrets API is more appropriate.</p>&#13;
&#13;
<p>For your application to use the ConfigMap data, it can be injected as&#13;
either a volume mounted into the pod or as environment variables.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Secrets" data-type="sect2"><div class="sect2" id="id30">&#13;
<h2>Secrets</h2>&#13;
&#13;
<p>Many <a data-primary="configuring" data-secondary="with secrets" data-secondary-sortas="secrets" data-type="indexterm" id="config-secret"/><a data-primary="secrets" data-secondary="configuring with" data-type="indexterm" id="secret-config"/>of the attributes and reasons for which you would want to use a ConfigMap&#13;
apply to secrets. The main differences lie in the fundamental nature of&#13;
a secret. Secret data should be stored and handled in a way that can be&#13;
easily hidden and possibly encrypted at rest if the environment is&#13;
configured as such. The secret data is represented as base64-encoded&#13;
information, and it is critical to understand that this is not encrypted.&#13;
As soon as the secret is injected into the pod, the pod itself can see the&#13;
secret data in plain text.</p>&#13;
&#13;
<p>Secret data is meant to be small amounts of data, limited by default in&#13;
Kubernetes to 1 MB in size for the base64-encoded data, so ensure that the actual data is approximately 750 KB because of the overhead of the encoding. There are three types of secrets in&#13;
Kubernetes:</p>&#13;
<dl>&#13;
<dt><code>generic</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="generic secrets" data-type="indexterm" id="id588"/>is typically just regular key/value pairs that are created from a file, a directory, or from string literals using the <code>--from-literal=</code> parameter, as follows:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">kubectl<code class="w"> </code>create<code class="w"> </code>secret<code class="w"> </code>generic<code class="w"> </code>mysecret<code class="w"> </code>--from-literal<code class="o">=</code><code class="nv">key1</code><code class="o">=</code><code class="nv">$3</code>cr3t1<code class="w"/>&#13;
<code class="w">    </code>--from-literal<code class="o">=</code><code class="nv">key2</code><code class="o">=</code>@3cr3t2<code class="w"/></pre>&#13;
</dd>&#13;
<dt><code>docker-registry</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="docker-registry secrets" data-type="indexterm" id="id589"/>is used by the kubelet when passed in a pod template if there is an <code>imagePullsecret</code> to provide the credentials needed to authenticate to a private Docker registry:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">kubectl<code class="w"> </code>create<code class="w"> </code>secret<code class="w"> </code>docker-registry<code class="w"> </code>registryKey<code class="w"> </code>--docker-server<code class="w"/>&#13;
<code class="w">    </code>myreg.azurecr.io<code class="w"> </code>--docker-username<code class="w"> </code>myreg<code class="w"> </code>--docker-password<code class="w"/>&#13;
<code class="w">    </code><code class="nv">$up3r$3</code>cr3tP@ssw0rd<code class="w"> </code>--docker-email<code class="w"> </code>ignore@dummy.com<code class="w"/></pre>&#13;
</dd>&#13;
<dt><code>tls</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="tls secrets" data-type="indexterm" id="id590"/>creates a Transport Layer Security (TLS) secret from a valid public/private key pair. As long as the cert is in a valid PEM format, the key pair will be encoded as a secret and can be passed to the pod to use for SSL/TLS needs:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">kubectl<code class="w"> </code>create<code class="w"> </code>secret<code class="w"> </code>tls<code class="w"> </code>www-tls<code class="w"> </code>--key<code class="o">=</code>./path_to_key/wwwtls.key<code class="w"/>&#13;
<code class="w">    </code>--cert<code class="o">=</code>./path_to_crt/wwwtls.crt<code class="w"/></pre>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Secrets are also mounted into tmpfs only on the nodes that have a pod&#13;
that requires the secret and are deleted when the pod that needs the secret is&#13;
gone. This prevents any secrets from being left behind on the disk of the node. Although this might seem secure, it is important to know that, by default, secrets are stored in the etcd data store of Kubernetes in plain text, and it is important that the system administrators or cloud service provider take efforts to ensure the security of the etcd environment, including mTLS between the etcd nodes and enabling encryption at rest for the etcd data. More recent versions of Kubernetes use etcd3 and have the ability to enable etcd native encryption; however, this is a manual process that must be configured in the API server configuration by specifying a provider and the appropriate key media to properly encrypt secret data held in etcd. As of Kubernetes v1.10 (it has been promoted to beta in v1.12), we have the KMS provider, which promises to provide a more secure key process by using third-party KMS systems to hold the proper<a data-primary="configuring" data-secondary="with secrets" data-secondary-sortas="secrets" data-startref="config-secret" data-type="indexterm" id="id591"/><a data-primary="secrets" data-secondary="configuring with" data-startref="secret-config" data-type="indexterm" id="id592"/> keys.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Common Best Practices for the ConfigMap &#10;and Secrets APIs" data-type="sect1"><div class="sect1" id="id31">&#13;
<h1>Common Best Practices for the ConfigMap &#13;
<span class="keep-together">and Secrets APIs</span></h1>&#13;
&#13;
<p>The majority<a data-primary="ConfigMaps resource" data-type="indexterm" id="configmaps-best-practice"/><a data-primary="best practices" data-secondary="ConfigMaps" data-type="indexterm" id="best-practice-configmaps"/><a data-primary="secrets" data-secondary="best practices" data-type="indexterm" id="secret-best-practice"/><a data-primary="best practices" data-secondary="secrets" data-type="indexterm" id="best-practice-secret"/> of issues that arise from the use of a ConfigMap or secret&#13;
are incorrect assumptions about how changes are handled when the data held&#13;
by the object is updated. By understanding the rules of the road and&#13;
adding a few tricks to make it easier to abide by those rules, you&#13;
can steer away from trouble:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>To support<a data-primary="volumes" data-secondary="mounting ConfigMaps/secrets as" data-type="indexterm" id="volume-mount"/><a data-primary="mounting volumes as ConfigMaps/secrets" data-type="indexterm" id="mount-volume"/> dynamic changes to your application without having to redeploy new versions of the pods, mount your ConfigMaps/Secrets as a volume and configure your application with a file watcher to detect the changed file data and reconfigure itself as needed. The following code shows a Deployment that mounts a ConfigMap and a Secret file as a volume:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-http-config</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp-prod</code><code class="w"/>&#13;
<code class="nt">data</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">config</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w"/>&#13;
<code class="w">    </code><code class="no">http {</code><code class="w"/>&#13;
<code class="w">      </code><code class="no">server {</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">location / {</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">root /data/html;</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">}</code><code class="w"/>&#13;
&#13;
<code class="w">        </code><code class="no">location /images/ {</code><code class="w"/>&#13;
<code class="w">          </code><code class="no">root /data;</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">}</code><code class="w"/>&#13;
<code class="w">      </code><code class="no">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="no">}</code><code class="w"/></pre>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Secret</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp-api-key</code><code class="w"/>&#13;
<code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Opaque</code><code class="w"/>&#13;
<code class="nt">data</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">myapikey</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">YWRtd5thSaW4=</code><code class="w"/></pre>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mywebapp</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp-prod</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/nginx</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-config</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/usr/var/nginx/html/keys</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-key</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-config</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">configMap</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-http-config</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">items</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx.conf</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">api-key</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">secret</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp-api-key</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">secretname</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapikey</code><code class="w"/></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There are a couple of things to consider when using <code>volumeMounts</code>. First, as soon as the ConfigMap/Secret is created, add it as a volume in your pod’s specification. Then mount that volume into the container’s filesystem. Each property name in the ConfigMap/Secret will become a new file in the mounted directory, and the contents of each file will be the value specified in the ConfigMap/Secret. Second, avoid mounting ConfigMaps/Secrets using the <code>volumeMounts.subPath</code> property. This will prevent the data from being dynamically updated in the volume if you update a ConfigMap/Secret with<a data-primary="volumes" data-secondary="mounting ConfigMaps/secrets as" data-startref="volume-mount" data-type="indexterm" id="id593"/><a data-primary="mounting volumes as ConfigMaps/secrets" data-startref="mount-volume" data-type="indexterm" id="id594"/> new data.</p>&#13;
</div>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>ConfigMaps/Secrets must exist in the namespace for the pods that will consume them prior to the pod being deployed. The optional flag can be used to prevent the pods from not starting if the ConfigMap/Secret is not present.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use an admission controller to ensure specific configuration data or to prevent deployments that do not have specific configuration values set. An example would be if you require all production Java workloads to have certain JVM properties set in production environments.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re using Helm to release applications into your environment, you can use a life cycle hook to ensure the ConfigMap/Secret template is deployed before the Deployment is applied.</p>&#13;
</li>&#13;
<li>&#13;
<p>Some applications require their configuration to be applied as a single file such as a JSON or YAML file. ConfigMap/Secret allows an entire block of raw data by using the <code>|</code> symbol, as demonstrated here:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">config-file</code><code class="w"/>&#13;
<code class="nt">data</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">config</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">|</code><code class="w"/>&#13;
<code class="w">    </code><code class="no">{</code><code class="w"/>&#13;
<code class="w">      </code><code class="no">"iotDevice": {</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">"name": "remoteValve",</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">"username": "CC:22:3D:E3:CE:30",</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">"port": 51826,</code><code class="w"/>&#13;
<code class="w">        </code><code class="no">"pin": "031-45-154"</code><code class="w"/>&#13;
<code class="w">      </code><code class="no">}</code><code class="w"/>&#13;
<code class="w">    </code><code class="no">}</code><code class="w"/></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the<a data-primary="environment variables with ConfigMaps/secrets" data-type="indexterm" id="env-variables-configmaps"/> application uses system environment variables to determine its&#13;
configuration, you can use the injection of the ConfigMap data to create an&#13;
environment variable mapping into the pod. There are two main ways to do&#13;
this: mounting every key/value pair in the ConfigMap as a series of&#13;
environment variables into the pod using <code>envFrom</code> and then using&#13;
<code>configMapRef</code> or <code>secretRef</code>, or assigning individual keys with their&#13;
respective values using the <code>configMapKeyRef</code> or <code>secretKeyRef</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re using the <code>configMapKeyRef</code> or <code>secretKeyRef</code> method, be aware that&#13;
if the actual key does not exist, this will prevent the pod from&#13;
starting.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re loading all the key/value pairs from the ConfigMap/Secret into&#13;
the pod using <code>envFrom</code>, any keys that are considered invalid environment&#13;
values will be skipped; however, the pod will be allowed to start. The&#13;
event for the pod will have an event with reason <code>InvalidVariableNames</code>&#13;
and the appropriate message about which key was skipped. The following code is an example of a Deployment with a ConfigMap and Secret reference as an environment variable:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ConfigMap</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql-config</code><code class="w"/>&#13;
<code class="nt">data</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">mysqldb</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myappdb1</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">user</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysqluser1</code><code class="w"/></pre>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Secret</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql-secret</code><code class="w"/>&#13;
<code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Opaque</code><code class="w"/>&#13;
<code class="nt">data</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">rootpassword</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">YWRtJasdhaW4=</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">userpassword</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MWYyZDigKJGUyfgKJBmU2N2Rm</code><code class="w"/></pre>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp-db-deploy</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp-db</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp-db</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">myapp-db-instance</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"128Mi"</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"500m"</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3306</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MYSQL_ROOT_PASSWORD</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">secretKeyRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql-secret</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rootpassword</code><code class="w"/>&#13;
<code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MYSQL_PASSWORD</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">secretKeyRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql-secret</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">userpassword</code><code class="w"/>&#13;
<code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MYSQL_USER</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql-config</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">user</code><code class="w"/>&#13;
<code class="w">          </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">MYSQL_DB</code><code class="w"/>&#13;
<code class="w">            </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">              </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql-config</code><code class="w"/>&#13;
<code class="w">                </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysqldb</code><code class="w"/></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If there is a need to pass command-line arguments to your containers,&#13;
environment variable data can be sourced using <code>$(ENV_KEY)</code> interpolation&#13;
syntax:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="p-Indicator">[</code><code class="nv">...</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">load-gen</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">busybox</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"/bin/sh"</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="nt">args</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"-c"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">curl</code><code class="nv"> </code><code class="s">$(WEB_UI_URL);</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">10;done"</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">WEB_UI_URL</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">valueFrom</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">configMapKeyRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">load-gen-config</code><code class="w"/>&#13;
<code class="w">          </code><code class="nt">key</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">url</code><code class="w"/></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>When consuming ConfigMap/Secret data as environment variables, it is very important to understand that updates to the data in the&#13;
ConfigMap/Secret will <em>not</em> update in the pod and will require a pod&#13;
restart. This can be done either by deleting the pods and letting the ReplicaSet&#13;
controller create a new pod, or by triggering a Deployment update, which will&#13;
follow the proper application update strategy as declared in the&#13;
Deployment specification.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<ul class="less_space pagebreak-before">&#13;
<li>&#13;
<p>It is easier to assume that all changes to a ConfigMap/Secret require an update to the entire Deployment; this ensures that even if you’re using environment variables or volumes, the code will take the new configuration data. To make this easier, you can use a CI/CD pipeline to update the <code>name</code> property of the ConfigMap/Secret and also update the reference in the Deployment, which will then trigger a Deployment update through normal Kubernetes update strategies. We will explore&#13;
this in the following example code. If you’re using Helm to release your application&#13;
code into Kubernetes, you can take advantage of an annotation in the&#13;
Deployment template to check the <code>sha256</code> checksum of the&#13;
ConfigMap/Secret. This triggers Helm to update the Deployment using&#13;
the <code>helm upgrade</code> command when the data within a ConfigMap/Secret is<a data-primary="ConfigMaps resource" data-startref="configmaps-best-practice" data-type="indexterm" id="id595"/><a data-primary="best practices" data-secondary="ConfigMaps" data-startref="best-practice-configmaps" data-type="indexterm" id="id596"/><a data-primary="environment variables with ConfigMaps/secrets" data-startref="env-variables-configmaps" data-type="indexterm" id="id597"/>&#13;
changed:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>&#13;
<code class="p-Indicator">[</code><code class="nv">...</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">      </code><code class="nt">annotations</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">        </code><code class="nt">checksum/config</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">include (print $.Template.BasePath "/configmap.yaml")</code><code class="w"/>&#13;
<code class="w">            </code><code class="nv">. | sha256sum</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>&#13;
<code class="p-Indicator">[</code><code class="nv">...</code><code class="p-Indicator">]</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Best Practices Specific to Secrets" data-type="sect1"><div class="sect1" id="id196">&#13;
<h1>Best Practices Specific to Secrets</h1>&#13;
&#13;
<p>Because of the nature of sensitive data of the Secrets API, there are&#13;
naturally more specific best practices, which are mainly around the&#13;
security of the data itself:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If your workload does not need to access the Kubernetes API directly it is good practice to block the automounting of the API Credential for the Service Account (Default or operator created). This will reduce the API calls to the API server as a watch is used to update the API credential data upon the credential expiring. In very large clusters or clusters with a lot of pods, this will reduce the calls to the Control Plane thus reducing a possible cause of performance degradation. This can be defined on the ServiceAccount or the Pod Spec itself:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ServiceAccount</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app1-svcacct</code><code class="w"/>&#13;
<code class="nt">automountServiceAccountToken</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>&#13;
<code class="p-Indicator">[</code><code class="nv">...</code><code class="p-Indicator">]</code><code class="w"/></pre>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>&#13;
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app1-pod</code><code class="w"/>&#13;
<code class="nt">spec</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">serviceAccountName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">app1-svcacct</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">automountServiceAccountToken</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>&#13;
<code class="p-Indicator">[</code><code class="nv">...</code><code class="p-Indicator">]</code><code class="w"/></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The original specification for the Secrets API outlined a pluggable&#13;
architecture to allow the actual storage of the secret to be&#13;
configurable based on requirements. Solutions such as HashiCorp Vault,&#13;
Aqua Security, Twistlock, AWS Secrets Manager, Google Cloud KMS, or Azure Key Vault allow the use of external storage systems for secret data using a higher level of encryption and auditability than what is offered natively in Kubernetes. The Linux Foundation project &#13;
<span class="keep-together">ExternalSecrets</span> Operator provides a native way to provide this functionality.</p>&#13;
</li>&#13;
<li>&#13;
<p>Assign an <code>imagePullSecrets</code> to a <code>serviceaccount</code> that the pod will use to&#13;
automatically mount the secret without having to declare it in the&#13;
<code>pod.spec</code>. You can patch the default service account for the namespace&#13;
of your application and add the <code>imagePullSecrets</code> to it directly. This automatically adds it to all pods in the namespace:</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">Create<code class="w"> </code>the<code class="w"> </code>docker-registry<code class="w"> </code>secret<code class="w"> </code>first<code class="w"/>&#13;
kubectl<code class="w"> </code>create<code class="w"> </code>secret<code class="w"> </code>docker-registry<code class="w"> </code>registryKey<code class="w"> </code>--docker-server<code class="w"/>&#13;
myreg.azurecr.io<code class="w"> </code>--docker-username<code class="w"> </code>myreg<code class="w"> </code>--docker-password<code class="w"> </code><code class="nv">$up3r$3</code>cr3tP@ssw0rd<code class="w"/>&#13;
--docker-email<code class="w"> </code>ignore@dummy.com<code class="w"/>&#13;
&#13;
patch<code class="w"> </code>the<code class="w"> </code>default<code class="w"> </code>serviceaccount<code class="w"> </code><code class="k">for</code><code class="w"> </code>the<code class="w"> </code>namespace<code class="w"> </code>you<code class="w"> </code>wish<code class="w"> </code>to<code class="w"> </code>configure<code class="w"/>&#13;
kubectl<code class="w"> </code>patch<code class="w"> </code>serviceaccount<code class="w"> </code>default<code class="w"> </code>-p<code class="w"> </code><code class="s1">'{"imagePullSecrets": [{"name":</code>&#13;
<code class="s1">"registryKey"}]}'</code><code class="w"/></pre>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use CI/CD capabilities to get secrets from a secure vault or encrypted&#13;
store with a Hardware Security Module (HSM) during the release pipeline. This allows for separation of duties. Security management teams can create and encrypt the secrets, and developers just need to reference the names of the secret expected. This is also the preferred DevOps process to ensure a more dynamic application delivery<a data-primary="secrets" data-secondary="best practices" data-startref="secret-best-practice" data-type="indexterm" id="id598"/><a data-primary="best practices" data-secondary="secrets" data-startref="best-practice-secret" data-type="indexterm" id="id599"/> process.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RBAC" data-type="sect1"><div class="sect1" id="id350">&#13;
<h1>RBAC</h1>&#13;
&#13;
<p>When working in large, distributed environments, it is very common that some type of security mechanism is needed to&#13;
prevent unauthorized access to critical systems. There are numerous strategies around how to limit access to resources in computer systems, but the majority all go through the same phases. Using an analogy of a common experience such as flying to a foreign country can help explain the processes that happen in systems like Kubernetes. We can use the common traveler’s experience with a passport, travel visa, and customs or border guards to show the process:</p>&#13;
<dl>&#13;
<dt>Passport (subject authentication)</dt>&#13;
<dd>&#13;
<p>Usually you need to have a passport issued by some government agency that will offer some sort of verification as to who you are. This would be equivalent to a user account in Kubernetes. Kubernetes relies on an external authority to authenticate users; however, service accounts are a type of account that is managed directly by Kubernetes.</p>&#13;
</dd>&#13;
<dt>Visa or travel policy (authorization)</dt>&#13;
<dd>&#13;
<p>Countries will have formal agreements to accept travelers holding passports from other countries through formal short-term agreements such as visas. The visas will also outline what the visitor may do and for how long they may stay in the visiting country, depending on the specific type of visa. This would be equivalent to authorization in Kubernetes. Kubernetes has different authorization methods, but RBAC is the one used most. This allows very granular access to different API capabilities.</p>&#13;
</dd>&#13;
<dt>Border patrol or customs (admission control)</dt>&#13;
<dd>&#13;
<p>When entering a foreign country, usually there is a body of authority that will check the requisite documents, including the passport and visa, and, in many cases, inspect what is being brought into the country to ensure it abides by that country’s laws. In Kubernetes this is equivalent to admission controllers. Admission controllers can allow, deny, or change the requests into the API based upon rules and policies that are defined. Kubernetes has many built-in admission controllers such as &#13;
<span class="keep-together">PodSecurity,</span> ResourceQuota, and ServiceAccount controllers. Kubernetes also allows for dynamic controllers through the use of validating or mutating admission <span class="keep-together">controllers.</span></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>The focus of this section is the least understood and the most&#13;
avoided of these three areas: RBAC. Before we outline some of the best&#13;
practices, we first must present a primer on Kubernetes RBAC.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RBAC Primer" data-type="sect2"><div class="sect2" id="id197">&#13;
<h2>RBAC Primer</h2>&#13;
&#13;
<p>The RBAC process<a data-primary="RBAC (Role Based Access Control)" data-secondary="components of" data-type="indexterm" id="rbac-components"/><a data-primary="access control" data-secondary="RBAC" data-see="RBAC" data-type="indexterm" id="id600"/> in Kubernetes has three main components that need to be&#13;
defined: the subject, the rule, and the role binding.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Subjects" data-type="sect3"><div class="sect3" id="id32">&#13;
<h3>Subjects</h3>&#13;
&#13;
<p>The <a data-primary="subjects (RBAC)" data-type="indexterm" id="id601"/>first component is the subject, the item that is actually being checked for&#13;
access. The subject is usually a user, a service account, or a group. As&#13;
mentioned earlier, users as well as groups are handled outside of&#13;
Kubernetes by the authorization module used. We can categorize these as basic authentication, x.509 client certificates, or bearer&#13;
tokens. The most common implementations use either x.509 client&#13;
certificates or some type of bearer token using something like an OpenID&#13;
Connect system such as Azure Active Directory (Azure AD), Salesforce, or Google.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Service accounts in<a data-primary="service accounts" data-type="indexterm" id="id602"/> Kubernetes are different from user accounts in that they are namespace bound and internally stored in Kubernetes; they are meant to represent processes, not people, and are managed by native Kubernetes controllers.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Rules" data-type="sect3"><div class="sect3" id="id33">&#13;
<h3>Rules</h3>&#13;
&#13;
<p>Simply stated, <a data-primary="rules (RBAC)" data-type="indexterm" id="id603"/>this is the actual list of actions that can be performed&#13;
on a specific object (resource) or a group of objects in the API. Verbs&#13;
align to typical create, read, update, and delete (CRUD) type operations&#13;
but with some added capabilities in Kubernetes such as <code>watch</code>, <code>list</code>, and&#13;
<code>exec</code>. The objects align to the different API components and are grouped&#13;
together in categories. Pod objects, as an example, are part of the core&#13;
API and can be referenced with <code>apiGroup: ""</code>, whereas deployments are under&#13;
the app API group. This is the real power of the RBAC process and&#13;
probably what intimidates and confuses people when creating proper RBAC controls.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Roles" data-type="sect3"><div class="sect3" id="id34">&#13;
<h3>Roles</h3>&#13;
&#13;
<p>Roles allow <a data-primary="roles (RBAC)" data-type="indexterm" id="id604"/>the definition of scope of the rules defined. Kubernetes has&#13;
two types of roles, <code>role</code> and <code>clusterRole</code>, the difference being that&#13;
<code>role</code> is specific to a <span class="keep-together">namespace,</span> and <code>clusterRole</code> is a cluster-wide&#13;
role across all namespaces. An example role definition with namespace scope would be as follows:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Role</code><code class="w"/>&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pod-viewer</code><code class="w"/>&#13;
<code class="nt">rules</code><code class="p">:</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">apiGroups</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">""</code><code class="p-Indicator">]</code><code class="w"> </code><code class="c1"># "" indicates the core API group</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">resources</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"pods"</code><code class="p-Indicator">]</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">verbs</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="s">"get"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"watch"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"list"</code><code class="p-Indicator">]</code><code class="w"/></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RoleBindings" data-type="sect3"><div class="sect3" id="id35">&#13;
<h3>RoleBindings</h3>&#13;
&#13;
<p>The<a data-primary="RoleBinding objects" data-type="indexterm" id="id605"/> RoleBinding allows a mapping of a subject like a user or group to a&#13;
specific role. Bindings also have two modes: <code>roleBinding</code>, which is&#13;
specific to a namespace, and <code>clusterRoleBinding</code>, which is across the&#13;
entire cluster. Here’s an example RoleBinding with namespace <a data-primary="RBAC (Role Based Access Control)" data-secondary="components of" data-startref="rbac-components" data-type="indexterm" id="id606"/>scope:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">RoleBinding</code><code class="w"/>&#13;
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code class="w"/>&#13;
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">noc-helpdesk-view</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">default</code><code class="w"/>&#13;
<code class="nt">subjects</code><code class="p">:</code><code class="w"/>&#13;
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">User</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">helpdeskuser@example.com</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code class="w"/>&#13;
<code class="nt">roleRef</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Role</code><code class="w"> </code><code class="c1">#this must be Role or ClusterRole</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">pod-viewer</code><code class="w"> </code><code class="c1"># this must match the name of the Role or ClusterRole</code><code class="w"/>&#13;
<code class="w">                   </code><code class="c1"># to bind to</code><code class="w"/>&#13;
<code class="w">  </code><code class="nt">apiGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io</code><code class="w"/></pre>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RBAC Best Practices" data-type="sect2"><div class="sect2" id="id198">&#13;
<h2>RBAC Best Practices</h2>&#13;
&#13;
<p>RBAC is<a data-primary="RBAC (Role Based Access Control)" data-secondary="best practices" data-type="indexterm" id="rbac-best-practice"/><a data-primary="best practices" data-secondary="RBAC (Role Based Access Control)" data-type="indexterm" id="best-practice-rbac"/> a critical component of running a secure, dependable, and stable Kubernetes environment. The concepts underlying RBAC can be complex; however, adhering to a few best practices can ease some of the major stumbling blocks:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Applications that are developed to run in Kubernetes rarely ever need an RBAC role and RoleBinding associated to them. Only if the application code interacts directly with the Kubernetes API does the application require RBAC &#13;
<span class="keep-together">configuration.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>If the application does need to directly access the Kubernetes API to&#13;
perhaps change configuration depending on endpoints being added to a&#13;
service, or if it needs to list all the pods in a specific namespace, the&#13;
best practice is to create a new service account that is then specified&#13;
in the pod specification. Then, create a role that has the least amount of&#13;
privileges needed to accomplish its goal.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use an OpenID Connect service that enables identity management and, if&#13;
needed, two-factor authentication. This will allow for a higher level of&#13;
identity authentication. Map user groups to roles that have the least&#13;
amount of privileges needed to accomplish the job.</p>&#13;
</li>&#13;
<li>&#13;
<p>Along with the aforementioned practice, you should use Just in Time (JIT) access systems to allow site reliability engineers (SREs), operators, and those who might need to have escalated&#13;
privileges for a short period of time to accomplish a very specific task. Alternatively, these users should have different&#13;
identities that are more heavily audited for sign-on, and those accounts should&#13;
have more elevated privileges assigned by the user account or group&#13;
bound to a role.</p>&#13;
</li>&#13;
<li>&#13;
<p>Specific service accounts should be used for CI/CD tools that deploy&#13;
into your Kubernetes clusters. This ensures auditability within the&#13;
cluster and an understanding of who might have deployed or deleted any objects in a&#13;
cluster.</p>&#13;
</li>&#13;
<li>&#13;
<p>If you’re still using Helm v2 to deploy applications, the default service account is Tiller, deployed to <code>kube-system</code>. It is better to deploy Tiller into each namespace with a service account specifically for Tiller that is scoped for that namespace. In the CI/CD tool that calls the Helm install/upgrade command, as a prestep, initialize the Helm client with the service account and the specific namespace for the Deployment. The service account name can be the same for each namespace, but the namespace should be specific. It is advised to move to Helm v3 because one of its core principles is that Tiller is no longer needed to run in a cluster. The new architecture is completely client based and uses the RBAC access of the user calling the Helm commands. This is in alignment with the preferred approach of client-based tooling to the Kubernetes API.</p>&#13;
</li>&#13;
<li>&#13;
<p>Limit any applications that require <code>watch</code> and <code>list</code> on the Secrets&#13;
API. This basically allows the application or the person who deployed&#13;
the pod to view the secrets in that namespace. If an application needs&#13;
to access the Secrets API for specific secrets, limit using <code>get</code> on any&#13;
specific secrets that the application needs to read outside of those&#13;
that it is directly <a data-primary="RBAC (Role Based Access Control)" data-secondary="best practices" data-startref="rbac-best-practice" data-type="indexterm" id="id607"/><a data-primary="best practices" data-secondary="RBAC (Role Based Access Control)" data-startref="best-practice-rbac" data-type="indexterm" id="id608"/>assigned.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id351">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Principles for developing applications for cloud native delivery is a&#13;
topic for another day, but it is universally accepted that strict&#13;
separation of configuration from code is a key principle for success. With native objects for nonsensitive data, the ConfigMap API, and for&#13;
sensitive data, the Secrets API, Kubernetes can now manage this process in a&#13;
declarative approach. As more and more critical data is represented and&#13;
stored natively in the Kubernetes API, it is critical to secure access&#13;
to those APIs through proper gated security processes such as RBAC and&#13;
integrated authentication systems.</p>&#13;
&#13;
<p>As you’ll see throughout the rest of this book, these principles permeate&#13;
every aspect of the proper deployment of services into a Kubernetes&#13;
platform to build a stable, reliable, secure, and robust system.</p>&#13;
</div></section>&#13;
</div></section></body></html>