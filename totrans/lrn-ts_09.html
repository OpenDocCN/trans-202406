<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Interfaces"><div class="chapter" id="interfaces">
<h1><span class="label">Chapter 7. </span>Interfaces</h1>

<blockquote>
<p>Why only use the</p>

<p>Boring built-in type shapes when</p>

<p>We can make our own!</p></blockquote>

<p>I <a data-type="indexterm" data-primary="types" data-secondary="objects" data-tertiary="interfaces" data-see="interfaces" id="idm45584685187792"/><a data-type="indexterm" data-primary="objects" data-secondary="interfaces" data-see="interfaces" id="idm45584685186240"/>mentioned back in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch04.xhtml#objects">Chapter 4, “Objects”</a> that although type aliases for <code>{ ... }</code> object types are a way to describe object shapes, TypeScript also includes an “interface” feature many developers prefer.
Interfaces are another way to declare an object shape with an associated name.
Interfaces are in many ways similar to aliased object types but are generally preferred for their more readable error messages, speedier compiler performance, and better interoperability with classes.</p>






<section data-type="sect1" data-pdf-bookmark="Type Aliases Versus Interfaces"><div class="sect1" id="idm45584685183120">
<h1>Type Aliases Versus Interfaces</h1>

<p>Here is<a data-type="indexterm" data-primary="type aliases" data-secondary="interfaces vs." id="type-alias-interface"/><a data-type="indexterm" data-primary="interfaces" data-secondary="type aliases vs." id="interface-typealias"/> a quick recap of the syntax for how an aliased object type would describe an object with a <code>born: number</code> and <code>name: string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">Poet</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">born</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">};</code></pre>

<p>Here is the equivalent syntax for an interface:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Poet</code> <code class="p">{</code>
  <code class="nx">born</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>The two syntaxes are almost identical.</p>
<div data-type="tip"><h6>Tip</h6>
<p>TypeScript developers who prefer semicolons generally put them after type aliases and not after interfaces.
This preference mirrors the difference between declaring a variable with a <code>;</code> versus declaring a class or function without.</p>
</div>

<p>TypeScript’s assignability checking and error messages for interfaces also work and look just about the same as they do for object types.
The following assignability errors for assigning to the <code>valueLater</code> variable would be roughly the same if <code>Poet</code> was an interface or type alias:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">valueLater</code>: <code class="nx">Poet</code><code class="p">;</code>

<code class="c1">// Ok</code>
<code class="nx">valueLater</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">born</code>: <code class="nx">1935</code><code class="p">,</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Sara Teasdale'</code><code class="p">,</code>
<code class="p">};</code>

<code class="nx">valueLater</code> <code class="o">=</code> <code class="s2">"Emily Dickinson"</code><code class="p">;</code>
<code class="c1">// Error: Type 'string' is not assignable to 'Poet'.</code>

<code class="nx">valueLater</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">born</code>: <code class="nx">true</code><code class="p">,</code>
  <code class="c1">// Error: Type 'boolean' is not assignable to type 'number'.</code>
  <code class="nx">name</code><code class="o">:</code> <code class="s1">'Sappho'</code>
<code class="p">};</code></pre>

<p>However, there are a few key differences between interfaces and type aliases:</p>

<ul>
<li>
<p>As you’ll see later in this chapter, interfaces can “merge” together to be augmented—a feature particularly useful when working with third-party code such as built-in globals or npm packages.</p>
</li>
<li>
<p>As you’ll see in the next chapter, <a data-type="xref" data-xrefstyle="chap-num-title" href="ch08.xhtml#classes">Chapter 8, “Classes”</a>, interfaces can be used to type check the structure of class declarations while type aliases cannot.</p>
</li>
<li>
<p>Interfaces are generally speedier for the TypeScript type checker to work with: they declare a named type that can be cached more easily internally, rather than a dynamic copy-and-paste of a new object literal the way type aliases do.</p>
</li>
<li>
<p>Because interfaces are considered named objects rather than an alias for an unnamed object literal, their error messages are more likely to be readable in hard edge cases.</p>
</li>
</ul>

<p>For the latter two reasons and to maintain consistency, the rest of this book and its associated projects default to using interfaces over aliased object shapes.
I generally recommend using interfaces whenever possible (i.e., until you need features such as union types from type<a data-type="indexterm" data-primary="type aliases" data-secondary="interfaces vs." data-startref="type-alias-interface" id="idm45584685065232"/><a data-type="indexterm" data-primary="interfaces" data-secondary="type aliases vs." data-startref="interface-typealias" id="idm45584685063984"/> aliases).</p>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Types of Properties"><div class="sect1" id="idm45584685182496">
<h1>Types of Properties</h1>

<p>JavaScript objects can be wild and wacky in real-world usage, including getters and setters, properties that only sometimes exist, or accepting any arbitrary property names.
TypeScript provides a set of type system tools for interfaces to help us model that wackiness.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Because interfaces and type aliases behave so similarly, the following types of properties introduced in this chapter are all also usable with aliased object types.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Optional Properties"><div class="sect2" id="idm45584685032864">
<h2>Optional Properties</h2>

<p>As with<a data-type="indexterm" data-primary="interfaces" data-secondary="properties" data-tertiary="optional" id="idm45584685031184"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="optional" data-secondary-sortas="interfaces" id="idm45584685029904"/><a data-type="indexterm" data-primary="optional properties" data-secondary="of interfaces" data-secondary-sortas="interfaces" id="idm45584685028416"/> object types, interface properties don’t all have to be required in the object.
You can indicate an interface’s property is optional by including a <code>?</code> before the <code>:</code> in its type annotation.</p>

<p>This <code>Book</code> interface requires only a <code>required</code> property and optionally allows an <code>optional</code>.
Objects adhering to it may provide <code>optional</code> or leave it out as long as they provide <code>required</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Book</code> <code class="p">{</code>
  <code class="nx">author?</code>: <code class="nx">string</code><code class="p">;</code>
  <code class="nx">pages</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">};</code>

<code class="c1">// Ok</code>
<code class="kr">const</code> <code class="nx">ok</code>: <code class="nx">Book</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="s2">"Rita Dove"</code><code class="p">,</code>
    <code class="nx">pages</code>: <code class="nx">80</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">missing</code>: <code class="nx">Book</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">pages</code>: <code class="nx">80</code>
<code class="p">};</code>
<code class="c1">// Error: Property 'author' is missing in type</code>
<code class="c1">// '{ pages: number; }' but required in type 'Book'.</code></pre>

<p>The same caveats around the difference between optional properties and properties whose type happens to include <code>undefined</code> in a type union apply to interfaces as well as object types.
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a> will describe TypeScript’s strictness settings around optional properties.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Read-Only Properties"><div class="sect2" id="idm45584685014208">
<h2>Read-Only Properties</h2>

<p>You <a data-type="indexterm" data-primary="interfaces" data-secondary="properties" data-tertiary="read-only" id="interface-property-read-only"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="read-only" data-secondary-sortas="interfaces" id="property-interface-read-only"/><a data-type="indexterm" data-primary="read-only properties" data-secondary="of interfaces" data-secondary-sortas="interfaces" id="read-only-interface"/>may sometimes wish to block users of your interface from reassigning properties of objects adhering to an interface.
TypeScript allows you to add a <code>readonly</code> modifier before a property name to indicate that once set, that property should not be set to a different value.
These <code>readonly</code> properties can be read from normally, but not reassigned to anything new.</p>

<p>For example, the <code>text</code> property in the below <code>Page</code> interface gives back a <code>string</code> when accessed, but causes a type error if assigned a new value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Page</code> <code class="p">{</code>
    <code class="nx">readonly</code> <code class="nx">text</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">read</code><code class="p">(</code><code class="nx">page</code>: <code class="nx">Page</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Ok: reading the text property doesn't attempt to modify it</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">page</code><code class="p">.</code><code class="nx">text</code><code class="p">);</code>

    <code class="nx">page</code><code class="p">.</code><code class="nx">text</code> <code class="o">+=</code> <code class="s2">"!"</code><code class="p">;</code>
    <code class="c1">//   ~~~~</code>
    <code class="c1">// Error: Cannot assign to 'text'</code>
    <code class="c1">// because it is a read-only property.</code>
<code class="p">}</code></pre>

<p>Note that <code>readonly</code> modifiers exist only in the type system, and only apply to the usage of that interface.
It won’t apply to an object unless that object is used in a location that declares it to be of that interface.</p>

<p>In this continuation of the <code>exclaim</code> example, the <code>text</code> property is allowed to be modified outside of the function because its parent object isn’t explicitly used as a <code>Text</code> until inside the function.
<code>pageIsh</code> is allowed to be used as a <code>Page</code> because a writable property is assignable to a <code>readonly</code> property (mutable properties can be read from, which is all a <code>readonly</code> property needs):</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">pageIsh</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">text</code><code class="o">:</code> <code class="s2">"Hello, world!"</code><code class="p">,</code>
<code class="p">};</code>

<code class="c1">// Ok: messengerIsh is an inferred object type with text, not a Page</code>
<code class="nx">page</code><code class="p">.</code><code class="nx">text</code> <code class="o">+=</code> <code class="s2">"!"</code><code class="p">;</code>

<code class="c1">// Ok: read takes in Page, which happens to</code>
<code class="c1">// be a more specific version of pageIsh's type</code>
<code class="nx">read</code><code class="p">(</code><code class="nx">messengerIsh</code><code class="p">);</code></pre>

<p>Declaring the variable <code>pageIsh</code> with the explicit type annotation <code>: Page</code> would have indicated to TypeScript that its <code>text</code> property was <code>readonly</code>.
Its inferred type, however, was not <code>readonly</code>.</p>

<p>Read-only interface members are a handy way to make sure areas of code don’t unexpectedly modify objects they’re not meant to.
However, remember that they’re a type system construct only and don’t exist in the compiled JavaScript output code.
They only protect from modification during development with the<a data-type="indexterm" data-primary="interfaces" data-secondary="properties" data-tertiary="read-only" data-startref="interface-property-read-only" id="idm45584684820784"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="read-only" data-secondary-sortas="interfaces" data-startref="property-interface-read-only" id="idm45584684851664"/><a data-type="indexterm" data-primary="read-only properties" data-secondary="of interfaces" data-secondary-sortas="interfaces" data-startref="read-only-interface" id="idm45584684849936"/> TypeScript type checker.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Functions and Methods"><div class="sect2" id="idm45584684848192">
<h2>Functions and Methods</h2>

<p>It’s <a data-type="indexterm" data-primary="interfaces" data-secondary="functions in, declaring" id="interface-function"/><a data-type="indexterm" data-primary="functions" data-secondary="in interfaces" data-tertiary="declaring" data-secondary-sortas="interfaces" id="functions-interface"/><a data-type="indexterm" data-primary="declaring" data-secondary="functions" data-tertiary="in interfaces" data-tertiary-sortas="interfaces" id="declare-function-interface"/><a data-type="indexterm" data-primary="methods" data-secondary="of interfaces" data-tertiary="function declarations" data-secondary-sortas="interfaces" id="method-interface-function"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="as functions" data-secondary-sortas="interfaces" data-tertiary-sortas="functions" id="property-interface-function"/>very common in JavaScript for object members to be functions.
TypeScript therefore allows declaring interface members as being the function types previously covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch05.xhtml#functions">Chapter 5, “Functions”</a>.</p>

<p>TypeScript provides two ways of declaring interface members as functions:</p>

<ul>
<li>
<p><em>Method</em> syntax: declaring that a member of the interface is a function intended to be called as a member of the object, like <code>member(): void</code></p>
</li>
<li>
<p><em>Property</em> syntax: declaring that a member of the interface is equal to a standalone function, like <code>member: () =&gt; void</code></p>
</li>
</ul>

<p>The two declaration forms are an analog for the two ways you can declare a JavaScript object as having a function.</p>

<p>Both <code>method</code> and <code>property</code> members shown here are functions that may be called with no parameters and return a <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">HasBothFunctionTypes</code> <code class="p">{</code>
  <code class="nx">property</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
  <code class="nx">method</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">hasBoth</code>: <code class="nx">HasBothFunctionTypes</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">property</code><code class="o">:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="s2">""</code><code class="p">,</code>
  <code class="nx">method() {</code>
    <code class="k">return</code> <code class="s2">""</code><code class="p">;</code>
  <code class="p">}</code>
<code class="p">};</code>

<code class="nx">hasBoth</code><code class="p">.</code><code class="nx">property</code><code class="p">();</code> <code class="c1">// Ok</code>
<code class="nx">hasBoth</code><code class="p">.</code><code class="nx">method</code><code class="p">();</code> <code class="c1">// Ok</code></pre>

<p>Both forms can receive the <code>?</code> optional modifier to indicate they don’t need to be provided:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">OptionalReadonlyFunctions</code> <code class="p">{</code>
  <code class="nx">optionalProperty</code><code class="o">?:</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
  <code class="nx">optionalMethod</code><code class="o">?</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Method and property declarations can mostly be used interchangeably.
The main differences between them that I’ll cover in this book are:</p>

<ul>
<li>
<p>Methods cannot be declared as <code>readonly</code>; properties can.</p>
</li>
<li>
<p>Interface merging (covered later in this chapter) treats them differently.</p>
</li>
<li>
<p>Some of the operations performed on types covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch15.xhtml#type_operations">Chapter 15, “Type Operations”</a> treat them differently.</p>
</li>
</ul>

<p>Future versions of TypeScript may add the option to be more strict about the differences between methods and property functions.</p>

<p>For now, the general style guide I recommend is:</p>

<ul>
<li>
<p>Use a method function if you know the underlying function may refer to <code>this</code>, most commonly for instances of classes (covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch08.xhtml#classes">Chapter 8, “Classes”</a>).</p>
</li>
<li>
<p>Use a property function otherwise.</p>
</li>
</ul>

<p>Don’t sweat it if you mix up these two, or don’t understand the difference.
It’ll rarely impact your code unless you’re being intentional about <code>this</code> scoping and which form you <a data-type="indexterm" data-primary="interfaces" data-secondary="functions in, declaring" data-startref="interface-function" id="idm45584684696208"/><a data-type="indexterm" data-primary="functions" data-secondary="in interfaces" data-tertiary="declaring" data-secondary-sortas="interfaces" data-startref="functions-interface" id="idm45584684694960"/><a data-type="indexterm" data-primary="declaring" data-secondary="functions" data-tertiary="in interfaces" data-tertiary-sortas="interfaces" data-startref="declare-function-interface" id="idm45584684693200"/><a data-type="indexterm" data-primary="methods" data-secondary="of interfaces" data-tertiary="function declarations" data-secondary-sortas="interfaces" data-startref="method-interface-function" id="idm45584684691472"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="as functions" data-secondary-sortas="interfaces" data-tertiary-sortas="functions" data-startref="property-interface-function" id="idm45584684689696"/>choose.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Call Signatures"><div class="sect2" id="idm45584684847600">
<h2>Call Signatures</h2>

<p>Interfaces <a data-type="indexterm" data-primary="interfaces" data-secondary="call signatures" id="idm45584684685872"/><a data-type="indexterm" data-primary="call signatures in interfaces" id="idm45584684684864"/>and object types can declare <em>call signatures</em>, which is a type system description of how a value may be called like a function.
Only values that may be called in the way the call signature declares will be assignable to the interface—i.e., a function with assignable parameters and return type.
A call signature looks similar to a function type, but with a <code>:</code> colon instead of an <code>=&gt;</code> arrow.</p>

<p>The following <code>FunctionAlias</code> and <code>CallSignature</code> types both describe the same function parameters and return type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">type</code> <code class="nx">FunctionAlias</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">number</code><code class="p">;</code>

<code class="kr">interface</code> <code class="nx">CallSignature</code> <code class="p">{</code>
  <code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Type: (input: string) =&gt; number</code>
<code class="kr">const</code> <code class="nx">typedFunctionAlias</code>: <code class="nx">FunctionAlias</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="c1">// Type: (input: string) =&gt; number</code>
<code class="kr">const</code> <code class="nx">typedCallSignature</code>: <code class="nx">CallSignature</code> <code class="o">=</code> <code class="p">(</code><code class="nx">input</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">input</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// Ok</code></pre>

<p>Call signatures can be used to describe functions that additionally have some user-defined property on them.
TypeScript will recognize a property added to a function declaration as adding to that function declaration’s type.</p>

<p>The following <code>keepsTrackOfCalls</code> function declaration is given a <code>count</code> property of type <code>number</code>, making it assignable to the <code>FunctionWithCount</code> interface.
It can therefore be assigned to the <code>hasCallCount</code> argument of type <code>FunctionWithCount</code>.
The function at the end of the snippet was not given a <code>count</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">FunctionWithCount</code> <code class="p">{</code>
  <code class="nx">count</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="p">()</code><code class="o">:</code> <code class="k">void</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">hasCallCount</code>: <code class="nx">FunctionWithCount</code><code class="p">;</code>

<code class="kd">function</code> <code class="nx">keepsTrackOfCalls() {</code>
  <code class="nx">keepsTrackOfCalls</code><code class="p">.</code><code class="nx">count</code> <code class="o">+=</code> <code class="mi">1</code><code class="p">;</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`I've been called </code><code class="si">${</code><code class="nx">keepsTrackOfCalls</code><code class="p">.</code><code class="nx">count</code><code class="si">}</code><code class="sb"> times!`</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">keepsTrackOfCalls</code><code class="p">.</code><code class="nx">count</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>

<code class="nx">hasCallCount</code> <code class="o">=</code> <code class="nx">keepsTrackOfCalls</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="kd">function</code> <code class="nx">doesNotHaveCount() {</code>
  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"No idea!"</code><code class="p">);</code>
<code class="p">}</code>

<code class="nx">hasCallCount</code> <code class="o">=</code> <code class="nx">doesNotHaveCount</code><code class="p">;</code>
<code class="c1">// Error: Property 'count' is missing in type</code>
<code class="c1">// '() =&gt; void' but required in type 'FunctionWithCalls'</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Index Signatures"><div class="sect2" id="idm45584684459904">
<h2>Index Signatures</h2>

<p>Some <a data-type="indexterm" data-primary="interfaces" data-secondary="index signatures" data-tertiary="purpose of" id="interface-index-sig-purpose"/><a data-type="indexterm" data-primary="index signatures in interfaces" data-secondary="purpose of" id="index-sig-interface-purpose"/>JavaScript projects create objects meant to store values under any arbitrary <code>string</code> key.
For these “container” objects, declaring an interface with a field for every possible key would be impractical or impossible.</p>

<p>TypeScript provides a syntax called an <em>index signature</em> to indicate that an interface’s objects are allowed to take in any key and give back a certain type under that key.
They’re most commonly used with string keys because JavaScript object property lookups convert keys to strings implicitly.
An index signature looks like a regular property definition but with a type after the key, and array brackets surrounding them, like <code>{ [i: string]: ... }</code>.</p>

<p>This <code>WordCounts</code> interface is declared as allowing any <code>string</code> key with a <code>number</code> value.
Objects of that type aren’t bound to receiving any particular key—as long as the value is a <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">WordCounts</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">i</code>: <code class="nx">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">counts</code>: <code class="nx">WordCounts</code> <code class="o">=</code> <code class="p">{};</code>

<code class="nx">counts</code><code class="p">.</code><code class="nx">apple</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="nx">counts</code><code class="p">.</code><code class="nx">banana</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">counts</code><code class="p">.</code><code class="nx">cherry</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
<code class="c1">// Error: Type 'boolean' is not assignable to type 'number'.</code></pre>

<p>Index signatures are convenient for assigning values to an object but aren’t completely type safe.
They indicate that an object should give back a value no matter what property is being accessed.</p>

<p>This <code>publishDates</code> value safely gives back <code>Frankenstein</code> as a <code>Date</code> but tricks TypeScript into thinking its <code>Beloved</code> is defined even though it’s <code>undefined</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">DatesByName</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">i</code>: <code class="nx">string</code><code class="p">]</code><code class="o">:</code> <code class="nb">Date</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">publishDates</code>: <code class="nx">DatesByName</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">Frankenstein</code>: <code class="nx">new</code> <code class="nb">Date</code><code class="p">(</code><code class="s2">"1 January 1818"</code><code class="p">),</code>
<code class="p">};</code>

<code class="nx">publishDates</code><code class="p">.</code><code class="nx">Frankenstein</code><code class="p">;</code> <code class="c1">// Type: Date</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">publishDates</code><code class="p">.</code><code class="nx">Frankenstein</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code> <code class="c1">// Ok</code>

<code class="nx">publishDates</code><code class="p">.</code><code class="nx">Beloved</code><code class="p">;</code> <code class="c1">// Type: Date, but runtime value of undefined!</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">publishDates</code><code class="p">.</code><code class="nx">Beloved</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code> <code class="c1">// Ok in the type system, but...</code>
<code class="c1">// Runtime error: Cannot read property 'toString'</code>
<code class="c1">// of undefined (reading publishDates.Beloved)</code></pre>

<p>When possible, if you’re looking to store key-value pairs and the keys aren’t known ahead of time, it is generally safer to use a <code>Map</code>.
Its <code>.get</code> method always returns a type with <code>| undefined</code> to indicate that the key might not exist.
<a data-type="xref" data-xrefstyle="chap-num-title" href="ch09.xhtml#type_modifiers_chapter">Chapter 9, “Type Modifiers”</a> will discuss working with generic container classes<a data-type="indexterm" data-primary="interfaces" data-secondary="index signatures" data-tertiary="purpose of" data-startref="interface-index-sig-purpose" id="idm45584684341136"/><a data-type="indexterm" data-primary="index signatures in interfaces" data-secondary="purpose of" data-startref="index-sig-interface-purpose" id="idm45584684339648"/> such as <code>Map</code> and <code>Set</code>.</p>










<section data-type="sect3" data-pdf-bookmark="Mixing properties and index signatures"><div class="sect3" id="idm45584684337504">
<h3>Mixing properties and index signatures</h3>

<p>Interfaces<a data-type="indexterm" data-primary="interfaces" data-secondary="index signatures" data-tertiary="properties and" id="interface-index-sig-property"/><a data-type="indexterm" data-primary="index signatures in interfaces" data-secondary="properties and" id="index-sig-interface-property"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="index signatures and" data-secondary-sortas="interfaces" id="property-interface-index-sig"/> are able to include explicitly named properties and catchall <code>string</code> index signatures, with one catch: each named property’s type must be assignable to its catchall index signature’s type.
You can think of mixing them as telling TypeScript that named properties give a more specific type, and any other property falls back to the index signature’s type.</p>

<p>Here, <code>HistoricalNovels</code> declares that all properties are type <code>number</code>, and additionally the <code>Oroonoko</code> property must exist to begin with:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">HistoricalNovels</code> <code class="p">{</code>
  <code class="nx">Oroonoko</code>: <code class="nx">number</code><code class="p">;</code>
  <code class="p">[</code><code class="nx">i</code>: <code class="nx">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Ok</code>
<code class="kr">const</code> <code class="nx">novels</code>: <code class="nx">HistoricalNovels</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">Outlander</code>: <code class="nx">1991</code><code class="p">,</code>
  <code class="nx">Oroonoko</code>: <code class="nx">1688</code><code class="p">,</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">missingOroonoko</code>: <code class="nx">HistoricalNovels</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">Outlander</code>: <code class="nx">1991</code><code class="p">,</code>
<code class="p">};</code>
<code class="c1">// Error: Property 'Oroonoko' is missing in type</code>
<code class="c1">// '{ Outlander: number; }' but required in type 'HistoricalNovels'.</code></pre>

<p>One common type system trick with mixed properties and index signatures is to use a more specific property type literal for the named property than an index signature’s primitive.
As long as the named property’s type is assignable to the index signature’s—which is true for a literal and a primitive, respectively—TypeScript will allow it.</p>

<p>Here, <code>ChapterStarts</code> declares that a property under <code>preface</code> must be <code>0</code> and all other properties have the more general <code>number</code>.
That means any object adhering to <code>ChapterStarts</code> must have a <code>preface</code> property <a data-type="indexterm" data-primary="interfaces" data-secondary="index signatures" data-tertiary="properties and" data-startref="interface-index-sig-property" id="idm45584684268944"/><a data-type="indexterm" data-primary="index signatures in interfaces" data-secondary="properties and" data-startref="index-sig-interface-property" id="idm45584684248240"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="index signatures and" data-secondary-sortas="interfaces" data-startref="property-interface-index-sig" id="idm45584684247056"/>equal to <code>0</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">ChapterStarts</code> <code class="p">{</code>
  <code class="nx">preface</code>: <code class="nx">0</code><code class="p">;</code>
  <code class="p">[</code><code class="nx">i</code>: <code class="nx">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">const</code> <code class="nx">correctPreface</code>: <code class="nx">ChapterStarts</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">preface</code>: <code class="nx">0</code><code class="p">,</code>
  <code class="nx">night</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="nx">shopping</code>: <code class="nx">5</code>
<code class="p">};</code>

<code class="kr">const</code> <code class="nx">wrongPreface</code>: <code class="nx">ChapterStarts</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">preface</code>: <code class="nx">1</code><code class="p">,</code>
  <code class="c1">// Error: Type '1' is not assignable to type '0'.</code>
<code class="p">};</code></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Numeric index signatures"><div class="sect3" id="idm45584684140896">
<h3>Numeric index signatures</h3>

<p>Although <a data-type="indexterm" data-primary="interfaces" data-secondary="index signatures" data-tertiary="numeric" id="idm45584684131808"/><a data-type="indexterm" data-primary="index signatures in interfaces" data-secondary="numeric" id="idm45584684130592"/><a data-type="indexterm" data-primary="numeric index signatures" id="idm45584684129680"/>JavaScript implicitly converts object property lookup keys to strings, it is sometimes desirable to only allow numbers as keys for an object.
TypeScript index signatures can use a <code>number</code> type instead of <code>string</code> but with the same catch as named properties that their types must be assignable to the catchall <code>string</code> index signature’s.</p>

<p>The following <code>MoreNarrowNumbers</code> interface would be allowed because <code>string</code> is assignable to <code>string | undefined</code>, but <code>MoreNarrowStrings</code> would not because <code>string | undefined</code> is not assignable to <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Ok</code>
<code class="kr">interface</code> <code class="nx">MoreNarrowNumbers</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">i</code>: <code class="nx">number</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
  <code class="p">[</code><code class="nx">i</code>: <code class="nx">string</code><code class="p">]</code><code class="o">:</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">undefined</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Ok</code>
<code class="kr">const</code> <code class="nx">mixesNumbersAndStrings</code>: <code class="nx">MoreNarrowNumbers</code> <code class="o">=</code> <code class="p">{</code>
  <code class="mi">0</code><code class="o">:</code> <code class="s1">''</code><code class="p">,</code>
  <code class="nx">key1</code><code class="o">:</code> <code class="s1">''</code><code class="p">,</code>
  <code class="nx">key2</code>: <code class="nx">undefined</code><code class="p">,</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">MoreNarrowStrings</code> <code class="p">{</code>
  <code class="p">[</code><code class="nx">i</code>: <code class="nx">number</code><code class="p">]</code><code class="o">:</code> <code class="nx">string</code><code class="o"> | </code><code class="nx">undefined</code><code class="p">;</code>
  <code class="c1">// Error: 'number' index type 'string | undefined'</code>
  <code class="c1">// is not assignable to 'string' index type 'string'.</code>
  <code class="p">[</code><code class="nx">i</code>: <code class="nx">string</code><code class="p">]</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code></pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Nested Interfaces"><div class="sect2" id="idm45584684459312">
<h2>Nested Interfaces</h2>

<p>Just <a data-type="indexterm" data-primary="interfaces" data-secondary="nested" id="idm45584684050528"/><a data-type="indexterm" data-primary="nested interfaces" id="idm45584684086624"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="nested" data-secondary-sortas="interfaces" id="idm45584684085952"/>like object types can be nested as properties of other object types, interface types can also have properties that are themselves interface types (or object types).</p>

<p>This <code>Novel</code> interface contains an <code>author</code> property that must satisfy an inline object type and a <code>setting</code> property that must satisfy the <code>Setting</code> interface:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Novel</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="p">};</code>
    <code class="nx">setting</code>: <code class="nx">Setting</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">Setting</code> <code class="p">{</code>
    <code class="nx">place</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">year</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">myNovel</code>: <code class="nx">Novel</code><code class="p">;</code>

<code class="c1">// Ok</code>
<code class="nx">myNovel</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">name</code><code class="o">:</code> <code class="s1">'Jane Austen'</code><code class="p">,</code>
    <code class="p">},</code>
    <code class="nx">setting</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">place</code><code class="o">:</code> <code class="s1">'England'</code><code class="p">,</code>
        <code class="nx">year</code>: <code class="nx">1812</code><code class="p">,</code>
    <code class="p">}</code>
<code class="p">};</code>

<code class="nx">myNovel</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">name</code><code class="o">:</code> <code class="s1">'Emily Brontë'</code><code class="p">,</code>
    <code class="p">},</code>
    <code class="nx">setting</code><code class="o">:</code> <code class="p">{</code>
        <code class="nx">place</code><code class="o">:</code> <code class="s1">'West Yorkshire'</code><code class="p">,</code>
    <code class="p">},</code>
    <code class="c1">// Error: Property 'year' is missing in type</code>
    <code class="c1">// '{ place: string; }' but required in type 'Setting'.</code>
<code class="p">};</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Interface Extensions"><div class="sect1" id="idm45584685062208">
<h1>Interface Extensions</h1>

<p>Sometimes<a data-type="indexterm" data-primary="interfaces" data-secondary="extensions" data-tertiary="purpose of" id="interface-extend-purpose"/><a data-type="indexterm" data-primary="extending" data-secondary="interfaces" data-tertiary="purpose of" id="extend-interface-purpose"/> you may end up with multiple interfaces that look similar to each other.
One interface may contain all the same members of another interface, with a few extras added on.</p>

<p>TypeScript allows an interface to <em>extend</em> another interface, which declares it as copying all the members of another.
An interface may be marked as extending another interface by adding the <code>extends</code> keyword after its name (the “derived” interface), followed by the name of the interface to extend (the “base” interface).
Doing so indicates to TypeScript that all objects adhering to the derived interface must also have all the members of the base interface.</p>

<p>In the following example, the <code>Novella</code> interface extends from <code>Writing</code> and thus requires objects to have at least both <code>Novella</code>’s <code>pages</code> and <code>Writing</code>’s <code>title</code> members:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Writing</code> <code class="p">{</code>
    <code class="nx">title</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">Novella</code> <code class="kr">extends</code> <code class="nx">Writing</code> <code class="p">{</code>
    <code class="nx">pages</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Ok</code>
<code class="kd">let</code> <code class="nx">myNovella</code>: <code class="nx">Novella</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">pages</code>: <code class="nx">195</code><code class="p">,</code>
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"Ethan Frome"</code><code class="p">,</code>
<code class="p">};</code>

<code class="kd">let</code> <code class="nx">missingPages</code>: <code class="nx">Novella</code> <code class="o">=</code> <code class="p">{</code>
 <code class="c1">// ~~~~~~~~~~~~</code>
 <code class="c1">// Error: Property 'pages' is missing in type</code>
 <code class="c1">// '{ title: string; }' but required in type 'Novella'.</code>
    <code class="nx">title</code><code class="o">:</code> <code class="s2">"The Awakening"</code><code class="p">,</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">extraProperty</code>: <code class="nx">Novella</code> <code class="o">=</code> <code class="p">{</code>
 <code class="c1">// ~~~~~~~~~~~~~</code>
 <code class="c1">// Error: Type '{ genre: string; name: string; strategy: string; }'</code>
 <code class="c1">// is not assignable to type 'Novella'.</code>
 <code class="c1">//   Object literal may only specify known properties,</code>
 <code class="c1">//   and 'genre' does not exist in type 'Novella'.</code>
    <code class="nx">pages</code>: <code class="nx">300</code><code class="p">,</code>
    <code class="nx">strategy</code><code class="o">:</code> <code class="s2">"baseline"</code><code class="p">,</code>
    <code class="nx">style</code><code class="o">:</code> <code class="s2">"Naturalism"</code>
<code class="p">};</code></pre>

<p>Interface extensions are a nifty way to represent that one type of entity in your project is a superset (it includes all the members of) another entity.
They allow you to avoid having to type out the same code repeatedly across multiple interfaces to represent that<a data-type="indexterm" data-primary="interfaces" data-secondary="extensions" data-tertiary="purpose of" data-startref="interface-extend-purpose" id="idm45584683831072"/><a data-type="indexterm" data-primary="extending" data-secondary="interfaces" data-tertiary="purpose of" data-startref="extend-interface-purpose" id="idm45584683798320"/> relationship.</p>








<section data-type="sect2" data-pdf-bookmark="Overridden Properties"><div class="sect2" id="idm45584683796608">
<h2>Overridden Properties</h2>

<p>Derived interfaces<a data-type="indexterm" data-primary="interfaces" data-secondary="extensions" data-tertiary="overridden properties of" id="idm45584683795040"/><a data-type="indexterm" data-primary="extending" data-secondary="interfaces" data-tertiary="overridden properties of" id="idm45584683793792"/><a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="overridden" data-secondary-sortas="interfaces" id="idm45584683764752"/><a data-type="indexterm" data-primary="overriding" data-secondary="interface properties" id="idm45584683763424"/><a data-type="indexterm" data-primary="derived interfaces, overridden properties of" id="idm45584683762576"/> may <em>override</em>, or replace, properties from their base interface by declaring the property again with a different type.
TypeScript’s type checker will enforce that an overridden property must be assignable to its base property.
It does so to ensure that instances of the derived interface type stay assignable to the base interface type.</p>

<p>Most derived interfaces that redeclare properties do so either to make those properties a more specific subset of a type union or to make the properties a type that extends from the base interface’s type.</p>

<p>For example, this <code>WithNullableName</code> type is properly made non-nullable in 
<span class="keep-together"><code>WithNonNullableName</code></span>.
<code>WithNumericName</code>, however, is not allowed as <code>number | string</code> and is not assignable to <code>string | null</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">WithNullableName</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code> <code class="o">|</code> <code class="kc">null</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">WithNonNullableName</code> <code class="kr">extends</code> <code class="nx">WithNullableName</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">WithNumericName</code> <code class="kr">extends</code> <code class="nx">WithNullableName</code> <code class="p">{</code>
    <code class="nx">name</code>: <code class="nx">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>
<code class="c1">// Error: Interface 'WithNumericName' incorrectly</code>
<code class="c1">// extends interface 'WithNullableName'.</code>
<code class="c1">//   Types of property 'name' are incompatible.</code>
<code class="c1">//     Type 'string | number' is not assignable to type 'string | null'.</code>
<code class="c1">//       Type 'number' is not assignable to type 'string'.</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Extending Multiple Interfaces"><div class="sect2" id="idm45584683686736">
<h2>Extending Multiple Interfaces</h2>

<p>Interfaces<a data-type="indexterm" data-primary="interfaces" data-secondary="extensions" data-tertiary="of multiple interfaces" data-tertiary-sortas="multiple interfaces" id="interface-extend-multiple"/><a data-type="indexterm" data-primary="extending" data-secondary="interfaces" data-tertiary="multiple interfaces" id="extend-interface-multiple"/><a data-type="indexterm" data-primary="multiple interfaces" data-secondary="extending" id="multiple-interface-extend"/> in TypeScript are allowed to be declared as extending multiple other interfaces.
Any number of interface names separated by commas may be used after the <code>extends</code> keyword following the derived interface’s name.
The derived interface will receive all members from all base interfaces.</p>

<p>Here, the <code>GivesBothAndEither</code> has three methods: one on its own, one from 
<span class="keep-together"><code>GivesNumber</code></span>, and one from <code>GivesString</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">GivesNumber</code> <code class="p">{</code>
  <code class="nx">giveNumber</code><code class="p">()</code><code class="o">:</code> <code class="kt">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">GivesString</code> <code class="p">{</code>
  <code class="nx">giveString</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">GivesBothAndEither</code> <code class="kr">extends</code> <code class="nx">GivesNumber</code><code class="p">,</code> <code class="nx">GivesString</code> <code class="p">{</code>
  <code class="nx">giveEither</code><code class="p">()</code><code class="o">:</code> <code class="kt">number</code> <code class="o">|</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kd">function</code> <code class="nx">useGivesBoth</code><code class="p">(</code><code class="nx">instance</code>: <code class="nx">GivesBothAndEither</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">instance</code><code class="p">.</code><code class="nx">giveEither</code><code class="p">();</code> <code class="c1">// Type: number | string</code>
  <code class="nx">instance</code><code class="p">.</code><code class="nx">giveNumber</code><code class="p">();</code> <code class="c1">// Type: number</code>
  <code class="nx">instance</code><code class="p">.</code><code class="nx">giveString</code><code class="p">();</code> <code class="c1">// Type: string</code>
<code class="p">}</code></pre>

<p>By marking an interface as extending multiple other interfaces, you can both reduce code duplication and make it easier for object shapes to be reused across different areas of code.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Interface Merging"><div class="sect1" id="idm45584683585408">
<h1>Interface Merging</h1>

<p>One of <a data-type="indexterm" data-primary="interfaces" data-secondary="merging" id="interface-merge"/><a data-type="indexterm" data-primary="merging interfaces" id="merge-interface"/>the important features of interfaces is their ability to <em>merge</em> with each other.
Interface merging means if two interfaces are declared in the same scope with the same name, they’ll join into one bigger interface under that name with all declared fields.</p>

<p>This snippet declares a <code>Merged</code> interface with two properties: <code>fromFirst</code> and 
<span class="keep-together"><code>fromSecond</code></span>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Merged</code> <code class="p">{</code>
  <code class="nx">fromFirst</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">Merged</code> <code class="p">{</code>
  <code class="nx">fromSecond</code>: <code class="nx">number</code><code class="p">;</code>
<code class="p">}</code>

<code class="c1">// Equivalent to:</code>
<code class="c1">// interface Merged {</code>
<code class="c1">//   fromFirst: string;</code>
<code class="c1">//   fromSecond: number;</code>
<code class="c1">// }</code></pre>

<p>Interface merging isn’t a feature used very often in day-to-day TypeScript development.
I would recommend avoiding it when possible, as it can be difficult to understand code where an interface is declared in multiple places.</p>

<p>However, interface merging is particularly useful for augmenting interfaces from external packages or built-in global interfaces such as <code>Window</code>.
For example, when using the default TypeScript compiler options, declaring a <code>Window</code> interface in a file with a <code>myEnvironmentVariable</code> property makes a 
<span class="keep-together"><code>window.myEnvironmentVariable</code></span> available:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">Window</code> <code class="p">{</code>
  <code class="nx">myEnvironmentVariable</code>: <code class="nx">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="nb">window</code><code class="p">.</code><code class="nx">myEnvironmentVariable</code><code class="p">;</code> <code class="c1">// Type: string</code></pre>

<p>I’ll cover type definitions more deeply in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch11.xhtml#declaration_files">Chapter 11, “Declaration Files”</a> and TypeScript global type options in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>.</p>








<section data-type="sect2" data-pdf-bookmark="Member Naming Conflicts"><div class="sect2" id="idm45584683547952">
<h2>Member Naming Conflicts</h2>

<p>Note <a data-type="indexterm" data-primary="properties" data-secondary="of interfaces" data-tertiary="naming conflicts" data-secondary-sortas="interfaces" id="idm45584683546352"/><a data-type="indexterm" data-primary="naming conflicts in merged interfaces" id="idm45584683544800"/>that merged interfaces may not declare the same name of a property multiple times with different types.
If a property is already declared in an interface, a later merged interface must use the same type.</p>

<p>In this <code>MergedProperties</code> interface, the <code>same</code> property is allowed because it is the same in both declarations, but <code>different</code> is an error for being a different type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">MergedProperties</code> <code class="p">{</code>
  <code class="nx">same</code><code class="o">:</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
  <code class="nx">different</code><code class="o">:</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">MergedProperties</code> <code class="p">{</code>
  <code class="nx">same</code><code class="o">:</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">boolean</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code> <code class="c1">// Ok</code>

  <code class="nx">different</code><code class="o">:</code> <code class="p">(</code><code class="nx">input</code>: <code class="nx">number</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="kt">string</code><code class="p">;</code>
  <code class="c1">// Error: Subsequent property declarations must have the same type.</code>
  <code class="c1">// Property 'different' must be of type '(input: string) =&gt; string',</code>
  <code class="c1">// but here has type '(input: number) =&gt; string'.</code>
<code class="p">}</code></pre>

<p>Merged <a data-type="indexterm" data-primary="methods" data-secondary="of interfaces" data-tertiary="overloading" data-secondary-sortas="interfaces" id="idm45584683465664"/><a data-type="indexterm" data-primary="functions" data-secondary="in interfaces" data-tertiary="overloading" data-secondary-sortas="interfaces" id="idm45584683444704"/><a data-type="indexterm" data-primary="overloading interface functions" id="idm45584683443216"/>interfaces may, however, define a method with the same name and a different signature.
Doing so creates a function overload for the method.</p>

<p>This <code>MergedMethods</code> interface creates a <code>different</code> method that has <a data-type="indexterm" data-primary="interfaces" data-secondary="merging" data-startref="interface-merge" id="idm45584683441168"/><a data-type="indexterm" data-primary="merging interfaces" data-startref="merge-interface" id="idm45584683439888"/>two overloads:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">interface</code> <code class="nx">MergedMethods</code> <code class="p">{</code>
  <code class="nx">different</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">string</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code>
<code class="p">}</code>

<code class="kr">interface</code> <code class="nx">MergedMethods</code> <code class="p">{</code>
  <code class="nx">different</code><code class="p">(</code><code class="nx">input</code>: <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="p">}</code></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584683339888">
<h1>Summary</h1>

<p>This chapter introduced how object types may be described by interfaces:</p>

<ul>
<li>
<p>Using interfaces instead of type aliases to declare object types</p>
</li>
<li>
<p>Various interface property types: optional, read-only, function, and method</p>
</li>
<li>
<p>Using index signatures for catchall object properties</p>
</li>
<li>
<p>Reusing interfaces using nested interfaces and <code>extends</code> inheritance</p>
</li>
<li>
<p>How interfaces with the same name can merge together</p>
</li>
</ul>

<p>Next up will be a native JavaScript syntax for setting up multiple objects to have the same properties: classes.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/objects-and-interfaces"><em class="hyperlink">https://learningtypescript.com/objects-and-interfaces</em></a>.</p>
</div>
<blockquote class="joke">
<p>Why are interfaces good drivers?</p>

<p>They’re great at merging.</p></blockquote>
</div></section>







</div></section></div></body></html>