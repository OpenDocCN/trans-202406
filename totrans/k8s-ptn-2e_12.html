<html><head></head><body><section data-pdf-bookmark="Chapter 9. Daemon Service" data-type="chapter" epub:type="chapter"><div class="chapter" id="DaemonService">&#13;
<h1><span class="label">Chapter 9. </span>Daemon Service</h1>&#13;
&#13;
&#13;
<p>The <em>Daemon Service</em> pattern<a data-primary="Daemon Service" data-type="indexterm" id="daemserv09"/> allows you to place and run prioritized, infrastructure-focused Pods on targeted nodes. It is used primarily by administrators to run<a data-primary="Pods" data-secondary="node-specific" data-type="indexterm" id="idm45902102206720"/> node-specific Pods to enhance the Kubernetes platform capabilities.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902102205520">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>The<a data-primary="problems" data-secondary="Pods, node-specific" data-type="indexterm" id="idm45902102204000"/><a data-primary="daemons" data-secondary="concept of" data-type="indexterm" id="idm45902102202992"/> concept of a daemon in software systems exists at many levels. At an operating system level, a <em>daemon</em> is a long-running, self-recovering computer program that runs as a background process. In Unix, the names of daemons end in <em>d</em>, such as httpd, named, and sshd. In other operating systems, alternative terms such as <em>services-started tasks</em> and <em>ghost jobs</em> are used.</p>&#13;
&#13;
<p>Regardless of what these programs are called, the common characteristics among them are that they run as processes and usually do not interact with the monitor, keyboard, and mouse and are launched at system boot time. A similar concept also exists at the application level. For example, in the Java Virtual Machine, daemon threads run in the background and provide supporting services to the user threads. These daemon threads have a low priority, run in the background without a say in the life of the application, and perform tasks such as garbage collection or finalization.</p>&#13;
&#13;
<p>Similarly, Kubernetes also has the concept of a<a data-primary="DaemonSets" data-secondary="concept of" data-type="indexterm" id="idm45902101430304"/> DaemonSet. Considering that Kubernetes is a distributed platform spread across multiple nodes and with the primary goal of managing application Pods, a DaemonSet is represented by Pods that run on the cluster nodes and provide some background capabilities for the rest of the cluster.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902101428640">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>ReplicaSet and its predecessor<a data-primary="Pods" data-secondary="creating and managing" data-type="indexterm" id="idm45902101426944"/><a data-primary="ReplicaSet" data-secondary="creating and managing Pods" data-type="indexterm" id="idm45902101425968"/><a data-primary="ReplicationController" data-type="indexterm" id="idm45902101425056"/> ReplicationController are control structures responsible for making sure a specific number of Pods are running. These controllers constantly monitor the list of running Pods and make sure the actual number of Pods always matches the desired number. In that regard, a<a data-primary="DaemonSets" data-secondary="defining" data-type="indexterm" id="DSdefin09"/> DaemonSet is a similar construct and is responsible for ensuring that a certain number of Pods are always running. The difference is that the first two run a specific number of Pods, usually driven by the application requirements of high availability and user load, irrespective of the node count.</p>&#13;
&#13;
<p>On the other hand, a DaemonSet is not driven by consumer load in deciding how many Pod instances to run and where to run. Its main purpose is to keep running a single Pod on every node or specific nodes. Let’s see such a DaemonSet definition next in <a data-type="xref" href="#ex-daemonset">Example 9-1</a>.</p>&#13;
<div data-type="example" id="ex-daemonset">&#13;
<h5><span class="label">Example 9-1. </span>DaemonSet resource</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DaemonSet</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-refresher</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">selector</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">matchLabels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-refresher</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-refresher</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">nodeSelector</code><code class="p">:</code><code class="w">            </code><a class="co" href="#callout_daemon_service_CO1-1" id="co_daemon_service_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="nt">feature</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">hw-rng</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">k8spatterns/random-generator:1.0</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">random-generator</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">[</code><code class="w"> </code><code class="s">"</code><code class="s">java</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">RandomRunner</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">/numbers.txt</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">10000</code><code class="s">"</code><code class="p-Indicator">,</code><code class="w"> </code><code class="s">"</code><code class="s">30</code><code class="s">"</code><code class="w"> </code><code class="p-Indicator">]</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">          </code><a class="co" href="#callout_daemon_service_CO1-2" id="co_daemon_service_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">        </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/host_dev</code><code class="w">&#13;
</code><code class="w">          </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">devices</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">volumes</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">devices</code><code class="w">&#13;
</code><code class="w">        </code><code class="nt">hostPath</code><code class="p">:</code><code class="w">              </code><a class="co" href="#callout_daemon_service_CO1-3" id="co_daemon_service_CO1-3"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">          </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/dev</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_daemon_service_CO1-1" id="callout_daemon_service_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use only nodes with the label <code>feature</code> set to value <code>hw-rng</code>.</p></dd>&#13;
<dt><a class="co" href="#co_daemon_service_CO1-2" id="callout_daemon_service_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>DaemonSets often mount a portion of a node’s filesystem to perform maintenance actions.</p></dd>&#13;
<dt><a class="co" href="#co_daemon_service_CO1-3" id="callout_daemon_service_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p><code>hostPath</code> for accessing the node directories directly.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>Given this behavior, the primary candidates for a DaemonSet are usually infrastructure-related processes, such as cluster storage providers, log collectors, metric exporters, and even kube-proxy, that perform cluster-wide operations. There are many differences in how DaemonSet<a data-primary="DaemonSets" data-secondary="versus ReplicaSet" data-secondary-sortas="ReplicaSet" data-type="indexterm" id="idm45902101276592"/> and<a data-primary="ReplicaSet" data-secondary="creating and managing Pods" data-type="indexterm" id="idm45902101275248"/> ReplicaSet are managed, but the main ones are the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>By default, a<a data-primary="Pods" data-secondary="creating and managing" data-type="indexterm" id="idm45902101207136"/> DaemonSet places one Pod instance on every node. That can be controlled and limited to a subset of nodes by using the <code>nodeSelector</code> or <code>affinity</code> fields.</p>&#13;
</li>&#13;
<li>&#13;
<p>A Pod created by a DaemonSet already has <code>nodeName</code> specified. As a result, the DaemonSet doesn’t require the existence of the Kubernetes<a data-primary="scheduler" data-secondary="Daemon Service" data-type="indexterm" id="idm45902101203552"/> scheduler to run containers. That also allows you to use a DaemonSet for running and managing the Kubernetes components.</p>&#13;
</li>&#13;
<li>&#13;
<p>Pods created by a DaemonSet can run before the scheduler has started, which allows them to run before any other Pod is placed on a node.</p>&#13;
</li>&#13;
<li>&#13;
<p>Since the scheduler is not used, the <code>unschedulable</code> field of a node is not respected by the DaemonSet controller.</p>&#13;
</li>&#13;
<li>&#13;
<p>Pods created by a DaemonSet can have a<a data-primary="restartPolicy" data-type="indexterm" id="idm45902101199312"/> <code>RestartPolicy</code> only set to <code>Always</code> or left unspecified, which defaults to <code>Always</code>. This is to ensure that when a liveness probe fails, the container will be killed and always restarted.</p>&#13;
</li>&#13;
<li>&#13;
<p>Pods managed by a DaemonSet are supposed to run only on targeted nodes and, as a result, are treated with higher priority by many controllers. For example, the descheduler will avoid evicting such Pods, the cluster autoscaler will manage them separately, etc.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The<a data-primary="Pods" data-secondary="running system critical" data-type="indexterm" id="idm45902101195376"/> main use case for DaemonSets is to run system-critical Pods on certain nodes in the cluster. The DaemonSet controller ensures that all eligible nodes run a copy of a Pod by assigning the Pod directly to the node by setting the <code>nodeName</code> field of the Pod specification. This allows DaemonSet Pods to be scheduled even before the default scheduler starts and keeps it immune to any scheduler customizations configured by the user. This approach works as long as there are enough resources on the nodes and it is done before other Pods are placed. When a node does not have enough resources, the DaemonSet controller cannot create a Pod for the node, and it cannot do anything such as preemption to release resources on the nodes. This duplication of scheduling logic in the DaemonSet controller and the scheduler creates maintenance challenges. The DaemonSet implementation also does not benefit from new scheduler features such as affinity, anti-affinity, and preemption. As a result, with Kubernetes v1.17 and newer versions, DaemonSet uses the default scheduler for scheduling by setting the <code>nodeAffinity</code> field instead of the <code>nodeName</code> field to the DaemonSet Pods. This change makes the default scheduler a mandatory dependency for running DaemonSets, but at the same time it brings<a data-primary="taints and tolerations" data-type="indexterm" id="idm45902101192832"/> taints, tolerations, Pod priority, and preemption to DaemonSets and improves the overall experience of running DaemonSet Pods on the desired nodes even when there is resource starvation.</p>&#13;
&#13;
<p>Typically, a DaemonSet creates a single Pod on every node or subset of nodes. Given that, there are several ways to reach Pods managed by DaemonSets:</p>&#13;
<dl>&#13;
<dt>Service</dt>&#13;
<dd>&#13;
<p>Create a Service with the same Pod selector as a DaemonSet, and use the Service to reach a daemon Pod load-balanced to a random node.</p>&#13;
</dd>&#13;
<dt>DNS</dt>&#13;
<dd>&#13;
<p>Create a headless Service with the same Pod selector as a DaemonSet that can be used to retrieve multiple A records from DNS containing all Pod IPs and ports.</p>&#13;
</dd>&#13;
<dt>Node IP with <code>hostPort</code></dt>&#13;
<dd>&#13;
<p>Pods in the DaemonSet can specify a <code>hostPort</code> and become reachable via the node IP addresses and the specified port. Since the combination of node IP and <code>hostPort</code> and <code>protocol</code> must be unique, the number of places where a Pod can be scheduled is limited.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Also, the application in the DaemonSets Pods can push data to a well-known location or service that’s external to the Pod. No consumer needs to reach the DaemonSets Pods in this case.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902101184320">&#13;
<h1>Static Pods</h1>&#13;
<p>Another<a data-primary="static Pods" data-type="indexterm" id="idm45902101182992"/><a data-primary="Pods" data-secondary="static" data-type="indexterm" id="idm45902101182256"/> way to run containers similar to the way a DaemonSet does is through the <em>static Pods</em> mechanism. The<a data-primary="Kubelet" data-secondary="static pods mechanism" data-type="indexterm" id="idm45902101180800"/> Kubelet, in addition to talking to the Kubernetes API Server and getting Pod manifests, can get the resource definitions from a local directory. Pods defined this way are managed by the Kubelet only and run on one node only. The API service is not observing these Pods, and no controller and no health checks are performed on them. The Kubelet watches such Pods and restarts them when they crash. Similarly, the Kubelet also periodically scans the configured directory for Pod definition changes and adds or removes Pods accordingly.</p>&#13;
</div></aside>&#13;
&#13;
<p>Static Pods can be used to spin off a containerized version of Kubernetes system processes or other containers. However, DaemonSets are better integrated with the rest of the platform and are recommended over static Pods.<a data-primary="" data-startref="DSdefin09" data-type="indexterm" id="idm45902101179152"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902101428048">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>There are other ways to run<a data-primary="daemons" data-secondary="running on every node" data-type="indexterm" id="idm45902101176880"/> daemon processes on every node, but they all have limitations. Static Pods are managed by the Kubelet but cannot be managed through Kubernetes APIs. Bare Pods (Pods without a controller) cannot survive if they are accidentally deleted or terminated, nor can they survive a node failure or disruptive node maintenance. Init scripts such as upstartd or systemd require different toolchains for monitoring and management and cannot benefit from the Kubernetes tools used for application workloads. All that makes Kubernetes and DaemonSet an attractive option for running daemon processes too.</p>&#13;
&#13;
<p>In this book, we describe patterns and Kubernetes features primarily used by developers rather than platform administrators. A DaemonSet is somewhere in the middle, inclining more toward the administrator toolbox, but we include it here because it also has relevance to application developers. DaemonSets and CronJobs<a data-primary="CronJobs" data-secondary="multinode clustered primitives" data-type="indexterm" id="idm45902101175392"/> are also perfect examples of how Kubernetes turns single-node concepts such as<a data-primary="crontab" data-type="indexterm" id="idm45902101174272"/> crontab and daemon scripts into multinode clustered primitives for managing distributed systems. These are new distributed concepts developers must also be familiar with.<a data-primary="" data-startref="daemserv09" data-type="indexterm" id="idm45902101173472"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902101172272">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/_YRZc">Daemon Service Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/62c3q">DaemonSet</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/nTSbi">Perform a Rolling Update on a DaemonSet</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/CnHin">DaemonSets and Jobs</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/yYHft">Create Static Pods</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>