<html><head></head><body><section data-pdf-bookmark="Chapter 10. Deploying Our API" data-type="chapter" epub:type="chapter"><div class="chapter" id="api-deployment">&#13;
<h1><span class="label">Chapter 10. </span>Deploying Our API</h1>&#13;
&#13;
&#13;
<p><a data-primary="API deployment" data-type="indexterm" id="ix_ch10-asciidoc0"/>Imagine if each time a user wanted to access our API to create, read, update, or delete a note we had to go meet them, laptop in tow. Currently, this is how our API works, as it is running only on our individual computer. We can resolve this by <em>deploying</em> our application to a web server.</p>&#13;
&#13;
<p>In this chapter we’ll take two steps:</p>&#13;
<ol>&#13;
<li>&#13;
<p>First, we’ll set up a remote database that our API can access.</p>&#13;
</li>&#13;
<li>&#13;
<p>Second, we’ll deploy our API code to a server and connect it to the database.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Once we’ve followed these steps, we can access our API from any web-connected computer, including the web, desktop, and mobile interfaces that we will develop.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hosting Our Database" data-type="sect1"><div class="sect1" id="idm45339501980536">&#13;
<h1>Hosting Our Database</h1>&#13;
&#13;
<p><a data-primary="API deployment" data-secondary="hosting database" data-type="indexterm" id="ix_ch10-asciidoc1"/><a data-primary="hosting database" data-type="indexterm" id="ix_ch10-asciidoc2"/>For the first step we’ll use a hosted database solution. For our Mongo database, we’ll be using<a data-primary="MongoDB Atlas" data-type="indexterm" id="idm45339501976504"/> MongoDB Atlas. This is a fully managed cloud offering backed by the organization behind Mongo itself. Additionally, they offer a free tier that will work well for our initial deployment. Let’s walk through the steps of deploying to MongoDB Atlas.</p>&#13;
&#13;
<p>First, visit <a class="orm:hideurl" href="https://oreil.ly/-TpJG"><em>mongodb.com/cloud/atlas</em></a> and create an account. Once you’ve created an account, you’ll be prompted to create a database. From this screen you can manage the settings of your sandbox database, but I recommend sticking with the defaults for now. These are:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Amazon’s AWS as the database host, though Google’s Cloud Platform and Microsoft’s Azure are also offered as options</p>&#13;
</li>&#13;
<li>&#13;
<p>The closest region with a “free tier” option</p>&#13;
</li>&#13;
<li>&#13;
<p>Cluster Tier with a default value of “M0 Sandbox (Shared RAM, 512MB <span class="keep-together">Storage</span>)”</p>&#13;
</li>&#13;
<li>&#13;
<p>Additional Settings, which we can leave as the defaults</p>&#13;
</li>&#13;
<li>&#13;
<p>Cluster Name, which we can leave as the default</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>From here, click Create Cluster, at which point it will take a few minutes for Mongo to set up the database (<a data-type="xref" href="#mongo-atlas-create">Figure 10-1</a>).</p>&#13;
&#13;
<figure><div class="figure" id="mongo-atlas-create">&#13;
<img alt="A screenshot of the default MongoDB Atlas new database settings" src="assets/jsev_1001.png"/>&#13;
<h6><span class="label">Figure 10-1. </span>The MongoDB Atlas database creation screen</h6>&#13;
</div></figure>&#13;
&#13;
<p>Next, you’ll see the Clusters page, where you can manage your individual database cluster (<a data-type="xref" href="#mongo-atlas-cluster">Figure 10-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="mongo-atlas-cluster">&#13;
<img alt="A screenshot of MongoDB Atlas's Cluster Screen" src="assets/jsev_1002.png"/>&#13;
<h6><span class="label">Figure 10-2. </span>MongoDB Atlas Cluster</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">From the Clusters screen, click Connect, where you’ll be prompted to set up your connection security. The first step will be to whitelist your IP address. Because our application will have a dynamic IP address, you’ll need to open this to any IP address by using <code>0.0.0.0/0</code>. With all IP addresses whitelisted, you’ll then need to set up a secure username and password for accessing the data (<a data-type="xref" href="#mongo-atlas-ip">Figure 10-3</a>).</p>&#13;
&#13;
<figure><div class="figure" id="mongo-atlas-ip">&#13;
<img alt="A screenshot of MongoDB Atlas's IP whitelist and user prompt" src="assets/jsev_1003.png"/>&#13;
<h6><span class="label">Figure 10-3. </span>MongoDB Atlas IP whitelist and user account management</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Once your IP has been whitelisted and your user account has been created, you’ll choose the connection method for the database. In this case, it will be an “Application” connection (<a data-type="xref" href="#mongo-atlas-connection">Figure 10-4</a>).</p>&#13;
&#13;
<figure><div class="figure" id="mongo-atlas-connection">&#13;
<img alt="A screenshot of the connection type selection in MongoDB Atlas" src="assets/jsev_1004.png"/>&#13;
<h6><span class="label">Figure 10-4. </span>Selecting a connection type in MongoDB Atlas</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">From here, you can copy the connection string, which we’ll be using in our production <em>.env</em> file (<a data-type="xref" href="#mongo-atlas-connection-string">Figure 10-5</a>).</p>&#13;
&#13;
<figure><div class="figure" id="mongo-atlas-connection-string">&#13;
<img alt="A screenshot of the connection string in MongoDB Atlas" src="assets/jsev_1005.png"/>&#13;
<h6><span class="label">Figure 10-5. </span>MongoDB Atlas’s database connection string</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h1>Mongo Passwords</h1>&#13;
<p><a data-primary="passwords" data-secondary="MongoDB" data-type="indexterm" id="idm45339501947672"/>MongoDB Atlas <em>hex-encodes</em> special characters within passwords. This means that if you use (and you should!) any nonalpha or numeric value, you will need to use the hex value for that code when adding your password to the connection string. The site <a class="orm:hideurl" href="https://ascii.cl"><em>ascii.cl</em></a> offers the corresponding hex codes for all special characters. For example, if your password was <code>Pizz@2!</code> you would need to encode the <code>@</code> and <code>!</code> characters. You do this with a <code>%</code> followed by the hex value. The resulting password would be <span class="keep-together"><code>Pizz%402%21</code></span>.</p>&#13;
</div>&#13;
&#13;
<p>With our MongoDB Atlas managed database up and running, we now have a hosted data store for our application. In the next step we’ll host our application code and connect it to our database.<a data-startref="ix_ch10-asciidoc2" data-type="indexterm" id="idm45339501941352"/><a data-startref="ix_ch10-asciidoc1" data-type="indexterm" id="idm45339501940648"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploying Our Application" data-type="sect1"><div class="sect1" id="idm45339501979912">&#13;
<h1>Deploying Our Application</h1>&#13;
&#13;
<p><a data-primary="API deployment" data-secondary="application code deployment" data-type="indexterm" id="ix_ch10-asciidoc3"/>The next step in our deployment setup is to deploy our application code. For the purpose of this book we will use the cloud application platform Heroku. I’ve chosen Heroku due to its excellent user experience and generous free tier, but other cloud platforms such as Amazon Web Services, Google Cloud Platform, Digital Ocean, or Microsoft Azure all provide alternative hosting environments for Node.js applications.</p>&#13;
&#13;
<p>Before we begin, you will need to visit <a href="https://heroku.com/apps">Heroku’s website</a> and create an account. Once your account has been created, you’ll need to install the <a href="https://oreil.ly/Vf2Q_">Heroku command-line tools</a> for your operating system.</p>&#13;
&#13;
<p>For <a data-primary="macOS" data-secondary="Heroku command-line tools" data-type="indexterm" id="idm45339501934424"/>macOS you can install the Heroku command-line tools using Homebrew as <span class="keep-together">follows:</span></p>&#13;
&#13;
<pre data-type="programlisting">$ brew tap heroku/brew &amp;&amp; brew install heroku</pre>&#13;
&#13;
<p>For <a data-primary="Windows" data-secondary="Heroku command-line tools" data-type="indexterm" id="idm45339501931592"/>Windows users, visit the Heroku command-line tools guide and download the appropriate installer.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Project Setup" data-type="sect2"><div class="sect2" id="idm45339501930200">&#13;
<h2>Project Setup</h2>&#13;
&#13;
<p><a data-primary="API deployment" data-secondary="project setup" data-type="indexterm" id="ix_ch10-asciidoc4"/><a data-primary="application code deployment" data-secondary="project setup" data-type="indexterm" id="ix_ch10-asciidoc5"/>With the Heroku command-line tools installed, we can set up our project within the Heroku website. Create a new Heroku project by clicking New → Create New App (<a data-type="xref" href="#heroku-new-app">Figure 10-6</a>).</p>&#13;
&#13;
<figure><div class="figure" id="heroku-new-app">&#13;
<img alt="A screenshot of the Heroku new app dialog" src="assets/jsev_1006.png"/>&#13;
<h6><span class="label">Figure 10-6. </span>The Heroku New App dialog</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">From here you’ll be prompted to give the application a unique name, after which you can click the Create App button (<a data-type="xref" href="#heroku-name-app">Figure 10-7</a>). Going forward, use this name anywhere you see <code>YOUR_APP_NAME</code>.</p>&#13;
&#13;
<figure><div class="figure" id="heroku-name-app">&#13;
<img alt="A screenshot of the Heroku app name screen" src="assets/jsev_1007.png"/>&#13;
<h6><span class="label">Figure 10-7. </span>Provide a unique application name</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Now we can add environment variables. Similar to how we used our <em>.env</em> file locally, we can manage our production environment variables within the Heroku website interface. To do so, click Settings followed by the Reveal Config Vars button. From this screen, add the following configuration variables (<a data-type="xref" href="#heroku-env">Figure 10-8</a>):</p>&#13;
&#13;
<pre data-type="programlisting">NODE_ENV production&#13;
JWT_SECRET A_UNIQUE_PASSPHRASE&#13;
DB_HOST YOUR_MONGO_ATLAS_URL</pre>&#13;
&#13;
<figure><div class="figure" id="heroku-env">&#13;
<img alt="Screenshot of the Heroku environment variable configuration" src="assets/jsev_1008.png"/>&#13;
<h6><span class="label">Figure 10-8. </span>Heroku’s environment variable configuration</h6>&#13;
</div></figure>&#13;
&#13;
<p>With our application configured, we’re ready to deploy our code.<a data-startref="ix_ch10-asciidoc5" data-type="indexterm" id="idm45339501890344"/><a data-startref="ix_ch10-asciidoc4" data-type="indexterm" id="idm45339501889560"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deployment" data-type="sect2"><div class="sect2" id="idm45339501888760">&#13;
<h2>Deployment</h2>&#13;
&#13;
<p><a data-primary="API deployment" data-secondary="to Heroku's servers" data-type="indexterm" id="idm45339501887624"/><a data-primary="application code deployment" data-secondary="to Heroku's servers" data-type="indexterm" id="idm45339501886648"/><a data-primary="Heroku's servers" data-type="indexterm" id="idm45339501885640"/>Now we’re ready to deploy our code to Heroku’s servers. To do this, we can use straightforward Git commands from our terminal application. We’ll set Heroku as a remote endpoint, then add and commit our changes, and finally push our code to Heroku. To do this, run the following commands within your terminal application:</p>&#13;
&#13;
<pre data-type="programlisting">$ heroku git:remote -a &lt;YOUR_APP_NAME&gt;&#13;
$ git add .&#13;
$ git commit -am "application ready for production"&#13;
$ git push heroku master</pre>&#13;
&#13;
<p>You should see output in your terminal while Heroku builds and deploys the files. Once complete, Heroku will use the <code>run</code> script within our <em>package.json</em> file to run our application on their servers.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Testing" data-type="sect2"><div class="sect2" id="idm45339501881880">&#13;
<h2>Testing</h2>&#13;
&#13;
<p><a data-primary="API deployment" data-secondary="testing" data-type="indexterm" id="idm45339501880504"/><a data-primary="application code deployment" data-secondary="testing" data-type="indexterm" id="idm45339501879528"/><a data-primary="testing" data-secondary="API deployment" data-type="indexterm" id="idm45339501878568"/>Once our application has been successfully deployed, we will be able to make GraphQL API requests to our remote server. By default, the GraphQL Playground UI is disabled in production, but we can test our application using <code>curl</code> from our terminal application. To run a <code>curl</code> request, enter the following in your terminal <span class="keep-together">application:</span></p>&#13;
&#13;
<pre data-type="programlisting">$ curl \&#13;
  -X POST \&#13;
  -H "Content-Type: application/json" \&#13;
  --data '{ "query": "{ notes { id } }" }' \&#13;
  https://YOUR_APP_NAME.herokuapp.com/api</pre>&#13;
&#13;
<p>If the test is successful, we should receive a response containing an empty <code>notes</code> array, since our production database does not yet contain any data:</p>&#13;
&#13;
<pre data-type="programlisting">{"data":{"notes":[]}}</pre>&#13;
&#13;
<p>With this, we have deployed our application!<a data-startref="ix_ch10-asciidoc3" data-type="indexterm" id="idm45339501872808"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339501871976">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>In this chapter we used cloud services to deploy a database and our application code. Services such as MongoDB Atlas and Heroku enable developers to launch small applications and scale them anywhere from hobby projects to heavily trafficked business. With our API deployed, we have successfully developed the backend services of our applications’ stack. In the following chapters, we will focus on the UIs of our app.<a data-startref="ix_ch10-asciidoc0" data-type="indexterm" id="idm45339501870280"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>