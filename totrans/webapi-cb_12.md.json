["```\nclass MyComponent extends HTMLElement {\n  connectedCallback() {\n    this.textContent = 'Hello from MyComponent';\n  }\n}\n```", "```\ncustomElements.define('my-component', MyComponent);\n```", "```\n<my-component></my-component>\n```", "```\n<template>\n  <h2><slot name=\"name\"></slot></h2>\n  <slot></slot>\n</template>\n```", "```\n<author-bio>\n  <span slot=\"name\">John Doe</span>\n  <p>John is a great author who has written many books.</p>\n</author-bio>\n```", "```\nclass TodaysDate extends HTMLElement {\n  connectedCallback() {\n    const formatter = new Intl.DateTimeFormat(\n      navigator.language,\n      { dateStyle: 'full' }\n    );\n\n    this.textContent = formatter.format(new Date());\n  }\n}\n\ncustomElements.define('todays-date', TodaysDate);\n```", "```\n<p>\n  Today's date is: <todays-date></todays-date>\n</p>\n```", "```\nclass DateFormatter extends HTMLElement {\n  // The browser will only notify the component about changes, via the\n  // attributeChangedCallback, for attributes that are listed here.\n  static observedAttributes = ['date'];\n\n  constructor() {\n    super();\n\n    // Create the format here so you don't have to\n    // re-create it every time the date changes.\n    this.formatter = new Intl.DateTimeFormat(\n      navigator.language,\n      { dateStyle: 'full' }\n    );\n  }\n\n  /**\n * Formats the date represented by the current value of the 'date'\n * attribute, if any.\n */\n  formatDate() {\n    if (this.hasAttribute('date')) {\n      this.textContent = this.formatter.format(\n        new Date(this.getAttribute('date'))\n      );\n    } else {\n      // If no date specified, show nothing.\n      this.textContent = '';\n    }\n  }\n\n  attributeChangedCallback() {\n    // Only watching one attribute, so this must be a change\n    // to the date attribute. Update the formatted date, if any.\n    this.formatDate();\n  }\n\n  connectedCallback() {\n    // The element was just added. Show the initial formatted date, if any.\n    this.formatDate();\n  }\n}\n\ncustomElements.define('date-formatter', DateFormatter);\n```", "```\n<date-formatter date=\"2023-10-16T03:52:49.955Z\"></date-formatter>\n```", "```\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n <style>\n .feedback-prompt {\n display: flex;\n align-items: center;\n gap: 0.5em;\n }\n\n button {\n padding: 0.5em 1em;\n }\n </style>\n\n <div class=\"feedback-prompt\">\n <p>Was this helpful?</p>\n <button type=\"button\" data-helpful=\"true\">Yes</button>\n <button type=\"button\" data-helpful=\"false\">No</button>\n </div>\n`;\n```", "```\nclass FeedbackRating extends HTMLElement {\n  constructor() {\n    super();\n\n    // Create the shadow DOM and render the template into it.\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n\n  connectedCallback() {\n    this.shadowRoot.querySelector('.feedback-prompt').addEventListener('click',\n    event => {\n      const { helpful } = event.target.dataset;\n\n      if (typeof helpful !== 'undefined') {\n        // Once a feedback option is chosen, hide the buttons and show a\n        // confirmation.\n        this.shadowRoot.querySelector('.feedback-prompt').remove();\n        this.shadowRoot.textContent = 'Thanks for your feedback!';\n\n        // JavaScript doesn't have a 'parseBoolean' type function, so convert the\n        // string value to the corresponding boolean value.\n        this.helpful = helpful === 'true';\n\n        // Dispatch a custom event, so your app can be notified when a feedback\n        // button is clicked.\n        this.shadowRoot.dispatchEvent(new CustomEvent('feedback', {\n          composed: true, // This is needed to \"escape\" the shadow DOM boundary.\n          bubbles: true // This is needed to propagate up the DOM.\n        }));\n      }\n    });\n  }\n}\n\ncustomElements.define('feedback-rating', FeedbackRating);\n```", "```\n<h2>Feedback</h2>\n<feedback-rating></feedback-rating>\n```", "```\ndocument.querySelector('feedback-rating').addEventListener('feedback', event => {\n  // Get the value of the feedback component's \"helpful\" property and send it to an\n  // endpoint with a POST request.\n  fetch('/api/analytics/feedback', {\n    method: 'POST',\n    body: JSON.stringify({ helpful: event.target.helpful }),\n    headers: {\n      'Content-Type': 'application/json'\n    }\n  });\n});\n```", "```\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n <style>\n :host {\n display: grid;\n border: 1px solid #ccc;\n border-radius: 5px;\n padding: 8px;\n grid-template-columns: auto 1fr;\n column-gap: 16px;\n align-items: center;\n margin: 1rem;\n }\n\n .photo {\n border-radius: 50%;\n grid-row: 1 / span 3;\n }\n\n .name {\n font-size: 2rem;\n font-weight: bold;\n }\n\n .title {\n font-weight: bold;\n }\n </style>\n\n <div class=\"photo\"><slot name=\"photo\"></slot></div>\n <div class=\"name\"><slot name=\"name\"></slot></div>\n <div class=\"title\"><slot name=\"title\"></slot></div>\n <div class=\"bio\"><slot></slot></div>\n`;\n```", "```\nclass ProfileCard extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n  }\n}\n\ncustomElements.define('profile-card', ProfileCard);\n```", "```\n<profile-card>\n  <img slot=\"photo\" src=\"/api/portraits/chavez.jpg\" />\n  <div slot=\"name\">Phillip Chavez</div>\n  <div slot=\"title\">CEO</div>\n  <p>Philip is a great CEO.</p>\n</profile-card>\n\n<profile-card>\n  <img slot=\"photo\" src=\"/api/portraits/lynch.jpg\" />\n  <div slot=\"name\">Jamie Lynch</div>\n  <div slot=\"title\">Vice President</div>\n  <p>Jamie is a great vice president.</p>\n</profile-card>\n```", "```\nclass LazyImage extends HTMLElement {\n  constructor() {\n    super();\n\n    const shadowRoot = this.attachShadow({ mode: 'open' });\n    this.image = document.createElement('img');\n    shadowRoot.appendChild(this.image);\n  }\n\n  connectedCallback() {\n    const observer = new IntersectionObserver(entries => {\n      if (entries[0].isIntersecting) {\n        console.log('Loading image');\n        this.image.src = this.getAttribute('src');\n        observer.disconnect();\n      }\n    });\n\n    observer.observe(this);\n  }\n}\n\ncustomElements.define('lazy-image', LazyImage);\n```", "```\n<lazy-image src=\"https://placekitten.com/200/138\"></lazy-image>\n```", "```\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n <div>\n <button type=\"button\" class=\"toggle-button\">\n <slot name=\"title\"></slot>\n </button>\n <div class=\"content\">\n <slot></slot>\n </div>\n </div>\n`;\n```", "```\nclass Disclosure extends HTMLElement {\n  // Watch the 'open' attribute to react to changes.\n  static observedAttributes = ['open'];\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n\n    this.content = this.shadowRoot.querySelector('.content');\n  }\n\n  connectedCallback() {\n    this.content.hidden = !this.hasAttribute('open');\n    this.shadowRoot.querySelector('.toggle-button')\n      .addEventListener('click', () => {\n        if (this.hasAttribute('open')) {\n          // Content is currently showing; remove the 'open'\n          // attribute and hide the content.\n          this.removeAttribute('open');\n          this.content.hidden = true;\n        } else {\n          // Content is currently hidden; add the 'open' attribute\n          // and show the content.\n          this.setAttribute('open', '');\n          this.content.hidden = false;\n        }\n      });\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    // Update the content's hidden state based on the new attribute value.\n    if (newValue !== null) {\n      this.content.hidden = false;\n    } else {\n      this.content.hidden = true;\n    }\n  }\n}\n\n// The element name must be hyphenated.\ncustomElements.define('x-disclosure', Disclosure);\n```", "```\nx-disclosure:not(:defined) {\n  display: none;\n}\n```", "```\n<x-disclosure>\n  <div slot=\"title\">Details</div>\n  This is the detail child content that will be expanded or collapsed\n  when clicking the title button.\n</x-disclosure>\n```", "```\n<x-disclosure open>\n  <div slot=\"title\">Details</div>\n  This is the detail child content that will be expanded or collapsed\n  when clicking the title button.\n</x-disclosure>\n```", "```\nconst template = document.createElement('template');\ntemplate.innerHTML = `\n <style>\n button {\n background: #333;\n padding: 0.5em 1.25em;\n font-size: 1rem;\n border: none;\n border-radius: 5px;\n color: white;\n }\n\n button.primary {\n background: #2563eb;\n }\n\n button.danger {\n background: #dc2626;\n }\n </style>\n\n <button>\n <slot></slot>\n </button>\n`;\n```", "```\nclass StyledButton extends HTMLElement {\n  static observedAttributes = ['variant', 'type'];\n\n  constructor() {\n    super();\n    this.attachShadow({ mode: 'open' });\n    this.shadowRoot.appendChild(template.content.cloneNode(true));\n    this.button = this.shadowRoot.querySelector('button');\n  }\n\n  attributeChangedCallback(name, oldValue, newValue) {\n    if (name === 'variant') {\n      this.button.className = newValue;\n    } else if (name === 'type') {\n      this.button.type = newValue;\n    }\n  }\n}\n\ncustomElements.define('styled-button', StyledButton);\n```", "```\n<styled-button id=\"default-button\" type=\"button\">Default</styled-button>\n<styled-button id=\"primary-button\" type=\"button\" variant=\"primary\">\n  Primary\n</styled-button>\n<styled-button id=\"danger-button\" type=\"button\" variant=\"danger\">\n  Danger\n</styled-button>\n```", "```\n<script>\ndocument.querySelector('#default-button').addEventListener('click', () => {\n  console.log('Clicked the default button');\n});\n</script>\n\n<styled-button id=\"default-button\" type=\"button\">Default</styled-button>\n```"]