<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 3. Containers" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_Containers">
<h1><span class="label">Chapter 3. </span>Containers</h1>
<p>Containers <a data-primary="containers" data-type="indexterm" id="idm45120848345488"/>are a popular and standard format for packaging applications. The format is an open standard promoted by the <a href="https://opencontainers.org">Open Container Initiative (OCI)</a>, an <a data-primary="Open Container Initiative" data-type="indexterm" id="idm45120848369280"/>open governance structure for the express purpose of creating open industry standards around container formats and runtimes. The openness of this format ensures portability and interoperability across different operating systems, vendors, platforms, or clouds. <a data-primary="Kubernetes" data-secondary="containerized applications" data-type="indexterm" id="idm45120848368480"/>Kubernetes runs containerized apps, so before going into the GitOps approach to managing apps on Kubernetes, we provide a list of recipes useful for understanding how to package your application as a container image.</p>
<p>The first step for creating <a data-primary="container images" data-secondary="creating" data-type="indexterm" id="idm45120848367008"/><a data-primary="images, creating" data-type="indexterm" id="idm45120848331920"/><a data-primary="applications" data-secondary="container images" data-type="indexterm" id="idm45120848331248"/>images is to use a container engine for packaging your application by building a layered structure containing a base OS and additional layers on top such as runtimes, libraries, and applications. Docker is a widespread open source implementation of a container engine and runtime, and it can generate a container image by specifying a manifest called a <a data-primary="manifests" data-secondary="Dockerfiles" data-type="indexterm" id="idm45120848330176"/><a data-primary="Dockerfiles" data-type="indexterm" id="idm45120848329232"/>Dockerfile (see <a data-type="xref" href="#recipe_3_1">Recipe 3.1</a>).</p>
<p>Since the format is open, it’s possible to create container images with other tools. <a href="https://www.docker.com">Docker</a>, a <a data-primary="container engines, Docker" data-type="indexterm" id="idm45120848114512"/><a data-primary="Docker" data-type="indexterm" id="idm45120848113760"/>popular container engine, requires the installation and the execution of a <em>daemon</em> that <a data-primary="daemons, Docker" data-type="indexterm" id="idm45120848112576"/>can handle all the operations with the container engine. Developers can use a software development kit (SDK) to interact with the Docker daemon or use <em>dockerless</em> solutions <a data-primary="dockerless container images" data-type="indexterm" id="idm45120848043008"/>such as JiB<a data-primary="Jib" data-type="indexterm" id="idm45120848042128"/> to create container images (see <a data-type="xref" href="#recipe_3_2">Recipe 3.2</a>).</p>
<p>If you don’t want to rely on a specific programming language or SDK to build container images, you can use another <em>daemonless</em> solution<a data-primary="daemonless container images" data-type="indexterm" id="idm45120848199728"/><a data-primary="Buildah" data-type="indexterm" id="idm45120848199024"/><a data-primary="Buildpacks" data-type="indexterm" id="idm45120848198352"/> like Buildah (see <a data-type="xref" href="#recipe_3_3">Recipe 3.3</a>) or Buildpacks (see <a data-type="xref" href="#recipe_3_4">Recipe 3.4</a>).
Those are other popular open source tools for building<a data-primary="OCI containers" data-type="indexterm" id="idm45120848195888"/> OCI container images. By avoiding dependencies from the OS, such tools make automation more manageable and portable (see <a data-type="xref" href="ch06.xhtml#ch_Cloud_Native_CICD">Chapter 6</a>).</p>
<p class="less_space pagebreak-before">Kubernetes doesn’t provide a native mechanism for building container images. However, its highly extensible architecture allows interoperability with external tools and the platform’s extensibility to create container images.
Shipwright is an open source framework for building container images on Kubernetes, providing an abstraction that can use tools such as kaniko, Buildpacks, or Buildah (see <a data-type="xref" href="#recipe_3_5">Recipe 3.5</a>) to create container images.</p>
<p>At the end of this chapter, you’ll learn how to create OCI-compliant container images from a Dockerfile, either from a host with Docker installed, or using tools such as Buildah and Buildpacks.</p>
<section data-pdf-bookmark="3.1 Building a Container Using Docker" data-type="sect1"><div class="sect1" id="recipe_3_1">
<h1>3.1 Building a Container Using Docker</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45120848182512">
<h2>Problem</h2>
<p>You want to create a <a data-primary="Docker" data-secondary="container images" data-tertiary="creating" data-type="indexterm" id="Dock_cont_img"/><a data-primary="container images" data-secondary="Docker" data-tertiary="creating" data-type="indexterm" id="cont_img_Dock"/><a data-primary="applications" data-secondary="container images" data-tertiary="creating with Docker" data-type="indexterm" id="app_contimg_Dock"/>container image for your application with Docker.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45120848395408">
<h2>Solution</h2>
<p>The first thing you need to do is <a data-primary="Docker" data-secondary="installing" data-type="indexterm" id="idm45120848392832"/>install <a href="https://oreil.ly/jd0kH">Docker</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Docker is available for Mac, Windows, and Linux. Download the installer for your operating system and refer to the <a href="https://oreil.ly/7vGmZ">documentation</a> to start the Docker service.</p>
</div>
<p>Developers can create a container image by <a data-primary="Dockerfiles" data-secondary="defining" data-type="indexterm" id="Dockfile_def"/>defining a <em>Dockerfile</em>. The best definition for a Dockerfile comes from the <a href="https://oreil.ly/RMm2y">Docker documentation</a> itself: “A Dockerfile is a text document that contains all the commands a user could call on the command line to assemble an image.”</p>
<p>Container images present a layered <a data-primary="container images" data-secondary="structure" data-type="indexterm" id="contimg_struct"/>structure, as you can see in <a data-type="xref" href="#fig3-1">Figure 3-1</a>.
Each container image provides the foundation layer for a container, and any update is just an additional layer that can be committed on the foundation.</p>
<figure><div class="figure" id="fig3-1">
<img alt="Container image layers" height="424" src="assets/gocb_0301.png" width="1280"/>
<h6><span class="label">Figure 3-1. </span>Container image layers</h6>
</div></figure>
<p>You <a data-primary="container images" data-secondary="structure" data-startref="contimg_struct" data-type="indexterm" id="idm45120848074944"/>can create a Dockerfile like the one shown here, which will generate a container image for Python <a data-primary="applications" data-secondary="Python, Dockerfile" data-type="indexterm" id="idm45120848073424"/>apps. You can also find this example in <a href="https://oreil.ly/J7cXP">this book’s repository</a>.</p>
<pre data-code-language="text" data-type="programlisting"><code>FROM registry.access.redhat.com/ubi8/python-39 </code><a class="co" href="#callout_containers_CO1-1" id="co_containers_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code>
ENV PORT 8080 </code><a class="co" href="#callout_containers_CO1-2" id="co_containers_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code>
EXPOSE 8080 </code><a class="co" href="#callout_containers_CO1-3" id="co_containers_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code>
WORKDIR /usr/src/app </code><a class="co" href="#callout_containers_CO1-4" id="co_containers_CO1-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code>

COPY requirements.txt ./ </code><a class="co" href="#callout_containers_CO1-5" id="co_containers_CO1-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a><code>
RUN pip install --no-cache-dir -r requirements.txt </code><a class="co" href="#callout_containers_CO1-6" id="co_containers_CO1-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a><code>

COPY . .

ENTRYPOINT ["python"] </code><a class="co" href="#callout_containers_CO1-7" id="co_containers_CO1-7"><img alt="7" height="12" src="assets/7.png" width="12"/></a><code>
CMD ["app.py"] </code><a class="co" href="#callout_containers_CO1-8" id="co_containers_CO1-8"><img alt="8" height="12" src="assets/8.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_containers_CO1-1" id="callout_containers_CO1-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p><code>FROM</code>: always start from a base image as a foundational layer. In this case we start from a Universal Base Image (UBI), publicly available based on RHEL 8 with Python 3.9 runtime.</p></dd>
<dt><a class="co" href="#co_containers_CO1-2" id="callout_containers_CO1-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p><code>ENV</code>: set an environment variable for the app.</p></dd>
<dt><a class="co" href="#co_containers_CO1-3" id="callout_containers_CO1-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p><code>EXPOSE</code>: expose a port to the container network, in this case port TCP 8080.</p></dd>
<dt><a class="co" href="#co_containers_CO1-4" id="callout_containers_CO1-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p><code>WORKDIR</code>: set a directory inside the container to work with.</p></dd>
<dt><a class="co" href="#co_containers_CO1-5" id="callout_containers_CO1-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p><code>COPY</code>: copy the assets from the source code files on your workstation to the container image layer, in this case, to the <code>WORKDIR</code>.</p></dd>
<dt><a class="co" href="#co_containers_CO1-6" id="callout_containers_CO1-6"><img alt="6" height="12" src="assets/6.png" width="12"/></a></dt>
<dd><p><code>RUN</code>: run a command inside the container, using the tools already available within the base image. In this case, it runs the <code>pip</code> tool to install dependencies.</p></dd>
<dt><a class="co" href="#co_containers_CO1-7" id="callout_containers_CO1-7"><img alt="7" height="12" src="assets/7.png" width="12"/></a></dt>
<dd><p><code>ENTRYPOINT</code>: define the entry point for your app inside the container. It can be a binary or a script. In this case, it runs the Python interpreter.</p></dd>
<dt><a class="co" href="#co_containers_CO1-8" id="callout_containers_CO1-8"><img alt="8" height="12" src="assets/8.png" width="12"/></a></dt>
<dd><p><code>CMD</code>: the command that is used when starting a container. In this case it uses the name of the Python app <code>app.py</code>.</p></dd>
</dl>
<p>You <a data-primary="Dockerfiles" data-secondary="defining" data-startref="Dockfile_def" data-type="indexterm" id="idm45120848136192"/>can now create your container image with<a data-primary="container images" data-secondary="creating" data-tertiary="commands" data-type="indexterm" id="idm45120848134784"/> the following command:</p>
<pre data-code-language="bash" data-type="programlisting">docker build -f Dockerfile -t quay.io/gitops-cookbook/pythonapp:latest</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Change the <a data-primary="container images" data-secondary="naming" data-type="indexterm" id="idm45120848414096"/>container image name with the your registry, user, and repo. Example: <code>quay.io/youruser/yourrepo:latest</code>. See <a data-type="xref" href="ch02.xhtml#ch_Requirements">Chapter 2</a> for how to create a new account on registries such as Quay.io.</p>
</div>
<p>Your container image is building now. Docker will fetch <a data-primary="container images" data-secondary="layers" data-type="indexterm" id="idm45120848451664"/>existing layers from a public container registry (DockerHub, Quay, Red Hat Registry, etc.) and add a new layer with the content specified in the Dockerfile. Such layers could also be available locally, if already downloaded, in special storage called a <em>container cache</em> or <em>Docker cache</em>.</p>
<pre data-code-language="text" data-type="programlisting">STEP 1: FROM registry.access.redhat.com/ubi8/python-39
Getting image source signatures
Copying blob adffa6963146 done
Copying blob 4125bdfaec5e done
Copying blob 362566a15abb done
Copying blob 0661f10c38cc done
Copying blob 26f1167feaf7 done
Copying config a531ae7675 done
Writing manifest to image destination
Storing signatures
STEP 2: ENV PORT 8080
--&gt; 6dbf4ac027e
STEP 3: EXPOSE 8080
--&gt; f78357fe402
STEP 4: WORKDIR /usr/src/app
--&gt; 547bf8ca5c5
STEP 5: COPY requirements.txt ./
--&gt; 456cab38c97
STEP 6: RUN pip install --no-cache-dir -r requirements.txt
Collecting Flask
  Downloading Flask-2.0.2-py3-none-any.whl (95 kB)
     |████████████████████████████████| 95 kB 10.6 MB/s
Collecting itsdangerous&gt;=2.0
  Downloading itsdangerous-2.0.1-py3-none-any.whl (18 kB)
Collecting Werkzeug&gt;=2.0
  Downloading Werkzeug-2.0.2-py3-none-any.whl (288 kB)
     |████████████████████████████████| 288 kB 1.7 MB/s
Collecting click&gt;=7.1.2
  Downloading click-8.0.3-py3-none-any.whl (97 kB)
     |████████████████████████████████| 97 kB 31.9 MB/s
Collecting Jinja2&gt;=3.0
  Downloading Jinja2-3.0.3-py3-none-any.whl (133 kB)
     |████████████████████████████████| 133 kB 38.8 MB/s
STEP 7: COPY . .
--&gt; 3e6b73464eb
STEP 8: ENTRYPOINT ["python"]
--&gt; acabca89260
STEP 9: CMD ["app.py"]
STEP 10: COMMIT quay.io/gitops-cookbook/pythonapp:latest
--&gt; 52e134d39af
52e134d39af013a25f3e44d25133478dc20b46626782762f4e46b1ff6f0243bb</pre>
<p>Your container image is now available in your Docker cache and ready to be used. You can verify its <a data-primary="container images" data-secondary="Docker" data-tertiary="cache, verifying" data-type="indexterm" id="idm45120848402976"/><a data-primary="Docker" data-secondary="container images" data-tertiary="verifying" data-type="indexterm" id="idm45120848415568"/>presence with this command:</p>
<pre data-code-language="bash" data-type="programlisting">docker images</pre>
<p>You should get the list of available <a data-primary="container images" data-secondary="list of available" data-type="indexterm" id="idm45120848406304"/><a data-primary="docker pull command" data-type="indexterm" id="idm45120848425856"/>container images from the cache in output. Those could be images you have built or downloaded with the <code>docker pull</code> command:</p>
<pre data-code-language="text" data-type="programlisting">REPOSITORY                           TAG         IMAGE ID      CREATED↳
        SIZE
quay.io/gitops-cookbook/pythonapp    latest      52e134d39af0  6 minutes ago↳
        907 MB</pre>
<p>Once your image is <a data-primary="container images" data-secondary="consuming" data-type="indexterm" id="idm45120848406000"/>created, you can consume it locally or push it to a public container registry to be consumed elsewhere, like from a CI/CD pipeline.</p>
<p>You need to first log in to your<a data-primary="registries" data-secondary="logging into" data-type="indexterm" id="idm45120848318544"/><a data-primary="Quay" data-secondary="logging into" data-type="indexterm" id="idm45120848326032"/> public registry. In this example, we are using Quay:</p>
<pre data-code-language="bash" data-type="programlisting">docker login quay.io</pre>
<p>You should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">Login Succeeded!</pre>
<p>Then you can<a data-primary="container images" data-secondary="pushing to registry" data-type="indexterm" id="idm45120848286320"/><a data-primary="registries" data-secondary="container images, pushing to" data-type="indexterm" id="idm45120848323328"/> push your container image to the registry:</p>
<pre data-code-language="bash" data-type="programlisting">docker push quay.io/gitops-cookbook/pythonapp:latest</pre>
<p>As confirmed, you should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">Getting image source signatures
Copying blob e6e8a2c58ac5 done
Copying blob 3ba8c926eef9 done
Copying blob 558b534f4e1b done
Copying blob 25f82e0f4ef5 done
Copying blob 7b17276847a2 done
Copying blob 352ba846236b done
Copying blob 2de82c390049 done
Copying blob 26525e00a8d8 done
Copying config 52e134d39a done
Writing manifest to image destination
Copying config 52e134d39a [--------------------------------------] 0.0b / 5.4KiB
Writing manifest to image destination
Storing signatures</pre>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45120848292960">
<h2>Discussion</h2>
<p>You can create container images in this way with Docker from your workstation or any host where the Docker service/daemon is running.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Additionally, you can use functionalities offered by a public registry such as <a class="orm:hideurl" href="https://quay.io">Quay.io</a> that can directly create the container image from a Dockerfile and store it to the registry.</p>
</div>
<p>The build requires access to all<a data-primary="container images" data-secondary="layers" data-tertiary="internet connections" data-type="indexterm" id="idm45120848226144"/> layers, thus an internet connection to the registries storing base layers is needed, or at least having them in the container cache. Docker has a layered structure where any change to your app is committed on top of the existing layers, so there’s no need to download all the layers each time since it will add only deltas for each new change.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Container images <a data-primary="container images" data-secondary="layers" data-type="indexterm" id="idm45120848224160"/>typically start from a base OS layer such as Fedora, CentOS, Ubuntu, Alpine, etc. However, they can also start from <code>scratch</code>, an empty layer for super-minimal images containing only the app’s binary. See the <a href="https://oreil.ly/vj0gs"><code>scratch</code> documentation</a> for more info.</p>
</div>
<p>If you want to run your <a data-primary="container images" data-secondary="running" data-type="indexterm" id="idm45120847838688"/>previously created container image, you<a data-primary="docker run command" data-type="indexterm" id="idm45120847837584"/> can do so with this command:</p>
<pre data-code-language="bash" data-type="programlisting">docker run -p <code class="m">8080</code>:8080 -ti quay.io/gitops-cookbook/pythonapp:latest</pre>
<p><code>docker run</code> has many options to start your container. The most common are:</p>
<dl>
<dt><code>-p</code></dt>
<dd>
<p>Binds the port of the container with the port of the host running such container.</p>
</dd>
<dt><code>-t</code></dt>
<dd>
<p>Attaches a TTY to the container.</p>
</dd>
<dt><code>-i</code></dt>
<dd>
<p>Goes into an interactive mode.</p>
</dd>
<dt><code>-d</code></dt>
<dd>
<p>Goes in the background, printing a hash that you can use to interact asynchronously with the running container.</p>
</dd>
</dl>
<p class="pagebreak-before less_space">The preceding command will start your app in the Docker network and bind it to port 8080 of your workstation:</p>
<pre data-code-language="text" data-type="programlisting"> * Serving Flask app 'app' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: on
 * Running on all addresses.
   WARNING: This is a development server. Do not use it in a production deployment.
 * Running on http://10.0.2.100:8080/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger PIN: 103-809-567</pre>
<p>From a new terminal, try <a data-primary="containers" data-secondary="accessing" data-type="indexterm" id="idm45120847789024"/>accessing your running container:</p>
<pre data-code-language="bash" data-type="programlisting">curl http://localhost:8080</pre>
<p>You should get output <a data-primary="Docker" data-secondary="container images" data-startref="Dock_cont_img" data-tertiary="creating" data-type="indexterm" id="idm45120847770864"/><a data-primary="container images" data-secondary="Docker" data-startref="cont_img_Dock" data-tertiary="creating" data-type="indexterm" id="idm45120847789616"/><a data-primary="applications" data-secondary="container images" data-startref="app_contimg_Dock" data-tertiary="creating with Docker" data-type="indexterm" id="idm45120847761312"/>like this:</p>
<pre data-code-language="text" data-type="programlisting">Hello, World!</pre>
</div></section>
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45120848426528">
<h2>See Also</h2>
<ul>
<li>
<p><a href="https://oreil.ly/2hMQD">Best practices for writing Dockerfiles</a></p>
</li>
<li>
<p><a href="https://oreil.ly/hUByf">Manage Docker images</a></p>
</li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="3.2 Building a Container Using Dockerless Jib" data-type="sect1"><div class="sect1" id="recipe_3_2">
<h1>3.2 Building a Container Using Dockerless Jib</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45120847765552">
<h2>Problem</h2>
<p>You are a software developer, and you want to create a container image without installing Docker or any additional software on your workstation.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45120847743056">
<h2>Solution</h2>
<p>As discussed in <a data-type="xref" href="#recipe_3_1">Recipe 3.1</a>, you need to install the Docker engine to create container images. Docker requires permissions to install a service running as a daemon, thus a privileged process in your operating system. <a data-primary="dockerless container images" data-seealso="Jib" data-type="indexterm" id="idm45120847740464"/><a data-primary="container images" data-secondary="Jib, creating" data-type="indexterm" id="cont_img_Jib"/><a data-primary="Jib" data-secondary="container images" data-tertiary="creating" data-type="indexterm" id="J_cont_img"/><a data-primary="dockerless container images" data-secondary="creating" data-type="indexterm" id="D_cont_img"/>Today, <em>dockerless</em> solutions are also available for developers; a popular one is Jib.</p>
<p><a href="https://oreil.ly/NYCtv">Jib</a> is an open source framework for Java made by Google to build OCI-compliant container images, without the need for Docker or any container runtime. Jib comes as a library that Java developers can import in their <a data-primary="Maven" data-type="indexterm" id="idm45120847714656"/><a data-primary="Gradle" data-type="indexterm" id="idm45120847713952"/>Maven or Gradle projects. This means you can create a container image for your app without writing or maintaining any Dockerfiles, delegating <a data-primary="Jib" data-secondary="Dockerfiles" data-type="indexterm" id="idm45120847713152"/>this complexity to Jib.</p>
<p>We see the benefits from this approach as the following:<sup><a data-type="noteref" href="ch03.xhtml#idm45120847711664" id="idm45120847711664-marker">1</a></sup></p>
<dl>
<dt>Pure Java</dt>
<dd>
<p>No<a data-primary="Jib" data-secondary="benefits" data-type="indexterm" id="idm45120847692512"/> Docker or Dockerfile knowledge is required. Simply add Jib as a plug-in, and it will generate the container image for you.</p>
</dd>
<dt>Speed</dt>
<dd>
<p>The application is divided into multiple layers, splitting dependencies from classes. There’s no need to rebuild the container image like for Dockerfiles; Jib takes care of modifying the layers that changed.</p>
</dd>
<dt>Reproducibility</dt>
<dd>
<p>Unnecessary updates are not triggered because the same contents generate the same image.</p>
</dd>
</dl>
<p>The easiest way to kickstart a container image build with Jib on existing <a data-primary="Maven" data-secondary="container images, building" data-type="indexterm" id="idm45120847688608"/>Maven is by adding the <a data-primary="container images" data-secondary="plugins, adding" data-type="indexterm" id="idm45120847687632"/><a data-primary="plugins, building container images with Jib" data-type="indexterm" id="idm45120847686784"/>plug-in via the command line:</p>
<pre data-code-language="bash" data-type="programlisting">mvn compile com.google.cloud.tools:jib-maven-plugin:3.2.0:build -Dimage<code class="o">=</code>&lt;MY IMAGE&gt;</pre>
<p>Alternatively, you can do so by adding Jib as a plug-in into your <em>pom.xml</em>:</p>
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;project&gt;</code>
  ...
  <code class="nt">&lt;build&gt;</code>
    <code class="nt">&lt;plugins&gt;</code>
      ...
      <code class="nt">&lt;plugin&gt;</code>
        <code class="nt">&lt;groupId&gt;</code>com.google.cloud.tools<code class="nt">&lt;/groupId&gt;</code>
        <code class="nt">&lt;artifactId&gt;</code>jib-maven-plugin<code class="nt">&lt;/artifactId&gt;</code>
        <code class="nt">&lt;version&gt;</code>3.2.0<code class="nt">&lt;/version&gt;</code>
        <code class="nt">&lt;configuration&gt;</code>
          <code class="nt">&lt;to&gt;</code>
            <code class="nt">&lt;image&gt;</code>myimage<code class="nt">&lt;/image&gt;</code>
          <code class="nt">&lt;/to&gt;</code>
        <code class="nt">&lt;/configuration&gt;</code>
      <code class="nt">&lt;/plugin&gt;</code>
      ...
    <code class="nt">&lt;/plugins&gt;</code>
  <code class="nt">&lt;/build&gt;</code>
  ...
<code class="nt">&lt;/project&gt;</code></pre>
<p>In this way, you can also manage other settings such as authentication or parameters for the build.</p>
<p>Let’s now add <a data-primary="Jib" data-secondary="Java applications" data-type="indexterm" id="J_java_apps"/><a data-primary="Java, Jib" data-type="indexterm" id="Java_J"/><a data-primary="applications" data-secondary="Java, adding Jib" data-type="indexterm" id="app_Java_J"/>Jib to an existing Java application, a Hello World application in Spring Boot that you can find in the <a href="https://oreil.ly/dn1LF">book’s repository</a>.</p>
<p>Run the following command to create a container image without using Docker, and push it directly to a container registry. In this example, we use Quay.io, and we will store the container image at <em>quay.io/gitops-cookbook/jib-example:latest</em>, so you will need to provide your credentials for the registry:</p>
<pre data-code-language="bash" data-type="programlisting">mvn compile com.google.cloud.tools:jib-maven-plugin:3.2.0:build <code class="se">\</code>
-Dimage<code class="o">=</code>quay.io/gitops-cookbook/jib-example:latest <code class="se">\</code>
-Djib.to.auth.username<code class="o">=</code>&lt;USERNAME&gt; <code class="se">\</code>
-Djib.to.auth.password<code class="o">=</code>&lt;PASSWORD&gt;</pre>
<p>The authentication<a data-primary="authentication" data-secondary="Jib" data-type="indexterm" id="idm45120847601632"/> here is handled with command-line options, but Jib can manage existing authentication with Docker CLI or read credentials from your <em>settings.xml</em> file.</p>
<p>The build takes a few moments, and the result is a Java-specific container image, based on the <em>adoptOpenJDK</em> base image, built locally and pushed directly to a registry. In this case, to Quay.io:</p>
<pre data-code-language="text" data-type="programlisting">[INFO] Scanning for projects...
[INFO]
[INFO] --------------------------&lt; com.redhat:hello &gt;--------------------------
[INFO] Building hello 0.0.1-SNAPSHOT
[INFO] --------------------------------[ jar ]---------------------------------
...
[INFO] Containerizing application to quay.io/gitops-cookbook/jib-example...
[INFO] Using credentials from &lt;to&gt;&lt;auth&gt; for quay.io/gitops-cookbook/jib-example
[INFO] The base image requires auth. Trying again for eclipse-temurin:11-jre...
[INFO] Using base image with digest:↳
 sha256:83d92ee225e443580cc3685ef9574582761cf975abc53850c2bc44ec47d7d943O]
[INFO]
[INFO] Container entrypoint set to [java, -cp, @/app/jib-classpath-file,↳
 com.redhat.hello.HelloApplication]FO]
[INFO]
[INFO] Built and pushed image as quay.io/gitops-cookbook/jib-example
[INFO] Executing tasks:
[INFO] [==============================] 100,0% complete
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time:  41.366 s
[INFO] Finished at: 2022-01-25T19:04:09+01:00
[INFO] ------------------------------------------------------------------------</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you have Docker and run <a data-primary="docker images command" data-type="indexterm" id="idm45120847565680"/>the command <code>docker images</code>, you won’t see this image in your local <a data-primary="Jib" data-secondary="Java applications" data-startref="J_java_apps" data-type="indexterm" id="idm45120847597728"/><a data-primary="Java, Jib" data-startref="Java_J" data-type="indexterm" id="idm45120847596576"/><a data-primary="applications" data-secondary="Java, adding Jib" data-startref="app_Java_J" data-type="indexterm" id="idm45120847595632"/>cache!</p>
</div>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45120847742432">
<h2>Discussion</h2>
<p>Your <a data-primary="Jib" data-secondary="container images" data-tertiary="storing in cache" data-type="indexterm" id="idm45120847570096"/>container image is not present in your local cache, as you don’t need any container runtime to build images with Jib. You won’t see it with the <code>docker images</code> command, but you can pull it from the public container registry afterward, and it will store it in your cache.</p>
<p>This approach is suitable for development velocity and automation, where the CI system doesn’t need to have Docker installed on the nodes where it runs. Jib can create the container image without any Dockerfiles. Additionally, it can push the image to a container registry.</p>
<p>If you also want to store it locally from the beginning, Jib can connect to Docker hosts and do it for you.</p>
<p>You can pull your container image from the registry to try it:</p>
<pre data-code-language="bash" data-type="programlisting">docker run -p <code class="m">8080</code>:8080 -ti quay.io/gitops-cookbook/jib-example</pre>
<pre data-code-language="text" data-type="programlisting">Trying to pull quay.io/gitops-cookbook/jib-example:latest...
Getting image source signatures
Copying blob ea362f368469 done
Copying blob d5cc550bb6a0 done
Copying blob bcc17963ea24 done
Copying blob 9b46d5d971fa done
Copying blob 51f4f7c353f0 done
Copying blob 43b2cdfa19bb done
Copying blob fd142634d578 done
Copying blob 78c393914c97 done
Copying config 346462b8d3 done
Writing manifest to image destination
Storing signatures

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::                (v2.6.3)

2022-01-25 18:36:24.762  INFO 1 --- [ main] com.redhat.hello.HelloApplication↳
        : Starting HelloApplication using Java 11.0.13 on a719cf76f440 with PID 1↳
         (/app/classes started by root in /)
2022-01-25 18:36:24.765  INFO 1 --- [ main] com.redhat.hello.HelloApplication↳
        : No active profile set, falling back to default profiles: default
2022-01-25 18:36:25.700  INFO 1 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer↳
  : Tomcat initialized with port(s): 8080 (http)
2022-01-25 18:36:25.713  INFO 1 --- [ main] o.apache.catalina.core.StandardService↳
   : Starting service [Tomcat]
2022-01-25 18:36:25.713  INFO 1 --- [ main] org.apache.catalina.core.StandardEngine↳
  : Starting Servlet engine: [Apache Tomcat/9.0.56]
2022-01-25 18:36:25.781  INFO 1 --- [ main] o.a.c.c.C.[Tomcat].[localhost].[/]↳
       : Initializing Spring embedded WebApplicationContext
2022-01-25 18:36:25.781  INFO 1 --- [ main] w.s.c.ServletWebServerApplicationContext↳
 : Root WebApplicationContext: initialization completed in 947 ms
2022-01-25 18:36:26.087  INFO 1 --- [ main] o.s.b.w.embedded.tomcat.TomcatWebServer↳
  : Tomcat started on port(s): 8080 (http) with context path ''
2022-01-25 18:36:26.096  INFO 1 --- [ main] com.redhat.hello.HelloApplication↳
        : Started HelloApplication in 1.778 seconds (JVM running for 2.177)</pre>
<p>Get the <code>hello</code> <a data-primary="container images" data-secondary="Jib, creating" data-startref="cont_img_Jib" data-type="indexterm" id="idm45120847554320"/><a data-primary="Jib" data-secondary="container images" data-startref="J_cont_img" data-tertiary="creating" data-type="indexterm" id="idm45120847553344"/><a data-primary="dockerless container images" data-secondary="creating" data-startref="D_cont_img" data-type="indexterm" id="idm45120847550160"/>endpoint:</p>
<pre data-code-language="bash" data-type="programlisting">curl localhost:8080/hello</pre>
<pre data-code-language="json" data-type="programlisting"><code class="p">{</code><code class="nt">"id"</code><code class="p">:</code><code class="mi">1</code><code class="p">,</code><code class="nt">"content"</code><code class="p">:</code><code class="s2">"Hello, World!"</code><code class="p">}</code><code class="w"/></pre>
</div></section>
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45120847571328">
<h2>See Also</h2>
<ul>
<li>
<p><a href="https://oreil.ly/sTcpJ">Using Jib with Quarkus projects</a></p>
</li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="3.3 Building a Container Using Buildah" data-type="sect1"><div class="sect1" id="recipe_3_3">
<h1>3.3 Building a Container Using Buildah</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45120847491824">
<h2>Problem</h2>
<p>Sometimes installing or managing Docker is not possible. Dockerless solutions for creating container images are useful in use cases such as local development or CI/CD systems.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45120847454704">
<h2>Solution</h2>
<p>The OCI <a data-primary="OCI containers" data-secondary="building" data-type="indexterm" id="OCI_cont_build"/><a data-primary="container images" data-secondary="OCI, building" data-type="indexterm" id="cont_img_build"/>specification is an open standard, and this favors multiple open source implementations for the container engine and the container image building mechanism. Two growing popular examples today are <a href="https://podman.io">Podman</a> and <a href="https://buildah.io">Buildah</a>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>While Docker uses a single monolithic application for creating, running, and shipping container images, the codebase for container management functionalities here has been split between different projects like Podman, Buildah, and Skopeo. <a data-primary="Podman, OS support" data-type="indexterm" id="idm45120847447616"/><a data-primary="Buildah, OS support" data-type="indexterm" id="idm45120847446912"/>Podman support is already available on Mac and Windows, however Buildah is currently only available on Linux or Linux subsystems such as WSL2 for Windows. See the <a href="https://oreil.ly/W9l1a">documentation</a> to install it on your workstation.</p>
</div>
<p>Those are two complementary open source projects and command-line tools that work on OCI containers and images; however, they differ in their specialization. While Podman specializes in commands and functions that help you to maintain and modify container images, such as pulling, tagging, and pushing, Buildah specializes<a data-primary="Buildah" data-secondary="container images" data-tertiary="creating" data-type="indexterm" id="Buildah_cont_img"/><a data-primary="container images" data-secondary="Buildah, creating" data-type="indexterm" id="cont_img_Buildah"/> in building container images. Decoupling functions in different processes is done by design, as the authors wanted to move from the single privileged process Docker model to a lightweight, rootless, daemonless, and decoupled set of tools to improve agility and security.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Following the same approach, you<a data-primary="Skopeo" data-type="indexterm" id="idm45120847425152"/> find <a href="https://oreil.ly/oJnAK">Skopeo</a>, a tool used to move container images; and <a href="https://cri-o.io">CRI-O</a>, a <a data-primary="CRI-O" data-type="indexterm" id="idm45120847423168"/>container engine complaint with the Kubernetes container runtime interface for running applications.</p>
</div>
<p>Buildah supports <a data-primary="Buildah" data-secondary="Dockerfile" data-type="indexterm" id="idm45120847421808"/><a data-primary="Dockerfiles" data-secondary="Buildah" data-type="indexterm" id="idm45120847420960"/>the Dockerfile format, but its goal is to provide a lower-level interface to build container images without requiring a Dockerfile. Buildah is a daemonless solution that can create images inside a container without mounting the Docker socket. This functionality improves security and portability since it’s easy to add Buildah builds on the fly to a CI/CD pipeline where the Linux or Kubernetes nodes do not require a Docker installation.</p>
<p>As we discussed, you can create a container image with or without a Dockerfile. Let’s now create a simple<a data-primary="HTTPD container image, creating" data-type="indexterm" id="idm45120847419472"/><a data-primary="container images" data-secondary="HTTPD, creating" data-type="indexterm" id="idm45120847418864"/> HTTPD container image without a Dockerfile.</p>
<p>You can start from any base image such as <a data-primary="Centos, container images" data-type="indexterm" id="idm45120847417504"/><a data-primary="container images" data-secondary="Centos" data-type="indexterm" id="idm45120847416896"/>CentOS:</p>
<pre data-code-language="bash" data-type="programlisting">buildah from centos</pre>
<p>You should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">Resolved short name "centos" to a recorded short-name alias↳
 (origin: /etc/containers/registries.conf.d/shortnames.conf)
Getting image source signatures
Copying blob 926a85fb4806 done
Copying config 2f3766df23 done
Writing manifest to image destination
Storing signatures
centos-working-container</pre>
<div data-type="tip"><h6>Tip</h6>
<p>Similarly to Docker and <code>docker images</code>, you can run the <a data-primary="buildah containers command" data-type="indexterm" id="idm45120847413296"/>command <code>buildah containers</code> to get the list of available images from the container cache. If you also have installed Podman, this is similar to <code>podman images</code>.</p>
</div>
<p>In this case, the container image ID is <code>centos-working-container</code>, and you can refer to it for creating the other layers.</p>
<p>Now let’s install <a data-primary="httpd package, installing" data-type="indexterm" id="idm45120847412176"/>the <code>httpd</code> package inside a new layer:</p>
<pre data-code-language="bash" data-type="programlisting">buildah run centos-working-container yum install httpd -y</pre>
<p>You should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">CentOS Linux 8 - AppStream                          9.0 MB/s | 8.4 MB     00:00
CentOS Linux 8 - BaseOS                             436 kB/s | 4.6 MB     00:10
CentOS Linux 8 - Extras                              23 kB/s |  10 kB     00:00
Dependencies resolved.
===============================================================================
 Package                      Arch    Version         Repository     Size
===============================================================================
Installing:
 httpd                        x86_64  2.4.37-43.module_el8.5.0+1022+b541f3b1
Installing dependencies:
 apr                          x86_64  1.6.3-12.el8
 apr-util                     x86_64  1.6.1-6.el8
 brotli                       x86_64  1.0.6-3.el8
 centos-logos-httpd           noarch  85.8-2.el8
 httpd-filesystem             noarch  2.4.37-43.module_el8.5.0+1022+b541f3b1
 httpd-tools                  x86_64  2.4.37-43.module_el8.5.0+1022+b541f3b1
 mailcap                      noarch  2.1.48-3.el8
 mod_http2                    x86_64  1.15.7-3.module_el8.4.0+778+c970deab
Installing weak dependencies:
 apr-util-bdb                 x86_64  1.6.1-6.el8
 apr-util-openssl             x86_64  1.6.1-6.el8
Enabling module streams:
...
Complete!</pre>
<p>Now let’s copy a welcome<a data-primary="welcome page, copying to container" data-type="indexterm" id="idm45120847379568"/> HTML page inside the container running HTTPD. You can find the source code in <a href="https://oreil.ly/azx91">this book’s repo</a>:</p>
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">html</code><code class="p">&gt;</code>
    <code class="p">&lt;</code><code class="nt">head</code><code class="p">&gt;</code>
        <code class="p">&lt;</code><code class="nt">title</code><code class="p">&gt;</code>GitOps CookBook example<code class="p">&lt;/</code><code class="nt">title</code><code class="p">&gt;</code>
    <code class="p">&lt;/</code><code class="nt">head</code><code class="p">&gt;</code>
    <code class="p">&lt;</code><code class="nt">body</code><code class="p">&gt;</code>
        <code class="p">&lt;</code><code class="nt">h1</code><code class="p">&gt;</code>Hello, World!<code class="p">&lt;/</code><code class="nt">h1</code><code class="p">&gt;</code>
    <code class="p">&lt;/</code><code class="nt">body</code><code class="p">&gt;</code>
<code class="p">&lt;/</code><code class="nt">html</code><code class="p">&gt;</code></pre>
<pre data-code-language="bash" data-type="programlisting">buildah copy centos-working-container index.xhtml /var/www/html/index.xhtml</pre>
<p>For each new layer added, you should get output with the new container image hash, similar to the following:</p>
<pre data-code-language="text" data-type="programlisting">78c6e1dcd6f819581b54094fd38a3fd8f170a2cb768101e533c964e04aacab2e</pre>
<pre data-code-language="bash" data-type="programlisting">buildah config --entrypoint <code class="s2">"/usr/sbin/httpd -DFOREGROUND"</code> centos-working-container</pre>
<pre data-code-language="bash" data-type="programlisting">buildah commit centos-working-container quay.io/gitops-cookbook/gitops-website</pre>
<p class="less_space pagebreak-before">You should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">Getting image source signatures
Copying blob 618ce6bf40a6 skipped: already exists
Copying blob eb8c13ba832f done
Copying config b825e91208 done
Writing manifest to image destination
Storing signatures
b825e91208c33371e209cc327abe4f53ee501d5679c127cd71c4d10cd03e5370</pre>
<p>Your container image is now in the container cache, ready to run or push to another registry.</p>
<p>As mentioned before, Buildah can also create container images from a Dockerfile. Let’s make the same container image from the Dockerfile listed here:</p>
<pre data-code-language="text" data-type="programlisting">FROM centos:latest
RUN yum -y install httpd
COPY index.xhtml /var/www/html/index.xhtml
EXPOSE 80
CMD ["/usr/sbin/httpd", "-DFOREGROUND"]</pre>
<pre data-code-language="bash" data-type="programlisting">buildah bud -f Dockerfile -t quay.io/gitops-cookbook/gitops-website</pre>
<pre data-code-language="text" data-type="programlisting">STEP 1: FROM centos:latest
Resolved short name "centos" to a recorded short-name alias↳
 (origin: /etc/containers/registries.conf.d/shortnames.conf)
Getting image source signatures
Copying blob 926a85fb4806 done
Copying config 2f3766df23 done
Writing manifest to image destination
Storing signatures
STEP 2: RUN yum -y install httpd
CentOS Linux 8 - AppStream                      9.6 MB/s | 8.4 MB     00:00
CentOS Linux 8 - BaseOS                         7.5 MB/s | 4.6 MB     00:00
CentOS Linux 8 - Extras                          63 kB/s |  10 kB     00:00
Dependencies resolved.
...
Complete!
STEP 3: COPY index.xhtml /var/www/html/index.xhtml
STEP 4: EXPOSE 80
STEP 5: CMD ["/usr/sbin/httpd", "-DFOREGROUND"]
STEP 6: COMMIT quay.io/gitops-cookbook/gitops-website
Getting image source signatures
Copying blob 618ce6bf40a6 skipped: already exists
Copying blob 1be523a47735 done
Copying config 3128caf147 done
Writing manifest to image destination
Storing signatures
--&gt; 3128caf1475
3128caf147547e43b84c13c241585d23a32601f2c2db80b966185b03cb6a8025</pre>
<p>If you have also installed Podman, you can run it this way:</p>
<pre data-code-language="bash" data-type="programlisting">podman run -p <code class="m">8080</code>:80 -ti quay.io/gitops-cookbook/gitops-website</pre>
<p>Then you <a data-primary="OCI containers" data-secondary="building" data-startref="OCI_cont_build" data-type="indexterm" id="idm45120847125472"/><a data-primary="container images" data-secondary="OCI, building" data-startref="cont_img_build" data-type="indexterm" id="idm45120847124576"/>can test it by opening the browser on <a class="bare" href="http://localhost:8080"><em class="hyperlink">http://localhost:8080</em></a>.</p>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45120847453760">
<h2>Discussion</h2>
<p>With Buildah, you have the opportunity to create container images from scratch or starting from a Dockerfile. You don’t need to install Docker, and everything is designed around security: rootless mechanism, daemonless utilities, and more refined control of creating image layers.</p>
<p>Buildah can also build images <a data-primary="Buildah" data-secondary="container images" data-tertiary="building from scratch" data-type="indexterm" id="idm45120847127776"/>from scratch, thus it creates an empty layer similar to the <code>FROM scratch</code> Dockerfile statement. This aspect is useful for creating very lightweight images containing only the packages needed to run your application, as you can see in <a data-type="xref" href="#fig3-2">Figure 3-2</a>.</p>
<figure><div class="figure" id="fig3-2">
<img alt="Buildah image shrink" height="722" src="assets/gocb_0302.png" width="1220"/>
<h6><span class="label">Figure 3-2. </span>Buildah image shrink</h6>
</div></figure>
<p>A good example use case for a scratch build is considering the development images versus staging or production images. During development, container images may require a compiler and other tools. However, in production, you may only need the runtime or your <a data-primary="Buildah" data-secondary="container images" data-startref="Buildah_cont_img" data-tertiary="creating" data-type="indexterm" id="idm45120847106592"/><a data-primary="container images" data-secondary="Buildah, creating" data-startref="cont_img_Buildah" data-type="indexterm" id="idm45120847105072"/>packages.</p>
</div></section>
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45120847103472">
<h2>See Also</h2>
<ul>
<li>
<p><a href="https://oreil.ly/GUfss">Running Buildah inside a container</a></p>
</li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="3.4 Building a Container with Buildpacks" data-type="sect1"><div class="sect1" id="recipe_3_4">
<h1>3.4 Building a Container with Buildpacks</h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45120847066448">
<h2>Problem</h2>
<p>Creating container image by using Dockerfiles can be challenging at scale. You want a tool complementing Docker that can inspect your application source code to create container images without writing a Dockerfile.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45120847065056">
<h2>Solution</h2>
<p><a href="https://oreil.ly/psc6h">Cloud Native Buildpacks</a> <a data-primary="Cloud Native Buildpacks" data-see="Buildpacks" data-type="indexterm" id="idm45120847062608"/>is an open<a data-primary="container images" data-secondary="Buildpacks" data-type="indexterm" id="cont_img_Bpacks"/><a data-primary="Buildpacks" data-secondary="container images, creating" data-type="indexterm" id="Bpacks_cont_img"/> source project that provides a set of executables to inspect your app source code and to create a plan to build and run your application.</p>
<p>Buildpacks can create OCI-compliant container images without a Dockerfile, starting from the app source code, as you can see in <a data-type="xref" href="#fig3-3">Figure 3-3</a>.</p>
<figure><div class="figure" id="fig3-3">
<img alt="Buildpacks builds" height="248" src="assets/gocb_0303.png" width="728"/>
<h6><span class="label">Figure 3-3. </span>Buildpacks builds</h6>
</div></figure>
<p>This mechanism consists of two phases:</p>
<dl>
<dt>Detection</dt>
<dd>
<p>Buildpacks tooling will navigate your source code to discover which programming language or framework is used (e.g., POM, NPM files, Python requirements, etc.) and assign a suitable buildpack for the build.</p>
</dd>
<dt>Building</dt>
<dd>
<p>Once a buildpack is found, the source is compiled and Buildpacks creates a container image with the appropriate entry point and startup scripts.</p>
</dd>
</dl>
<p>To use Buildpacks, you have to download the <a href="https://oreil.ly/K0gGM">pack</a> CLI for your operating system (Mac, Windows, Linux), and also have Docker installed.</p>
<div data-type="tip"><h6>Tip</h6>
<p>On macOS, <code>pack</code> is available through<a data-primary="Buildpacks" data-secondary="Homebrew" data-type="indexterm" id="idm45120847051120"/><a data-primary="Homebrew, Buildpacks" data-type="indexterm" id="idm45120847050272"/> <a href="https://brew.sh">Homebrew</a> as follows:</p>
<pre data-type="programlisting">brew install buildpacks/tap/pack</pre>
</div>
<p>Now let’s start creating our container image with Buildpacks from a sample Node.js<a data-primary="Node.js, Buildpacks container images" data-type="indexterm" id="idm45120847047776"/> app. You can find the app source code in this <a href="https://oreil.ly/eViRN">book’s repository</a>:</p>
<pre data-code-language="bash" data-type="programlisting"><code class="nb">cd</code> chapters/ch03/nodejs-app</pre>
<p>The app directory structure contains a <em>package.json</em> file, a <a data-primary="manifests" data-secondary="Node.js packages" data-type="indexterm" id="idm45120847038320"/>manifest listing Node.js packages required for this build, which helps Buildpacks understand which buildpack to use.</p>
<p>You can verify it with<a data-primary="pack builder suggest command" data-type="indexterm" id="idm45120847036832"/> this command:</p>
<pre data-code-language="bash" data-type="programlisting">pack builder suggest</pre>
<p>You should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">Suggested builders:
        Google:                gcr.io/buildpacks/builder:v1↳
              Ubuntu 18 base image with buildpacks for .NET, Go, Java, Node.js,↳
              and Python
        Heroku:                heroku/buildpacks:18↳
               Base builder for Heroku-18 stack, based on ubuntu:18.04 base↳
               image
        Heroku:                heroku/buildpacks:20↳
               Base builder for Heroku-20 stack, based on ubuntu:20.04 base↳
               image
        Paketo Buildpacks:     paketobuildpacks/builder:base↳
               Ubuntu bionic base image with buildpacks for Java, .NET Core,↳
               Node.js, Go, Python, Ruby, NGINX and Procfile
        Paketo Buildpacks:     paketobuildpacks/builder:full↳
               Ubuntu bionic base image with buildpacks for Java, .NET Core,↳
               Node.js, Go, Python, PHP, Ruby, Apache HTTPD, NGINX and Procfile
        Paketo Buildpacks:     paketobuildpacks/builder:tiny↳
               Tiny base image (bionic build image, distroless-like run image)↳
               with buildpacks for Java, Java Native Image and Go</pre>
<p>Now you can decide to pick one of the suggested buildpacks. Let’s try the <code>paketobuildpacks/builder:base</code>, which also contains the Node.js runtime:</p>
<pre data-code-language="bash" data-type="programlisting">pack build nodejs-app --builder paketobuildpacks/builder:base</pre>
<div data-type="tip"><h6>Tip</h6>
<p>Run <code>pack builder inspect paketobuildpacks/builder:base</code><a data-primary="pack builder inspect paketobuildpacks/builder:base command" data-type="indexterm" id="idm45120847010832"/> to know the exact content of libraries and frameworks available in this buildpack.</p>
</div>
<p>The building process should start accordingly, and after a while, it should finish, and you should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">base: Pulling from paketobuildpacks/builder
bf99a8b93828: Pulling fs layer
...
Digest: sha256:7034e52388c11c5f7ee7ae8f2d7d794ba427cc2802f687dd9650d96a70ac0772
Status: Downloaded newer image for paketobuildpacks/builder:base
base-cnb: Pulling from paketobuildpacks/run
bf99a8b93828: Already exists
9d58a4841c3f: Pull complete
77a4f59032ac: Pull complete
24e58505e5e0: Pull complete
Digest: sha256:59aa1da9db6d979e21721e306b9ce99a7c4e3d1663c4c20f74f9b3876cce5192
Status: Downloaded newer image for paketobuildpacks/run:base-cnb
===&gt; ANALYZING
Previous image with name "nodejs-app" not found
===&gt; DETECTING
5 of 10 buildpacks participating
paketo-buildpacks/ca-certificates 3.0.1
paketo-buildpacks/node-engine     0.11.2
paketo-buildpacks/npm-install     0.6.2
paketo-buildpacks/node-module-bom 0.2.0
paketo-buildpacks/npm-start       0.6.1
===&gt; RESTORING
===&gt; BUILDING
...
Paketo NPM Start Buildpack 0.6.1
  Assigning launch processes
    web: node server.js

===&gt; EXPORTING
Adding layer 'paketo-buildpacks/ca-certificates:helper'
Adding layer 'paketo-buildpacks/node-engine:node'
Adding layer 'paketo-buildpacks/npm-install:modules'
Adding layer 'launch.sbom'
Adding 1/1 app layer(s)
Adding layer 'launcher'
Adding layer 'config'
Adding layer 'process-types'
Adding label 'io.buildpacks.lifecycle.metadata'
Adding label 'io.buildpacks.build.metadata'
Adding label 'io.buildpacks.project.metadata'
Setting default process type 'web'
Saving nodejs-app...
*** Images (82b805699d6b):
      nodejs-app
Adding cache layer 'paketo-buildpacks/node-engine:node'
Adding cache layer 'paketo-buildpacks/npm-install:modules'
Adding cache layer 'paketo-buildpacks/node-module-bom:cyclonedx-node-module'
Successfully built image nodejs-app</pre>
<p>Now let’s run it with Docker:</p>
<pre data-code-language="bash" data-type="programlisting">docker run --rm -p <code class="m">3000</code>:3000 nodejs-app</pre>
<p>You should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">Server running at http://0.0.0.0:3000/</pre>
<p class="less_space pagebreak-before">View the running application:</p>
<pre data-code-language="bash" data-type="programlisting">curl http://localhost:3000/</pre>
<p>You should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">Hello Buildpacks!</pre>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45120846930224">
<h2>Discussion</h2>
<p>Cloud Native Buildpacks is an incubating project in the Cloud Native Computing Foundation (CNCF), and it supports both Docker and Kubernetes.
On Kubernetes, it can be used with <a href="https://tekton.dev">Tekton</a>, a Kubernetes-native CI/CD system that can run Buildpacks as a Tekton <code>Task</code> to create container images.
It recently adopted the <a href="https://oreil.ly/F0OTs">Boson Project</a> to provide a functions-as-a-service (FaaS) experience on Kubernetes with Knative, by enabling the build of functions via <a data-primary="container images" data-secondary="Buildpacks" data-startref="cont_img_Bpacks" data-type="indexterm" id="idm45120846885776"/><a data-primary="Buildpacks" data-secondary="container images, creating" data-startref="Bpacks_cont_img" data-type="indexterm" id="idm45120846884864"/>buildpacks.</p>
</div></section>
<section data-pdf-bookmark="See Also" data-type="sect2"><div class="sect2" id="idm45120846890848">
<h2>See Also</h2>
<ul>
<li>
<p><a href="https://oreil.ly/wFIHd">Using Buildpacks with Tekton Pipelines</a></p>
</li>
<li>
<p><a href="https://oreil.ly/p1U6n">FaaS Knative Boson project’s buildpacks</a></p>
</li>
</ul>
</div></section>
</div></section>
<section data-pdf-bookmark="3.5 Building a Container Using Shipwright and kaniko &#10;in Kubernetes" data-type="sect1"><div class="sect1" id="recipe_3_5">
<h1>3.5 Building a Container Using Shipwright and kaniko 
<span class="keep-together">in Kubernetes</span></h1>
<section data-pdf-bookmark="Problem" data-type="sect2"><div class="sect2" id="idm45120846852128">
<h2>Problem</h2>
<p>You need to create a container image, and you want to do it with Kubernetes.</p>
</div></section>
<section data-pdf-bookmark="Solution" data-type="sect2"><div class="sect2" id="idm45120846850544">
<h2>Solution</h2>
<p>Kubernetes is<a data-primary="Kubernetes" data-secondary="container images, building with Shipwright" data-type="indexterm" id="K_contimg_shipw"/><a data-primary="container images" data-secondary="Kubernetes, building with Shipwright" data-type="indexterm" id="contimg_K_shipw"/><a data-primary="Shipwright, building container images" data-type="indexterm" id="Shipw_contimg"/> well known as a container orchestration platform to deploy and manage apps. However, it doesn’t include support for building container images 
<span class="keep-together">out-of-the-box</span>.
Indeed, according to <a href="https://oreil.ly/qgpKi">Kubernetes documentation</a>: “(Kubernetes) Does not deploy source code and does not build your application. Continuous Integration, Delivery, and Deployment (CI/CD) workflows are determined by organization cultures and preferences as well as technical 
<span class="keep-together">requirements</span>.”</p>
<p>As mentioned, one standard option is to rely on CI/CD systems for this purpose, like Tekton (see <a data-type="xref" href="ch06.xhtml#ch_Cloud_Native_CICD">Chapter 6</a>). Another option is to use a framework to manage builds with many underlying tools, such as the one we discussed in the previous recipes. One example is Shipwright.</p>
<p><a href="https://shipwright.io">Shipwright</a> is an extensible framework for building container images on Kubernetes. It supports popular tools such as Buildah, Cloud Native Buildpacks, and <a data-primary="kaniko" data-type="indexterm" id="kaniko"/>kaniko. It uses Kubernetes-style APIs, and it runs workloads using <a data-primary="Tekton" data-type="indexterm" id="idm45120846827232"/>Tekton.</p>
<p>The benefit for developers is a simplified approach for building container images, by defining a minimal YAML file that does not require any previous knowledge of containers or container engines. This approach makes this solution agnostic and highly integrated with the Kubernetes API ecosystem.</p>
<p>The first thing to do is to install Shipwright to your Kubernetes cluster, say kind or Minikube (see <a data-type="xref" href="ch02.xhtml#ch_Requirements">Chapter 2</a>), following the <a href="https://oreil.ly/FWvXv">documentation</a> or from <a href="https://oreil.ly/6Ds5R">OperatorHub.io</a>.</p>
<div data-type="tip"><h6>Tip</h6>
<p>Using Operators and Operator Lifecycle Manager (OLM) gives consistency for installing/uninstalling software on Kubernetes, along with dependency management and lifecycle control. For instance, the Tekton Operator dependency is automatically resolved and installed if you install Shipwright via the Operator. Check the OLM <a href="https://oreil.ly/V3k2p">documentation</a> for details with this approach.</p>
</div>
<p>Let’s follow the standard procedure from the documentation. First you need to install the Tekton dependency. At the time of writing this book, it is version <code>0.30.0</code>:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl apply -f <code class="se">\</code>
  https://storage.googleapis.com/tekton-releases/pipeline/previous/v0.30.0/release.yaml</pre>
<p>Then you install Shipwright. At the time of writing this book, it is version <code>0.7.0</code>:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl apply -f <code class="se">\</code>
  https://github.com/shipwright-io/build/releases/download/v0.7.0/release.yaml</pre>
<p>Finally, you install Shipwright build strategies:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl apply -f <code class="se">\</code>
  https://github.com/shipwright-io/build/releases/download/v0.7.0/sample-strategies.yaml</pre>
<p>Once you have installed Shipwright, you can start creating your container image build using one of these tools:</p>
<ul>
<li>
<p>kaniko</p>
</li>
<li>
<p>Cloud Native Buildpacks</p>
</li>
<li>
<p>BuildKit</p>
</li>
<li>
<p>Buildah</p>
</li>
</ul>
<p>Let’s explore kaniko.</p>
<p><a href="https://oreil.ly/ncdWg">kaniko</a> is another dockerless <a data-primary="dockerless container images" data-secondary="kaniko" data-type="indexterm" id="idm45120846784432"/>solution to build container images from a Dockerfile inside a container or Kubernetes cluster. Shipwright brings additional APIs to Kubernetes to use tools such as kaniko to create container images, acting as an abstract layer that can be considered an extensible building system for Kubernetes.</p>
<p>Let’s explore the APIs that are defined from Cluster Resource Definitions (CRDs):</p>
<dl>
<dt><code>ClusterBuildStrategy</code></dt>
<dd>
<p>Represents the type of build to execute.</p>
</dd>
<dt><code>Build</code></dt>
<dd>
<p>Represents the build. It includes the specification of one <code>ClusterBuildStrategy</code> object.</p>
</dd>
<dt><code>BuildRun</code></dt>
<dd>
<p>Represents a running build. The build starts when this object is created.</p>
</dd>
</dl>
<p>Run the following command to check all available <code>ClusterBuildStrategy</code> (CBS) objects:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl get cbs</pre>
<p>You should get a list of available CBSs to consume:</p>
<pre data-code-language="text" data-type="programlisting">NAME                     AGE
buildah                  26s
buildkit                 26s
buildpacks-v3            26s
buildpacks-v3-heroku     26s
kaniko                   26s
kaniko-trivy             26s
ko                       26s
source-to-image          26s
source-to-image-redhat   26s</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>This CRD is cluster-wide, available for all namespaces. If you don’t see any items, please install the Shipwright build strategies as discussed previously.</p>
</div>
<p>Shipwright will generate a container image on the Kubernetes nodes container cache, and then it can push it to a container registry.</p>
<p>You need to provide the credentials to push the image to the registry in the form of a Kubernetes Secret.
For example, if you use Quay <a data-primary="Quay" data-secondary="Kubernetes Secrets" data-type="indexterm" id="idm45120846725776"/><a data-primary="Kubernetes Secrets" data-type="indexterm" id="idm45120846725136"/>you can create one like the following:</p>
<pre data-code-language="bash" data-type="programlisting"><code class="nv">REGISTRY_SERVER</code><code class="o">=</code>quay.io
<code class="nv">REGISTRY_USER</code><code class="o">=</code>&lt;your_registry_user&gt;
<code class="nv">REGISTRY_PASSWORD</code><code class="o">=</code>&lt;your_registry_password&gt;
<code class="nv">EMAIL</code><code class="o">=</code>&lt;your_email&gt;
kubectl create secret docker-registry push-secret <code class="se">\</code>
    --docker-server<code class="o">=</code><code class="nv">$REGISTRY_SERVER</code> <code class="se">\</code>
    --docker-username<code class="o">=</code><code class="nv">$REGISTRY_USER</code> <code class="se">\</code>
    --docker-password<code class="o">=</code><code class="nv">$REGISTRY_PASSWORD</code>  <code class="se">\</code>
    --docker-email<code class="o">=</code><code class="nv">$EMAIL</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>With Quay, you can use an encrypted password instead of using your account password. See the documentation for more details.</p>
</div>
<p>Now let’s<a data-primary="build-kaniko.yaml file" data-type="indexterm" id="idm45120846674432"/> create a <em>build-kaniko.yaml</em> file containing the <code>Build</code> object that will use kaniko to containerize a Node.js sample app. You can find the source code in this <a href="https://oreil.ly/S84zu">book’s repository</a>:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shipwright.io/v1alpha1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Build</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">buildpack-nodejs-build</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">source</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">url</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://github.com/shipwright-io/sample-nodejs</code><code class="w"> </code><a class="co" href="#callout_containers_CO2-1" id="co_containers_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">    </code><code class="nt">contextDir</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">docker-build</code><code class="w"> </code><a class="co" href="#callout_containers_CO2-2" id="co_containers_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="nt">strategy</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kaniko</code><code class="w"> </code><a class="co" href="#callout_containers_CO2-3" id="co_containers_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a><code class="w">
</code><code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterBuildStrategy</code><code class="w">
</code><code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">quay.io/gitops-cookbook/sample-nodejs:latest</code><code class="w"> </code><a class="co" href="#callout_containers_CO2-4" id="co_containers_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a><code class="w">
</code><code class="w">    </code><code class="nt">credentials</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">push-secret</code><code class="w"> </code><a class="co" href="#callout_containers_CO2-5" id="co_containers_CO2-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_containers_CO2-1" id="callout_containers_CO2-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>Repository to grab the source code from.</p></dd>
<dt><a class="co" href="#co_containers_CO2-2" id="callout_containers_CO2-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>The directory where the source code is present.</p></dd>
<dt><a class="co" href="#co_containers_CO2-3" id="callout_containers_CO2-3"><img alt="3" height="12" src="assets/3.png" width="12"/></a></dt>
<dd><p>The <code>ClusterBuildStrategy</code> to use.</p></dd>
<dt><a class="co" href="#co_containers_CO2-4" id="callout_containers_CO2-4"><img alt="4" height="12" src="assets/4.png" width="12"/></a></dt>
<dd><p>The destination of the resulting container image. Change this with your container registry repo.</p></dd>
<dt><a class="co" href="#co_containers_CO2-5" id="callout_containers_CO2-5"><img alt="5" height="12" src="assets/5.png" width="12"/></a></dt>
<dd><p>The secret to use to authenticate to the container registry and push the image.</p></dd>
</dl>
<p class="less_space pagebreak-before">Now, let’s create the <code>Build</code> object:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl create -f build-kaniko.yaml</pre>
<p>You should get output similar to this:</p>
<pre data-code-language="text" data-type="programlisting">build.shipwright.io/kaniko-nodejs-build created</pre>
<p>Let’s list the available builds:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl get builds</pre>
<p>You should get output similar to the following:</p>
<pre data-code-language="text" data-type="programlisting">NAME                  REGISTERED   REASON      BUILDSTRATEGYKIND↳
      BUILDSTRATEGYNAME   CREATIONTIME
kaniko-nodejs-build   True         Succeeded   ClusterBuildStrategy↳
      kaniko              13s</pre>
<p>At this point, your <code>Build</code> is <code>REGISTERED</code>, but it’s not started yet. Let’s create the following object in order to start it:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shipwright.io/v1alpha1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">BuildRun</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">generateName</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kaniko-nodejs-buildrun-</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">buildRef</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">kaniko-nodejs-build</code><code class="w"/></pre>
<pre data-code-language="bash" data-type="programlisting">kubectl create -f buildrun.yaml</pre>
<p>If you check the list of running pods, you should see one being created:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl get pods</pre>
<pre data-code-language="text" data-type="programlisting">NAME                                           READY   STATUS            RESTARTS↳
      AGE
kaniko-nodejs-buildrun-b9mmb-qbrgl-pod-dk7xt   0/3     PodInitializing   0↳
      19s</pre>
<p>When the <code>STATUS</code> changes, the build will <a data-primary="kaniko" data-startref="kaniko" data-type="indexterm" id="idm45120846371296"/>start, and you can track the progress by checking <a data-primary="build logs, checking" data-type="indexterm" id="idm45120846370656"/>the logs from the containers used by this pod to run the build in multiple steps:</p>
<dl>
<dt>step-source-default</dt>
<dd>
<p>The first step, used to get the source code</p>
</dd>
<dt>step-build-and-push</dt>
<dd>
<p>The step to run the build, either from source code or from a Dockerfile like in this case with kaniko</p>
</dd>
<dt>step-results</dt>
<dd>
<p>The result of the build</p>
</dd>
</dl>
<p>Let’s check the logs of the building phase:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl logs -f kaniko-nodejs-buildrun-b9mmb-qbrgl-pod-dk7xt -c step-build-and-push</pre>
<pre data-code-language="text" data-type="programlisting">INFO[0001] Retrieving image manifest ghcr.io/shipwright-io/shipwright-samples/node:12
INFO[0001] Retrieving image ghcr.io/shipwright-io/shipwright-samples/node:12↳
 from registry ghcr.io
INFO[0002] Built cross stage deps: map[]
INFO[0002] Retrieving image manifest ghcr.io/shipwright-io/shipwright-samples/node:12
INFO[0002] Returning cached image manifest
INFO[0002] Executing 0 build triggers
INFO[0002] Unpacking rootfs as cmd COPY . /app requires it.
INFO[0042] COPY . /app
INFO[0042] Taking snapshot of files...
INFO[0042] WORKDIR /app
INFO[0042] cmd: workdir
INFO[0042] Changed working directory to /app
INFO[0042] No files changed in this command, skipping snapshotting.
INFO[0042] RUN     pwd &amp;&amp;     ls -l &amp;&amp;     npm install &amp;&amp;↳
     npm run print-http-server-version
INFO[0042] Taking snapshot of full filesystem...
INFO[0052] cmd: /bin/sh
INFO[0052] args: [-c pwd &amp;&amp;     ls -l &amp;&amp;     npm install &amp;&amp;↳
     npm run print-http-server-version]
INFO[0052] Running: [/bin/sh -c pwd &amp;&amp;     ls -l &amp;&amp;     npm install &amp;&amp;↳
     npm run print-http-server-version]
/app
total 44
-rw-r--r-- 1 node node   261 Jan 27 14:29 Dockerfile
-rw-r--r-- 1 node node 30000 Jan 27 14:29 package-lock.json
-rw-r--r-- 1 node node   267 Jan 27 14:29 package.json
drwxr-xr-x 2 node node  4096 Jan 27 14:29 public
npm WARN npm-simple-renamed@0.0.1 No repository field.
npm WARN npm-simple-renamed@0.0.1 No license field.

added 90 packages from 40 contributors and audited 90 packages in 6.405s

10 packages are looking for funding
  run `npm fund` for details

found 0 vulnerabilities


&gt; npm-simple-renamed@0.0.1 print-http-server-version /app
&gt; serve -v

13.0.2
INFO[0060] Taking snapshot of full filesystem...
INFO[0062] EXPOSE 8080
INFO[0062] cmd: EXPOSE
INFO[0062] Adding exposed port: 8080/tcp
INFO[0062] CMD ["npm", "start"]
INFO[0070] Pushing image to quay.io/gitops-cookbook/sample-nodejs:latest
INFO[0393] Pushed image to 1 destinations</pre>
<p>The image is built and pushed to the registry, and you can check the result from this command as well:</p>
<pre data-code-language="bash" data-type="programlisting">kubectl get buildruns</pre>
<p>And on your registry, as shown in <a data-type="xref" href="#fig3-4">Figure 3-4</a>.</p>
<figure><div class="figure" id="fig3-4">
<img alt="Image pushed to Quay.io" height="1138" src="assets/gocb_0304.png" width="2531"/>
<h6><span class="label">Figure 3-4. </span>Image pushed to Quay</h6>
</div></figure>
</div></section>
<section data-pdf-bookmark="Discussion" data-type="sect2"><div class="sect2" id="idm45120846848960">
<h2>Discussion</h2>
<p>Shipwright provides a convenient way to create container images on Kubernetes, and its agnostic approach makes it robust and interoperable. The project aims at being the Build API for Kubernetes, providing an easier path for developers to automate on Kubernetes. As Tekton runs under the hood creating builds, Shipwright also makes transitioning from micropipeline to extended pipeline workflows on Kubernetes<a data-primary="Kubernetes" data-secondary="container images, building with Shipwright" data-startref="K_contimg_shipw" data-type="indexterm" id="idm45120846280848"/><a data-primary="container images" data-secondary="Kubernetes, building with Shipwright" data-startref="contimg_K_shipw" data-type="indexterm" id="idm45120846279696"/><a data-primary="Shipwright, building container images" data-startref="Shipw_contimg" data-type="indexterm" id="idm45120846278512"/> easier.</p>
<p>As a reference, if you would like to create a build with Buildah instead of kaniko, it’s just a <code>ClusterBuildStrategy</code> change in your <code>Build</code> object:</p>
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">shipwright.io/v1alpha1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Build</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">buildpack-nodejs-build</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">source</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">url</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">https://github.com/shipwright-io/sample-nodejs</code><code class="w">
</code><code class="w">    </code><code class="nt">contextDir</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">source-build</code><code class="w"> </code><a class="co" href="#callout_containers_CO3-1" id="co_containers_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a><code class="w">
</code><code class="w">  </code><code class="nt">strategy</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">buildah</code><code class="w"> </code><a class="co" href="#callout_containers_CO3-2" id="co_containers_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a><code class="w">
</code><code class="w">    </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ClusterBuildStrategy</code><code class="w">
</code><code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">quay.io/gitops-cookbook/sample-nodejs:latest</code><code class="w">
</code><code class="w">    </code><code class="nt">credentials</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">push-secret</code></pre>
<dl class="calloutlist">
<dt><a class="co" href="#co_containers_CO3-1" id="callout_containers_CO3-1"><img alt="1" height="12" src="assets/1.png" width="12"/></a></dt>
<dd><p>As we discussed previously in <a data-type="xref" href="#recipe_3_3">Recipe 3.3</a>, Buildah can create the container image from the source code. It doesn’t need a Dockerfile.</p></dd>
<dt><a class="co" href="#co_containers_CO3-2" id="callout_containers_CO3-2"><img alt="2" height="12" src="assets/2.png" width="12"/></a></dt>
<dd><p>Selecting Buildah as the <code>ClusterBuildStrategy</code>.</p></dd>
</dl>
</div></section>
</div></section>
<section data-pdf-bookmark="3.6 Final Thoughts" data-type="sect1"><div class="sect1" id="idm45120846176896">
<h1>3.6 Final Thoughts</h1>
<p>The container format is the de facto standard for packaging applications, and today many tools help create container images. Developers can create images with Docker or with other tools and frameworks and then use the same with any CI/CD system to deploy their apps to Kubernetes.</p>
<p>While Kubernetes per se doesn’t build container images, some tools interact with the Kubernetes API ecosystem to add this functionality. This aspect improves development velocity and consistency across environments, delegating this complexity to the platform.</p>
<p>In the following chapters, you will see how to control the deployment of your containers running on Kubernetes with tools such as Kustomize or Helm, and then how to add automation to support highly scalable workloads with CI/CD and GitOps.</p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="idm45120847711664"><sup><a href="ch03.xhtml#idm45120847711664-marker">1</a></sup> For a presentation about Jib, see Appu Goundan and Qingyang Chen’s <a href="https://oreil.ly/W4j49">presentation from Velocity San Jose 2018</a>.</p></div></div></section></div></body></html>