<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 11. Final Time-Savers"><div class="chapter" id="ch_timesavers">
<h1><span class="label">Chapter 11. </span>Final Time-Savers</h1>


<p>I’ve had a lot of fun writing this book, and I hope you’ve had fun
reading it too. For the last act, let’s cover a bunch of smaller
topics that didn’t quite fit into the earlier chapters. These topics
have made me a better Linux user, and maybe they’ll help you as well.</p>






<section data-type="sect1" data-pdf-bookmark="Quick Wins"><div class="sect1" id="idm46586636435920">
<h1>Quick Wins</h1>

<p>The following time-savers are simple to learn in a few minutes.</p>








<section data-type="sect2" data-pdf-bookmark="Jumping Into Your Editor from less"><div class="sect2" id="section_less">
<h2>Jumping Into Your Editor from less</h2>

<p><a data-type="indexterm" data-primary="less command" data-secondary="editing the viewed file" id="idm46586636432544"/><a data-type="indexterm" data-primary="text editors" data-secondary="less command keystroke to launch" id="idm46586636431344"/><a data-type="indexterm" data-primary="editing files" data-secondary="less command keystroke to launch" id="idm46586636430432"/>
When you’re viewing a text file with <code>less</code> and want to edit the file,
don’t exit <code>less</code>. Just press <code>v</code> to launch your preferred text
editor.  It loads the file and places the cursor right at the spot
you were viewing in <code>less</code>. Exit the editor and you’re back in
<code>less</code> at the original location.</p>

<p>For this trick to work best, set the environment variable <code>EDITOR</code><a data-type="indexterm" data-primary="EDITOR variable" id="idm46586636426224"/><a data-type="indexterm" data-primary="variables" data-secondary="EDITOR" id="idm46586636425520"/><a data-type="indexterm" data-primary="text editors" data-secondary="default" id="idm46586636424576"/>
and/or <code>VISUAL</code><a data-type="indexterm" data-primary="VISUAL variable" id="idm46586636423216"/><a data-type="indexterm" data-primary="variables" data-secondary="VISUAL" id="idm46586636422512"/> to an editing command. These environment variables
represent your default Linux text editor that may be launched by
various commands, including <code>less</code>, <code>lynx</code>,<a data-type="indexterm" data-primary="lynx command" data-secondary="EDITOR variable" id="idm46586636407184"/> <code>git</code>,<a data-type="indexterm" data-primary="Git" data-secondary="git commands" data-tertiary="EDITOR variable" id="idm46586636405824"/> <code>crontab</code>,<a data-type="indexterm" data-primary="crontab command" data-secondary="EDITOR variable" id="idm46586636404224"/> and numerous email programs.
For example, to set <code>emacs</code>
as your default editor,<a data-type="indexterm" data-primary="less command" data-secondary="default editor" id="idm46586636402864"/> place either of the following lines (or both)
in a shell configuration file and source it:</p>

<pre data-type="programlisting">VISUAL=emacs
EDITOR=emacs</pre>

<p>If you don’t set these variables, your default editor is whatever
your Linux system sets it to be, which is usually <code>vim</code>. If you end up
inside of <code>vim</code> and you don’t know how to use it, don’t panic.<a data-type="indexterm" data-primary="vim editor" data-secondary="exiting" id="idm46586636399680"/> Quit
<code>vim</code> by pressing the Escape key and typing <code>:q!</code> (a colon, the letter
<em>q</em>, and an exclamation point), then press Enter. To quit <code>emacs</code>, press
Ctrl-X followed by Ctrl-C.<a data-type="indexterm" data-primary="emacs editor" data-secondary="exiting" id="idm46586636396816"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Editing Files That Contain a Given String"><div class="sect2" id="section_edit_grep">
<h2>Editing Files That Contain a Given String</h2>

<p><a data-type="indexterm" data-primary="editing files" data-secondary="containing a given string" id="idm46586636394256"/><a data-type="indexterm" data-primary="strings" data-secondary="editing files containing a given string" id="idm46586636393312"/><a data-type="indexterm" data-primary="text files" data-secondary="editing files with given string" id="idm46586636392352"/>
Want to edit every file in the current directory that contains a
certain string (or regular expression)? Generate a list of filenames
with <code>grep -l</code> and pass them to your editor with command substitution.
Assuming your editor is <code>vim</code>, the command is as follows:</p>

<pre data-type="programlisting">$ <strong>vim $(grep -l <em>string</em> *) </strong></pre>

<p>Edit all files containing <em>string</em> in an entire directory tree
(current directory and all subdirectories) by adding the <code>-r</code><a data-type="indexterm" data-primary="grep command" data-secondary="recursive (-r option)" id="idm46586636387680"/> option
(recursive) to <code>grep</code> and beginning in the current directory (the
dot):</p>

<pre data-type="programlisting">$ <strong>vim $(grep -lr <em>string</em> .) </strong></pre>

<p>For faster searches of large directory trees, use <code>find</code> with <code>xargs</code>
instead of <code>grep -r</code>:<a data-type="indexterm" data-primary="find command" data-secondary="xargs command with" id="idm46586636382848"/><a data-type="indexterm" data-primary="xargs command" data-secondary="find command with" id="idm46586636381840"/></p>

<pre data-type="programlisting">$ <strong>vim $(find . -type f -print0 | xargs -0 grep -l <em>string</em>) </strong></pre>

<p><a data-type="xref" href="ch07.xhtml#section_cmd_sub">“Technique #3: Command Substitution”</a> touched on this technique, but I wanted to
emphasize it since it’s so useful. Remember to watch out for
filenames containing spaces and other characters special to the shell,
since they may disrupt the results as explained in <a data-type="xref" href="ch07.xhtml#warn_command_substitution">“Special Characters and Command Substitution”</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Embracing Typos"><div class="sect2" id="idm46586636377328">
<h2>Embracing Typos</h2>

<p><a data-type="indexterm" data-primary="aliases" data-secondary="typing errors" id="idm46586636375952"/><a data-type="indexterm" data-primary="typing errors, aliases for" id="idm46586636374976"/><a data-type="indexterm" data-primary="text" data-secondary="misspellings as aliases" id="idm46586636374336"/><a data-type="indexterm" data-primary="misspellings as aliases" id="idm46586636373392"/>
If you consistently misspell a command, define aliases for your most
common mistakes so the correct command runs anyway:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="nb">alias</code> <code class="nv">firfox</code><code class="o">=</code>firefox
<code class="nb">alias</code> <code class="nv">les</code><code class="o">=</code>less
<code class="nb">alias</code> <code class="nv">meacs</code><code class="o">=</code>emacs</pre>

<p>Be careful not to shadow<a data-type="indexterm" data-primary="aliases" data-secondary="shadowing a command" id="idm46586636337984"/><a data-type="indexterm" data-primary="shadowing" id="idm46586636337136"/><a data-type="indexterm" data-primary="overriding a command" data-secondary="alias safety" id="idm46586636369840"/><a data-type="indexterm" data-primary="command" data-secondary="overriding with alias" id="idm46586636368896"/> (override) an existing Linux command
accidentally by defining an alias with the same name. Search for your
proposed alias first with the command <code>which</code> or <code>type</code> (see
<a data-type="xref" href="ch02.xhtml#section_path">“Locating Programs to Be Run”</a>), and run the <code>man</code> command to be extra sure there’s
no other same-named command:</p>

<pre data-type="programlisting">$ <strong>type firfox</strong>
bash: type: firfox: not found
$ <strong>man firfox</strong>
No manual entry for firfox</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating Empty Files Quickly"><div class="sect2" id="idm46586636364000">
<h2>Creating Empty Files Quickly</h2>

<p><a data-type="indexterm" data-primary="file" data-secondary="empty" id="idm46586636362592"/><a data-type="indexterm" data-primary="empty file creation" data-secondary="in bulk" id="idm46586636361616"/>
There are several ways to create empty files in Linux. The <code>touch</code><a data-type="indexterm" data-primary="touch command" id="idm46586636360288"/>
command, which updates the timestamp on a file, also creates a file
if one doesn’t already exist:</p>

<pre data-type="programlisting">$ <strong>touch newfile1</strong></pre>

<p><code>touch</code> is great for creating large numbers of empty files for testing:</p>

<pre data-type="programlisting">$ <strong>mkdir tmp</strong>                           <em>Create a directory</em>
$ <strong>cd tmp</strong>
$ <strong>touch file{0000..9999}.txt</strong>          <em>Create 10,000 files</em>
$ <strong>cd ..</strong>
$ <strong>rm -rf tmp</strong>                          <em>Remove the directory and files</em></pre>

<p>The <code>echo</code> command creates an empty file if you redirect its output to
a file, but only if you supply the <code>-n</code> option:<a data-type="indexterm" data-primary="echo command" data-secondary="suppressing newline (-n option)" id="idm46586636320656"/><a data-type="indexterm" data-primary="newline character" data-secondary="empty file generation" id="idm46586636319808"/></p>

<pre data-type="programlisting">$ <strong>echo -n &gt; newfile2</strong></pre>

<p>If you forget the <code>-n</code> option, the resulting file contains one
character, a newline, so it’s not empty.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Processing a File One Line at a Time"><div class="sect2" id="idm46586636316864">
<h2>Processing a File One Line at a Time</h2>

<p>When you need to process a file one line at a time, <code>cat</code> the file
into a <code>while read</code> loop<a data-type="indexterm" data-primary="while loop" data-secondary="while read" id="idm46586636314304"/><a data-type="indexterm" data-primary="read command" id="idm46586636313296"/><a data-type="indexterm" data-primary="builtins" data-secondary="read" id="idm46586636312624"/><a data-type="indexterm" data-primary="builtins" data-secondary="while" id="idm46586636311680"/><a data-type="indexterm" data-primary="loops" data-secondary="bash" data-tertiary="while read loop" id="idm46586636310736"/>:</p>

<pre data-type="programlisting">$ <strong>cat myfile | while read line; do</strong>
 <em>...do something here...</em>
<strong>done</strong></pre>

<p>For example, to compute the length of each line of a file, such as
<em>/etc/hosts</em>,<a data-type="indexterm" data-primary="/etc/hosts file" id="idm46586636306816"/><a data-type="indexterm" data-primary="/etc/hosts file" data-primary-sortas="etc hosts" id="idm46586636306080"/> pipe each line to <code>wc -c</code>:</p>

<pre data-type="programlisting">$ <strong>cat /etc/hosts | while read line; do</strong>
  <strong>echo "$line" | wc -c</strong>
<strong>done</strong>
65
31
1
⋮</pre>

<p>A more practical example of this technique is in <a data-type="xref" href="ch09.xhtml#ex_check_expiry_all">Example 9-3</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Identifying Commands That Support Recursion"><div class="sect2" id="idm46586636301312">
<h2>Identifying Commands That Support Recursion</h2>

<p><a data-type="indexterm" data-primary="recursive commands" id="idm46586636300064"/><a data-type="indexterm" data-primary="command" data-secondary="recursive" id="idm46586636299424"/>
In <a data-type="xref" href="ch05.xhtml#section_find">“The find Command”</a>, I introduced <code>find -exec</code>, which applies any Linux
command to a whole directory tree recursively:</p>

<pre data-type="programlisting">$ <strong>find . -exec <em>your command here</em> \;</strong></pre>

<p>Certain other commands support recursion themselves, and if you’re
aware of them, you can save typing time by using their native
recursion instead of constructing a <code>find</code> command:</p>
<dl>
<dt><code>ls -R</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="ls command" data-secondary="recursive (-R option)" id="idm46586636292800"/>To list directories and their contents recursively</p>
</dd>
<dt><code>cp -r</code> or <code>cp -a</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="cp command" data-secondary="recursive (-r and -a options)" id="idm46586636289904"/><a data-type="indexterm" data-primary="copying files" data-secondary="recursively" id="idm46586636288960"/>To copy directories and their contents recursively</p>
</dd>
<dt><code>rm -r</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="rm command" data-secondary="recursive (-r option)" id="idm46586636286544"/>To delete directories and their contents recursively</p>
</dd>
<dt><code>grep -r</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="grep command" data-secondary="recursive (-r option)" id="idm46586636284096"/>To search by regular expression throughout a directory tree</p>
</dd>
<dt><code>chmod -R</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="chmod command" data-secondary="recursive (-r option)" id="idm46586636281712"/>To change file protections recursively</p>
</dd>
<dt><code>chown -R</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="chown command" id="idm46586636279328"/>To change file ownership recursively</p>
</dd>
<dt><code>chgrp -R</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="chgrp command" id="idm46586636277216"/>To change file group ownership recursively</p>
</dd>
</dl>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Read a Manpage"><div class="sect2" id="idm46586636276064">
<h2>Read a Manpage</h2>

<p><a data-type="indexterm" data-primary="manpages" data-secondary="continuous learning" id="idm46586636274928"/>
Pick a common command, such as <code>cut</code> or <code>grep</code>, and read its manpage
thoroughly. You’ll probably discover an option or two that you’ve never
used and will find valuable. Repeat this activity every so often to polish
and extend your Linux toolbox.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Longer Learning"><div class="sect1" id="idm46586636272512">
<h1>Longer Learning</h1>

<p>The following techniques require real effort to learn, but you’ll be
paid back in time saved. I provide just a taste of each topic, not
to teach you the details but to entice you to discover more on
your own.</p>








<section data-type="sect2" data-pdf-bookmark="Read the bash Manpage"><div class="sect2" id="idm46586636270656">
<h2>Read the bash Manpage</h2>

<p><a data-type="indexterm" data-primary="bash" data-secondary="manpage" id="idm46586636269456"/>
Run <code>man bash</code> to display the full, official documentation on <code>bash</code>,
and read the whole thing—yes, all 46,318 words of it:</p>

<pre data-type="programlisting">$ <strong>man bash | wc -w</strong>
46318</pre>

<p>Take a few days. Work through it slowly. You’ll definitely learn a lot
to make your daily Linux use easier.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Learn cron, crontab, and at"><div class="sect2" id="section_crontab">
<h2>Learn cron, crontab, and at</h2>

<p><a data-type="indexterm" data-primary="cron" id="idm46586636263712"/><a data-type="indexterm" data-primary="crontab command" id="idm46586636263008"/><a data-type="indexterm" data-primary="scheduled jobs" id="idm46586636262336"/>
In <a data-type="xref" href="ch09.xhtml#section_finding_files">“A First Example: Finding Files”</a>, there’s a brief note about scheduling
commands to run automatically in the future at regular intervals. I
recommend learning the program <code>crontab</code> to set up scheduled commands for
yourself. For example, you could back up files to an external drive on
a schedule, or send yourself reminders by email for a monthly event.</p>

<p>Before running <code>crontab</code>, define your default editor as shown in
<a data-type="xref" href="#section_less">“Jumping Into Your Editor from less”</a>. Then run <code>crontab -e</code><a data-type="indexterm" data-primary="crontab command" data-secondary="edit (-e option)" id="idm46586636257696"/> to edit your personal file of
scheduled commands. <code>crontab</code> launches your default editor and opens an empty
file to specify the commands. That file is called your <em>crontab</em>.</p>

<p>Briefly, a scheduled command in a crontab file,<a data-type="indexterm" data-primary="crontab command" data-secondary="file format" id="idm46586636255248"/> often
called a <em>cron job</em>,<a data-type="indexterm" data-primary="cron" data-secondary="cron job" id="idm46586636253728"/><a data-type="indexterm" data-primary="job" data-secondary="cron job" id="idm46586636252720"/> consists of six fields, all
on a single (possibly long) line.  The first five fields
determine the job’s schedule by minute, hour, day of month, month, and day of week, respectively.
The sixth field is the Linux command to run. You can launch a
command hourly, daily, weekly, monthly, yearly, at certain days or times,
or in other more complex arrangements. Some examples are:</p>
<pre data-type="programlisting"> * * * * * <em>command</em>             <em>Run command every minute</em>
30 7 * * * <em>command</em>             <em>Run command at 07:30 every day</em>
30 7 5 * * <em>command</em>             <em>Run command at 07:30 the 5th day of every month</em>
30 7 5 1 * <em>command</em>             <em>Run command at 07:30 every January 5</em>
30 7 * * 1 <em>command</em>             <em>Run command at 07:30 every Monday</em>
</pre>

<p>Once you’ve created all six fields, saved the file, and exited your
editor, the command is launched automatically (by a program called
<code>cron</code>) according to the schedule you defined. The syntax for
schedules is short and cryptic but well-documented on the manpage
(<code>man 5 crontab</code>) and numerous online tutorials (search for <em>cron
tutorial</em>).</p>

<p>I also recommend learning the <code>at</code> command,<a data-type="indexterm" data-primary="at command" id="idm46586636243744"/> which schedules commands
to run once, rather than repeatedly, at a specified date and time. Run
<code>man at</code> for details. Here’s a command that sends you an email
reminder tomorrow at 10 p.m. to brush your teeth:</p>

<pre data-type="programlisting">$ <strong>at 22:00 tomorrow</strong>
warning: commands will be executed using /bin/sh
at&gt; <strong>echo brush your teeth | mail $USER</strong>
at&gt; <strong>^D</strong>                                       <em>Type Ctrl-D to end input</em>
job 699 at Sun Nov 14 22:00:00 2021</pre>

<p>To list your pending <code>at</code> jobs, run <code>atq</code>:<a data-type="indexterm" data-primary="atq command" id="idm46586636238384"/></p>

<pre data-type="programlisting">$ <strong>atq</strong>
699     Sun Nov 14 22:00:00 20211 a smith</pre>

<p>To view the commands in an <code>at</code> job, run <code>at -c</code> with the job
number, and print the final few lines:<a data-type="indexterm" data-primary="tail command" data-secondary="examples" id="idm46586636235088"/></p>

<pre data-type="programlisting">$ <strong>at -c 699 | tail</strong>
⋮
echo brush your teeth | mail $USER</pre>

<p>To remove a pending job before it’s executed, run <code>atrm</code><a data-type="indexterm" data-primary="atrm command" id="idm46586636232192"/>
with the job number:</p>

<pre data-type="programlisting">$ <strong>atrm 699</strong></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Learn rsync"><div class="sect2" id="idm46586636264864">
<h2>Learn rsync</h2>

<p><a data-type="indexterm" data-primary="rsync command" id="idm46586636228848"/><a data-type="indexterm" data-primary="copying files" data-secondary="recursively" data-tertiary="with rsync" id="idm46586636228144"/>
To copy a full directory, including its subdirectories, from one disk location to
another, many Linux users turn to the command <code>cp -r</code> or <code>cp -a</code>:<a data-type="indexterm" data-primary="cp command" data-secondary="recursive (-r and -a options)" data-tertiary="rsync instead" id="idm46586636225824"/></p>

<pre data-type="programlisting">$ <strong>cp -a dir1 dir2</strong></pre>

<p><code>cp</code> does the job fine the first time, but if you later modify a few
files in directory <em>dir1</em> and perform the copy again, <code>cp</code> is
wasteful. It dutifully copies all files and directories from <em>dir1</em>
all over again, even if identical copies already exist in <em>dir2</em>.</p>

<p>The command <code>rsync</code> is a smarter copy<a data-type="indexterm" data-primary="smart copy with rsync" id="idm46586636220128"/> program.
It copies only the <em>differences</em> between the first and second directories.</p>

<pre data-type="programlisting">$ <strong>rsync -a dir1/ dir2</strong></pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The forward slash in the preceding command means to copy the files
inside <em>dir1</em>. Without the slash, <code>rsync</code> would copy <em>dir1</em> itself,
creating <em>dir2/dir1</em>.</p>
</div>

<p>If you later add a file to directory <em>dir1</em>, <code>rsync</code> copies just that
one file. If you change one <em>line</em> inside a file in <em>dir1</em>, <code>rsync</code>
copies that one line! It’s a huge time-saver when copying large
directory trees multiple times. <code>rsync</code> can even copy to a remote
server over an SSH connection.</p>

<p><code>rsync</code> has dozens of options. These are some particularly useful ones:</p>
<dl>
<dt><code>-v</code> (meaning “verbose”)</dt>
<dd>
<p>To print the names of files as they’re copied</p>
</dd>
<dt><code>-n</code></dt>
<dd>
<p>To pretend to copy; combine with <code>-v</code> to see which files <em>would</em> be copied</p>
</dd>
<dt><code>-x</code></dt>
<dd>
<p>To tell <code>rsync</code> not to cross filesystem boundaries</p>
</dd>
</dl>

<p>I highly recommend getting comfortable with <code>rsync</code> for more efficient
copying. Read the manpage and view examples in the article <a href="https://oreil.ly/7gHCi">“Rsync Examples in Linux”</a> by Korbin Brown.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Learn Another Scripting Language"><div class="sect2" id="idm46586636229760">
<h2>Learn Another Scripting Language</h2>

<p><a data-type="indexterm" data-primary="scripting languages" id="idm46586636200944"/><a data-type="indexterm" data-primary="bash" data-secondary="scripting language, weaknesses" id="idm46586636200240"/><a data-type="indexterm" data-primary="whitespace" data-secondary="scripting languages handling" id="idm46586636199280"/>
Shell scripts are convenient and powerful but have some serious
shortcomings. For example, they’re terrible at handling filenames that
contain whitespace characters. Consider this short <code>bash</code> script that
attempts to remove a file:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="nv">BOOKTITLE</code><code class="o">=</code><code class="s2">"Slow Inefficient Linux"</code>
rm <code class="nv">$BOOKTITLE</code>					<code class="c1"># Wrong! Don't do this!</code></pre>

<p>It looks like the second line removes a file named <em>Slow
Inefficient Linux</em>, but it doesn’t. It attempts to remove three files
named <em>Slow</em>, <em>Inefficient</em>, and <em>Linux</em>. The shell expands the
variable <code>$BOOKTITLE</code> before calling <code>rm</code>, and its expansion is three
words separated by whitespace, as if you had typed the following:</p>

<pre data-type="programlisting" data-code-language="bash">rm Slow Efficient Linux</pre>

<p>The shell then invokes <code>rm</code> with three arguments, and potential
disaster ensues as it removes the wrong files. A correct removal
command would surround <code>$BOOKTITLE</code> with double quotes:</p>

<pre data-type="programlisting" data-code-language="bash">rm <code class="s2">"</code><code class="nv">$BOOKTITLE</code><code class="s2">"</code></pre>

<p>which the shell expands to:</p>

<pre data-type="programlisting" data-code-language="bash">rm <code class="s2">"Slow Efficient Linux"</code></pre>

<p>This sort of subtle, potentially destructive quirk is just one
example of how unsuitable shell scripting is for serious projects.
So, I recommend learning a second scripting language, such as Perl<a data-type="indexterm" data-primary="Perl" id="idm46586636172928"/>,
PHP<a data-type="indexterm" data-primary="PHP" id="idm46586636172192"/>, Python<a data-type="indexterm" data-primary="Python" id="idm46586636171456"/>, or Ruby<a data-type="indexterm" data-primary="Ruby" id="idm46586636170720"/>. They all handle whitespace properly. They all
support real data structures. They all have powerful string-handling
functions. They all do math easily. The list of benefits goes on.</p>

<p>Use the shell to launch complex commands and create simple scripts,
but for more substantial tasks, turn to another language. Try one of
the many language tutorials online.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Use make for Nonprogramming Tasks"><div class="sect2" id="section_make">
<h2>Use make for Nonprogramming Tasks</h2>

<p><a data-type="indexterm" data-primary="make command" id="idm46586636107456"/><a data-type="indexterm" data-primary="text files" data-secondary="make command" id="idm46586636106752"/>
The program <code>make</code> automatically updates files based on rules.<a data-type="indexterm" data-primary="rules for updating files" id="idm46586636105264"/> It’s
designed to speed up software development, but with a little effort,
<code>make</code> can simplify other aspects of your Linux life.</p>

<p>Suppose you have three files named <em>chapter1.txt</em>, <em>chapter2.txt</em>, and
<em>chapter3.txt</em> that you work on separately. You also have a fourth
file, <em>book.txt</em>, that’s a combination of the three chapter files.
Anytime a chapter changes, you need to recombine them and update
<em>book.txt</em>, perhaps with a command like this:</p>

<pre data-type="programlisting">$ <strong>cat chapter1.txt chapter2.txt chapter3.txt &gt; book.txt</strong></pre>

<p>This situation is perfect for using <code>make</code>. You have:</p>

<ul>
<li>
<p>A bunch of files</p>
</li>
<li>
<p>A rule that relates the files, namely, that <em>book.txt</em> needs an update
whenever any chapter file changes</p>
</li>
<li>
<p>A command that performs the update</p>
</li>
</ul>

<p><code>make</code> operates by reading a configuration file,<a data-type="indexterm" data-primary="configuration files" data-secondary="make command" id="idm46586636083488"/> usually named
<em>Makefile<a data-type="indexterm" data-primary="Makefile" id="idm46586636082128"/></em>, that is full of rules and commands. For example, the
following <em>Makefile</em> rule states that <em>book.txt</em> depends on the three
chapter files:</p>

<pre data-type="programlisting" data-code-language="makefile"><code class="nf">book.txt</code><code class="o">:</code>	<code class="n">chapter</code>1.<code class="n">txt</code> <code class="n">chapter</code>2.<code class="n">txt</code> <code class="n">chapter</code>3.<code class="n">txt</code></pre>

<p>If the target<a data-type="indexterm" data-primary="target, make" id="idm46586636077488"/> of the rule (in this case <em>book.txt</em>) is older than any of its
dependencies<a data-type="indexterm" data-primary="dependencies, make" id="idm46586636076368"/> (the chapter files), then <code>make</code> considers the target to
be out-of-date. If you supply a command on the line after the rule,
<code>make</code> runs the command to update the target:</p>

<pre data-type="programlisting" data-code-language="makefile"><code class="nf">book.txt</code><code class="o">:</code>	<code class="n">chapter</code>1.<code class="n">txt</code> <code class="n">chapter</code>2.<code class="n">txt</code> <code class="n">chapter</code>3.<code class="n">txt</code>
		cat chapter1.txt chapter2.txt chapter3.txt &gt; book.txt</pre>

<p>To apply the rule, simply run the command <code>make</code>:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
Makefile  chapter1.txt  chapter2.txt  chapter3.txt
$ <strong>make</strong>
cat chapter1.txt chapter2.txt chapter3.txt &gt; book.txt       <em>Executed by make</em>
$ <strong>ls</strong>
Makefile  book.txt  chapter1.txt  chapter2.txt  chapter3.txt
$ <strong>make</strong>
make: 'book.txt' is up to date.
$ <strong>vim chapter2.txt</strong>                                           <em>Update a chapter</em>
$ <strong>make</strong>
cat chapter1.txt chapter2.txt chapter3.txt &gt; book.txt</pre>

<p><code>make</code> was developed for programmers, but with a little study, you can
use it for nonprogramming tasks. Anytime you need to update files
that depend on other files, you can likely simplify your work by writing a
<em>Makefile</em>.</p>

<p><code>make</code> helped me write and debug this book. I wrote the book in a
typesetting language called AsciiDoc<a data-type="indexterm" data-primary="AsciiDoc" data-secondary="HTML conversion" id="idm46586635992432"/><a data-type="indexterm" data-primary="HTML" data-secondary="AsciiDoc converted to" id="idm46586635991456"/><a data-type="indexterm" data-primary="text files" data-secondary="AsciiDoc converted to HTML" id="idm46586635990512"/> and regularly converted chapters
to HTML to view in a browser. Here’s a <code>make</code> rule to convert any AsciiDoc
file to an HTML file:</p>

<pre data-type="programlisting" data-code-language="makefile"><code class="nf">%.html</code><code class="o">:</code>	%.<code class="n">asciidoc</code>
	asciidoctor -o <code class="k">$@</code> <code class="k">$&lt;</code></pre>

<p>It means: to create a file with the extension <em>.html</em> (<code>%.html</code>), look
for a corresponding file with the extension <em>.asciidoc</em>
(<code>%.asciidoc</code>). If the HTML file is older than the AsciiDoc file,
regenerate the HTML file by running the command <code>asciidoctor</code> on the
dependent file (<code>$&lt;</code>), sending the output to the target HTML file (<code>-o
$@</code>). With this slightly cryptic but short rule in place, I type a
simple <code>make</code> command to create the HTML version of the chapter you’re
reading now. <code>make</code> launches <code>asciidoctor</code> to perform the update:</p>

<pre data-type="programlisting">$ <strong>ls ch11* </strong>
ch11.asciidoc
$ <strong>make ch11.html</strong>
asciidoctor -o ch11.html ch11.asciidoc
$ <strong>ls ch11* </strong>
ch11.asciidoc  ch11.html
$ <strong>firefox ch11.html</strong>                              <em>View the HTML file</em></pre>

<p>It takes less than an hour to become reasonably proficient with <code>make</code>
for small tasks. It’s worth the effort. A helpful guide is at
<a href="https://makefiletutorial.com/" class="orm:hideurl">makefiletutorial.com</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Apply Version Control to Day-to-Day Files"><div class="sect2" id="section_git">
<h2>Apply Version Control to Day-to-Day Files</h2>

<p><a data-type="indexterm" data-primary="version control" data-secondary="day-to-day files" id="idm46586635953200"/>
Have you ever wanted to edit a file but were afraid that your changes
might mess it up? Perhaps you made a backup copy for safekeeping and
edited the original, knowing you could restore the backup if you make
a mistake:</p>

<pre data-type="programlisting">$ <strong>cp myfile myfile.bak</strong></pre>

<p>This solution isn’t scalable. What if you have dozens or hundreds of
files and dozens or hundreds of people working on them? Version
control systems such as Git<a data-type="indexterm" data-primary="Git" id="idm46586635927504"/> and Subversion<a data-type="indexterm" data-primary="Subversion" id="idm46586635926768"/> were invented to solve this
problem in general by tracking multiple versions of a file
conveniently.</p>

<p>Git is widespread for maintaining software source code, but I
recommend learning and using it for any important text files where
your changes matter. Perhaps they’re personal files, or operating
system files in <em>/etc</em>. <a data-type="xref" href="ch06.xhtml#section_traveling">“Traveling with Your Environment”</a> suggests maintaining
your <code>bash</code> configuration files with version control.</p>

<p>I used Git while writing this book so I could try different ways of
presenting the material. Without too much effort, I created and
maintained three different versions of the book—one for the full
manuscript so far, one containing only the chapters I’d submitted to
my editor for review, and one for experimental work where I tried out
new ideas. If I didn’t like what I wrote, a single command would
restore a previous version.</p>

<p>Teaching Git is beyond the scope of this book, but here are some
example commands to show you the basic workflow and whet your
appetite. Convert the current directory (and all its subdirectories)
into a Git repository:<a data-type="indexterm" data-primary="Git" data-secondary="git commands" data-tertiary="overview" id="idm46586635922816"/></p>

<pre data-type="programlisting">$ <strong>git init</strong></pre>

<p>Edit some files. Afterward, add the changed files to an invisible
“staging area,” an operation that declares your intent to create a new
version:</p>

<pre data-type="programlisting">$ <strong>git add .</strong></pre>

<p>Create the new version, providing a comment to describe your changes
to the files:</p>

<pre data-type="programlisting">$ <strong>git commit -m"Changed X to Y"</strong></pre>

<p>View your version history:</p>

<pre data-type="programlisting">$ <strong>git log</strong></pre>

<p>There’s much more to it, like retrieving old versions of files and
saving (<em>pushing</em>) versions to another server. Grab a <a href="https://oreil.ly/0AlOu"><code>git</code> tutorial</a>, and get started!</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Farewell"><div class="sect1" id="idm46586635914320">
<h1>Farewell</h1>

<p>Thank you so much for following along with me through this book. I
hope it has fulfilled the promise I made in the preface to take your
Linux command-line skills to the next level. Tell me about your
experience at <a href="mailto:dbarrett@oreilly.com">dbarrett@oreilly.com</a>. Happy computing.</p>
</div></section>







</div></section></div></body></html>