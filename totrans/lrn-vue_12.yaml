- en: Chapter 12\. Continuous Integration/Continuous Deployment of Vue.Js Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The previous chapter showed us how to set up testing for our Vue application,
    from unit tests with Vite to E2E tests with Playwright. With our application covered
    with proper tests, we can move on to the next step: deployment.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will introduce you to the concept of CI/CD and how to set up a
    CI/CD pipeline using GitHub Actions for your Vue application. We will also learn
    how to use Netlify as our deployment and hosting platform for our application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD in Software Development
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous integration (CI) and continuous delivery (CD) are combined software
    development practices aiming to speed up and stabilize the software development
    and delivery process. CI/CD includes monitoring the software lifecycle effectively
    through an automated integration, testing, and continuous software deployment
    to production process.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'CI/CD offers many benefits to software development, including:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Faster software delivery with automated deployment
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stronger collaboration between different teams
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Better software quality with automated testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster response to bugs and software issues in a more agile approach
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In short, CI/CD contains three main concepts: continuous integration, continuous
    delivery, and continuous deployment, and when combined, they form a robust software
    development process known as the CI/CD pipeline ([Figure 12-1](#figure_ch10_pipeline)).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the CI/CD pipeline approach, with continuous integration,
    continuous delivery, and continuous deployment](assets/lvue_1201.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
- en: Figure 12-1\. CI/CD pipeline
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Continuous Integration
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous integration enables developers to integrate code into a shared repository
    frequently and simultaneously while working independently. With each code integration
    (or merge), we validate it using an automated build of the application and an
    automated system of different levels of testing. If there are conflicts between
    new and old code versions or any problems with the new code, we can detect and
    fix them quickly. Standard tools for continuous integration include Jenkins, CircleCI,
    and GitHub Actions, which we will discuss in [“CI/CD Pipeline with GitHub Actions”](#chapter12_pipeline).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Delivery
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step after a successful continuous integration is continuous delivery.
    Continuous delivery automates the release of the validated application’s code
    to the shared repository, making it ready for production deployment. Continuous
    delivery requires continuous integration since it assumes the code is always verified.
    It also includes another series of automated testing and release automation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Deployment
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous deployment is the CI/CD pipeline’s final step, automatically deploying
    the validated code to production. It relies significantly on a well-tested automation
    system for the codebase. Continuous deployment is the most advanced step of the
    CI/CD pipeline. It is only necessary for some projects, especially when manual
    approval is necessary before production deployment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: The three stages of the CI/CD pipeline form a more secure and flexible application
    development and deployment process. In the next section, we will learn how to
    set up a CI/CD pipeline for our Vue application using GitHub Actions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD Pipeline with GitHub Actions
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provided by GitHub, GitHub Actions is a platform-agnostic, language-agnostic,
    and cloud-agnostic CI/CD platform. It is straightforward to use and free for projects
    hosted on the GitHub platform. Each CI/CD pipeline in GitHub Actions contains
    single or multiple workflows, denoted by a YAML file. Each workflow includes a
    series of jobs and executes in parallel or sequentially. Each job has a series
    of steps containing many sequential actions. And each action is a standalone command
    or a script that gets executed in the designated runner environment ([Example 12-1](#example_workflow)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Example 12-1\. Example GitHub workflow file
  id: totrans-22
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The workflow file follows YAML syntax. You can learn how to use YAML syntax
    at the [workflow syntax for GitHub Actions documentation](https://oreil.ly/uIIkh).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using GitHub Actions, within our Vue project directory, we will create
    a new directory named `.github/workflows` with a workflow file, `ci.yml`. This
    file will contain the configuration for our CI/CD pipeline. For example, the following
    is a simple workflow file that runs our unit tests:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_continuous_integration_continuous_deployment_of_vue_js_applications_CO1-1)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: The workflow will be triggered when there is a push to the `main` branch or
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_continuous_integration_continuous_deployment_of_vue_js_applications_CO1-2)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: When there is a pull request to merge to `main`
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_continuous_integration_continuous_deployment_of_vue_js_applications_CO1-3)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Checkout the testing branch to a runner environment using built-in GitHub Actions,
    `actions/checkout`
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_continuous_integration_continuous_deployment_of_vue_js_applications_CO1-4)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Set up the node environment with Node.js version 18.x using built-in GitHub
    Actions, `actions/setup-node`
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_continuous_integration_continuous_deployment_of_vue_js_applications_CO1-5)'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Install dependencies
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_continuous_integration_continuous_deployment_of_vue_js_applications_CO1-6)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Run unit tests with reporting coverage
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_continuous_integration_continuous_deployment_of_vue_js_applications_CO1-7)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Upload the test report to GitHub Actions as artifacts
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each job is a standalone process and does not share the same environment. Therefore,
    in its steps, we need to install dependencies for each job separately.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: On GitHub, we can navigate to the Actions tab to see the status of our workflow
    ([Figure 12-2](#figure_ch10_actions)).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the GitHub Actions page, with the CI workflow running](assets/lvue_1202.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: Figure 12-2\. GitHub Actions page with workflow running
  id: totrans-46
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: GitHub displays the workflows according to the commits, with their status and
    the target branch (`main`). We can then view the status of each job within a workflow
    by clicking on the job name, such as how we can see the status of the *unit-tests*
    job in [Figure 12-3](#figure_ch10_unit_tests).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the status of the unit tests job](assets/lvue_1203.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
- en: Figure 12-3\. Unit-tests of the job’s running status in steps
  id: totrans-49
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once the workflow finishes running, we can see the test report uploaded to the
    Artifacts section ([Figure 12-4](#figure_ch10_artifacts)).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing uploaded artifacts, with the test report](assets/lvue_1204.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: Figure 12-4\. Artifacts section with test report
  id: totrans-52
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We also can check the status result of a workflow, broken down by jobs, by clicking
    on the workflow name ([Figure 12-5](#figure_ch10_workflow)).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the execution status of a workflow](assets/lvue_1205.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
- en: Figure 12-5\. Workflow status page
  id: totrans-55
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: GitHub Actions will mark any failed job and provide summary annotations of the
    failures. We can also rerun a failed job by clicking on the *Re-run jobs* button.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we have created our first CI/CD pipeline for our Vue application.
    Alternatively, you can use available templates from the official [GitHub Actions
    marketplace](https://oreil.ly/ch9V2) to create your workflows, with built-in support
    for different programming languages, frameworks, services, and cloud providers
    ([Figure 12-6](#figure_ch10_actions_marketplace)).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the GitHub Actions marketplace](assets/lvue_1206.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: Figure 12-6\. GitHub Actions marketplace
  id: totrans-59
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Based on our workflow example, you can create more workflows for your application
    if required or extend the current workflow to include more steps, such as deployment.
    In the next section, we will learn how to set up continuous deployment for our
    application using Netlify.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Continuous Deployment with Netlify
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Netlify is a cloud platform that offers a wide range of services for hosting
    modern web applications, including hosting, serverless functions APIs, and CI/CD
    integration. It is free for personal projects while offering a generous free tier
    for commercial ones.^([1](ch12.html#id1738))
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: To deploy our Vue project on Netlify, we need to [create a Netlify account](https://oreil.ly/uLHpQ)
    and log in. Once logged in to the dashboard, we can head to the *Sites* tab and
    click on the *Add new site* button to import our project from the GitHub provider
    for automatic deployment, or deploy manually ([Figure 12-7](#figure_ch10_netlify)).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Netlify dashboard](assets/lvue_1207.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
- en: Figure 12-7\. Netlify dashboard
  id: totrans-65
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, we select the Git provider for our project (GitHub) and authorize Netlify
    to access our GitHub account. Once confirmed, we can choose the repository for
    our project and click on the `Deploy site` button to start the deployment process.
    After completing the deployment, we can view our site deployment’s status and
    other details, such as a PR preview on the *Site overview* tab of the dashboard
    ([Figure 12-8](#figure_ch10_netlify_site)).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Netlify site overview](assets/lvue_1208.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
- en: Figure 12-8\. Netlify site overview
  id: totrans-68
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once deployed successfully, Netlify will provide a temporary URL to access the
    application. In fact, you can configure your site’s custom domain by navigating
    to the *Domain Management* section ([Figure 12-9](#figure_ch10_netlify_domain)).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the Netlify domain settings](assets/lvue_1209.png)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
- en: Figure 12-9\. Netlify domain settings
  id: totrans-71
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, once integrated, Netlify will automatically deploy your application
    whenever a new commit is merged to the `main` branch. Additionally, it will generate
    a preview build for each pull request. Within this view, you can also configure
    additional settings such as build command, deployment context for continuous deployment,
    and environment variables for your application. Netlify also offers build hooks
    as a unique URL for triggering build and deployment with a third-party service
    like Github Actions workflow via HTTP requests ([Figure 12-10](#ch11_build_hook)).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot showing the build hook settings](assets/lvue_1210.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: Figure 12-10\. Build a hook section in Site settings
  id: totrans-74
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can manually build your application using the `yarn build` command locally,
    then drag and drop the `dist` folder to the [Netlify app](https://oreil.ly/LInwT)
    to deploy your application to a temporary URL provided by Netlify.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Deploying with Netlify CLI
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Alternatively, we can install the Netlify CLI as a global tool in our local
    machine, using the command `npm install -g netlify-cli`. With this CLI installed,
    we can initialize our project for Netlify using the command `netlify init`. This
    command will prompt us to log in to the relevant account (GitHub) and prepare
    our project for deployment. Once initialized and ready, we can run the command
    `netlify deploy` to deploy our project to a temporary URL for previewing or `netlify
    deploy --prod` to deploy to production directly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: We have successfully deployed our first Vue application to Netlify. Other advanced
    features Netlify offers include serverless functions, form handling, and split
    testing. You can explore these features per the project’s requirements using [the
    Netlify official documentation](https://oreil.ly/6X9F6).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned about the concept of CI/CD and how to set up
    a simple CI/CD process for our Vue application using GitHub Actions. We also learned
    about Netlify and how to automatically deploy our application to Netlify hosting.
    In the next chapter, we will explore the final aspects of the Vue ecosystem, server-side
    rendering (SSR) and static site generation (SSG) using Nuxt.js.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于CI/CD的概念，以及如何利用GitHub Actions为我们的Vue应用程序建立一个简单的CI/CD流程。我们还了解了Netlify，并学习了如何自动将我们的应用程序部署到Netlify托管平台。在下一章中，我们将探讨Vue生态系统的最后几个方面，即使用Nuxt.js进行服务器端渲染（SSR）和静态站点生成（SSG）。
- en: ^([1](ch12.html#id1738-marker)) Other alternatives are Azure Static Web Apps
    and Vercel.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch12.html#id1738-marker)) 其他选择包括Azure静态Web应用和Vercel。
