<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 15. REST APIs and JSON"><div class="chapter" id="ch_rest_apis_and_json">
<h1><span class="label">Chapter 15. </span>REST APIs and JSON</h1>


<p><a data-type="indexterm" data-primary="JSON" data-secondary="REST APIs and" id="ix_ch-15-rest_apis_and_json-asciidoc0"/><a data-type="indexterm" data-primary="REST APIs" id="ix_ch-15-rest_apis_and_json-asciidoc1"/>While we saw some REST API examples in <a data-type="xref" href="ch08.xhtml#ch_form_handling">Chapter 8</a>, our paradigm so far has mostly been “process the data on the server side and send formatted HTML to the client.” Increasingly, this is not the default mode of operation for web applications. Instead, most modern web applications are single-page applications (SPAs) that receive all of their HTML and CSS in one static bundle and then rely on receiving unstructured data as JSON and manipulating HTML directly. Similarly, the importance of posting forms to communicate changes to the server is giving way to communicating directly using HTTP requests to an API.</p>

<p>So it’s time to turn our attention to using Express to provide API endpoints instead of preformatted HTML. This will serve us well in <a data-type="xref" href="ch16.xhtml#ch_single_page_applications">Chapter 16</a>, when we demonstrate how our API could be used to dynamically render an application.</p>

<p>In this chapter, we’ll strip down our application to providing a “coming soon” HTML interface: we’ll fill that in in <a data-type="xref" href="ch16.xhtml#ch_single_page_applications">Chapter 16</a>. Instead, we’ll focus on an API that will provide access to our vacation database and provide API support for registering “out of season” listeners.</p>

<p><a data-type="indexterm" data-primary="web service, defined" id="idm45053580983528"/><em>Web service</em> is a general term that means any application programming interface (API) that’s accessible over HTTP. The idea of web services has been around for quite some time, but until recently, the technologies that enabled them were stuffy, Byzantine, and overcomplicated. There are still systems that use those technologies (such as SOAP and WSDL), and there are Node packages that will help you interface with these systems. We won’t be covering those, though. Instead, we will be focused on providing so-called RESTful services, which are much more straightforward to interface with.</p>

<p><a data-type="indexterm" data-primary="REST/RESTful, defined" id="idm45053580981560"/>The acronym <em>REST</em> stands for <em>representational state transfer</em>, and the grammatically troubling <em>RESTful</em> is used as an adjective to describe a web service that satisfies the principles of REST. The formal description of REST is complicated and steeped in computer science formality, but the basics are that REST is a stateless connection between a client and a server. The formal definition of REST also specifies that the service can be cached and that services can be layered (that is, when you use a REST API, there may be other REST APIs beneath it).</p>

<p>From a practical standpoint, the constraints of HTTP actually make it difficult to create an API that’s not RESTful; you’d have to go out of your way to establish state, for example. So our work is mostly cut out for us.</p>






<section data-type="sect1" data-pdf-bookmark="JSON and XML"><div class="sect1" id="idm45053580978184">
<h1>JSON and XML</h1>

<p><a data-type="indexterm" data-primary="JSON" data-secondary="XML and" id="idm45053580976984"/><a data-type="indexterm" data-primary="REST APIs" data-secondary="JSON and XML" id="idm45053580976008"/><a data-type="indexterm" data-primary="XML, JSON and" id="idm45053580975064"/>Vital to providing an API is having a common language to speak in. Part of the communication is dictated for us: we must use HTTP methods to communicate with the server. But past that, we are free to use whatever data language we choose. Traditionally, XML has been a popular choice, and it remains an important markup language. While XML is not particularly complicated, <a data-type="indexterm" data-primary="Crockford, Douglas" id="idm45053580973880"/><a data-type="indexterm" data-primary="JSON" data-secondary="origins" id="idm45053580973208"/>Douglas Crockford saw that there was room for something more lightweight, and JavaScript Object Notation (JSON) was born. In addition to being JavaScript-friendly (though it is by no means proprietary; it is an easy format for any language to parse), it also has the advantage of being generally easier to write by hand than XML.</p>

<p>I prefer JSON over XML for most applications: there’s better JavaScript support, and it’s a simpler, more compact format. I recommend focusing on JSON and providing XML only if existing systems require XML to communicate with your app.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Our API"><div class="sect1" id="idm45053580970888">
<h1>Our API</h1>

<p><a data-type="indexterm" data-primary="REST APIs" data-secondary="planning an API" id="idm45053580969448"/>We’ll plan our API before we start implementing it. In addition to listing vacations and subscribing to “in-season” notifications, we’ll add a “delete vacation” endpoint. Since this is a public API, we won’t actually delete the vacation. We’ll simply mark it as “delete requested” so an administrator can review. For example, you might use this unsecured endpoint to allow vendors to request the removal of vacations from the site, which could then later be reviewed by an administrator. Here are our API endpoints.</p>
<dl>
<dt><code>GET /api/vacations</code></dt>
<dd>
<p>Retrieves vacations</p>
</dd>
<dt><code>GET /api/vacation/:sku</code></dt>
<dd>
<p>Returns a vacation by its SKU</p>
</dd>
<dt><code>POST /api/vacation/:sku/notify-when-in-season</code></dt>
<dd>
<p>Takes <code>email</code> as a querystring parameter and adds a notification listener for the specified vacation</p>
</dd>
<dt><code>DELETE /api/vacation/:sku</code></dt>
<dd>
<p>Requests the deletion of a vacation; takes <code>email</code> (the person requesting the deletion) and <code>notes</code> as querystring parameters</p>
<pre>[NOTE]</pre>
<div data-type="example">
<h5><span class="label">Example 15-1. </span></h5>

<p><a data-type="indexterm" data-primary="HTTP" data-secondary="verbs" id="idm45053580958440"/>There are many HTTP verbs available. <code>GET</code> and <code>POST</code> are the most common,
followed by <code>DELETE</code> and <code>PUT</code>. It has become a standard to use <code>POST</code> for
<em>creating</em> something, and <code>PUT</code> for <em>updating</em> (or modifying) something.
The English meaning of these words doesn’t support this distinction in any
way, so you may want to consider using the path to distinguish between
these two operations to avoid confusion. If you want more information
about HTTP verbs, I recommend starting with this <a href="http://bit.ly/32L4QWt">Tamas Piros article</a>.</p></div>
</dd>
</dl>

<p>There are many ways we could have described our API. Here, we’ve chosen to use <span class="keep-together">combinations</span> of HTTP methods and paths to distinguish our API calls, and a mix of querystring and body parameters for passing data. As an alternative, we could have had different paths (such as <em>/api/vacations/delete</em>) with the same method.<sup><a data-type="noteref" id="idm45053580950936-marker" href="ch15.xhtml#idm45053580950936">1</a></sup> We could also have passed data in a consistent way. For example, we might have chosen to pass all the necessary information for retrieving parameters in the URL instead of using a querystring: <code>DEL /api/vacation/:id/:email/:notes</code>. To avoid excessively long URLs, I recommend using the request body to pass large blocks of data (for example, the deletion request notes).</p>
<div data-type="tip"><h6>Tip</h6>
<p><a data-type="indexterm" data-primary="JSON:API" id="idm45053580947768"/>There is a popular and well-respected convention for JSON APIs, creatively
named JSON:API. It’s a bit verbose and repetitive for my taste, but I also
believe that an imperfect standard is better than no standard at all.
While we’re not using JSON:API for this book, you will learn everything you
need to adopt the conventions laid down by JSON:API. See the
<a href="https://jsonapi.org">JSON:API home page</a> for more information.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="API Error Reporting"><div class="sect1" id="idm45053580945640">
<h1>API Error Reporting</h1>

<p><a data-type="indexterm" data-primary="error handling/reporting" data-secondary="REST APIs" id="idm45053580944408"/><a data-type="indexterm" data-primary="HTTP APIs" id="idm45053580943464"/><a data-type="indexterm" data-primary="REST APIs" data-secondary="error reporting" id="idm45053580942792"/>Error reporting in HTTP APIs is usually achieved through HTTP status codes. If the request returns 200 (OK), the client knows the request was successful. If the request returns 500 (Internal Server Error), the request failed. In most applications, however, not everything can (or should be) categorized coarsely into “success” or “failure.” For example, what if you request something by an ID but that ID doesn’t exist? This does not represent a server error. The client has asked for something that doesn’t exist. In general, errors can be grouped into the following categories:</p>
<dl>
<dt>Catastrophic errors</dt>
<dd>
<p><a data-type="indexterm" data-primary="catastrophic errors" id="idm45053580939544"/>Errors that result in an unstable or unknown state for the server. Usually, this is the result of an unhandled exception. The only safe way to recover from a catastrophic error is to restart the server. Ideally, any pending requests would receive a 500 response code, but if the failure is severe enough, the server may not be able to respond at all, and the request will time out.</p>
</dd>
<dt>Recoverable server errors</dt>
<dd>
<p><a data-type="indexterm" data-primary="recoverable errors" id="idm45053580937192"/>Recoverable errors do not require a server restart, or any other heroic action. The error is a result of an unexpected error condition on the server (for example, a database connection being unavailable). The problem may be transient or permanent. A 500 response code is appropriate in this situation.</p>
</dd>
<dt>Client errors</dt>
<dd>
<p><a data-type="indexterm" data-primary="client errors" id="idm45053580934888"/>Client errors are a result of the client making the mistake—usually missing or invalid parameters. It isn’t appropriate to use a 500 response code. After all, the server has not failed. Everything is working normally; the client just isn’t using the API correctly. You have a couple of options here: you could respond with a status code of 200 and describe the error in the response body, or you could additionally try to describe the error with an appropriate HTTP status code. I recommend the latter approach. The most useful response codes in this case are 404 (Not Found), 400 (Bad Request), and 401 (Unauthorized). Additionally, the response body should contain an explanation of the specifics of the error. If you want to go above and beyond, the error message would even contain a link to documentation. Note that if the user requests a list of things and there’s nothing to return, this is not an error condition. It’s appropriate to simply return an empty list.</p>
</dd>
</dl>

<p>In our application, we’ll be using a combination of HTTP response codes and error messages in the body.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Cross-Origin Resource Sharing"><div class="sect1" id="idm45053580932168">
<h1>Cross-Origin Resource Sharing</h1>

<p><a data-type="indexterm" data-primary="CORS (cross-origin resource sharing)" id="idm45053580930712"/><a data-type="indexterm" data-primary="cross-origin resource sharing (CORS)" id="idm45053580929832"/><a data-type="indexterm" data-primary="REST APIs" data-secondary="cross-origin resource sharing" id="idm45053580929144"/>If you’re publishing an API, you’ll likely want to make the API available
to others. <a data-type="indexterm" data-primary="cross-site HTTP requests" id="idm45053580927944"/>This will result in a
<em>cross-site HTTP request</em>. Cross-site HTTP requests have been the subject
of many attacks and have therefore been restricted by the <em>same-origin
policy</em>, which restricts where scripts can be loaded from. Specifically,
the protocol, domain, and port must match. This
makes it impossible for your API to be used by another site, which is where cross-origin resource sharing
(CORS) comes in. CORS allows you to lift this restriction on a case-by-case
basis, even allowing you to list which domains specifically are allowed to
access the script. <a data-type="indexterm" data-primary="Access-Control-Allow-Origin header" id="idm45053580925768"/>CORS is implemented through the
<code>Access-Control-Allow-Origin</code> header. <a data-type="indexterm" data-primary="cors package" id="idm45053580924488"/>The easiest way to implement it in an Express application is to
use the <code>cors</code> package (<code>npm install cors</code>). To enable CORS for your
application, use this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">cors</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'cors'</code><code class="p">)</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">cors</code><code class="p">())</code></pre>

<p>Because the same-origin API is there for a reason (to prevent attacks), I recommend applying CORS only where necessary. In our case, we want to expose our entire API (but only the API), so we’re going to restrict CORS to paths starting with <em>/api</em>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">cors</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'cors'</code><code class="p">)</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="s1">'/api'</code><code class="p">,</code> <code class="nx">cors</code><code class="p">())</code></pre>

<p>See the <a href="https://github.com/expressjs/cors">package documentation</a> for information about more advanced use of CORS.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Our Tests"><div class="sect1" id="idm45053580836424">
<h1>Our Tests</h1>

<p><a data-type="indexterm" data-primary="REST APIs" data-secondary="testing" id="ix_ch-15-rest_apis_and_json-asciidoc2"/>If we use HTTP verbs other than <code>GET</code>, it can be a hassle to test our API, since browsers only know how to issue <code>GET</code> requests (and <code>POST</code> requests for forms). There are ways around this, such as the excellent application <a href="https://www.getpostman.com">Postman</a>. However, whether or not you use such a utility, it’s good to have automated tests. Before we write tests for our API, we need a way to actually <em>call</em> a REST API. <a data-type="indexterm" data-primary="node-fetch package" id="idm45053580830840"/>For that, we’ll be using a Node package called <code>node-fetch</code>, which replicates the browser’s <em>fetch</em> API:</p>

<pre data-type="programlisting">npm install --save-dev node-fetch@2.6.0</pre>

<p>We’ll put the tests for the API calls we’re going to implement in
<em>tests/api/api.test.js</em> (<em>ch15/test/api/api.test.js</em> in the companion
repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fetch</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'node-fetch'</code><code class="p">)</code>

<code class="kr">const</code> <code class="nx">baseUrl</code> <code class="o">=</code> <code class="s1">'http://localhost:3000'</code>

<code class="kr">const</code> <code class="nx">_fetch</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">method</code><code class="p">,</code> <code class="nx">path</code><code class="p">,</code> <code class="nx">body</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">body</code> <code class="o">=</code> <code class="k">typeof</code> <code class="nx">body</code> <code class="o">===</code> <code class="s1">'string'</code> <code class="o">?</code> <code class="nx">body</code> <code class="o">:</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">body</code><code class="p">)</code>
  <code class="kr">const</code> <code class="nx">headers</code> <code class="o">=</code> <code class="p">{</code> <code class="s1">'Content-Type'</code><code class="o">:</code> <code class="s1">'application/json'</code> <code class="p">}</code>
  <code class="kr">const</code> <code class="nx">res</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">baseUrl</code> <code class="o">+</code> <code class="nx">path</code><code class="p">,</code> <code class="p">{</code> <code class="nx">method</code><code class="p">,</code> <code class="nx">body</code><code class="p">,</code> <code class="nx">headers</code> <code class="p">})</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">res</code><code class="p">.</code><code class="nx">status</code> <code class="o">&lt;</code> <code class="mi">200</code> <code class="o">||</code> <code class="nx">res</code><code class="p">.</code><code class="nx">status</code> <code class="o">&gt;</code> <code class="mi">299</code><code class="p">)</code>
    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`API returned status </code><code class="si">${</code><code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="si">}</code><code class="sb">`</code><code class="p">)</code>
  <code class="k">return</code> <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">()</code>
<code class="p">}</code>

<code class="nx">describe</code><code class="p">(</code><code class="s1">'API tests'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>

  <code class="nx">test</code><code class="p">(</code><code class="s1">'GET /api/vacations'</code><code class="p">,</code> <code class="nx">async</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">vacations</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">_fetch</code><code class="p">(</code><code class="s1">'get'</code><code class="p">,</code> <code class="s1">'/api/vacations'</code><code class="p">)</code>
    <code class="nx">expect</code><code class="p">(</code><code class="nx">vacations</code><code class="p">.</code><code class="nx">length</code><code class="p">).</code><code class="nx">not</code><code class="p">.</code><code class="nx">toBe</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
    <code class="kr">const</code> <code class="nx">vacation0</code> <code class="o">=</code> <code class="nx">vacations</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
    <code class="nx">expect</code><code class="p">(</code><code class="nx">vacation0</code><code class="p">.</code><code class="nx">name</code><code class="p">).</code><code class="nx">toMatch</code><code class="p">(</code><code class="sr">/\w/</code><code class="p">)</code>
    <code class="nx">expect</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">vacation0</code><code class="p">.</code><code class="nx">price</code><code class="p">).</code><code class="nx">toBe</code><code class="p">(</code><code class="s1">'number'</code><code class="p">)</code>
  <code class="p">})</code>

  <code class="nx">test</code><code class="p">(</code><code class="s1">'GET /api/vacation/:sku'</code><code class="p">,</code> <code class="nx">async</code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">vacations</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">_fetch</code><code class="p">(</code><code class="s1">'get'</code><code class="p">,</code> <code class="s1">'/api/vacations'</code><code class="p">)</code>
    <code class="nx">expect</code><code class="p">(</code><code class="nx">vacations</code><code class="p">.</code><code class="nx">length</code><code class="p">).</code><code class="nx">not</code><code class="p">.</code><code class="nx">toBe</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
    <code class="kr">const</code> <code class="nx">vacation0</code> <code class="o">=</code> <code class="nx">vacations</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
    <code class="kr">const</code> <code class="nx">vacation</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">_fetch</code><code class="p">(</code><code class="s1">'get'</code><code class="p">,</code> <code class="s1">'/api/vacation/'</code> <code class="o">+</code> <code class="nx">vacation0</code><code class="p">.</code><code class="nx">sku</code><code class="p">)</code>
    <code class="nx">expect</code><code class="p">(</code><code class="nx">vacation</code><code class="p">.</code><code class="nx">name</code><code class="p">).</code><code class="nx">toBe</code><code class="p">(</code><code class="nx">vacation0</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code>
  <code class="p">})</code>

  <code class="nx">test</code><code class="p">(</code><code class="s1">'POST /api/vacation/:sku/notify-when-in-season'</code><code class="p">,</code> <code class="nx">async</code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">vacations</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">_fetch</code><code class="p">(</code><code class="s1">'get'</code><code class="p">,</code> <code class="s1">'/api/vacations'</code><code class="p">)</code>
    <code class="nx">expect</code><code class="p">(</code><code class="nx">vacations</code><code class="p">.</code><code class="nx">length</code><code class="p">).</code><code class="nx">not</code><code class="p">.</code><code class="nx">toBe</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
    <code class="kr">const</code> <code class="nx">vacation0</code> <code class="o">=</code> <code class="nx">vacations</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
    <code class="c1">// at this moment, all we can do is make sure the HTTP request is successful</code>
    <code class="nx">await</code> <code class="nx">_fetch</code><code class="p">(</code><code class="s1">'post'</code><code class="p">,</code> <code class="sb">`/api/vacation/</code><code class="si">${</code><code class="nx">vacation0</code><code class="p">.</code><code class="nx">sku</code><code class="si">}</code><code class="sb">/notify-when-in-season`</code><code class="p">,</code>
      <code class="p">{</code> <code class="nx">email</code><code class="o">:</code> <code class="s1">'test@meadowlarktravel.com'</code> <code class="p">})</code>
  <code class="p">})</code>

  <code class="nx">test</code><code class="p">(</code><code class="s1">'DELETE /api/vacation/:id'</code><code class="p">,</code> <code class="nx">async</code><code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">vacations</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">_fetch</code><code class="p">(</code><code class="s1">'get'</code><code class="p">,</code> <code class="s1">'/api/vacations'</code><code class="p">)</code>
    <code class="nx">expect</code><code class="p">(</code><code class="nx">vacations</code><code class="p">.</code><code class="nx">length</code><code class="p">).</code><code class="nx">not</code><code class="p">.</code><code class="nx">toBe</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>
    <code class="kr">const</code> <code class="nx">vacation0</code> <code class="o">=</code> <code class="nx">vacations</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>
    <code class="c1">// at this moment, all we can do is make sure the HTTP request is successful</code>
    <code class="nx">await</code> <code class="nx">_fetch</code><code class="p">(</code><code class="s1">'delete'</code><code class="p">,</code> <code class="sb">`/api/vacation/</code><code class="si">${</code><code class="nx">vacation0</code><code class="p">.</code><code class="nx">sku</code><code class="si">}</code><code class="sb">`</code><code class="p">)</code>
  <code class="p">})</code>

<code class="p">})</code></pre>

<p>Our test suite starts off with a helper function <code>_fetch</code>, which handles some common housekeeping. It will JSON encode the body if it isn’t already, add the appropriate headers, and throw an appropriate error if the response status code isn’t in the 200s.</p>

<p>We have a single test for each of our API endpoints. I’m not suggesting that these tests are robust or complete; even with this simple API, we could (and should) have several tests for each endpoint. What we have here is more of a starting point that illustrates techniques for testing an API.</p>

<p>There are a couple of important characteristics of these tests that deserve mention. One is that we are relying on the API being already started and running on port 3000. A more robust test suite would find an open port, start the API on that port as part of its setup, and stop it when all the tests have run. Second, this test relies on data already being present in our API. For example, the first test expects there to be at least one vacation, and for that vacation to have a name and a price. In a real application, you may not be able to make these assumptions (for example, you may start with no data, and you may want to test for allowable missing data). Again, a more robust testing framework would have a way of setting and resetting the initial data in the API so you could start from a known state every time. For example, you might have scripts that set up and seed a test database, attach the API to it, and tear it down for every test run. As we saw in <a data-type="xref" href="ch05.xhtml#ch_qa">Chapter 5</a>, testing is a large and complicated topic, and we can only scratch the surface here.</p>

<p>The first test covers our <code>GET /api/vacations</code> endpoint. It fetches all of the vacations, validates that there is at least one, and checks the first one to see if it has a name and a price. We could also conceivably test other data properties. I’ll leave it as a reader’s exercise to think about which properties are most important to test.</p>

<p>The second test covers our <code>GET /api/vacation/:sku</code> endpoint. Since we don’t have consistent test data, we start by fetching all of the vacations and getting the SKU from the first one so we can test this endpoint.</p>

<p>Our last two tests cover our <code>POST /api/vacation/:sku/notify-when-in-season</code> and <code>DELETE /api/vacation/:sku</code> endpoints. Unfortunately, with our current API and testing framework, we can do very little to verify that these endpoints are doing what they are supposed to, so we default to invoking them and trusting the API is doing the right thing when it doesn’t return an error. If we wanted to make these tests more robust, we would have to either add endpoints that allow us to verify the actions (for example, an endpoint that determined if a given email was registered for a specific vacation) or somehow give the tests “backdoor” access to our database.</p>

<p>If you run the tests now, they will time out and fail…because we haven’t implemented our API or even started our server. So let’s get started!<a data-type="indexterm" data-startref="ix_ch-15-rest_apis_and_json-asciidoc2" id="idm45053580479624"/></p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Using Express to Provide an API"><div class="sect1" id="idm45053580835832">
<h1>Using Express to Provide an API</h1>

<p><a data-type="indexterm" data-primary="Express" data-secondary="APIs provided by" id="idm45053580477480"/><a data-type="indexterm" data-primary="REST APIs" data-secondary="Express as source of" id="idm45053580476504"/>Express is quite capable of providing an API. There are various npm modules available that provide helpful functionality (see <code>connect-rest</code> and <code>json-api</code>, for example), but I find that Express is perfectly capable out of the box, and we’ll be sticking with a pure Express implementation.</p>

<p>We’ll start by creating the handlers in <em>lib/handlers.js</em> (we could create a separate file, such as <em>lib/api.js</em>, but let’s keep things simple for now):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">exports</code><code class="p">.</code><code class="nx">getVacationsApi</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">vacations</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">db</code><code class="p">.</code><code class="nx">getVacations</code><code class="p">({</code> <code class="nx">available</code><code class="o">:</code> <code class="kc">true</code> <code class="p">})</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">(</code><code class="nx">vacations</code><code class="p">)</code>
<code class="p">}</code>

<code class="nx">exports</code><code class="p">.</code><code class="nx">getVacationBySkuApi</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">vacation</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">db</code><code class="p">.</code><code class="nx">getVacationBySku</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">sku</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">(</code><code class="nx">vacation</code><code class="p">)</code>
<code class="p">}</code>

<code class="nx">exports</code><code class="p">.</code><code class="nx">addVacationInSeasonListenerApi</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">await</code> <code class="nx">db</code><code class="p">.</code><code class="nx">addVacationInSeasonListener</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">sku</code><code class="p">,</code> <code class="nx">req</code><code class="p">.</code><code class="nx">body</code><code class="p">.</code><code class="nx">email</code><code class="p">)</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">json</code><code class="p">({</code> <code class="nx">message</code><code class="o">:</code> <code class="s1">'success'</code> <code class="p">})</code>
<code class="p">}</code>

<code class="nx">exports</code><code class="p">.</code><code class="nx">requestDeleteVacationApi</code> <code class="o">=</code> <code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="p">{</code> <code class="nx">email</code><code class="p">,</code> <code class="nx">notes</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">body</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">status</code><code class="p">(</code><code class="mi">500</code><code class="p">).</code><code class="nx">json</code><code class="p">({</code> <code class="nx">message</code><code class="o">:</code> <code class="s1">'not yet implemented'</code> <code class="p">})</code>
<code class="p">}</code></pre>

<p>Then we hook up the API in <em>meadowlark.js</em>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/api/vacations'</code><code class="p">,</code> <code class="nx">handlers</code><code class="p">.</code><code class="nx">getVacationsApi</code><code class="p">)</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/api/vacation/:sku'</code><code class="p">,</code> <code class="nx">handlers</code><code class="p">.</code><code class="nx">getVacationBySkuApi</code><code class="p">)</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">post</code><code class="p">(</code><code class="s1">'/api/vacation/:sku/notify-when-in-season'</code><code class="p">,</code>
  <code class="nx">handlers</code><code class="p">.</code><code class="nx">addVacationInSeasonListenerApi</code><code class="p">)</code>
<code class="nx">app</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="s1">'/api/vacation/:sku'</code><code class="p">,</code> <code class="nx">handlers</code><code class="p">.</code><code class="nx">requestDeleteVacationApi</code><code class="p">)</code></pre>

<p>Nothing here should be particularly surprising by now. Note that we’re using our database abstraction layer, so it doesn’t matter if we use our MongoDB implementation or our PostgreSQL implementation (though you will find minor inconsequential extra fields depending on the implementation, which we could remove if necessary).</p>

<p>I am leaving <code>requestDeleteVacationsApi</code> as a reader’s exercise, mainly because this functionality could be implemented so many different ways. The simplest approach would be to just modify our vacation schema to have “delete requested” fields that just get updated with the email and notes when the API is called. A more sophisticated approach would be to have a separate table, like a moderation queue, that records the deletion requests separately, referencing the vacation in question, which would better lend itself to administrator use.</p>

<p>Assuming you set up Jest correctly in <a data-type="xref" href="ch05.xhtml#ch_qa">Chapter 5</a>, you should just be able to run <code>npm test</code>, and the API tests will be picked up (Jest will look for any file that ends in <code>.test.js</code>). You’ll see we have three passing tests and one failing one: the incomplete <code>DELETE /api/vacation/:sku</code>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45053580313400">
<h1>Conclusion</h1>

<p>I hope this chapter has left you asking, “That’s it?” At this point, you’re probably realizing that the primary function of Express is to respond to HTTP requests. What the requests are for—and how they respond—is entirely up to you. Do they need to respond with HTML? CSS? Plain text? JSON? All easy to do with Express. You could even respond with binary file types. For example, it would not be hard to dynamically construct and return images. In this sense, an API is just another one of the many ways Express can respond.</p>

<p>In the next chapter, we’ll put this API to use by building a single-page application, and replicate what we’ve done in previous chapters in a different way.<a data-type="indexterm" data-startref="ix_ch-15-rest_apis_and_json-asciidoc1" id="idm45053580310920"/><a data-type="indexterm" data-startref="ix_ch-15-rest_apis_and_json-asciidoc0" id="idm45053580310200"/></p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45053580950936"><sup><a href="ch15.xhtml#idm45053580950936-marker">1</a></sup> If your client can’t use different HTTP methods, see <a href="http://bit.ly/2O7nr9E">this module</a>, which allows you to “fake” different HTTP methods.</p></div></div></section></div>



  </body></html>