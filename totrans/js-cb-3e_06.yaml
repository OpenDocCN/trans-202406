- en: Chapter 5\. Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since its inception, JavaScript has had arrays as a separate, standalone data
    type. But over the years, the way we interact with arrays has changed considerably.
  prefs: []
  type: TYPE_NORMAL
- en: In the past, manipulating an array involved plenty of loops and iterative logic,
    along with a small set of underpowered methods. Today, the `Array` object is stocked
    with much more functionality, including methods that emphasize *functional* approaches.
    Using these methods, you can filter, sort, copy, and transform data, without stepping
    through array elements one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll see how to use these functional approaches—and learn
    when you might need to sidestep them. The focus is on solving problems using the
    most modern practices that are available today.
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re trying these examples out in the browser’s developer console, be warned
    that *lazy evaluation* can fool you. For example, consider what happens if you
    output an array with `console.log()`, sort it, and then log it again. You expect
    to see the information for two differently sorted arrays. But you’ll actually
    see the final, sorted array twice. That’s because most browsers won’t examine
    the items in your array until you open the console and click to expand the array.
    One way to avoid this problem is to iterate over the array and log each item separately.
    For more about the issue, see [“Why Chrome’s Developer Console Sometimes Lies”](https://oreil.ly/VDHtm).
  prefs: []
  type: TYPE_NORMAL
- en: Checking If an Object Is an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you perform an array operation, you want to verify that your object truly
    is an array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the static `Array.isArray()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Array.isArray()` method is an obvious choice. Problems happen when developers
    are tempted to use the older `instanceOf` operator. For historical reasons, the
    `instanceOf` operator has weird edge cases with arrays (for example, it returns
    `false` when you test an array that was created in another execution context,
    such as a different window). The `isArray()` method was added to patch this gap.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also important to understand that `isArray()` specifically checks for instances
    of the `Array` object. If you call it on a different type of collection (like
    `Map` or `Set`), it returns `false`. This is true even if these collections have
    array-like semantics, and even if they have *array* in the name, like `TypedArray`
    (a low-level wrapper for a buffer of binary data).
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Over All the Elements in an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the best approach for looping over every element in an array,
    in order.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The traditional approach is a `for`…`of` loop, which automatically gets each
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In modern JavaScript, it’s becoming increasingly common to favor *functional*
    approaches in array-processing code. You can iterate over your array in a functional
    way using the `Array.forEach()` method. You supply a function, and that function
    is called once for each element in the array, and passed three potentially useful
    parameters (the element, the element’s index, and the original array). Here’s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to condense this further with arrow syntax ([“Using Arrow Functions”](ch06.html#arrow_functions)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In long-lived languages like JavaScript, there are often many ways to accomplish
    the same thing. The `for`…`of` loop offers a straightforward syntax for iterating
    over an array. It doesn’t allow you to modify the elements in the array you’re
    traversing, which is a safe, sensible approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are cases when you’ll need to use something different. One of
    the most flexible choices is a basic `for` loop with a counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This approach can allow off-by-one errors to slip by undetected, which are still
    a surprisingly common source of mistakes in modern-day programming. However, you’ll
    need to use a `for` loop in some situations, such as when you’re moving through
    more than one array at the same time (see [“Checking If Two Arrays Are Equal”](#checking_if_two_arrays_are_equal)).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also iterate over an array by passing a function to the `Array.forEach()`
    method. This function is then called once for each element. Your function can
    receive three parameters: the current array element, the current array index,
    and a reference to the original array. Usually, you’ll only need the element.
    (You could use the index to make changes to the element in the original array,
    but that’s considered bad form.)'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, if you want to use a functional approach to change or examine your
    array, consider using a more specific, targeted method. [Table 5-1](#functional_array_methods)
    lists the most useful.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Methods for functional array processing
  prefs: []
  type: TYPE_NORMAL
- en: '| Task | Array method | Covered in |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Change every array element | `map()` | [“Transforming Every Element of an
    Array”](#mapping_array) |'
  prefs: []
  type: TYPE_TB
- en: '| See if all elements meet a specific condition | `every()` | [“Validating
    Array Contents”](#validating_array) |'
  prefs: []
  type: TYPE_TB
- en: '| See if at least one element meets a specific condition | `some()` | [“Validating
    Array Contents”](#validating_array) |'
  prefs: []
  type: TYPE_TB
- en: '| Find array elements matching your criteria | `filter()` | [“Extracting Array
    Items That Meet Specific Criteria”](#copying_items_by_criteria) |'
  prefs: []
  type: TYPE_TB
- en: '| Reorder an array | `sort()` | [“Sorting an Array of Objects by a Property
    Value”](#sorting_array) |'
  prefs: []
  type: TYPE_TB
- en: '| Use all the values of an array in one calculation | `reduce()` | [“Combining
    an Array’s Values in a Single Calculation”](#reducing_array) |'
  prefs: []
  type: TYPE_TB
- en: Modern coding practice favors *functional approaches* to array processing over
    *iterative approaches*. The advantage of a functional approach is that your code
    can be more concise, often more readable, and less error-prone. Most of the time,
    the functional approach also enforces *immutability* for your array. It does that
    by creating a new copy of the array with the changes you want, rather than making
    direct modifications on the original array object. This approach also makes certain
    types of errors less likely.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As a rule of thumb, look at the functional array methods as a *first resort*.
    If they make your task more difficult (which might happen if you need to write
    multiple arrays or perform several array operations at once), switch to the iterative
    approach. And if you’re writing performance-intensive code (for example, routines
    that operate on extremely large arrays), consider the iterative approach, because
    it tends to perform better. But don’t forget to profile both approaches first
    to see if the difference is truly significant.
  prefs: []
  type: TYPE_NORMAL
- en: Checking If Two Arrays Are Equal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a simple way to test if two arrays are equivalent (have exactly the
    same contents).
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most straightforward approach is actually the old-fashioned approach: use
    a basic `for` loop with a counter, step through both arrays at the same time,
    and compare each element. Of course, there are a couple of checks to make before
    you start looping, like verifying that each object is an array, isn’t null, and
    so on. Here’s a bit of code that packages all these criteria into a single useful
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can check that two arrays are the same, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this version of `areArraysEqual()`, arrays with the same items in a different
    order are considered nonmatching. You can easily sort arrays of strings or numbers
    using the `Array.sort()` method. However, it doesn’t make sense to put this code
    in the `areArrayEquals()` method, because it may not be appropriate for the data
    types you want to use, or it may be prohibitively slow if you want to compare
    huge arrays. Instead, sort your arrays before you test them for equality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often in programming, it’s up to you to decide what equality means. In this
    example, `areArraysEqual()` performs a *shallow compare*. If two arrays have the
    same primitives or the same object references, and their elements are in the same
    order, they match. But if you start comparing more complex *objects*, ambiguities
    appear.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this comparison of two arrays that hold a single, identical
    `Date` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These arrays don’t match because even though the underlying date content is
    the same, the `Date` *instances* are different. (Or, to put it another way, there
    are two separate `Date` objects that just happen to save the same information
    in them.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can easily compare the content of two `Date` objects (just call
    `getTime()` to convert them to the millisecond time representation, as explained
    in [“Comparing Dates and Testing Dates for Equality”](ch04.html#comparing_dates)).
    But if you want to do that in an array comparison, it’s up to you to write a different
    function. In your function, you can use `instanceOf` to identify `Date` objects,
    and then call `getTime()` on them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The problem shown in this example applies to arrays that hold any type of JavaScript
    object. It even applies to arrays that hold nested arrays (because every `Array`
    is an object). Your solution will differ, however, because different equality
    tests make sense for different objects.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s worth noting that many popular JavaScript libraries have their
    own generic solutions for deep array comparison, which may or may not be suitable
    for your data. If you’re already using a library like Lodash or *Underscore.js*,
    investigate its `isEqual()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Down an Array into Separate Variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to assign array element values to several variables, but you want a
    convenient approach that doesn’t force you to assign each variable separately.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the array *destructuring syntax* to assign multiple variables at a time.
    You write an expression that declares several variables (on the left) and grabs
    the values from an array (on the right). Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When you use array destructuring, the values are copied by position. In this
    example, that means `arizona` gets the first value in the array, `missouri` the
    second, and so on. If you have more variables than array elements, the extra variables
    get the value `undefined`.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use array destructuring, you don’t need to copy every value that’s
    in the array. You can skip values you don’t want by adding extra commas without
    a variable name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the *rest operator* to stuff all the remaining values (ones
    you didn’t explicitly assign to variables) into a new array. Here’s an example
    that copies the three last array elements into an array named `others`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JavaScript’s rest operator looks just like the spread operator (it’s three dots
    before a variable). They even “feel” similar in your code, although they actually
    play complementary roles. The rest operator vacuums up extra values and squashes
    them into a single array. The spread operator *expands* an array (or another type
    of iterable object) into separate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far you’ve seen the variable declaration and assignment in one statement,
    but you can split them, just as you can when you create ordinary variables. Just
    make sure you keep the square brackets, because they indicate that you’re using
    array destructuring:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want a way to convert an array into a list of values *without* assigning
    these values to variables, check out the spread operator described in [“Passing
    an Array to a Function That Expects a List of Values”](#array_spread).
  prefs: []
  type: TYPE_NORMAL
- en: Passing an Array to a Function That Expects a List of Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your array has a list of values that you want to pass to a function. But the
    function expects a list of argument values, not an array object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the spread operator to expand your array. Here’s an example with the `Math.max()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spread operator unfolds an array into a list of elements. Technically, it
    works with any iterable object, including other types of collections. You’ll see
    it at work in several recipes in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The spread operator doesn’t need to supply all the arguments to a function,
    or even the final arguments. It’s perfectly valid to use it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You probably don’t want to use this approach if the order of your arguments
    has any significance. It’s just too easy to end up with an array that’s a bit
    bigger or smaller than you thought, which will then displace your other arguments
    to new positions and change their significance.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Merging Two Arrays”](#merging_arrays) shows an example of how you can use
    the spread operator to merge different arrays. [“Removing or Replacing Array Elements”](#removing_replacing_array)
    shows how you can use spread when removing items. [“Cloning an Array”](#cloning_arrays)
    shows how you can use spread to copy an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Cloning an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make a copy of an existing array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the spread operator to expand your array into items and feed it into a
    new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'An equally good approach is to use the `Array.slice()` method with no arguments,
    which tells it to take a slice of the entire array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Both of these approaches are preferable to looping over array elements and building
    up a new array by hand.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating array copies is important because it allows you to perform *nondestructive
    changes*. For example, you might keep your original array intact while you make
    changes to a new copy. That way, you reduce the risk of unanticipated side effects
    (for example, if other parts of your code are still using the original array).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all reference objects, arrays cannot be copied by assignment. This
    code, for example, ends with two variables pointing to the same in-memory `Array`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To properly copy an array, you need to duplicate all of its elements. The easiest
    approach is to use the spread operator, although the `Array.slice()` method works
    equally well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both approaches shown here create *shallow copies*. If your array consists
    of primitives (numbers, strings, or Boolean values), the copied array matches
    exactly. But if your array holds objects, these techniques copy the *reference*,
    not the entire object. As a result, your new array will have references pointing
    to the same objects. Change one of the objects in the copied array, and it also
    affects the original array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This may or may not be a problem, depending on how you plan to use your arrays.
    If you want multiple copies of objects that you can manipulate separately, there
    are several possible solutions you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: Loop through your array with a `for` loop, create the new objects you need explicitly,
    and then add them to the new array.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Array.map()` function. This works well for simple objects, but doesn’t
    do a deep clone all the way down. (For example, if you have objects referencing
    *other* objects, only the first layer of objects is truly duplicated.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a helper function from another JavaScript library, like `cloneDeep()` in
    Lodash or `clone()` in Ramda.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example that demonstrates `Array.map()`. It works a little bit of
    magic by first expanding the array element into its properties with the spread
    operator (…`element`), then uses them to create a new object (`{`…`element}`),
    which is assigned to the new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: To take a closer look at the `map()` method, see the full explanation in [“Transforming
    Every Element of an Array”](#mapping_array).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The spread operator (`...`) does double duty. In the original solution, you
    saw how the spread operator can expand an array into separate elements. In the
    `Array.map()` example, the spread operator expands an *object* into separate properties.
    For more about how the spread operator works on objects, see [“Merging the Properties
    of Two Objects”](ch07.html#merging_object_properties).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to copy only *some* array items, see [“Copying a Portion of an Array
    by Position”](#copying_items_by_position). To learn more about different ways
    of making deep copies of an object, see [“Making a Deep Copy of an Object”](ch07.html#deep_clone_an_object).
  prefs: []
  type: TYPE_NORMAL
- en: Merging Two Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to join two entire arrays together into a new array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two commonly used approaches for combining two arrays. The time-honored
    approach (and likely the most performant option) is to use the `Array.concat()`
    method. You call `concat()` on the first array, passing in the second array as
    an argument. The result is a third array that contains all the elements of both:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The resulting array has the first array’s items first (`evens`, in this example),
    followed by second array’s items (`odds`). Of course, you can follow up your `concat()`
    with a call to the `Array.sort()` method ([“Sorting an Array of Objects by a Property
    Value”](#sorting_array)).
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternate approach is to use the spread operator (introduced in [“Passing
    an Array to a Function That Expects a List of Values”](#array_spread)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The advantage of this approach is that the code is (arguably) more intuitive
    and easier to read. The spread operator is also a great tool if you want to combine
    more than two arrays at a time, or you want to combine arrays with literal values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Performance testing suggests that on current implementations, large arrays are
    merged faster with `concat()`. But in most scenarios, this performance different
    won’t be significant (or even apparent).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you merge arrays with either of these techniques, you are left with three
    arrays: the original two, and the new merged result. If your arrays contain primitive
    values (numbers, strings, Boolean values), these are duplicated in the new array.
    But if your array holds objects, the object *reference* is copied. For example,
    if you merge two arrays of `Date` objects, no new `Date` objects are created.
    Instead, the new merged array gets references pointing to the *same* `Date` objects.
    If you change a `Date` object in the merged array, you’ll see the modification
    in the original array as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: For more about the difference between shallow and deep copies, see [“Making
    a Deep Copy of an Object”](ch07.html#deep_clone_an_object).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you merge arrays, you have no power to control how the elements are combined.
    If you want to copy just a portion of an array, or put one array in the *middle*
    of another, see the `slice()` method in [“Copying a Portion of an Array by Position”](#copying_items_by_position).
  prefs: []
  type: TYPE_NORMAL
- en: Copying a Portion of an Array by Position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to copy a portion of an array, and keep the original array intact.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Array.slice()` method, which makes a *shallow copy* of a portion of
    an existing array, and returns that as a new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `slice()` method takes two parameters, indicating a starting and ending
    position. You can omit the second parameter to go from the start index to the
    end of the array. Calling `slice(0)` on an array copies the whole array.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code uses slice to get two subsections of the first array,
    and use them to build a new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This may seem like an arbitrary example, because the index numbers are hard-coded.
    But you can combine it with array searches and the `findIndex()` method (see [“Searching
    Through an Array for Exact Matches”](#searching_array_exact_matches)) to find
    the place where you should divide an array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `slice()` method is easily confused with the `splice()` method, which is
    used to replace or delete portions of an array. Unlike `slice()`, the `splice()`
    method makes in-place changes that affect the original array. In modern practice,
    it’s considered better to lock-down your objects, keep them immutable when possible
    (hence the use of `const`), and create a new copy with changes. So stick with
    `slice()` unless you have a strong reason to use `splice()` (for example, there’s
    a difference in performance that’s significant in your use case).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Removing or Replacing Array Elements”](#removing_replacing_array) shows how
    you can use `slice()` to remove sections of an array.'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Array Items That Meet Specific Criteria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find all the items in an array that match a certain condition, and
    copy them to a new array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Array.filter()` method to run a test on every item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This example is intentionally long-winded so you can see the different pieces
    of the solution. The *filter function* is called for every item in the array.
    In this case, that means `startsWithE()` is called 10 times, and passed a different
    string each time. If the filter function returns `true`, that item is added to
    the new array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the same example condensed with an arrow function. Now the filter logic
    is defined in the same place in code where you use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, the filter function checks that each item begins with the letter
    *e*. But you could just as easily grab numbers that fall in a certain range, or
    objects that have certain property values.
  prefs: []
  type: TYPE_NORMAL
- en: The `filter()` method is one of a new set of modern array methods that replace
    old-fashioned iterative code with a functional approach. Nothing stops you from
    using a `for` loop to step through your array, test each item, and insert matches
    into a new array with `Array.push()`. However, if you can perform the same task
    with the `filter()` method, you’ll usually be rewarded with more compact code
    and easier testing.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several of the recipes in this chapter introduce similar methods for functional
    array processing. In particular, [“Transforming Every Element of an Array”](#mapping_array)
    shows how to transform all the elements in an array, and [“Combining an Array’s
    Values in a Single Calculation”](#reducing_array) shows how to perform a calculation
    that combines all the values in an array into one result.
  prefs: []
  type: TYPE_NORMAL
- en: Emptying an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to remove all the elements from an array, either to reclaim memory
    or so that your array can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set the `length` property of your array to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the easiest ways to give yourself a new array is to simply assign a
    new blank array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: However, this approach has a couple of limits. First, because it creates a whole
    new array object, it doesn’t work if you’ve defined your array with the `const`
    keyword. This is a small detail, but modern practice favors using `const` over
    `let` to narrow the possibilities for bugs in your code. Second, this assignment
    doesn’t actually destroy the array. If you have another variable pointing to your
    array, it will stay alive and remain in memory.
  prefs: []
  type: TYPE_NORMAL
- en: An alternate solution is to call the `Array.pop()` method repeatedly. Each time
    you call `pop()`, you remove the last item from the array, so you can empty an
    array with a loop that continues calling `pop()` until the array is empty. However,
    the `length` setting trick has exactly the same effect and requires just a single
    statement. Developers sometimes overlook this technique, because they expect `length`
    to be a read-only property (as it is in many other languages). But setting `length`
    on a JavaScript array allows you to shrink its size and drop the leftover items.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other interesting ways to use the `length` property. For example,
    you can chop off only part of an array by reducing `length`, but not all the way
    to 0\. Or, you can add blank items to the end of an array by increasing `length`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Removing Duplicate Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to ensure that every value in your array is unique by removing the
    duplicates.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `Set` object and fill it with your array. The `Set` object will
    discard duplicates automatically. Then, convert the `Set` object back to an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you understand the idea, you can compress this down to a single statement
    with the spread operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Set` object is a special type of collection that ignores duplicate values.
    It also works as a quick and efficient way to remove duplicates from an array.
    This technique (switching to a `Set` and then back to an array) is far more efficient
    than iterating over the array and looking for duplicates with `findIndex()`.
  prefs: []
  type: TYPE_NORMAL
- en: When searching for duplicates, the `Set` uses a test that’s similar to the strict
    equality comparison `===`, which means 3 and `'3'` are not considered duplicates.
    One special bit of behavior the `Set` implements is that it treats repeated `NaN`
    values as duplicates, even though `NaN === NaN` ordinarily evaluates to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example uses the spread operator described in [“Passing an Array to a Function
    That Expects a List of Values”](#array_spread). For more about the `Set` object,
    see [“Creating a Collection of Nonduplicated Values”](#using_set).
  prefs: []
  type: TYPE_NORMAL
- en: Flattening a Two-Dimensional Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to flatten a two-dimensional array so that it becomes a one-dimensional
    list.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Array.flat()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a two-dimensional array, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Each element in the `fruitArray` holds *another* array. For example, `fruitArray[0]`
    has three strings, representing different berries. `fruitArray[1]` has citrus
    fruits, and `fruitArray[2]` has stone fruits.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could transform `fruitArray` with the help of the `concat()` method. Start
    with the first nested array, call `concat()`, and pass the other nested arrays,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If the array has several members, this approach is tedious and error prone.
    Alternatively, you could use a loop or recursion, but these approaches can be
    equally tedious. The `flat()` method implements the same logic, and concatenates
    every row for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flat()` method takes an optional `depth` argument, with a default value
    of 1\. You can increase this number to flatten more deeply nested arrays. For
    example, imagine you have an array that contains nested arrays, and those arrays
    hold *another* layer of nested arrays. In this case, a `depth` of 2 will concatenate
    both layers, putting everything into a single list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `depth` argument sets the maximum level of flattening that’s used, if needed.
    There’s no risk to increasing the `depth` beyond the actual dimensions of your
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Searching Through an Array for Exact Matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to search an array for a specific value. You may want to know if the
    array contains a match, or the position where that match occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use one of the array searching methods: `indexOf()`, `lastIndexOf()`, or `includes()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This technique only works for primitive values (typically numbers, strings,
    and Boolean values). If you want to search for objects, you need to use the `Array.find()`
    method instead ([“Searching Through an Array for Items That Meet Specific Criteria”](#searching_array_test_function)).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `indexOf()` and `lastIndexOf()` take a search value that is then compared
    to every element in the array. If the value is found, they return the index position
    of the array element. If the value is not found, they return *–1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `indexOf()` method returns the first match found searching from lowest
    to highest index (in other words, starting at the beginning of the array and going
    forward). The `lastIndexOf()` method goes in reverse, starting at the end of the
    array. The difference appears if the same item appears more than once in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `indexOf()` and `lastIndexOf()` take an optional starting index argument.
    That sets the position where the search will begin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: It may occur to you that you can use a loop to step through increasingly higher
    indexes with `indexOf()` until you’ve found all the matches. But before you write
    that kind of boilerplate code, consider using the `filter()` method, which quickly
    and painlessly creates an array with all the matches for a condition you specify
    (see [“Extracting Array Items That Meet Specific Criteria”](#copying_items_by_criteria)).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s important to understand that `indexOf()`, `lastIndexOf()`, and
    `includes()` all use the `===` operator to test for matches. That means no type
    conversion is performed (so `3` will not equal `'3'`). Also, if your array contains
    objects, the references are compared, not the content. If you need to change the
    meaning of equality or you want to use a different search test, use the `findIndex()`
    method instead (see [“Searching Through an Array for Items That Meet Specific
    Criteria”](#searching_array_test_function)).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For customizable searching, see the `find()` and `findIndex()` methods in [“Searching
    Through an Array for Items That Meet Specific Criteria”](#searching_array_test_function).
  prefs: []
  type: TYPE_NORMAL
- en: Searching Through an Array for Items That Meet Specific Criteria
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to search an array for an item that meets certain criteria. For example,
    maybe you’re looking for an object with a specific property.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use one of the functional array searching methods: `find()` or `findIndex()`.
    Either way, you supply the function that tests each item until a match is found.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that finds the first number over 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If instead of finding the matching element, you would rather know its position,
    you can use the similar `findIndex()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If no match is found, `find()` returns `undefined`, and `findIndex()` returns
    –1.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using `find()` and `findIndex()`, you supply a callback function that receives
    up to three parameters (the current array element in the iteration, its index,
    and the array itself). Arrow syntax offers a more streamlined approach, allowing
    you to define the callback function right where you use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find()` and `findIndex()` methods really shine when you need to write
    more complicated conditions. Consider the following code, which finds the first
    date in a specific year:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This approach isn’t possible with the `indexOf()` method, because it involves
    examining a *property* of an array item. (In fact, the standard `indexOf()` method
    can’t even test `Date` objects for equality, because it only checks if the object
    references match.)
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to write a finding function and use it to get multiple results,
    you probably want the `filter()` function described in [“Extracting Array Items
    That Meet Specific Criteria”](#copying_items_by_criteria). For more about the
    syntax of arrow function, see [“Using Arrow Functions”](ch06.html#arrow_functions).
  prefs: []
  type: TYPE_NORMAL
- en: Removing or Replacing Array Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find occurrences of a given value in an array, and either remove
    the element or replace it.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, find the location of the item you want to remove using `indexOf()`. Then,
    you can use one of two approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'For small jobs, the cleanest solution is to construct a new array *around*
    the item you don’t want. You build the new array using `slice()` and the spread
    operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternate approach is to perform an in-place array edit, instead of creating
    a changed copy. This may perform better for large arrays. However, the more mutability
    you allow, the more complex your code becomes, which may make it more difficult
    to manage and debug in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform an in-place edit, you use the similarly named but very different
    `splice()` method. It lets you remove as many items as you want, starting from
    any position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument to the `splice()` method is the index where the splicing
    starts. This is the only argument you need to supply. If you leave out the others,
    all the array elements from the index to the end are removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The optional second argument is the number of elements to remove. The third
    argument is an optional set of the replacement elements to *insert* at the same
    location.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: You could use `indexOf()` in a loop to find and remove a series of matching
    elements. But if this is your goal, the `filter()` method usually provides a cleaner
    approach, letting you define a function that picks the items you want to keep
    (see [“Extracting Array Items That Meet Specific Criteria”](#copying_items_by_criteria)).
  prefs: []
  type: TYPE_NORMAL
- en: Sorting an Array of Objects by a Property Value
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort an array that contains objects, based on one of its properties.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Array.sort()` method reorders an array. For example, it arranges an array
    of numbers from smallest to largest, or it puts an array of strings in alphabetical
    order. But you don’t need to stick to the array’s standard sorting system. Instead,
    you can pass a comparison function to the `sort()` method, and the array will
    use it to order its items.
  prefs: []
  type: TYPE_NORMAL
- en: The comparison function gets two items (corresponding to two different array
    elements), compares them, and returns a number that indicates the result. You
    return *0* if the values should be considered equal, *–1* if the first value is
    less than the second, or *1* if the first value is greater than the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple implementation that sorts an array of objects with people information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of shortcuts are possible here. Technically, you can return any negative
    number instead of –1, and any positive number instead of 1\. That allows you to
    write a much shorter comparison function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Combine that with the compact arrow syntax, and it gets shorter still:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, when you perform sorting you can make use of existing comparison
    methods. For example, if you want this example to sort by last name, there’s no
    need to reinvent the wheel. Instead, make good use of the `String.localeCompare()`
    method, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sort()` method alters your array *in place*. This is different than most
    of the other array methods you’ll use, which return changed copies but leave your
    original array untouched. If this isn’t the behavior you want, you can clone your
    array before you sort it, as detailed in [“Cloning an Array”](#cloning_arrays).
  prefs: []
  type: TYPE_NORMAL
- en: Transforming Every Element of an Array
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert every element in an array using the same transformation,
    and use the changed values to build a new array.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Array.map()` method, and supply a function that performs the change.
    The `map()` method goes through the entire array, applying your function to each
    element and building a new array with the return values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that uses this approach to change an array of decimal numbers
    into a new array with their hexadecimal equivalents (using the conversion technique
    described in [“Converting a Decimal to a Hexadecimal Value”](ch03.html#converting_a_decimal_to_a_hexadecimal_va)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, the `map()` function is only interested in the array elements. However,
    your callback function can accept two more parameters: the index and the original
    array. Using these details, it’s technically possible to use `map()` to change
    your *original* array. This is considered an antipattern. In other words, if you
    don’t plan to use the new array that `map()` returns, you shouldn’t use the `map()`
    method. Consider using the `forEach()` method instead ([“Iterating Over All the
    Elements in an Array”](#iterating_array)), or just iterate over your array procedurally.'
  prefs: []
  type: TYPE_NORMAL
- en: Combining an Array’s Values in a Single Calculation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use all the values in an array in some sort of aggregate calculation,
    like computing a sum or average.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could iterate over the array in a loop. But for a more streamlined solution,
    use the `Array.reduce()` method with a callback function. Your function (called
    the *reducer function*) is called for each element in the array. You build some
    sort of running total using an *accumulator*, a value that the `reduce()` method
    maintains until the process is finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you want to calculate the sum of an array of numbers.
    Each time your reducer function is called, it gets the current running total in
    the accumulator. It then adds the value of the current element and returns the
    new total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This new total becomes the accumulator when the reducer is called for the *next*
    item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use this function to sum up an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: When the reducer function is called on the last item, it makes its final calculation.
    That return value becomes the result that’s returned from `reduce()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’re comfortable with the way `reduce()` works, you can make your code
    shorter and more concise with inline functions and arrow syntax. Here’s a demonstration
    that uses `reduce()` to calculate the sum of squared values, an average, and the
    maximum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `reduce()` method can seem more complicated than other functional-style
    array processing methods, like `map()` ([“Transforming Every Element of an Array”](#mapping_array)),
    `filter()` ([“Extracting Array Items That Meet Specific Criteria”](#copying_items_by_criteria)),
    or `sort()` ([“Sorting an Array of Objects by a Property Value”](#sorting_array)).
    The difference is that you need to think carefully about what data you need to
    store after each function call. Remember that you can use the accumulator to store
    a custom object with more than one property, allowing you to track as much information
    as you need. You can also add two more optional parameters to your reducer function:
    `index` (the current index number of the element), and `array` (the entire array
    that’s being reduced). But be careful. Over-enthusiastic code that uses `reduce()`
    can quickly get hard for others to understand.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s another way to get the maximum out of an array of numbers. You can use
    the `Math.max()` method in conjunction with the spread operator to turn your array
    into a list of arguments (see [“Passing an Array to a Function That Expects a
    List of Values”](#array_spread)).
  prefs: []
  type: TYPE_NORMAL
- en: Validating Array Contents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to ensure that array contents meet certain criteria.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Array.every()` method to check that every element passes a given test.
    For example, the following code checks to ensure that every element in the array
    consists of alphabetic characters using a regular expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, use the `Array.some()` method to ensure that at least one of the elements
    passes the test. As an example, the following code checks to ensure that at least
    one of the array elements is an alphabetical string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike many other array methods that use callback functions, the `every()` and
    `some()` methods do not work against all array elements. Instead, they only process
    as many array elements as necessary to fulfill their functionality.
  prefs: []
  type: TYPE_NORMAL
- en: The solution demonstrates that the same callback function can be used for both
    the `every()` and `some()` methods. The difference is that when using `every()`,
    as soon as the function returns a `false` value, the processing is finished, and
    the method returns `false`. The `some()` method continues to test against every
    array element until the callback function returns `true`. At that time, no other
    elements are validated, and the method returns `true`. However, if the callback
    function tests against all elements, and doesn’t return `true` for any of them,
    `some()` returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To review regular expression syntax, which is used for the string matching pattern
    in this example, see [“Using a Regular Expression to Replace Patterns in a String”](ch02.html#replacing_patterns_string).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Collection of Nonduplicated Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create an array-like object that never contains more than one copy
    of the same value.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `Set` object. It quietly ignores attempts to add the same item more
    than once, without generating an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Set` is not an array, but—like an array—it’s an iterable collection of
    elements. You can add elements to a `Set` one at a time with the `add()` method,
    or you can pass an array in the `Set` constructor to add multiple items at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Set` object is not an array. Unlike the `Array` class, which is stocked
    with thirty-some useful methods, the `Set` class offers much less. You can use
    `add()` to insert an item, `delete()` to remove one, `has()` to check if an item
    is in the `Set`, and `clear()` to remove all the items at once. There are no methods
    for sorting, filtering, transforming, or copying.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you need to process your `Set` object like an array, it’s easy
    enough to make the conversion by passing your `Set` to the static `Array.from()`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In fact, you can convert a `Set` to an `Array` object and back as many times
    as you want, with no cost other than possible performance (if you have a very
    long list of items).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To count the number of items in a `Set` or `Map` collection, you use the `size`
    property. This is different than arrays, which have a `length` property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Key-Indexed Collection of Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a collection where each item is labeled with a unique string
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Map` object. Each object is indexed with a unique key (usually, but
    not necessarily, a string). To add an item, you call the `set()` method. When
    you need to retrieve a specific item, you can grab exactly the item you want by
    using the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When adding items to a `Map` object, you must always use the `set()` method.
    Don’t fall into this trap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Although this seems to work at first (and it uses the same kind of syntax that’s
    used with name-value collections in many other programming languages), it actually
    bypasses the `Map` collection and sets an ordinary property named `RU007` on the
    `Map` object. These properties won’t appear if you iterate over the `Map` with
    a `for`…`of` loop, and they won’t be visible to the `has()` or `get()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Map` object has a small set of methods for managing its contents: `set()`,
    `get()`, `has()`, and `delete()`. If you want to make use of the functionality
    in the `Array` object, you can easily convert your `Map` to an array with the
    static `Array.from()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You might expect that the `productArray` in this example will hold a collection
    of product objects, but that’s not quite true. Instead, each element in `productsArray`
    is a *separate* array with two elements. The first element is the key (like `*RUU07*`),
    and the second element is the value (the product object).
  prefs: []
  type: TYPE_NORMAL
- en: 'In some situations, you might not need to keep the key name when you convert
    a `Map` to an array. Maybe the key isn’t important, or it’s duplicated by a property
    of your elements. In this case, you can choose to transform your collection, throwing
    away the key values as you copy your data out of the `Map`. Here’s how that works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
