- en: Chapter 5\. Arrays
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since its inception, JavaScript has had arrays as a separate, standalone data
    type. But over the years, the way we interact with arrays has changed considerably.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: In the past, manipulating an array involved plenty of loops and iterative logic,
    along with a small set of underpowered methods. Today, the `Array` object is stocked
    with much more functionality, including methods that emphasize *functional* approaches.
    Using these methods, you can filter, sort, copy, and transform data, without stepping
    through array elements one at a time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll see how to use these functional approaches—and learn
    when you might need to sidestep them. The focus is on solving problems using the
    most modern practices that are available today.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  id: totrans-4
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you’re trying these examples out in the browser’s developer console, be warned
    that *lazy evaluation* can fool you. For example, consider what happens if you
    output an array with `console.log()`, sort it, and then log it again. You expect
    to see the information for two differently sorted arrays. But you’ll actually
    see the final, sorted array twice. That’s because most browsers won’t examine
    the items in your array until you open the console and click to expand the array.
    One way to avoid this problem is to iterate over the array and log each item separately.
    For more about the issue, see [“Why Chrome’s Developer Console Sometimes Lies”](https://oreil.ly/VDHtm).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Checking If an Object Is an Array
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you perform an array operation, you want to verify that your object truly
    is an array.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the static `Array.isArray()` method:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Discussion
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Array.isArray()` method is an obvious choice. Problems happen when developers
    are tempted to use the older `instanceOf` operator. For historical reasons, the
    `instanceOf` operator has weird edge cases with arrays (for example, it returns
    `false` when you test an array that was created in another execution context,
    such as a different window). The `isArray()` method was added to patch this gap.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: It’s also important to understand that `isArray()` specifically checks for instances
    of the `Array` object. If you call it on a different type of collection (like
    `Map` or `Set`), it returns `false`. This is true even if these collections have
    array-like semantics, and even if they have *array* in the name, like `TypedArray`
    (a low-level wrapper for a buffer of binary data).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Iterating Over All the Elements in an Array
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use the best approach for looping over every element in an array,
    in order.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The traditional approach is a `for`…`of` loop, which automatically gets each
    item:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In modern JavaScript, it’s becoming increasingly common to favor *functional*
    approaches in array-processing code. You can iterate over your array in a functional
    way using the `Array.forEach()` method. You supply a function, and that function
    is called once for each element in the array, and passed three potentially useful
    parameters (the element, the element’s index, and the original array). Here’s
    an example:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It’s possible to condense this further with arrow syntax ([“Using Arrow Functions”](ch06.html#arrow_functions)):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Discussion
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In long-lived languages like JavaScript, there are often many ways to accomplish
    the same thing. The `for`…`of` loop offers a straightforward syntax for iterating
    over an array. It doesn’t allow you to modify the elements in the array you’re
    traversing, which is a safe, sensible approach.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are cases when you’ll need to use something different. One of
    the most flexible choices is a basic `for` loop with a counter:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This approach can allow off-by-one errors to slip by undetected, which are still
    a surprisingly common source of mistakes in modern-day programming. However, you’ll
    need to use a `for` loop in some situations, such as when you’re moving through
    more than one array at the same time (see [“Checking If Two Arrays Are Equal”](#checking_if_two_arrays_are_equal)).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also iterate over an array by passing a function to the `Array.forEach()`
    method. This function is then called once for each element. Your function can
    receive three parameters: the current array element, the current array index,
    and a reference to the original array. Usually, you’ll only need the element.
    (You could use the index to make changes to the element in the original array,
    but that’s considered bad form.)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Instead, if you want to use a functional approach to change or examine your
    array, consider using a more specific, targeted method. [Table 5-1](#functional_array_methods)
    lists the most useful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Methods for functional array processing
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '| Task | Array method | Covered in |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
- en: '| Change every array element | `map()` | [“Transforming Every Element of an
    Array”](#mapping_array) |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
- en: '| See if all elements meet a specific condition | `every()` | [“Validating
    Array Contents”](#validating_array) |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
- en: '| See if at least one element meets a specific condition | `some()` | [“Validating
    Array Contents”](#validating_array) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
- en: '| Find array elements matching your criteria | `filter()` | [“Extracting Array
    Items That Meet Specific Criteria”](#copying_items_by_criteria) |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
- en: '| Reorder an array | `sort()` | [“Sorting an Array of Objects by a Property
    Value”](#sorting_array) |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
- en: '| Use all the values of an array in one calculation | `reduce()` | [“Combining
    an Array’s Values in a Single Calculation”](#reducing_array) |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
- en: Modern coding practice favors *functional approaches* to array processing over
    *iterative approaches*. The advantage of a functional approach is that your code
    can be more concise, often more readable, and less error-prone. Most of the time,
    the functional approach also enforces *immutability* for your array. It does that
    by creating a new copy of the array with the changes you want, rather than making
    direct modifications on the original array object. This approach also makes certain
    types of errors less likely.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-42
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As a rule of thumb, look at the functional array methods as a *first resort*.
    If they make your task more difficult (which might happen if you need to write
    multiple arrays or perform several array operations at once), switch to the iterative
    approach. And if you’re writing performance-intensive code (for example, routines
    that operate on extremely large arrays), consider the iterative approach, because
    it tends to perform better. But don’t forget to profile both approaches first
    to see if the difference is truly significant.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Checking If Two Arrays Are Equal
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want a simple way to test if two arrays are equivalent (have exactly the
    same contents).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most straightforward approach is actually the old-fashioned approach: use
    a basic `for` loop with a counter, step through both arrays at the same time,
    and compare each element. Of course, there are a couple of checks to make before
    you start looping, like verifying that each object is an array, isn’t null, and
    so on. Here’s a bit of code that packages all these criteria into a single useful
    function:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now you can check that two arrays are the same, like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this version of `areArraysEqual()`, arrays with the same items in a different
    order are considered nonmatching. You can easily sort arrays of strings or numbers
    using the `Array.sort()` method. However, it doesn’t make sense to put this code
    in the `areArrayEquals()` method, because it may not be appropriate for the data
    types you want to use, or it may be prohibitively slow if you want to compare
    huge arrays. Instead, sort your arrays before you test them for equality:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Discussion
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Often in programming, it’s up to you to decide what equality means. In this
    example, `areArraysEqual()` performs a *shallow compare*. If two arrays have the
    same primitives or the same object references, and their elements are in the same
    order, they match. But if you start comparing more complex *objects*, ambiguities
    appear.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this comparison of two arrays that hold a single, identical
    `Date` object:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: These arrays don’t match because even though the underlying date content is
    the same, the `Date` *instances* are different. (Or, to put it another way, there
    are two separate `Date` objects that just happen to save the same information
    in them.)
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can easily compare the content of two `Date` objects (just call
    `getTime()` to convert them to the millisecond time representation, as explained
    in [“Comparing Dates and Testing Dates for Equality”](ch04.html#comparing_dates)).
    But if you want to do that in an array comparison, it’s up to you to write a different
    function. In your function, you can use `instanceOf` to identify `Date` objects,
    and then call `getTime()` on them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The problem shown in this example applies to arrays that hold any type of JavaScript
    object. It even applies to arrays that hold nested arrays (because every `Array`
    is an object). Your solution will differ, however, because different equality
    tests make sense for different objects.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s worth noting that many popular JavaScript libraries have their
    own generic solutions for deep array comparison, which may or may not be suitable
    for your data. If you’re already using a library like Lodash or *Underscore.js*,
    investigate its `isEqual()` method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Breaking Down an Array into Separate Variables
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to assign array element values to several variables, but you want a
    convenient approach that doesn’t force you to assign each variable separately.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the array *destructuring syntax* to assign multiple variables at a time.
    You write an expression that declares several variables (on the left) and grabs
    the values from an array (on the right). Here’s an example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When you use array destructuring, the values are copied by position. In this
    example, that means `arizona` gets the first value in the array, `missouri` the
    second, and so on. If you have more variables than array elements, the extra variables
    get the value `undefined`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you use array destructuring, you don’t need to copy every value that’s
    in the array. You can skip values you don’t want by adding extra commas without
    a variable name:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also use the *rest operator* to stuff all the remaining values (ones
    you didn’t explicitly assign to variables) into a new array. Here’s an example
    that copies the three last array elements into an array named `others`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JavaScript’s rest operator looks just like the spread operator (it’s three dots
    before a variable). They even “feel” similar in your code, although they actually
    play complementary roles. The rest operator vacuums up extra values and squashes
    them into a single array. The spread operator *expands* an array (or another type
    of iterable object) into separate values.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'So far you’ve seen the variable declaration and assignment in one statement,
    but you can split them, just as you can when you create ordinary variables. Just
    make sure you keep the square brackets, because they indicate that you’re using
    array destructuring:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See Also
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want a way to convert an array into a list of values *without* assigning
    these values to variables, check out the spread operator described in [“Passing
    an Array to a Function That Expects a List of Values”](#array_spread).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Passing an Array to a Function That Expects a List of Values
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your array has a list of values that you want to pass to a function. But the
    function expects a list of argument values, not an array object.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the spread operator to expand your array. Here’s an example with the `Math.max()`
    method:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Discussion
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The spread operator unfolds an array into a list of elements. Technically, it
    works with any iterable object, including other types of collections. You’ll see
    it at work in several recipes in this chapter.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'The spread operator doesn’t need to supply all the arguments to a function,
    or even the final arguments. It’s perfectly valid to use it like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You probably don’t want to use this approach if the order of your arguments
    has any significance. It’s just too easy to end up with an array that’s a bit
    bigger or smaller than you thought, which will then displace your other arguments
    to new positions and change their significance.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Merging Two Arrays”](#merging_arrays) shows an example of how you can use
    the spread operator to merge different arrays. [“Removing or Replacing Array Elements”](#removing_replacing_array)
    shows how you can use spread when removing items. [“Cloning an Array”](#cloning_arrays)
    shows how you can use spread to copy an array.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Cloning an Array
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make a copy of an existing array.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the spread operator to expand your array into items and feed it into a
    new array:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'An equally good approach is to use the `Array.slice()` method with no arguments,
    which tells it to take a slice of the entire array:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Both of these approaches are preferable to looping over array elements and building
    up a new array by hand.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating array copies is important because it allows you to perform *nondestructive
    changes*. For example, you might keep your original array intact while you make
    changes to a new copy. That way, you reduce the risk of unanticipated side effects
    (for example, if other parts of your code are still using the original array).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'As with all reference objects, arrays cannot be copied by assignment. This
    code, for example, ends with two variables pointing to the same in-memory `Array`
    object:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To properly copy an array, you need to duplicate all of its elements. The easiest
    approach is to use the spread operator, although the `Array.slice()` method works
    equally well.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'Both approaches shown here create *shallow copies*. If your array consists
    of primitives (numbers, strings, or Boolean values), the copied array matches
    exactly. But if your array holds objects, these techniques copy the *reference*,
    not the entire object. As a result, your new array will have references pointing
    to the same objects. Change one of the objects in the copied array, and it also
    affects the original array:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This may or may not be a problem, depending on how you plan to use your arrays.
    If you want multiple copies of objects that you can manipulate separately, there
    are several possible solutions you can use:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Loop through your array with a `for` loop, create the new objects you need explicitly,
    and then add them to the new array.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `Array.map()` function. This works well for simple objects, but doesn’t
    do a deep clone all the way down. (For example, if you have objects referencing
    *other* objects, only the first layer of objects is truly duplicated.)
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a helper function from another JavaScript library, like `cloneDeep()` in
    Lodash or `clone()` in Ramda.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example that demonstrates `Array.map()`. It works a little bit of
    magic by first expanding the array element into its properties with the spread
    operator (…`element`), then uses them to create a new object (`{`…`element}`),
    which is assigned to the new array:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To take a closer look at the `map()` method, see the full explanation in [“Transforming
    Every Element of an Array”](#mapping_array).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-117
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The spread operator (`...`) does double duty. In the original solution, you
    saw how the spread operator can expand an array into separate elements. In the
    `Array.map()` example, the spread operator expands an *object* into separate properties.
    For more about how the spread operator works on objects, see [“Merging the Properties
    of Two Objects”](ch07.html#merging_object_properties).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to copy only *some* array items, see [“Copying a Portion of an Array
    by Position”](#copying_items_by_position). To learn more about different ways
    of making deep copies of an object, see [“Making a Deep Copy of an Object”](ch07.html#deep_clone_an_object).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Merging Two Arrays
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to join two entire arrays together into a new array.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two commonly used approaches for combining two arrays. The time-honored
    approach (and likely the most performant option) is to use the `Array.concat()`
    method. You call `concat()` on the first array, passing in the second array as
    an argument. The result is a third array that contains all the elements of both:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The resulting array has the first array’s items first (`evens`, in this example),
    followed by second array’s items (`odds`). Of course, you can follow up your `concat()`
    with a call to the `Array.sort()` method ([“Sorting an Array of Objects by a Property
    Value”](#sorting_array)).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternate approach is to use the spread operator (introduced in [“Passing
    an Array to a Function That Expects a List of Values”](#array_spread)):'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The advantage of this approach is that the code is (arguably) more intuitive
    and easier to read. The spread operator is also a great tool if you want to combine
    more than two arrays at a time, or you want to combine arrays with literal values:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Performance testing suggests that on current implementations, large arrays are
    merged faster with `concat()`. But in most scenarios, this performance different
    won’t be significant (or even apparent).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you merge arrays with either of these techniques, you are left with three
    arrays: the original two, and the new merged result. If your arrays contain primitive
    values (numbers, strings, Boolean values), these are duplicated in the new array.
    But if your array holds objects, the object *reference* is copied. For example,
    if you merge two arrays of `Date` objects, no new `Date` objects are created.
    Instead, the new merged array gets references pointing to the *same* `Date` objects.
    If you change a `Date` object in the merged array, you’ll see the modification
    in the original array as well:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: For more about the difference between shallow and deep copies, see [“Making
    a Deep Copy of an Object”](ch07.html#deep_clone_an_object).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you merge arrays, you have no power to control how the elements are combined.
    If you want to copy just a portion of an array, or put one array in the *middle*
    of another, see the `slice()` method in [“Copying a Portion of an Array by Position”](#copying_items_by_position).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Copying a Portion of an Array by Position
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to copy a portion of an array, and keep the original array intact.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Array.slice()` method, which makes a *shallow copy* of a portion of
    an existing array, and returns that as a new array:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Discussion
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `slice()` method takes two parameters, indicating a starting and ending
    position. You can omit the second parameter to go from the start index to the
    end of the array. Calling `slice(0)` on an array copies the whole array.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, this code uses slice to get two subsections of the first array,
    and use them to build a new array:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This may seem like an arbitrary example, because the index numbers are hard-coded.
    But you can combine it with array searches and the `findIndex()` method (see [“Searching
    Through an Array for Exact Matches”](#searching_array_exact_matches)) to find
    the place where you should divide an array.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-150
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `slice()` method is easily confused with the `splice()` method, which is
    used to replace or delete portions of an array. Unlike `slice()`, the `splice()`
    method makes in-place changes that affect the original array. In modern practice,
    it’s considered better to lock-down your objects, keep them immutable when possible
    (hence the use of `const`), and create a new copy with changes. So stick with
    `slice()` unless you have a strong reason to use `splice()` (for example, there’s
    a difference in performance that’s significant in your use case).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Removing or Replacing Array Elements”](#removing_replacing_array) shows how
    you can use `slice()` to remove sections of an array.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Extracting Array Items That Meet Specific Criteria
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find all the items in an array that match a certain condition, and
    copy them to a new array.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Array.filter()` method to run a test on every item:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This example is intentionally long-winded so you can see the different pieces
    of the solution. The *filter function* is called for every item in the array.
    In this case, that means `startsWithE()` is called 10 times, and passed a different
    string each time. If the filter function returns `true`, that item is added to
    the new array.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the same example condensed with an arrow function. Now the filter logic
    is defined in the same place in code where you use it:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Discussion
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, the filter function checks that each item begins with the letter
    *e*. But you could just as easily grab numbers that fall in a certain range, or
    objects that have certain property values.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: The `filter()` method is one of a new set of modern array methods that replace
    old-fashioned iterative code with a functional approach. Nothing stops you from
    using a `for` loop to step through your array, test each item, and insert matches
    into a new array with `Array.push()`. However, if you can perform the same task
    with the `filter()` method, you’ll usually be rewarded with more compact code
    and easier testing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Several of the recipes in this chapter introduce similar methods for functional
    array processing. In particular, [“Transforming Every Element of an Array”](#mapping_array)
    shows how to transform all the elements in an array, and [“Combining an Array’s
    Values in a Single Calculation”](#reducing_array) shows how to perform a calculation
    that combines all the values in an array into one result.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Emptying an Array
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to remove all the elements from an array, either to reclaim memory
    or so that your array can be reused.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Set the `length` property of your array to 0:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Discussion
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the easiest ways to give yourself a new array is to simply assign a
    new blank array, like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: However, this approach has a couple of limits. First, because it creates a whole
    new array object, it doesn’t work if you’ve defined your array with the `const`
    keyword. This is a small detail, but modern practice favors using `const` over
    `let` to narrow the possibilities for bugs in your code. Second, this assignment
    doesn’t actually destroy the array. If you have another variable pointing to your
    array, it will stay alive and remain in memory.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: An alternate solution is to call the `Array.pop()` method repeatedly. Each time
    you call `pop()`, you remove the last item from the array, so you can empty an
    array with a loop that continues calling `pop()` until the array is empty. However,
    the `length` setting trick has exactly the same effect and requires just a single
    statement. Developers sometimes overlook this technique, because they expect `length`
    to be a read-only property (as it is in many other languages). But setting `length`
    on a JavaScript array allows you to shrink its size and drop the leftover items.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other interesting ways to use the `length` property. For example,
    you can chop off only part of an array by reducing `length`, but not all the way
    to 0\. Or, you can add blank items to the end of an array by increasing `length`:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Removing Duplicate Values
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to ensure that every value in your array is unique by removing the
    duplicates.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a new `Set` object and fill it with your array. The `Set` object will
    discard duplicates automatically. Then, convert the `Set` object back to an array:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once you understand the idea, you can compress this down to a single statement
    with the spread operator:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Discussion
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Set` object is a special type of collection that ignores duplicate values.
    It also works as a quick and efficient way to remove duplicates from an array.
    This technique (switching to a `Set` and then back to an array) is far more efficient
    than iterating over the array and looking for duplicates with `findIndex()`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: When searching for duplicates, the `Set` uses a test that’s similar to the strict
    equality comparison `===`, which means 3 and `'3'` are not considered duplicates.
    One special bit of behavior the `Set` implements is that it treats repeated `NaN`
    values as duplicates, even though `NaN === NaN` ordinarily evaluates to `false`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example uses the spread operator described in [“Passing an Array to a Function
    That Expects a List of Values”](#array_spread). For more about the `Set` object,
    see [“Creating a Collection of Nonduplicated Values”](#using_set).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Flattening a Two-Dimensional Array
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to flatten a two-dimensional array so that it becomes a one-dimensional
    list.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Array.flat()` method:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Discussion
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Consider a two-dimensional array, like this one:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Each element in the `fruitArray` holds *another* array. For example, `fruitArray[0]`
    has three strings, representing different berries. `fruitArray[1]` has citrus
    fruits, and `fruitArray[2]` has stone fruits.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'You could transform `fruitArray` with the help of the `concat()` method. Start
    with the first nested array, call `concat()`, and pass the other nested arrays,
    like this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: If the array has several members, this approach is tedious and error prone.
    Alternatively, you could use a loop or recursion, but these approaches can be
    equally tedious. The `flat()` method implements the same logic, and concatenates
    every row for you.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flat()` method takes an optional `depth` argument, with a default value
    of 1\. You can increase this number to flatten more deeply nested arrays. For
    example, imagine you have an array that contains nested arrays, and those arrays
    hold *another* layer of nested arrays. In this case, a `depth` of 2 will concatenate
    both layers, putting everything into a single list:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `depth` argument sets the maximum level of flattening that’s used, if needed.
    There’s no risk to increasing the `depth` beyond the actual dimensions of your
    array.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Searching Through an Array for Exact Matches
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to search an array for a specific value. You may want to know if the
    array contains a match, or the position where that match occurred.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use one of the array searching methods: `indexOf()`, `lastIndexOf()`, or `includes()`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This technique only works for primitive values (typically numbers, strings,
    and Boolean values). If you want to search for objects, you need to use the `Array.find()`
    method instead ([“Searching Through an Array for Items That Meet Specific Criteria”](#searching_array_test_function)).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both `indexOf()` and `lastIndexOf()` take a search value that is then compared
    to every element in the array. If the value is found, they return the index position
    of the array element. If the value is not found, they return *–1*.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: 'The `indexOf()` method returns the first match found searching from lowest
    to highest index (in other words, starting at the beginning of the array and going
    forward). The `lastIndexOf()` method goes in reverse, starting at the end of the
    array. The difference appears if the same item appears more than once in the array:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Both `indexOf()` and `lastIndexOf()` take an optional starting index argument.
    That sets the position where the search will begin:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: It may occur to you that you can use a loop to step through increasingly higher
    indexes with `indexOf()` until you’ve found all the matches. But before you write
    that kind of boilerplate code, consider using the `filter()` method, which quickly
    and painlessly creates an array with all the matches for a condition you specify
    (see [“Extracting Array Items That Meet Specific Criteria”](#copying_items_by_criteria)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it’s important to understand that `indexOf()`, `lastIndexOf()`, and
    `includes()` all use the `===` operator to test for matches. That means no type
    conversion is performed (so `3` will not equal `'3'`). Also, if your array contains
    objects, the references are compared, not the content. If you need to change the
    meaning of equality or you want to use a different search test, use the `findIndex()`
    method instead (see [“Searching Through an Array for Items That Meet Specific
    Criteria”](#searching_array_test_function)).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For customizable searching, see the `find()` and `findIndex()` methods in [“Searching
    Through an Array for Items That Meet Specific Criteria”](#searching_array_test_function).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Searching Through an Array for Items That Meet Specific Criteria
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to search an array for an item that meets certain criteria. For example,
    maybe you’re looking for an object with a specific property.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use one of the functional array searching methods: `find()` or `findIndex()`.
    Either way, you supply the function that tests each item until a match is found.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that finds the first number over 10:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If instead of finding the matching element, you would rather know its position,
    you can use the similar `findIndex()` method:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: If no match is found, `find()` returns `undefined`, and `findIndex()` returns
    –1.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using `find()` and `findIndex()`, you supply a callback function that receives
    up to three parameters (the current array element in the iteration, its index,
    and the array itself). Arrow syntax offers a more streamlined approach, allowing
    you to define the callback function right where you use it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'The `find()` and `findIndex()` methods really shine when you need to write
    more complicated conditions. Consider the following code, which finds the first
    date in a specific year:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: This approach isn’t possible with the `indexOf()` method, because it involves
    examining a *property* of an array item. (In fact, the standard `indexOf()` method
    can’t even test `Date` objects for equality, because it only checks if the object
    references match.)
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to write a finding function and use it to get multiple results,
    you probably want the `filter()` function described in [“Extracting Array Items
    That Meet Specific Criteria”](#copying_items_by_criteria). For more about the
    syntax of arrow function, see [“Using Arrow Functions”](ch06.html#arrow_functions).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Removing or Replacing Array Elements
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to find occurrences of a given value in an array, and either remove
    the element or replace it.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, find the location of the item you want to remove using `indexOf()`. Then,
    you can use one of two approaches.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: 'For small jobs, the cleanest solution is to construct a new array *around*
    the item you don’t want. You build the new array using `slice()` and the spread
    operator:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Discussion
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternate approach is to perform an in-place array edit, instead of creating
    a changed copy. This may perform better for large arrays. However, the more mutability
    you allow, the more complex your code becomes, which may make it more difficult
    to manage and debug in the future.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform an in-place edit, you use the similarly named but very different
    `splice()` method. It lets you remove as many items as you want, starting from
    any position:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first argument to the `splice()` method is the index where the splicing
    starts. This is the only argument you need to supply. If you leave out the others,
    all the array elements from the index to the end are removed:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The optional second argument is the number of elements to remove. The third
    argument is an optional set of the replacement elements to *insert* at the same
    location.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: You could use `indexOf()` in a loop to find and remove a series of matching
    elements. But if this is your goal, the `filter()` method usually provides a cleaner
    approach, letting you define a function that picks the items you want to keep
    (see [“Extracting Array Items That Meet Specific Criteria”](#copying_items_by_criteria)).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Sorting an Array of Objects by a Property Value
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to sort an array that contains objects, based on one of its properties.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Array.sort()` method reorders an array. For example, it arranges an array
    of numbers from smallest to largest, or it puts an array of strings in alphabetical
    order. But you don’t need to stick to the array’s standard sorting system. Instead,
    you can pass a comparison function to the `sort()` method, and the array will
    use it to order its items.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: The comparison function gets two items (corresponding to two different array
    elements), compares them, and returns a number that indicates the result. You
    return *0* if the values should be considered equal, *–1* if the first value is
    less than the second, or *1* if the first value is greater than the second.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple implementation that sorts an array of objects with people information:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'A couple of shortcuts are possible here. Technically, you can return any negative
    number instead of –1, and any positive number instead of 1\. That allows you to
    write a much shorter comparison function:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Combine that with the compact arrow syntax, and it gets shorter still:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Sometimes, when you perform sorting you can make use of existing comparison
    methods. For example, if you want this example to sort by last name, there’s no
    need to reinvent the wheel. Instead, make good use of the `String.localeCompare()`
    method, like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Discussion
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `sort()` method alters your array *in place*. This is different than most
    of the other array methods you’ll use, which return changed copies but leave your
    original array untouched. If this isn’t the behavior you want, you can clone your
    array before you sort it, as detailed in [“Cloning an Array”](#cloning_arrays).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Transforming Every Element of an Array
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to convert every element in an array using the same transformation,
    and use the changed values to build a new array.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `Array.map()` method, and supply a function that performs the change.
    The `map()` method goes through the entire array, applying your function to each
    element and building a new array with the return values.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that uses this approach to change an array of decimal numbers
    into a new array with their hexadecimal equivalents (using the conversion technique
    described in [“Converting a Decimal to a Hexadecimal Value”](ch03.html#converting_a_decimal_to_a_hexadecimal_va)):'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Discussion
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, the `map()` function is only interested in the array elements. However,
    your callback function can accept two more parameters: the index and the original
    array. Using these details, it’s technically possible to use `map()` to change
    your *original* array. This is considered an antipattern. In other words, if you
    don’t plan to use the new array that `map()` returns, you shouldn’t use the `map()`
    method. Consider using the `forEach()` method instead ([“Iterating Over All the
    Elements in an Array”](#iterating_array)), or just iterate over your array procedurally.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Combining an Array’s Values in a Single Calculation
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use all the values in an array in some sort of aggregate calculation,
    like computing a sum or average.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You could iterate over the array in a loop. But for a more streamlined solution,
    use the `Array.reduce()` method with a callback function. Your function (called
    the *reducer function*) is called for each element in the array. You build some
    sort of running total using an *accumulator*, a value that the `reduce()` method
    maintains until the process is finished.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine you want to calculate the sum of an array of numbers.
    Each time your reducer function is called, it gets the current running total in
    the accumulator. It then adds the value of the current element and returns the
    new total:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This new total becomes the accumulator when the reducer is called for the *next*
    item.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can use this function to sum up an array:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: When the reducer function is called on the last item, it makes its final calculation.
    That return value becomes the result that’s returned from `reduce()`.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’re comfortable with the way `reduce()` works, you can make your code
    shorter and more concise with inline functions and arrow syntax. Here’s a demonstration
    that uses `reduce()` to calculate the sum of squared values, an average, and the
    maximum value:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Discussion
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the `reduce()` method can seem more complicated than other functional-style
    array processing methods, like `map()` ([“Transforming Every Element of an Array”](#mapping_array)),
    `filter()` ([“Extracting Array Items That Meet Specific Criteria”](#copying_items_by_criteria)),
    or `sort()` ([“Sorting an Array of Objects by a Property Value”](#sorting_array)).
    The difference is that you need to think carefully about what data you need to
    store after each function call. Remember that you can use the accumulator to store
    a custom object with more than one property, allowing you to track as much information
    as you need. You can also add two more optional parameters to your reducer function:
    `index` (the current index number of the element), and `array` (the entire array
    that’s being reduced). But be careful. Over-enthusiastic code that uses `reduce()`
    can quickly get hard for others to understand.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There’s another way to get the maximum out of an array of numbers. You can use
    the `Math.max()` method in conjunction with the spread operator to turn your array
    into a list of arguments (see [“Passing an Array to a Function That Expects a
    List of Values”](#array_spread)).
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Validating Array Contents
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to ensure that array contents meet certain criteria.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `Array.every()` method to check that every element passes a given test.
    For example, the following code checks to ensure that every element in the array
    consists of alphabetic characters using a regular expression:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Or, use the `Array.some()` method to ensure that at least one of the elements
    passes the test. As an example, the following code checks to ensure that at least
    one of the array elements is an alphabetical string:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Discussion
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike many other array methods that use callback functions, the `every()` and
    `some()` methods do not work against all array elements. Instead, they only process
    as many array elements as necessary to fulfill their functionality.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: The solution demonstrates that the same callback function can be used for both
    the `every()` and `some()` methods. The difference is that when using `every()`,
    as soon as the function returns a `false` value, the processing is finished, and
    the method returns `false`. The `some()` method continues to test against every
    array element until the callback function returns `true`. At that time, no other
    elements are validated, and the method returns `true`. However, if the callback
    function tests against all elements, and doesn’t return `true` for any of them,
    `some()` returns `false`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To review regular expression syntax, which is used for the string matching pattern
    in this example, see [“Using a Regular Expression to Replace Patterns in a String”](ch02.html#replacing_patterns_string).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Collection of Nonduplicated Values
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create an array-like object that never contains more than one copy
    of the same value.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a `Set` object. It quietly ignores attempts to add the same item more
    than once, without generating an error.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Set` is not an array, but—like an array—it’s an iterable collection of
    elements. You can add elements to a `Set` one at a time with the `add()` method,
    or you can pass an array in the `Set` constructor to add multiple items at once:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Discussion
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Set` object is not an array. Unlike the `Array` class, which is stocked
    with thirty-some useful methods, the `Set` class offers much less. You can use
    `add()` to insert an item, `delete()` to remove one, `has()` to check if an item
    is in the `Set`, and `clear()` to remove all the items at once. There are no methods
    for sorting, filtering, transforming, or copying.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you need to process your `Set` object like an array, it’s easy
    enough to make the conversion by passing your `Set` to the static `Array.from()`
    method:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In fact, you can convert a `Set` to an `Array` object and back as many times
    as you want, with no cost other than possible performance (if you have a very
    long list of items).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以随意将`Set`转换为`Array`对象，反复进行操作，除了可能的性能损失外（如果列表项非常长）并不会有其他成本。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: To count the number of items in a `Set` or `Map` collection, you use the `size`
    property. This is different than arrays, which have a `length` property.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算`Set`或`Map`集合中的项数，您使用`size`属性。这与数组不同，数组具有`length`属性。
- en: Creating a Key-Indexed Collection of Items
  id: totrans-329
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建带有键索引项的集合
- en: Problem
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to create a collection where each item is labeled with a unique string
    key.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 您想创建一个集合，其中每个项都带有唯一的字符串键。
- en: Solution
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: 'Use the `Map` object. Each object is indexed with a unique key (usually, but
    not necessarily, a string). To add an item, you call the `set()` method. When
    you need to retrieve a specific item, you can grab exactly the item you want by
    using the key:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Map`对象。每个对象都以唯一键索引（通常是字符串，但不一定）。要添加项目，可以调用`set()`方法。当需要检索特定项目时，可以通过键直接获取所需的项目：
- en: '[PRE60]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Discussion
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'When adding items to a `Map` object, you must always use the `set()` method.
    Don’t fall into this trap:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当向`Map`对象添加项时，必须始终使用`set()`方法。不要陷入这个陷阱：
- en: '[PRE61]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Although this seems to work at first (and it uses the same kind of syntax that’s
    used with name-value collections in many other programming languages), it actually
    bypasses the `Map` collection and sets an ordinary property named `RU007` on the
    `Map` object. These properties won’t appear if you iterate over the `Map` with
    a `for`…`of` loop, and they won’t be visible to the `has()` or `get()` methods.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一开始似乎能行得通（并且它使用了许多其他编程语言中用于名称-值集合的相同语法），但实际上是绕过了`Map`集合，并在`Map`对象上设置了一个名为`RU007`的普通属性。如果你用`for`...`of`循环迭代`Map`时，这些属性不会出现，并且它们对于`has()`或`get()`方法也是不可见的。
- en: 'The `Map` object has a small set of methods for managing its contents: `set()`,
    `get()`, `has()`, and `delete()`. If you want to make use of the functionality
    in the `Array` object, you can easily convert your `Map` to an array with the
    static `Array.from()` method:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`Map`对象有一小组用于管理其内容的方法：`set()`、`get()`、`has()`和`delete()`。如果您想利用`Array`对象中的功能，可以使用静态的`Array.from()`方法轻松将`Map`转换为数组：'
- en: '[PRE62]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You might expect that the `productArray` in this example will hold a collection
    of product objects, but that’s not quite true. Instead, each element in `productsArray`
    is a *separate* array with two elements. The first element is the key (like `*RUU07*`),
    and the second element is the value (the product object).
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望此示例中的`productArray`将保存一组产品对象，但这并不完全正确。相反，`productsArray`中的每个元素都是一个*单独*的数组，其中第一个元素是键（如`*RUU07*`），第二个元素是值（产品对象）。
- en: 'In some situations, you might not need to keep the key name when you convert
    a `Map` to an array. Maybe the key isn’t important, or it’s duplicated by a property
    of your elements. In this case, you can choose to transform your collection, throwing
    away the key values as you copy your data out of the `Map`. Here’s how that works:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，当您将`Map`转换为数组时，可能不需要保留键名。也许键名不重要，或者被元素的属性重复了。在这种情况下，您可以选择转换您的集合，将键值丢弃，同时将数据从`Map`中复制出来。这是它的工作原理：
- en: '[PRE63]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
