["```\nstruct my_value {\n     ... <other fields>\n     struct bpf_spin_lock lock;\n... <other fields>\n};\n```", "```\nbpftool btf list\n1: name [vmlinux]  size 5843164B\n2: name [aes_ce_cipher]  size 407B\n3: name [cryptd]  size 3372B\n...\n149: name <anon>  size 4372B  prog_ids 319  map_ids 103\n        pids hello-buffer-co(7660)\n155: name <anon>  size 37100B\n        pids bpftool(7784)\n```", "```\n149: name <anon>  size 4372B  prog_ids 319  map_ids 103\n        pids hello-buffer-co(7660)\n```", "```\nbpftool prog show name hello\n319: kprobe  name hello  tag a94092da317ac9ba  gpl\n        loaded_at 2022-08-28T14:13:35+0000  uid 0\n        xlated 400B  jited 428B  memlock 4096B  map_ids 103,104\n        btf_id 149\n        pids hello-buffer-co(7660)\n```", "```\nstruct user_msg_t {\n  char message[12];\n};\n\nBPF_HASH(config, u32, struct user_msg_t);\n```", "```\n[1] TYPEDEF 'u32' type_id=2\n[2] TYPEDEF '__u32' type_id=3\n[3] INT 'unsigned int' size=4 bits_offset=0 nr_bits=32 encoding=(none)\n```", "```\n[4] STRUCT 'user_msg_t' size=12 vlen=1\n        'message' type_id=6 bits_offset=0\n[5] INT 'char' size=1 bits_offset=0 nr_bits=8 encoding=(none)\n[6] ARRAY '(anon)' type_id=5 index_type_id=7 nr_elems=12\n[7] INT '__ARRAY_SIZE_TYPE__' size=4 bits_offset=0 nr_bits=32 encoding=(none)\n```", "```\n[8] STRUCT '____btf_map_config' size=16 vlen=2\n        'key' type_id=1 bits_offset=0\n        'value' type_id=4 bits_offset=32\n```", "```\nstruct something {\n    char letter; \n    u64 number;\n}\n```", "```\nstruct { /* anonymous struct used by BPF_MAP_CREATE command */\n    `__u32`   `map_type`;             /* one of enum bpf_map_type */\n    `__u32`   `key_size`;             /* size of key in bytes */\n    `__u32`   `value_size`;           /* size of value in bytes */\n    `__u32`   `max_entries`;          /* max number of entries in a map */\n    ...\n    char    `map_name`[`BPF_OBJ_NAME_LEN`];\n    ...\n    `__u32`   `btf_fd`;               /* fd pointing to a BTF type data */\n    `__u32`   `btf_key_type_id`;      /* BTF type_id of the key */\n    `__u32`   `btf_value_type_id`;    /* BTF type_id of the value */\n    ...\n};\n```", "```\n[31] FUNC_PROTO '(anon)' ret_type_id=23 vlen=1\n        'ctx' type_id=10\n[32] FUNC 'hello' type_id=31 linkage=static\n```", "```\n[10] PTR '(anon)' type_id=0\n\n[23] INT 'int' size=4 bits_offset=0 nr_bits=32 encoding=SIGNED\n```", "```\nint hello(void *ctx)\n```", "```\nbpftool btf dump map name config\n[1] TYPEDEF 'u32' type_id=2\n[4] STRUCT 'user_msg_t' size=12 vlen=1\n        'message' type_id=6 bits_offset=0\n```", "```\n$ bpftool btf list\n1: name [vmlinux]  size 5842973B\n2: name [aes_ce_cipher]  size 407B\n3: name [cryptd]  size 3372B\n...\n```", "```\nbpftool btf dump file /sys/kernel/btf/vmlinux format c > vmlinux.h\n```", "```\n#include \"vmlinux.h\"\n#include <bpf/bpf_helpers.h>\n#include <bpf/bpf_tracing.h>\n#include <bpf/bpf_core_read.h>\n#include \"hello-buffer-config.h\"\n```", "```\nstruct data_t {\n  int pid;\n  int uid;\n  char command[16];\n  char message[12];\n  char path[16];\n};\n```", "```\nstruct {\n   __uint(type, BPF_MAP_TYPE_PERF_EVENT_ARRAY);\n   __uint(key_size, sizeof(u32));\n   __uint(value_size, sizeof(u32));\n} output SEC(\".maps\");\n\nstruct user_msg_t {\n  char message[12];\n};\n\nstruct {\n   __uint(type, BPF_MAP_TYPE_HASH);\n   __uint(max_entries, 10240);\n   __type(key, u32);\n   __type(value, struct user_msg_t);\n} my_config SEC(\".maps\");\n```", "```\nBPF_HASH(config, u64, struct user_msg_t);\n```", "```\n#define `__uint`(name, val) int (*name)[val]\n#define `__type`(name, val) `typeof`(val) *name\n#define `__array`(name, val) `typeof`(val) *name[]\n```", "```\nSEC(\"kprobe\")\n```", "```\nSEC(\"kprobe/__arm64_sys_execve\")\n```", "```\nSEC(\"ksyscall/execve\")\n```", "```\nSEC(\"ksyscall/execve\")\nint BPF_KPROBE_SYSCALL(hello, const char *pathname)                   ![1](assets/1.png)\n{\n  struct data_t data = {};\n  struct user_msg_t *p;\n\n  data.pid = bpf_get_current_pid_tgid() >> 32;\n  data.uid = bpf_get_current_uid_gid() & 0xFFFFFFFF;\n\n  bpf_get_current_comm(&data.command, sizeof(data.command));\n  bpf_probe_read_user_str(&data.path, sizeof(data.path), pathname);  ![2](assets/2.png)\n\n  p = bpf_map_lookup_elem(&my_config, &data.uid);                    ![3](assets/3.png)\n  if (p != 0) {\n     bpf_probe_read_kernel(&data.message, sizeof(data.message), p->message);      \n  } else {\n     bpf_probe_read_kernel(&data.message, sizeof(data.message), message);\n  }\n\n  bpf_perf_event_output(ctx, &output, BPF_F_CURRENT_CPU,             ![4](assets/4.png)\n                        &data, sizeof(data));  \n  return 0;\n}\n```", "```\nchar message[12] = \"Hello World\";\n```", "```\nint hello(void *ctx)\n```", "```\nbpf_perf_event_output(ctx, &output, BPF_F_CURRENT_CPU, &data, sizeof(data));\n```", "```\n#define bpf_core_read(dst, sz, src)                        \\\n bpf_probe_read_kernel(dst, sz,                         \\\n (const void *)__builtin_preserve_access_index(src))\n```", "```\nstruct b_t *b;\nstruct c_t *c;\n\nbpf_core_read(&b, 8, &a->b);\nbpf_core_read(&c, 8, &b->c);\nbpf_core_read(&d, 8, &c->d);\n```", "```\nd = BPF_CORE_READ(a, b, c, d);\n```", "```\nchar LICENSE[] SEC(\"license\") = \"Dual BSD/GPL\";\n```", "```\nllvm-strip -g <object file>\n```", "```\nhello-buffer-config.bpf.o: %.o: %.c\n   clang \\\n       -target bpf \\\n       -D __TARGET_ARCH_$(ARCH) \\\n       -I/usr/include/$(shell uname -m)-linux-gnu \\\n       -Wall \\\n       -O2 -g \\\n       -c $< -o $@\n   llvm-strip -g $@\n```", "```\n$ readelf -S hello-buffer-config.bpf.o | grep BTF\n  [10] .BTF              PROGBITS         0000000000000000  000002c0\n  [11] .rel.BTF          REL              0000000000000000  00000e50\n  [12] .BTF.ext          PROGBITS         0000000000000000  00000b18\n  [13] .rel.BTF.ext      REL              0000000000000000  00000ea0\n```", "```\nbpftool btf dump file hello-buffer-config.bpf.o\n```", "```\nstruct `bpf_core_relo` {\n    `__u32` `insn_off`;\n    `__u32` `type_id`;\n    `__u32` `access_str_off`;\n    enum `bpf_core_relo_kind` `kind`;\n};\n```", "```\n#pragma clang attribute push (__attribute__((preserve_access_index)), \\\n apply_to = record)\n```", "```\nbpftool -d prog load hello.bpf.o /sys/fs/bpf/hello\n```", "```\nlibbpf: CO-RE relocating [24] struct user_pt_regs: found target candidate [205]\nstruct user_pt_regs in [vmlinux]\nlibbpf: prog 'hello': relo #0: <byte_off> [24] struct user_pt_regs.regs[0]\n(0:0:0 @ offset 0)\nlibbpf: prog 'hello': relo #0: matching candidate #0 <byte_off> [205] struct\nuser_pt_regs.regs[0] (0:0:0 @ offset 0)\nlibbpf: prog 'hello': relo #0: patched insn #1 (LDX/ST/STX) off 0 -> 0\n```", "```\nbpftool gen skeleton hello-buffer-config.bpf.o > hello-buffer-config.skel.h\n```", "```\n... [other #includes]\n#include \"hello-buffer-config.h\"                                       ![1](assets/1.png)\n#include \"hello-buffer-config.skel.h\"\n\n... [some callback functions]\n\nint main()\n{\n   struct hello_buffer_config_bpf *skel;\n   struct perf_buffer *pb = NULL;\n   int err;\n\n   libbpf_set_print(libbpf_print_fn);                                 ![2](assets/2.png)\n\n   skel = hello_buffer_config_bpf__open_and_load();                   ![3](assets/3.png)\n...\n   err = hello_buffer_config_bpf__attach(skel);                       ![4](assets/4.png)\n...\n   pb = perf_buffer__new(bpf_map__fd(skel->maps.output), 8, handle_event,\n                                                         lost_event, NULL, NULL);                                              \n                                                                      ![5](assets/5.png)\n...\n   while (true) {                                                     ![6](assets/6.png)\n       err = perf_buffer__poll(pb, 100);\n...}\n\n   perf_buffer__free(pb);                                             ![7](assets/7.png)\n   hello_buffer_config_bpf__destroy(skel);\n   return -err;\n}\n```", "```\nskel = hello_buffer_config_bpf__open_and_load();\n```", "```\nskel = hello_buffer_config_bpf__open();\nif (!skel) {\n    // Error ...\n}   \nskel->data->c = 10;\nerr = hello_buffer_config_bpf__load(skel);\n```", "```\nstruct bpf_map_info info = {};\nunsigned int len = sizeof(info);\n\nint findme = bpf_obj_get(\"/sys/fs/bpf/findme\");\nif (findme <= 0) {\n    printf(\"No FD\\n\");\n} else {\n    bpf_obj_get_info_by_fd(findme, &info, &len);\n    printf(\"Name: %s\\n\", info.name);\n}\n```", "```\n$ bpftool map create /sys/fs/bpf/findme type array key 4 value 32 entries 4\nname findme\n```", "```\nName: findme\n```", "```\nerr = hello_buffer_config_bpf__attach(skel);\n```", "```\npb = perf_buffer__new(bpf_map__fd(skel->maps.output), 8, handle_event,\n                                                         lost_event, NULL, NULL);\n```", "```\nwhile (true) {\n   err = perf_buffer__poll(pb, 100);\n   ...\n}\n```", "```\nperf_buffer__free(pb);\nhello_buffer_config_bpf__destroy(skel);\n```", "```\n23664  501    bash             Hello World\n23665  501    bash             Hello World\n23667  0      cron             Hello World\n23668  0      sh               Hello World\n```"]