- en: Chapter 10\. Errors and Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To write code is to write errors. Often, an error can be anticipated. Risky
    activities include actions that interact with outside resources (like files, databases,
    or web server APIs). Information that comes from outside your code—whether you’re
    reading it from a web page form or receiving it from another library—may arrive
    with errors, or in a different form than you expect. But to modify a well-worn
    cliché, it’s not so much the error as what you do with it that matters.
  prefs: []
  type: TYPE_NORMAL
- en: What should we do with our errors, then? JavaScript’s default behavior is to
    die at the point of the error, quietly logging a stack trace to the console. However,
    better options are available. You can capture an error, react to it, modify it,
    rethrow it, and even hide it if you choose. Compared to many other languages,
    JavaScript’s error-handling features are relatively underdeveloped. But basic
    error handling is still just as important, and many of the recipes in this chapter
    focus on that task.
  prefs: []
  type: TYPE_NORMAL
- en: Defending against errors is essential practice, but it’s equally important to
    *prevent* them wherever possible. To that end, there are many testing frameworks
    that work with JavaScript, including Jest, Mocha, Jasmine, and Karma. With their
    help, you can write unit tests that guarantee your code is executing as expected.
    You’ll take a quick look at Jest in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Catching and Neutralizing an Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are performing a task that may not succeed, and you don’t want an error
    to interrupt your code or appear in the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Wrap the section of your code in a `try...catch` block, like this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When the `decodeURI()` function fails and an error occurs, execution jumps
    to the `catch` block. The catch block receives an error object (also known as
    an *exception*), which provides the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs: []
  type: TYPE_NORMAL
- en: A string that usually reflects the error subtype (as in “URIError”), but it
    may just be “Error.”
  prefs: []
  type: TYPE_NORMAL
- en: '`message`'
  prefs: []
  type: TYPE_NORMAL
- en: A string that gives you a human-language description of the problem, like “URI
    malformed.”
  prefs: []
  type: TYPE_NORMAL
- en: '`stack`'
  prefs: []
  type: TYPE_NORMAL
- en: A string that lists the currently open functions on the stack, in order, from
    the most recent calls to the earlier ones. Depending on the browser, the `stack`
    property may include information about the location of the function (such as line
    number and filename) and the arguments the functions were called with.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be careful. There are a few other properties defined on the error object (like
    `description` and `lineNumber`) that only work in specific browsers. Don’t rely
    on these nonstandard properties when writing error-handling code, because they
    won’t work on all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you pass the error object directly to the `console.log()` method (as in
    this example), you’ll get the information extracted from all three of these properties.
    It will look something like this, depending on the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, a piece of top-level code written in the developer console (represented
    by the bottom `<anonymous>` in the call stack list) called a function named `runTest()`,
    which then used the code shown above to call `decodeURI()` with a bad URI, triggering
    the error that was then logged.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you test your error-handling code, you need a routine that can cause
    an error to occur. For this example, we don’t want to consider syntax errors or
    any logical mistake that should realistically be caught when you’re writing your
    code (perhaps using a linter, as described in [“Enforcing Code Standards with
    a Linter”](ch01.html#using_eslint)). Instead, we want an operation that is *risky*
    because it relies on an outside resource and could fail due to no fault of your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is unusually tolerant of usage that would be considered an error
    in many other programming languages. Attempting to access a property that doesn’t
    exist gets an error-free value of `undefined`. The same is true if you go beyond
    the bounds of an array. JavaScript’s error tolerance is particularly apparent
    with math, where nonsensical calculations like multiplying a number by a string
    returns an error-free value of `NaN` (not a number), and dividing by zero returns
    the special value `Infinity`. Attempting to use the `decodeURI()` function is
    an example of an operation that can fail, in this case with a `UriError`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `decodeURI()` and `encodeURI()` methods are designed to replace characters
    that aren’t allowed in web URLs with escape sequences that are acceptable, which
    is an important technique if you’re storing arbitrary data in the *query string*
    (the portion of the URL that follows the `?`). Attempting to reverse this encoding
    on a string that has not been properly encoded can fail—for example, if it includes
    a `%` character that should begin an escape sequence.
  prefs: []
  type: TYPE_NORMAL
- en: The act of catching an error prevents it from being an unhandled error. This
    means your code can continue (and in the case of a Node application, prevents
    your application from ending altogether). However, you should only catch errors
    that you understand and are prepared to deal with. You never use error-handling
    simply to suppress and ignore potential problems. [“Detecting Unhandled Errors”](#unhandled_errors)
    has more about the effect of unhandled errors.
  prefs: []
  type: TYPE_NORMAL
- en: Although a `try...catch` block is the most common structure for error handling,
    you can optional add a `finally` section to the end. The code in the `finally`
    block always runs. It runs after the `try` block if no errors occurred, or after
    the `catch` block if an error was caught. It’s most commonly used as a place to
    put cleanup code that should run regardless of whether your code succeeded or
    failed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Catching Different Types of Errors”](#catching_error_subtypes) shows how
    to selectively catch different error types. [“Catching Asynchronous Errors”](#catching_async_errors)
    shows how to catch errors that happen during asynchronous operations.'
  prefs: []
  type: TYPE_NORMAL
- en: Catching Different Types of Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to distinguish between different types of errors and handle them differently,
    or handle only specific types.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike many languages, JavaScript does not allow you to catch errors by type.
    Instead, you must catch all errors (as usual), and then investigate the error
    with the `instanceof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Finally, if the error is not a type that you can handle, you should rethrow
    the error.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has eight error types, which are represented by different error objects
    (see [Table 10-1](#error_types)). You can check an error’s type to determine the
    kind of problem that occurred. This may indicate what actions you should take,
    or if you can carry out alternate code, retry an operation, or recover. It may
    also provide more information about exactly what went wrong.
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-1\. Error objects
  prefs: []
  type: TYPE_NORMAL
- en: '| Error Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `RangeError` | Occurs when a numeric value is outside of its allowed range.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ReferenceError` | Occurs when trying to assign a nonexistent object to a
    variable. |'
  prefs: []
  type: TYPE_TB
- en: '| `SyntaxError` | Occurs when code has a clear syntactical error, like an extra
    `(` or missing `}`. |'
  prefs: []
  type: TYPE_TB
- en: '| `TypeError` | Occurs when a value is not the right data type for a given
    operation. |'
  prefs: []
  type: TYPE_TB
- en: '| `URIError` | Raised by problems escaping URLs with `decodeURI()` and other
    related functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `AggregateError` | Is a wrapper for multiple errors, which is useful for
    errors that occur asynchronously. An array of error objects is provided in the
    `errors` property. |'
  prefs: []
  type: TYPE_TB
- en: '| `EvalError` | Meant to represent problems that occur with the built-in `eval()`,
    but it’s no longer used. Now, using `eval()` on syntactically invalid code will
    cause a `SyntaxError` to be thrown. |'
  prefs: []
  type: TYPE_TB
- en: '| `InternalError` | Occurs for a variety of nonstandard cases, and is browser
    specific. For example, on Firefox an `InternalError` occurs if you exceed the
    recursion limit (by having a function call itself over and over again), while
    in Chrome the same condition is represented by a `RangeError`. |'
  prefs: []
  type: TYPE_TB
- en: In addition to these error types, you can also throw and catch your own custom
    error objects, as described in [“Throwing a Custom Error”](#throwing_custom_errors).
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript only allows one `catch` block for every `try` block, which prevents
    you from catching errors by type. However, you can catch the standard `Error`
    object, examine its type with `instanceof`, and write conditional code to deal
    with it accordingly. When you use this approach, you must be careful not to accidentally
    suppress errors you can’t deal with.
  prefs: []
  type: TYPE_NORMAL
- en: In the current example, the code explicitly handles the `RangeError` and `TypeError`
    type. If the error is something else, we assume there’s nothing practical we can
    do to resolve the problem. The error is then rethrown with the `throw` statement.
    When you use `throw`, it’s as if the same error occurred again. If your code is
    in a function, this allows the error to continue to bubble up the stack until
    it reaches some error-handling code that can deal with it appropriately. If there
    is no other error-handling that catches this error, it becomes an unhandled error,
    just as it would have if you hadn’t caught it in the first place. (See [“Detecting
    Unhandled Errors”](#unhandled_errors) for more about that.)
  prefs: []
  type: TYPE_NORMAL
- en: In other words, rethrowing unknown errors gives you the same behavior you would
    have if you caught only specific exception types—which is the approach you would
    probably take if the JavaScript language supported it.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Throwing a Custom Error”](#throwing_custom_errors) shows how to create your
    own error class to indicate a custom error condition and pass along extra information
    about the error.'
  prefs: []
  type: TYPE_NORMAL
- en: Catching Asynchronous Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add error handling but the risky operation is performed on a background
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript APIs have more than one model of asynchronicity, and the way you
    handle errors depends on the function you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using an older API, you may need to supply a callback function that
    will be called in the event of an error, or attach an event handler. The `XMLHttpRequest`
    object provides an `error` event to notify you about failed requests, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here the call to `send()` triggers the asynchronous operation that leads to
    the error, but the actual error occurs on a separate thread. Adding a `try...catch`
    block around this statement won’t catch the problem. The best you can do is receive
    a notification through the `error` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re using a promise-based API, you attach your error-handling function
    by calling `Promise.catch()`. Here’s an example with the Fetch API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The code you write here will be triggered in the event of an unhandled error
    or a rejected promise. If you don’t catch an error that occurs in a promise, it
    will bubble up to your main application thread and trigger the `window.unhandledrejection`
    event, which is the promise-based equivalent to the `window.error` event (see
    [“Detecting Unhandled Errors”](#unhandled_errors)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you’re using promises with the higher-level `async` and `await`
    model, you can use a traditional error-handling block. The `catch` section will
    be attached to the promise automatically with `Promise.catch()`. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Putting error-handling code in the wrong place is a common mistake. Unfortunately,
    it’s not always obvious that your error-handling code is ineffective or will never
    run, although a linting tool ([“Enforcing Code Standards with a Linter”](ch01.html#using_eslint))
    may alert you to the problem. The best solution is to test actual error conditions
    in your application, and verify that your error-handling code runs and mitigates
    them.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Using a Function That Returns a Promise”](ch09.html#async_call_with_promise)
    shows a complete example with the Fetch API and promise-based error handling.
    [“Waiting for a Promise to Finish with Await and Async”](ch09.html#using_await)
    shows a complete example with the Fetch API and `async` and `await` error handling.'
  prefs: []
  type: TYPE_NORMAL
- en: Detecting Unhandled Errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to catch errors that have not been handled in your code, possibly to
    create a diagnostic log.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Handle the `window.error` event. Your event-handling function receives five
    parameters with error information. Along with an error object that represents
    the actual error, you also get a separate `message` parameter and location information
    (`source` with the URL of the script file, `lineno` with the line number where
    the error occurred, and `colno` with the column number).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example that tests this event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note that to test this example, you need to use a sample test page. You can’t
    attach a function to the `window.error` event handler using the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In some cases, the browser’s cross-origin security policy will prevent your
    JavaScript code from having access to the error details. One example is if you’re
    running your test page from the local filesystem instead of using a test server.
    In this situation, the `message` parameter will have the generic text “Script
    error,” and the `url`, `lineNo`, `columnNo`, and `error` properties will be blank.
    For more information, see [the `onerror` notes](https://oreil.ly/9MbGP).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unhandled errors that occur on the main thread of your application bubble up
    the stack until they reach the top level of your code and—if it’s not handled
    there—trigger the `window.error` event in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: The `window.error` event is unusual in that it allows you to *cancel* the error,
    effectively suppressing it. To do that, you return `true` from the event-handling
    function. If you don’t suppress an error, the browser’s default error-handler
    springs into action. It displays the error information in the developer console
    in bright red lettering, just as when you log it with the `console.error()` method.
    But if you return `true` from `window.error`, the error vanishes, and no trace
    of it will appear in the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: Other than that, there’s no practical difference between suppressing or allowing
    an error in your `window.error` event handler. By the time an error has triggered
    the `window.error` event, your code has already been halted and the stack has
    been unwound. However, this doesn’t stop your web page from working. As soon as
    another event occurs (for example, you click a button), JavaScript begins executing
    your code again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Modern practice discourages us from hiding errors, even from the developer console,
    unless there’s a very good reason. One possibility might be you’re replacing the
    default error display with something that’s fine-tuned to your application, and
    provides more useful information or removes information you don’t want to make
    visible to users.
  prefs: []
  type: TYPE_NORMAL
- en: You can use your `window.error` event handler to execute any type of JavaScript
    code. For example, you could log the error to a local data store or even send
    it to a web server using the Fetch API. If an error occurs *during* the `window.error`
    event handler, the event handler won’t be triggered again. It will simply pass
    straight to the browser’s default error handler and show up in the developer console.
  prefs: []
  type: TYPE_NORMAL
- en: 'For asynchronous code, errors are handled differently. For older callback-based
    APIs, there usually are no errors. Instead, these APIs use callbacks to notify
    your code about error conditions (see [“Catching Asynchronous Errors”](#catching_async_errors)).
    But for promise-based APIs, unhandled errors bubble up and will trigger the `window.unhandledrejection`
    event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `unhandledrejection` event passes a single object with event properties
    to your event handler. The `reason` property (used in the example above) has the
    unhandled error object, or whatever object was passed to `Promise.reject()` if
    the promise was manually rejected. You can also get the underlying `Promise` object
    from the `promise` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like `window.error`, `window.unhandledrejection` is a cancellable event. However,
    it uses a different, more modern convention for cancellation. Instead of returning
    `true`, you can use the `preventDefault()` method of the object with the event
    arguments. Here’s an example that shows a message when an unhanded promise error
    occurs, but hides the automatic error logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might think that the unhandled exception events are a good place to put
    your logging code. Sometimes they are. But usually, you’ll want to catch errors
    closer to where they occur, log them there, and rethrow them if necessary. However,
    the unhandled exception events are always a good way to find risky bits of code
    that need exception-handling logic but don’t have it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Logging Tools'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Broadly speaking, there are two times you catch errors: when you’re testing
    your code and you’re able to fix them, and when your application is in production
    and you want to know what went wrong. In the first case, logging is simple—your
    goal is to detect the problem and fix it. Often your logging simply involves calling
    `console.log()`. In the latter case, you need to investigate a problem that may
    be occurring sporadically, in a specific environment, and in front of an end user.
    Now you need a way to detect the problem and report the details back to you.'
  prefs: []
  type: TYPE_NORMAL
- en: You could handle the `window.error` and `window.unhandledrejection` events,
    and then write the details to some sort of storage. For example, you could save
    error information in the `localStorage` object so it persists for longer than
    the current browser session. You could use `fetch()` to send the details to a
    web API on your server. If you’re building a Node application, you could write
    the details to a file or database on the server. You could add extra contextual
    information, like system details, a priority level, and a timestamp. But as your
    logging needs grow, you may want to consider using an open source logging tool
    rather than roll your own solution.
  prefs: []
  type: TYPE_NORMAL
- en: A good logging tool gives you an *abstraction layer* over your logging. That
    means you’ll log messages (in much the same way you call the usual `console.log()`
    method), without thinking about where that log is or how it’s implemented. While
    you’re testing, the logging layer might just output your messages to the console.
    But when your application is deployed, the logging layer might ignore low-level
    messages entirely while sending the important ones somewhere else, such as to
    a remote web server. The logging tool can implement advanced features, like batching,
    which improves performance when multiple messages are logged to a remote site
    in quick succession.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a dizzying array of logging libraries for JavaScript applications, including
    Winston, Bunyan, Log4js, Loglevel, Debug, Pino, and many more. Some are designed
    specifically for Node applications, but many can also work with web page code
    in a browser.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing a Standard Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to indicate an error condition by throwing an error object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create an instance of the `Error` object, passing a short description of the
    problem to the constructor, which is used for the `message` property. Throw the
    `Error` object with the `throw` statement. Your code can then catch this `Error`
    object just like it catches any other type of JavaScript error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two ways to create an `Error` object. You can use the `new` keyword
    to create it, as in the solution. Or (less commonly), you can call `Error()` like
    a function, which has the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `Error` object has the standard error properties, including the `message`
    you set, a `name` (unhelpfully set to “Error”), and `stack` (the stack trace that
    pinpoints where the error occurred).
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: JavaScript also allows code to use `throw` with nonerror objects (like strings).
    This usage is nonstandard and can cause problems in exception-handling code that
    expects properties like `name` and `message`. As a rule of thumb, do not throw
    nonexception objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you may be able to repurpose a more specific error subtype. Most
    of JavaScript’s built-in error types (listed in [Table 10-1](#error_types)) are
    for specialized cases and are not suitable for custom code. But a couple are potentially
    useful. You can use `RangeError` if a function receives a value that falls outside
    of the acceptable numeric range. Make sure to include an informative error message
    that includes the given value and the expected range:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`RangeError` is specifically intended for numeric values. However, you might
    use `TypeError` to indicate errors where the supplied value was of the wrong type.
    It’s up to you to decide what constitutes a “wrong” type; perhaps a string when
    you expect a number (test that with `typeof`), or the wrong sort of object (test
    that with `instanceof`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Less useful error subtypes that you might consider include `ReferenceError`
    (if you receive a `null` reference or `undefined` value when you expect an object)
    or `SyntaxError` (for instance, if you’re parsing some type of string content
    that doesn’t follow the rules you’ve established). To get more specific about
    other error conditions, consider making your own error class ([“Throwing a Custom
    Error”](#throwing_custom_errors)).
  prefs: []
  type: TYPE_NORMAL
- en: Compared to many stricter languages, JavaScript uses errors sparingly. When
    designing your own libraries, it’s usually best to follow that convention. Don’t
    use exceptions for cases that JavaScript would ordinarily tolerate (like implicit
    type conversions). Don’t use errors to notify the calling code about nonexceptional
    cases—in other words, things that are likely to happen during normal operation,
    like invalid user input. *Do* use exceptions to prevent code from continuing with
    an operation that will fail because something hasn’t been initialized correctly.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Throwing a Custom Error”](#throwing_custom_errors) explains how to create
    your own error object.'
  prefs: []
  type: TYPE_NORMAL
- en: Throwing a Custom Error
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to indicate a specific error condition by throwing a custom error object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a class that inherits from the standard `Error` class. The constructor
    should accept the descriptive text for the `message` property, and use `super()`
    to call the base `Error` class constructor with the message. Here’s a bare minimum
    custom error, with the code that throws it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There’s one more recommended, but optional, refinement. You can use the static
    `Error.captureStackTrace()` method to clean up the stack trace slightly. (Technically,
    `captureStackTrace()` ensures that the call to the error constructor doesn’t appear
    in the stack trace that’s stored in the `Error.stack` property.)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add custom properties to pass extra information about the error
    condition. Here’s an example that stores a `productID` after a failed lookup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating custom `Error` classes, we should keep in mind two possibly competing
    concerns: staying within the bounds of a typical JavaScript error, and expressing
    enough information for our customized error condition. In the former case, do
    not attempt to recreate the errors or exceptions of your second favorite language.
    Do not overextend JavaScript’s `Error` type with unnecessary methods and extra
    functionality.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you create a custom error, there are a few conventions to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the class name to indicate the error type, and set the `name` property to
    match. This is important if any code checks the `name` to determine the type of
    error (rather than using `instanceof`). It also persists even if the error object
    is serialized to JSON, and it appears in the error’s default string representation
    and the developer console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the constructor, put your custom properties first in the parameter list.
    If you include a `message` parameter, it should be the last parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the constructor, call `super()` and pass the `message` to the base class
    constructor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a nicety, properly set the stack trace. Check for the `captureStackTrace()`
    method, and, if present, call it, passing a reference to the current instance
    (as `this`) and your custom error class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To learn more about inheritance and the `extends` keyword, see [“Inheriting
    Functionality from Another Class”](ch08.html#custom_class_inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: Writing Unit Tests for Your Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use automated tests to ensure your code matches your design criteria
    now and in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use a tool like Jest to write unit tests for your code at the earliest possible
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to install Jest is with npm ([“Downloading a Package with npm”](ch01.html#installing_npm_package)).
    Open a terminal window in your project folder, and create the *package.json* configuration
    file if you don’t already have it with `npm init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install Jest using the `--save-dev` parameter so that it’s only included
    in development builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to find some code to test. Let’s say you have a file named *factorialize.js*,
    with the `factorialize()` function shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To make this function accessible to Jest, you need to export the `factorialze()`
    function by adding this line to the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Jest assumes you’re using the Node module standard (CommonJS). If you’re already
    using the newer ES6 module standard, you need to use Babel, a JavaScript transpilation
    tool, to convert your module references before Jest processes your code. This
    sounds complicated, but the `plugin-transform-modules-commonjs` module will take
    care of most of the work. To see the completely configured solution both ways
    (with CommonJS modules or ES6 modules), refer to the sample code. For more about
    CommonJS modules, see [“Converting Your Library into a Node Module”](ch18.html#converting_library_node_module).
    For more about ES6 modules, see [“Organizing Your JavaScript Classes with Modules”](ch08.html#using_es6_modules).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you need to create your test file. In Jest, test files have the extension
    *.test.js*. In this case, that means you need to create a new file named *factorialize.test.js*.
    This file then imports the function you want to test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The rest of your test file defines the test you want to run. The simplest approach
    to testing is to start by verifying that your function works the way you expect.
    For example, you can write a Jest test that verifies that `factorialize()` returns
    the correct information for a few representative cases. Here’s an example that
    checks that 10! is 3,628,800:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Jest’s `test()` function creates a named test. The name allows you to identify
    tests in the test report, so you know exactly which tests succeeded and which
    ones failed. The test in this example uses Jest’s `expect()` function, which calls
    your code (in this case, the `factorialize()` function) and then evaluates the
    result with `toBe()`. Technically, `toBe()` is one of several Jest *matcher functions*.
    It determines whether the code passes or fails the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run this test, you need to use Jest. You can run it from the command line,
    with your test file and the help of npm’s package runner, npx. In this example,
    you would use this command in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'which runs the single test you’ve written and generates a report like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'More commonly, you’ll add Jest to the `scripts` section of your *package.json*
    file so it can run all your tests automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now you can ask Jest to run all the tests (the *.test.js* files) in your project
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple types of tests, such as tests for security, usability, and
    performance, but the most basic form of testing is *unit testing*. Unit testing
    consists of performing tests of discrete source code units, and verifying that
    those units behave as expected. In JavaScript, the most common unit for unit testing
    is a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although there are many possible testing frameworks (Jest, Mocha, Jasmine,
    Karma, and more), most of them use a similar syntax. In Jest, everything revolves
    around a `test()` function that takes two arguments. The first argument is a label
    for the test, which appears in the test report. The second argument is a function
    that includes one or more test assertions—claims that will either be successfully
    proved true (a pass) or false (a fail):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'To create test assertions, you use the `expect()` function, which is the lynchpin
    of Jest. It works in conjunction with a matching function like `toBe()` that evaluates
    the results from your test call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates a single test of the `factorialize()` function. But
    the goal of the test writer is broader. You need to choose a representative group
    of tests—ones that check multiple values and capture boundary conditions where
    possible. For example, with the `factorialize()` function test, it makes sense
    to test how the function deals with nonnumeric input, negative values, 0, very
    large values, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows a more complete test suite. It checks the results
    of five different calls to `factorialize()`. These calls are all grouped into
    one test suite using `describe()`. The `describe()` function simply lets you label
    a collection of related test calls. In this example, `describe()` is grouping
    calls to the same function, but you might also use it to group calls that use
    the same set of sample data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this test, you’ll find that the final test fails. It expects the
    call `factorialize(NaN)` to return `0`, but it actually throws an error, as the
    test log makes clear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Right now, every test you’ve seen uses the `toBe()` matching function to check
    for an exact value. But Jest, like all testing frameworks, lets you use different
    types of rules. For example, you could check that a number falls in a specific
    range, that text matches a certain pattern, or that a value isn’t null. [Table 10-2](#jest_matchers)
    outlines some of the most useful matching functions you can use with `expect()`.
    For a comprehensive list, consult the Jest documentation for the [`expect()` method](https://oreil.ly/hnbiy).
  prefs: []
  type: TYPE_NORMAL
- en: Table 10-2\. Jest matchers
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `arrayContaining()` | Searches an array for a given value. |'
  prefs: []
  type: TYPE_TB
- en: '| `not()` | Allows you to reverse any condition. For example, using `` expect(...).not.toBe(5)`
    `` passes if the value is *not* 5. |'
  prefs: []
  type: TYPE_TB
- en: '| `stringContaining()` | Searches a string for a substring. |'
  prefs: []
  type: TYPE_TB
- en: '| `stringMatching()` | Attempts to match a string to a regular expression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toBe()` | Tests for standard JavaScript equality, just as if you used the
    `==` operator. |'
  prefs: []
  type: TYPE_TB
- en: '| `toBeCloseTo()` | Tests that two numbers are equal or *very* close. Intended
    to avoid minute rounding errors with floating-point numbers (an issue detailed
    in [“Preserving Accuracy in Decimal Values”](ch03.html#preserving_decimal_accuracy)).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toBeGreaterThan()` | Checks if a numeric value is greater than the value
    you specify. There’s a small set of similar matchers for different comparisons,
    including `toBeGreaterThanOrEqual()`, `toBeLessThan()`, and `toBeLessThanOrEqual()`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `toBeInstanceOf()` | Checks if a returned object is an instance of a specified
    class, just as if you used the `instanceof` operator. |'
  prefs: []
  type: TYPE_TB
- en: '| `toBeNull()` | Checks if a value is `null`. You can also test for `NaN` values
    with `toBeNaN()` and undefined values with `toBeUndefined()`. |'
  prefs: []
  type: TYPE_TB
- en: '| `toBeTruthy()` | Tests if a number is *truthy*, which means it will be coerced
    to `true` in an `if` statement. In JavaScript, everything is truthy except `null`,
    `undefined`, empty strings, `NaN`, `0`, and `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `toEqual()` | Performs a *deep comparison* that checks if one object has
    the same content as another. This is in contrast to `toBe()`, which tests reference
    equality for objects. As a general rule of thumb, `toBe()` works for primitive
    types, but `toEqual()` is what you need to compare object instances. ([“Making
    a Deep Copy of an Object”](ch07.html#deep_clone_an_object) explains more about
    object equality in JavaScript.) |'
  prefs: []
  type: TYPE_TB
- en: '| `toHaveProperty()` | Checks if a returned object has a specific property
    and (optionally) if that property matches a certain value. |'
  prefs: []
  type: TYPE_TB
- en: '| `toStrictEqual()` | Similar to `toEqual()` but requires the objects to match
    exactly. For example, objects with the same properties and property values won’t
    match if they are instances of different classes, or if one is a class instance
    and the other an object literal. |'
  prefs: []
  type: TYPE_TB
- en: '| `toThrow` | Tests if the function throws an exception. You can optionally
    require the exception to be a specific error object. |'
  prefs: []
  type: TYPE_TB
- en: 'To fix the current example, you can indicate that you expect a value of `NaN`
    to throw an exception with the `toThrow()` matcher. However, `toThrow()` requires
    an extra step. You need to wrap the code inside `expect()` inside *another* anonymous
    function. Otherwise, the exception won’t be caught and the test will still fail.
    Here’s the correct code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This example gives a good overview of Jest’s core functionality, but there are
    many additional features you may want to consider. For example, Jest has additional
    support for using mock data, handling asynchronous results from promises, simulating
    timers, and snapshot testing (which verifies that the UI of a page hasn’t changed).
    For more information about all these features, refer to the [Jest documentation](https://oreil.ly/aeu1l).
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Writing Tests First'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Modern development practices have embraced the idea of writing the tests before
    much of the functionality for the application (and libraries) is written. This
    test-driven development (TDD) is a component of the Agile development paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: 'TDD takes some getting used to. Rather than a more formal *structured programming*
    or *waterfall* project design, which delays testing until you have reasonably
    complete code, TDD mandates that you write tests before your write anything else.
    Here’s how it unfolds:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Define the tests.* For example, if you were planning to write the `factorialize()`
    function shown in the previous example, you would begin by defining a representative
    set of tests that capture its expected inputs: for example, the largest number
    it can factorialize, boundary values like 0, and potential edge cases (like an
    implicitly coerced string or `BigInt` value). You would also write tests to check
    that failure cases are treated appropriately—in this case, by throwing the expected
    error.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Make it fail.* Once you’ve written your tests, you write the code. Some TDD
    practitioners suggest that the first step is to make your code compile and your
    tests fail. By achieving this step, you ensure that your tests are running, your
    test requirements are meaningful, and you aren’t accidentally passing code before
    it’s complete.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Make it pass.* The next step is sometimes described as “make the tests pass
    any way possible.” In other words, you don’t worry about creating the best possible
    solution, but simply making all the tests pass. Do not write more code than dictated
    by the test requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Refactor.* After you successfully pass your tests, you start the work of refining
    the code. This is the time when you refactor, remove duplicate code, and introduce
    improvements, repeating your tests all the while to make sure they continue to
    pass. You’ll probably also discover cases you haven’t covered, and end up writing
    more tests.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One obvious advantage in TDD is that it makes you focus on the problem at hand.
    You don’t need to interpret design requirements to decide how you should code
    a solution. Instead, you code to the exacting specifications that are formalized
    in tests. But TDD development also helps as an application evolves, because it
    diminishes the fear of change. As long as your code continues to pass the tests
    you’ve set out, and as long as your tests are truly representative (a bigger “if”),
    it’s safe to commit new revisions to your codebase.
  prefs: []
  type: TYPE_NORMAL
- en: The cost for this protection is that creating proper tests takes significantly
    more time to complete and significant experience to get right. One metric that
    can help you evaluate your testing regimen is *test code coverage* ([“Tracking
    Test Code Coverage”](#unit_testing_coverage)).
  prefs: []
  type: TYPE_NORMAL
- en: Tracking Test Code Coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to assess how well your test cases cover all the possibilities in your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Get a code coverage report from your testing tool. In Jest, you use the `--collect-coverage`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Jest will run all the tests in all the *test.js* files (as usual), followed
    by a more detailed report that analyzes the code coverage of your tests. Here’s
    the report with the tests for the `factorialize()` function shown in [“Writing
    Unit Tests for Your Code”](#unit_testing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Determining test code coverage requires a multifaceted approach. To be successful,
    it should include techniques such as code reviews and walkthroughs with peers.
    However, all testing tools also include automated code analysis features that
    can help you size up how successful your tests are at evaluating your code.
  prefs: []
  type: TYPE_NORMAL
- en: In Jest, the `--collect-coverage` parameter triggers this analysis. You can
    use this parameter at the command line or add it to the `jest` command in the
    *package.json* configuration file for your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code coverage report assesses how much of your code is tested using several
    percentages, which appear in separate columns:'
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs: []
  type: TYPE_NORMAL
- en: Shows how many of your functions are tested. This is a good starting point for
    evaluating your test coverage, but it’s also the least fine-grained statistic.
    In the `factorialize()` test, all the functions are tested. That doesn’t mean
    that all the code in these functions is executed!
  prefs: []
  type: TYPE_NORMAL
- en: Statements
  prefs: []
  type: TYPE_NORMAL
- en: Shows the percentage of code statements that are executed during your tests.
    In the `factorialize()` test, roughly 83% of all the code written is covered by
    at least one test.
  prefs: []
  type: TYPE_NORMAL
- en: Branch
  prefs: []
  type: TYPE_NORMAL
- en: Shows how many different branches (through conditional logic, like `if` statements)
    are reached. In the `factorialize()` test, the tests travel down 67% of the separate
    conditional branches.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the code report can point you to lines that don’t have code coverage.
    For example, the `factorialize()` example highlights lines 3–4 in your source
    code file, which rejects negative numbers, and lines 6–7, which rejects noninteger
    numbers. To improve your test code coverage, you could write a test assertion
    that uses `toThrow()` to ensure that both these cases are rejected properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command-line report gives you a quick review of your coverage, but Jest
    also generates a more comprehensive HTML-formatted report, which it stores in
    the *coverage* folder. Open *index.html* to see a list of all the tested files
    with the top-line statistics in slightly more detail (see [Figure 10-1](#test_report_1)).
    For example, rather than just giving you percentages, the report tells you the
    exact number of statements, branches, and functions. Click on any file in the
    list to go to another page that shows the code, with a twist: uncovered statements
    are highlighted for quick reference (see [Figure 10-2](#test_report_2)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![jsc3 1001](assets/jsc3_1001.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-1\. Code coverage report
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![jsc3 1002](assets/jsc3_1002.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2\. Highlighted code without test coverage
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The appropriate test coverage goal is much-debated. Some developers advocate
    for getting as close to 100% as possible, while others argue that 70%–80% is more
    practical and achieves the best return for your test-writing investment. However,
    the honest answer is that test coverage is not a definitive metric. Not only does
    the percentage differ based on how you measure it (functions, statements, or branches),
    but testing tools have no way to identify the riskiest or most vulnerable paths
    in your codebase.
  prefs: []
  type: TYPE_NORMAL
