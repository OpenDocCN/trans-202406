<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Syntax Extensions"><div class="chapter" id="syntax_extensions">
<h1><span class="label">Chapter 14. </span>Syntax Extensions</h1>

<blockquote>
<p>“TypeScript does not add</p>

<p>to the JavaScript runtime.”</p>

<p>…was that all a lie?!</p></blockquote>

<p>When <a data-type="indexterm" data-primary="syntax extensions" data-secondary="limitations of" id="idm45584668417584"/><a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="limitations of" id="idm45584668416576"/><a data-type="indexterm" data-primary="runtime syntax extensions" data-see="syntax extensions" id="idm45584668415360"/>TypeScript was first released in 2012, web applications were growing in complexity faster than plain JavaScript was adding features that supported the deep complexity.
The most popular JavaScript language flavor at the time, CoffeeScript, had made its mark diverging from JavaScript by introducing new and exciting syntactic constructs.</p>

<p>Nowadays, extending JavaScript syntax with new runtime features specific to a superset language such as TypeScript is considered bad practice for several reasons:</p>

<ul>
<li>
<p>Most importantly, runtime syntax extensions might conflict with new syntax in newer versions of JavaScript.</p>
</li>
<li>
<p>They make it more difficult for programmers new to the language to understand where JavaScript ends and other languages begin.</p>
</li>
<li>
<p>They increase complexity of transpilers that take superset language code and emit JavaScript.</p>
</li>
</ul>

<p>Thus, it is with a heavy heart and deep regret that I must inform you that the early TypeScript designers introduced three syntax extensions to JavaScript in the TypeScript language:</p>

<ul>
<li>
<p>Classes, which aligned with JavaScript classes as the spec was ratified</p>
</li>
<li>
<p>Enums, a straightforward syntactic sugar akin to a plain object of keys and values</p>
</li>
<li>
<p>Namespaces, a solution predating modern modules to structure and arrange code</p>
</li>
</ul>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>TypeScript’s “original sin” of runtime syntax extensions to JavaScript is fortunately not a design decision the language has made since its early years.
TypeScript does not add new runtime syntax constructs until they have made significant progress through the ratification process to be added to JavaScript itself.</p>
</div>

<p>TypeScript classes ended up looking and behaving almost identical to JavaScript classes (phew!) with the exception of <code>useDefineForClassFields</code> behavior (a configuration option not covered in this book) and parameter properties (covered here).
Enums are still used in some projects because they are occasionally useful.
Virtually no new projects use namespaces anymore.</p>

<p>TypeScript also adopted an experimental proposal for JavaScript “decorators” that I’ll cover as well.</p>






<section data-type="sect1" data-pdf-bookmark="Class Parameter Properties"><div class="sect1" id="idm45584668404272">
<h1>Class Parameter Properties</h1>
<div data-type="tip"><h6>Tip</h6>
<p>I <a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="class parameter properties" id="javascript-syntax-classparams"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="class parameter properties" id="syntax-classparams"/><a data-type="indexterm" data-primary="classes" data-secondary="parameter properties" id="class-param-properties"/><a data-type="indexterm" data-primary="parameters" data-secondary="properties" id="parameter-property"/><a data-type="indexterm" data-primary="properties" data-secondary="of parameters" data-secondary-sortas="parameters" id="property-params"/>recommend avoiding using class parameter properties unless you’re working in a project that heavily uses classes or a framework that would benefit from them.</p>
</div>

<p>It is common in JavaScript classes to want to take in a parameter in a constructor and immediately assign it to a class property.</p>

<p>This <code>Engineer</code> class takes in a single <code>area</code> parameter of type <code>string</code> and assigns it to an <code>area</code> property of type <code>string</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Engineer</code> <code class="p">{</code>
    <code class="nx">readonly</code> <code class="nx">area</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code><code class="nx">area</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">area</code> <code class="o">=</code> <code class="nx">area</code><code class="p">;</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`I work in the </code><code class="si">${</code><code class="nx">area</code><code class="si">}</code><code class="sb"> area.`</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Type: string</code>
<code class="k">new</code> <code class="nx">Engineer</code><code class="p">(</code><code class="s2">"mechanical"</code><code class="p">).</code><code class="nx">area</code><code class="p">;</code></pre>

<p>TypeScript includes a shorthand syntax for declaring these kinds of “parameter properties”: properties that are assigned to a member property of the same type at the beginning of a class constructor.
Placing <code>readonly</code> and/or one of the privacy modifiers—<code>public</code>, <code>protected</code>, or <code>private</code>—in front of the parameter to a constructor indicates to TypeScript to also declare a property of that same name and type.</p>

<p>The previous <code>Engineer</code> example could be rewritten in TypeScript using a parameter property for <code>area</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">Engineer</code> <code class="p">{</code>
    <code class="kr">constructor</code><code class="p">(</code><code class="nx">readonly</code> <code class="nx">area</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`I work in the </code><code class="si">${</code><code class="nx">area</code><code class="si">}</code><code class="sb"> area.`</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="c1">// Type: string</code>
<code class="k">new</code> <code class="nx">Engineer</code><code class="p">(</code><code class="s2">"mechanical"</code><code class="p">).</code><code class="nx">area</code><code class="p">;</code></pre>

<p>Parameter properties are assigned at the very beginning of the class constructor (or after the <code>super()</code> call if the class is derived from a base class).
They can be intermixed with other parameters and/or properties on a class.</p>

<p>The following <code>NamedEngineer</code> class declares a regular property <code>fullName</code>, a regular parameter <code>name</code>, and a parameter property <code>area</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">NamedEngineer</code> <code class="p">{</code>
    <code class="nx">fullName</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code>
        <code class="nx">name</code>: <code class="nx">string</code><code class="p">,</code>
        <code class="kr">public</code> <code class="nx">area</code>: <code class="nx">string</code><code class="p">,</code>
    <code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">fullName</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="nx">area</code><code class="si">}</code><code class="sb"> engineer`</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Its equivalent TypeScript without parameter properties looks similar, but with a couple more lines of code to explicitly assign <code>area</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">class</code> <code class="nx">NamedEngineer</code> <code class="p">{</code>
    <code class="nx">fullName</code>: <code class="nx">string</code><code class="p">;</code>
    <code class="nx">area</code>: <code class="nx">string</code><code class="p">;</code>

    <code class="kr">constructor</code><code class="p">(</code>
        <code class="nx">name</code>: <code class="nx">string</code><code class="p">,</code>
        <code class="nx">area</code>: <code class="nx">string</code><code class="p">,</code>
    <code class="p">)</code> <code class="p">{</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">area</code> <code class="o">=</code> <code class="nx">area</code><code class="p">;</code>
        <code class="k">this</code><code class="p">.</code><code class="nx">fullName</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="nx">area</code><code class="si">}</code><code class="sb"> engineer`</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Parameter properties are a sometimes-debated issue in the TypeScript community.
Most projects prefer to avoid them categorically, as they’re a runtime syntax extension and therefore suffer from the same drawbacks I mentioned earlier.
They also can’t be used with the newer <code>#</code> class private fields syntax.</p>

<p>On the other hand, they’re quite nice when used in projects that heavily favor creating classes.
Parameter properties solve a convenience issue of needing to declare the parameter property name and type twice, which is inherent to TypeScript and not <a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="class parameter properties" data-startref="javascript-syntax-classparams" id="idm45584668169504"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="class parameter properties" data-startref="syntax-classparams" id="idm45584668168144"/><a data-type="indexterm" data-primary="classes" data-secondary="parameter properties" data-startref="class-param-properties" id="idm45584668166960"/><a data-type="indexterm" data-primary="parameters" data-secondary="properties" data-startref="parameter-property" id="idm45584668165744"/><a data-type="indexterm" data-primary="properties" data-secondary="of parameters" data-secondary-sortas="parameters" data-startref="property-params" id="idm45584668164528"/>JavaScript.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Experimental Decorators"><div class="sect1" id="idm45584668403776">
<h1>Experimental Decorators</h1>
<div data-type="tip"><h6>Tip</h6>
<p>I <a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="decorators" id="javascript-syntax-decorator"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="decorators" id="syntax-decorator"/><a data-type="indexterm" data-primary="decorators" id="decorators"/><a data-type="indexterm" data-primary="experimentalDecorators compiler option" id="experimentaldecorator"/>recommend avoiding decorators if at all possible until a version of ECMAScript is ratified with decorator syntax.
If you’re working in a version of a framework such as Angular or NestJS that recommends using TypeScript decorators, the framework’s documentation will guide how to use them.</p>
</div>

<p>Many other languages that contain classes allow annotating, or decorating, those classes and/or their members with some kind of runtime logic to modify them.
<em>Decorator</em> functions are a proposal for JavaScript to allow annotating classes and members by placing a <code>@</code> and the name of a function first.</p>

<p>For example, the following code snippet shows just the syntax for using a decorator on a class <code>MyClass</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">@myDecorator</code>
<code class="kr">class</code> <code class="nx">MyClass</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code></pre>

<p>Decorators have not yet been ratified in ECMAScript, so TypeScript does not support them by default as of version 4.7.2.
However, TypeScript does include an <code>experimentalDecorators</code> compiler option that allows for an old experimental version of them to be used in code.
It can be enabled via the <code>tsc</code> CLI or in a TSConfig file, shown here, like other compiler options:</p>

<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"compilerOptions"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">        </code><code class="nt">"experimentalDecorators"</code><code class="p">:</code><code class="w"> </code><code class="kc">true</code><code class="w"/>
<code class="w">    </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>

<p>Each usage of a decorator will execute once, as soon as the entity it’s decorating is created.
Each kind of decorator—accessor, class, method, parameter, and property—receives a different set of arguments describing the entity it’s decorating.</p>

<p>For example, this <code>logOnCall</code> decorator used on a <code>Greeter</code> class method receives the <code>Greeter</code> class itself, the key of the property (<code>"log"</code>), and a <code>descriptor</code> object describing the property.
Modifying <code>descriptor.value</code> to log before calling the original <code>greet</code> method on the <code>Greeter</code> class “decorates” the <code>greet</code> method:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kd">function</code> <code class="nx">logOnCall</code><code class="p">(</code><code class="nx">target</code>: <code class="nx">any</code><code class="p">,</code> <code class="nx">key</code>: <code class="nx">string</code><code class="p">,</code> <code class="nx">descriptor</code>: <code class="nx">PropertyDescriptor</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">original</code> <code class="o">=</code> <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"[logOnCall] I am decorating"</code><code class="p">,</code> <code class="nx">target</code><code class="p">.</code><code class="kr">constructor</code><code class="p">.</code><code class="nx">name</code><code class="p">);</code>

    <code class="nx">descriptor</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="kd">function</code> <code class="p">(...</code><code class="nx">args</code>: <code class="nx">unknown</code><code class="p">[])</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`[descriptor.value] Calling '</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb">' with:`</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>
        <code class="k">return</code> <code class="nx">original</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="kr">class</code> <code class="nx">Greeter</code> <code class="p">{</code>
    <code class="kd">@logOnCall</code>
    <code class="nx">greet</code><code class="p">(</code><code class="nx">message</code>: <code class="nx">string</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`[greet] Hello, </code><code class="si">${</code><code class="nx">message</code><code class="si">}</code><code class="sb">!`</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code>

<code class="k">new</code> <code class="nx">Greeter</code><code class="p">().</code><code class="nx">greet</code><code class="p">(</code><code class="s2">"you"</code><code class="p">);</code>
<code class="c1">// Output log:</code>
<code class="c1">// "[logOnCall] I am decorating", "Greeter"</code>
<code class="c1">// "[descriptor.value] Calling 'greet' with:", "you"</code>
<code class="c1">// "[greet] Hello, you!"</code></pre>

<p>I won’t delve into the nuances and specifics of how the old <code>experimentalDecorators</code> works for each of the possible decorator types.
TypeScript’s decorator support is experimental and does not align with the latest drafts of the ECMAScript 
<span class="keep-together">proposal.
Writing</span> your own decorators in particular is rarely justified in any TypeScript <a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="decorators" data-startref="javascript-syntax-decorator" id="idm45584667901504"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="decorators" data-startref="syntax-decorator" id="idm45584667900112"/><a data-type="indexterm" data-primary="decorators" data-startref="decorators" id="idm45584667898896"/><a data-type="indexterm" data-primary="experimentalDecorators compiler option" data-startref="experimentaldecorator" id="idm45584667897952"/>project.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Enums"><div class="sect1" id="idm45584668112288">
<h1>Enums</h1>
<div data-type="tip"><h6>Tip</h6>
<p>I <a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="enums" id="javascript-syntax-enum"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="enums" data-tertiary="purpose of" id="syntax-enum-purpose"/><a data-type="indexterm" data-primary="enums" data-secondary="purpose of" id="enum-purpose"/>recommend not to use enums unless you have a set of literals that are repeated often, can all be described by a common name, and whose code would be much easier to read if switched to an enum.</p>
</div>

<p>Most programming languages contain the concept of an “enum,” or enumerated type, to represent a set of related values.
Enums can be thought of as a set of literal values stored in an object with a friendly name for each value.</p>

<p>JavaScript does not include an enum syntax because traditional objects can be used in place of them.
For example, while HTTP status codes can be stored and used as numbers, many developers find it more readable to store them in an object that keys them by their friendly name:</p>

<pre data-type="programlisting" data-code-language="ts" class="less_space pagebreak-before"><code class="kr">const</code> <code class="nx">StatusCodes</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">InternalServerError</code>: <code class="nx">500</code><code class="p">,</code>
    <code class="nx">NotFound</code>: <code class="nx">404</code><code class="p">,</code>
    <code class="nx">Ok</code>: <code class="nx">200</code><code class="p">,</code>
    <code class="c1">// ...</code>
<code class="p">}</code> <code class="kr">as</code> <code class="kr">const</code><code class="p">;</code>

<code class="nx">StatusCodes</code><code class="p">.</code><code class="nx">InternalServerError</code><code class="p">;</code> <code class="c1">// 500</code></pre>

<p>The tricky thing with enum-like objects in TypeScript is that there isn’t a great type system way to represent that a value must be one of their values.
One common method is to use the <code>keyof</code> and <code>typeof</code> type modifiers from <a data-type="xref" data-xrefstyle="chap-num-title" href="ch09.xhtml#type_modifiers_chapter">Chapter 9, “Type Modifiers”</a> to hack one together, but that’s a fair amount of syntax to type out.</p>

<p>The following <code>StatusCodeValue</code> type uses the previous <code>StatusCodes</code> value to create a type union of its possible status code number values:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// Type: 200 | 404 | 500</code>
<code class="kr">type</code> <code class="nx">StatusCodeValue</code> <code class="o">=</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">StatusCodes</code><code class="p">)[</code><code class="nx">keyof</code> <code class="k">typeof</code> <code class="nx">StatusCodes</code><code class="p">];</code>

<code class="kd">let</code> <code class="nx">statusCodeValue</code>: <code class="nx">StatusCodeValue</code><code class="p">;</code>

<code class="nx">statusCodeValue</code> <code class="o">=</code> <code class="mi">200</code><code class="p">;</code> <code class="c1">// Ok</code>

<code class="nx">statusCodeValue</code> <code class="o">=</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
<code class="c1">// Error: Type '-1' is not assignable to type 'StatusCodeValue'.</code></pre>

<p>TypeScript provides an <code>enum</code> syntax for creating an object with literal values of type <code>number</code> or <code>string</code>.
Start with the <code>enum</code> keyword, then a name of an object—conventionally in PascalCase—then an <code>{}</code> object containing comma-separated keys in the enum.
Each key can optionally use <code>=</code> before an initial value.</p>

<p>The previous <code>StatusCodes</code> object would look like this <code>StatusCode</code> enum:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">enum</code> <code class="nx">StatusCode</code> <code class="p">{</code>
    <code class="nx">InternalServerError</code> <code class="o">=</code> <code class="mi">500</code><code class="p">,</code>
    <code class="nx">NotFound</code> <code class="o">=</code> <code class="mi">404</code><code class="p">,</code>
    <code class="nx">Ok</code> <code class="o">=</code> <code class="mi">200</code><code class="p">,</code>
<code class="p">}</code>

<code class="nx">StatusCode</code><code class="p">.</code><code class="nx">InternalServerError</code><code class="p">;</code> <code class="c1">// 500</code></pre>

<p>As with class names, an enum name such as <code>StatusCode</code> can be used as the type name in a type annotation.
Here, the <code>statusCode</code> variable of type <code>StatusCode</code> may be given <code>StatusCode.Ok</code> or a number value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kd">let</code> <code class="nx">statusCode</code>: <code class="nx">StatusCode</code><code class="p">;</code>

<code class="nx">statusCode</code> <code class="o">=</code> <code class="nx">StatusCode</code><code class="p">.</code><code class="nx">Ok</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="nx">statusCode</code> <code class="o">=</code> <code class="mi">200</code><code class="p">;</code> <code class="c1">// Ok</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>TypeScript allows any number to be assigned to a numeric enum value as a convenience at the cost of a little type safety.

<span class="keep-together"><code>statusCode = -1</code></span> would have also been allowed in the previous code snippet.</p>
</div>

<p>Enums compile down to an equivalent object in output compiled JavaScript.
Each of their members becomes an object member key with the corresponding value, and vice versa.</p>

<p>The previous <code>enum StatusCode</code> would create roughly the following JavaScript:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">var</code> <code class="nx">StatusCode</code><code class="p">;</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">StatusCode</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">StatusCode</code><code class="p">[</code><code class="nx">StatusCode</code><code class="p">[</code><code class="s2">"InternalServerError"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">500</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"InternalServerError"</code><code class="p">;</code>
    <code class="nx">StatusCode</code><code class="p">[</code><code class="nx">StatusCode</code><code class="p">[</code><code class="s2">"NotFound"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">404</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"NotFound"</code><code class="p">;</code>
    <code class="nx">StatusCode</code><code class="p">[</code><code class="nx">StatusCode</code><code class="p">[</code><code class="s2">"Ok"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">200</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Ok"</code><code class="p">;</code>
<code class="p">})(</code><code class="nx">StatusCode</code> <code class="o">||</code> <code class="p">(</code><code class="nx">StatusCode</code> <code class="o">=</code> <code class="p">{}));</code></pre>

<p>Enums are a mildly contentious topic in the TypeScript community.
On the one hand, they violate TypeScript’s general mantra of never adding new runtime syntax constructs to JavaScript.
They present a new non-JavaScript syntax for developers to learn and have a few quirks around options such as <code>preserveConstEnums</code>, covered later in this chapter.</p>

<p>On the other hand, they’re quite useful for explicitly declaring known sets of values.
Enums are used extensively in both the TypeScript <a data-type="indexterm" data-primary="syntax extensions" data-secondary="enums" data-tertiary="purpose of" data-startref="syntax-enum-purpose" id="idm45584667613984"/><a data-type="indexterm" data-primary="enums" data-secondary="purpose of" data-startref="enum-purpose" id="idm45584667612560"/>and VS Code source repositories!</p>








<section data-type="sect2" data-pdf-bookmark="Automatic Numeric Values"><div class="sect2" id="idm45584667611088">
<h2>Automatic Numeric Values</h2>

<p>Enum members<a data-type="indexterm" data-primary="syntax extensions" data-secondary="enums" data-tertiary="automatic numeric values" id="syntax-enum-autovalue"/><a data-type="indexterm" data-primary="enums" data-secondary="automatic numeric values" id="enum-autovalue"/><a data-type="indexterm" data-primary="automatic numeric values with enums" id="autovalue"/> don’t need to have an explicit initial value.
When values are omitted, TypeScript will start the first value off with <code>0</code> and increment each subsequent value by <code>1</code>.
Allowing TypeScript to choose the values for enum members is a good option when the value doesn’t matter beyond being unique and associated with the key name.</p>

<p>This <code>VisualTheme</code> enum allows TypeScript to choose the values entirely, resulting in three integers:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">enum</code> <code class="nx">VisualTheme</code> <code class="p">{</code>
    <code class="nx">Dark</code><code class="p">,</code> <code class="c1">// 0</code>
    <code class="nx">Light</code><code class="p">,</code> <code class="c1">// 1</code>
    <code class="nx">System</code><code class="p">,</code> <code class="c1">// 2</code>
<code class="p">}</code></pre>

<p class="less_space pagebreak-before">The emitted JavaScript looks the same as if the values had been set explicitly:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">var</code> <code class="nx">VisualTheme</code><code class="p">;</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">VisualTheme</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">VisualTheme</code><code class="p">[</code><code class="nx">VisualTheme</code><code class="p">[</code><code class="s2">"Dark"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Dark"</code><code class="p">;</code>
    <code class="nx">VisualTheme</code><code class="p">[</code><code class="nx">VisualTheme</code><code class="p">[</code><code class="s2">"Light"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Light"</code><code class="p">;</code>
    <code class="nx">VisualTheme</code><code class="p">[</code><code class="nx">VisualTheme</code><code class="p">[</code><code class="s2">"System"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"System"</code><code class="p">;</code>
<code class="p">})(</code><code class="nx">VisualTheme</code> <code class="o">||</code> <code class="p">(</code><code class="nx">VisualTheme</code> <code class="o">=</code> <code class="p">{}));</code></pre>

<p>In enums with numeric values, any members missing an explicit value will be <code>1</code> greater than the previous value.</p>

<p>As an example, a <code>Direction</code> enum might only care that its <code>Top</code> member has a value of <code>1</code> and the remaining values are also positive integers:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">enum</code> <code class="nx">Direction</code> <code class="p">{</code>
  <code class="nx">Top</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code>
  <code class="nx">Right</code><code class="p">,</code>
  <code class="nx">Bottom</code><code class="p">,</code>
  <code class="nx">Left</code><code class="p">,</code>
<code class="p">}</code></pre>

<p>Its output JavaScript would also look the same as if the remaining members had explicit values <code>2</code>, <code>3</code>, and <code>4</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">var</code> <code class="nx">Direction</code><code class="p">;</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Direction</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Direction</code><code class="p">[</code><code class="nx">Direction</code><code class="p">[</code><code class="s2">"Top"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Top"</code><code class="p">;</code>
    <code class="nx">Direction</code><code class="p">[</code><code class="nx">Direction</code><code class="p">[</code><code class="s2">"Right"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Right"</code><code class="p">;</code>
    <code class="nx">Direction</code><code class="p">[</code><code class="nx">Direction</code><code class="p">[</code><code class="s2">"Bottom"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Bottom"</code><code class="p">;</code>
    <code class="nx">Direction</code><code class="p">[</code><code class="nx">Direction</code><code class="p">[</code><code class="s2">"Left"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">4</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Left"</code><code class="p">;</code>
<code class="p">})(</code><code class="nx">Direction</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Direction</code> <code class="o">=</code> <code class="p">{}));</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Modifying the order of an enum will cause the underlying number to change.
If you persist these values somewhere, such as a database, be careful of changing the enum order or removing an entry.
Your data may suddenly be corrupt because the saved number will no longer represent what your code <a data-type="indexterm" data-primary="syntax extensions" data-secondary="enums" data-tertiary="automatic numeric values" data-startref="syntax-enum-autovalue" id="idm45584667374416"/><a data-type="indexterm" data-primary="enums" data-secondary="automatic numeric values" data-startref="enum-autovalue" id="idm45584667310864"/><a data-type="indexterm" data-primary="automatic numeric values with enums" data-startref="autovalue" id="idm45584667309680"/>expects.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="String-Valued Enums"><div class="sect2" id="idm45584667610496">
<h2>String-Valued Enums</h2>

<p>Enums <a data-type="indexterm" data-primary="syntax extensions" data-secondary="enums" data-tertiary="string values" id="syntax-enum-string"/><a data-type="indexterm" data-primary="enums" data-secondary="string values" id="enum-string"/><a data-type="indexterm" data-primary="string-valued enums" id="string-enum"/>may also use strings for their members instead of numbers.</p>

<p>This <code>LoadStyle</code> enum uses friendly string values for its members:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">enum</code> <code class="nx">LoadStyle</code> <code class="p">{</code>
    <code class="nx">AsNeeded</code> <code class="o">=</code> <code class="s2">"as-needed"</code><code class="p">,</code>
    <code class="nx">Eager</code> <code class="o">=</code> <code class="s2">"eager"</code><code class="p">,</code>
<code class="p">}</code></pre>

<p>Output JavaScript for enums with string member values looks structurally the same as enums with numeric member values:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">var</code> <code class="nx">LoadStyle</code><code class="p">;</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">LoadStyle</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">LoadStyle</code><code class="p">[</code><code class="s2">"AsNeeded"</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"as-needed"</code><code class="p">;</code>
    <code class="nx">LoadStyle</code><code class="p">[</code><code class="s2">"Eager"</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"eager"</code><code class="p">;</code>
<code class="p">})(</code><code class="nx">LoadStyle</code> <code class="o">||</code> <code class="p">(</code><code class="nx">LoadStyle</code> <code class="o">=</code> <code class="p">{}));</code></pre>

<p>String valued enums are handy for aliasing shared constants under legible names.
Instead of using a type union of string literals, string valued enums allow for more powerful editor autocompletions and renames of those properties—as covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch12.xhtml#using_ide_features">Chapter 12, “Using IDE Features”</a>.</p>

<p>One downside of string member values is that they cannot be computed automatically by TypeScript.
Only enum members that follow a member with a numeric value are allowed to be computed automatically.</p>

<p>TypeScript would be able to provide an implicit value of <code>9001</code> in this enum’s 
<span class="keep-together"><code>ImplicitNumber</code></span> because the previous member value is the number <code>9000</code>, but its <code>NotAllowed</code> member would issue an error because it follows a string member value:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">enum</code> <code class="nx">Wat</code> <code class="p">{</code>
    <code class="nx">FirstString</code> <code class="o">=</code> <code class="s2">"first"</code><code class="p">,</code>
    <code class="nx">SomeNumber</code> <code class="o">=</code> <code class="mi">9000</code><code class="p">,</code>
    <code class="nx">ImplicitNumber</code><code class="p">,</code> <code class="c1">// Ok (value 9001)</code>
    <code class="nx">AnotherString</code> <code class="o">=</code> <code class="s2">"another"</code><code class="p">,</code>

    <code class="nx">NotAllowed</code><code class="p">,</code>
    <code class="c1">// Error: Enum member must have initializer.</code>
<code class="p">}</code></pre>
<div data-type="tip"><h6>Tip</h6>
<p>In theory, you could make an enum with both numeric and string member values.
In practice, that enum would likely be unnecessarily confusing, so you probably <a data-type="indexterm" data-primary="syntax extensions" data-secondary="enums" data-tertiary="string values" data-startref="syntax-enum-string" id="idm45584667138112"/><a data-type="indexterm" data-primary="enums" data-secondary="string values" data-startref="enum-string" id="idm45584667136592"/><a data-type="indexterm" data-primary="string-valued enums" data-startref="string-enum" id="idm45584667161552"/>shouldn’t.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Const Enums"><div class="sect2" id="idm45584667307920">
<h2>Const Enums</h2>

<p>Because <a data-type="indexterm" data-primary="syntax extensions" data-secondary="enums" data-tertiary="const enums" id="syntax-enum-const"/><a data-type="indexterm" data-primary="enums" data-secondary="const enums" id="enum-const"/><a data-type="indexterm" data-primary="const enums" id="const-enum"/>enums create a runtime object, using them produces more code than the common alternative strategy of unions of literal values.
TypeScript allows declaring enums with the <code>const</code> modifier in front of them to tell TypeScript to omit their objects definition and property lookups from compiled JavaScript code.</p>

<p>This <code>DisplayHint</code> enum is used as a value for a <code>displayHint</code> variable:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="kr">enum</code> <code class="nx">DisplayHint</code> <code class="p">{</code>
    <code class="nx">Opaque</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code>
    <code class="nx">Semitransparent</code><code class="p">,</code>
    <code class="nx">Transparent</code><code class="p">,</code>
<code class="p">}</code>

<code class="kd">let</code> <code class="nx">displayHint</code> <code class="o">=</code> <code class="nx">DisplayHint</code><code class="p">.</code><code class="nx">Transparent</code><code class="p">;</code></pre>

<p>The output compiled JavaScript code would be missing the enum declaration altogether and would use a comment for the enum’s value:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">displayHint</code> <code class="o">=</code> <code class="mi">2</code> <code class="cm">/* DisplayHint.Transparent */</code><code class="p">;</code></pre>

<p>For projects where it’s still desirable to create enum object definitions, a 
<span class="keep-together"><code>preserveConstEnums</code></span> compiler option does exist that would keep the enum declaration itself in existence.
Values would still directly use literals instead of accessing them on the enum object.</p>

<p>The previous code snippet would still omit the property lookup in its compiled JavaScript output:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">var</code> <code class="nx">DisplayHint</code><code class="p">;</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">DisplayHint</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">DisplayHint</code><code class="p">[</code><code class="nx">DisplayHint</code><code class="p">[</code><code class="s2">"Opaque"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Opaque"</code><code class="p">;</code>
    <code class="nx">DisplayHint</code><code class="p">[</code><code class="nx">DisplayHint</code><code class="p">[</code><code class="s2">"Semitransparent"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Semitransparent"</code><code class="p">;</code>
    <code class="nx">DisplayHint</code><code class="p">[</code><code class="nx">DisplayHint</code><code class="p">[</code><code class="s2">"Transparent"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Transparent"</code><code class="p">;</code>
<code class="p">})(</code><code class="nx">DisplayHint</code> <code class="o">||</code> <code class="p">(</code><code class="nx">DisplayHint</code> <code class="o">=</code> <code class="p">{}));</code>

<code class="kd">let</code> <code class="nx">displayHint</code> <code class="o">=</code> <code class="mi">2</code> <code class="cm">/* Transparent */</code><code class="p">;</code></pre>

<p><code>preserveConstEnums</code> can help reduce the size of emitted JavaScript code, though not all ways to transpile TypeScript code support it.
See <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a> for more information on the <code>isolatedModules</code> compiler option and when <code>const</code> enums may not be <a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="enums" data-startref="javascript-syntax-enum" id="idm45584666997232"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="enums" data-tertiary="const enums" data-startref="syntax-enum-const" id="idm45584666995680"/><a data-type="indexterm" data-primary="enums" data-secondary="const enums" data-startref="enum-const" id="idm45584666994192"/><a data-type="indexterm" data-primary="const enums" data-startref="const-enum" id="idm45584666992976"/>supported.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Namespaces"><div class="sect1" id="idm45584666991904">
<h1>Namespaces</h1>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Unless <a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="namespaces" id="javascript-syntax-namespace"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="namespaces" data-tertiary="purpose of" id="syntax-namespace-purpose"/><a data-type="indexterm" data-primary="namespaces" data-secondary="purpose of" id="namespace-purpose"/>you are authoring DefinitelyTyped type definitions for an existing package, do not use namespaces.
Namespaces do not match up to modern JavaScript module semantics.
Their automatic member assignments can make code confusing to read.
I only mention them because you may come across them in <em>.d.ts</em> files.</p>
</div>

<p>Back before ECMAScript modules were ratified, it wasn’t uncommon for web applications to bundle much of their output code into a single file loaded by the browser.
Those giant single files often created global variables to hold references to important values across different areas of the project.
It was simpler for pages to include that one file than to set up an old module loader such as RequireJS—and oftentimes more performant to load, since many servers didn’t yet support HTTP/2 download streaming.
Projects made for a single-file output needed a way to organize sections of code and those global variables.</p>

<p>The TypeScript language provided one solution with the concept of “internal modules,” now referred to as namespaces.
A <em>namespace</em> is a globally available object with “exported” contents available to call as members of that object.
Namespaces are defined with the <code>namespace</code> keyword followed by a <code>{}</code> block of code.
Everything in that namespace block is evaluated inside a function closure.</p>

<p>This <code>Randomized</code> namespace creates a <code>value</code> variable and uses it internally:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">namespace</code> <code class="nx">Randomized</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">();</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`My value is </code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Its output JavaScript creates a <code>Randomized</code> object and evaluates the contents of the block inside a function, so the <code>value</code> variable isn’t available outside of the namespace:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">var</code> <code class="nx">Randomized</code><code class="p">;</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Randomized</code><code class="p">)</code> <code class="p">{</code>
    <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">();</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`My value is </code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
<code class="p">})(</code><code class="nx">Randomized</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Randomized</code> <code class="o">=</code> <code class="p">{}));</code></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Namespaces and the <code>namespace</code> keyword were originally called “modules” and "<code>module</code>,” respectively, in TypeScript.
That was a regrettable choice in hindsight given the rise of modern module loaders and ECMAScript modules.
The <code>module</code> keyword is still occasionally found in very old projects, but can—and should—be safely replaced<a data-type="indexterm" data-primary="syntax extensions" data-secondary="namespaces" data-tertiary="purpose of" data-startref="syntax-namespace-purpose" id="idm45584666855632"/><a data-type="indexterm" data-primary="namespaces" data-secondary="purpose of" data-startref="namespace-purpose" id="idm45584666854144"/><a data-type="indexterm" data-primary="namespaces" data-secondary="modules vs." id="idm45584666852928"/><a data-type="indexterm" data-primary="modules" data-secondary="namespaces vs." id="idm45584666851984"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="namespaces" data-tertiary="modules vs." id="idm45584666851040"/> with <code>namespace</code>.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Namespace Exports"><div class="sect2" id="idm45584666849152">
<h2>Namespace Exports</h2>

<p>The key<a data-type="indexterm" data-primary="syntax extensions" data-secondary="namespaces" data-tertiary="exports" id="syntax-namespace-export"/><a data-type="indexterm" data-primary="namespaces" data-secondary="exports" id="namespace-export"/><a data-type="indexterm" data-primary="exporting" data-secondary="namespaces and" id="export-namespace"/> feature of namespaces that made them useful was that a namespace could “export” contents by making them a member of the namespace object.
Other areas of code can then refer to that member by name.</p>

<p>Here, a <code>Settings</code> namespace exports <code>describe</code>, <code>name</code>, and <code>version</code> values used internally and externally to the namespace:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">namespace</code> <code class="nx">Settings</code> <code class="p">{</code>
  <code class="kr">export</code> <code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"My Application"</code><code class="p">;</code>
  <code class="kr">export</code> <code class="kr">const</code> <code class="nx">version</code> <code class="o">=</code> <code class="s2">"1.2.3"</code><code class="p">;</code>

  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">describe() {</code>
    <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> at version </code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">version</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
  <code class="p">}</code>

  <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initializing"</code><code class="p">,</code> <code class="nx">describe</code><code class="p">());</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initialized"</code><code class="p">,</code> <code class="nx">Settings</code><code class="p">.</code><code class="nx">describe</code><code class="p">());</code></pre>

<p>The output JavaScript shows that the values are always referenced as members of <code>Settings</code> (e.g., <code>Settings.name</code>) in both internal and external usage:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">var</code> <code class="nx">Settings</code><code class="p">;</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Settings</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Settings</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s2">"My Application"</code><code class="p">;</code>
    <code class="nx">Settings</code><code class="p">.</code><code class="nx">version</code> <code class="o">=</code> <code class="s2">"1.2.3"</code><code class="p">;</code>
    <code class="kd">function</code> <code class="nx">describe</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> at version </code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">version</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">Settings</code><code class="p">.</code><code class="nx">describe</code> <code class="o">=</code> <code class="nx">describe</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initializing"</code><code class="p">,</code> <code class="nx">describe</code><code class="p">());</code>
<code class="p">})(</code><code class="nx">Settings</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Settings</code> <code class="o">=</code> <code class="p">{}));</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initialized"</code><code class="p">,</code> <code class="nx">Settings</code><code class="p">.</code><code class="nx">describe</code><code class="p">());</code></pre>

<p>By using a <code>var</code> for the output object and referencing exported contents as members of those objects, namespaces by design work well when split across multiple files.
The previous <code>Settings</code> namespace could be rewritten across multiple files:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// settings/constants.ts</code>
<code class="nx">namespace</code> <code class="nx">Settings</code> <code class="p">{</code>
  <code class="kr">export</code> <code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"My Application"</code><code class="p">;</code>
  <code class="kr">export</code> <code class="kr">const</code> <code class="nx">version</code> <code class="o">=</code> <code class="s2">"1.2.3"</code><code class="p">;</code>
<code class="p">}</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// settings/describe.ts</code>
<code class="nx">namespace</code> <code class="nx">Settings</code> <code class="p">{</code>
    <code class="kr">export</code> <code class="kd">function</code> <code class="nx">describe() {</code>
        <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> at version </code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">version</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
    <code class="p">}</code>

    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initializing"</code><code class="p">,</code> <code class="nx">describe</code><code class="p">());</code>
<code class="p">}</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initialized"</code><code class="p">,</code> <code class="nx">Settings</code><code class="p">.</code><code class="nx">describe</code><code class="p">());</code></pre>

<p>The output JavaScript, concatenated together, would look roughly like:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// settings/constants.ts</code>
<code class="kd">var</code> <code class="nx">Settings</code><code class="p">;</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Settings</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">Settings</code><code class="p">.</code><code class="nx">name</code> <code class="o">=</code> <code class="s2">"My Application"</code><code class="p">;</code>
    <code class="nx">Settings</code><code class="p">.</code><code class="nx">version</code> <code class="o">=</code> <code class="s2">"1.2.3"</code><code class="p">;</code>
<code class="p">})(</code><code class="nx">Settings</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Settings</code> <code class="o">=</code> <code class="p">{}));</code>
<code class="c1">// settings/describe.ts</code>
<code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Settings</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">function</code> <code class="nx">describe</code><code class="p">()</code> <code class="p">{</code>
        <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> at version </code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">version</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
    <code class="p">}</code>
    <code class="nx">Settings</code><code class="p">.</code><code class="nx">describe</code> <code class="o">=</code> <code class="nx">describe</code><code class="p">;</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initialized"</code><code class="p">,</code> <code class="nx">describe</code><code class="p">());</code>
<code class="p">})(</code><code class="nx">Settings</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Settings</code> <code class="o">=</code> <code class="p">{}));</code>
<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initialized"</code><code class="p">,</code> <code class="nx">Settings</code><code class="p">.</code><code class="nx">describe</code><code class="p">());</code></pre>

<p>In both the single-file and multiple-file declaration forms, the output object at runtime is one with three keys.
Roughly:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">const</code> <code class="nx">Settings</code> <code class="o">=</code> <code class="p">{</code>
    <code class="nx">describe</code>: <code class="nx">function</code> <code class="nx">describe() {</code>
        <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> at version </code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">version</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
    <code class="p">},</code>
    <code class="nx">name</code><code class="o">:</code> <code class="s2">"My Application"</code><code class="p">,</code>
    <code class="nx">version</code><code class="o">:</code> <code class="s2">"1.2.3"</code><code class="p">,</code>
<code class="p">};</code></pre>

<p>The key difference with using a namespace is that it can be split across different files and members can still refer to each other under the namespace’s <a data-type="indexterm" data-primary="syntax extensions" data-secondary="namespaces" data-tertiary="exports" data-startref="syntax-namespace-export" id="idm45584666324992"/><a data-type="indexterm" data-primary="namespaces" data-secondary="exports" data-startref="namespace-export" id="idm45584666310544"/><a data-type="indexterm" data-primary="exporting" data-secondary="namespaces and" data-startref="export-namespace" id="idm45584666309328"/>name.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Nested Namespaces"><div class="sect2" id="idm45584666848496">
<h2>Nested Namespaces</h2>

<p>Namespaces <a data-type="indexterm" data-primary="syntax extensions" data-secondary="namespaces" data-tertiary="nested" id="idm45584666277792"/><a data-type="indexterm" data-primary="namespaces" data-secondary="nested" id="idm45584666276512"/><a data-type="indexterm" data-primary="nested namespaces" id="idm45584666275568"/>can be “nested” to indefinite levels by either exporting a namespace from within another namespace or putting one or more <code>.</code> periods inside a name.</p>

<p>The following two namespace declarations would behave identically:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="nx">namespace</code> <code class="nx">Root</code><code class="p">.</code><code class="nx">Nested</code> <code class="p">{</code>
    <code class="kr">export</code> <code class="kr">const</code> <code class="nx">value1</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">namespace</code> <code class="nx">Root</code> <code class="p">{</code>
    <code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">Nested</code> <code class="p">{</code>
        <code class="kr">export</code> <code class="kr">const</code> <code class="nx">value2</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>They both compile to structurally identical code:</p>

<pre data-type="programlisting" data-code-language="js"><code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Root</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">Nested</code><code class="p">;</code>
    <code class="p">(</code><code class="kd">function</code> <code class="p">(</code><code class="nx">Nested</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">Nested</code><code class="p">.</code><code class="nx">value2</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
    <code class="p">})(</code><code class="nx">Nested</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Nested</code> <code class="o">=</code> <code class="p">{}));</code>
<code class="p">})(</code><code class="nx">Root</code> <code class="o">||</code> <code class="p">(</code><code class="nx">Root</code> <code class="o">=</code> <code class="p">{}));</code></pre>

<p>Nested namespaces are a handy way to enforce more delineation between sections within larger projects organized with namespaces.
Many developers opted to use a root namespace by the name of their project—perhaps inside a namespace for their company and/or organization—and child namespaces for each major area of the project.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Namespaces in Type Definitions"><div class="sect2" id="idm45584666213696">
<h2>Namespaces in Type Definitions</h2>

<p>The only<a data-type="indexterm" data-primary="syntax extensions" data-secondary="namespaces" data-tertiary="in type definitions" data-tertiary-sortas="type definitions" id="syntax-namespace-typedef"/><a data-type="indexterm" data-primary="namespaces" data-secondary="in type definitions" data-secondary-sortas="type definitions" id="namespace-typedef"/><a data-type="indexterm" data-primary="type definitions" data-secondary="namespaces in" id="typedef-namespace"/> redeeming quality for namespaces today—and the only reason why I opted to include them in this book—is that they can be useful for DefinitelyTyped type definitions.
Many JavaScript libraries—particularly older web application staples such as jQuery—are set up to be included in web browsers with a traditional, non-module <code>&lt;script&gt;</code> tag.
Their typings need to indicate that they create a global variable available to all code—structure perfectly captured by namespaces.</p>

<p>Additionally, many browser-capable JavaScript libraries are set up both to be imported in more modern module systems and also to create a global namespace.
TypeScript allows a module type definition to include an <code>export as namespace</code>, followed by a global name, to indicate the module is also available globally under that name.</p>

<p>For example, this declaration file for a module exports a <code>value</code> and is available globally:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// node_modules/@types/my-example-lib/index.d.ts</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">value</code>: <code class="nx">number</code><code class="p">;</code>
<code class="kr">export</code> <code class="kr">as</code> <code class="nx">namespace</code> <code class="nx">libExample</code><code class="p">;</code></pre>

<p>The type system would know that both <code>import("my-example-lib")</code> and 
<span class="keep-together"><code>window.libExample</code></span> would give back the module, with a <code>value</code> property of type <code>number</code>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// src/index.ts</code>
<code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">libExample</code> <code class="nx">from</code> <code class="s2">"my-example-lib"</code><code class="p">;</code> <code class="c1">// Ok</code>
<code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="nb">window</code><code class="p">.</code><code class="nx">libExample</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code> <code class="c1">// Ok</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Prefer Modules Over Namespaces"><div class="sect2" id="idm45584666176688">
<h2>Prefer Modules Over Namespaces</h2>

<p>Instead of <a data-type="indexterm" data-primary="syntax extensions" data-secondary="namespaces" data-tertiary="modules vs." id="idm45584666086496"/><a data-type="indexterm" data-primary="namespaces" data-secondary="modules vs." id="idm45584666085248"/><a data-type="indexterm" data-primary="modules" data-secondary="namespaces vs." id="idm45584666084304"/><a data-type="indexterm" data-primary="ECMAScript Modules (ESM)" id="idm45584666083360"/><a data-type="indexterm" data-primary="ESM (ECMAScript Modules)" id="idm45584666082720"/>using namespaces, the previous examples’ <em>settings/constants.ts</em> file and <em>settings/describe.ts</em> file could be rewritten for modern standards with ECMAScript modules:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// settings/constants.ts</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"My Application"</code><code class="p">;</code>
<code class="kr">export</code> <code class="kr">const</code> <code class="nx">version</code> <code class="o">=</code> <code class="s2">"1.2.3"</code><code class="p">;</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// settings/describe.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">version</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./constants"</code><code class="p">;</code>

<code class="kr">export</code> <code class="kd">function</code> <code class="nx">describe() {</code>
    <code class="k">return</code> <code class="sb">`</code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> at version </code><code class="si">${</code><code class="nx">Settings</code><code class="p">.</code><code class="nx">version</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
<code class="p">}</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initializing"</code><code class="p">,</code> <code class="nx">describe</code><code class="p">());</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">describe</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"./settings/describe"</code><code class="p">;</code>

<code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Initialized"</code><code class="p">,</code> <code class="nx">describe</code><code class="p">());</code></pre>

<p>TypeScript code structured with namespaces can’t be easily tree-shaken (have unused files removed) in modern builders such as Webpack because namespaces create implicit, rather than explicitly declared, ties between files the way ECMAScript modules do.
It is generally strongly preferred to write runtime code using ECMAScript modules and not TypeScript namespaces.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>As of 2022, TypeScript itself is written in namespaces, but the TypeScript team is working on migrating over to modules.
Who knows, maybe by the time you’re reading this, they’ll have finished that conversion!
Fingers <a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="namespaces" data-startref="javascript-syntax-namespace" id="idm45584665937216"/>crossed.</p>
</div>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Type-Only Imports and Exports"><div class="sect1" id="idm45584667896000">
<h1>Type-Only Imports and Exports</h1>

<p>I’d like<a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="type-only imports and exports" id="javascript-syntax-type-only"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="type-only imports and exports" id="syntax-type-only"/><a data-type="indexterm" data-primary="type-only imports and exports" id="type-only"/><a data-type="indexterm" data-primary="importing" data-secondary="type-only imports and exports" id="import-type-only"/><a data-type="indexterm" data-primary="exporting" data-secondary="type-only imports and exports" id="export-type-only"/> to end this chapter on a positive note.
One last set of syntax extensions, type-only imports and exports, can be quite useful and don’t add any complexity to output emitted JavaScript.</p>

<p>TypeScript’s transpiler will remove values used only in the type system from imports and exports in files because they aren’t used in runtime JavaScript.</p>

<p>For example, the following <em>index.ts</em> file creates an <code>action</code> variable and an 
<span class="keep-together"><code>ActivistArea</code></span> type, then later exports both of them with a standalone export declaration.
When compiling it to <em>index.js</em>, TypeScript’s transpiler would know to remove <code>ActivistArea</code> from that standalone export declaration:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">const</code> <code class="nx">action</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">area</code><code class="o">:</code> <code class="s2">"people"</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Bella Abzug"</code><code class="p">,</code> <code class="nx">role</code><code class="o">:</code> <code class="s2">"politician"</code> <code class="p">};</code>

<code class="kr">type</code> <code class="nx">ActivistArea</code> <code class="o">=</code> <code class="s2">"nature"</code> <code class="o">|</code> <code class="s2">"people"</code><code class="p">;</code>

<code class="kr">export</code> <code class="p">{</code> <code class="nx">action</code><code class="p">,</code> <code class="nx">ActivistArea</code> <code class="p">};</code></pre>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// index.js</code>
<code class="kr">const</code> <code class="nx">action</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">area</code><code class="o">:</code> <code class="s2">"people"</code><code class="p">,</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Bella Abzug"</code><code class="p">,</code> <code class="nx">role</code><code class="o">:</code> <code class="s2">"politician"</code> <code class="p">};</code>

<code class="kr">export</code> <code class="p">{</code> <code class="nx">action</code> <code class="p">};</code></pre>

<p>Knowing to remove re-exported types such as that <code>ActivistArea</code> requires knowledge of the TypeScript type system.
Transpilers such as <a data-type="indexterm" data-primary="Babel" id="idm45584665869216"/>Babel that act on a single file at a time don’t have access to the TypeScript type system to know whether each name is only used in the type system.
TypeScript’s <code>isolatedModules</code> compiler option, covered in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch13.xhtml#configuration_options">Chapter 13, “Configuration Options”</a>, helps make sure code will transpile in tools other than TypeScript.</p>

<p>TypeScript allows adding the <code>type</code> modifier in front of individual imported names or the entire <code>{...}</code> object in <code>export</code> and <code>import</code> declarations.
Doing so indicates they’re only meant to be used in the type system.
Marking a default import of a package as <code>type</code> is allowed as well.</p>

<p>In the following snippet, only the <code>value</code> import and export are kept when <em>index.ts</em> is transpiled to the output <em>index.js</em>:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.ts</code>
<code class="kr">import</code> <code class="p">{</code> <code class="kr">type</code> <code class="nx">TypeOne</code><code class="p">,</code> <code class="nx">value</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"my-example-types"</code><code class="p">;</code>
<code class="kr">import</code> <code class="kr">type</code> <code class="p">{</code> <code class="nx">TypeTwo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"my-example-types"</code><code class="p">;</code>
<code class="kr">import</code> <code class="kr">type</code> <code class="nx">DefaultType</code> <code class="nx">from</code> <code class="s2">"my-example-types"</code><code class="p">;</code>

<code class="kr">export</code> <code class="p">{</code> <code class="kr">type</code> <code class="nx">TypeOne</code><code class="p">,</code> <code class="nx">value</code> <code class="p">};</code>
<code class="kr">export</code> <code class="kr">type</code> <code class="p">{</code> <code class="nx">DefaultType</code><code class="p">,</code> <code class="nx">TypeTwo</code> <code class="p">};</code></pre>

<pre data-type="programlisting" data-code-language="ts"><code class="c1">// index.js</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">value</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"my-example-types"</code><code class="p">;</code>

<code class="kr">export</code> <code class="p">{</code> <code class="nx">value</code> <code class="p">};</code></pre>

<p>Some TypeScript developers even prefer to opt into using type-only imports to make it more clear which imports are only used as types.
If an import is marked as type-only, attempting to use it as a runtime value will trigger a TypeScript error.</p>

<p>The following <code>ClassOne</code> is imported normally and can be used at runtime, but <code>ClassTwo</code> cannot because it is imported as a type:</p>

<pre data-type="programlisting" data-code-language="ts"><code class="kr">import</code> <code class="p">{</code> <code class="nx">ClassOne</code><code class="p">,</code> <code class="kr">type</code> <code class="nx">ClassTwo</code> <code class="p">}</code> <code class="nx">from</code> <code class="s2">"my-example-types"</code><code class="p">;</code>

<code class="k">new</code> <code class="nx">ClassOne</code><code class="p">();</code> <code class="c1">// Ok</code>

<code class="k">new</code> <code class="nx">ClassTwo</code><code class="p">();</code>
<code class="c1">//  ~~~~~~~~</code>
<code class="c1">// Error: 'ClassTwo' cannot be used as a value</code>
<code class="c1">// because it was imported using 'import type'.</code></pre>

<p>Instead of adding complexity to emitted JavaScript, type-only imports and exports make it clear to transpilers outside of TypeScript when it’s possible to remove pieces of code.
Most TypeScript developers therefore don’t treat them with the distaste given to the previous syntax extensions covered in this<a data-type="indexterm" data-primary="JavaScript" data-secondary="syntax extensions" data-tertiary="type-only imports and exports" data-startref="javascript-syntax-type-only" id="idm45584665657168"/><a data-type="indexterm" data-primary="syntax extensions" data-secondary="type-only imports and exports" data-startref="syntax-type-only" id="idm45584665655840"/><a data-type="indexterm" data-primary="type-only imports and exports" data-startref="type-only" id="idm45584665654688"/><a data-type="indexterm" data-primary="importing" data-secondary="type-only imports and exports" data-startref="import-type-only" id="idm45584665653776"/><a data-type="indexterm" data-primary="exporting" data-secondary="type-only imports and exports" data-startref="export-type-only" id="idm45584665652592"/> chapter.</p>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Summary"><div class="sect1" id="idm45584665934912">
<h1>Summary</h1>

<p>In this chapter, you worked with some of the JavaScript syntax extensions included in TypeScript:</p>

<ul>
<li>
<p>Declaring class parameter properties in class constructors</p>
</li>
<li>
<p>Using decorators to augment classes and their fields</p>
</li>
<li>
<p>Representing groups of values with enums</p>
</li>
<li>
<p>Using namespaces to create groupings across files or in type definitions</p>
</li>
<li>
<p>Type-only imports and exports</p>
</li>
</ul>
<div data-type="tip"><h6>Tip</h6>
<p>Now that you’ve finished reading this chapter, practice what you’ve learned on <a href="https://learningtypescript.com/syntax-extensions"><em class="hyperlink">https://learningtypescript.com/syntax-extensions</em></a>.</p>
</div>
<blockquote class="joke">
<p>What do you call the cost of supporting legacy JavaScript extensions in TypeScript?</p>

<p>“Sin tax.”</p></blockquote>
</div></section>







</div></section></div></body></html>