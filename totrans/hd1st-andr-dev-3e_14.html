<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 12. Live Data: Leaping into Action"><div class="chapter" id="live_datacolon_leaping_into_action">
<h1><span class="label">Chapter 12. </span>Live Data: <em>Leaping into Action</em></h1>
<figure class="informal"><div class="figure">
<img src="Images/f0483-01.png" alt="image" width="600" height="386"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="Guessing Game app" data-secondary="live data" data-see="live data" id="idm46053737268160"/><a data-type="indexterm" data-primary="live data" id="idm46053737266416"/><strong>Your code often needs to react to property value changes.</strong></p>
<p>If a view model property changes value, for example, <strong>the fragment might need to respond</strong> by updating its views or navigating elsewhere. But <strong>how does a fragment get to hear when a property’s been updated</strong>? Here, we’ll introduce you to <strong>live data</strong>: a way of <strong>telling interested parties when something’s changed</strong>. You’ll learn all about <strong><em>MutableLiveData</em></strong>, and how to <strong>make your fragment observe properties</strong> of this type. You’ll discover <strong>how the <em>LiveData</em> type helps maintain your app’s integrity</strong>. Soon, you’ll be writing apps that are <strong>more responsive than ever before</strong>...</p>
<section data-type="sect1" data-pdf-bookmark="The Guessing Game app revisited"><div class="sect1" id="the_guessing_game_app_revisited">
<h1>The Guessing Game app revisited</h1>
<p><a data-type="indexterm" data-primary="fragments" data-secondary="updating views versus view model" id="idm46053737258944"/><a data-type="indexterm" data-primary="Guessing Game app" id="idm46053737257376"/>In the previous chapter, we built a Guessing Game app that lets the user guess which letters are included in a secret word. When the user guesses all the letters or runs out of lives, the game ends.</p>
<p>To stop the fragment code from becoming too bloated and maintain the app’s state when the user rotated the device screen, we used view models for the app’s game logic and data. <code>GameFragment</code> uses <code>GameViewModel</code> for its logic and data, and <code>ResultViewModel</code> holds the game result that’s needed by <code>ResultFragment</code>:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0484-01.png" alt="image" width="600" height="528"/>
<h6/>
</div></figure>
<p>When each fragment is displayed, or the user makes a guess, the fragments get the latest values from their view models and display them on the screen.</p>
<p>While this approach works, however, there are some disadvantages.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The fragments decide when to update views"><div class="sect1" id="the_fragments_decide_when_to_update_view">
<h1>The fragments decide when to update views</h1>
<p><a data-type="indexterm" data-primary="GameFragment" data-secondary="live data with" id="idm46053737248272"/><a data-type="indexterm" data-primary="GameViewModel" data-secondary="live data with" id="idm46053737246848"/><a data-type="indexterm" data-primary="view models" data-secondary="live data with" id="idm46053737245712"/>The downside to this approach is that each fragment decides when to fetch the latest property values from the view model and update its views. And some of the time, these values won’t have changed. If the user makes a correct guess, for example, <code>GameFragment</code> updates the text that’s displayed for the number of lives left and the incorrect guesses, even though these values won’t have changed.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0485-01.png" alt="image" width="442" height="202"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="Let the view model say when a value’s changed"><div class="sect2" id="let_the_view_model_say_when_a_valueapost">
<h2>Let the view model say when a value’s changed</h2>
<p>An alternative approach is for <code>GameViewModel</code> to let <code>GameFragment</code> know when each of its properties has been updated. If the fragment is notified of these changes, it will no longer need to decide for itself when to fetch the latest property values from the view model and update its views. Instead, it will only need to update its views once it’s told that the underlying property has been updated.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0485-02.png" alt="image" width="600" height="179"/>
<h6/>
</div></figure>
<p>We’re going to implement this change in the Guessing Game app using Android’s <strong>live data</strong> library: part of Android Jetpack. Live data lets the view model tell interested parties—such as fragments and activities—when its property values have been updated. They can then react to these changes by updating views, or calling other methods.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0485-03.png" alt="image" width="328" height="147"/>
<h6/>
</div></figure>
<p>You’ll find out how to use live data through the rest of this chapter. First, let’s go through the steps we’ll take to update the app.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Here’s what we’re going to do"><div class="sect1" id="hereapostrophes_what_weapostroph-id00177">
<h1>Here’s what we’re going to do</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0486-01.png" alt="image" width="313" height="87"/>
<h6/>
</div></figure>
<p>Here are the steps that we’ll go through to write the app:</p>
<ol>
<li><p><strong>Make the Guessing Game app use live data.</strong></p>
<p>We’ll update <code>GameViewModel</code> so that the <code>livesLeft</code>, <code>incorrectGuesses,</code> and <code>secretWordDisplay</code> properties use live data. We’ll then make <code>GameFragment</code> update its views when the values of these properties change.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0486-02.png" alt="image" width="348" height="166"/>
<h6/>
</div></figure></li>
<li><p><strong>Protect GameViewModel’s properties and methods.</strong></p>
<p>We’ll restrict access to <code>GameViewModel</code>’s properties so that only <code>GameViewModel</code> can update them. We’ll also make sure that <code>GameFragment</code> only has access to the methods it requires to do its job.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0486-03.png" alt="image" width="600" height="120"/>
<h6/>
</div></figure></li>
<li><p><strong>Add a gameOver property.</strong></p>
<p>We’ll make <code>GameViewModel</code> decide when each game is over using a new <code>gameOver</code> property. <code>GameFragment</code> will navigate to <code>ResultFragment</code> when the value of this property changes.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0486-04.png" alt="image" width="321" height="108"/>
<h6/>
</div></figure></li>
</ol>
<section data-type="sect2" data-pdf-bookmark="Add a live data dependency to the app build.gradle file"><div class="sect2" id="add_a_live_data_dependency_to_the_app_bu">
<h2>Add a live data dependency to the <u>app</u> build.gradle file</h2>
<p>As we’re going to be using live data, we’ll begin by adding a live data dependency to the app’s <em>build.gradle</em> file.</p>
<p>Open the project for the Guessing Game app (if you haven’t already done so), open the file <em>GuessingGame/app/build.gradle</em>, and add the following line (in bold) to the <code>dependencies</code> section:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0486-05.png" alt="image" width="600" height="128"/>
<h6/>
</div></figure>
<p>When prompted, sync your changes.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="GameViewModel and GameFragment need to use live data"><div class="sect1" id="gameviewmodel_and_gamefragment_need_to_u">
<h1>GameViewModel and GameFragment need to use live data</h1>
<p><a data-type="indexterm" data-primary="Android Jetpack" data-secondary="live data" data-see="live data" id="idm46053737204912"/><a data-type="indexterm" data-primary="fragments" data-secondary="live data" id="idm46053737203344"/><a data-type="indexterm" data-primary="incorrectGuesses property, GameViewModel" id="idm46053737202240"/><a data-type="indexterm" data-primary="live data" data-secondary="setting up fragments’ use of" id="idm46053737201440"/><a data-type="indexterm" data-primary="livesLeft property, GameViewModel" data-secondary="using live data" id="idm46053737200368"/><a data-type="indexterm" data-primary="MutableLiveData&lt;Type&gt;" id="idm46053737199296"/><a data-type="indexterm" data-primary="properties" data-secondary="view model" id="idm46053737198464"/><a data-type="indexterm" data-primary="secretWordDisplay property, GameViewModel" id="idm46053737197360"/>We want to use live data in the Guessing Game app so that <code>GameViewModel</code> notifies <code>GameFragment</code> when its property values have changed. <code>GameFragment</code> will then react to these changes.</p>
<p>We’ll tackle this in two stages:</p>
<ol>
<li><p><strong>Specify which GameViewModel property changes GameFragment needs to know about.</strong></p></li>
<li><p><strong>Tell GameFragment how to respond to each change.</strong></p></li>
</ol>
<p>For now, we’ll focus on the <code>GameViewModel</code> code changes.</p>
<section data-type="sect2" data-pdf-bookmark="Which view model properties should use live data?"><div class="sect2" id="which_view_model_properties_should_use_l">
<h2>Which view model properties should use live data?</h2>
<p><code>GameViewModel</code> includes three properties—<code>secretWordDisplay</code>, <code>incorrectGuesses,</code> and <code>livesLeft</code>—that <code>GameFragment</code> uses to update its views. We’ll specify that these three properties use live data so that <code>GameFragment</code> is notified when their values change.</p>
<p>You specify that a property uses live data by changing its type to <code><strong>MutableLiveData&lt;Type&gt;</strong></code>, where <code>Type</code> is the type of data the property should hold. The <code>livesLeft</code> property, for example, is currently defined as an <code>Int</code> using the code:</p>
<pre data-type="programlisting">var livesLeft = 8</pre>
<p>To make the property use live data, you change its type to <code>MutableLiveData&lt;Int&gt;</code> so that it looks like this instead:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0487-03.png" alt="image" width="600" height="64"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0487-02.png" alt="image" width="212" height="392"/>
<h6/>
</div></figure>
<p>This specifies that <code>livesLeft</code> is now a <code>MutableLiveData&lt;Int&gt;</code> with an initial value of 8.</p>
<p>Similarly, we can define the <code>incorrectGuesses</code> and <code>secretWordDisplay</code> properties using code like this</p>
<figure class="informal"><div class="figure">
<img src="Images/f0487-04.png" alt="image" width="600" height="95"/>
<h6/>
</div></figure>
<p>Here, each property’s type is set to <code>MutableLiveData&lt;String&gt;</code>. <code>incorrectGuesses</code>’s value is set to <code>""</code>, while <code>secretWordDisplay</code>’s value will get set in <code>GameViewModel</code>’s <code>init</code> block.</p>
<p>So that’s how you define a live data property. Next up, how to update its value.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Live data objects use a value property"><div class="sect1" id="live_data_objects_use_a_value_property">
<h1>Live data objects use a <u>value</u> property</h1>
<p><a data-type="indexterm" data-primary="deriveSecretWordDisplay() method, SecretWordDisplay" id="idm46053737169808"/><a data-type="indexterm" data-primary="Elvis operator" id="idm46053737168496"/><a data-type="indexterm" data-primary="isLost() method" id="idm46053737167664"/><a data-type="indexterm" data-primary="livesLeft property, GameViewModel" data-secondary="value options" id="idm46053737166832"/><a data-type="indexterm" data-primary="value property, MutableLiveData" id="idm46053737165760"/><a data-type="indexterm" data-primary="value property, MutableLiveData" data-secondary="as nullable" id="idm46053737164960"/>When you use <code>MutableLiveData</code> properties, you update their values using a property named <code><strong>value</strong></code>. To update the <code>secretWordDisplay</code> property with the <code>deriveSecretWordDisplay()</code> method’s return value, for example, you don’t use the code:</p>
<pre data-type="programlisting">secretWordDisplay = deriveSecretWordDisplay()</pre>
<p>as you did before. You use the following code instead:</p>
<pre data-type="programlisting">secretWordDisplay<strong>.value</strong> = deriveSecretWordDisplay()</pre>
<p>Changing the <code>value</code> property in this way is important, because it’s how any interested parties—in this case <code>GameFragment</code>—get notified of any changes. Each time <code>secretWordDisplay</code>’s <code>value</code> property gets updated, <code>GameFragment</code> is informed, so it can respond by updating its views.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0488-02.png" alt="image" width="314" height="307"/>
<h6/>
</div></figure>
<section data-type="sect2" data-pdf-bookmark="The value property can be null"><div class="sect2" id="the_value_property_can_be_null">
<h2>The value property can be null</h2>
<p>There’s one extra thing to be aware of when you use live data: the <code>value</code>’s type is <em>nullable</em>. This means that when you use live data values in your code, you need to perform null-safety checks, or your code won’t compile.</p>
<p>As an example, the <code>livesLeft</code> property is defined using the code:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0488-03.png" alt="image" width="600" height="40"/>
<h6/>
</div></figure>
<p>This property’s type is <code>MutableLiveData&lt;Int&gt;</code>, so its <code>value</code> property can accept an <code>Int</code>, or be <code>null</code>.</p>
<p>As the <code>value</code> property may be <code>null</code>, we can’t, say subtract one from its value using the code:</p>
<pre data-type="programlisting">livesLeft.value--</pre>
<p>Instead, we need to use:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0488-04.png" alt="image" width="600" height="41"/>
<h6/>
</div></figure>
<p>which subtracts 1 from its value so long as it isn’t <code>null</code>.</p>
<p>Similarly, the following <code>isLost()</code> method won’t compile because <code>liveLeft.value</code> may be <code>null</code>:</p>
<pre data-type="programlisting">fun isLost() = livesLeft.value &lt;= 0</pre>
<p>We can, however, change it to use Kotlin’s Elvis operator like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0488-05.png" alt="image" width="600" height="57"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0489-02.png" alt="image" width="600" height="732"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="livesLeft property, GameViewModel" data-secondary="updating value property" id="idm46053737132912"/><a data-type="indexterm" data-primary="val and var, for live data properties" id="idm46053737131648"/><a data-type="indexterm" data-primary="value property, MutableLiveData" data-secondary="updating as val not var" id="idm46053737130848"/><strong>Live Data properties can be defined using val.</strong></p>
<p>As you already know, you use <code>val</code> and <code>var</code> in Kotlin to specify whether or not a property can be given a reference to a new object.</p>
<p>When we first defined each property, we used <code>var</code> so that we could update it. We defined the <code>livesLeft</code> property, for example, using:</p>
<pre data-type="programlisting">var livesLeft = 8</pre>
<p>which initialized <code>livesLeft</code> with an <code>Int</code> object whose value is 8. Each time the user made an incorrect guess, we subtracted 1 from <code>livesLeft</code>, which gave it a reference to a new <code>Int</code> object:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0489-03.png" alt="image" width="564" height="222"/>
<h6/>
</div></figure>
<p>With live data, you update the <code>value</code> property of the <em>existing</em> object, instead of replacing it with another object, and interested parties are notified of this change. As the object is no longer being replaced, you can define the property using <code>val</code> instead of <code>var</code> like this:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0489-04.png" alt="image" width="600" height="136"/>
<h6/>
</div></figure>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full code for GameViewModel.kt"><div class="sect1" id="the_full_code_for_gameviewmodeld-id00178">
<h1>The full code for GameViewModel.kt</h1>
<p>Now that you know how live data works, let’s update <code>GameViewModel</code> so that its <code>livesLeft</code>, <code>incorrectGuesses</code>, and <code>secretWordDisplay</code> properties all use live data.</p>
<p>Here’s the full code for <em>GameViewModel.kt</em>; update the code to include the changes (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0490-02.png" alt="image" width="600" height="575"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0491-02.png" alt="image" width="600" height="562"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="GameFragment" data-secondary="response to view model property updates" id="idm46053737112576"/>That’s everything that we need for <code>GameViewModel</code>. Next up, let’s make <code>GameFragment</code> respond when the <code>livesLeft</code>, <code>incorrectGuesses</code>, and <code>secretWordDisplay</code> properties get updated.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The fragment observes the view model properties and reacts to changes."><div class="sect1" id="the_fragment_observes_the_view_model_pro">
<h1>The fragment observes the view model properties and reacts to changes.</h1>
<p><a data-type="indexterm" data-primary="livesLeft property, GameViewModel" id="idm46053737102912"/><a data-type="indexterm" data-primary="livesLeft property, GameViewModel" data-secondary="updating text" id="idm46053737101952"/><a data-type="indexterm" data-primary="MutableLiveData properties" id="idm46053737100880"/><a data-type="indexterm" data-primary="observe() method, MutableLiveData property" id="idm46053737100080"/><a data-type="indexterm" data-primary="Observer class" id="idm46053737099152"/><a data-type="indexterm" data-primary="properties" data-secondary="MutableLiveData" id="idm46053737098320"/><a data-type="indexterm" data-primary="viewLifecycleOwner argument" id="idm46053737097216"/>You make a fragment respond to <code>value</code> changes in a view model’s <code>MutableLiveData</code> property by calling the property’s <code><strong>observe()</strong></code> method. If the following code is added to <code>GameFragment</code>, for example, it will observe the view model’s <code>livesLeft</code> property, and take action when it changes:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0492-02.png" alt="image" width="600" height="110"/>
<h6/>
</div></figure>
<p>As you can see, the above code passes <code>viewLifecycleOwner</code> and <code>Observer</code> arguments to the <code>observe()</code> method.</p>
<p><code>viewLifecycleOwner</code> refers to the lifecycle of the fragment’s views. It’s tied to when the fragment has access to its UI: from when it’s created in the fragment’s <code>onCreateView()</code> method, to when its destroyed, and <code>onDestroyView()</code> gets called.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0492-03.png" alt="image" width="387" height="261"/>
<h6/>
</div></figure>
<p><code>Observer</code> is a class that can receive live data. It’s tied to the <code>viewLifecycleOwner</code>, so it’s only active—and able to receive live data notifications—when the fragment has access to its views. If the live data property’s value changes while the fragment doesn’t have access to its UI, the observer isn’t notified, so the fragment doesn’t respond. This stops the fragment from trying to update views when they’re not available, which might cause the app to crash.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><span style="color:#9D9EA0;">It also makes your coding life easier because you don’t need to check whether the view’s available for yourself. Using live data handles it all for you.</span></p>
</div>
<p>The <code>Observer</code> class accepts a lambda parameter, which specifies how the property’s new value should be used. In the Guessing Game app, for example, we want <code>GameFragment</code> to update its <code>lives</code> text each time the view model’s <code>livesLeft</code> property gets updated, and we can achieve this using the following code:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0492-04.png" alt="image" width="600" height="95"/>
<h6/>
</div></figure>
<p>That’s everything that we need to know in order to make <code>GameFragment</code> update its views when the view model property values get changed. Let’s update its code.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full code for GameFragment.kt"><div class="sect1" id="the_full_code_for_gamefragmentdotkt">
<h1>The full code for GameFragment.kt</h1>
<p><a data-type="indexterm" data-primary="GameFragment" data-secondary="code for" id="idm46053737080976"/>Here’s the updated code for <code>GameFragment</code>; make sure that the file <em>GameFragment.kt</em> includes the changes shown below (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0493-02.png" alt="image" width="600" height="618"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0494-02.png" alt="image" width="600" height="508"/>
<h6/>
</div></figure>
<p>Those are all the changes we need to make to <code>GameFragment</code> so that it updates its views each time it observes changes to the <code>incorrectGuesses</code>, <code>livesLeft</code>, and <code>secretWordDisplay</code> properties.</p>
<p>We’ve now implemented live data in the Guessing Game app Let’s go through what happens when the app runs.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0495-02.png" alt="image" width="600" height="598"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="ResultViewModel" data-secondary="live data" id="idm46053737067440"/><strong>ResultViewModel doesn’t need to use live data, so we don’t need to update it.</strong></p>
<p>As you may recall, <code>ResultViewModel</code> has one property (named <code>result</code>), which gets set when the view model gets created. The code looks like this:</p>
<pre data-type="programlisting">class ResultViewModel(finalResult: String) : ViewModel(){
    <strong>val result = finalResult</strong>
}</pre>
<p>As you can see, result is defined using <code>val</code>, so once it’s been initialized, it can’t be updated to another value. <code>ResultFragment</code> doesn’t need to be notified when <code>result</code> changes because <strong>once set,</strong> <code><strong>result</strong></code> <strong>can never change</strong>. There’s no need to make <code>ResultFragment</code> respond to any changes, because there can’t be any.</p>
<p>So let’s walk through what happens when the code runs, and then take the app for a test drive.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="there_are_no_dumb_questions-id00179">
<h5>there are no Dumb Questions</h5>
<p><strong>Q: What happens if <code>GameFragment</code> is inactive when one of <code>GameViewModel</code>’s live data properties gets updated? Won’t this make the app crash?</strong></p>
<p><strong>A:</strong> No. Live data is lifecycle-aware, so it only notifies active lifecycle observers when its property values have changed. If <code>GameFragment</code> is inactive when <code>GameViewModel</code>’s properties get updated, <code>GameFragment</code> won’t get notified, so you don’t have to worry about the app crashing.</p>
<p><strong>Q: Is there a <code>LiveData</code> type too?</strong></p>
<p><strong>A:</strong> Yes! The <code>LiveData</code> type is like <code>MutableLiveData</code> except that its <code>value</code> property can’t be updated. You’ll find out how the <code>LiveData</code> type is used a few pages ahead.</p>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="What happens when the app runs"><div class="sect1" id="what_happens_when_the_app_runs-id00180">
<h1>What happens when the app runs</h1>
<p><a data-type="indexterm" data-primary="GameViewModel" data-secondary="live data with" id="idm46053737047168"/>The following things happen when the app runs:</p>
<ol>
<li><p><strong>GameFragment asks the ViewModelProvider class for an instance of GameViewModel.</strong></p>
<p>The <code>GameViewModel</code> object is initialized, and the values of its three <code>MutableLiveData</code> properties—<code>livesLeft</code>, <code>incorrectGuesses</code>, and <code>secretWordDisplay</code>—are set.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0496-02.png" alt="image" width="600" height="171"/>
<h6/>
</div></figure></li>
<li><p><strong>GameFragment observes the livesLeft, incorrectGuesses, and secretWordDisplay properties in the GameViewModel.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0496-03.png" alt="image" width="600" height="187"/>
<h6/>
</div></figure></li>
<li><p><strong>GameFragment updates its views with the values of the properties it’s observing.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0496-04.png" alt="image" width="351" height="184"/>
<h6/>
</div></figure></li>
<li><p><strong>When the user makes a correct guess, secretWordDisplay’s value is updated, and the new value is passed to GameFragment.</strong></p>
<p><code>GameFragment</code> responds by updating its <code>word</code> view, which is displayed on the screen.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0497-02.png" alt="image" width="600" height="114"/>
<h6/>
</div></figure></li>
<li><p><strong>When the user makes an incorrect guess, the values for incorrectGuesses and livesLeft are updated, and passed to GameFragment.</strong></p>
<p><code>GameFragment</code> responds by updating its views.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0497-03.png" alt="image" width="600" height="170"/>
<h6/>
</div></figure></li>
<li><p><strong>When isWon() or isLost() return true, GameFragment navigates to ResultFragment, passing it the result.</strong></p>
<p><code>ResultFragment</code> displays the result.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0497-04.png" alt="image" width="600" height="175"/>
<h6/>
</div></figure></li>
</ol>
<p>Let’s take the app for a test drive.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark=" Test Drive"><div class="sect1" id="test_drive-id00181">
<h1><span class="inlineimage"><img src="Images/car.png" alt="Images" width="119" height="58"/></span> Test Drive</h1>
<p>When we run the app, <code>GameFragment</code> is displayed as before.</p>
<p>When we make a correct guess, the secret word display gets updated. When we make an incorrect guess, the lives left is updated, and our guess is added to the incorrect guesses display.</p>
<p>If we guess all the letters or lose all our lives, the app navigates to <code>ResultFragment</code>, which displays the result.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0498-02.png" alt="image" width="600" height="548"/>
<h6/>
</div></figure>
<p>The game behaves in the same way as before, but behind the scenes, it responds using live data.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil-id00182">
<h5><span class="inlineimage"><img src="Images/pencil.png" alt="Images" width="149" height="65"/></span> Sharpen your pencil</h5>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Sharpen your pencil" id="idm46053737012224"/>The code below describes a view model named <code>MyViewModel</code>. See if you can change the code so that it uses live data to let fragments respond to the <code>rate</code> property changing.</p>
<pre data-type="programlisting">package com.hfad.myapp

import androidx.lifecycle.ViewModel
import android.util.Log

class MyViewModel : ViewModel() {
    var rate = 2

    init {
        Log.i("MyViewModel", "ViewModel created")
    }

    override fun onCleared() {
        Log.i("MyViewModel", "ViewModel cleared")
    }

    fun updateRate(newRate: Int) {
        rate = newRate
    }

    fun Calculation(val1: Int, val2: Int): Int {
        Log.i("MyViewModel", "Called Calculation")
        return (val1 + val2) * rate
    }

    fun JoinTogether(text1: String, text2: String): String {
        Log.i("MyViewModel", "Called JoinTogether")
        return ("${text1} ${text2}")
    }
}</pre>
</div></aside>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sharpen_your_pencil_solution-id00183">
<h5><span class="inlineimage"><img src="Images/pencil.png" alt="Images" width="149" height="65"/></span> Sharpen your pencil Solution</h5>
<p>The code below describes a view model named <code>MyViewModel</code>. See if you can change the code so that it uses live data to let fragments respond to the <code>rate</code> property changing.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0500-01.png" alt="image" width="600" height="707"/>
<h6/>
</div></figure>
</div></aside>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Fragments can update GameViewModel’s properties"><div class="sect1" id="fragments_can_update_gameviewmodelapostr">
<h1>Fragments can update GameViewModel’s properties</h1>
<p><a data-type="indexterm" data-primary="backing property" data-see="private properties, marking" id="idm46053736999680"/><a data-type="indexterm" data-primary="GameFragment" data-secondary="restricting properties" id="idm46053736998416"/><a data-type="indexterm" data-primary="GameViewModel" data-secondary="protecting properties" id="idm46053736997312"/><a data-type="indexterm" data-primary="Guessing Game app" data-secondary="protecting properties" id="idm46053736996208"/><a data-type="indexterm" data-primary="live data" data-secondary="protecting properties" id="idm46053736995104"/><a data-type="indexterm" data-primary="LiveData type" id="idm46053736994000"/><a data-type="indexterm" data-primary="livesLeft property, GameViewModel" data-secondary="updating value property" id="idm46053736993168"/><a data-type="indexterm" data-primary="MutableLiveData properties" id="idm46053736992096"/><a data-type="indexterm" data-primary="private properties, marking" id="idm46053736991296"/><a data-type="indexterm" data-primary="properties" data-secondary="MutableLiveData" id="idm46053736990496"/><a data-type="indexterm" data-primary="properties" data-secondary="protecting view model" id="idm46053736989392"/><a data-type="indexterm" data-primary="protecting view model properties" id="idm46053736988288"/><a data-type="indexterm" data-primary="value property, MutableLiveData" data-secondary="making private" id="idm46053736987488"/>So far, we’ve updated the code in <code>GameViewModel</code> and <code>GameFragment</code> so that it uses live data. Each time the value of a <code>MutableLiveData</code> property in <code>GameViewModel</code> gets updated, <code>GameFragment</code> responds by updating its views.</p>
<p>There’s a slight problem with the code, however. <code>GameFragment</code> has full access to <code>GameViewModel</code>’s properties and methods, so if it wanted to, it could use them inappropriately. There’s nothing to stop the fragment from, say, updating the <code>livesLeft</code> property to 100 so that the user can make many more guesses and win the game each time she plays.</p>
<p>To get around this problem, we’re going to restrict direct access to the <code>GameViewModel</code>’s properties so that <strong>only methods in the view model can update them</strong>.</p>
<blockquote>
<p><strong>You can restrict direct access to a view model’s property by marking it private, and providing read-only access via another property’s getter.</strong></p>
</blockquote>
<section data-type="sect2" data-pdf-bookmark="Keep your privates private"><div class="sect2" id="keep_your_privates_private">
<h2>Keep your privates private</h2>
<p>To protect <code>GameViewModel</code>’s properties, we’ll mark each one as <code>private</code> so that only code in <code>GameViewModel</code> can update their values. We’ll then expose a <em>read-only version</em> of each <code>MutableLiveData</code> property that <code>GameFragment</code> needs to observe. Instead of defining the <code>livesLeft</code> property using code like this:</p>
<pre data-type="programlisting">val livesLeft = MutableLiveData&lt;Int&gt;(8)</pre>
<p>we’ll use the following:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0501-01.png" alt="image" width="600" height="95"/>
<h6/>
</div></figure>
<p>Here, the <code>_livesLeft</code> property holds a reference to a <code>MutableLiveData</code> object. <code>GameFragment</code> doesn’t have access to this property because it’s marked as <code>private</code>.</p>
<p><code>GameFragment</code> can, however, access the value of this property using <code>livesLeft</code>’s getter. <code>livesLeft</code>’s type is <code><strong>LiveData</strong></code>, which is like <code>MutableLiveData</code> except that it can’t be used to update the underlying object’s <code>value</code> property: <code>GamesFragment</code> can read the value, but it can’t update it.</p>
<p>When you structure your code in this way, the private property is sometimes called a <strong>backing property</strong>. It holds a reference to an object that other classes only have access to via another property.</p>
<p>Let’s update the <code>GameViewModel</code> code.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0501-02.png" alt="image" width="414" height="366"/>
<h6/>
</div></figure>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full code for GameViewModel.kt"><div class="sect1" id="the_full_code_for_gameviewmodeld-id00184">
<h1>The full code for GameViewModel.kt</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0502-01.png" alt="image" width="312" height="87"/>
<h6/>
</div></figure>
<p>We’ll update the code for <code>GameViewModel</code> so that it uses backing properties to restrict direct access to its live data properties. We’ll also mark as private any properties and methods that <code>GameFragment</code> doesn’t need to use.</p>
<p>Here’s the full code for <em>GameViewModel.kt</em>; update the code to include our changes (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0502-02.png" alt="image" width="600" height="482"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0503-02.png" alt="image" width="600" height="663"/>
<h6/>
</div></figure>
<p>Let’s go through what happens when the code runs.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="What happens when the app runs"><div class="sect1" id="what_happens_when_the_app_runs-id00185">
<h1>What happens when the app runs</h1>
<p>The following things happen when the app runs:</p>
<ol>
<li><p><strong>GameFragment asks the ViewModelProvider class for an instance of GameViewModel.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0504-02.png" alt="image" width="600" height="121"/>
<h6/>
</div></figure></li>
<li><p><strong>GameViewModel’s properties are initialized.</strong></p>
<p><code>livesLeft</code>, <code>incorrectGuesses</code>, and <code>secretWordDisplay</code> are <code>LiveData</code> properties that refer to the same underlying objects as their <code>MutableLiveData</code> backing properties.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0504-03.png" alt="image" width="600" height="227"/>
<h6/>
</div></figure></li>
<li><p><strong>GameFragment observes the livesLeft, incorrectGuesses, and secretWordDisplay properties.</strong></p>
<p><code>GameFragment</code> can’t update any of these properties, but it responds when <code>GameViewModel</code> updates any of the backing properties because they refer to the same underlying object.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0504-04.png" alt="image" width="600" height="185"/>
<h6/>
</div></figure></li>
<li><p><strong>GameFragment continues to respond to value changes until isWon() or isLost() returns true.</strong></p>
<p><code>GameFragment</code> navigates to <code>ResultFragment</code>, passing it the result. <code>ResultFragment</code> displays the result.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0505-01.png" alt="image" width="600" height="176"/>
<h6/>
</div></figure></li>
</ol>
<p>Let’s take the app for a test drive.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark=" Test Drive"><div class="sect1" id="test_drive-id00186">
<h1><span class="inlineimage"><img src="Images/car.png" alt="Images" width="119" height="58"/></span> Test Drive</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0505-02.png" alt="image" width="313" height="87"/>
<h6/>
</div></figure>
<p>When we run the app, it works in the same way as before. This time, however, we’ve protected <code>GameViewModel</code>’s <code>MutableLiveData</code> properties by restricting <code>GameFragment</code>’s access to them.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0505-03.png" alt="image" width="600" height="353"/>
<h6/>
</div></figure>
<p>We’ve nearly finished updating the Guessing Game app. There’s just one more thing we need to change...</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="GameFragment still includes game logic"><div class="sect1" id="gamefragment_still_includes_game_logic">
<h1>GameFragment still includes game logic</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0506-01.png" alt="image" width="312" height="87"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="GameFragment" data-secondary="passing of gameOver control to GameViewModel" id="idm46053736920560"/><a data-type="indexterm" data-primary="_gameOver backing property, GameViewModel" id="idm46053736919312"/><a data-type="indexterm" data-primary="gameOver property, adding to GameViewModel" id="idm46053736918448"/><a data-type="indexterm" data-primary="GameViewModel" data-secondary="adding gameOver to" id="idm46053736917584"/><a data-type="indexterm" data-primary="Guessing Game app" data-secondary="gameOver property" id="idm46053736916480"/><a data-type="indexterm" data-primary="MutableLiveData properties" id="idm46053736915376"/><a data-type="indexterm" data-primary="properties" data-secondary="MutableLiveData" id="idm46053736914576"/><a data-type="indexterm" data-primary="ResultFragment" data-secondary="in gameOver with live data" id="idm46053736913472"/>In the current version of the app, <code>GameFragment</code> decides when the game is finished by calling <code>GameViewModel</code>’s <code>isWon()</code> and <code>isLost()</code> methods after the user has made each guess. If either of these returns <em>true</em>, <code>GameFragment</code> navigates to <code>ResultFragment</code>, passing it the result.</p>
<p>Here’s the current code:</p>
<figure class="informal"><div class="figure">
<img src="Images/f0506-02.png" alt="image" width="600" height="321"/>
<h6/>
</div></figure>
<p>The problem with this approach is that <code>GameFragment</code> decides when the game is over instead of <code>GameViewModel</code>. As determining when the game has finished is a game decision, it’s something that <code>GameViewModel</code> should be responsible for, not <code>GameFragment</code>.</p>
<section data-type="sect2" data-pdf-bookmark="Make GameViewModel decide when the game is over"><div class="sect2" id="make_gameviewmodel_decide_when_the_game">
<h2>Make GameViewModel decide when the game is over</h2>
<p>To deal with this, we’ll add a <code>MutableLiveData&lt;Boolean&gt;</code> property named <code>_gameOver</code> to <code>GameViewModel</code>, whose value we’ll expose using a <code>LiveData</code> property named <code>gameOver</code>. We’ll set this property to <em>true</em> when the user wins or loses the game. When this happens, <code>GameFragment</code> will respond by navigating to <code>ResultFragment</code>.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0506-03.png" alt="image" width="600" height="87"/>
<h6/>
</div></figure>
<p>You’re already familiar with the changes that are required to do this, so before we show you the code, try the following exercise.</p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Pool Puzzle"><div class="sect1" id="pool_puzzle-id00187">
<h1>Pool Puzzle</h1>
<figure class="informal"><div class="figure">
<img src="Images/common01.png" alt="image" width="148" height="160"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Pool Puzzle" id="idm46053736892592"/>Your <strong>goal</strong> is to add a <code>gameOver</code> property (with a <code>_gameOver</code> backing property) to <code>GameViewModel</code> so that <code>GameFragment</code> can respond when its value (a <code>Boolean</code>) gets updated. The property should be initialized with a value of <em>false</em>. Take code snippets from the pool and place them into the blank lines in the code. You may <strong>not</strong> use the same snippet more than once, and you won’t need to use all the snippets.</p>
<pre data-type="programlisting">package com.hfad.guessinggame

import androidx.lifecycle.ViewModel
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.LiveData

class GameViewModel : ViewModel() {
    ...
    ............................................................................................
    ............................................................................................
    ............................................................................................
    ...
}</pre>
<figure class="informal"><div class="figure">
<img src="Images/f0507-01.png" alt="image" width="600" height="277"/>
<h6/>
</div></figure>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><strong>Note: each thing from the pool can only be used once!</strong></p>
</div>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Pool Puzzle Solution"><div class="sect1" id="pool_puzzle_solution-id00188">
<h1>Pool Puzzle Solution</h1>
<figure class="informal"><div class="figure">
<img src="Images/common01.png" alt="image" width="148" height="160"/>
<h6/>
</div></figure>
<p>Your <strong>goal</strong> is to add a <code>gameOver</code> property (with a <code>_gameOver</code> backing property) to <code>GameViewModel</code> so that <code>GameFragment</code> can respond when its value (a <code>Boolean</code>) gets updated. The property should be initialized with a value of <em>false</em>. Take code snippets from the pool and place them into the blank lines in the code. You may <strong>not</strong> use the same snippet more than once, and you won’t need to use all the snippets.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0508-01.png" alt="image" width="600" height="261"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0508-02.png" alt="image" width="600" height="266"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="The full code for GameViewModel.kt"><div class="sect1" id="the_full_code_for_gameviewmodeld-id00189">
<h1>The full code for GameViewModel.kt</h1>
<p><a data-type="indexterm" data-primary="GameViewModel" data-secondary="code for" id="idm46053736869424"/>We need to add a <code>gameOver</code> property to <code>GameViewModel</code>, along with a <code>_gameOver</code> backing property. We’ll get the <code>makeGuess()</code> method to set it to <em>true</em> when the user has guessed all of the letters in the secret word, or run out of lives.</p>
<p>Here’s the full code for <code>GameViewModel</code>; update the code in <em>GameViewModel.kt</em> to include the changes shown below (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0509-02.png" alt="image" width="600" height="499"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0510-02.png" alt="image" width="600" height="640"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Make GameFragment observe the new property"><div class="sect1" id="make_gamefragment_observe_the_new_proper">
<h1>Make GameFragment observe the new property</h1>
<p><a data-type="indexterm" data-primary="GameFragment" data-secondary="code for" id="idm46053736858464"/><a data-type="indexterm" data-primary="GameFragment" data-secondary="passing of gameOver control to GameViewModel" id="idm46053736857040"/>Now that we’ve added the <code>gameOver</code> property to <code>GameViewModel</code>, we need to make <code>GameFragment</code> respond to when it’s been updated. We’ll make the fragment observe the property, so that when its value is changed to <em>true</em>, the fragment will navigate to <code>ResultFragment</code>.</p>
<p>Here’s the code for <code>GameFragment</code>; update the code in <em>GameFragment.kt</em> so that it includes the changes below (in bold):</p>
<figure class="informal"><div class="figure">
<img src="Images/f0511-01.png" alt="image" width="600" height="600"/>
<h6/>
</div></figure>
<figure class="informal"><div class="figure">
<img src="Images/f0512-02.png" alt="image" width="600" height="539"/>
<h6/>
</div></figure>
<p>That’s it! Let’s go through what happens when it runs.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="What happens when the app runs"><div class="sect1" id="what_happens_when_the_app_runs-id00190">
<h1>What happens when the app runs</h1>
<p>The following things happen when the app runs:</p>
<ol>
<li><p><strong>GameFragment asks the ViewModelProvider class for an instance of GameViewModel.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0513-02.png" alt="image" width="600" height="121"/>
<h6/>
</div></figure></li>
<li><p><strong>GameViewModel’s properties are initialized.</strong></p>
<p>The <code>_gameOver</code> and <code>gameOver</code> properties refer to a <code>MutableLiveData&lt;Boolean&gt;</code> object whose value is set to <em>false</em>.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0513-03.png" alt="image" width="527" height="288"/>
<h6/>
</div></figure></li>
<li><p><strong>GameFragment observes the GameViewModel’s gameOver property.</strong></p>
<p><code>GameFragment</code> can’t update the <code>MutableLiveData</code> object that the <code>gameOver</code> property refers to, but it can respond to when its value changes.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0513-04.png" alt="image" width="600" height="246"/>
<h6/>
</div></figure></li>
<li><p><strong>Each time the GameViewModel’s makeGuess() method is called, it checks whether isWon() or isLost() returns true.</strong></p>
<p>If either is <em>true</em>, it sets the value of its <code>_gameOver</code> property to <em>true</em>.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0514-02.png" alt="image" width="600" height="206"/>
<h6/>
</div></figure></li>
<li><p><strong>GameFragment observes the value has been updated to true via the GameViewModel’s gameOver property.</strong></p>
<p>The new value is passed to <code>GameFragment</code>.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0514-03.png" alt="image" width="600" height="244"/>
<h6/>
</div></figure></li>
<li><p><strong>GameFragment responds by navigating to ResultFragment, passing it the result.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0514-04.png" alt="image" width="414" height="125"/>
<h6/>
</div></figure></li>
</ol>
<p>We’ll take the app for a test drive after the following exercise.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Fragment Magnets"><div class="sect1" id="fragment_magnets">
<h1>Fragment Magnets</h1>
<figure class="informal"><div class="figure">
<img src="Images/common02.png" alt="image" width="86" height="144"/>
<h6/>
</div></figure>
<p><a data-type="indexterm" data-primary="exercises" data-secondary="Magnets" id="idm46053736819920"/><a data-type="indexterm" data-primary="fragments" data-secondary="view model" id="idm46053736818560"/>Somebody wrote the code for a fragment named <code>LotteryFragment</code> on the fridge door, but a freak kitchen blizzard blew some of the code away. Can you piece it back together again?</p>
<p>The fragment needs to observe <code>LotteryViewModel</code>’s <code>winningNumbers</code> property, which is defined like this:</p>
<pre data-type="programlisting">private val _winningNumbers = MutableLiveData&lt;String&gt;()
val winningNumbers: LiveData&lt;String&gt;
    get() = _winningNumbers</pre>
<p>When <code>winningNumbers</code> changes, <code>LotteryFragment</code> needs to update its <code>numbers</code> view with the new value.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0515-01.png" alt="image" width="600" height="457"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Fragment Magnets Solution"><div class="sect1" id="fragment_magnets_solution">
<h1>Fragment Magnets Solution</h1>
<figure class="informal"><div class="figure">
<img src="Images/common02.png" alt="image" width="86" height="144"/>
<h6/>
</div></figure>
<p>Somebody wrote the code for a fragment named <code>LotteryFragment</code> on the fridge door, but a freak kitchen blizzard blew some of the code away. Can you piece it back together again?</p>
<p>The fragment needs to observe <code>LotteryViewModel</code>’s <code>winningNumbers</code> property, which is defined like this:</p>
<pre data-type="programlisting">private val _winningNumbers = MutableLiveData&lt;String&gt;()
val winningNumbers: LiveData&lt;String&gt;
    get() = _winningNumbers</pre>
<p>When <code>winningNumbers</code> changes, <code>LotteryFragment</code> needs to update its <code>numbers</code> view with the new value.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0516-01.png" alt="image" width="600" height="462"/>
<h6/>
</div></figure>
</div></section>
<section data-type="sect1" data-pdf-bookmark=" Test Drive"><div class="sect1" id="test_drive-id00191">
<h1><span class="inlineimage"><img src="Images/car.png" alt="Images" width="119" height="58"/></span> Test Drive</h1>
<figure class="informal"><div class="figure">
<img src="Images/f0517-01.png" alt="image" width="313" height="87"/>
<h6/>
</div></figure>
<p>When we run the app, it works in the same way as before. This time, however, <code>GameViewModel</code> decides when the game is over instead of <code>GameFragment</code>. The fragment simply observes the view model’s <code>gameOver</code> property, and navigates to <code>ResultFragment</code> when it’s changed to <em>true</em>.</p>
<figure class="informal"><div class="figure">
<img src="Images/f0517-02.png" alt="image" width="600" height="547"/>
<h6/>
</div></figure>
<p>Congratulations! You’ve now built an app that uses live data to respond to changes as and when they occur. In the next chapter, we’ll build on this still further using a new technique called data binding.</p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Your Android Toolbox"><div class="sect1" id="your_android_toolbox-id00192">
<h1>Your Android Toolbox</h1>
<figure class="informal"><div class="figure">
<img src="Images/tools.png" alt="image" width="182" height="129"/>
<h6/>
</div></figure>
<p><strong>You’ve got <a data-type="xref" href="#live_datacolon_leaping_into_action">Chapter 12</a> under your belt and now you’ve added live data to your toolbox.</strong></p>
<figure class="informal"><div class="figure">
<img src="Images/f0518-01.png" alt="image" width="233" height="210"/>
<h6/>
</div></figure>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="bullet_points-id00193">
<h5>Bullet Points</h5>
<ul>
<li><p>Live data lets the view model’s properties tell interested parties (such as fragments and activities) when its values have changed.</p></li>
<li><p>To make a property use live data, define the property using <code>val</code>, and change its type to <code>MutableLiveData&lt;Type&gt;</code> where <code>Type</code> is the type of data the property needs to hold.</p></li>
<li><p>The <code>MutableLiveData</code> object’s <code>value</code> property is used to hold its value. This property is nullable.</p></li>
<li><p>You make a fragment or activity respond to changes in the view model by calling the property’s <code>observe</code> method and specifying how the new value should be used.</p></li>
<li><p>You can restrict direct access to a view model’s properties using backing properties.</p></li>
<li><p>The <code>LiveData</code> type is like <code>MutableLiveData</code> except that it’s immutable. It’s used to expose a <code>MutableLiveData</code> object’s value while preventing it from being updated.</p></li>
</ul>
</div></aside>
</div></section>
</div></section></div></body></html>