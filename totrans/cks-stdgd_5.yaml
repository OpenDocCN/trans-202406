- en: Chapter 5\. Minimizing Microservice Vulnerabilities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application stacks operated in a Kubernetes cluster often follow a microservices
    architecture. The domain “minimize microservice vulnerabilities” covers governance
    and enforcement of security settings on the Pod level. We’ll touch on Kubernetes
    core features, as well as external tooling, that help with minimizing security
    vulnerabilities. Additionally, we’ll also talk about encrypted network communication
    between Pods running microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up appropriate OS-level security domains with security contexts, Pod
    Security Admission (PSA), and Open Policy Agent Gatekeeper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using container runtime sandboxes, such as gVisor and Kata Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing Pod-to-Pod communication encryption via mutual Transport Layer
    Security (TLS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting Appropriate OS-Level Security Domains
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both core Kubernetes and the Kubernetes ecosystem offer solutions for defining,
    enforcing, and governing security settings on the Pod and container level. This
    section will discuss security contexts, Pod Security Admission, and Open Policy
    Agent Gatekeeper. You will learn how to apply each of the features and tools using
    examples that demonstrate their importance to security. Let’s begin by setting
    up a scenario.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Misuses root User Container Access'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, containers run with root privileges. A vulnerability in the application
    could grant an attacker `root` access to the container. The container’s root user
    is the same as the root user on the host machine. Not only can the attacker then
    inspect or modify the application, but they can also potentially install additional
    tooling that allows the attacker to break out of the container and step into host
    namespace with `root` permissions. The attacker could also copy sensitive data
    from the host’s filesystem to the container. [Figure 5-1](#root-user-attacker)
    illustrates the scenario.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0501](assets/ckss_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. An attacker misuses root user container access
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For that reason, running a container with the default root user is a bad idea.
    The next sections will explain how to declare a security context for the container
    that enforces the use of a non-root user or a specific user and/or group identifier.
    We’ll also discuss other security context settings relevant to shielding host
    access from the container.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Security Contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes, as the container orchestration engine, can apply additional configuration
    to increase container security. You do so by defining a security context. A security
    context defines privilege and access control settings for a Pod or a container.
    The following list provides some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: The user ID that should be used to run the Pod and/or container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The group ID that should be used for filesystem access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting a running process inside the container some privileges of the root
    user but not all of them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The security context is not a Kubernetes primitive. It is modeled as a set of
    attributes under the directive `securityContext` within the Pod specification.
    Security settings defined on the Pod level apply to all containers running in
    the Pod; however, container-level settings take precedence. For more information
    on Pod-level security attributes, see the [PodSecurityContext API](https://oreil.ly/cJWXA).
    Container-level security attributes can be found in the [SecurityContext API](https://oreil.ly/XOy2a).
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing the Usage of a Non-Root User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll have a look at a use case to make the functionality more transparent.
    Some images, like the one for the open source reverse-proxy server nginx, must
    be run with the `root` user. Say you wanted to enforce that containers cannot
    be run as the `root` user as a means to support a more sensible security strategy.
    The YAML manifest file `container-non-root-user-error.yaml` shown in [Example 5-1](#non-root-security-context-error)
    defines the security configuration specifically for a container. This security
    context only applies to this very container, but not others if you were to define
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-1\. Enforcing a non-root user on an image that needs to run with the
    root user
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The container fails during the startup process with the status `CreateContainer​Confi⁠gError`.
    A look at the Pod’s event log reveals that the image tries to run with the `root`
    user. The configured security context does not allow it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are alternative nginx container images available that are not required
    to run with the `root` user. An example is [bitnami/nginx](https://oreil.ly/EnvzT).
    [Example 5-2](#non-root-security-context-success) shows the contents of the file
    `container-non-root-user-success.yaml`. The major change in this file is the value
    assigned to the `spec.containers[].image` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-2\. Enforcing a non-root user on an image that supports running with
    a user ID
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting the container with the `runAsNonRoot` directive will work just fine.
    The container transitions into the “Running” status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s quickly check which user ID the container runs with. Shell into the container
    and run the `id` command. The output renders the user ID, the group ID, and the
    IDs of supplemental groups. The image `bitnami/nginx` sets the user ID to 1001
    with the help of an instruction when the container image is built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting a Specific User and Group ID
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many container images do not set an explicit user ID or group ID. Instead of
    running with the `root` default user, you can set the desired user ID and group
    ID to minimize potential security risks. The YAML manifest stored in the file
    `container-user-id.yaml` shown in [Example 5-3](#user-group-id-security-context-success)
    sets the user ID to 1000 and the group ID to 3000.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-3\. Running the container with a specific user and group ID
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the Pod will work without issues. The container transitions into the
    “Running” status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can inspect the user ID and group ID after shelling into the container.
    The current user is not allowed to create files in the `/` directory. Creating
    a file in the `/tmp` directory will work, as most users have the permissions to
    write to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding Privileged Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes establishes a clear separation between the container namespace and
    the host namespace for processes, network, mounts, user ID, and more. You can
    configure the container’s security context to gain privileges to certain aspects
    of the host namespace. Assume the following implications when using a privileged
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: Processes within a container almost have the same privileges as processes on
    the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container has access to all devices on the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The root user in the container has similar privileges to the `root` user on
    the host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All directories on the host’s filesystem can be mounted in the container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kernel settings can be changed, e.g., by using the [`sysctl` command](https://oreil.ly/YEcOs).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using containers in privileged mode
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuring a container to use privileged mode should be a rare occasion. Most
    applications and processes running in a container do not need elevated privileges
    beyond the container namespace. Should you encounter a Pod that has been configured
    to use privileged mode, contact the team or developer in charge to clarify, as
    it will open a loophole for attackers to gain access to the host system.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s compare the behavior of a non-privileged container with one configured
    to run in privileged mode. First, we are going to set up a regular Pod, as shown
    in [Example 5-4](#non-privileged-container). No security context has been set
    on the Pod or container level.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-4\. A Pod with a container in non-privileged mode
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Pod and ensure that it comes up properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To demonstrate the isolation between the container namespace and host’s namespace,
    we’ll try to use the `sysctl` to change the hostname. As you can see in the output
    of the command, the container will clearly enforce the restricted privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To make a container privileged, simply assign the value `true` to the security
    context attribute `privileged`. The YAML manifest in [Example 5-5](#privileged-security-context)
    shows an example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-5\. A Pod with a container configured to run in privileged mode
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the Pod as usual. The Pod should transition into the “Running” status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now see that the same `sysctl` will allow you to change the hostname:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A container security context configuration related to privileged mode is the
    attribute `allowPrivilegeEscalation`. This attribute will allow a process running
    the container to gain more privileges than the parent process. The default value
    for the attribute is `false`, but if you see the attribute set to `true`, critically
    question its use. In most cases, you do not need the functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: A Developer Doesn’t Follow Pod Security Best Practices'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is unfair to assume that developers of all trades and levels of seniority
    have extensive knowledge of Kubernetes features, especially the ones that apply
    to security best practices. In the previous section, we learned about the security
    context and which settings to avoid. Developers are probably unaware of those
    best practices without continued education and therefore may create Pods that
    use problematic security settings or none at all. [Figure 5-2](#privileged-mode-attacker)
    shows a developer creating a Pod in privileged mode enabled by a copied manifest
    found on the internet. An attacker will gladly use this setup to their advantage.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0502](assets/ckss_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. A developer creates a Pod with enabled privileged mode
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This is where you, as the Kubernetes security specialist, come in. The Kubernetes
    ecosystem provides core features and external tooling for enforcing security standards
    for Pods so that objects without the right configuration will be rejected, or
    at least audited. The next section explores the Kubernetes core feature named
    Pod Security Admission.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Pod Security Admission (PSA)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Older versions of Kubernetes shipped with a feature called Pod Security Policies
    (PSP). Pod Security Policies are a concept that help with enforcing security standards
    for Pod objects. Kubernetes 1.21 deprecated Pod Security Policies and introduced
    the replacement functionality Pod Security Admission. PSA determines which Pod
    Security Standard (PSS) to follow. A PSS defines a range of security policies
    from highly restrictive to highly permissive.
  prefs: []
  type: TYPE_NORMAL
- en: However, the Kubernetes release 1.25 completely removed Pod Security Policies.
    You may still see the feature listed in older versions of the CKS curriculum.
    We will only focus on Pod Security Admission in this book. PSA is enabled by default
    with Kubernetes 1.23; however, you will need to declare which Pods should adhere
    to the security standards. All you need to do to opt into the PSA feature is to
    add a label with a specific format to a namespace. All Pods in that namespace
    will have to follow the standards declared.
  prefs: []
  type: TYPE_NORMAL
- en: 'The label consists of three parts: a prefix, a mode, and a level. The *prefix*
    always uses the hard-coded value `pod-security.kubernetes.io` followed by a slash.
    The *mode* determines the handling of a violation. Finally, the *level* dictates
    the degree of security standards to adhere to. An example of such a label could
    look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The mode allows for setting three different options, shown in [Table 5-1](#psa-modes).
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Pod Security Admission modes
  prefs: []
  type: TYPE_NORMAL
- en: '| Mode | Behavior |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `enforce` | Violations will cause the Pod to be rejected. |'
  prefs: []
  type: TYPE_TB
- en: '| `audit` | Pod creation will be allowed. Violations will be appended to the
    audit log. |'
  prefs: []
  type: TYPE_TB
- en: '| `warn` | Pod creation will be allowed. Violations will be rendered on the
    console. |'
  prefs: []
  type: TYPE_TB
- en: '[Table 5-2](#psa-levels) illustrates the security policies determined by the
    level set for the PSA.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Pod Security Admission levels
  prefs: []
  type: TYPE_NORMAL
- en: '| Level | Behavior |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `privileged` | Fully unrestricted policy. |'
  prefs: []
  type: TYPE_TB
- en: '| `baseline` | Minimally restrictive policy that covers crucial standards.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `restricted` | Heavily restricted policy following best practices for hardening
    Pods from a security perspective. |'
  prefs: []
  type: TYPE_TB
- en: See the [Kubernetes documentation](https://oreil.ly/DYziy) for details on the
    PSA, including usage examples.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing Pod Security Standards for a Namespace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s apply a PSA to a Pod in the namespace `psa`. [Example 5-6](#psa-namespace-label)
    shows the definition of the namespace and the declaration of the relevant label.
    The label will enforce a PSS on the highest level of security standards.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-6\. A namespace enforcing the highest level of security standards
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Make sure that the Pod is created in the namespace `psa`. [Example 5-7](#psa-violating-pod)
    shows the YAML manifest for a simple Pod running the `busybox` image.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-7\. A Pod violating the PSA restrictions
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Violations will be rendered in the console upon running a command to create
    a Pod in the namespace. As you can see in the following, the Pod wasn’t allowed
    to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You need to configure the Pod’s security context settings to follow the very
    restrictive standards. [Example 5-8](#psa-non-violating-pod) shows an exemplary
    Pod definition that does not violate the Pod Security Standard.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-8\. A Pod following the PSS
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Creating the Pod object now works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: PSA is a built-in, enabled-by-default feature in Kubernetes version 1.23 or
    higher. It’s easy to adopt, allows for picking and choosing a suitable policy
    standard, and can be configured to enforce or just log violations.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, PSA only applies to Pods with a predescribed set of policies.
    You cannot write your own custom rules, change the messaging, or mutate the Pod
    object should it not adhere to a PSS. In the next section, we are going to have
    a look at tooling that goes beyond the functionality of PSA.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Open Policy Agent (OPA) and Gatekeeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Open Policy Agent (OPA)](https://oreil.ly/oK9pI) is an open source, general-purpose
    policy engine for enforcing rules. OPA is not specific to Kubernetes and can be
    used across other technology stacks. One of its benefits is the ability to define
    a policy in a very flexible fashion. You can write your own rules with the help
    of the query language named [Rego](https://oreil.ly/0_mA8). The validation logic
    written in Rego determines if the object is accepted or denied.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Gatekeeper](https://oreil.ly/AyVjP) is an extension to Kubernetes that uses
    OPA. Gatekeeper allows for defining and enforcing custom policies for any kind
    of Kubernetes API primitive. Therefore, it is far more versatile than PSA but
    requires more intricate knowledge on how to craft those rules. Gatekeeper gets
    involved in the *admission control* stage discussed in [“Processing a Request”](ch03.xhtml#processing-api-request).
    The following list of policies tries to give you an impression on what’s possible
    with Gatekeeper:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that all Service objects need to define a label with the key `team`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that all container images defined by Pods need to be pulled from a
    company-internal registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that Deployments need to control at least three replicas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, Gatekeeper allows for enforcing policies by rejecting
    object creation if requirements haven’t been met. Future versions of Gatekeeper
    might also provide a mechanism for mutating an object upon creation. For example,
    you may want to add specific label key-value pairs for any object created. The
    mutation would take care of adding those labels automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Gatekeeper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Installing Gatekeeper is relatively easy. All you need to do is to create a
    bunch of Kubernetes objects from a YAML manifest provided by the Gatekeeper project.
    You need to have cluster admin permissions to properly install Gatekeeper. The
    following command shows the `kubectl` command used to apply the latest release.
    For more information, see the [installation manual](https://oreil.ly/CyZ1c):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Gatekeeper objects have been installed in the namespace `gatekeeper-system`.
    Make sure that all Pods in the namespace transition into the “Running” status
    before trying to use Gatekeeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Implementing an OPA Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll use a specific use case as an example to demonstrate the moving parts
    required to define a custom OPA policy. [“Using Network Policies to Restrict Pod-to-Pod
    Communication”](ch02.xhtml#network-policies) explained how to assign a label to
    a namespace so that it can be selected from a network policy. At its core, our
    custom OPA policy will determine that namespaces need to define at least one label
    with the key `app` to signify the application hosted by the namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Gatekeeper requires us to implement two components for custom policy, the *constraint
    template* and the *constraint*. In a nutshell, the constraint template defines
    the rules with Rego and describes the schema for the constraint. [Example 5-9](#opa-constraint-template)
    shows a constraint template definition for enforcing a label assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-9\. An OPA constraint template requiring the definition of at least
    a single label
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_minimizing_microservice_vulnerabilities_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Declares the kind to be used by the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_minimizing_microservice_vulnerabilities_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Specifies the validation schema of the constraint. In this case, we allow to
    pass in a property named `labels` that captures the required label keys.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_minimizing_microservice_vulnerabilities_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses Rego to check for the existence of labels and compares them to the list
    of required keys.
  prefs: []
  type: TYPE_NORMAL
- en: The constraint is essentially an implementation of the constraint template.
    It uses the kind defined by the constraint template and populates the data provided
    by the end user. In [Example 5-10](#opa-constraint), the kind is `K8sRequiredLabels`,
    which we defined in the constraint template. We are matching on namespaces and
    expect them to define the label with the key `app`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-10\. An OPA constraint that defines the “data” for the policy
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_minimizing_microservice_vulnerabilities_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Uses the kind defined by the constraint template.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_minimizing_microservice_vulnerabilities_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the API resources the constraint template should apply to.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_minimizing_microservice_vulnerabilities_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Declares that the `labels` property expects the key `app` to exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the relevant YAML manifests in place, let’s create the objects for the
    constraint template and the constraint. Assume that the constraint template was
    written to the file `constraint-template-labels.yaml` and the constraint to the
    file `constraint-ns-labels.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify the validation behavior with a quick-to-run imperative command.
    The following command tries to create a new namespace without a label assignment.
    Gatekeeper will render an error message and prevent the creation of the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Let’s make sure that we can actually create a namespace with the expected label
    assignment. [Example 5-11](#namespace-app-label) shows the YAML manifest of such
    a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-11\. YAML manifest for namespace with a label assignment
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The following command creates the object from the YAML manifest file named
    `namespace-app-label.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This simple example demonstrated the usage of OPA Gatekeeper. You can find a
    lot of other examples in the [OPA Gatekeeper Library](https://oreil.ly/1VV5e).
    Despite it not being spelled out explicitly in the CKS curriculum, you may also
    want to check out the project [Kyverno](https://kyverno.io), which recently gained
    a lot of traction with the Kubernetes community.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No discussion on security features in Kubernetes would be complete without bringing
    up the topic of Secrets. I would assume that you are already well familiar with
    the API primitive Secret to define sensitive data and the different options for
    consuming it in a Pod. Given that this topic is already part of the CKA exam,
    I will not reiterate it here. For more information, see the relevant section in
    the [*Certified Kubernetes Administrator (CKA) Study Guide*](https://oreil.ly/cka-study-guide)
    or the [Kubernetes documentation](https://oreil.ly/1afoc). I talk about security
    aspects when consuming ConfigMaps and Secrets in a container in [“Configuring
    a Container with a ConfigMap or Secret”](ch07.xhtml#configuring-container-configmap-secret).
  prefs: []
  type: TYPE_NORMAL
- en: The CKS exam puts a stronger emphasis on more specialized aspects of Secret
    management. One of those scenarios, which we already touched on, was the handling
    of a Secret you can assign to a service account. Revisit [“Creating a Secret for
    a service account”](ch03.xhtml#creating-secret-serviceaccount) to refresh your
    memory on the topic. As we are not going to discuss all built-in Secret types
    here, you may want to read up on their purpose and creation in the relevant section
    of the [Kubernetes documentation](https://oreil.ly/YU7Yy).
  prefs: []
  type: TYPE_NORMAL
- en: The central location for storing Secrets key-value pairs is etcd. Let’s have
    a look at potential issues that may arise if an attacker gains access to Kubernetes
    backing store for cluster data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Gains Access to the Node Running etcd'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Where etcd runs is dependent on the [topology of your Kubernetes cluster](https://oreil.ly/bf5Gt).
    For the purpose of this scenario, we’ll assume that etcd runs on the control plane
    node. Any data stored in etcd exists in unencrypted form, so access to the control
    plane node allows for reading Secrets in plain text. [Figure 5-3](#etcd-attacker)
    shows an attacker gaining access to the control plane node and therefore the unencrypted
    Secrets in etcd.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0503](assets/ckss_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. An attacker gains access to etcd to read Secrets
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: One way to mitigate the situation is by encrypting the data stored in etcd.
    Access to etcd, either using `etcdctl` or by reading the etcd data from the filesystem,
    would not expose human-readable, sensitive information anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing etcd Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start by showing how an attacker could read etcd data after being able
    to log into the control plane node. First, we need to create a Secret object to
    store in etcd. Use the following imperative command to create an entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We created a Secret with the key-value pair `password=passwd123`. Shell into
    the control plane node using SSH. You can easily use the etcd client tool `etcdctl`
    to read an entry from etcd.
  prefs: []
  type: TYPE_NORMAL
- en: Using the etcd client tool etcdctl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s very likely that you do not have `etcdctl` installed on the control plane
    node yet. Follow the [installation manual](https://oreil.ly/wpCkO) to make the
    tool available. On Debian Linux, it can be installed with `sudo apt install etcd-client`.
    To authenticate against etcd, you will need to provide the mandatory command line
    options `--cacert`, `--cert`, and `--key`. You can find the corresponding values
    in the configuration file for the API server usually available at `/etc/kubernetes/manifests/kube-apiserver.yaml`.
    The parameters need to start with the prefix `--etcd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command uses the mandatory CLI options to read the contents from
    the Secret object named `app-config`. The following output displays the file contents
    in hexadecimal format. While not 100% obvious, you can still identify the key-value
    pair in plain text from the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the next step, we’ll encrypt the Secret stored in etcd and then verify the
    existing entries with the same command.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting etcd Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can control how API data is encrypted in etcd with the help of the command
    line option `--encryption-provider-config` provided to the API server process.
    The value assigned to the parameter needs to point to a configuration file that
    defines an `EncryptionConfiguration` object. We’ll first create the configuration
    file and then configure the API server process to consume it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Generate a 32-byte random key and base64-encode it. The value is needed to
    configure a so-called provider in the encryption configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we’ll use the base64-encoded key and assign it to a provider in the
    encryption configuration, as shown in [Example 5-12](#encryption-configuration).
    Save the contents in the file `/etc/kubernetes/enc/enc.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-12\. YAML manifest for encryption configuration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_minimizing_microservice_vulnerabilities_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Defines the API resource to be encrypted in etcd. We are only encrypting Secrets
    data here.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_minimizing_microservice_vulnerabilities_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The base64-encoded key assigned to an AES-CBC encryption provider.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the manifest at `/etc/kubernetes/manifests/kube-apiserver.yaml`, the YAML
    manifest that defines how to run an API server in a Pod. Add the parameter `--encryption-provider-config`,
    and define the Volume and its mountpath for the configuration file as the following
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The Pod running the API server should automatically restart. This process may
    take a couple of minutes. Once fully restarted, you should be able to query for
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'New Secrets will be encrypted automatically. Existing Secrets need to be updated.
    You can run the following command to perform an update on Secrets across all namespaces.
    This includes the Secret named `app-config` in the `default` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the `etcdctl` command we used before will reveal that the `aescbc`
    provider has been used to encrypt the data. The password value cannot be read
    in plain text anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: For more details on encrypting etcd data, refer to the [Kubernetes documentation](https://oreil.ly/uIylK).
    There, you will find additional information on other encryption providers, how
    to rotate the decryption key, and the process to consider for a high-availability
    (HA) cluster setup.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Container Runtime Sandboxes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers run in a container runtime isolated from the host environment. The
    process or application running in the container can interact with the kernel by
    making syscalls. Now, we can have multiple containers (as controlled by Pods)
    running on a single Kubernetes cluster node and therefore the same kernel. Under
    certain conditions, vulnerabilities can lead to a situation where a process running
    a container can “break out” of its isolated environment and access another container
    running on the same host machine. A *container runtime sandbox* runs side-by-side
    with the regular container runtime but adds an additional layer of security by
    tightening process isolation.
  prefs: []
  type: TYPE_NORMAL
- en: There are a couple of use cases where using a container runtime sandbox may
    make sense. For example, your Kubernetes cluster handles the workload of different
    customers with the same infrastructure, a so-called multi-tenant environment.
    Another reason for wanting to rely on stronger container isolation is that you
    may not trust the process or application running in a container image, as should
    be the case if you pulled the container image from a public registry and you can’t
    verify the creator or its runtime behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Gains Access to Another Container'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this scenario, we are confronted with a developer that pulls a container
    image from a public registry, as referenced by a Pod. The container has not been
    scanned for security vulnerabilities. An attacker can push a new tag of the container
    image executing malicious code. After instantiating a container from the image,
    the malicious code running in the kernel group of container 1 can access the process
    running in container 2\. As you can see in [Figure 5-4](#container-runtime-attacker),
    both containers use the same kernel of the host system.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0504](assets/ckss_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. An attacker gains access to another container
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Generally speaking, it’s not a good idea to blindly trust public container images.
    One way to ensure that such a container image runs with more isolation is the
    container runtime sandbox. The next section will introduce you to two implementations,
    both of which are explicitly mentioned by the curriculum.
  prefs: []
  type: TYPE_NORMAL
- en: Available Container Runtime Sandbox Implementations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this book, we’ll only want to talk about two container runtime sandbox implementations,
    [Kata Containers](https://katacontainers.io) and [gVisor](https://gvisor.dev).
    Kata containers achieves container isolation by running them in a lightweight
    virtual machine. gVisor takes a different approach. It effectively implements
    a Linux kernel that runs on the host system. Therefore, syscalls are not shared
    anymore across all containers on the host system.
  prefs: []
  type: TYPE_NORMAL
- en: 'A deeper discussion on the feature sets or specific use cases for those container
    runtime sandbox implementations goes beyond the scope of this book. We’ll simply
    learn how to use one solution as an example, gVisor, and how to tie it into Kubernetes.
    Have a look at the talk [“Kata Containers and gVisor: a Quantitative Comparison”](https://oreil.ly/PBfEn)
    for an in-depth comparison.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing and Configuring gVisor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following [instructions](https://oreil.ly/MlSET) describe the steps required
    to install gVisor on Linux using the `apt` package manager. You will want to repeat
    those steps on all host machines declared as worker nodes. For the exam, you will
    not be expected to install gVisor or Kata Containers. You can assume that the
    container runtime sandbox has already been installed and configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the dependencies for gVisor with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, configure the key used to sign archives and the repository. As you can
    see in the following commands, gVisor is hosted on Google storage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'gVisor includes an Open Container Initiative (OCI) runtime called runsc. The
    runsc runtime integrates with tools like Docker and Kubernetes to run container
    runtime sandboxes. The following command installs the executable from the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume we are using containerd as the container runtime. You need to
    add some configuration to containerd to make it aware of runsc. You can find similar
    instructions for other container runtimes in the gVisor documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, restart containerd to let the changes take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We successfully installed gVisor and can now configure Pods to use it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and Using a Runtime Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s a two-step approach to use a container runtime sandbox in a Pod. First,
    you need to create a runtime class. A RuntimeClass is a Kubernetes API resource
    that defines the configuration of the container runtime. [Example 5-13](#gvisor-runtimeclass)
    shows a YAML manifest of a container runtime that points to runsc as the handler
    we set in the containerd configuration file earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-13\. YAML manifest for defining a runtime class using runsc handler
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can now reference the runtime class name, `gvisor`, in the configuration
    of a Pod. [Example 5-14](#nginx-pod-gvisor) shows a Pod definition that assigns
    the runtime class using the attribute `spec.runtimeClassName`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 5-14\. YAML manifest for a Pod using a runtime class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the runtime class and Pod object using the `apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that the container is running with the container runtime sandbox.
    Simply execute the `dmesg` command to examine the kernel ring buffer. The output
    from the command should mention gVisor, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Pod-to-Pod Encryption with mTLS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [“Using Network Policies to Restrict Pod-to-Pod Communication”](ch02.xhtml#network-policies),
    we talked about Pod-to-Pod communication. One of the big takeaways was that every
    Pod can talk to any other Pod by targeting its virtual IP address unless you put
    a more restrictive network policy in place. The communication between two Pods
    is unencrypted by default.
  prefs: []
  type: TYPE_NORMAL
- en: TLS provides encryption for network communication, often in conjunction with
    the HTTP protocol. That’s when we talk about using the HTTPS protocol for calls
    to web pages from the browser. As part of the authentication process, the client
    offers its client certificate to the server for proving its identity. The server
    does not authenticate the client, though.
  prefs: []
  type: TYPE_NORMAL
- en: When loading a web page, the identity of the client, in this case the browser,
    usually doesn’t matter. The important part is that the web page proves its identity.
    Mutual TLS (mTLS) is like TLS, but both sides have to authenticate. This approach
    has the following benefits. First, you achieve secure communication through encryption.
    Second, you can verify the client identity. An attacker cannot easily impersonate
    another Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scenario: An Attacker Listens to the Communication Between Two Pods'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An attacker can use the default, unencrypted Pod-to-Pod network communication
    behavior to their advantage. As you can see in [Figure 5-5](#pod-communication-attacker),
    an attacker doesn’t even need to break into a Pod. They can simply listen to the
    Pod-to-Pod communication by impersonating the sending or the receiving side, extract
    sensitive information, and then use it for more advanced attack vectors.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckss 0505](assets/ckss_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. An attacker listens to Pod-to-Pod communication
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can mitigate the situation by setting up mTLS. The next section will briefly
    touch on the options for making that happen.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting mTLS in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The tricky part about implementing mTLS in a Kubernetes cluster is the management
    of certificates. As you can imagine, we’ll have to deal with a lot of certificates
    when implementing a microservices architecture. Those certificates are usually
    generated by an official certificate authority (CA) to ensure that they can be
    trusted. Requesting a certificate involves sending a certificate signing request
    (CSR) to the CA. If the CA approves the request, it creates the certificate, then
    signs and returns it. It’s recommended to assign short lifespans to a certificate
    before it needs to be re-issued again. That process is called certificate rotation.
  prefs: []
  type: TYPE_NORMAL
- en: It’s somewhat unclear to what degree of detail the CKS exam requires you to
    understand mTLS. The general process of requesting and approving a certificate
    is described in the [Kubernetes documentation](https://oreil.ly/QvtEQ).
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, Kubernetes administrators rely on a Kubernetes service mesh to
    implement mTLS instead of implementing it manually. A Kubernetes service mesh,
    such as Linkerd or Istio, is a tool for adding cross-cutting functionality to
    your cluster, like observability and security.
  prefs: []
  type: TYPE_NORMAL
- en: Another option is to use transparent encryption to ensure that traffic doesn’t
    go on the wire unencrypted. Some of the popular CNI plugins, such as [Calico](https://oreil.ly/XZSpx)
    and [Cilium](https://oreil.ly/Qsqq_), have added support for [WireGuard](https://www.wireguard.com).
    WireGuard is an open source, lightweight, and secure Virtual Private Network (VPN)
    solution that doesn’t require the configuration or management of encryption keys
    or certificates. Many teams prefer WireGuard over a service mesh as it is easier
    to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Services meshes and WireGuard are out of scope for the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s important to enforce security best practices for Pods. In this chapter,
    we reviewed different options. We looked at security contexts and how they can
    be defined on the Pod and container level. For example, we can configure a security
    context for a container to run with a non-root user and prevent the use of privileged
    mode. It’s usually the responsibility of a developer to define those settings.
    The Pod Security Admission is a Kubernetes feature that takes Pod security settings
    one step further. You can centrally configure a Pod such that it needs to adhere
    to certain security standards. The configured security standard can either be
    enforced, audited, or just logged to standard output. Gatekeeper is an open source
    project that implements the functionality of the Open Policy Agent for Kubernetes.
    Not only can you govern the configuration for Pod objects, you can also apply
    policies to other kinds of objects during creation time.
  prefs: []
  type: TYPE_NORMAL
- en: Key-value pairs defined by Secrets are stored in etcd in plain text. You should
    configure encryption for etcd to ensure that attackers cannot read sensitive data
    from it. To enable encryption, create a YAML manifest for an EncryptionConfiguration,
    which you would then pass to the API server process with the command line option
    `--encryption-provider-config`.
  prefs: []
  type: TYPE_NORMAL
- en: Container runtime sandboxes help with isolating processes and applications to
    a stronger degree than the regular container runtime. The projects Kata Containers
    and gVisor are implementations of such a container runtime sandbox and can be
    installed and configured to work with Kubernetes. We tried gVisor. After installing
    and configuring gVisor, you will need to create a RuntimeClass object that points
    to runsc. In the Pod configuration, point to the RuntimeClass object by name.
  prefs: []
  type: TYPE_NORMAL
- en: Pod-to-Pod communication is unencrypted and unauthenticated by default. Mutual
    TLS makes the process more secure. Pods communicating with one another need to
    provide certificates to prove their identity. Implementing mTLS for a cluster
    with hundreds of microservices is a tedious task. Each Pod running a microservice
    needs to employ an approved certificate from a Client Authority. Services meshes
    help with adding mTLS as a feature to a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practice the use of core Kubernetes features and external tools to govern security
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: In the course of this chapter, we looked at OS-level security settings and how
    to govern them with different core features and external tooling. You need to
    understand the different options, their benefits and limitations, and be able
    to apply them to implement contextual requirements. Practice the use of security
    contexts, Pod Security Admission, and Open Policy Agent Gatekeeper. The Kubernetes
    ecosystem offers more tooling in this space. Feel free to explore those on your
    own to expand your horizon.
  prefs: []
  type: TYPE_NORMAL
- en: Understand how etcd manages Secrets data.
  prefs: []
  type: TYPE_NORMAL
- en: The CKA exam already covers the workflow of creating and using Secrets to inject
    sensitive configuration data into Pods. I am assuming that you already know how
    to do this. Every Secret key-value pair is stored in etcd. Expand your knowledge
    of Secret management by learning how to encrypt etcd so that an attacker with
    access to a host running etcd isn’t able to read information in plain text.
  prefs: []
  type: TYPE_NORMAL
- en: Know how to configure the use of a container runtime sandbox.
  prefs: []
  type: TYPE_NORMAL
- en: Container runtime sandboxes help with adding stricter isolation to containers.
    You will not be expected to install a container runtime sandbox, such as Kata
    Containers or gVisor. You do need to understand the process for configuring a
    container runtime sandbox with the help of a RuntimeClass object and how to assign
    the RuntimeClass to a Pod by name.
  prefs: []
  type: TYPE_NORMAL
- en: Gain awareness of mTLS.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up mTLS for all microservices running in a Pod can be extremely tedious
    due to certificate management. For the exam, understand the general use case for
    wanting to set up mTLS for Pod-to-Pod communication. You are likely not expected
    to actually implement it manually, though. Production Kubernetes clusters use
    services meshes to provide mTLS as a feature.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Pod named `busybox-security-context` with the container image `busybox:1.28`
    that runs the command `sh -c sleep 1h`. Add a Volume of type `emptydir` and mount
    it to the path `/data/test`. Configure a security context with the following attributes:
    `runAsUser: 1000`, `runAsGroup: 3000`, and `fsGroup: 2000`. Furthermore, set the
    attribute `allowPrivilegeEscalation` to `false`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Shell into the container, navigate to the directory `/data/test`, and create
    the file named `hello.txt`. Check the group assigned to the file. What’s the value?
    Exit out of the container.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Pod Security Admission (PSA) rule. In the namespace called `audited`,
    create a Pod Security Standard (PSS) with the level `baseline` that should be
    rendered to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to create a Pod in the namespace that violates the PSS and produces a message
    on the console log. You can provide any name, container image, and security configuration
    you like. Will the Pod be created? What PSA level needs to be configured to prevent
    the creation of the Pod?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Install Gatekeeper on your cluster. Create a Gatekeeper ConstraintTemplate object
    that defines the minimum and maximum number of replicas controlled by a ReplicaSet.
    Instantiate a Constraint object that uses the ConstraintTemplate. Set the minimum
    number of replicas to 3 and the maximum number to 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Deployment object that sets the number of replicas to 15\. Gatekeeper
    should not allow the Deployment, ReplicaSet, and Pods to be created. An error
    message should be rendered. Try again to create the Deployment object but with
    a replica number of 7\. Verify that all objects have been created successfully.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Configure encryption for etcd using the `aescbc` provider. Create a new Secret
    object of type `Opaque`. Provide the key-value pair `api-key=YZvkiWUkycvspyGHk3fQRAkt`.
    Query for the value of the Secret using etcdctl. What’s the encrypted value?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the directory *app-a/ch05/gvisor* of the checked-out GitHub repository
    [*bmuschko/cks-study-guide*](https://oreil.ly/sImXZ). Start up the VMs running
    the cluster using the command `vagrant up`. The cluster consists of a single control
    plane node named `kube-control-plane` and one worker node named `kube-worker-1`.
    Once done, shut down the cluster using `vagrant destroy -f`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: gVisor has been installed in the VM `kube-worker-1`. Shell into the VM and create
    a RuntimeClass object named `container-runtime-sandbox` with runsc as the handler.
    Then create a Pod with the name `nginx` and the container image `nginx:1.23.2`
    and assign the RuntimeClass to it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Prerequisite:* This exercise requires the installation of the tools [Vagrant](https://oreil.ly/FiyeH)
    and [VirtualBox](https://oreil.ly/WW8IK).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
