- en: Chapter 19\. And Yet, We Persisted
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we take stock of where we are with our app so far, it’s come along quite
    nicely. We’ve got some solid functionality. The data being pulled is backed by
    a portable format, specifically JSON, and it’s functionally sound. This is a great
    starting place to take our app further.
  prefs: []
  type: TYPE_NORMAL
- en: Detailing Our Books
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we should add a new screen to show some more information on a book. Right
    now, there really isn’t a way to view anything of importance about our books other
    than the title. And guess what? Books have a TON of information about them. Everything
    from title, author, ISBN, the list goes on! In fact, some of the most usable information
    about a book is contained in this information.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know we’ll display a book. Specifically, the information currently available
    in our book model object, `Book`, is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`title`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`authors`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isbn`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pageCount`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fiction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s not tons of data, but it’s enough. Plus, we’re going to expand on this
    screen in a bit, but for now let’s add something quickly in Android and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you recall [Chapter 2](ch02.html#topics_views) and [Chapter 15](ch15.html#app_setup),
    what follows should be very familiar.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s define our layout using XML. We know we want to show each of the
    `Book` instances properties, so let’s just list them out in a vertical fashion
    that we’ll decorate programmatically. Again, we’ll want to make sure our `LinearLayout`
    is wrapped in a `ScrollView` so that we can show all our information regardless
    of screen size, device density, or accessibility settings like large font rendering.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let’s save the preceding code as *res/layout/activity_detail.xml*.
  prefs: []
  type: TYPE_NORMAL
- en: Since we want these `TextViews` to show complete labels, we’ll introduce the
    concept of placeholder `Strings` in your *strings.xml* file. A placeholder string
    just accepts special formatting characters and allows them to be replaced with
    variables. Read up on Java’s `String.format` method for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *strings.xml*, let’s add some placeholders:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need a UI controller to show, control, and modify the layout, as well
    as provide behavior instructions. In our case, an `Activity`.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll want to pass this UI controller some information about the `Book`, and
    in Android, this is where things can get contentious. An `Activity` is created
    programmatically and opaquely, but as described in [Chapter 1](ch01.html#topics_ui_controllers),
    we can pass some primitive data via a `Bundle` instance with the `Intent` that
    starts the controller.
  prefs: []
  type: TYPE_NORMAL
- en: For an example like this, you’ll find two schools of thought. Sometimes, one
    makes much more sense than the other, but a lot of the time it’s really up to
    you and your team. And feel free to experiment with other approaches besides those
    details—in fact our current teams use a very different, very custom approach to
    solve this problem that’s beyond the scope of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, approach number 1: you can serialize the whole object and pass it along
    as a `String` (or `byte[]`) and deserialize it in the new controller. This makes
    things pretty straightforward, but remember that `Bundle` is limited to 1 MB in
    size and is shared between any number of operations, potentially ones you have
    no knowledge of.'
  prefs: []
  type: TYPE_NORMAL
- en: The second approach is to pass some kind of unique identifier, like an ID number
    or a URI, and then retrieve the information in full from another source, like
    a local database, JSON store, or even remote server.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity for this example, and just for now, we’ll use the first approach.
    This `Activity` will expect a JSON `String` representing a serialized `Book` object
    in its `Intent` object as an “extra”—let’s call the `String` extra “BOOK_JSON”
    and save it in a constant. We’ll deserialize it during the `onCreate` callback
    and decorate our view with those properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, let’s not forget to register this new `Activity` with our manifest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Great! We’ve got an `Activity` with a UI that will display all the details we
    have for a `Book` instance. Let’s jump back to the list view from [Chapter 17](ch17.html#app_lists)
    and wire up a tap event to pass the selected `Book` instance from the `BrowseContentActivity`
    to our new `BookDetailActivity`. First, we’ll want to make sure our row (just
    a `TextView` at the moment) has a `View.OnClickListener` to bundle up its associated
    `Book` instance and start the `BookDetailActivity`. We can do this once, in the
    creation phase—the `onCreateViewHolder` method. Since these `Views` are recycled,
    we just need to make sure we update that association with the appropriate book,
    which we can do in the bind and update cycle, represented by the `onBindViewHolder`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your new `BrowseBooksAdapter` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: If you run the app now, whenever you tap a row from the list view, you should
    see a book detail screen show up with all the details we have about that book.
    Congratulations, you’ve just mastered one of the widely used patterns in Android
    specifically and UI programming generally! Take a moment to give yourself a pat
    on the back.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start by opening up *Main.storyboard*. Drag a new View Controller object
    onto the canvas from the Library just like we did to add our other screens. This
    screen is sitting isolated from the rest of the app currently, so let’s connect
    it via a segue so we can transition to it later.
  prefs: []
  type: TYPE_NORMAL
- en: This is an area storyboards excel. If you click on the table view cell inside
    the Catalog scene—the one we created in [Chapter 4, *User Input*](ch04.html#topics_user_input)—in
    the Document Outline within the storyboard editor, you can drag while holding
    down Control, and you’ll be able to wire up a segue *directly* to the table view
    cell itself.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the modal that’s presented, select `Show` as the segue type. If you build
    and run the app, you’ll see that tapping on a book within the catalog pushes a
    new view controller—that’s currently blank—onto the view stack. There is currently
    a bit of UI weirdness we need to fix, however. If you go back to the catalog view,
    you’ll notice our table view cell stays selected. Additionally, our view is fairly
    basic at this point—it’s just a white screen. Let’s fix it!
  prefs: []
  type: TYPE_NORMAL
- en: Add some detail to yo’ detail so you can detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To fix both of those items, we need to create a custom view controller for
    our new scene. Add a new file to your project called `DetailViewController`. It
    should inherit from `UIViewController` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Remembering our list from earlier and what our Android app currently has, we
    can recall we’re going to add a few views to our view controller. These will all
    be labels, so let’s go ahead and add some view outlets now; we can wire them up
    later in the storyboard editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding view outlets, your view controller should now look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have a problem, though. How are we going to fill these properties?
  prefs: []
  type: TYPE_NORMAL
- en: 'We know they’ll be coming from a book. So let’s create a method call `populate(from:)`
    that takes a `Book` argument we can use to set the text of our labels. We’ll use
    this in our catalog view controller to pass a `Book` object in during the segue.
    The final class with this method should look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s bounce back over to `CatalogViewController` and wire up this connection.
    If you’ll recall, our segue is automatically triggered because we wired it up
    to the table view cell itself. The preparation for the segue occurs in the view
    controller that triggered the segue. There is a special method we can override
    to add our custom preparation code: `prepare(for:sender:)`. It takes a `UISegue`
    object as the first parameter; this object contains the destination view controller,
    which happens to be our `DetailViewController` from before.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use this method, though, we need to get an instance of the book
    for the cell that was tapped from our data source. To do this, we need to add
    a new method onto `ListDataSource` called `book(for:)` that will take an index
    path from the table view. Add the following method to `ListDataSource`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Head back over to `CatalogViewController` and override `prepare(for:sender:)`
    to populate our destination view controller during our segue like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: There isn’t much to this method, but it’s extremely important to understand
    what’s going on. First, we check to see if our destination view controller type
    is `DetailViewController`. If it is, we continue forward in our `if` condition
    checking and make sure there is currently a selected row in the table view. These
    are both important checks because this method is called for *every* segue that’s
    triggered from this view controller. If both conditions are true, then we take
    the `DetailViewController` instance and call the method we created earlier to
    populate the book instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before we leave this file and head back over to our storyboard editor
    to wire things up, let’s add one more fix: let’s clear our table row selection.
    This doesn’t happen automatically because we’re using a standard `UIViewController`
    as our base class instead of a `UITableViewController`. We want this to happen
    whenever the view appears, which will provide a nice fade-out animation to provide
    context to our users as to what row they selected. As such, we’ll do this in the
    `viewDidAppear(_:)` method that’s part of our view controller life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our final `CatalogViewController` class should look like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The last part of adding this view is fairly simple and similar to what we’ve
    done in the past. We need to add the labels for our new outlets in `DetailViewController`
    onto the scene. Feel free to arrange these however you’d like. Be creative! If
    you’d like to take a look at the sample project available on our GitHub repository,
    you can. In it, we’ve used stack views (from our Library picker) to create a view
    that expands and contracts automatically depending on the size of the screen.
    However, just dragging labels onto the view with some Auto Layout constraints
    would suffice for this example. You might end up with something like that looks
    like [Figure 19-1](#detail).
  prefs: []
  type: TYPE_NORMAL
- en: '![You might notice some stretching between views thats perfectly normal](assets/nmdv_1901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-1\. You might notice some stretching between views (that’s perfectly
    normal!)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s switch this scene to use our custom class `DetailViewController` by clicking
    to show the Identity inspector on the right side of the editor and switching from
    `UIViewController` to `DetailViewController`. Now, Control-drag from the view
    controller object in the document outline to each label and select the corresponding
    view outlet we coded earlier.
  prefs: []
  type: TYPE_NORMAL
- en: If you build and run the project, you’ll see that after you click on an item
    in the catalog now, that item populates the book detail screen. Awesome!
  prefs: []
  type: TYPE_NORMAL
- en: Saving Books for Later
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can see more information about our books, what happens if we find
    a particularly interesting book and want to save it for later? We could, of course,
    save it in memory within the application, but it wouldn’t last between application
    launches. We *could* save it to the filesystem using JSON, but you’ll find that
    will quickly become cumbersome and not very performant if we’re saving a large
    number of books. Don’t forget: the dataset we’re using for this example app is
    small, but the library we’re building this app for has a HUGE number of books
    available.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another major consideration is manipulating that information; things like sort
    and filter and pagination are easily accomplished using most persistence engines
    like Core Data, or any flavor of SQL, or Realm or Room, etc. The same cannot be
    said of a flat file store of JSON objects. Similarly, you’ll notice size start
    to become an issue when each file must reestablish structure, order, and key names
    for every object. For small or one-off data objects, a JSON file here and there
    can not only be fine but even preferable, but for a library of books we want the
    user to browse and curate, we need something a little more robust: a database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’re pondering the best approach available (hint: this chapter is about
    native persistence), let’s go ahead and add a button to toggle a book as a user
    favorite, which we’ll wire up later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we’re not using an `ActionBar` in our sample app, we’ll deviate slightly
    from iOS in that we’ll put our save button in the same UI as the informational
    `TextViews`. Simply add an XML `Button` to the end of the `LinearLayout` and give
    it an ID of `button_save`. If you’d like to differentiate it visually, use `android:layout_gravity="center"`,
    like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Your new detail layout should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We’ll wire up the tap behavior to save the detail a little later, after we’ve
    established a persistence layer. Stay tuned.
  prefs: []
  type: TYPE_NORMAL
- en: So that was painless. Let’s do the same on iOS, which is slightly more painful.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s add our button to the navigation bar. This is a pretty common place to
    put actions like this. Open up *Main.storyboard* and head over to the detail scene
    if you’re not already there. Search for “Navigation Item” in the Library and drag
    that over to the scene. This creates a navigation item that is associated with
    our view controller’s navigation bar that we can edit in the storyboard editor.
    Click on the navigation item—labeled “Title”—in the Document Outline of the editor.
    Show the Attributes inspector and clear the value in the Title field so that it’s
    blank. This will cause the object to change to Navigation Item in the Document
    Outline.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you select `Push` as the segue type, this is automatically added for you
    by Xcode because `Push` is a segue type for navigation controllers. However, that
    segue type is deprecated, which requires us to provide a bit more manual context
    when we create the scene to keep things inside the storyboard editor. We could,
    however, do all this in code as well, but it’s arguably easier in the storyboard
    editor. At a minimum, it helps us keep our UI setup in one place, as opposed to
    spread across code files and storyboards unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the Library, search for “Bar Button Item” and drag that item onto the
    right side of the navigation bar in the scene. In the Attributes inspector for
    this item, change the title field from “Item” to “Save Book.” Your scene should
    look like [Figure 19-2](#save-book).
  prefs: []
  type: TYPE_NORMAL
- en: '![Save Book button added to the navigation bar](assets/nmdv_1902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 19-2\. “Save Book” button added to the navigation bar
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s create an action for this new button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Assistant editor, which shows the code and interface side by side.
    Control-drag on the new button and drop the action inside the view controller
    below our `populate(for:)` method declaration at the very bottom of the class.
    This should create a new method inside of `DetailViewController` that looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you build and run the project, you’ll see the button at the top right of
    screen in the book detail screen, but tapping it won’t do anything just yet. Let’s
    address that now.
  prefs: []
  type: TYPE_NORMAL
- en: Storing Books for Later
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, we need to store our books for later. We need something
    performant due to the size of our library, something that lasts between launches,
    and something that will allow us to read and write data to and from. This is starting
    to sound like a data persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: Gasp!
  prefs: []
  type: TYPE_NORMAL
- en: If you’re building a cross-platform set of apps, like we are in this book, you’ll
    find this is a major area where the native components diverge. We could use a
    cross-platform solution, like Realm, but in the interests of staying true to each
    platform, we’re going to use the most common and supported options available for
    Android and iOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, before we talk about Android and iOS separately, let’s talk about our
    common goals with our data persistence layer. There are some requirements we have.
    The expected functionality is as such:'
  prefs: []
  type: TYPE_NORMAL
- en: Tapping “Save Book” will save a book identifier to some sort of store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This data store will be able to show a list of books from our returned identifiers
    that were saved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The detail screen will indicate if a book is saved or not.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be able to delete books from our list that we’ve saved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two items in that list are where Android and iOS will have the most
    different approaches. However, because we are using an MVC architecture, a lot
    of the code differences will be contained to the Model layer. The View and Controller
    layers (i.e., the last two items in that list of requirements) will continue to
    have code that is similar in terms of architecture.
  prefs: []
  type: TYPE_NORMAL
- en: So, without further ado, let’s build a persistence layer.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned a couple times already, there are a number of ways to persist data
    using the Android framework, and at the time of the writing, Google suggests we
    use the Room library. However, we’re going to use SQLite for a couple reasons,
    the most important being that SQL is extremely mature, well-vetted, and accepted
    by the databasing community as the gold standard. We have access to SQLite only
    for local device persistence, but the same basic syntax, rules, and operations
    apply to all the major SQL databases, like PostgreSql, MySql, and MSSql. Of course
    you should feel free to experiment with other approaches, like Room. Realm is
    another popular choice, with the additional benefit of it being cross-platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any event, let’s see how we can build a persistence layer with SQLite. First,
    as with all relational database management systems, we need at least one table.
    In our example, we’re going to use three: one for `Book` instances, one for authors
    (that will be represented as `Strings`), and a single table to relate the two.
    The relational table is sometimes known as a through table, bridge table, pivot
    table, or join table, but it’s an extremely common paradigm and we think it is
    a great but simple example on how to use SQL.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use SQL standard “create table” syntax. For the specifics of each keyword,
    check the dev docs, but we’ll present enough to get you up and running.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You’ll want each of these tables created the first time your application is
    launched, so you have access to them immediately. If you recall the detail around
    `SqliteOpenHelper` back in [Chapter 7](ch07.html#topics_databases), you might
    remember you can accomplish this with an overridden `onCreate` method. Remember,
    this will fire only once during the first app launch following install. Note further
    that it will not be invoked until the first time you use the subclass to get an
    instance of a database, with either `getReadableDatabase` or `getWritableDatabase`.
    For our examples, we’ll always prefer the latter, so we can update our data store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what that might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: 'So at this point, we’ve got a nice, shiny new database, but it’s empty—all
    of our data is still in *catalog.json*. Let’s remedy that. First, we know we’re
    going to need methods to read and write `Book` instances to and from the database,
    so let’s set that up. Maybe something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve got helpers to read and write `Book` data, let’s update our `DbHelper`
    class to read out *catalog.json* during the single `onCreate` invocation and write
    those entries to the database!
  prefs: []
  type: TYPE_NORMAL
- en: Now, the first time you get a `SqliteDatabase` instance from your `DbHelper`
    class, `onCreate` will run and you’ll populate your database from the *catalog.json*
    file you installed with the app in the *assets* special directory! Not bad!
  prefs: []
  type: TYPE_NORMAL
- en: We’ve spent a lot of time building out our persistence layer. We’re at the point
    where we’re about to display our saved books, but before we do that, let’s see
    what things look like in iOS before we continue.
  prefs: []
  type: TYPE_NORMAL
- en: iOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For Android, we used a database with raw SQL calls to get our data. On iOS,
    we have another option that allows us to work directly inside of Swift without
    having to deal with raw SQL: Core Data.'
  prefs: []
  type: TYPE_NORMAL
- en: Core Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get this out of the way now: Core Data is not a database. Core Data is
    an *object graph* that just *happens* to use a database as its backing store.
    It’s a framework available for iOS (and other Apple platforms) that is meant to
    make working with the data model layer and its persistence seamless and (fairly)
    easy.'
  prefs: []
  type: TYPE_NORMAL
- en: It can be incredibly complex, but for 90% of use cases, it’s a great option
    for apps. It’s perfect for our application. Why don’t we add it to our project?
  prefs: []
  type: TYPE_NORMAL
- en: 'To add support for Core Data to an existing project, there are a few things
    that you need:'
  prefs: []
  type: TYPE_NORMAL
- en: A data model file and any entities defined
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A data controller that handles setting up the Core Data stack
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialization logic in your app’s start-up logic
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting started with the model file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our first item on the list, a data model file, is the easiest one to check off.
    Go to File > New > File in Xcode and scroll down a bit to the Core Data section.
    There, select Data Model and hit Next. Let’s name our model “LibraryModel” to
    keep things simple, but really you could name this model whatever you wanted.
    You should see a file named *LibraryModel.xcdatamodel*, in your project files.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data uses entities with associated attributes as backing objects. If you
    click on *LibraryModel.xcdatamodel* you’ll see an empty list of entities.
  prefs: []
  type: TYPE_NORMAL
- en: We’re at an inflection point here.
  prefs: []
  type: TYPE_NORMAL
- en: We could continue to use our existing *Book.swift* structure that we’ve been
    using already and create a separate entity that’s specific to saved books that
    just contains some kind of identifier (a unique string, for example). This has
    the benefit of keeping our Core Data stack lightweight. However, it treats Core
    Data more like a database and limits its true potential in managing the entirety
    of our model layer.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we’re going to continue using our *catalog.json* file as the source
    of our library data, but only the first time the application starts. This allows
    us to use Core Data as a cache, of sorts, so we don’t have to read that entire
    file into memory whenever we want to view the library’s catalog.
  prefs: []
  type: TYPE_NORMAL
- en: To add an entity to Core Data, click the Add Entity button at the bottom of
    the screen. You’ll see an entity gets created with the generic name of “Entity”
    in the list of entities. Click to show the Entity inspector on the right side
    of the screen. Change the Entity name from “Entity” to “Book” and under Class,
    change the name to “BookManagedObject” to separate the actual file name of our
    managed object from our entity’s name. The reason for this is to allow us to recognize
    we are dealing with a Core Data–managed object whenever we deal with objects of
    the type `BookManagedObject`.
  prefs: []
  type: TYPE_NORMAL
- en: The existing properties inside our *Book.swift* file need to be re-created as
    attributes inside of our `Book` entity. Do this by clicking the plus symbol under
    Attributes and adding each existing property and its associated type (e.g., `String`,
    `Int`, `Bool`, etc.) for each property inside our preexisting `Book` structure.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For the `authors` property, you need to specify the type as “Transformable.”
    Then, with that attribute selected, in the Data Model inspector, set the Custom
    Class type to `[String]` to indicate in the generated file that it’s a `String`
    array.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our `Book` entity defined, let’s have Xcode generate our file
    for us. Select the book entity in the editor. Show the Data Model inspector and
    under Codegen change it from Class Definition to Category/Extension. Click Editor
    > Create NSManagedObject Subclass in the menu bar and hit Next a few times for
    the default values.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll notice, once everything has been generated, that two new files were
    created: *BookManagedObject+CoreDataClass.swift* and *BookManagedObject+CoreDataProperties.swift*.
    The first file is technically unnecessary, so go ahead and drag it to the trash.
    The second file contains all the Core Data attributes we added as Swift properties
    decorated with `@NSManaged`. This is some syntactic sugar to let the compiler
    know Core Data is managing this particular property.'
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use this extension eventually to add some functionality to our
    model. For now, though, let’s finish setting up the rest of our Core Data stack.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing our stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are three parts to the Core Data stack:'
  prefs: []
  type: TYPE_NORMAL
- en: The data model file, which we’ve just created. It holds our entity descriptions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The persistent store container, which provides the link to our application and
    our persistent store. In this case, it will be backed by a SQLite database, but
    it could be XML or in-memory storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The managed object context, which is the “scratch pad” of sorts where all our
    `BookManagedObject` instances live while they’re active; this is what’s actually
    persisted to the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve taken care of (1) *LibraryModel.xcdatamodel* is our data model file. But,
    we still need to set up (2) and (3). Usually, our Core Data stack is initialized
    on app startup. We’ll wrap everything in a `DataController` object to make things
    a bit easier to work with as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xcode, create a new Swift file named `DataController` and add it to your
    project. Here’s what `DataController` should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through what’s happening here. First, we’re initializing our `DataController`
    with a completion handler in the `init(completion:)` method. This completion handler
    will be called after everything has been set up and allows the application startup
    to continue.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The store will load serially on whatever thread it’s called from. We can add
    the store asynchronously by adding a new description for the store when it boots
    up with the property `shouldAddStoreAsynchronously` set to `true`. For this example,
    however, we are not using this property to simplify the loading of the Core Data
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the initializer, we first assign the object’s instance variable, `persistentContainer`,
    to a new instance of an `NSPersistentContainer`. This container does a lot of
    the setup of linking the data model file and the persistent store coordinator.
    It’s the “glue” between these two objects. To create it, we pass in the name of
    our data model file, minus the extension. Once that is created, we take the persistent
    container object and call `loadPersistentStores(_:)` on it and pass in a closure
    with a bit of error checking. If the database can’t be connected, the model file
    can’t be read, or any number of errors, we call `fatalError` to kill the application.
    Finally, if the store was loaded correctly, we call `completion()`, which is the
    original closure we passed in during `DataController`’s initialization.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve got our persistent store set up, and through that process, we’ve also
    got our managed object context set up through the persistent container as a property.
    We’ll dive into how to use it in a bit. For now, let’s finish setting up our stack
    and use the `DataController` object we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up *AppDelegate.swift*. Add a new property called `dataController` with
    the type `DataController!`. Inside the `application(_:didFinishLaunchingWithOptions:)`
    method insert the following lines above the `return true` statement at the bottom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Your `AppDelegate` should look mostly like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'If you build and run the app, you’ll see the following text in Xcode’s console:
    `Core Data stack has been initialized.`'
  prefs: []
  type: TYPE_NORMAL
- en: Yes! Our Core Data stack is up and running, however nothing is actually powered
    by Core Data right now. It’s still powered by *catalog.json*. Let’s switch from
    using the raw JSON file in our `ListDataSource` to using Core Data directly.
  prefs: []
  type: TYPE_NORMAL
- en: Switching from JSON to Core Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can do this by first creating a new extension on `BookManagedObject`. You
    can do this in a new file. Normal practice for Swift extensions is to have the
    file named something like *BookManagedObject+Extensions.swift*. Inside this file,
    we’ll create a new fetched results controller, which is essentially an object
    that controls the results of a Core Data fetch. Here’s what our extension should
    contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot going on here, but really only a few important things. First,
    we’re creating a new fetch request. Fetch requests are how we query Core Data
    for our model objects. We’re sorting this request by `title`, which seems like
    the most appropriate way to sort for a list of books. Next, we’re grabbing the
    `viewContext` as the managed object context we’re going to be operating on for
    this fetch. The `viewContext` is the context that operates on the main thread.
    It’s perfectly acceptable, and recommended, to view managed objects on the main
    thread. However, if we were writing objects, we’d be performing our actions on
    a background thread instead.
  prefs: []
  type: TYPE_NORMAL
- en: After we get our context, we create a fetched results controller object of type
    `NSFetchedResultsController`. This is a purpose-built Core Data object used to
    power fetched objects and supply them to a data source like a table view data
    source or collection view data source. Eventually, we’ll have our `ListDataSource`
    adhere to the delegate protocol `NSFetchedResultsControllerDelegate` that we’re
    assigning here so it can receive updates and populate the table view, but for
    now, we’re just setting the property on `fetchedResultsController` to what’s passed
    in.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we perform the actual fetch in Core Data with `performFetch()`. This
    method can `throw`, so it’s wrapped in a `try` block to capture any errors. For
    the sample app, we’re just calling `fatalError`, but in a production app, it would
    be important to catch the error and handle it appropriately or display messaging
    to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use this extension and wire up our data source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to `ListDataSource`. We’re going to perform a few updates to this
    file. The first thing to update is to remove the `data` property we’ve been using
    to lazy load the JSON files. Replace that with a new `fetchedResultsController`
    property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a new method to `ListDataSource` called `fetchCatalogResults`
    that create our catalog fetched results controller we just created earlier. We’ll
    store this in our new property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a new method to `ListDataSource` called `fetchCatalogResults`
    that initializes an instance of the fetched results controller we created earlier.
    We then take that instance and store it in our new property like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We’ve used `fetchedResultsController` to supply the results where possible.
    The only thing to note is that in the method `book(for:)` we grab a `BookManagedObject`
    but then convert that using the extension method we created earlier to make it
    a `Book` instance. We’ll continue to use `Book` instances throughout the view
    controller and view layers of our application instead of passed-around managed
    object instances directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only missing piece is to switch `CatalogViewController` over to use the
    new data source methods. We do this by calling `dataSource.fetchCatalogResults(with:delegate:)`
    in the lazy loaded property `dataSource` like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Build and run the application and you’ll see…nothing in the catalog results.
  prefs: []
  type: TYPE_NORMAL
- en: If you’ll recall, we created our Core Data objects, but we *did not* populate
    it with data. A common approach for this with iOS apps is to bundle the application
    with either a database that’s been pre-populated or some sort of data to jump-start
    the application via the web or inside the app bundle. In this instance, we’re
    going to use our *catalog.json* to pre-populate the database if it didn’t exist
    before it was created.
  prefs: []
  type: TYPE_NORMAL
- en: Seeding the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open up the `DataController` we created earlier. Add the following code to
    the top of the `init(with:)` method along with a new variable called `shouldSeedDatabase`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we grab the database path where it’s expected to be. Then, we set the
    variable `shouldSeedDatabase` to `true` if the database doesn’t exist yet. It’s
    a simple bit of logic, but useful. Now, let’s create the method that actually
    seeds the database. We’ll call it `seedData()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Let’s walk through what this code does.
  prefs: []
  type: TYPE_NORMAL
- en: You might recognize this line. First, we grab our *catalog.json* file that exists
    in the application bundle. Next, we decode it from JSON into an array to `Book`
    objects. The next line, starting with `persistentContainer.performBackgroundTask`,
    uses the `NSPersistentContainer` we created as part of initializing our Core Data
    stack to perform a task in a background queue. This is important because it’s
    a task that writes to the persistent store, ultimately, and would block the main
    thread until it’s complete. We get an `NSManagedObjectContext` as part of calling
    this method, which, in turn, is used to create a new `BookManagedObject` as we
    loop through our `books` array from the JSON.
  prefs: []
  type: TYPE_NORMAL
- en: Each `BookManagedObject` is created inside of the background managed object
    context. It’s important to note that really, it only exists in-memory at this
    point. It’s not until we actually `save()` on the managed object context that
    the objects and changes are persisted back through the persistent store coordinator
    and on through to the database if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the application will not, however, populate the database. The reason
    for this is simple: the database already exists and this code checks to make sure
    it doesn’t before it’ll seed the database. The solution: delete the app from the
    iOS Simulator and then build and run the application again. If everything goes
    well, you’ll see, in our catalog view, a list of the same books as before, sorted
    by `title`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Whew. Breathe a sigh of relief. We’ve done it. We’re using a database just
    like in our Android app. However, we’ve taken it a bit further to get the full
    benefits of using Core Data over just a straight SQLite database. But, we’re not
    done yet! We need to take this database and utilize it for our original purpose:
    saving books for later. Let’s jump back on that part of the project!'
  prefs: []
  type: TYPE_NORMAL
- en: Saving Books
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So our persistence layer saves our books. If later we’re offered a remote service
    that can update our database with more books from the library, we have both the
    infrastructure and plumbing in place to do so. So what’s left? Remember that button
    we added earlier, to mark a `Book` instance as a favorite of the current user?
    Let’s hook that up now.
  prefs: []
  type: TYPE_NORMAL
- en: Android
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve mentioned several times, there are several ways to accomplish this,
    and it’s very fair to assume someone might want to add a column to the `BOOKS`
    table in the database and set a `INTEGER` value of 0 (false) or 1 (true) there
    as the toggle is switched (unlike most SQL RDBMSs, SQLite does not have a boolean
    data type—typically integers are used in the pattern just described). In fact,
    in the long run, that’s probably how I’d do it to. However, for this example,
    we’re going to use an alternate approach, first for simplicity, but also to show
    another common and handy feature built in to the Android framework and discussed
    in [Part I, *Tasks and Operations*](part01.html#part_1_tasks), in [Chapter 11](ch11.html#topics_preferences).
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, `SharedPreferences` accepts as `Set` of `Strings`. This seems
    like an ideal data structure for this kind of work—we want a unique, unordered
    collection if book IDs (ISBN numbers) by which we can easily identify if a book
    is a favorite of the user or not. If toggling “on,” we add the ISBN to the `Set`—if
    toggling “off,” we remove it. Simple! At some point you might want to add a custom
    UI like a star that turns from gold to gray, or special styling in the list, but
    for now we’ll just update the text of the button to identify the current state.
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, let’s make a method that toggles a `Book` in the `Set<String>` we
    identify in `SharedPreferences`. Let’s assume we’ll define this function in the
    `BookDetailActivity` class and therefore have local access to a `Context` object
    (the activity itself) and all its accessors:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add that method to the button in a click listener like so:'
  prefs: []
  type: TYPE_NORMAL
- en: That should do it! Run the app, pick a book from the list, and in the detail
    page, toggle the favorite setting. Since this value is stored in a persistent
    structure, the value will persist between app launches and power cycles.
  prefs: []
  type: TYPE_NORMAL
- en: What We’ve Learned
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congrats! We’ve got a diverse, if basic, set of functionality in our app. The
    application is usable and consistent between Android and iOS. In this chapter,
    we’ve learned about data persistence and how different it is in both platforms.
    Android has a much more approachable database approach to storing and accessing
    data, whereas iOS takes a more abstract method but offers considerably more functionality
    for free—albeit with considerable added complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we ride off into the sunset with our app, we need to take a look at
    one more aspect: networking. Let’s walk through the pitfalls and practices to
    adding some lightweight connectivity to this app in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
