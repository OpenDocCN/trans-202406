- en: 'Chapter 12\. Live Data: *Leaping into Action*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章。LiveData：*行动的跃进*
- en: '![image](Images/f0483-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0483-01.png)'
- en: '**Your code often needs to react to property value changes.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**您的代码经常需要对属性值变化作出反应。**'
- en: 'If a view model property changes value, for example, **the fragment might need
    to respond** by updating its views or navigating elsewhere. But **how does a fragment
    get to hear when a property’s been updated**? Here, we’ll introduce you to **live
    data**: a way of **telling interested parties when something’s changed**. You’ll
    learn all about ***MutableLiveData***, and how to **make your fragment observe
    properties** of this type. You’ll discover **how the *LiveData* type helps maintain
    your app’s integrity**. Soon, you’ll be writing apps that are **more responsive
    than ever before**...'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果视图模型属性的值发生变化，**片段可能需要响应**通过更新其视图或导航到其他位置。但是，**片段如何知道属性何时被更新**？在这里，我们将向您介绍**LiveData**：一种**告知感兴趣方何时发生变化**的方式。您将了解有关***MutableLiveData***的所有内容，以及如何**使您的片段观察此类属性**。您将发现**LiveData**类型如何帮助维护应用程序的完整性。很快，您将编写比以往更具响应性的应用程序...
- en: The Guessing Game app revisited
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新审视猜字游戏应用
- en: In the previous chapter, we built a Guessing Game app that lets the user guess
    which letters are included in a secret word. When the user guesses all the letters
    or runs out of lives, the game ends.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们构建了一个猜字游戏应用，让用户猜测哪些字母包含在一个秘密单词中。当用户猜测所有字母或生命用尽时，游戏结束。
- en: 'To stop the fragment code from becoming too bloated and maintain the app’s
    state when the user rotated the device screen, we used view models for the app’s
    game logic and data. `GameFragment` uses `GameViewModel` for its logic and data,
    and `ResultViewModel` holds the game result that’s needed by `ResultFragment`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止片段代码变得过于臃肿，并在用户旋转设备屏幕时保持应用程序状态，我们为应用程序的游戏逻辑和数据使用了视图模型。`GameFragment`使用`GameViewModel`处理其逻辑和数据，而`ResultViewModel`则保存了`ResultFragment`所需的游戏结果：
- en: '![image](Images/f0484-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0484-01.png)'
- en: When each fragment is displayed, or the user makes a guess, the fragments get
    the latest values from their view models and display them on the screen.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每当显示每个片段或用户进行猜测时，片段从其视图模型获取最新值并将其显示在屏幕上。
- en: While this approach works, however, there are some disadvantages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种方法有效，但也存在一些缺点。
- en: The fragments decide when to update views
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段决定何时更新视图
- en: The downside to this approach is that each fragment decides when to fetch the
    latest property values from the view model and update its views. And some of the
    time, these values won’t have changed. If the user makes a correct guess, for
    example, `GameFragment` updates the text that’s displayed for the number of lives
    left and the incorrect guesses, even though these values won’t have changed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点在于，每个片段决定何时从视图模型获取最新的属性值并更新其视图。而有时这些值并没有改变。例如，如果用户猜对了，`GameFragment`会更新显示剩余生命和错误猜测的文本，即使这些值并没有改变。
- en: '![image](Images/f0485-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0485-01.png)'
- en: Let the view model say when a value’s changed
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让视图模型在数值变更时发出通知
- en: An alternative approach is for `GameViewModel` to let `GameFragment` know when
    each of its properties has been updated. If the fragment is notified of these
    changes, it will no longer need to decide for itself when to fetch the latest
    property values from the view model and update its views. Instead, it will only
    need to update its views once it’s told that the underlying property has been
    updated.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是让`GameViewModel`告诉`GameFragment`每个属性何时被更新。如果片段收到这些更改的通知，它将不再需要自行决定何时从视图模型获取最新的属性值并更新其视图。相反，它只需在告知底层属性已更新后更新其视图。
- en: '![image](Images/f0485-02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0485-02.png)'
- en: 'We’re going to implement this change in the Guessing Game app using Android’s
    **live data** library: part of Android Jetpack. Live data lets the view model
    tell interested parties—such as fragments and activities—when its property values
    have been updated. They can then react to these changes by updating views, or
    calling other methods.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用Android的**LiveData**库在猜字游戏应用中实现这一变更：它是Android Jetpack的一部分。LiveData允许视图模型通知感兴趣的方（如片段和活动），其属性值已被更新。它们可以通过更新视图或调用其他方法来对这些更改作出响应。
- en: '![image](Images/f0485-03.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0485-03.png)'
- en: You’ll find out how to use live data through the rest of this chapter. First,
    let’s go through the steps we’ll take to update the app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在本章的其余部分了解如何使用LiveData。首先，让我们浏览一下更新应用程序的步骤。
- en: Here’s what we’re going to do
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下面是我们要做的事情
- en: '![image](Images/f0486-01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0486-01.png)'
- en: 'Here are the steps that we’ll go through to write the app:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将执行的应用程序编写步骤：
- en: '**Make the Guessing Game app use live data.**'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**使猜谜游戏应用程序使用 LiveData。**'
- en: We’ll update `GameViewModel` so that the `livesLeft`, `incorrectGuesses,` and
    `secretWordDisplay` properties use live data. We’ll then make `GameFragment` update
    its views when the values of these properties change.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将更新 `GameViewModel`，使 `livesLeft`、`incorrectGuesses` 和 `secretWordDisplay`
    属性使用 LiveData。然后，当这些属性的值更改时，我们将使 `GameFragment` 更新其视图。
- en: '![image](Images/f0486-02.png)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0486-02.png)'
- en: '**Protect GameViewModel’s properties and methods.**'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保护 GameViewModel 的属性和方法。**'
- en: We’ll restrict access to `GameViewModel`’s properties so that only `GameViewModel`
    can update them. We’ll also make sure that `GameFragment` only has access to the
    methods it requires to do its job.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将限制对 `GameViewModel` 属性的访问，以便只有 `GameViewModel` 可以更新它们。我们还将确保 `GameFragment`
    只能访问其执行工作所需的方法。
- en: '![image](Images/f0486-03.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0486-03.png)'
- en: '**Add a gameOver property.**'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**添加一个 gameOver 属性。**'
- en: We’ll make `GameViewModel` decide when each game is over using a new `gameOver`
    property. `GameFragment` will navigate to `ResultFragment` when the value of this
    property changes.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使 `GameViewModel` 使用一个新的 `gameOver` 属性来决定每场游戏何时结束。当此属性的值更改时，`GameFragment`
    将导航到 `ResultFragment`。
- en: '![image](Images/f0486-04.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0486-04.png)'
- en: Add a live data dependency to the app build.gradle file
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向应用的 build.gradle 文件添加 LiveData 依赖项
- en: As we’re going to be using live data, we’ll begin by adding a live data dependency
    to the app’s *build.gradle* file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将使用 LiveData，所以我们将首先向应用程序的 *build.gradle* 文件添加 LiveData 依赖项。
- en: 'Open the project for the Guessing Game app (if you haven’t already done so),
    open the file *GuessingGame/app/build.gradle*, and add the following line (in
    bold) to the `dependencies` section:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 打开猜谜游戏应用程序的项目（如果尚未打开），打开文件 *GuessingGame/app/build.gradle*，并在 `dependencies`
    部分添加以下行（加粗）：
- en: '![image](Images/f0486-05.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0486-05.png)'
- en: When prompted, sync your changes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示时，同步您的更改。
- en: GameViewModel and GameFragment need to use live data
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameViewModel 和 GameFragment 需要使用 LiveData
- en: We want to use live data in the Guessing Game app so that `GameViewModel` notifies
    `GameFragment` when its property values have changed. `GameFragment` will then
    react to these changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在猜谜游戏应用程序中使用 LiveData，这样 `GameViewModel` 在其属性值更改时会通知 `GameFragment`。然后，`GameFragment`
    将对这些更改做出反应。
- en: 'We’ll tackle this in two stages:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将分两个阶段来解决这个问题：
- en: '**Specify which GameViewModel property changes GameFragment needs to know about.**'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**指定 GameFragment 需要了解哪些 GameViewModel 属性更改。**'
- en: '**Tell GameFragment how to respond to each change.**'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**告诉 GameFragment 如何响应每个更改。**'
- en: For now, we’ll focus on the `GameViewModel` code changes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将专注于 `GameViewModel` 的代码更改。
- en: Which view model properties should use live data?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 哪些视图模型属性应该使用 LiveData？
- en: '`GameViewModel` includes three properties—`secretWordDisplay`, `incorrectGuesses,`
    and `livesLeft`—that `GameFragment` uses to update its views. We’ll specify that
    these three properties use live data so that `GameFragment` is notified when their
    values change.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameViewModel` 包括三个属性——`secretWordDisplay`、`incorrectGuesses` 和 `livesLeft`——`GameFragment`
    使用这些属性来更新其视图。我们将指定这三个属性使用 LiveData，以便在它们的值更改时通知 `GameFragment`。'
- en: 'You specify that a property uses live data by changing its type to `**MutableLiveData<Type>**`,
    where `Type` is the type of data the property should hold. The `livesLeft` property,
    for example, is currently defined as an `Int` using the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您通过将其类型更改为 `**MutableLiveData<Type>**` 来指定属性使用 LiveData，其中 `Type` 是属性应持有的数据类型。例如，`livesLeft`
    属性当前使用以下代码定义为 `Int`：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To make the property use live data, you change its type to `MutableLiveData<Int>`
    so that it looks like this instead:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要使属性使用 LiveData，您需要将其类型更改为 `MutableLiveData<Int>`，使其看起来像这样：
- en: '![image](Images/f0487-03.png)![image](Images/f0487-02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0487-03.png)![image](Images/f0487-02.png)'
- en: This specifies that `livesLeft` is now a `MutableLiveData<Int>` with an initial
    value of 8.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了 `livesLeft` 现在是具有初始值 8 的 `MutableLiveData<Int>`。
- en: Similarly, we can define the `incorrectGuesses` and `secretWordDisplay` properties
    using code like this
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们可以使用以下代码定义 `incorrectGuesses` 和 `secretWordDisplay` 属性
- en: '![image](Images/f0487-04.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0487-04.png)'
- en: Here, each property’s type is set to `MutableLiveData<String>`. `incorrectGuesses`’s
    value is set to `""`, while `secretWordDisplay`’s value will get set in `GameViewModel`’s
    `init` block.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，每个属性的类型都设置为 `MutableLiveData<String>`。`incorrectGuesses` 的值设置为 `""`，而 `secretWordDisplay`
    的值将在 `GameViewModel` 的 `init` 块中设置。
- en: So that’s how you define a live data property. Next up, how to update its value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是您如何定义实时数据属性。接下来，我们来看如何更新其值。
- en: Live data objects use a value property
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实时数据对象使用一个value属性
- en: 'When you use `MutableLiveData` properties, you update their values using a
    property named `**value**`. To update the `secretWordDisplay` property with the
    `deriveSecretWordDisplay()` method’s return value, for example, you don’t use
    the code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用`MutableLiveData`属性时，您使用名为`**value**`的属性来更新它们的值。例如，要使用`deriveSecretWordDisplay()`方法的返回值更新`secretWordDisplay`属性，您不使用以下代码：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'as you did before. You use the following code instead:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 就像以前一样。您改用以下代码：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Changing the `value` property in this way is important, because it’s how any
    interested parties—in this case `GameFragment`—get notified of any changes. Each
    time `secretWordDisplay`’s `value` property gets updated, `GameFragment` is informed,
    so it can respond by updating its views.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式更改`value`属性很重要，因为这是任何感兴趣的方面（在本例中是`GameFragment`）被通知任何更改的方式。每当`secretWordDisplay`的`value`属性更新时，`GameFragment`都会被通知，以便它可以通过更新其视图来做出响应。
- en: '![image](Images/f0488-02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0488-02.png)'
- en: The value property can be null
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: value属性可以为null
- en: 'There’s one extra thing to be aware of when you use live data: the `value`’s
    type is *nullable*. This means that when you use live data values in your code,
    you need to perform null-safety checks, or your code won’t compile.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用实时数据时，还有一件额外的事情需要注意：`value`的类型是*可空*的。这意味着当您在代码中使用实时数据值时，您需要执行空安全检查，否则您的代码将无法编译。
- en: 'As an example, the `livesLeft` property is defined using the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`livesLeft`属性是使用以下代码定义的：
- en: '![image](Images/f0488-03.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0488-03.png)'
- en: This property’s type is `MutableLiveData<Int>`, so its `value` property can
    accept an `Int`, or be `null`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 该属性的类型是`MutableLiveData<Int>`，因此其`value`属性可以接受一个`Int`，或者为`null`。
- en: 'As the `value` property may be `null`, we can’t, say subtract one from its
    value using the code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`value`属性可能为`null`，我们不能使用以下代码从其值中减去1：
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead, we need to use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们需要使用：
- en: '![image](Images/f0488-04.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0488-04.png)'
- en: which subtracts 1 from its value so long as it isn’t `null`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 它从其值中减去1，只要它不为`null`。
- en: 'Similarly, the following `isLost()` method won’t compile because `liveLeft.value`
    may be `null`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，以下`isLost()`方法不会编译，因为`liveLeft.value`可能为`null`：
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can, however, change it to use Kotlin’s Elvis operator like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，我们可以将其更改为使用Kotlin的Elvis运算符，如下所示：
- en: '![image](Images/f0488-05.png)![image](Images/f0489-02.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0488-05.png)![图片](Images/f0489-02.png)'
- en: '**Live Data properties can be defined using val.**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '**实时数据属性可以使用val来定义。**'
- en: As you already know, you use `val` and `var` in Kotlin to specify whether or
    not a property can be given a reference to a new object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经知道的，您在Kotlin中使用`val`和`var`来指定属性是否可以引用新对象。
- en: 'When we first defined each property, we used `var` so that we could update
    it. We defined the `livesLeft` property, for example, using:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们首次定义每个属性时，我们使用`var`以便可以更新它。例如，我们使用以下方式定义`livesLeft`属性：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'which initialized `livesLeft` with an `Int` object whose value is 8\. Each
    time the user made an incorrect guess, we subtracted 1 from `livesLeft`, which
    gave it a reference to a new `Int` object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用一个值为8的`Int`对象初始化了`livesLeft`。每当用户猜错时，我们从`livesLeft`中减去1，这使其引用了一个新的`Int`对象：
- en: '![image](Images/f0489-03.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0489-03.png)'
- en: 'With live data, you update the `value` property of the *existing* object, instead
    of replacing it with another object, and interested parties are notified of this
    change. As the object is no longer being replaced, you can define the property
    using `val` instead of `var` like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用实时数据，您更新*现有*对象的`value`属性，而不是用另一个对象替换它，并且感兴趣的方面会被通知到这一更改。由于对象不再被替换，您可以像这样使用`val`而不是`var`来定义属性：
- en: '![image](Images/f0489-04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0489-04.png)'
- en: The full code for GameViewModel.kt
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameViewModel.kt的完整代码
- en: Now that you know how live data works, let’s update `GameViewModel` so that
    its `livesLeft`, `incorrectGuesses`, and `secretWordDisplay` properties all use
    live data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道实时数据是如何工作的，让我们更新`GameViewModel`，使其`livesLeft`、`incorrectGuesses`和`secretWordDisplay`属性都使用实时数据。
- en: 'Here’s the full code for *GameViewModel.kt*; update the code to include the
    changes (in bold):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是*GameViewModel.kt*的完整代码；更新代码以包含更改（用粗体标出）：
- en: '![image](Images/f0490-02.png)![image](Images/f0491-02.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0490-02.png)![图片](Images/f0491-02.png)'
- en: That’s everything that we need for `GameViewModel`. Next up, let’s make `GameFragment`
    respond when the `livesLeft`, `incorrectGuesses`, and `secretWordDisplay` properties
    get updated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要为 `GameViewModel` 做的一切。接下来，让我们在 `GameFragment` 中响应 `livesLeft`、`incorrectGuesses`
    和 `secretWordDisplay` 属性更新时的情况。
- en: The fragment observes the view model properties and reacts to changes.
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段观察视图模型属性并对更改作出反应。
- en: 'You make a fragment respond to `value` changes in a view model’s `MutableLiveData`
    property by calling the property’s `**observe()**` method. If the following code
    is added to `GameFragment`, for example, it will observe the view model’s `livesLeft`
    property, and take action when it changes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用属性的 `**observe()**` 方法，可以使片段响应视图模型的 `MutableLiveData` 属性中 `value` 的更改。例如，如果将以下代码添加到
    `GameFragment` 中，它将观察视图模型的 `livesLeft` 属性，并在其更改时采取行动：
- en: '![image](Images/f0492-02.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0492-02.png)'
- en: As you can see, the above code passes `viewLifecycleOwner` and `Observer` arguments
    to the `observe()` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，上述代码将 `viewLifecycleOwner` 和 `Observer` 参数传递给 `observe()` 方法。
- en: '`viewLifecycleOwner` refers to the lifecycle of the fragment’s views. It’s
    tied to when the fragment has access to its UI: from when it’s created in the
    fragment’s `onCreateView()` method, to when its destroyed, and `onDestroyView()`
    gets called.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewLifecycleOwner` 引用片段视图的生命周期。它与片段访问其 UI 的时间相关联：从在片段的 `onCreateView()` 方法中创建时，到销毁时调用
    `onDestroyView()` 方法。'
- en: '![image](Images/f0492-03.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0492-03.png)'
- en: '`Observer` is a class that can receive live data. It’s tied to the `viewLifecycleOwner`,
    so it’s only active—and able to receive live data notifications—when the fragment
    has access to its views. If the live data property’s value changes while the fragment
    doesn’t have access to its UI, the observer isn’t notified, so the fragment doesn’t
    respond. This stops the fragment from trying to update views when they’re not
    available, which might cause the app to crash.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer` 是一个能够接收实时数据的类。它与 `viewLifecycleOwner` 相关联，因此仅在片段可以访问其视图时才活跃，并能接收实时数据通知。如果在片段无法访问其
    UI 时实时数据属性的值发生更改，则不会通知观察者，因此片段不会做出响应。这可以防止应用在试图更新不可用视图时崩溃。'
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: It also makes your coding life easier because you don’t need to check whether
    the view’s available for yourself. Using live data handles it all for you.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 它还可以让您的编码生活更轻松，因为您无需自行检查视图是否可用。使用实时数据，这一切都由它处理。
- en: 'The `Observer` class accepts a lambda parameter, which specifies how the property’s
    new value should be used. In the Guessing Game app, for example, we want `GameFragment`
    to update its `lives` text each time the view model’s `livesLeft` property gets
    updated, and we can achieve this using the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer` 类接受一个 lambda 参数，指定属性的新值应如何使用。例如，在猜词游戏应用中，我们希望 `GameFragment` 每当视图模型的
    `livesLeft` 属性更新时更新其 `lives` 文本，我们可以通过以下代码实现：'
- en: '![image](Images/f0492-04.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0492-04.png)'
- en: That’s everything that we need to know in order to make `GameFragment` update
    its views when the view model property values get changed. Let’s update its code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们需要知道的一切，以便在视图模型属性值更改时使 `GameFragment` 更新其视图。让我们更新其代码。
- en: The full code for GameFragment.kt
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GameFragment.kt` 的完整代码'
- en: 'Here’s the updated code for `GameFragment`; make sure that the file *GameFragment.kt*
    includes the changes shown below (in bold):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `GameFragment` 的更新代码；确保 *GameFragment.kt* 文件包含下面显示的更改（用粗体显示）：
- en: '![image](Images/f0493-02.png)![image](Images/f0494-02.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0493-02.png)![image](Images/f0494-02.png)'
- en: Those are all the changes we need to make to `GameFragment` so that it updates
    its views each time it observes changes to the `incorrectGuesses`, `livesLeft`,
    and `secretWordDisplay` properties.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是我们需要对 `GameFragment` 进行的所有更改，以便在观察到 `incorrectGuesses`、`livesLeft` 和 `secretWordDisplay`
    属性更改时更新其视图。
- en: We’ve now implemented live data in the Guessing Game app Let’s go through what
    happens when the app runs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在猜词游戏应用中实现了实时数据，让我们看看应用运行时会发生什么。
- en: '![image](Images/f0495-02.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0495-02.png)'
- en: '**ResultViewModel doesn’t need to use live data, so we don’t need to update
    it.**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ResultViewModel` 不需要使用实时数据，因此我们无需更新它。**'
- en: 'As you may recall, `ResultViewModel` has one property (named `result`), which
    gets set when the view model gets created. The code looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能记得的那样，`ResultViewModel` 有一个属性（名为 `result`），该属性在视图模型创建时设置。代码如下所示：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, result is defined using `val`, so once it’s been initialized,
    it can’t be updated to another value. `ResultFragment` doesn’t need to be notified
    when `result` changes because **once set,** `**result**` **can never change**.
    There’s no need to make `ResultFragment` respond to any changes, because there
    can’t be any.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，结果是使用 `val` 定义的，因此一旦初始化，就无法将其更新为另一个值。`ResultFragment` 在 `result` 更改时无需通知，因为
    **一旦设置**，`**result**` **就无法更改**。无需使 `ResultFragment` 响应任何更改，因为不会有任何更改。
- en: So let’s walk through what happens when the code runs, and then take the app
    for a test drive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解代码运行时发生了什么，然后进行一次应用程序的测试驾驶。
- en: What happens when the app runs
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序运行时会发生什么
- en: 'The following things happen when the app runs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行时会发生以下情况：
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment 请求 `ViewModelProvider` 类获取 `GameViewModel` 的实例。**'
- en: The `GameViewModel` object is initialized, and the values of its three `MutableLiveData`
    properties—`livesLeft`, `incorrectGuesses`, and `secretWordDisplay`—are set.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameViewModel` 对象被初始化，并设置了其三个 `MutableLiveData` 属性的值 — `livesLeft`、`incorrectGuesses`
    和 `secretWordDisplay`。'
- en: '![image](Images/f0496-02.png)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0496-02.png)'
- en: '**GameFragment observes the livesLeft, incorrectGuesses, and secretWordDisplay
    properties in the GameViewModel.**'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment 观察 `GameViewModel` 中的 `livesLeft`、`incorrectGuesses` 和 `secretWordDisplay`
    属性。**'
- en: '![image](Images/f0496-03.png)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0496-03.png)'
- en: '**GameFragment updates its views with the values of the properties it’s observing.**'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment 使用其观察的属性的值更新其视图。**'
- en: '![image](Images/f0496-04.png)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0496-04.png)'
- en: '**When the user makes a correct guess, secretWordDisplay’s value is updated,
    and the new value is passed to GameFragment.**'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当用户猜对时，将更新 `secretWordDisplay` 的值，并将新值传递给 `GameFragment`。**'
- en: '`GameFragment` responds by updating its `word` view, which is displayed on
    the screen.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameFragment` 通过更新其在屏幕上显示的 `word` 视图做出响应。'
- en: '![image](Images/f0497-02.png)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0497-02.png)'
- en: '**When the user makes an incorrect guess, the values for incorrectGuesses and
    livesLeft are updated, and passed to GameFragment.**'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当用户猜错时，更新 `incorrectGuesses` 和 `livesLeft` 的值，并传递给 `GameFragment`。**'
- en: '`GameFragment` responds by updating its views.'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameFragment` 通过更新其视图做出响应。'
- en: '![image](Images/f0497-03.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0497-03.png)'
- en: '**When isWon() or isLost() return true, GameFragment navigates to ResultFragment,
    passing it the result.**'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**当 `isWon()` 或 `isLost()` 返回 true 时，`GameFragment` 导航到 `ResultFragment`，并将结果传递给它。**'
- en: '`ResultFragment` displays the result.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`ResultFragment` 显示结果。'
- en: '![image](Images/f0497-04.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0497-04.png)'
- en: Let’s take the app for a test drive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们带着这个应用程序来进行一次测试驾驶。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: When we run the app, `GameFragment` is displayed as before.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用程序时，`GameFragment` 如以前一样显示。
- en: When we make a correct guess, the secret word display gets updated. When we
    make an incorrect guess, the lives left is updated, and our guess is added to
    the incorrect guesses display.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们猜对时，秘密单词显示会更新。当我们猜错时，生命剩余将更新，并且我们的猜测将添加到错误的猜测显示中。
- en: If we guess all the letters or lose all our lives, the app navigates to `ResultFragment`,
    which displays the result.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们猜中所有字母或失去所有生命，应用程序将导航到 `ResultFragment`，显示结果。
- en: '![image](Images/f0498-02.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0498-02.png)'
- en: The game behaves in the same way as before, but behind the scenes, it responds
    using live data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的行为方式与以往相同，但在幕后，它使用实时数据做出响应。
- en: Fragments can update GameViewModel’s properties
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fragment 可以更新 `GameViewModel` 的属性。
- en: So far, we’ve updated the code in `GameViewModel` and `GameFragment` so that
    it uses live data. Each time the value of a `MutableLiveData` property in `GameViewModel`
    gets updated, `GameFragment` responds by updating its views.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经更新了 `GameViewModel` 和 `GameFragment` 中的代码，以便它使用实时数据。每当 `GameViewModel`
    中的 `MutableLiveData` 属性的值更新时，`GameFragment` 通过更新其视图做出响应。
- en: There’s a slight problem with the code, however. `GameFragment` has full access
    to `GameViewModel`’s properties and methods, so if it wanted to, it could use
    them inappropriately. There’s nothing to stop the fragment from, say, updating
    the `livesLeft` property to 100 so that the user can make many more guesses and
    win the game each time she plays.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 但代码中存在一个小问题。`GameFragment` 具有对 `GameViewModel` 属性和方法的完全访问权限，因此如果它愿意，它可以不适当地使用它们。没有什么可以阻止
    fragment，例如将 `livesLeft` 属性更新为 100，以便用户可以每次玩游戏时都进行许多猜测并赢得游戏。
- en: To get around this problem, we’re going to restrict direct access to the `GameViewModel`’s
    properties so that **only methods in the view model can update them**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将限制对 `GameViewModel` 属性的直接访问，使得**只有视图模型中的方法可以更新它们**。
- en: '**You can restrict direct access to a view model’s property by marking it private,
    and providing read-only access via another property’s getter.**'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**您可以通过将视图模型的属性标记为私有，并通过另一个属性的 getter 提供只读访问来限制对视图模型属性的直接访问。**'
- en: Keep your privates private
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持私密内容私密
- en: 'To protect `GameViewModel`’s properties, we’ll mark each one as `private` so
    that only code in `GameViewModel` can update their values. We’ll then expose a
    *read-only version* of each `MutableLiveData` property that `GameFragment` needs
    to observe. Instead of defining the `livesLeft` property using code like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护 `GameViewModel` 的属性，我们将每个属性标记为 `private`，以便只有 `GameViewModel` 中的代码可以更新它们的值。然后，我们将暴露每个
    `MutableLiveData` 属性的只读版本，供 `GameFragment` 观察。而不是像这样定义 `livesLeft` 属性的代码：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'we’ll use the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下内容：
- en: '![image](Images/f0501-01.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0501-01.png)'
- en: Here, the `_livesLeft` property holds a reference to a `MutableLiveData` object.
    `GameFragment` doesn’t have access to this property because it’s marked as `private`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_livesLeft` 属性持有对 `MutableLiveData` 对象的引用。 `GameFragment` 无法访问此属性，因为它标记为
    `private`。
- en: '`GameFragment` can, however, access the value of this property using `livesLeft`’s
    getter. `livesLeft`’s type is `**LiveData**`, which is like `MutableLiveData`
    except that it can’t be used to update the underlying object’s `value` property:
    `GamesFragment` can read the value, but it can’t update it.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，`GameFragment` 可以通过 `livesLeft` 的 getter 访问此属性的值。 `livesLeft` 的类型是 `**LiveData**`，类似于
    `MutableLiveData`，但无法用于更新底层对象的 `value` 属性：`GamesFragment` 可以读取值，但无法更新它。
- en: When you structure your code in this way, the private property is sometimes
    called a **backing property**. It holds a reference to an object that other classes
    only have access to via another property.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 当您以这种方式组织代码时，私有属性有时称为**支持属性**。它持有一个对象的引用，其他类只能通过另一个属性访问该对象。
- en: Let’s update the `GameViewModel` code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更新 `GameViewModel` 的代码。
- en: '![image](Images/f0501-02.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0501-02.png)'
- en: The full code for GameViewModel.kt
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`GameViewModel.kt` 的完整代码如下：'
- en: '![image](Images/f0502-01.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0502-01.png)'
- en: We’ll update the code for `GameViewModel` so that it uses backing properties
    to restrict direct access to its live data properties. We’ll also mark as private
    any properties and methods that `GameFragment` doesn’t need to use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新 `GameViewModel` 的代码，以使用支持属性来限制直接访问其 LiveData 属性。我们还将将 `GameFragment` 不需要使用的属性和方法标记为私有。
- en: 'Here’s the full code for *GameViewModel.kt*; update the code to include our
    changes (in bold):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '*GameViewModel.kt* 的完整代码如下；更新代码以包括我们的更改（用粗体标出）：'
- en: '![image](Images/f0502-02.png)![image](Images/f0503-02.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0502-02.png)![image](Images/f0503-02.png)'
- en: Let’s go through what happens when the code runs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步了解代码运行时发生了什么。
- en: What happens when the app runs
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 当应用程序运行时会发生什么
- en: 'The following things happen when the app runs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序运行时会发生以下事情：
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment 请求 `ViewModelProvider` 类获取 `GameViewModel` 实例。**'
- en: '![image](Images/f0504-02.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0504-02.png)'
- en: '**GameViewModel’s properties are initialized.**'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameViewModel 的属性已初始化。**'
- en: '`livesLeft`, `incorrectGuesses`, and `secretWordDisplay` are `LiveData` properties
    that refer to the same underlying objects as their `MutableLiveData` backing properties.'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`livesLeft`、`incorrectGuesses` 和 `secretWordDisplay` 是指向与其 `MutableLiveData`
    支持属性相同底层对象的 `LiveData` 属性。'
- en: '![image](Images/f0504-03.png)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0504-03.png)'
- en: '**GameFragment observes the livesLeft, incorrectGuesses, and secretWordDisplay
    properties.**'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment 观察 `livesLeft`、`incorrectGuesses` 和 `secretWordDisplay` 属性。**'
- en: '`GameFragment` can’t update any of these properties, but it responds when `GameViewModel`
    updates any of the backing properties because they refer to the same underlying
    object.'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameFragment` 无法更新任何这些属性，但在 `GameViewModel` 更新任何支持属性时会作出响应，因为它们引用相同的底层对象。'
- en: '![image](Images/f0504-04.png)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0504-04.png)'
- en: '**GameFragment continues to respond to value changes until isWon() or isLost()
    returns true.**'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment 在 `isWon()` 或 `isLost()` 返回 true 之前继续响应值的更改。**'
- en: '`GameFragment` navigates to `ResultFragment`, passing it the result. `ResultFragment`
    displays the result.'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameFragment` 导航到 `ResultFragment`，并将结果传递给它。 `ResultFragment` 显示结果。'
- en: '![image](Images/f0505-01.png)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0505-01.png)'
- en: Let’s take the app for a test drive.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来测试这个应用程序。
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: '![image](Images/f0505-02.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0505-02.png)'
- en: When we run the app, it works in the same way as before. This time, however,
    we’ve protected `GameViewModel`’s `MutableLiveData` properties by restricting
    `GameFragment`’s access to them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用程序时，它的工作方式与以前相同。但是，这一次我们通过限制 `GameFragment` 对 `GameViewModel` 的 `MutableLiveData`
    属性的访问来保护了它们。
- en: '![image](Images/f0505-03.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0505-03.png)'
- en: We’ve nearly finished updating the Guessing Game app. There’s just one more
    thing we need to change...
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了更新猜词游戏应用程序的工作。只剩下一件事需要改变…
- en: GameFragment still includes game logic
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameFragment 仍然包含游戏逻辑
- en: '![image](Images/f0506-01.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0506-01.png)'
- en: In the current version of the app, `GameFragment` decides when the game is finished
    by calling `GameViewModel`’s `isWon()` and `isLost()` methods after the user has
    made each guess. If either of these returns *true*, `GameFragment` navigates to
    `ResultFragment`, passing it the result.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用的当前版本中，`GameFragment` 在用户每次猜测后调用 `GameViewModel` 的 `isWon()` 和 `isLost()`
    方法来决定游戏是否结束。如果其中任何一个返回 *true*，`GameFragment` 将导航到 `ResultFragment`，并将结果传递给它。
- en: 'Here’s the current code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是当前的代码：
- en: '![image](Images/f0506-02.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0506-02.png)'
- en: The problem with this approach is that `GameFragment` decides when the game
    is over instead of `GameViewModel`. As determining when the game has finished
    is a game decision, it’s something that `GameViewModel` should be responsible
    for, not `GameFragment`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于 `GameFragment` 决定游戏何时结束，而不是 `GameViewModel`。确定游戏何时结束是一项游戏决策，这是 `GameViewModel`
    应该负责的，而不是 `GameFragment`。
- en: Make GameViewModel decide when the game is over
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让 `GameViewModel` 决定游戏何时结束
- en: To deal with this, we’ll add a `MutableLiveData<Boolean>` property named `_gameOver`
    to `GameViewModel`, whose value we’ll expose using a `LiveData` property named
    `gameOver`. We’ll set this property to *true* when the user wins or loses the
    game. When this happens, `GameFragment` will respond by navigating to `ResultFragment`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们将在 `GameViewModel` 中添加一个名为 `_gameOver` 的 `MutableLiveData<Boolean>`
    属性，并将其值通过名为 `gameOver` 的 `LiveData` 属性暴露出来。当用户赢得或输掉游戏时，我们将设置此属性为 *true*。在这种情况下，`GameFragment`
    将响应并导航到 `ResultFragment`。
- en: '![image](Images/f0506-03.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0506-03.png)'
- en: You’re already familiar with the changes that are required to do this, so before
    we show you the code, try the following exercise.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉所需的更改，因此在向您显示代码之前，请尝试以下练习。
- en: Pool Puzzle
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池塘难题
- en: '![image](Images/common01.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common01.png)'
- en: Your **goal** is to add a `gameOver` property (with a `_gameOver` backing property)
    to `GameViewModel` so that `GameFragment` can respond when its value (a `Boolean`)
    gets updated. The property should be initialized with a value of *false*. Take
    code snippets from the pool and place them into the blank lines in the code. You
    may **not** use the same snippet more than once, and you won’t need to use all
    the snippets.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 您的**目标**是向 `GameViewModel` 添加一个名为 `gameOver` 的属性（带有 `_gameOver` 支持属性），以便 `GameFragment`
    在其值（一个 `Boolean`）更新时作出响应。该属性应初始化为 *false*。从池中获取代码片段并将其放入代码中的空白行。您不可以多次使用同一代码片段，并且不需要使用所有代码片段。
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![image](Images/f0507-01.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0507-01.png)'
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '**Note: each thing from the pool can only be used once!**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**注意：每个池中的事物只能使用一次！**'
- en: Pool Puzzle Solution
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 池塘难题解答
- en: '![image](Images/common01.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common01.png)'
- en: Your **goal** is to add a `gameOver` property (with a `_gameOver` backing property)
    to `GameViewModel` so that `GameFragment` can respond when its value (a `Boolean`)
    gets updated. The property should be initialized with a value of *false*. Take
    code snippets from the pool and place them into the blank lines in the code. You
    may **not** use the same snippet more than once, and you won’t need to use all
    the snippets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 您的**目标**是向 `GameViewModel` 添加一个名为 `gameOver` 的属性（带有 `_gameOver` 支持属性），以便 `GameFragment`
    在其值（一个 `Boolean`）更新时作出响应。该属性应初始化为 *false*。从池中获取代码片段并将其放入代码中的空白行。您不可以多次使用同一代码片段，并且不需要使用所有代码片段。
- en: '![image](Images/f0508-01.png)![image](Images/f0508-02.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0508-01.png)![image](Images/f0508-02.png)'
- en: The full code for GameViewModel.kt
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GameViewModel.kt 的完整代码
- en: We need to add a `gameOver` property to `GameViewModel`, along with a `_gameOver`
    backing property. We’ll get the `makeGuess()` method to set it to *true* when
    the user has guessed all of the letters in the secret word, or run out of lives.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `GameViewModel` 中添加一个名为 `gameOver` 的属性，以及一个名为 `_gameOver` 的支持属性。当用户猜对了秘密单词中的所有字母或者耗尽生命时，我们将让
    `makeGuess()` 方法将其设置为 *true*。
- en: 'Here’s the full code for `GameViewModel`; update the code in *GameViewModel.kt*
    to include the changes shown below (in bold):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`GameViewModel`的完整代码；更新*GameViewModel.kt*中的代码以包括下面显示的更改（用粗体表示）：
- en: '![image](Images/f0509-02.png)![image](Images/f0510-02.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0509-02.png)![image](Images/f0510-02.png)'
- en: Make GameFragment observe the new property
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使GameFragment观察新属性
- en: Now that we’ve added the `gameOver` property to `GameViewModel`, we need to
    make `GameFragment` respond to when it’s been updated. We’ll make the fragment
    observe the property, so that when its value is changed to *true*, the fragment
    will navigate to `ResultFragment`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将`gameOver`属性添加到`GameViewModel`中，我们需要使`GameFragment`响应其更新。我们将使片段观察该属性，因此当其值更改为*true*时，片段将导航到`ResultFragment`。
- en: 'Here’s the code for `GameFragment`; update the code in *GameFragment.kt* so
    that it includes the changes below (in bold):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`GameFragment`的代码；更新*GameFragment.kt*中的代码，以包括以下更改（用粗体表示）：
- en: '![image](Images/f0511-01.png)![image](Images/f0512-02.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0511-01.png)![image](Images/f0512-02.png)'
- en: That’s it! Let’s go through what happens when it runs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样！让我们来看看运行时会发生什么。
- en: What happens when the app runs
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序运行时发生了什么
- en: 'The following things happen when the app runs:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行时会发生以下事情：
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment请求ViewModelProvider类提供GameViewModel的实例。**'
- en: '![image](Images/f0513-02.png)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0513-02.png)'
- en: '**GameViewModel’s properties are initialized.**'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameViewModel的属性已初始化。**'
- en: The `_gameOver` and `gameOver` properties refer to a `MutableLiveData<Boolean>`
    object whose value is set to *false*.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`_gameOver`和`gameOver`属性指向一个`MutableLiveData<Boolean>`对象，其值设置为*false*。'
- en: '![image](Images/f0513-03.png)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0513-03.png)'
- en: '**GameFragment observes the GameViewModel’s gameOver property.**'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment观察GameViewModel的gameOver属性。**'
- en: '`GameFragment` can’t update the `MutableLiveData` object that the `gameOver`
    property refers to, but it can respond to when its value changes.'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameFragment`无法更新`gameOver`属性引用的`MutableLiveData`对象，但可以响应其值变化。'
- en: '![image](Images/f0513-04.png)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0513-04.png)'
- en: '**Each time the GameViewModel’s makeGuess() method is called, it checks whether
    isWon() or isLost() returns true.**'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**每次调用GameViewModel的makeGuess()方法时，它都会检查isWon()或isLost()是否返回true。**'
- en: If either is *true*, it sets the value of its `_gameOver` property to *true*.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果其中任何一个*true*，它将其`_gameOver`属性的值设置为*true*。
- en: '![image](Images/f0514-02.png)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0514-02.png)'
- en: '**GameFragment observes the value has been updated to true via the GameViewModel’s
    gameOver property.**'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment观察到通过GameViewModel的gameOver属性，值已更新为true。**'
- en: The new value is passed to `GameFragment`.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 新值传递给`GameFragment`。
- en: '![image](Images/f0514-03.png)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0514-03.png)'
- en: '**GameFragment responds by navigating to ResultFragment, passing it the result.**'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**GameFragment响应并导航到ResultFragment，并将结果传递给它。**'
- en: '![image](Images/f0514-04.png)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![image](Images/f0514-04.png)'
- en: We’ll take the app for a test drive after the following exercise.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在进行以下练习后，我们将测试驾驶这个应用程序。
- en: Fragment Magnets
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段磁铁
- en: '![image](Images/common02.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common02.png)'
- en: Somebody wrote the code for a fragment named `LotteryFragment` on the fridge
    door, but a freak kitchen blizzard blew some of the code away. Can you piece it
    back together again?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有人在冰箱门上为名为`LotteryFragment`的片段编写了代码，但一个怪异的厨房暴风雪把一些代码吹走了。你能把它重新拼起来吗？
- en: 'The fragment needs to observe `LotteryViewModel`’s `winningNumbers` property,
    which is defined like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 片段需要观察`LotteryViewModel`的`winningNumbers`属性，其定义如下：
- en: '[PRE9]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When `winningNumbers` changes, `LotteryFragment` needs to update its `numbers`
    view with the new value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当`winningNumbers`变化时，`LotteryFragment`需要使用新值更新其`numbers`视图。
- en: '![image](Images/f0515-01.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0515-01.png)'
- en: Fragment Magnets Solution
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段磁铁解决方案
- en: '![image](Images/common02.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/common02.png)'
- en: Somebody wrote the code for a fragment named `LotteryFragment` on the fridge
    door, but a freak kitchen blizzard blew some of the code away. Can you piece it
    back together again?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 有人在冰箱门上为名为`LotteryFragment`的片段编写了代码，但一个怪异的厨房暴风雪把一些代码吹走了。你能把它重新拼起来吗？
- en: 'The fragment needs to observe `LotteryViewModel`’s `winningNumbers` property,
    which is defined like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 片段需要观察`LotteryViewModel`的`winningNumbers`属性，其定义如下：
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When `winningNumbers` changes, `LotteryFragment` needs to update its `numbers`
    view with the new value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当`winningNumbers`变化时，`LotteryFragment`需要使用新值更新其`numbers`视图。
- en: '![image](Images/f0516-01.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0516-01.png)'
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '![Images](Images/car.png) 测试驾驶'
- en: '![image](Images/f0517-01.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![image](Images/f0517-01.png)'
- en: When we run the app, it works in the same way as before. This time, however,
    `GameViewModel` decides when the game is over instead of `GameFragment`. The fragment
    simply observes the view model’s `gameOver` property, and navigates to `ResultFragment`
    when it’s changed to *true*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行应用时，它的工作方式与以往相同。然而，这一次，`GameViewModel`决定游戏何时结束，而不是`GameFragment`。该片段只需观察视图模型的`gameOver`属性，并在其更改为*true*时导航到`ResultFragment`。
- en: '![image](Images/f0517-02.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0517-02.png)'
- en: Congratulations! You’ve now built an app that uses live data to respond to changes
    as and when they occur. In the next chapter, we’ll build on this still further
    using a new technique called data binding.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！您现在已经构建了一个应用程序，使用实时数据在发生更改时进行响应。在下一章中，我们将进一步使用一种称为数据绑定的新技术。
- en: Your Android Toolbox
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的Android工具箱
- en: '![image](Images/tools.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/tools.png)'
- en: '**You’ve got [Chapter 12](#live_datacolon_leaping_into_action) under your belt
    and now you’ve added live data to your toolbox.**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**您已经掌握了[第12章](#live_datacolon_leaping_into_action)，现在您的工具箱中添加了实时数据。**'
- en: '![image](Images/f0518-01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片](Images/f0518-01.png)'
