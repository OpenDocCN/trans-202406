- en: 'Chapter 13\. Data Binding: *Building Smart Layouts*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0519-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Layouts can do more than control your app’s appearance.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the layouts you’ve written so far have been told how they should behave
    by activity or fragment code. But just imagine if **the layouts could think for
    themselves**, and **make their own decisions**. In this chapter, we’ll introduce
    you to **data binding**: a way of **boosting your layout’s IQ**. You’ll find out
    **how to make views get values** directly from the view model. You’ll use **listener
    binding** to make buttons call their methods. You’ll even discover how **one simple
    line of code lets views respond to live data updates**. Soon, your layouts will
    be more powerful than ever before.'
  prefs: []
  type: TYPE_NORMAL
- en: Back to the Guessing Game app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, you built a Guessing Game app that lets the user
    guess which letters are included in a secret word. When the user guesses all the
    letters or runs out of lives, the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app uses two view models—`GameViewModel` and `ResultViewModel`—which hold
    the app’s game logic and data, and maintain its state when the app is rotated.
    `GameViewModel` is used by `GameFragment`, and `ResultViewModel` is used by `ResultFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0520-01.png)'
  prefs: []
  type: TYPE_IMG
- en: The first screen the user sees is `GameFragment`, and she interacts with it
    to play the game. It displays information—such as the number of lives left and
    any incorrect guesses the user has made—and lets the user make guesses.
  prefs: []
  type: TYPE_NORMAL
- en: When the game is over, the app navigates to `ResultFragment`. This screen tells
    the user whether she has won or lost the game, and what the secret word was.
  prefs: []
  type: TYPE_NORMAL
- en: The fragments update the views in their layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Each of the app’s fragments are responsible for updating the views in their
    layouts. `ResultFragment`, for example, sets the text in its `won_lost` text view
    to the value of `ResultViewModel`’s `result` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0521-01.png)'
  prefs: []
  type: TYPE_IMG
- en: But while this approach works, it has a downside. When you make fragments responsible
    for keeping views up-to-date in this way, it can make your Kotlin code more complicated,
    and harder to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: So what’s the alternative?
  prefs: []
  type: TYPE_NORMAL
- en: We can make the views update themselves instead
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The alternative is to use a technique called **data binding**. With data binding,
    **views can get their values directly from the view model**, so the fragment code
    no longer has to keep them updated. Instead of using code in `ResultFragment`
    to update the text in the `won_lost` text view, for example, we can use data binding
    to make the view get its text directly from `ResultViewModel`’s `result` property.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0521-02.png)![image](Images/f0521-03.png)'
  prefs: []
  type: TYPE_IMG
- en: In this chapter, you’ll learn how to use data binding by implementing it in
    the Guessing Game app. Let’s go through the steps we’ll take to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what we’re going to do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the steps that we’ll go through to make the Guessing Game app use
    data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implement data binding for ResultFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll update `ResultFragment` so that its layout uses data binding to display
    the value of the `result` property directly from `ResultViewModel`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0522-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Implement data binding for GameFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll then change up `GameFragment` so that its layout uses data binding to
    display property values from `GameViewModel`. Along the way, we’ll also make the
    layout dynamically respond to any live data updates.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0522-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add a Finish Game button to GameFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we’ll add a new button to `GameFragment`’s layout that, when clicked,
    immediately finishes the game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0522-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![image](Images/f0522-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Enable data binding in the app build.gradle file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0523-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Just like with view binding, you need to enable data binding in the `android`
    section of the app’s *build.gradle* file before you can use it in your app. The
    code to enable data binding looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0523-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’ve already enabled view binding in the Guessing Game app, so let’s enable
    data binding too. Open the file *GuessingGame/app/build.gradle*, and update the
    `buildFeatures` section so that it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0523-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Then choose the Sync Now option to sync this change with the rest of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve enabled data binding, let’s implement it in `ResultFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: ResultFragment updates the text in its layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may recall, `ResultFragment`’s layout contains a text view with an ID
    of `won_lost`, which is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0524-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'When the app navigates to `ResultFragment`, the fragment gets the value of
    the `result` property from its view model, and displays it in the text view using
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0524-03.png)'
  prefs: []
  type: TYPE_IMG
- en: We’re going to change the fragment and its layout so that it uses data binding.
    Instead of getting `ResultFragment` to update the text view, we’ll make the text
    view get its value directly from the view model.
  prefs: []
  type: TYPE_NORMAL
- en: How we’ll implement data binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make the text view get its text from `ResultViewModel`, we need to update
    the code for `ResultFragment` and its layout. We’ll do this by going through the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add <layout> and <data> elements to the layout.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `<layout>` element is required for data binding, and the `<data>` element
    is used to set up a data binding variable that links the layout to the view model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Set the layout’s data binding variable to an instance of the view model.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll do this using fragment code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Use the data binding variable to access the view model’s properties.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll update the `won_lost` text view so that it gets its text value directly
    from the view model.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let’s begin by updating the layout code.
  prefs: []
  type: TYPE_NORMAL
- en: 1\. Add <layout> and <data> elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every layout that uses data binding takes the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0525-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The above layout has a `**<layout>**` element as its root element. This enables
    data binding in the layout, so it’s required by *all* layouts that need to use
    data binding.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `<layout>` element sits a `**<data>**` element. This is used to
    specify any variables—defined using the `**<variable>**` element—that are needed
    for data binding, such as the view model you want the layout’s views to gets their
    data from. The above code, for example, uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0525-03.png)'
  prefs: []
  type: TYPE_IMG
- en: to specify a data binding variable named `resultViewModel` whose type is `ResultViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: The `<layout>` element also includes a view or view group for the layout’s view
    hierarchy. If you want to display views in a linear layout, for example, you’d
    put the `<LinearLayout>` element and its views inside the `<layout>` element along
    with all of its views. You’ll see how this is done a few pages ahead.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve defined a data binding variable, you need to set it. We’ll see how
    to do this next.
  prefs: []
  type: TYPE_NORMAL
- en: 2\. Set the layout’s data binding variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You set the layout’s data binding variable using Kotlin code.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the previous page, we showed you the code to add a data binding variable
    (named `resultViewModel`) to `ResultFragment`’s layout file *fragment_result.xml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The variable’s type is `ResultViewModel`, so we need to set it to an object
    with a matching type.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall, `ResultFragment` includes code in its `onCreateView()` method
    that gets a `ResultViewModel` object like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0526-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can assign this view model to the layout’s `resultViewModel` data binding
    variable by adding the following line to the `onCreateView()` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0526-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This uses the fragment’s `binding` property to set the layout’s `resultViewModel`
    property to the fragment’s view model object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0526-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Once you’ve set the data binding variable, the layout can use it to access the
    view model’s properties and methods. Let’s see how.
  prefs: []
  type: TYPE_NORMAL
- en: 3\. Use the layout’s data binding variable to access the view model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ResultFragment`’s layout defines a `won_lost` text view that needs to display
    the value of `ResultViewModel`’s `result` property. Its text is set in the fragment
    code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0527-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we’ve set a data binding variable for this view model in the layout
    code, we can use data binding to set its text instead. The code to do so looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0527-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The above code uses the `resultViewModel` variable to get the value of the view
    model’s `result` property. It then sets the text view’s text to the value of this
    property.
  prefs: []
  type: TYPE_NORMAL
- en: That’s everything that you need to know in order to implement data binding for
    `ResultFragment`. We’ll show you the full code for *result_fragment.xml* and *ResultFragment.kt*
    over the next couple pages.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for fragment_result.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for `ResultFragment`’s layout; update the code for *fragment_result.xml*
    to include the changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0528-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The full code for ResultFragment.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to update the fragment code too. Update the code for *ResultFragment.kt*
    so that it includes the changes shown here (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0529-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s go through what happens when the app runs.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**When the user completes a game, the app navigates to ResultFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0530-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**ResultFragment gets a reference to its ResultViewModel object.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0530-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**ResultFragment assigns the ResultViewModel object to the layout’s resultViewModel
    data binding variable.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout’s views can now use the variable to access the view model’s properties
    and methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0530-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The won_lost view’s text is set to the value of the ResultViewModel object’s
    result property.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The text is displayed on the device screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0530-05.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s take the app for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run the app, it works in the same way as before. This time, however,
    `ResultFragment`’s layout is getting the game’s result directly from `ResultViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0531-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve now implemented data binding in `ResultFragment`. Before we apply it to
    `GameFragment`, let’s take a closer look at the `<layout>` element, and why it’s
    necessary for data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Layout Magnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  prefs: []
  type: TYPE_IMG
- en: Somebody wrote the code for a layout using fridge magnets, but some of them
    fell off when we shut the fridge door too firmly. Can you piece the code back
    together again?
  prefs: []
  type: TYPE_NORMAL
- en: The layout needs to use data binding to display the `welcomeText` property from
    a `MyViewModel` object in its `welcome` text view. The view model resides in a
    package named `com.hfad.myapp.MyViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0533-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Layout Magnets Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  prefs: []
  type: TYPE_IMG
- en: Somebody wrote the code for a layout using fridge magnets, but some of them
    fell off when we shut the fridge door too firmly. Can you piece the code back
    together again?
  prefs: []
  type: TYPE_NORMAL
- en: The layout needs to use data binding to display the `welcomeText` property from
    a `MyViewModel` object in its `welcome` text view. The view model resides in a
    package named `com.hfad.myapp.MyViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0534-01.png)'
  prefs: []
  type: TYPE_IMG
- en: GameFragment can use data binding too
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0535-01.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ve now implemented data binding for `ResultFragment` so that the text view
    in its layout gets its text directly from `ResultViewModel`’s result property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll do a similar thing with `GameFragment`: we’ll implement data binding
    so that the text views in its layout get their values directly from `GameViewModel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0535-02.png)'
  prefs: []
  type: TYPE_IMG
- en: To do this, we need to update the code for `GameFragment` and its layout. We’ll
    begin with the layout code.
  prefs: []
  type: TYPE_NORMAL
- en: Add <layout> and <data> elements to fragment_game.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just as we did with `ResultFragment`, we’ll begin by adding `<layout>` and
    `<data>` elements to `GameFragment`’s layout. These elements specify that the
    layout uses data binding, and define a data binding variable. The code looks like
    this; update the code in *fragment_game.xml* to include these changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0536-02.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the code defines a data binding variable named `gameViewModel`
    whose type is `GameViewModel`. Before we set this variable in the fragment’s Kotlin
    code, let’s update the layout’s views so that they get their values from the view
    model.
  prefs: []
  type: TYPE_NORMAL
- en: Use the data binding variable to set the layout’s text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you learned earlier, views can get data directly from the view model using
    the layout’s data binding variable. *fragment_game.xml*’s `word` text view, for
    example, can display the value of `GameViewModel`’s `secretWordDisplay` property
    using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0537-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Two of the views need to show extra text
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `lives` and `incorrect_guesses` text views, however, don’t just display
    the property values: **they include extra text**. The `GameFragment` code, for
    example, currently sets the `incorrectGuesses` view’s text using this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0537-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'so we can’t simply use the view model’s `incorrectGuesses` property using the
    code below, or the extra text won’t be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0537-03.png)'
  prefs: []
  type: TYPE_IMG
- en: To get around this problem, we’ll use `String` formatting to pass the property
    value to a `String` resource. Let’s find out how.
  prefs: []
  type: TYPE_NORMAL
- en: String resources revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you learned earlier in the book, you can add `String` resources to your
    app’s `String` resource file to avoid using hardcoded text. The following code,
    for example, defines a `String` resource named `my_string` that displays the text
    “This is a String resource”:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0538-02.png)'
  prefs: []
  type: TYPE_IMG
- en: String resources can have arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also define `String` resources that accept one or more arguments, which
    is useful if you want to display more complex text. The following resource, for
    example, uses a `**%s**` placeholder to specify where to place a `String` argument
    that’s passed to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0538-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'and this one uses `**%d**` to say where a number argument should go:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0538-04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can pass multiple arguments to a `String` resource by numbering each one.
    The following resource, for example, takes a `String` as its first argument, and
    a number as its second:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0538-05.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Use %s for String arguments and %d for numbers.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Add two new String resources to strings.xml
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the Guessing Game app, we’ll define two new `String` resources: one for
    the number of lives left, and another for the incorrect guesses the user has made.
    Open the *strings.xml* file in the *app/src/main/res/values* folder, and add the
    two resources shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0538-06.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we’ve defined the two `String` resources, let’s use them in `GameFragment`’s
    layout.
  prefs: []
  type: TYPE_NORMAL
- en: The layout can pass parameters to String resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use the two `String` resources we just created, we need to pass
    each one a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'You pass parameters to `String` resources in your layout code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0539-01.png)'
  prefs: []
  type: TYPE_IMG
- en: where `string_name` is the name of the `String` resource, and `arg1` and `arg2`
    are two parameter values. `arg1` is passed to the `String`’s first argument, and
    `arg2` is passed to its second.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Guessing Game app, the `lives_left String` resource is defined using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'so we can use it to display the `livesLeft` property from `GameViewModel` using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0539-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, the `incorrect_guesses String` resource is defined using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'so we display the value of the `incorrectGuesses` property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0539-03.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s everything that we need to know in order to change `GameFragment`’s layout
    so that it uses data binding. Let’s see what the full code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for fragment_game.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0540-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the full code for `GameFragment`’s layout; update the code for *fragment_game.xml*
    to include the changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0540-02.png)![image](Images/f0541-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s all the code we need to change in the layout file. Before we take the
    app for a test drive, however, we first need to update the corresponding fragment
    code in *GameFragment.kt*.
  prefs: []
  type: TYPE_NORMAL
- en: We need to set the gameViewModel variable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first change we need to make to the `GameFragment` code is to set the layout’s
    data binding variable `gameViewModel` to an instance of the fragment’s view model.
  prefs: []
  type: TYPE_NORMAL
- en: '`GameFragment` currently includes the following line in its `onCreateView()`
    method, which uses the view model provider to get a `GameViewModel` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can therefore assign this view model to the `gameViewModel` data binding
    variable by adding the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once the `gameViewModel` variable is linked to the view model in this way, the
    layout’s views can use it to get their values.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0542-02.png)'
  prefs: []
  type: TYPE_IMG
- en: We also need to make the data binding use live data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as setting the `gameViewModel` variable, we need to make the layout’s
    data binding work with live data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike `ResultViewModel`, the `GameViewModel` code uses live data so that when
    its property values are updated, the `GameFragment` code responds. The following
    code in *GameFragment.kt*, for example, observes the `incorrectGuesses` property,
    and updates the `incorrect_guesses` view when it’s updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As we’re now using data binding, we can make each view respond to live data
    changes by adding the following line to the fragment code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Each time a live data property value in the view model gets updated, the layout
    no longer has to rely on the fragment code updating its views. The layout can
    respond to any updates without any further intervention from the fragment.
  prefs: []
  type: TYPE_NORMAL
- en: That’s everything that we need to know in order to update the `GameFragment`
    code. Let’s see what it looks like.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0542-03.png)'
  prefs: []
  type: TYPE_IMG
- en: The full code for GameFragment.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the full code for `GameFragment`; update the code for *GameFragment.kt*
    so that it includes the changes shown here (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0543-02.png)![image](Images/f0544-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Those are all the changes we need to make to `GameFragment`. Let’s run through
    what happens when the code runs, and take the app for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment gets a reference to its GameViewModel object.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0545-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment assigns the GameViewModel object to the layout’s gameViewModel
    data binding variable.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout’s views can now use this variable to access the view model’s properties
    and methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0545-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment sets the layout’s lifecycle owner.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout can now observe the view model’s live data properties and respond
    to any changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0545-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user makes a correct guess, the GameViewModel object’s secretWordDisplay
    property gets updated.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout observes this change and its `word` view displays the new text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0546-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user makes an incorrect guess, the GameViewModel object’s livesLeft
    and incorrectGuesses properties are updated.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout observes the changes and its corresponding views display the new
    text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0546-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the game is over, GameFragment navigates to ResultFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0546-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run the app, it works in the same way as before. This time, however,
    `GameFragment` uses data binding to get property values directly from `GameViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0547-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/arr.png) **Answers in [“![Images](Images/pencil.png) Sharpen
    your pencil Solution”](#sharpen_your_pencil_solution-id00212).**'
  prefs: []
  type: TYPE_NORMAL
- en: You can use data binding to call methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0549-01.png)'
  prefs: []
  type: TYPE_IMG
- en: So far, you’ve implemented data binding so that views get their values directly
    from the view model instead of relying on fragment code.
  prefs: []
  type: TYPE_NORMAL
- en: Another way in which you can use data binding is to make a button call a method
    in the view model *without writing any extra fragment code*. To see how this works,
    we’re going to add a new Finish Game button to `GameFragment`’s layout that, when
    clicked, will finish the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the new version of the screen will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0549-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make the new button finish the game, we’ll do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Add a new finishGame() method to GameViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This method will set the view model’s `_gameOver` property to *true*. When this
    happens, the existing code in `GameFragment` will respond by navigating to `ResultFragment`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Add the new button to the layout and make it call finishGame().**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The button will call the method using data binding.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We’ll begin by updating the `GameViewModel` code.
  prefs: []
  type: TYPE_NORMAL
- en: Add finishGame() to GameViewModel.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add a new `finishGame()` method to the `GameViewModel` code that
    sets the value of `_gameOver` to *true*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know how to do this, so here’s the new code for *GameViewModel.kt*;
    make sure that you update the code to include the new method (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0550-02.png)![image](Images/f0551-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s all the `GameViewModel` code we need to add. Next, we’ll add the new
    Finish Game button to `GameFragment`’s layout, and make it call the `finishGame()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Use data binding to make a button call a method when clicked
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we said earlier, you can use data binding to make a button call a method
    in its view model without writing any extra fragment code. To do this, you add
    an `**android:onClick**` attribute to the button, and set its value to an expression
    that calls the method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Guessing Game app, we want to add a new button to `GameFragment`’s layout
    that calls `GameViewModel`’s `finishGame()` method when clicked. The code for
    this button looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0552-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'is just like adding the following code to your fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'except that this time, no fragment code is required. Behind the scenes, data
    binding uses the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: to create an `onClickListener` for the button. When the user clicks the button,
    the code is executed, which calls the view model’s `finishGame()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use a binding expression to call a method such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: the binding expression is sometimes known as a **listener binding**.
  prefs: []
  type: TYPE_NORMAL
- en: That’s everything that we need to know in order to add the button to `GameFragment`’s
    layout and make it respond to clicks. Let’s see what the full code looks like.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for fragment_game.xml
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0553-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here’s the full code for `GameFragment`’s layout; update the code for *fragment_game.xml*
    to include the new button (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0553-02.png)![image](Images/f0554-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s see what happens when the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0555-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment assigns the GameViewModel object to the layout’s gameViewModel
    data binding variable.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The layout’s views can now use the variable to access the view model’s properties
    and methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0555-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**The user clicks on the Finish Game button.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The button calls the `finishGame()` method in the `GameViewModel` object, which
    sets its `_gameOver` property to *true*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0555-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes that _gameOver has a new value.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It responds by navigating to `ResultFragment`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0555-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s take the app for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0556-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the app, `GameFragment`’s layout includes a new Finish Game button.
    When we click on the button, the app navigates to `ResultFragment`, which displays
    the secret word.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0556-02.png)'
  prefs: []
  type: TYPE_IMG
- en: There’s just one more tweak we’re going to make to the Guessing Game app. Before
    we show you what that is, try the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **goal** is to update the layout code below so that its button, when clicked,
    calls the `eatIceCream()` method in `MyViewModel`. Take code snippets from the
    pool and place them into the blank lines in the code. You may **not** use the
    same snippet more than once, and you won’t need to use all the snippets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0557-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Note: each thing from the pool can only be used once!**'
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/arr.png) **Answers in [“Pool Puzzle Solution”](#pool_puzzle_solution-id00213).**'
  prefs: []
  type: TYPE_NORMAL
- en: Fireside Chats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0558-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Tonight’s talk: **View Binding and Data Binding air their differences**'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Data Binding:** | **View Binding:** |'
  prefs: []
  type: TYPE_TB
- en: '| View Binding, we need to talk. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | We do? Why? |'
  prefs: []
  type: TYPE_TB
- en: '| Surely you’ve noticed how people keep getting the two of us confused. I mean,
    just because we both have Binding in our names, it doesn’t mean we’re the same
    thing. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | You’ve got to admit our names sound similar. Besides, we have a lot in
    common. |'
  prefs: []
  type: TYPE_TB
- en: '| You think so? |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Yes! We both generate binding classes. The *same* binding classes. Don’t
    pretend that’s not true. |'
  prefs: []
  type: TYPE_TB
- en: '| Maybe we do, but under completely different circumstances. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | It’s true that I’m much more convenient and helpful than you. I generate
    a binding class for every layout, and most of the time, that’s exactly what’s
    needed. Developers thank me for it. I even get fan mail. “Oh, View Binding, I’m
    your biggest fan! Thank you for eliminating `findViewById`. I thought my pain
    would never end!” |'
  prefs: []
  type: TYPE_TB
- en: '| You can’t claim sole responsibility for getting rid of `findViewById`. That’s
    down to the binding class, not you. The binding class that *I* generate, too.
    |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Whatever. |'
  prefs: []
  type: TYPE_TB
- en: '| Besides, generating a binding class for every single layout is such a waste
    of space. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Strictly speaking, I ignore any layouts with a `viewBindingIgnore` attribute
    that’s set to *true*. That’s way less complicated than your approach. |'
  prefs: []
  type: TYPE_TB
- en: '| Complicated? I’m just more discerning than you are. I only generate binding
    classes for layouts with a `<layout>` element. That way, the developer gets to
    decide exactly where I’m needed. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Yes, complicated! Who really wants to add even more XML to their layout
    code? That’s so much extra typing! |'
  prefs: []
  type: TYPE_TB
- en: '| So it means a bit of extra code, but I can do things that you can only dream
    of. I let views get their values directly from the view model, for instance. |
      |'
  prefs: []
  type: TYPE_TB
- en: '|   | I can do that too. Using fragment code. |'
  prefs: []
  type: TYPE_TB
- en: '| But that’s the point. You rely on fragment code to tell the views what they
    should do, but when I’m involved, that’s not necessary. I let the views get the
    values directly, which means simpler fragment code. I even let them use live data
    properties so that they can keep themselves up to date. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Huh. But what about updating property values? I bet you still need fragment
    code for that. |'
  prefs: []
  type: TYPE_TB
- en: '| No, I don’t. I have two-way data binding where views can update values *and*
    respond to changes. Look it up. It’ll change your life. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Huh. You’ll be telling me next you let views call methods. |'
  prefs: []
  type: TYPE_TB
- en: '| But of course. And why not? |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | It makes the layout code overly complicated. I just can’t believe you’d
    be so irresponsible. |'
  prefs: []
  type: TYPE_TB
- en: '| I hardly call simple method calls irresponsible, and it saves the developer
    from writing yet more fragment code. But I accept that for more complex things,
    the code really belongs in the fragment, not the layout. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | So even you admit you have your limitations. |'
  prefs: []
  type: TYPE_TB
- en: '| You’re just jealous. |   |'
  prefs: []
  type: TYPE_TB
- en: '|   | Riiiiiight. You keep telling yourself that… |'
  prefs: []
  type: TYPE_TB
- en: We can switch off view binding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve nearly finished updating the Guessing Game app, but there’s one more tweak
    we can make so that only the binding classes we’re using for data binding will
    get generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you know, data binding and view binding generate the same binding classes,
    but under different circumstances: view binding generates a binding class for
    *every* layout, while data binding generates the class for every layout with a
    `<layout>` element at its root.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Guessing Game app, we’re only using the binding classes for *fragment_game.xml*
    and *fragment_result.xml*. Since both of these files include a `<layout>` element,
    we can safely switch off the view binding option, and their binding classes will
    continue to get generated via data binding:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The only layout file that data binding won’t generate a binding class for is
    activity_main.xml because it doesn’t include a <layout> element. We don’t need
    to use this binding class, so view binding can be safely switched off.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0560-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Switch off view binding in the app’s build.gradle file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To switch off view binding, open the *GuessingGame/app/build.gradle* file,
    and remove the view binding line from the `buildFeatures` section like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0560-03.png)'
  prefs: []
  type: TYPE_IMG
- en: Then choose the Sync Now option to sync this change with the rest of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take the app for a quick test drive and make sure that it still works.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run the app, the game works in the same way as before. Switching off
    view binding has made no difference because data binding has generated all the
    binding classes that the app needs.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0561-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You’ve now learned how to use data binding, and used it in
    conjunction with view models and live data. This approach can be used to simplify
    your fragment code and build reactive, responsive apps.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/f0562-01.png) Binding-Cross'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each of the clues for the crossword below is a binding expression that’s used
    for a TextView’s android:text property. Can you solve the crossword using the
    output for each clue?
  prefs: []
  type: TYPE_NORMAL
- en: 'Hint: Each binding expression uses a String resource and a view model. You’ll
    find the code for these on the next page, along with a layout that includes the
    TextView.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0562-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Across**'
  prefs: []
  type: TYPE_NORMAL
- en: '**2** “@{@string/string2(vm.d[1])}”'
  prefs: []
  type: TYPE_NORMAL
- en: '**3** “@{@string/string3(vm.d[2], vm.g[0])}”'
  prefs: []
  type: TYPE_NORMAL
- en: '**6** “@{@string/string1(vm.a)}”'
  prefs: []
  type: TYPE_NORMAL
- en: '**7** “@{@string/string3(vm.f[1], vm.h[0])}”'
  prefs: []
  type: TYPE_NORMAL
- en: '**8** “@{@string/string1(vm.d[vm.i[1]])}”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Down**'
  prefs: []
  type: TYPE_NORMAL
- en: '**1** “@{@string/string3(vm.e[2], vm.g[0])}”'
  prefs: []
  type: TYPE_NORMAL
- en: '**4** “@{@string/string4(vm.h[2], vm.a)}”'
  prefs: []
  type: TYPE_NORMAL
- en: '**5** “@{@string/string4(vm.h[1], vm.g[2])}”'
  prefs: []
  type: TYPE_NORMAL
- en: '**Layout:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '**View model:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**String resource file:**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Images](Images/common05.png) Binding-Cross Solution'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0564-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Pool Puzzle Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **goal** is to update the layout code below so that its button, when clicked,
    calls the `eatIceCream()` method in `MyViewModel`. Take code snippets from the
    pool and place them into the blank lines in the code. You may **not** use the
    same snippet more than once, and you won’t need to use all the snippets.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0566-01.png)![image](Images/f0566-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Your Android Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/tools.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You’ve got [Chapter 13](#data_bindingcolon_building_smart_layouts) under
    your belt and now you’ve added data binding to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0567-01.png)'
  prefs: []
  type: TYPE_IMG
