- en: 'Chapter 12\. Live Data: *Leaping into Action*'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0483-01.png)'
  id: totrans-1
  prefs: []
  type: TYPE_IMG
- en: '**Your code often needs to react to property value changes.**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'If a view model property changes value, for example, **the fragment might need
    to respond** by updating its views or navigating elsewhere. But **how does a fragment
    get to hear when a property’s been updated**? Here, we’ll introduce you to **live
    data**: a way of **telling interested parties when something’s changed**. You’ll
    learn all about ***MutableLiveData***, and how to **make your fragment observe
    properties** of this type. You’ll discover **how the *LiveData* type helps maintain
    your app’s integrity**. Soon, you’ll be writing apps that are **more responsive
    than ever before**...'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: The Guessing Game app revisited
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a Guessing Game app that lets the user guess
    which letters are included in a secret word. When the user guesses all the letters
    or runs out of lives, the game ends.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the fragment code from becoming too bloated and maintain the app’s
    state when the user rotated the device screen, we used view models for the app’s
    game logic and data. `GameFragment` uses `GameViewModel` for its logic and data,
    and `ResultViewModel` holds the game result that’s needed by `ResultFragment`:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0484-01.png)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
- en: When each fragment is displayed, or the user makes a guess, the fragments get
    the latest values from their view models and display them on the screen.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: While this approach works, however, there are some disadvantages.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The fragments decide when to update views
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The downside to this approach is that each fragment decides when to fetch the
    latest property values from the view model and update its views. And some of the
    time, these values won’t have changed. If the user makes a correct guess, for
    example, `GameFragment` updates the text that’s displayed for the number of lives
    left and the incorrect guesses, even though these values won’t have changed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0485-01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
- en: Let the view model say when a value’s changed
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative approach is for `GameViewModel` to let `GameFragment` know when
    each of its properties has been updated. If the fragment is notified of these
    changes, it will no longer need to decide for itself when to fetch the latest
    property values from the view model and update its views. Instead, it will only
    need to update its views once it’s told that the underlying property has been
    updated.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0485-02.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
- en: 'We’re going to implement this change in the Guessing Game app using Android’s
    **live data** library: part of Android Jetpack. Live data lets the view model
    tell interested parties—such as fragments and activities—when its property values
    have been updated. They can then react to these changes by updating views, or
    calling other methods.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0485-03.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: You’ll find out how to use live data through the rest of this chapter. First,
    let’s go through the steps we’ll take to update the app.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what we’re going to do
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0486-01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: 'Here are the steps that we’ll go through to write the app:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '**Make the Guessing Game app use live data.**'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll update `GameViewModel` so that the `livesLeft`, `incorrectGuesses,` and
    `secretWordDisplay` properties use live data. We’ll then make `GameFragment` update
    its views when the values of these properties change.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0486-02.png)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Protect GameViewModel’s properties and methods.**'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll restrict access to `GameViewModel`’s properties so that only `GameViewModel`
    can update them. We’ll also make sure that `GameFragment` only has access to the
    methods it requires to do its job.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0486-03.png)'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add a gameOver property.**'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll make `GameViewModel` decide when each game is over using a new `gameOver`
    property. `GameFragment` will navigate to `ResultFragment` when the value of this
    property changes.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0486-04.png)'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Add a live data dependency to the app build.gradle file
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’re going to be using live data, we’ll begin by adding a live data dependency
    to the app’s *build.gradle* file.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project for the Guessing Game app (if you haven’t already done so),
    open the file *GuessingGame/app/build.gradle*, and add the following line (in
    bold) to the `dependencies` section:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0486-05.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
- en: When prompted, sync your changes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: GameViewModel and GameFragment need to use live data
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to use live data in the Guessing Game app so that `GameViewModel` notifies
    `GameFragment` when its property values have changed. `GameFragment` will then
    react to these changes.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll tackle this in two stages:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '**Specify which GameViewModel property changes GameFragment needs to know about.**'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tell GameFragment how to respond to each change.**'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, we’ll focus on the `GameViewModel` code changes.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Which view model properties should use live data?
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GameViewModel` includes three properties—`secretWordDisplay`, `incorrectGuesses,`
    and `livesLeft`—that `GameFragment` uses to update its views. We’ll specify that
    these three properties use live data so that `GameFragment` is notified when their
    values change.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'You specify that a property uses live data by changing its type to `**MutableLiveData<Type>**`,
    where `Type` is the type of data the property should hold. The `livesLeft` property,
    for example, is currently defined as an `Int` using the code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To make the property use live data, you change its type to `MutableLiveData<Int>`
    so that it looks like this instead:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0487-03.png)![image](Images/f0487-02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: This specifies that `livesLeft` is now a `MutableLiveData<Int>` with an initial
    value of 8.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can define the `incorrectGuesses` and `secretWordDisplay` properties
    using code like this
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0487-04.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
- en: Here, each property’s type is set to `MutableLiveData<String>`. `incorrectGuesses`’s
    value is set to `""`, while `secretWordDisplay`’s value will get set in `GameViewModel`’s
    `init` block.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: So that’s how you define a live data property. Next up, how to update its value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Live data objects use a value property
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you use `MutableLiveData` properties, you update their values using a
    property named `**value**`. To update the `secretWordDisplay` property with the
    `deriveSecretWordDisplay()` method’s return value, for example, you don’t use
    the code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'as you did before. You use the following code instead:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Changing the `value` property in this way is important, because it’s how any
    interested parties—in this case `GameFragment`—get notified of any changes. Each
    time `secretWordDisplay`’s `value` property gets updated, `GameFragment` is informed,
    so it can respond by updating its views.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0488-02.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: The value property can be null
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s one extra thing to be aware of when you use live data: the `value`’s
    type is *nullable*. This means that when you use live data values in your code,
    you need to perform null-safety checks, or your code won’t compile.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the `livesLeft` property is defined using the code:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0488-03.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
- en: This property’s type is `MutableLiveData<Int>`, so its `value` property can
    accept an `Int`, or be `null`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `value` property may be `null`, we can’t, say subtract one from its
    value using the code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead, we need to use:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0488-04.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: which subtracts 1 from its value so long as it isn’t `null`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the following `isLost()` method won’t compile because `liveLeft.value`
    may be `null`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can, however, change it to use Kotlin’s Elvis operator like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0488-05.png)![image](Images/f0489-02.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: '**Live Data properties can be defined using val.**'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, you use `val` and `var` in Kotlin to specify whether or
    not a property can be given a reference to a new object.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first defined each property, we used `var` so that we could update
    it. We defined the `livesLeft` property, for example, using:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'which initialized `livesLeft` with an `Int` object whose value is 8\. Each
    time the user made an incorrect guess, we subtracted 1 from `livesLeft`, which
    gave it a reference to a new `Int` object:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0489-03.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: 'With live data, you update the `value` property of the *existing* object, instead
    of replacing it with another object, and interested parties are notified of this
    change. As the object is no longer being replaced, you can define the property
    using `val` instead of `var` like this:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0489-04.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
- en: The full code for GameViewModel.kt
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how live data works, let’s update `GameViewModel` so that
    its `livesLeft`, `incorrectGuesses`, and `secretWordDisplay` properties all use
    live data.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for *GameViewModel.kt*; update the code to include the
    changes (in bold):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0490-02.png)![image](Images/f0491-02.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
- en: That’s everything that we need for `GameViewModel`. Next up, let’s make `GameFragment`
    respond when the `livesLeft`, `incorrectGuesses`, and `secretWordDisplay` properties
    get updated.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The fragment observes the view model properties and reacts to changes.
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You make a fragment respond to `value` changes in a view model’s `MutableLiveData`
    property by calling the property’s `**observe()**` method. If the following code
    is added to `GameFragment`, for example, it will observe the view model’s `livesLeft`
    property, and take action when it changes:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0492-02.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: As you can see, the above code passes `viewLifecycleOwner` and `Observer` arguments
    to the `observe()` method.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: '`viewLifecycleOwner` refers to the lifecycle of the fragment’s views. It’s
    tied to when the fragment has access to its UI: from when it’s created in the
    fragment’s `onCreateView()` method, to when its destroyed, and `onDestroyView()`
    gets called.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0492-03.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: '`Observer` is a class that can receive live data. It’s tied to the `viewLifecycleOwner`,
    so it’s only active—and able to receive live data notifications—when the fragment
    has access to its views. If the live data property’s value changes while the fragment
    doesn’t have access to its UI, the observer isn’t notified, so the fragment doesn’t
    respond. This stops the fragment from trying to update views when they’re not
    available, which might cause the app to crash.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-94
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It also makes your coding life easier because you don’t need to check whether
    the view’s available for yourself. Using live data handles it all for you.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observer` class accepts a lambda parameter, which specifies how the property’s
    new value should be used. In the Guessing Game app, for example, we want `GameFragment`
    to update its `lives` text each time the view model’s `livesLeft` property gets
    updated, and we can achieve this using the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0492-04.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: That’s everything that we need to know in order to make `GameFragment` update
    its views when the view model property values get changed. Let’s update its code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: The full code for GameFragment.kt
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the updated code for `GameFragment`; make sure that the file *GameFragment.kt*
    includes the changes shown below (in bold):'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0493-02.png)![image](Images/f0494-02.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
- en: Those are all the changes we need to make to `GameFragment` so that it updates
    its views each time it observes changes to the `incorrectGuesses`, `livesLeft`,
    and `secretWordDisplay` properties.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now implemented live data in the Guessing Game app Let’s go through what
    happens when the app runs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0495-02.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
- en: '**ResultViewModel doesn’t need to use live data, so we don’t need to update
    it.**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall, `ResultViewModel` has one property (named `result`), which
    gets set when the view model gets created. The code looks like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you can see, result is defined using `val`, so once it’s been initialized,
    it can’t be updated to another value. `ResultFragment` doesn’t need to be notified
    when `result` changes because **once set,** `**result**` **can never change**.
    There’s no need to make `ResultFragment` respond to any changes, because there
    can’t be any.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: So let’s walk through what happens when the code runs, and then take the app
    for a test drive.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GameViewModel` object is initialized, and the values of its three `MutableLiveData`
    properties—`livesLeft`, `incorrectGuesses`, and `secretWordDisplay`—are set.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0496-02.png)'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes the livesLeft, incorrectGuesses, and secretWordDisplay
    properties in the GameViewModel.**'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0496-03.png)'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment updates its views with the values of the properties it’s observing.**'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0496-04.png)'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user makes a correct guess, secretWordDisplay’s value is updated,
    and the new value is passed to GameFragment.**'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` responds by updating its `word` view, which is displayed on
    the screen.'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0497-02.png)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user makes an incorrect guess, the values for incorrectGuesses and
    livesLeft are updated, and passed to GameFragment.**'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` responds by updating its views.'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0497-03.png)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When isWon() or isLost() return true, GameFragment navigates to ResultFragment,
    passing it the result.**'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ResultFragment` displays the result.'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0497-04.png)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s take the app for a test drive.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run the app, `GameFragment` is displayed as before.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: When we make a correct guess, the secret word display gets updated. When we
    make an incorrect guess, the lives left is updated, and our guess is added to
    the incorrect guesses display.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: If we guess all the letters or lose all our lives, the app navigates to `ResultFragment`,
    which displays the result.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0498-02.png)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
- en: The game behaves in the same way as before, but behind the scenes, it responds
    using live data.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Fragments can update GameViewModel’s properties
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve updated the code in `GameViewModel` and `GameFragment` so that
    it uses live data. Each time the value of a `MutableLiveData` property in `GameViewModel`
    gets updated, `GameFragment` responds by updating its views.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: There’s a slight problem with the code, however. `GameFragment` has full access
    to `GameViewModel`’s properties and methods, so if it wanted to, it could use
    them inappropriately. There’s nothing to stop the fragment from, say, updating
    the `livesLeft` property to 100 so that the user can make many more guesses and
    win the game each time she plays.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: To get around this problem, we’re going to restrict direct access to the `GameViewModel`’s
    properties so that **only methods in the view model can update them**.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '**You can restrict direct access to a view model’s property by marking it private,
    and providing read-only access via another property’s getter.**'
  id: totrans-139
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Keep your privates private
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To protect `GameViewModel`’s properties, we’ll mark each one as `private` so
    that only code in `GameViewModel` can update their values. We’ll then expose a
    *read-only version* of each `MutableLiveData` property that `GameFragment` needs
    to observe. Instead of defining the `livesLeft` property using code like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'we’ll use the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0501-01.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Here, the `_livesLeft` property holds a reference to a `MutableLiveData` object.
    `GameFragment` doesn’t have access to this property because it’s marked as `private`.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '`GameFragment` can, however, access the value of this property using `livesLeft`’s
    getter. `livesLeft`’s type is `**LiveData**`, which is like `MutableLiveData`
    except that it can’t be used to update the underlying object’s `value` property:
    `GamesFragment` can read the value, but it can’t update it.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: When you structure your code in this way, the private property is sometimes
    called a **backing property**. It holds a reference to an object that other classes
    only have access to via another property.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update the `GameViewModel` code.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0501-02.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: The full code for GameViewModel.kt
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0502-01.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
- en: We’ll update the code for `GameViewModel` so that it uses backing properties
    to restrict direct access to its live data properties. We’ll also mark as private
    any properties and methods that `GameFragment` doesn’t need to use.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for *GameViewModel.kt*; update the code to include our
    changes (in bold):'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0502-02.png)![image](Images/f0503-02.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: Let’s go through what happens when the code runs.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0504-02.png)'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameViewModel’s properties are initialized.**'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`livesLeft`, `incorrectGuesses`, and `secretWordDisplay` are `LiveData` properties
    that refer to the same underlying objects as their `MutableLiveData` backing properties.'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0504-03.png)'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes the livesLeft, incorrectGuesses, and secretWordDisplay
    properties.**'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` can’t update any of these properties, but it responds when `GameViewModel`
    updates any of the backing properties because they refer to the same underlying
    object.'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0504-04.png)'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment continues to respond to value changes until isWon() or isLost()
    returns true.**'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` navigates to `ResultFragment`, passing it the result. `ResultFragment`
    displays the result.'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0505-01.png)'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s take the app for a test drive.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0505-02.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
- en: When we run the app, it works in the same way as before. This time, however,
    we’ve protected `GameViewModel`’s `MutableLiveData` properties by restricting
    `GameFragment`’s access to them.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0505-03.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: We’ve nearly finished updating the Guessing Game app. There’s just one more
    thing we need to change...
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: GameFragment still includes game logic
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0506-01.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
- en: In the current version of the app, `GameFragment` decides when the game is finished
    by calling `GameViewModel`’s `isWon()` and `isLost()` methods after the user has
    made each guess. If either of these returns *true*, `GameFragment` navigates to
    `ResultFragment`, passing it the result.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the current code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-02.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: The problem with this approach is that `GameFragment` decides when the game
    is over instead of `GameViewModel`. As determining when the game has finished
    is a game decision, it’s something that `GameViewModel` should be responsible
    for, not `GameFragment`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Make GameViewModel decide when the game is over
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deal with this, we’ll add a `MutableLiveData<Boolean>` property named `_gameOver`
    to `GameViewModel`, whose value we’ll expose using a `LiveData` property named
    `gameOver`. We’ll set this property to *true* when the user wins or loses the
    game. When this happens, `GameFragment` will respond by navigating to `ResultFragment`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-03.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
- en: You’re already familiar with the changes that are required to do this, so before
    we show you the code, try the following exercise.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common01.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Your **goal** is to add a `gameOver` property (with a `_gameOver` backing property)
    to `GameViewModel` so that `GameFragment` can respond when its value (a `Boolean`)
    gets updated. The property should be initialized with a value of *false*. Take
    code snippets from the pool and place them into the blank lines in the code. You
    may **not** use the same snippet more than once, and you won’t need to use all
    the snippets.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![image](Images/f0507-01.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Note: each thing from the pool can only be used once!**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle Solution
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common01.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
- en: Your **goal** is to add a `gameOver` property (with a `_gameOver` backing property)
    to `GameViewModel` so that `GameFragment` can respond when its value (a `Boolean`)
    gets updated. The property should be initialized with a value of *false*. Take
    code snippets from the pool and place them into the blank lines in the code. You
    may **not** use the same snippet more than once, and you won’t need to use all
    the snippets.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0508-01.png)![image](Images/f0508-02.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: The full code for GameViewModel.kt
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add a `gameOver` property to `GameViewModel`, along with a `_gameOver`
    backing property. We’ll get the `makeGuess()` method to set it to *true* when
    the user has guessed all of the letters in the secret word, or run out of lives.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for `GameViewModel`; update the code in *GameViewModel.kt*
    to include the changes shown below (in bold):'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0509-02.png)![image](Images/f0510-02.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
- en: Make GameFragment observe the new property
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve added the `gameOver` property to `GameViewModel`, we need to
    make `GameFragment` respond to when it’s been updated. We’ll make the fragment
    observe the property, so that when its value is changed to *true*, the fragment
    will navigate to `ResultFragment`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for `GameFragment`; update the code in *GameFragment.kt* so
    that it includes the changes below (in bold):'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0511-01.png)![image](Images/f0512-02.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: That’s it! Let’s go through what happens when it runs.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0513-02.png)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameViewModel’s properties are initialized.**'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `_gameOver` and `gameOver` properties refer to a `MutableLiveData<Boolean>`
    object whose value is set to *false*.
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0513-03.png)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes the GameViewModel’s gameOver property.**'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` can’t update the `MutableLiveData` object that the `gameOver`
    property refers to, but it can respond to when its value changes.'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0513-04.png)'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Each time the GameViewModel’s makeGuess() method is called, it checks whether
    isWon() or isLost() returns true.**'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either is *true*, it sets the value of its `_gameOver` property to *true*.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0514-02.png)'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes the value has been updated to true via the GameViewModel’s
    gameOver property.**'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new value is passed to `GameFragment`.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0514-03.png)'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment responds by navigating to ResultFragment, passing it the result.**'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0514-04.png)'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We’ll take the app for a test drive after the following exercise.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Fragment Magnets
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Somebody wrote the code for a fragment named `LotteryFragment` on the fridge
    door, but a freak kitchen blizzard blew some of the code away. Can you piece it
    back together again?
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'The fragment needs to observe `LotteryViewModel`’s `winningNumbers` property,
    which is defined like this:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When `winningNumbers` changes, `LotteryFragment` needs to update its `numbers`
    view with the new value.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0515-01.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Fragment Magnets Solution
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
- en: Somebody wrote the code for a fragment named `LotteryFragment` on the fridge
    door, but a freak kitchen blizzard blew some of the code away. Can you piece it
    back together again?
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'The fragment needs to observe `LotteryViewModel`’s `winningNumbers` property,
    which is defined like this:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When `winningNumbers` changes, `LotteryFragment` needs to update its `numbers`
    view with the new value.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0516-01.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/car.png) Test Drive'
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0517-01.png)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
- en: When we run the app, it works in the same way as before. This time, however,
    `GameViewModel` decides when the game is over instead of `GameFragment`. The fragment
    simply observes the view model’s `gameOver` property, and navigates to `ResultFragment`
    when it’s changed to *true*.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0517-02.png)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You’ve now built an app that uses live data to respond to changes
    as and when they occur. In the next chapter, we’ll build on this still further
    using a new technique called data binding.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Your Android Toolbox
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/tools.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: '**You’ve got [Chapter 12](#live_datacolon_leaping_into_action) under your belt
    and now you’ve added live data to your toolbox.**'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0518-01.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
