["```\nfun numbers(): Flow<Int> = flow {\n    emit(1)\n    emit(2)\n    // emit other values\n}\n```", "```\nfun main() = runBlocking {\n    val flow = numbers()      ![1](assets/1.png)\n    flow.collect {            ![2](assets/2.png)\n        println(it)\n    }\n}\n```", "```\ndata class TokenData(val token: String, val opt: String? = null)\n```", "```\n    fun main() = runBlocking<Unit> {\n        val flow = getDataFlow(3) // Nothing runs at initialization\n\n        // A coroutine collects the flow\n        launch {\n            flow.collect { data ->\n                println(data)\n            }\n        }\n    }\n    ```", "```\nfun main() = runBlocking<Unit> {\n    val numbers: Flow<Int> = // implementation hidden for brevity\n\n    val newFlow: Flow<String> = numbers().map {\n        transform(it)\n    }\n}\n\nsuspend fun transform(i :Int): String = withContext(Dispatchers.Default) {\n    delay(10) // simulate real work\n    \"${i + 1}\"\n}\n```", "```\ndata class Message(\n    val user: String,\n    val date: LocalDateTime,\n    val content: String\n)\n```", "```\nfun getMessageFlow(): Flow<Message> {\n    // we'll implement it later\n}\n```", "```\nfun getMessagesFromUser(user: String, language: String): Flow<Message> {\n    return getMessageFlow()\n        .filter { it.user == user }           ![1](assets/1.png)\n        .map { it.translate(language) }       ![2](assets/2.png)\n        .flowOn(Dispatchers.Default)          ![3](assets/3.png)\n}\n```", "```\nprivate suspend fun Message.translate(\n    language: String\n): Message  = withContext(Dispatchers.Default) {\n    // this is a dummy implementation\n    copy(content = \"translated content\")\n}\n```", "```\nfun main() = runBlocking {\n    getMessagesFromUser(\"Amanda\", \"en-us\").collect {\n        println(\"Received message from ${it.user}: ${it.content}\")\n    }\n}\n```", "```\nabstract class MessageFactory : Thread() {\n    /* The internal list of observers must be thread-safe */\n    private val observers = Collections.synchronizedList(\n        mutableListOf<MessageObserver>())\n    private var isActive = true\n\n    override fun run() = runBlocking {\n        while(isActive) {\n            val message = fetchMessage()\n            for (observer in observers) {\n                observer.onMessage(message)\n            }\n            delay(1000)\n        }\n    }\n\n    abstract fun fetchMessage(): Message\n\n    fun registerObserver(observer: MessageObserver) {\n        observers.add(observer)\n    }\n\n    fun unregisterObserver(observer: MessageObserver) {\n        observers.removeAll { it == observer }\n    }\n\n    fun cancel() {\n        isActive = false\n        observers.forEach {\n            it.onCancelled()\n        }\n        observers.clear()\n    }\n\n    interface MessageObserver {\n        fun onMessage(msg: Message)\n        fun onCancelled()\n        fun onError(cause: Throwable)\n    }\n}\n```", "```\nfun getMessageFlow(factory: MessageFactory) = callbackFlow<Message> {\n    val observer = object : MessageFactory.MessageObserver {\n        override fun onMessage(msg: Message) {\n            trySend(msg)\n        }\n\n        override fun onCancelled() {\n            channel.close()\n        }\n\n        override fun onError(cause: Throwable) {\n            cancel(CancellationException(\"Message factory error\", cause))\n        }\n    }\n\n    factory.registerObserver(observer)\n    awaitClose {\n        factory.unregisterObserver(observer)\n    }\n}\n```", "```\ncallbackFlow {\n    /*\n 1\\. Instantiate the \"callback.\" In this case, it's an observer.\n 2\\. Register that callback using the available api.\n 3\\. Listen for close event using `awaitClose`, and provide a\n relevant action to take in this case. Most probably,\n you'll have to unregister the callback.\n */\n}\n```", "```\npublic inline fun <T> callbackFlow(\n    @BuilderInference noinline block: suspend ProducerScope<T>.() -> Unit\n): Flow<T>\n```", "```\npublic interface ProducerScope<in E> : CoroutineScope, SendChannel<E>\n```", "```\nsuspend fun transform(loc: Location): Content = withContext(Dispatchers.IO) {\n    // Actual implementation doesn't matter\n}\n```", "```\n139 ms: [1, 2, 3, 4]\n172 ms: [5, 6, 7, 8]\n223 ms: [9, 10, 11, 12, 13]\n272 ms: [14, 15, 16, 17]\n322 ms: [18, 19, 20, 21, 22]\n...\n1022 ms: [86, 87, 88, 89, 90]\n1072 ms: [91, 92, 93, 94, 95]\n1117 ms: [96, 97, 98, 99, 100]\n```", "```\n// RxJava sample\nsomeObservable().subscribe(\n    { value -> /* Do something useful */ },\n    { error -> println(\"Error: $error\") }\n)\n```", "```\nReceived 1\nReceived 2\nCaught java.lang.RuntimeException\n```", "```\n// Warning: DON'T DO THIS, this flow swallows downstream exceptions\nval upstream: Flow<Int> = flow {\n    for (i in 1..3) {\n        try {\n            emit(i)\n        } catch (e: Throwable) {\n            println(\"Intercept downstream exception $e\")\n        }\n    }\n}\n\nfun main() = runBlocking {\n    try {\n        upstream.collect { value ->\n            println(\"Received $value\")\n            check(value <= 2) {\n                \"Collected $value while we expect values below 2\"\n            }\n        }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    }\n}\n```", "```\nReceived 1\nReceived 2\nCaught java.lang.IllegalStateException: Collected 3 while we expect values below 2\n```", "```\nReceived 1\nReceived 2\nReceived 3\nIntercept downstream exception java.lang.IllegalStateException: Collected 3 while we expect values below 2\n```", "```\nval violatesExceptionTransparency: Flow<Int> = flow {\n    for (i in 1..3) {\n        try {\n            emit(i)\n        } catch (e: Throwable) {\n            emit(-1)\n        }\n    }\n}\n\nfun main() = runBlocking {\n    try {\n        violatesExceptionTransparency.collect { value ->\n            check(value <= 2) { \"Collected $value\" }\n        }\n    } catch (e: Throwable) {\n        println(\"Caught $e\")\n    }\n}\n```", "```\nCaught java.lang.IllegalStateException: Flow exception transparency is\nviolated:\nPrevious 'emit' call has thrown exception java.lang.IllegalStateException: Collected 3, but then emission attempt of value '-1' has been detected.\nEmissions from 'catch' blocks are prohibited in order to avoid unspecified behaviour, 'Flow.catch' operator can be used instead.\nFor a more detailed explanation, please refer to Flow documentation.\n```", "```\nReceived 1\nReceived 2\nCaught java.lang.RuntimeException\n```", "```\nReceived 0\nCollector stopped collecting the flow\n```", "```\nfun main() = runBlocking {\n    // Defining the Flow of Content - nothing is executing yet\n    val contentFlow = locationsFlow.map { loc ->\n        flow {\n            emit(transform(loc))\n        }.catch { cause: Throwable ->\n            if (cause is NumberFormatException) {   ![1](assets/1.png)\n                println(\"Handling $cause\")\n            } else {\n                throw cause                         ![2](assets/2.png)\n            }\n        }\n    }.flattenMerge(4)\n\n    // We now collect the entire flow using the toList terminal operator\n    val contents = contentFlow.toList()\n}\n```", "```\nReceived 1\nReceived 3\nReceived 0\n```", "```\n// We don't use realistic URLs, for brevity\nval urlFlow = flowOf(\"url-1\", \"url-2\", \"url-retry\")\n```", "```\nsuspend fun fetchImage(url: String): Image {\n    // Simulate some remote call\n    delay(10)\n\n    // Simulate an exception thrown by the server or API\n    if (url.contains(\"retry\")) {\n        throw IOException(\"Server returned HTTP response code 503\")\n    }\n\n    return Image(url)\n}\n\ndata class Image(val url: String)\n```", "```\nsealed class Result\ndata class Success(val image: Image) : Result()\ndata class Error(val url: String) : Result()\n```", "```\nsuspend fun fetchResult(url: String): Result {\n    println(\"Fetching $url..\")\n    return try {\n        val image = fetchImage(url)\n        Success(image)\n    } catch (e: IOException) {\n        Error(url)\n    }\n}\n```", "```\nfun main() = runBlocking {\n    val urlFlow = flowOf(\"url-1\", \"url-2\", \"url-retry\")\n\n    val resultFlow = urlFlow\n        .map { url -> fetchResult(url) }\n\n    val results = resultFlow.toList()\n    println(\"Results: $results\")\n}\n```", "```\nFetching url-1..\nFetching url-2..\nFetching url-retry..\nResults: [Success(image=Image(url=url-1)), Success(image=Image(url=url-2)), Error(url=url-retry)]\n```", "```\nfun <T, R : Any> Flow<T>.mapWithRetry(\n    action: suspend (T) -> R,\n    predicate: suspend (R, attempt: Int) -> Boolean\n) = map { data ->\n    var attempt = 0L\n    var shallRetry: Boolean\n    var lastValue: R? = null\n    do {\n        val tr = action(data)\n        shallRetry = predicate(tr, ++attempt)\n        if (!shallRetry) lastValue = tr\n    } while (shallRetry)\n    return@map lastValue\n}\n```", "```\nfun main() = runBlocking {\n    val urlFlow = flowOf(\"url-1\", \"url-2\", \"url-retry\")\n\n    val resultFlowWithRetry = urlFlow\n        .mapWithRetry(\n            { url -> fetchResult(url) },\n            { value, attempt -> value is Error && attempt < 3L }\n        )\n\n    val results = resultFlowWithRetry.toList()\n    println(\"Results: $results\")\n}\n```", "```\nFetching url-1..\nFetching url-2..\nFetching url-retry..\nFetching url-retry..\nFetching url-retry..\nResults: [Success(image=Image(url=url-1)), Success(image=Image(url=url-2)), Error(url=url-retry)]\n```", "```\nprivate val _sharedFlow = MutableSharedFlow<Data>()\nval sharedFlow: SharedFlow<Data> = _sharedFlow.asSharedFlow()\n```", "```\nscope.launch {\n   sharedFlow.collect { data ->\n      println(data)\n   }\n}\n```", "```\ndata class News(val content: String)\n```", "```\ninterface NewsDao {\n    suspend fun fetchNewsFromApi(): List<News>\n}\n```", "```\nclass NewsRepository(private val dao: NewsDao) {\n    private val _newsFeed = MutableSharedFlow<News>()    ![1](assets/1.png)\n    val newsFeed = _newsFeed.asSharedFlow()              ![2](assets/2.png)\n\n    private val scope = CoroutineScope(Job() + Dispatchers.IO)\n\n    init {\n        scope.launch {                                   ![3](assets/3.png)\n            while (true) {\n                val news = dao.fetchNewsFromApi()\n                news.forEach { _newsFeed.emit(it) }      ![4](assets/4.png)\n\n                delay(3000)\n            }\n        }\n    }\n\n    fun stop() = scope.cancel()\n}\n```", "```\nclass NewsViewsModel(private val repository: NewsRepository) : ViewModel() {\n    private val newsList = mutableListOf<News>()\n\n    private val _newsLiveData = MutableLiveData<List<News>>(newsList)\n    val newsLiveData: LiveData<List<News>> = _newsLiveData\n\n    init {\n        viewModelScope.launch {\n            repository.newsFeed.collect {\n                println(\"NewsViewsModel receives $it\")\n                newsList.add(it)\n                _newsLiveData.value = newsList\n            }\n        }\n    }\n}\n```", "```\nval dao = object : NewsDao {\n    private var index = 0\n\n    override suspend fun fetchNewsFromApi(): List<News> {\n        delay(100)  // simulate network delay\n        return listOf(\n            News(\"news content ${++index}\"),\n            News(\"news content ${++index}\")\n        )\n    }\n}\n```", "```\nNewsViewsModel receives News(content=news content 1)\nNewsViewsModel receives News(content=news content 2)\nNewsViewsModel receives News(content=news content 3)\n...\n```", "```\nNewsViewsModel receives News(content=news content 1)\nNewsViewsModel receives News(content=news content 2)\nNewsViewsModel receives News(content=news content 3)\nAnotherViewModel receives News(content=news content 3)\nNewsViewsModel receives News(content=news content 4)\nAnotherViewModel receives News(content=news content 4)\nNewsViewsModel receives News(content=news content 5)\nAnotherViewModel receives News(content=news content 5)\nNewsViewsModel receives News(content=news content 6)\nAnotherViewModel receives News(content=news content 6)\n...\n```", "```\nprivate val _newsFeed = MutableSharedFlow<News>(replay = 2)\n```", "```\nMutableSharedFlow(replay = 3, onBufferOverflow = BufferOverflow.DROP_OLDEST)\n```", "```\nMutableSharedFlow(extraBufferCapacity = 2)\n```", "```\nclass MessageRepository {\n    private val _messageFlow = MutableSharedFlow<String>(\n        extraBufferCapacity = 1,\n        onBufferOverflow = BufferOverflow.DROP_OLDEST\n    )\n    val messageEventBus = _messageFlow.asSharedFlow()\n\n    private fun someTask() {\n        // Notify subscribers to display a message\n        _messageFlow.tryEmit(\"This is important\")\n    }\n}\n```", "```\nval shared = MutableSharedFlow(\n    replay = 1,\n    onBufferOverflow = BufferOverflow.DROP_OLDEST\n)\nshared.tryEmit(initialValue) // emit the initial value\nval state = shared.distinctUntilChanged() // get StateFlow-like behavior\n```", "```\nval state = MutableStateFlow(initialValue)\n```", "```\nclass DownloadService : Service() {\n    companion object {\n        private val _downloadState =\n            MutableStateFlow<ServiceStatus>(Stopped)\n        val downloadState = _downloadState.asStateFlow()\n    }\n    // Rest of the code hidden for brevity\n}\n\nsealed class ServiceStatus\nobject Started : ServiceStatus()\ndata class Downloading(val progress: Int) : ServiceStatus()\nobject Stopped : ServiceStatus()\n```", "```\nclass DownloadViewModel : ViewModel() {\n    val downloadServiceStatus = DownloadService.downloadState.asLiveData()\n}\n```", "```\nclass DownloadFragment : Fragment() {\n    private val viewModel: DownloadViewModel by viewModels()\n\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n\n        viewModel.downloadServiceStatus.observe(this) {   ![1](assets/1.png)\n            it?.also {\n                onDownloadServiceStatus(it)\n            }\n        }\n    }\n\n    private fun onDownloadServiceStatus(\n        status: ServiceStatus\n    ): Nothing = when (status) {                          ![2](assets/2.png)\n        Started -> TODO(\"Show download is about to start\")\n        Stopped -> TODO(\"Show download stopped\")\n        is Downloading -> TODO(\"Show progress\")\n    }\n}\n```"]