<html><head></head><body><section data-pdf-bookmark="Chapter 20. Filters, Blending, Clipping, and Masking" data-type="chapter" epub:type="chapter"><div class="chapter" id="filters-compositing">&#13;
<h1><span class="label">Chapter 20. </span>Filters, Blending, Clipping, and Masking</h1>&#13;
&#13;
&#13;
<p>Several special properties allow authors to alter the appearance of elements with visual filters, specify different ways to visually blend elements with whatever is behind them, and alter the presentation of elements by showing parts and hiding other parts.  While these may seem like disparate concepts, they all share one thing in common: they allow elements to be altered in ways that were previously difficult or impossible.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CSS Filters" data-type="sect1"><div class="sect1" id="idm45176032650368">&#13;
<h1>CSS Filters</h1>&#13;
&#13;
<p>CSS <a data-primary="filter property" data-type="indexterm" id="ix_filter_prop"/><a data-primary="filters" data-type="indexterm" id="ix_filters_ch20"/>provides a way to apply built-in visual filter effects, as well as custom filters defined in the page or in external files, to elements by way of the <code>filter</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176032646048">&#13;
<h1>filter</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>none</code> | <code>blur()</code> | <code>brightness()</code> | <code>contrast()</code> | <code>drop-shadow()</code> | <code>grayscale()</code> | <code>hue-rotate()</code>  | <code>invert()</code> | <code>opacity()</code> | <code>sepia()</code> | <code>saturate()</code> | <code>url()</code> ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <a data-primary="blur radius" data-secondary="filter-effects" data-type="indexterm" id="idm45176032601152"/>value syntax permits a space-separated list of filter functions, with each filter applied in sequence. Thus, given the declaration <code>filter: opacity(0.5) blur(1px);</code>, the opacity is applied to the element, and the semitransparent result is then blurred.  If the order is reversed, so too is the order of application: the fully opaque element is blurred, and the resulting blur made semitransparent.</p>&#13;
&#13;
<p>The CSS <a data-primary="input image" data-type="indexterm" id="idm45176032599184"/>specification talks of “input images” when discussing <code>filter</code>, but this doesn’t mean <code>filter</code> is used only on images.  Any HTML element can be filtered, and all graphic SVG elements can be filtered.  The <em>input image</em> is a visual copy of the rendered element <em>before</em> it is filtered.  Filters are applied to this input, and the final filtered result is then rendered to the display medium (e.g., the device display).</p>&#13;
&#13;
<p>All the values permitted (save <code>url()</code>) are function values, with the permitted value types for each function being dependent on the function in question.  We’ve grouped these functions into a few broad categories for ease of understanding.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Basic Filters" data-type="sect2"><div class="sect2" id="idm45176032595920">&#13;
<h2>Basic Filters</h2>&#13;
&#13;
<p>The following filters are basic in the sense that they cause the changes that their names directly describe—blurring, drop shadows, and opacity changes:</p>&#13;
<dl>&#13;
<dt><code>blur(</code> &lt;<em><code>length</code></em>&gt; <code>)</code></dt>&#13;
<dd>&#13;
<p>Blurs the <a data-primary="blur() function" data-type="indexterm" id="idm45176032591600"/><a data-primary="filters" data-secondary="blurring" data-type="indexterm" id="idm45176032590864"/>element’s contents by using a Gaussian blur whose standard deviation is defined by the &lt;<em><code>length</code></em>&gt; value supplied, where a value of <code>0</code> leaves the element unchanged.  Negative lengths are not permitted.</p>&#13;
</dd>&#13;
<dt><code>opacity(</code> [ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>)</code></dt>&#13;
<dd>&#13;
<p>Applies a <a data-primary="filters" data-secondary="opacity" data-type="indexterm" id="idm45176032585264"/><a data-primary="opacity() function" data-type="indexterm" id="idm45176032584256"/>transparency filter to the element in a manner very similar to the <code>opacity</code> property, where the value <code>0</code> yields a completely transparent element and a value of <code>1</code> or <code>100%</code> leaves the element unchanged.  Negative values are not permitted.  Values greater than <code>1</code> and <code>100%</code> are permitted, but are clipped to be <code>1</code> or <code>100%</code> for the purposes of computing the final value.</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>The specification makes clear that <code>filter: opacity()</code> is <em>not</em> meant to be a replacement or shorthand for the <code>opacity</code> property, and in fact both can be applied to the same element, resulting in a sort of double-transparency.</p>&#13;
</div>&#13;
<dl>&#13;
<dt><code>drop-shadow(</code> &lt;<em><code>length</code></em>&gt;{2,3} &lt;<em><code>color</code></em>&gt;? <code>)</code></dt>&#13;
<dd>&#13;
<p>Creates a <a data-primary="filters" data-secondary="drop shadows" data-type="indexterm" id="ix_filter_drop_shadow2"/><a data-primary="shadows" data-secondary="drop shadow filter" data-type="indexterm" id="ix_shadow_filter"/><a data-primary="drop-shadow() function" data-type="indexterm" id="ix_drop_shadow2"/>drop shadow that matches the shape of the element’s alpha channel, with a blur and using an optional color.  <a data-primary="box-shadow property" data-type="indexterm" id="idm45176032569968"/><a data-primary="shadows" data-secondary="box-shadow property" data-type="indexterm" id="idm45176032569296"/>The handling of the lengths and colors is the same as for the property <code>box-shadow</code>, which means that while the first two &lt;<em><code>length</code></em>&gt; values can be negative, the third (which defines the blur) cannot.  Unlike box-shadow, though, the <code>inset</code> value is not permitted. To apply multiple drop shadows, provide multiple space-separated <code>drop-shadow()</code> functions; unlike <code>box-shadow</code>, comma-separated shadows don’t work here.  If no &lt;<em><code>color</code></em>&gt; value is supplied, the used color is the same as the computed value of the <code>color</code> property for the element.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#filter-basic-effects">Figure 20-1</a> shows some effects of these filter functions.</p>&#13;
&#13;
<figure><div class="figure" id="filter-basic-effects">&#13;
<img alt="css5 2001" src="assets/css5_2001.png"/>&#13;
<h6><span class="label">Figure 20-1. </span>Basic filter effects</h6>&#13;
</div></figure>&#13;
&#13;
<p>Before we go on, two things deserve further exploration.  The first is how <code>drop-shadow()</code> really operates.  Just by looking at <a data-type="xref" href="#filter-basic-effects">Figure 20-1</a>, it’s easy to get the impression that drop shadows are bound to the element box, because of the boxlike nature of the drop shadows shown there.  But that’s just because the image used to illustrate filters is a PNG, which is to say a raster image, and more importantly one that doesn’t have any alpha channel.  The white parts of the image are opaque white, in other words.</p>&#13;
&#13;
<p>If the image has transparent bits, <code>drop-shadow()</code> will use those in computing the shadow.  To see what this means, consider <a data-type="xref" href="#filter-basic-effects-dropshadows">Figure 20-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="filter-basic-effects-dropshadows">&#13;
<img alt="css5 2002" src="assets/css5_2002.png"/>&#13;
<h6><span class="label">Figure 20-2. </span>Drop shadows and alpha channels</h6>&#13;
</div></figure>&#13;
&#13;
<p>The other thing to point out in <a data-type="xref" href="#filter-basic-effects-dropshadows">Figure 20-2</a> is the last image has two drop shadows.  This was accomplished as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">filter</code><code class="o">:</code> <code class="n">drop</code><code class="o">-</code><code class="n">shadow</code><code class="p">(</code><code class="m">0</code> <code class="m">0</code> <code class="m">0.5em</code> <code class="nb">yellow</code><code class="p">)</code> <code class="n">drop</code><code class="o">-</code><code class="n">shadow</code><code class="p">(</code><code class="m">0.5em</code> <code class="m">0.75em</code> <code class="m">30px</code> <code class="nb">gray</code><code class="p">);</code></pre>&#13;
&#13;
<p>Any number of filters can be chained together like this.  To pick another example, you could write the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">filter</code><code class="o">:</code> <code class="n">blur</code><code class="p">(</code><code class="m">3px</code><code class="p">)</code> <code class="n">drop</code><code class="o">-</code><code class="n">shadow</code><code class="p">(</code><code class="m">0.5em</code> <code class="m">0.75em</code> <code class="m">30px</code> <code class="nb">gray</code><code class="p">)</code> <code class="n">opacity</code><code class="p">(</code><code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">);</code></pre>&#13;
&#13;
<p>That would get you a blurry, drop-shadowed, half-opaque element.  It might not be the most reader-friendly effect for text, but it’s possible nonetheless.  This function-chaining is possible with all <code>filter</code> functions, both those you’ve seen and those to come.<a data-primary="" data-startref="ix_drop_shadow2" data-type="indexterm" id="idm45176032482080"/><a data-primary="" data-startref="ix_filter_drop_shadow2" data-type="indexterm" id="idm45176032481232"/><a data-primary="" data-startref="ix_shadow_filter" data-type="indexterm" id="idm45176032480288"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Color Filtering" data-type="sect2"><div class="sect2" id="csstdg4-color-filtering">&#13;
<h2>Color Filtering</h2>&#13;
&#13;
<p>This <a data-primary="filters" data-secondary="color" data-type="indexterm" id="ix_filter_color"/><a data-primary="color filtering" data-type="indexterm" id="ix_color_filter"/>next set of <code>filter</code> functions alter the colors present in the element.  This can be as simple as leaching out the colors, or as complex as shifting all the colors by way of an angle value.</p>&#13;
&#13;
<p>Note that for the first three of the four following functions, all of which accept either a &lt;<em><code>number</code></em>&gt; or &lt;<em><code>percentage</code></em>&gt;, negative values are not permitted; the fourth permits positive and negative angle values:</p>&#13;
<dl>&#13;
<dt><code>grayscale(</code> [ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>)</code></dt>&#13;
<dd>&#13;
<p>Alters <a data-primary="grayscale() function" data-type="indexterm" id="idm45176032449280"/>the colors in the element to be shifted toward shades of gray. A value of <code>0</code> leaves the element unchanged, and a value of <code>1</code> or <code>100%</code> will result in black and white, as a fully grayscale element.</p>&#13;
</dd>&#13;
<dt><code>sepia(</code> [ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>)</code></dt>&#13;
<dd>&#13;
<p>Alters the <a data-primary="sepia() function" data-type="indexterm" id="idm45176032443904"/>colors in the element to be shifted toward shades of sepia tones (sepia is the reddish-brown color used in antique photography, defined by Wikipedia to be equivalent to <code>#704214</code> or <code>rgba(112,66,20)</code> in the sRGB color space). A value of <code>0</code> leaves the element unchanged, and a value of <code>1</code> or <code>100%</code> will result in a fully sepia &#13;
<span class="keep-together">element.</span></p>&#13;
</dd>&#13;
<dt><code>invert(</code> [ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>)</code></dt>&#13;
<dd>&#13;
<p>Inverts<a data-primary="invert() function" data-type="indexterm" id="idm45176032437264"/> all colors in the element.  Each of the R, G, and B values for a given color are inverted by subtracting them from 255 (in 0–255 notation) or from 100% (in 0%–100% notation).  For example, a pixel with the color <code>rgb(255 128 55)</code> will be rendered as <code>rgb(0 127 200)</code>; a different pixel with the value <code>rgb(75% 57.2% 23%)</code> will become <code>rgb(25% 42.8% 77%)</code>.  A value of <code>0</code> leaves the element unchanged, and a value of <code>1</code> or <code>100%</code> results in a fully inverted element.  A value of <code>0.5</code> or <code>50%</code> stops the inversion of each color at the midpoint of the color space, leading to an element of uniform gray regardless of the input element’s appearance.</p>&#13;
</dd>&#13;
<dt><code>hue-rotate(</code> &lt;<em><code>angle</code></em>&gt; <code>)</code></dt>&#13;
<dd>&#13;
<p>Alters the <a data-primary="hue-rotate() function" data-type="indexterm" id="idm45176032429552"/>colors of the image by shifting their hue angle around an HSL color wheel, leaving saturation and lightness unchanged.  A value of <code>0deg</code> means no difference between the input and output images.  A value of <code>360deg</code> (a full single rotation) will also present an apparently unchanged element, though the rotation-angle value is maintained.  Values above <code>360deg</code> are permitted.  Negative values are also permitted, and cause a counterclockwise rotation as opposed to the clockwise rotation caused by positive values.  (In other words, the rotation is “compass-style,” with 0° at the top and increasing angle values in the clockwise direction.)<a data-primary="" data-startref="ix_color_filter" data-type="indexterm" id="idm45176032427312"/><a data-primary="" data-startref="ix_filter_color" data-type="indexterm" id="idm45176032426336"/></p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Examples of the preceding <code>filter</code> functions are shown in <a data-type="xref" href="#filter-color-effects">Figure 20-3</a>, though fully appreciating them depends on a color rendering.</p>&#13;
&#13;
<figure><div class="figure" id="filter-color-effects">&#13;
<img alt="css5 2003" src="assets/css5_2003.png"/>&#13;
<h6><span class="label">Figure 20-3. </span>Color filter effects</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Brightness, Contrast, and Saturation" data-type="sect2"><div class="sect2" id="idm45176032421728">&#13;
<h2>Brightness, Contrast, and Saturation</h2>&#13;
&#13;
<p>While the following <code>filter</code> functions also manipulate color, they do so in closely related ways, and are a familiar grouping to anyone who’s worked with images, particularly photographic images. For all these functions, values greater than <code>1</code> and <code>100%</code> are permitted, but are clipped to be <code>1</code> or <code>100%</code> for the purposes of computing the final value:</p>&#13;
<dl>&#13;
<dt><code>brightness(</code> [ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>)</code></dt>&#13;
<dd>&#13;
<p>Alters the <a data-primary="filters" data-secondary="brightness" data-type="indexterm" id="idm45176032414272"/><a data-primary="brightness() function" data-type="indexterm" id="idm45176032413296"/>brightness of the element’s colors. A value of <code>0</code> leaves the element a solid black, and a value of <code>1</code> or <code>100%</code> leaves it unchanged.  Values above <code>1</code> and <code>100%</code> yield colors brighter than the input element, and can eventually reach a state of solid white.</p>&#13;
</dd>&#13;
<dt><code>contrast(</code> [ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>)</code></dt>&#13;
<dd>&#13;
<p>Alters the <a data-primary="filters" data-secondary="contrast" data-type="indexterm" id="idm45176032406976"/><a data-primary="contrast() function" data-type="indexterm" id="idm45176032406000"/>contrast of the element’s colors. The higher the contrast, the more colors are differentiated from each other; the lower the contrast, the more they converge on each other. A value of <code>0</code> leaves the element a solid gray, and a value of <code>1</code> or <code>100%</code> leaves it unchanged.  Values above <code>1</code> and <code>100%</code> yield colors with greater contrast than is present in the input element.</p>&#13;
</dd>&#13;
<dt><code>saturate(</code> [ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ] <code>)</code></dt>&#13;
<dd>&#13;
<p>Alters the <a data-primary="filters" data-secondary="saturation" data-type="indexterm" id="idm45176032400080"/><a data-primary="saturate() function" data-type="indexterm" id="idm45176032398688"/>saturation of the element’s colors. The more saturated an element’s colors, the more intense they become; the less saturated they are, the more muted they appear.  A value of <code>0</code> leaves the element completely unsaturated, making it effectively grayscale, whereas a value of <code>1</code> or <code>100%</code> leaves the element unchanged.  Similar to <code>brightness()</code>, <code>saturate()</code> permits <em>and</em> acts upon values greater than <code>1</code> or <code>100%</code>; such values result in <em>supersaturation</em>.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>Examples of the preceding <code>filter</code> functions are shown in <a data-type="xref" href="#filter-bcs-effects">Figure 20-4</a>, though fully appreciating them depends on a color rendering.  Also, the effects of greater-than-one values may be hard to make out in the figure, but they are present.</p>&#13;
&#13;
<figure><div class="figure" id="filter-bcs-effects">&#13;
<img alt="css5 2004" src="assets/css5_2004.png"/>&#13;
<h6><span class="label">Figure 20-4. </span>Brightness, contrast, and saturation filter effects</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="SVG Filters" data-type="sect2"><div class="sect2" id="idm45176032389824">&#13;
<h2>SVG Filters</h2>&#13;
&#13;
<p>The <a data-primary="SVG format" data-secondary="filtering" data-type="indexterm" id="ix_svg_filter"/><a data-primary="filters" data-secondary="SVG" data-type="indexterm" id="ix_filter_svg"/>last <code>filter</code> value type is a function of a familiar kind: the <code>url()</code> value type.  This allows you to point to a (potentially very complicated) filter defined in SVG, whether it’s embedded in the document or stored in an external file.</p>&#13;
&#13;
<p>This takes the <a data-primary="url() function" data-type="indexterm" id="idm45176032383968"/>form <code>url(&lt;<em>uri</em>&gt;)</code>, where the &lt;<em><code>uri</code></em>&gt; value points to a filter defined using SVG syntax, specifically the <code>&lt;filter&gt;</code> element.  This can be a reference to a single SVG image that contains only a filter, such as <code>url(wavy.svg)</code>, or it can be a pointer to an identified filter embedded in an SVG image, such as <code>url(filters.svg#wavy)</code>.  The advantage of the latter pattern is that a single SVG file can define multiple filters, thus consolidating all your filtering into one file for easy loading, caching, and <span class="keep-together">referencing.</span></p>&#13;
&#13;
<p>If a <code>url()</code> function points to a nonexistent file, or points to an SVG fragment that is not a <code>&lt;filter&gt;</code> element, the function is invalid and the <em>entire</em> function list is ignored (thus rendering the <code>filter</code> declaration invalid).</p>&#13;
&#13;
<p>Examining the full range of filtering possibilities in SVG is well beyond the scope of this book, but let’s just say that the power of the offered features is substantial.  A few simple examples of SVG filtering are shown in <a data-type="xref" href="#filter-svg-effects">Figure 20-5</a>, with brief captions to indicate the kinds of operations the filters were built to create.  (The actual CSS used to apply these filters looks like <code>filter: url(filters.svg#rough)</code>.)</p>&#13;
&#13;
<figure><div class="figure" id="filter-svg-effects">&#13;
<img alt="css5 2005" src="assets/css5_2005.png"/>&#13;
<h6><span class="label">Figure 20-5. </span>SVG filter effects</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s easily possible to put every last bit of filtering you do into SVG, including replacements for every other <code>filter</code> function you’ve seen.  (In fact, all the other <code>filter</code> functions are defined by the specification as literal SVG filters, to give a precise rendering target for implementors.)  Remember, however, that you can chain CSS functions together.  Thus, you might define a specular-highlight filter in SVG, and modify it with blurring or grayscale functions as needed.  For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.logo</code> <code class="p">{</code><code class="k">filter</code><code class="o">:</code> <code class="sx">url(/assets/filters.svg#spotlight)</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.logo.print</code> <code class="p">{</code><code class="k">filter</code><code class="o">:</code> <code class="sx">url(/assets/filters.svg#spotlight)</code> <code class="n">grayscale</code><code class="p">(</code><code class="m">100%</code><code class="p">);}</code>&#13;
<code class="nt">img</code><code class="nc">.logo.censored</code> <code class="p">{</code><code class="k">filter</code><code class="o">:</code> <code class="sx">url(/assets/filters.svg#spotlight)</code> <code class="n">blur</code><code class="p">(</code><code class="m">3px</code><code class="p">);}</code></pre>&#13;
&#13;
<p>Always keep in mind that the filter functions are applied in order.  That’s why the <code>grayscale()</code> and <code>blur()</code> functions come after the <code>url()</code>-imported spotlight filter.  If they were reversed, the logos would be made grayscale or blurred first, and then have the spotlight filter applied afterward.<a data-primary="" data-startref="ix_filters_ch20" data-type="indexterm" id="idm45176032322080"/><a data-primary="" data-startref="ix_filter_prop" data-type="indexterm" id="idm45176032321136"/><a data-primary="" data-startref="ix_filter_svg" data-type="indexterm" id="idm45176032320192"/><a data-primary="" data-startref="ix_svg_filter" data-type="indexterm" id="idm45176032319248"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Compositing and Blending" data-type="sect1"><div class="sect1" id="idm45176032649744">&#13;
<h1>Compositing and Blending</h1>&#13;
&#13;
<p>In addition to <a data-primary="compositing" data-seealso="blending" data-type="indexterm" id="idm45176032316800"/>filtering, CSS enables you to determine how elements are <em>composited</em> together.  Take, for example, two elements that partially overlap because of positioning.  By default, the element in front, if fully opaque, completely obscures the one behind, wherever they overlap.  If the one in front is semitransparent, the element in back is partially visible.</p>&#13;
&#13;
<p>This is sometimes <a data-primary="simple alpha compositing" data-type="indexterm" id="idm45176032307792"/>called <em>simple alpha compositing</em>, in that you can see whatever is behind an element as long as some (or all) of it has alpha channel values less than <code>1</code>.  Think of how you can see the background through an element with <code>opacity: 0.5</code>, or in the areas of a PNG or GIF that are set to be transparent.  That’s simple alpha compositing.</p>&#13;
&#13;
<p>But if you’re <a data-primary="blending" data-type="indexterm" id="ix_blending_ch20"/>familiar with image-editing programs like Photoshop or GIMP, you know that overlapping image layers can be blended together in a variety of ways.  CSS has the same ability.  CSS has two blending strategies (at least as of late 2022): blending entire elements with whatever is behind them, and blending the background layers of a single element together. While similar to filter effects in many ways, blending mode values are predefined—they don’t accept a parameter—and while both filter effects and blend modes support multiple values, the properties that support blend modes use a comma-separated list of values instead of a space-separated list. (This inconsistency in value syntaxes is rooted deep in the history of CSS, and is something we just have to live with for the time being.)</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Blending Elements" data-type="sect2"><div class="sect2" id="blending-elements">&#13;
<h2>Blending Elements</h2>&#13;
&#13;
<p>If <a data-primary="mix-blend-mode property" data-type="indexterm" id="ix_mix_blend_mode_prop"/><a data-primary="blending" data-secondary="elements" data-type="indexterm" id="ix_blend_elem"/>elements overlap, you can change the way they blend together by using the  <code>mix-blend-mode</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176032299312">&#13;
<h1>mix-blend-mode</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>normal</code> | <code>multiply</code> | <code>screen</code> | <code>overlay</code> | <code>darken</code> | <code>lighten</code> | <span class="keep-together"><code>color-dodge</code></span> | <code>color-burn</code> | <code>hard-light</code> | <code>soft-light</code> | <code>difference</code> | <span class="keep-together"><code>exclusion</code></span> | <code>hue</code> | <span class="keep-together"><code>saturation</code></span> | <code>color</code> | <code>luminosity</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The CSS specification indicates that this property “defines the formula that must be used to mix the colors with the backdrop.”  The element is blended with whatever is behind it (the “backdrop”), whether that’s pieces of another element, or just the background of an ancestor element such as the <code>&lt;body&gt;</code>.</p>&#13;
&#13;
<p>The default value, <code>normal</code>, shows the element’s pixels as is, without any mixing with the backdrop, except where the alpha channel is less than <code>1</code>.  This is the simple alpha compositing mentioned previously.  It’s what we’re all used to, which is why it’s the default value.  <a data-type="xref" href="#blending-elements-normal">Figure 20-6</a> shows a few examples.</p>&#13;
&#13;
<figure><div class="figure" id="blending-elements-normal">&#13;
<img alt="css5 2006" src="assets/css5_2006.png"/>&#13;
<h6><span class="label">Figure 20-6. </span>Simple alpha-channel blending</h6>&#13;
</div></figure>&#13;
&#13;
<p>For the <a data-primary="mix-blend-mode property" data-secondary="non-mode categories" data-type="indexterm" id="idm45176032273120"/>rest of the <code>mix-blend-mode</code> keywords, we’ve grouped them into a few categories.  Let’s also nail down a few definitions we’ll be using in the blend mode descriptions:</p>&#13;
<dl>&#13;
<dt>Foreground</dt>&#13;
<dd>&#13;
<p>The element that has <code>mix-blend-mode</code> applied to it.</p>&#13;
</dd>&#13;
<dt>Backdrop</dt>&#13;
<dd>&#13;
<p>Whatever is behind an element.  This can be other elements, the background of an ancestor element, and so on.</p>&#13;
</dd>&#13;
<dt>Pixel component</dt>&#13;
<dd>&#13;
<p>The color component of a given pixel: R, G, and B.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>If it helps, think of the foreground and backdrop as layers atop each other in an image-editing program.  With <code>mix-blend-mode</code>, you can change the blend mode applied to the top element (the foreground).</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Darken, lighten, difference, and exclusion" data-type="sect3"><div class="sect3" id="idm45176032265232">&#13;
<h3>Darken, lighten, difference, and exclusion</h3>&#13;
&#13;
<p>The following blend modes might be called <em>simple-math modes</em>—they achieve their effect by directly comparing values in some way, or using simple addition and subtraction to modify pixels:</p>&#13;
<dl>&#13;
<dt><code>darken</code></dt>&#13;
<dd>&#13;
<p>Each <a data-primary="mix-blend-mode property" data-secondary="darken blend mode" data-type="indexterm" id="idm45176032261488"/><a data-primary="darken blend mode" data-type="indexterm" id="idm45176032260480"/>pixel in the foreground is compared with the corresponding pixel in the backdrop, and for each of the R, G, and B values (the pixel components), the smaller of the two is kept.  Thus, if the foreground pixel has a value corresponding to <code>rgb(91 164 22)</code> and the backdrop pixel is <code>rgb(102 104 255)</code>, the resulting pixel will be <code>rgb(91 104 22)</code>.</p>&#13;
</dd>&#13;
<dt><code>lighten</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="lighten blend mode" data-type="indexterm" id="idm45176032256768"/><a data-primary="mix-blend-mode property" data-secondary="lighten blend mode" data-type="indexterm" id="idm45176032256064"/>blend is the inverse of <code>darken</code>: when comparing the R, G, and B components of a foreground pixel and its corresponding backdrop pixel, the larger of the two values is kept.  Thus, if the foreground pixel has a value corresponding to <code>rgb(91 164 22)</code> and the backdrop pixel is <code>rgb(102 104 255)</code>, the resulting pixel will be <code>rgb(102 164 255)</code>.</p>&#13;
</dd>&#13;
<dt><code>difference</code></dt>&#13;
<dd>&#13;
<p>The R, G, and B <a data-primary="difference blend mode" data-type="indexterm" id="idm45176032251984"/><a data-primary="mix-blend-mode property" data-secondary="difference blend mode" data-type="indexterm" id="idm45176032251248"/>components of each pixel in the foreground are compared to the corresponding pixel in the backdrop, and the absolute value of subtracting one from the other is the final result.  Thus, if the foreground pixel has a value corresponding to <code>rgb(91 164 22)</code> and the backdrop pixel is <code>rgb(102 104 255)</code>, the resulting pixel will be <code>rgb(11 60 233)</code>. If one of the pixels is white, the resulting pixel will be the inverse of the nonwhite pixel.  If one of the pixels is black, the result will be exactly the same as the nonblack pixel.</p>&#13;
</dd>&#13;
<dt><code>exclusion</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="exclusion blend mode" data-type="indexterm" id="idm45176032247520"/><a data-primary="mix-blend-mode property" data-secondary="exclusion blend mode" data-type="indexterm" id="idm45176032246400"/>blend is a milder version of <code>difference</code>.  Rather than <em>| back</em> – <em>fore</em>, the formula is <em>back</em> + <em>fore</em> – (2 × <em>back</em> × <em>fore</em>), where <em>back</em> and <em>fore</em> are values in the range 0 to 1.  For example, an exclusion calculation of an orange (<code>rgb(100% 50% 0%)</code>) and a medium gray (<code>rgb(50% 50% 50%)</code>) will yield <code>rgb(50% 50% 50%)</code>.  For the green component, as an example, the math is 0.5 + 0.5 – (2 × 0.5 × 0.5), which reduces to 0.5, corresponding to <code>50%</code>.  Compare this to <code>difference</code>, where the result would be <code>rgb(50% 0% 50%)</code>, since each component is the absolute value of subtracting one from the other.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>This last definition highlights that, for all blend modes, the actual values being operated on are in the range 0–1.  The previous examples showing values like <code>rgb(11 60 233)</code> are normalized from the 0–1 range.  In other words, given the example of applying the <code>difference</code> blend mode to <code>rgb(91 164 22)</code> and <code>rgb(102 104 255)</code>, the actual operation is as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p><code>rgb(91 164 22)</code> is <em>R</em> = 91 ÷ 255 = 0.357; <em>G</em> = 164 ÷ 255 = 0.643; <em>B</em> = 22 ÷ 255 = 0.086.  Similarly, <code>rgb(102 104 255)</code> corresponds to <em>R</em> = 0.4; <em>G</em> = 0.408; <em>B</em> = 1.</p>&#13;
</li>&#13;
<li>&#13;
<p>Each component is subtracted from the corresponding component, and the absolute value taken.  Thus, <em>R</em> = | 0.357 – 0.4 | = 0.043; <em>G</em> = | 0.643 – 0.408 | = 0.235; <em>B</em> = | 1 – 0.086 | = 0.914.  This could be expressed as <code>rgba(4.3% 23.5% 91.4%)</code>, or (by multiplying each component by 255) as <code>rgb(11 60 233)</code>.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>From all this, you can perhaps understand why the full formulas are not written out for every blend mode we cover.  If you’re interested in the fine details, each blend mode’s formula is provided in the <a href="https://drafts.fxtf.org/compositing/#blendingseparable">“Compositing and Blending Level 2”</a> specification.</p>&#13;
&#13;
<p><a data-type="xref" href="#blending-elements-dark-light-diff-excl">Figure 20-7</a> depicts examples of the blend modes in this section.</p>&#13;
&#13;
<figure><div class="figure" id="blending-elements-dark-light-diff-excl">&#13;
<img alt="css5 2007" src="assets/css5_2007.png"/>&#13;
<h6><span class="label">Figure 20-7. </span>Darken, lighten, difference, and exclusion blending with <code>mix-blend-mode:</code> applied to the foreground image</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Multiply, screen, and overlay" data-type="sect3"><div class="sect3" id="idm45176032223632">&#13;
<h3>Multiply, screen, and overlay</h3>&#13;
&#13;
<p>The following blend modes might be called the <em>multiplication modes</em>—they achieve their effect by multiplying values together:</p>&#13;
<dl>&#13;
<dt><code>multiply</code></dt>&#13;
<dd>&#13;
<p>Each <a data-primary="mix-blend-mode property" data-secondary="multiply blend mode" data-type="indexterm" id="idm45176032219824"/><a data-primary="multiply blend mode" data-type="indexterm" id="idm45176032218816"/>pixel component in the foreground is multiplied by the corresponding pixel component in the backdrop.  This yields a darker version of the foreground, modified by what is underneath.  This blend mode is <em>symmetric</em>, in that the result will be exactly the same even if you were to swap the foreground with the backdrop.</p>&#13;
</dd>&#13;
<dt><code>screen</code></dt>&#13;
<dd>&#13;
<p>Each <a data-primary="mix-blend-mode property" data-secondary="screen blend mode" data-type="indexterm" id="idm45176032215840"/><a data-primary="screen blend mode" data-type="indexterm" id="idm45176032214864"/>pixel component in the foreground is inverted (see <code>invert</code> in <a data-type="xref" href="#csstdg4-color-filtering">“Color Filtering”</a>), multiplied by the inverse of the corresponding pixel component in the backdrop, and the result inverted again.  This yields a lighter version of the foreground, modified by what is underneath.  Like <code>multiply</code>, <code>screen</code> is symmetric.</p>&#13;
</dd>&#13;
<dt><code>overlay</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="mix-blend-mode property" data-secondary="overlay blend mode" data-type="indexterm" id="idm45176032210352"/><a data-primary="overlay blend mode" data-type="indexterm" id="idm45176032209376"/>blend is a combination of <code>multiply</code> and <code>screen</code>.  For foreground pixel components darker than 0.5 (50%), the <code>multiply</code> operation is carried out; for foreground pixel components whose values are above 0.5, <code>screen</code> is used.  This makes the dark areas darker, and the light areas lighter.  This blend mode is <em>not</em> symmetric, because swapping the foreground for the backdrop would mean a different pattern of light and dark, and thus a different pattern of multiplying versus screening.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p class="pagebreak-before"><a data-type="xref" href="#blending-elements-multiply-screen-overlay">Figure 20-8</a> depicts examples of these blend modes.</p>&#13;
&#13;
<figure><div class="figure" id="blending-elements-multiply-screen-overlay">&#13;
<img alt="css5 2008" src="assets/css5_2008.png"/>&#13;
<h6><span class="label">Figure 20-8. </span>Images with <code>mix-blend-mode</code> property set showing multiply, screen, and overlay blending</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hard and soft light" data-type="sect3"><div class="sect3" id="idm45176032202224">&#13;
<h3>Hard and soft light</h3>&#13;
&#13;
<p>The following blend modes are covered here because the first is closely related to a previous blend mode, and the other is just a muted version of the first:</p>&#13;
<dl>&#13;
<dt><code>hard-light</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="hard-light blend mode" data-type="indexterm" id="idm45176032198736"/><a data-primary="mix-blend-mode property" data-secondary="hard-light blend mode" data-type="indexterm" id="idm45176032198000"/>blend is the inverse of <code>overlay</code> blending.  Like <code>overlay</code>, it’s a combination of <code>multiply</code> and <code>screen</code>, but the determining layer is the backdrop.  Thus, for backdrop pixel components darker than 0.5 (50%), the <code>multiply</code> operation is carried out; for backdrop pixel components lighter than 0.5, <code>screen</code> is used.  This makes it appear somewhat as if the foreground is being projected onto the backdrop with a projector that employs a harsh light.</p>&#13;
</dd>&#13;
<dt><code>soft-light</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="mix-blend-mode property" data-secondary="soft-light blend mode" data-type="indexterm" id="idm45176032192704"/><a data-primary="soft-light blend mode" data-type="indexterm" id="idm45176032191696"/>blend is a softer version of <code>hard-light</code>.  This mode uses the same operation but is muted in its effects.  The intended appearance is as if the foreground is being projected onto the backdrop with a projector that employs a diffuse light.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p class="pagebreak-before"><a data-type="xref" href="#blending-elements-hard-soft-light">Figure 20-9</a> depicts examples of these blend modes.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="blending-elements-hard-soft-light">&#13;
<img alt="css5 2009" src="assets/css5_2009.png"/>&#13;
<h6><span class="label">Figure 20-9. </span>Hard- and soft-light blending</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Color dodge and burn" data-type="sect3"><div class="sect3" id="idm45176032186400">&#13;
<h3>Color dodge and burn</h3>&#13;
&#13;
<p>Color dodging and burning—terms that come from old darkroom techniques performed on chemical film stock—are meant to lighten or darken a picture with a minimum of change to the colors themselves. These modes are as follows:</p>&#13;
<dl>&#13;
<dt><code>color-dodge</code></dt>&#13;
<dd>&#13;
<p>Each <a data-primary="mix-blend-mode property" data-secondary="color-dodge blend mode" data-type="indexterm" id="idm45176032183264"/><a data-primary="color-dodge blend mode" data-type="indexterm" id="idm45176032182256"/>pixel component in the foreground is inverted, and the component of the corresponding backdrop pixel component is divided by the inverted foreground value.  This yields a brightened backdrop unless the foreground value is <code>0</code>, in which case the backdrop value is unchanged.</p>&#13;
</dd>&#13;
</dl>&#13;
<dl class="pagebreak-before">&#13;
<dt><code>color-burn</code></dt>&#13;
<dd>&#13;
<p>This <a data-primary="color-burn blend mode" data-type="indexterm" id="idm45176032178912"/><a data-primary="mix-blend-mode property" data-secondary="color-burn blend mode" data-type="indexterm" id="idm45176032178176"/>blend is a reverse of <code>color-dodge</code>: each pixel component in the backdrop is inverted, the inverted backdrop value is divided by the unchanged value of the corresponding foreground pixel component, and the result is then inverted.  This yields a result where the darker the backdrop pixel, the more its color will burn through the foreground pixel.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#blending-elements-color-dodge-burn">Figure 20-10</a> depicts examples of these blend modes.</p>&#13;
&#13;
<figure class="width-75"><div class="figure" id="blending-elements-color-dodge-burn">&#13;
<img alt="css5 2010" src="assets/css5_2010.png"/>&#13;
<h6><span class="label">Figure 20-10. </span>Blending with <code>mix-blend-mode: color-dodge</code> and <code>mix-blend-mode: color-burn</code></h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hue, saturation, luminosity, and color" data-type="sect3"><div class="sect3" id="idm45176032172112">&#13;
<h3>Hue, saturation, luminosity, and color</h3>&#13;
&#13;
<p>The final four blend modes are different from those we’ve shown before, because they do <em>not</em> perform operations on the R/G/B pixel components.  Instead, they perform operations to combine the hue, saturation, luminosity, and color of the foreground and backdrop in different ways.  These modes are as follows:</p>&#13;
<dl>&#13;
<dt><code>hue</code></dt>&#13;
<dd>&#13;
<p>For <a data-primary="hue blend mode" data-type="indexterm" id="idm45176032168272"/><a data-primary="mix-blend-mode property" data-secondary="hue blend mode" data-type="indexterm" id="idm45176032167536"/>each pixel, combines the luminosity and saturation levels of the backdrop with the hue angle of the foreground.</p>&#13;
</dd>&#13;
<dt><code>saturation</code></dt>&#13;
<dd>&#13;
<p>For <a data-primary="saturation blend mode" data-type="indexterm" id="idm45176032164928"/><a data-primary="mix-blend-mode property" data-secondary="saturation blend mode" data-type="indexterm" id="idm45176032164192"/>each pixel, combines the hue angle and luminosity level of the backdrop with the saturation level of the foreground.</p>&#13;
</dd>&#13;
<dt><code>color</code></dt>&#13;
<dd>&#13;
<p>For <a data-primary="color blend mode" data-type="indexterm" id="idm45176032161584"/><a data-primary="mix-blend-mode property" data-secondary="color blend mode" data-type="indexterm" id="idm45176032160848"/>each pixel, combines the luminosity level of the backdrop with the hue angle and saturation level of the foreground.</p>&#13;
</dd>&#13;
<dt><code>luminosity</code></dt>&#13;
<dd>&#13;
<p>For <a data-primary="luminosity blend mode" data-type="indexterm" id="idm45176032158240"/><a data-primary="mix-blend-mode property" data-secondary="luminosity blend mode" data-type="indexterm" id="idm45176032157504"/>each pixel, combines the hue angle and saturation level of the backdrop with the luminosity level of the foreground.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#blending-elements-hue-sat-lum-color">Figure 20-11</a> depicts examples of these blend modes.</p>&#13;
&#13;
<figure><div class="figure" id="blending-elements-hue-sat-lum-color">&#13;
<img alt="css5 2011" src="assets/css5_2011.png"/>&#13;
<h6><span class="label">Figure 20-11. </span>Hue, saturation, luminosity, and color blending</h6>&#13;
</div></figure>&#13;
&#13;
<p>These blend modes can be a lot harder to grasp without busting out raw formulas, and even those can be confusing if you aren’t familiar with how things like saturation and luminosity levels are determined.  If you don’t feel like you quite have a handle on how these modes work, the best solution is to practice with a bunch of images and simple &#13;
<span class="keep-together">color patterns.</span></p>&#13;
&#13;
<p class="pagebreak-before">Two points to note:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Remember that an element always blends with its backdrop.  If there are other elements behind an element, it will blend with them; if there’s a patterned background on the parent element, the blending will be done against that pattern.</p>&#13;
</li>&#13;
<li>&#13;
<p>Changing the opacity of a blended element will change the outcome, though not always in the way you might expect.  For example, if an element with <code>mix-blend-mode: difference</code> is also given <code>opacity: 0.8</code>, the difference calculations will be scaled by 80%.  More precisely, a scaling factor of 0.8 will be applied to the color-value calculations.  This can cause some operations to trend toward flat middle gray and others to shift the color changes.<a data-primary="" data-startref="ix_blend_elem" data-type="indexterm" id="idm45176032148448"/><a data-primary="" data-startref="ix_mix_blend_mode_prop" data-type="indexterm" id="idm45176032147472"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Blending Backgrounds" data-type="sect2"><div class="sect2" id="idm45176032146016">&#13;
<h2>Blending Backgrounds</h2>&#13;
&#13;
<p>Blending an <a data-primary="backgrounds" data-secondary="blending" data-type="indexterm" id="ix_back_blends"/><a data-primary="blending" data-secondary="backgrounds" data-type="indexterm" id="ix_blend_background"/><a data-primary="background-blend-mode property" data-type="indexterm" id="ix_back_blend_mode_prop"/>element with its backdrop is one thing, but what if an element has multiple background images that overlap and also need to be blended together?  That’s where <code>background-blend-mode</code> comes in.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176032140288">&#13;
<h1>background-blend-mode</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>normal</code> | <code>multiply</code> | <code>screen</code> | <code>overlay</code> | <code>darken</code> | <code>lighten</code> | <span class="keep-together"><code>color-dodge</code></span> | <code>color-burn</code> | <code>hard-light</code> | <code>soft-light</code> | <code>difference</code> | <code>exclusion</code> | <code>hue</code> | <span class="keep-together"><code>saturation</code></span> | <code>color</code> | <code>luminosity</code>]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>normal</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>We won’t go through an exhaustive list of all the blend modes and what they mean, because we did that in <a data-type="xref" href="#blending-elements">“Blending Elements”</a>.  What they meant there, they mean here.</p>&#13;
&#13;
<p>The difference is that when it comes to blending multiple background images, they’re blended with one other against an empty background—that is, a completely transparent, uncolored backdrop.  They do <em>not</em> blend with the backdrop of the element, except as directed by <code>mix-blend-mode</code>. To see what that means, consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code><code class="k">background-image</code><code class="o">:</code>&#13;
        <code class="sx">url(star.svg)</code><code class="o">,</code>&#13;
        <code class="sx">url(diamond.png)</code><code class="o">,</code>&#13;
        <code class="n">linear</code><code class="o">-</code><code class="n">gradient</code><code class="p">(</code><code class="m">135deg</code><code class="o">,</code> <code class="m">#F00</code><code class="o">,</code> <code class="m">#AEA</code><code class="p">);</code>&#13;
    <code class="k">background-blend-mode</code><code class="o">:</code> <code class="n">color</code><code class="o">-</code><code class="n">burn</code><code class="o">,</code> <code class="n">luminosity</code><code class="o">,</code> <code class="n">darken</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Here we have three background images, each with its own blend mode.  These are blended together into a single result, shown in <a data-type="xref" href="#blending-backgrounds-threebgs">Figure 20-12</a>.</p>&#13;
&#13;
<figure><div class="figure" id="blending-backgrounds-threebgs">&#13;
<img alt="css5 2012" src="assets/css5_2012.png"/>&#13;
<h6><span class="label">Figure 20-12. </span>Three backgrounds blended together</h6>&#13;
</div></figure>&#13;
&#13;
<p>So far, fine.  Here’s the kicker: the result will be the same regardless of what might appear behind the element.  We can change the parent’s background to white, gray, fuchsia, or a lovely pattern of repeating gradients, and in every case those three blended backgrounds will look exactly the same, pixel for pixel.  They’re blended in <em>isolation</em>, a term we’ll return to shortly. We can see the previous example (<a data-type="xref" href="#blending-backgrounds-threebgs">Figure 20-12</a>) sitting atop a variety of backgrounds in <a data-type="xref" href="#blending-backgrounds-color-transparent">Figure 20-13</a>.</p>&#13;
&#13;
<figure><div class="figure" id="blending-backgrounds-color-transparent">&#13;
<img alt="css5 2013" src="assets/css5_2013.png"/>&#13;
<h6><span class="label">Figure 20-13. </span>Blending with color versus transparency</h6>&#13;
</div></figure>&#13;
&#13;
<p>Like multiple blended elements stacked atop one another, the blending of background layers works from the back to the front.  Thus, if you have two background images over a solid background color, the background layer in the back is blended with the background color, and then the frontmost layer is blended with the result of the first blend.  Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.bbm</code> <code class="p">{</code><code class="k">background-image</code><code class="o">:</code>&#13;
        <code class="sx">url(star.svg)</code><code class="o">,</code>&#13;
        <code class="sx">url(diamond.png)</code><code class="p">;</code>&#13;
    <code class="k">background-color</code><code class="o">:</code> <code class="nb">goldenrod</code><code class="p">;</code>&#13;
    <code class="k">background-blend-mode</code><code class="o">:</code> <code class="n">color</code><code class="o">-</code><code class="n">burn</code><code class="o">,</code> <code class="n">luminosity</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Given these styles, <em>diamond.png</em> is blended with the background color <code>goldenrod</code> using the <code>luminosity</code> blend.  Once that’s done, <em>star.svg</em> is blended with the results of the diamond-goldenrod blend using a <code>color-burn</code> blend.</p>&#13;
&#13;
<p>Although it’s true that the background layers are blended in isolation, they’re also part of an element that may have its own blending rules via <code>mix-blend-mode</code>.  Thus, the final result of the isolated background blend may be blended with the element’s backdrop after all.  Given the following styles, the first example’s background will sit atop the element’s backdrop, but the rest will end up blended with it in some fashion, as illustrated in <a data-type="xref" href="#blending-backgrounds-backdrops">Figure 20-14</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.one</code> <code class="p">{</code><code class="k">mix-blend-mode</code><code class="o">:</code> <code class="n">normal</code><code class="p">;}</code>&#13;
<code class="nc">.two</code> <code class="p">{</code><code class="k">mix-blend-mode</code><code class="o">:</code> <code class="n">multiply</code><code class="p">;}</code>&#13;
<code class="nc">.three</code> <code class="p">{</code><code class="k">mix-blend-mode</code><code class="o">:</code> <code class="n">darken</code><code class="p">;}</code>&#13;
<code class="nc">.four</code> <code class="p">{</code><code class="k">mix-blend-mode</code><code class="o">:</code> <code class="n">luminosity</code><code class="p">;}</code>&#13;
<code class="nc">.five</code> <code class="p">{</code><code class="k">mix-blend-mode</code><code class="o">:</code> <code class="n">color</code><code class="o">-</code><code class="n">dodge</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"bbm one"</code><code class="nt">&gt;&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"bbm two"</code><code class="nt">&gt;&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"bbm three"</code><code class="nt">&gt;&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"bbm four"</code><code class="nt">&gt;&lt;/div&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;div</code><code class="w"> </code><code class="na">class=</code><code class="s">"bbm five"</code><code class="nt">&gt;&lt;/div&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="blending-backgrounds-backdrops">&#13;
<img alt="css5 2014" src="assets/css5_2014.png"/>&#13;
<h6><span class="label">Figure 20-14. </span>Blending elements with their backdrops</h6>&#13;
</div></figure>&#13;
&#13;
<p>Throughout this section, we’ve touched on the concept of blending in isolation as a thing that backgrounds naturally do.  Elements, on the other hand, do not naturally blend in isolation.  As you’ll see next, that behavior can be changed.<a data-primary="" data-startref="ix_back_blend_mode_prop" data-type="indexterm" id="idm45176031878272"/><a data-primary="" data-startref="ix_back_blends" data-type="indexterm" id="idm45176031877296"/><a data-primary="" data-startref="ix_blend_background" data-type="indexterm" id="idm45176031910880"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Blending in Isolation" data-type="sect2"><div class="sect2" id="blending-in-isolation1">&#13;
<h2>Blending in Isolation</h2>&#13;
&#13;
<p>Sometimes you might want to <a data-primary="isolation property" data-type="indexterm" id="ix_isol_prop"/><a data-primary="blending" data-secondary="in isolation" data-secondary-sortas="isolation" data-type="indexterm" id="ix_blend_isol"/>blend multiple elements together, but in a group of their own, in the same way background layers on an element are blended.  This is, as you’ve seen, called blending in <em>isolation</em>.  If that’s what you’re after, the <code>isolation</code> property is &#13;
<span class="keep-together">for you.</span></p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176031903968">&#13;
<h1>isolation</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>auto</code> | <code>isolate</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, it applies to container elements, graphics elements, and graphics-referencing elements)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This pretty much does exactly what it says: it either defines an element to create an isolated blending context, or not.  Given the following styles, then, we get the result shown in <a data-type="xref" href="#blending-isolation">Figure 20-15</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">mix-blend-mode</code><code class="o">:</code> <code class="n">difference</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.alone</code> <code class="p">{</code><code class="k">isolation</code><code class="o">:</code> <code class="n">isolate</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"alone"</code><code class="nt">&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"diamond.png"</code><code class="nt">&gt;&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"diamond.png"</code><code class="nt">&gt;&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="width-50"><div class="figure" id="blending-isolation">&#13;
<img alt="css5 2015" src="assets/css5_2015.png"/>&#13;
<h6><span class="label">Figure 20-15. </span>Blending in isolation, and not</h6>&#13;
</div></figure>&#13;
&#13;
<p>Take particular note of where <code>isolation</code> is applied, and where <code>mix-blend-mode</code> is applied.  The image is given the blend mode, but the containing element (in this case, a paragraph) is set to isolation blending.  It’s done this way because you want the parent (or ancestor element) to be isolated from the rest of the document, in terms of how its descendant elements are blended.  So if you want an element to blend in isolation, look for an ancestor element to set to <code>isolation: isolate</code>.</p>&#13;
&#13;
<p>An interesting wrinkle arises in all of this: any element that establishes a stacking context is automatically isolated, regardless of the <code>isolation</code> value.  For example, if you transform an element by using the <code>transform</code> property, it will become isolated.</p>&#13;
&#13;
<p class="pagebreak-before">The complete list of stacking-context-establishing conditions, as of late 2022, is as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The root element (e.g., <code>&lt;html&gt;</code>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Making an element a flex or grid item <em>and</em> setting its <code>z-index</code> to anything other than <code>auto</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Positioning an element with <code>relative</code> or <code>absolute</code> <em>and</em> setting its <code>z-index</code> to anything other than <code>auto</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Positioning an element with <code>fixed</code> or <code>sticky</code>, regardless of its <code>z-index</code> value</p>&#13;
</li>&#13;
<li>&#13;
<p>Setting <code>opacity</code> to anything other than <code>1</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Setting <code>transform</code> to anything other than <code>none</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Setting <code>mix-blend-mode</code> to anything other than <code>normal</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Setting <code>filter</code> to anything other than <code>none</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Setting <code>perspective</code> to anything other than <code>none</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Setting <code>mask-image</code>, <code>mask-border</code>, or <code>mask</code> to anything other than <code>none</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Setting <code>isolation</code> to <code>isolate</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Setting <code>contain</code> to a value that contains <code>layout</code> or <code>paint</code></p>&#13;
</li>&#13;
<li>&#13;
<p>Applying <code>will-change</code> to any of the other properties, even if they are not actually changed</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Thus, if you have a group of elements that are blended together and then blended with their shared backdrop, and you then transition the group’s <code>opacity</code> from <code>1</code> to <code>0</code>, the group will suddenly become isolated during the transition.  This might have no visual impact, depending on the original set of blends, but it very well might.<a data-primary="" data-startref="ix_blending_ch20" data-type="indexterm" id="idm45176031755056"/><a data-primary="" data-startref="ix_blend_isol" data-type="indexterm" id="idm45176031754080"/><a data-primary="" data-startref="ix_isol_prop" data-type="indexterm" id="idm45176031753136"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Containing Elements" data-type="sect1"><div class="sect1" id="contain">&#13;
<h1>Containing Elements</h1>&#13;
&#13;
<p>Similar to <a data-primary="elements" data-secondary="containment of" data-type="indexterm" id="ix_elem_contain"/><a data-primary="contain property" data-type="indexterm" id="ix_contain_prop"/>isolating elements for the purposes of blending modes, CSS has a property called <code>contain</code> that sets limits on how much an element’s layout can be affected by other content, and how much its layout will affect other content.  It’s meant as a way for authors to give optimization hints to browsers.</p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176031746960">&#13;
<h1>contain</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p><code>none</code> | [ <code>size</code> ‖ <code>layout</code> ‖ <code>style</code> ‖ <code>paint</code> ] | <code>strict</code> | <code>content</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (with caveats given later)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The default, <code>none</code>, means no containment is indicated and so no optimization hints are given.  Each of the other values has its own peculiar effects, so we’ll examine them in turn.</p>&#13;
&#13;
<p>Perhaps the simplest of the four alternatives is <code>contain: paint</code>.  With this value set, the painting of an element is confined to its overflow box, so that any descendants cannot be painted outside that area.  This is in many ways similar to <code>overflow: hidden</code>.  The difference here is that with paint containment enabled, there will never be a way to reveal the unpainted portions of the element and its descendants; thus, no scrollbar, click-dragging, or other user action will bring the unpainted content into view.  This allows browsers to completely ignore the layout and painting of elements that are entirely offscreen or otherwise not visible, since their descendants cannot be displayed either.</p>&#13;
&#13;
<p>A step up from that in complexity is <code>contain: style</code>.  With the <code>style</code> value, things like counter increments and resets, and quotation-mark nesting, are calculated within the contained element as though no such styles exist outside it, and furthermore, they cannot leave the element to affect other elements.  <a data-primary="scoped styles" data-type="indexterm" id="idm45176031728080"/>This sounds like it creates <em>scoped styles</em>, where you can have a set of styles just apply to a subtree of the DOM, but it doesn’t, really.  It does that only for things like counters and quote nesting.</p>&#13;
&#13;
<p>A more impactful option is <code>contain: size</code>.  This value makes it so that an element is laid out without checking to see how its descendant elements might affect its layout, and furthermore, its size is calculated as though it has no descendants, which means it will have zero height.  It’s also treated as though it has no intrinsic aspect ratio, even if the element is an <code>&lt;img&gt;</code>, <code>&lt;svg&gt;</code>, form input, or something else that would ordinarily have an intrinsic aspect ratio.</p>&#13;
&#13;
<p>Here are a couple examples of size containment, illustrated in <a data-type="xref" href="#size_containment">Figure 20-16</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="n">contain</code><code class="o">:</code> <code class="k">size</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="nb">medium</code> <code class="nb">solid</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">1px</code><code class="p">;}</code>&#13;
<code class="nt">figure</code> <code class="nt">img</code> <code class="p">{</code><code class="n">contain</code><code class="o">:</code> <code class="k">size</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">300px</code><code class="p">;}</code></pre>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p&gt;</code>This<code class="w"> </code>is<code class="w"> </code>a<code class="w"> </code>paragraph.<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
&#13;
<code class="nt">&lt;figure&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"i/bigimg.gif"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">   </code><code class="nt">&lt;figcaption&gt;</code>That’s<code class="w"> </code>a<code class="w"> </code>big<code class="w"> </code>image.<code class="nt">&lt;/figcaption&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/figure&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="size_containment">&#13;
<img alt="" src="assets/css5_2016.png"/>&#13;
<h6><span class="label">Figure 20-16. </span>Examples of size containment</h6>&#13;
</div></figure>&#13;
&#13;
<p>Maybe that’s interesting, but is it useful?  To pick one example, it could be when JavaScript is used to size elements based on the sizes of their ancestors, rather than the other way around (<em>container queries</em> by another name) in order to prevent layout loops.  It could also be applied to elements known to be offscreen at page render, in order to minimize the amount of work required by the browser.</p>&#13;
&#13;
<p>The last kind of containment is invoked with <code>contain: layout</code>.  This allows fragments to come into it, but no fragments to escape, as might be possible with proposed features like CSS Regions. When <code>layout</code> is set, the internal layout of the element is isolated from the rest of the page. This means that nothing in the element affects anything outside the element and that nothing outside the element affects the element’s internal layout.</p>&#13;
&#13;
<p>More than one of these keywords can be used in a single rule, such as <code>contain: size paint</code>.  This leads to the last two possible keywords, <code>content</code> and <code>strict</code>.  The <code>content</code> keyword is shorthand for <code>layout paint style</code>, and <code>strict</code> is shorthand for <code>size layout paint style</code>.  In other words, <code>content</code> contains everything but size, and <code>strict</code> contains in all possible ways.</p>&#13;
&#13;
<p>An important caveat is that <code>contain</code> can apply to elements with the following exceptions: elements that do not generate a box (e.g., <code>display: none</code> or <code>display: contents</code>), internal table boxes that aren’t table cells, internal&#13;
Ruby boxes, and nonatomic inline-level boxes can’t be set to <code>paint</code>, <code>size</code>, or <code>layout</code>.  Furthermore, elements that have an inside display type of <code>table</code> (e.g., <code>&lt;table&gt;</code>) can’t be set to <code>size</code>.  Any element can be set to <code>style</code>.</p>&#13;
&#13;
<p>We have one more caveat to mention: some forms of containment can be invoked even without <code>contain</code>.  For example, <code>overflow: hidden</code> will have effectively the same result as <code>contain: paint</code>, even though <code>contain: none</code> may apply to the same element.<a data-primary="" data-startref="ix_contain_prop" data-type="indexterm" id="idm45176031623792"/></p>&#13;
&#13;
<p>All this <a data-primary="content-visibility property" data-type="indexterm" id="idm45176031592736"/>leads us to the other containment property, <code>content-visibility</code>, which effectively invokes kinds of containment, as well as potentially suppressing the rendering of an element’s contents.</p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176031591488">&#13;
<h1>content-visibility</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p><code>visible</code> | <code>hidden</code> | <code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>visible</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Elements that can be layout-contained</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>In the default case, <code>visible</code>, the contents of an element are shown as normal.</p>&#13;
&#13;
<p>If the <code>hidden</code> value is used, none of the element’s contents are rendered, and they do not participate in the sizing of the element, as if all the contents (including any text outside of descendant elements) had been set to <code>display: none</code>.  Furthermore, the suppressed content should not be available to things such as page search and tab-order navigation, and should not be selectable (as with mouse click-and-drag) or focusable.</p>&#13;
&#13;
<p>If <code>auto</code> is used, paint, style, and layout containment are enabled, as if having declared <code>contain: content</code>.  The content may be skipped by the user agent or may not; most likely, it will be if the element is offscreen or otherwise not visible, but that’s up to the user agent.  The contents in this case <em>are</em> available to page search and tab-order navigation, and can be selected and focused.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of early 2023, <code>content-visibility</code> is behind a flag in Firefox and not supported in Safari.</p>&#13;
</div>&#13;
&#13;
<p>To be honest, you probably shouldn’t be messing with <code>contain</code> or <code>content-visibility</code> unless you know with absolute certainty that you really need them, and you’ll more likely be setting and disabling them via JavaScript.  But they’re there when you do need them.<a data-primary="" data-startref="ix_elem_contain" data-type="indexterm" id="idm45176031571344"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Float Shapes" data-type="sect1"><div class="sect1" id="float_shapes">&#13;
<h1>Float Shapes</h1>&#13;
&#13;
<p>Let’s take a <a data-primary="shaping content around floats" data-type="indexterm" id="ix_shape_float"/><a data-primary="text properties" data-secondary="shaping content around floats" data-type="indexterm" id="ix_text_float_shape"/><a data-primary="floating" data-secondary="shaping content around floats" data-type="indexterm" id="ix_float_shaping"/>moment to return to the world of floating elements and see how we can shape the way text flows past them.  Old-school web designers may remember techniques such as <em>ragged floats</em> and <em>sandbagging</em>—in both cases, using a series of short, floated images of varying widths to create ragged float shapes. <a data-primary="CSS Shapes" data-type="indexterm" id="idm45176031564096"/>Thanks to CSS Shapes, these tricks are no longer needed.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In the future, shapes may be available for nonfloated elements such as elements placed using CSS Grid, but as of late 2022, they’re allowed on only floated elements.</p>&#13;
</div>&#13;
&#13;
<p>To <a data-primary="shape-outside property" data-type="indexterm" id="ix_shape_out_prop"/>shape the flow of content around a floated element, you need to define a shape. The property <code>shape-outside</code> is how you do so.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176031559984">&#13;
<h1>shape-outside</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Value</strong></p></td>&#13;
<td><p><code>none</code> | [ &lt;<em><code>basic-shape</code></em>&gt; ‖ &lt;<em><code>shape-box</code></em>&gt; ] | &lt;<em><code>image</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Floats</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>For a &lt;<em><code>basic-shape</code></em>&gt;, as defined (see below); for an&#13;
&lt;<em><code>image</code></em>&gt;, its URL made absolute; otherwise, as specified (see below)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>basic-shape</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>With <code>none</code>, there’s no shaping except the margin box of the&#13;
float itself—same as it ever was. That’s straightforward and boring.&#13;
Time for the good stuff.</p>&#13;
&#13;
<p>Let’s start with using an image to define the float shape, as it’s both&#13;
the simplest and (in many ways) the most exciting. Say we have an image&#13;
of a crescent moon, and we want the content to flow around the visible&#13;
parts of it. If that image has transparent parts, as in a GIF or a&#13;
PNG, then the content will flow into those transparent parts, as shown&#13;
in <a data-type="xref" href="#using_an_image_to_define_fig">Figure 20-17</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.lunar</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code> <code class="k">shape-outside</code><code class="o">:</code> <code class="sx">url(moon.png)</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;img</code><code class="w"> </code><code class="na">class=</code><code class="s">"lunar"</code><code class="w"> </code><code class="na">src=</code><code class="s">"moon.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"a crescent moon"</code><code class="nt">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>In most cases, when you have a floated image, you’ll just use that same image as its shape.  You don’t have to—you can always load a second, different image to create a float shape that doesn’t match the visible image—but using a single image as both the float and its shape is by far the most common use case.  We’ll talk in the following sections about how&#13;
to push the content away from the visible parts of the image, and how to&#13;
vary the transparency threshold that determines the shape; but for now,&#13;
let’s just savor the power this affords us.</p>&#13;
&#13;
<figure><div class="figure" id="using_an_image_to_define_fig">&#13;
<img alt="image" src="assets/css5_2017.png"/>&#13;
<h6><span class="label">Figure 20-17. </span>Using an image to define a float shape</h6>&#13;
</div></figure>&#13;
&#13;
<p>One point needs to be clarified at this stage: the content will flow into transparent parts to which it has “direct&#13;
access,” for lack of a better term. That is, the content doesn’t flow to&#13;
both the left and right of the image in <a data-type="xref" href="#using_an_image_to_define_fig">Figure 20-17</a>, but just the right&#13;
side. That’s the side that faces the content, it being a left-floated&#13;
image. If we right-floated the image, the content would flow into&#13;
the transparent areas on the image’s left side. This is illustrated in&#13;
<a data-type="xref" href="#an_image_float_shape_fig">Figure 20-18</a> (with the text right-aligned to make the effect more obvious):</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">text-align</code><code class="o">:</code> <code class="nb">right</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.lunar</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">right</code><code class="p">;</code> <code class="k">shape-outside</code><code class="o">:</code> <code class="sx">url(moon.png)</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="an_image_float_shape_fig">&#13;
<img alt="image" src="assets/css5_2018.png"/>&#13;
<h6><span class="label">Figure 20-18. </span>An image float shape on the right</h6>&#13;
</div></figure>&#13;
&#13;
<p>Always remember that the image has to have actual areas of transparency&#13;
to create a shape. With an image format like JPEG, or even if you have a&#13;
GIF or PNG with no alpha channel, the shape will be a rectangle,&#13;
exactly as if you’d used <code>shape-outside: none</code>.<a data-primary="" data-startref="ix_shape_out_prop" data-type="indexterm" id="idm45176031448496"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Shaping with Image Transparency" data-type="sect2"><div class="sect2" id="shaping_with_image_transparency">&#13;
<h2>Shaping with Image Transparency</h2>&#13;
&#13;
<p>As you saw in the <a data-primary="shape-image-threshold property" data-type="indexterm" id="idm45176031443760"/><a data-primary="shaping content around floats" data-type="indexterm" id="idm45176031443056"/><a data-primary="shaping content around floats" data-secondary="with image transparency" data-secondary-sortas="image transparency" data-type="indexterm" id="idm45176031442416"/>previous section, it’s possible to use an image with&#13;
transparent areas to define the float shape. Any part of the image that isn’t fully transparent creates the shape.&#13;
That’s the default behavior, anyway, but you can modify it with&#13;
<code>shape-image-threshold</code>.</p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176031440544">&#13;
<h1>shape-image-threshold</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0.0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Floats</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>The same as the specified value after clipping the&#13;
&lt;<em><code>number</code></em>&gt; to the range [0.0, 1.0]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This property lets you decide what level of transparency determines an&#13;
area where content can flow, or, conversely, what level of opacity&#13;
defines the float shape. Thus, with <code>shape-image-threshold: 0.5</code>, any&#13;
part of the image with more than 50% transparency can allow content to&#13;
flow into it, and any part of the image with less than 50% transparency&#13;
is part of the float shape. This is illustrated in <a data-type="xref" href="#using_image_opacity_to_define">Figure 20-19</a>.</p>&#13;
&#13;
<figure><div class="figure" id="using_image_opacity_to_define">&#13;
<img alt="image" src="assets/css5_2019.png"/>&#13;
<h6><span class="label">Figure 20-19. </span>Using image opacity to define the float shape at the 50% opacity level</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you set the value of the <code>shape-image-threshold</code> property to <code>1.0</code>&#13;
(or just <code>1</code>), no part of the image can be part of the shape, so there won’t be one, and the content will flow over the entire float.</p>&#13;
&#13;
<p>On the other hand, a value of <code>0.0</code> (or just <code>0</code>) will make any&#13;
nontransparent part of the image the float shape, as if this property was not even set. Furthermore, any value below 0 is reset to <code>0.0</code>,&#13;
and any above one is reset to <code>1.0</code>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using Inset Shapes" data-type="sect2"><div class="sect2" id="inset_shapes">&#13;
<h2>Using Inset Shapes</h2>&#13;
&#13;
<p>Now let’s turn <a data-primary="shaping content around floats" data-secondary="inset shapes" data-type="indexterm" id="ix_shape_float_inset"/><a data-primary="inset shapes, for floated elements" data-type="indexterm" id="ix_inset_shapes"/>back to the &lt;<em><code>basic-shape</code></em>&gt; and &lt;<em><code>shape-box</code></em>&gt; values. A basic shape is one of the following types:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>inset()</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>circle()</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>ellipse()</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>polygon()</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>In addition, the &lt;<em><code>shape-box</code></em>&gt; can be one of these types:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>margin-box</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-box</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>padding-box</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>content-box</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>These shape boxes indicate the outermost limits of the shape. You can&#13;
use them on their own, as illustrated in <a data-type="xref" href="#basic_shape_boxes_fig">Figure 20-20</a>, where the images have some padding in which a dark background color can be seen, then a thick border, and finally some (invisible, as always) margins.</p>&#13;
&#13;
<figure><div class="figure" id="basic_shape_boxes_fig">&#13;
<img alt="image" src="assets/css5_2020.png"/>&#13;
<h6><span class="label">Figure 20-20. </span>The basic shape boxes</h6>&#13;
</div></figure>&#13;
&#13;
<p>The default shape box is the margin box, which makes sense, since that’s what&#13;
float boxes use when they aren’t being shaped. You can use a shape&#13;
box in combination with a basic shape; thus, for example, you could&#13;
declare <code>shape-outside: inset(10px) border-box</code>. The syntax for each of&#13;
the basic shapes is different, so we’ll take them in turn.</p>&#13;
&#13;
<p>If you’re used to <a data-primary="distance values" data-type="indexterm" id="idm45176031378256"/>working with border images,&#13;
inset shapes should seem familiar. Even if you aren’t, the syntax&#13;
isn’t too complicated. You define distances to move inward from each&#13;
side of the shape box, using from one to four length or percentage values, with an optional corner-rounding value.</p>&#13;
&#13;
<p>To pick a simple case, suppose we want to shrink the shape 2.5 em inside the shape box:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">2.5em</code><code class="p">);</code></pre>&#13;
&#13;
<p>Four offsets are created, each 2.5 em inward from the outside edge of the&#13;
shape box. In this case, the shape box is the margin box, since we&#13;
haven’t altered it. If we wanted the shape to shrink from, say, the&#13;
padding box, the value would change like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">2.5em</code><code class="p">)</code> <code class="nb">padding-box</code><code class="p">;</code></pre>&#13;
&#13;
<p><a data-type="xref" href="#insets_from_two_basic_shape_boxes">Figure 20-21</a> illustrates the two inset shapes we just defined.</p>&#13;
&#13;
<figure><div class="figure" id="insets_from_two_basic_shape_boxes">&#13;
<img alt="image" src="assets/css5_2021.png"/>&#13;
<h6><span class="label">Figure 20-21. </span>Insets from two basic shape boxes</h6>&#13;
</div></figure>&#13;
&#13;
<p>As with margins, padding, borders, and so on, <em>value replication</em> is in&#13;
force: if there are fewer than four lengths or percentages, the&#13;
missing values are derived from the given values. They go in&#13;
TRBL order, and thus the following pairs are&#13;
internally equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">23%</code><code class="p">);</code>&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">23%</code> <code class="m">23%</code> <code class="m">23%</code> <code class="m">23%</code><code class="p">);</code>  <code class="c">/* same as previous */</code>&#13;
&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">1em</code> <code class="m">13%</code><code class="p">);</code>&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">1em</code> <code class="m">13%</code> <code class="m">1em</code> <code class="m">13%</code><code class="p">);</code>  <code class="c">/* same as previous */</code>&#13;
&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">10px</code> <code class="m">0.5em</code> <code class="m">15px</code><code class="p">);</code>&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">10px</code> <code class="m">0.5em</code> <code class="m">15px</code> <code class="m">0.5em</code><code class="p">);</code>  <code class="c">/* same as previous */</code></pre>&#13;
&#13;
<p>An interesting <a data-primary="corners" data-secondary="rounding" data-type="indexterm" id="idm45176031256912"/><a data-primary="rounding corners" data-type="indexterm" id="idm45176031239264"/>aspect of inset shapes is the ability to round the&#13;
corners of the shape after the inset has been calculated. The syntax (and&#13;
effects) are identical to the <code>border-radius</code> property. Thus, if you&#13;
wanted to round the corners of the float shape with a 5-pixel round,&#13;
you’d write something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">7%</code><code class="p">)</code> <code class="n">round</code> <code class="m">5px</code><code class="p">;</code></pre>&#13;
&#13;
<p>On the other hand, if you want each corner to be rounded elliptically,&#13;
so that the elliptical curving is 5 pixels tall and half an em wide,&#13;
you’d write it like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">7%</code> <code class="n">round</code> <code class="m">0.5em</code><code class="o">/</code><code class="m">5px</code><code class="p">);</code></pre>&#13;
&#13;
<p>Setting a different rounding radius in each corner is also possible and&#13;
follows the usual replication pattern, except it starts from the top&#13;
left instead of the top. So if you have more than one value, they’re in&#13;
the order top left, top right, bottom right, bottom left (TL-TR-BR-BL, or TiLTeR-BuRBLe), and are filled in by copying declared values in for the missing values. <a data-type="xref" href="#rounding_the_corners_fig">Figure 20-22</a> shows a few examples. (The rounded shapes in the middle are the float shapes, which have&#13;
been added for clarity. Browsers do not actually draw the float shapes&#13;
on the page.)</p>&#13;
&#13;
<figure><div class="figure" id="rounding_the_corners_fig">&#13;
<img alt="image" src="assets/css5_2022.png"/>&#13;
<h6><span class="label">Figure 20-22. </span>Rounding the corners of a shape box</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you <a data-primary="border-radius property" data-type="indexterm" id="idm45176031180528"/>set a <code>border-radius</code> value for your floated&#13;
element, this is <em>not</em> the same as creating a flat shape with rounded&#13;
corners. Remember that <code>shape-outside</code> defaults to <code>none</code>, so the&#13;
floated element’s box won’t be affected by the rounding of borders. If&#13;
you want to have text flow closely past the border rounding you’ve&#13;
defined with <code>border-radius</code>, you’ll need to supply identical rounding&#13;
values to <code>shape-outside</code>.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Circles and ellipses" data-type="sect3"><div class="sect3" id="circles_and_ellipses">&#13;
<h3>Circles and ellipses</h3>&#13;
&#13;
<p>Circular and <a data-primary="circular float shapes" data-type="indexterm" id="ix_circ_float_shape"/>elliptical float shapes use similar syntax.&#13;
In either case, you define the radius (or two radii, for the&#13;
ellipse) of the shape, and then the position of its center.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>If you’re familiar with circular and elliptical gradient images, the&#13;
syntax for defining circular and elliptical float shapes will seem very much&#13;
the same. There are some important caveats, however, as this section&#13;
will explore.</p>&#13;
</div>&#13;
&#13;
<p>Suppose we want to create a circle shape that’s centered in its float, with a 25-pixel radius. We can accomplish that in any of the following ways:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="m">25px</code><code class="p">);</code>&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="m">25px</code> <code class="n">at</code> <code class="nb">center</code><code class="p">);</code>&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="m">25px</code> <code class="n">at</code> <code class="m">50%</code> <code class="m">50%</code><code class="p">);</code></pre>&#13;
&#13;
<p>Regardless of which we use, the result will be that shown in <a data-type="xref" href="#a_circular_float_shape">Figure 20-23</a>.</p>&#13;
&#13;
<figure><div class="figure" id="a_circular_float_shape">&#13;
<img alt="image" src="assets/css5_2023.png"/>&#13;
<h6><span class="label">Figure 20-23. </span>A circular float shape</h6>&#13;
</div></figure>&#13;
&#13;
<p>Something to watch out for is that shapes <em>cannot</em> exceed their shape&#13;
box, even if you set up a condition where that seems possible. For&#13;
example, suppose we applied the previous 25-pixel-radius rule to a small&#13;
image, one that’s no more than 30 pixels on a side. In that case, you’ll&#13;
have a circle 50 pixels in diameter centered on a rectangle that’s&#13;
smaller than the circle. What happens? The circle may be defined to&#13;
stick out past the edges of the shape box—in the default case, the&#13;
margin box—but it will be clipped at the edges of the shape box. Thus, given the following rules, the content will flow past the image as if it had no shape, as shown in <a data-type="xref" href="#a_rather_small_circular_float_shape">Figure 20-24</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="m">25px</code> <code class="n">at</code> <code class="nb">center</code><code class="p">);}</code>&#13;
<code class="nt">img</code><code class="nf">#small</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">30px</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">35px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="a_rather_small_circular_float_shape">&#13;
<img alt="image" src="assets/css5_2024.png"/>&#13;
<h6><span class="label">Figure 20-24. </span>A rather small circular float shape for an even smaller image</h6>&#13;
</div></figure>&#13;
&#13;
<p>We can see the circle extending past the edges of the image, but notice how the text flows along the edge of the image, not the float&#13;
shape. Again, that’s because the actual float shape is clipped by the&#13;
shape box; in <a data-type="xref" href="#a_rather_small_circular_float_shape">Figure 20-24</a>, that’s the margin box, which is at the outer&#13;
edge of the image. So the actual float shape isn’t a circle, but a box&#13;
the exact dimensions of the image.</p>&#13;
&#13;
<p>The same holds true no matter what edge you define to be the shape box.&#13;
If you declare <code>shape-outside: circle(5em) content-box;</code>, the shape&#13;
will be clipped at the edges of the content box. Content will be able to&#13;
flow over the padding, borders, and margins, and will not be pushed away&#13;
in a circular fashion.</p>&#13;
&#13;
<p>This means you can do things like create a float shape that’s the lower-right quadrant of a circle in the upper-left corner of the float, assuming the image is <code>3em</code> square:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="m">3em</code> <code class="n">at</code> <code class="nb">top</code> <code class="nb">left</code><code class="p">);</code></pre>&#13;
&#13;
<p>For that matter, if you have a perfectly square float, you can define a&#13;
circle-quadrant that just touches the opposite sides, using a percentage&#13;
radius:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="m">50%</code> <code class="n">at</code> <code class="nb">top</code> <code class="nb">left</code><code class="p">);</code></pre>&#13;
&#13;
<p>But note: that works <em>only</em> if the float is square. If it’s rectangular,&#13;
oddities creep in. Take this example, which is illustrated in <a data-type="xref" href="#circular_float_shape_that_results">Figure 20-25</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="m">50%</code> <code class="n">at</code> <code class="nb">center</code><code class="p">);}</code>&#13;
<code class="nt">img</code><code class="nf">#tall</code> <code class="p">{</code><code class="k">height</code><code class="o">:</code> <code class="m">150px</code><code class="p">;</code> <code class="k">width</code><code class="o">:</code> <code class="m">70px</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="circular_float_shape_that_results">&#13;
<img alt="image" src="assets/css5_2025.png"/>&#13;
<h6><span class="label">Figure 20-25. </span>The circular float shape that results from a rectangle</h6>&#13;
</div></figure>&#13;
&#13;
<p>Don’t bother trying to pick which dimension is controlling the <code>50%</code>&#13;
calculation, because neither is. Or, in a sense, both are.</p>&#13;
&#13;
<p>When you define a percentage for the radius of a circular float shape,&#13;
it’s calculated with respect to a calculated <em>reference box</em>. The&#13;
height and width of this box are calculated as follows:</p>&#13;
&#13;
<figure><div class="figure">&#13;
<img alt="css5 2026" src="assets/css5_2026.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
&#13;
<p>In effect, this creates a square that’s a blending of the float’s&#13;
intrinsic height and width. In the case of our floated image of 70 × 150 pixels, that works out to a square that’s 117.047 pixels on a side. Thus,&#13;
the circle’s radius is 50% of that, or 58.5235 pixels.</p>&#13;
&#13;
<p>Once again, note that the content in <a data-type="xref" href="#a_clipped_float_shape">Figure 20-26</a> is flowing past the image&#13;
and ignoring the circle. That’s because the actual float shape is clipped&#13;
by the shape box, so the final float shape would be a kind of vertical&#13;
bar with rounded ends, something very much like what’s shown in <a data-type="xref" href="#a_clipped_float_shape">Figure 20-26</a>.</p>&#13;
&#13;
<figure><div class="figure" id="a_clipped_float_shape">&#13;
<img alt="image" src="assets/css5_2027.png"/>&#13;
<h6><span class="label">Figure 20-26. </span>A clipped float shape</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">It’s a lot simpler to position the center of the circle and have it grow&#13;
until it touches either the closest side to the circle’s center, or the&#13;
farthest side from the circle’s center. Both techniques are possible, as&#13;
shown here and illustrated in <a data-type="xref" href="#various_circular_float_shapes">Figure 20-27</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="n">closest</code><code class="o">-</code><code class="n">side</code><code class="p">);</code>&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="n">farthest</code><code class="o">-</code><code class="n">side</code> <code class="n">at</code> <code class="nb">top</code> <code class="nb">left</code><code class="p">);</code>&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="n">closest</code><code class="o">-</code><code class="n">side</code> <code class="n">at</code> <code class="m">25%</code> <code class="m">40px</code><code class="p">);</code>&#13;
<code class="k">shape-outside</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="n">farthest</code><code class="o">-</code><code class="n">side</code> <code class="n">at</code> <code class="m">25%</code> <code class="m">50%</code><code class="p">);</code></pre>&#13;
&#13;
<figure><div class="figure" id="various_circular_float_shapes">&#13;
<img alt="image" src="assets/css5_2028.png"/>&#13;
<h6><span class="label">Figure 20-27. </span>Various circular float shapes</h6>&#13;
</div></figure>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>In one of the examples in <a data-type="xref" href="#various_circular_float_shapes">Figure 20-27</a>, the shape is clipped to its shape box, whereas in the others, the shape is allowed to extend beyond it. If we hadn’t clipped the shape, it would have been too big for the figure! You’ll see this again in the next figure.<a data-primary="" data-startref="ix_circ_float_shape" data-type="indexterm" id="idm45176030849568"/></p>&#13;
</div>&#13;
&#13;
<p>Now, how about <a data-primary="elliptical float shapes" data-type="indexterm" id="ix_ellip_float_shape"/>ellipses? Besides using the name <code>ellipse()</code>, the only&#13;
syntactical difference between circles and ellipses is that you define&#13;
two radii instead of one radius. The first is the x (horizontal) radius,&#13;
and the second is the y (vertical) radius. Thus, for an ellipse with an&#13;
x radius of 20 pixels and a y radius of 30 pixels, you’d declare&#13;
<code>ellipse(20px 30px)</code>.</p>&#13;
&#13;
<p>You can use any length or percentage, <em>or</em> the&#13;
keywords <code>closest-side</code> and <code>farthest-side</code>, for either of the radii in&#13;
an ellipse. <a data-type="xref" href="#various_elliptical_float_shapes">Figure 20-28</a> shows some possibilities.</p>&#13;
&#13;
<figure><div class="figure" id="various_elliptical_float_shapes">&#13;
<img alt="image" src="assets/css5_2029.png"/>&#13;
<h6><span class="label">Figure 20-28. </span>Defining float shapes with ellipses</h6>&#13;
</div></figure>&#13;
&#13;
<p>Working with percentages for the lengths of the radii is a little different with ellipses than with circles. Instead of a calculated reference box, percentages in ellipses are calculated against the axis of the radius. Thus, horizontal percentages are calculated with respect to the width of the shape box, and vertical percentages with respect to the height. This is illustrated in <a data-type="xref" href="#elliptical_float_shapes_and_percentages">Figure 20-29</a>.</p>&#13;
&#13;
<figure><div class="figure" id="elliptical_float_shapes_and_percentages">&#13;
<img alt="image" src="assets/css5_2030.png"/>&#13;
<h6><span class="label">Figure 20-29. </span>Elliptical float shapes and percentages</h6>&#13;
</div></figure>&#13;
&#13;
<p>As with any basic shape, an elliptical shape is clipped at the edges of&#13;
the shape box.<a data-primary="" data-startref="ix_ellip_float_shape" data-type="indexterm" id="idm45176030838064"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Polygons" data-type="sect3"><div class="sect3" id="polygons">&#13;
<h3>Polygons</h3>&#13;
&#13;
<p>Polygons are a lot <a data-primary="polygon float shapes" data-type="indexterm" id="ix_poly_float_shape"/>more complicated to write, though they may be a&#13;
little bit easier to understand. You define a polygonal shape by&#13;
specifying a comma-separated list of <em>x</em>-<em>y</em> coordinates, expressed as&#13;
either lengths or percentages, calculated from the top left of the shape&#13;
box, as in SVG. Each <em>x</em>-<em>y</em> pair is a <em>vertex</em> in the polygon. If the first and last&#13;
vertices are not the same, the browser will close the polygon by&#13;
connecting them. (All polygonal float shapes must be closed.)</p>&#13;
&#13;
<p>So let’s say we want a diamond shape that’s 50 pixels tall and wide. If&#13;
we start building the polygon from the topmost vertex, the <code>polygon()</code> value would look like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">polygon</code><code class="p">(</code><code class="m">25px</code> <code class="m">0</code><code class="o">,</code> <code class="m">50px</code> <code class="m">25px</code><code class="o">,</code> <code class="m">25px</code> <code class="m">50px</code><code class="o">,</code> <code class="m">0</code> <code class="m">25px</code><code class="p">)</code></pre>&#13;
&#13;
<p>Percentages have the same behavior as they do in <code>background-image</code>&#13;
positioning (for example), so we can define a diamond shape that always&#13;
“fills out” the shape box.  It would be written like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">polygon</code><code class="p">(</code><code class="m">50%</code> <code class="m">0</code><code class="o">,</code> <code class="m">100%</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">100%</code><code class="o">,</code> <code class="m">0</code> <code class="m">50%</code><code class="p">)</code></pre>&#13;
&#13;
<p>The result of this and the previous polygon example are shown in <a data-type="xref" href="#a_polygonal_float_shape">Figure 20-30</a>.</p>&#13;
&#13;
<figure><div class="figure" id="a_polygonal_float_shape">&#13;
<img alt="image" src="assets/css5_2031.png"/>&#13;
<h6><span class="label">Figure 20-30. </span>A polygonal float shape</h6>&#13;
</div></figure>&#13;
&#13;
<p>These examples both start from the topmost vertex, but&#13;
they don’t have to. All of the following will yield the same result:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">polygon</code><code class="p">(</code><code class="m">50%</code> <code class="m">0</code><code class="o">,</code> <code class="m">100%</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">100%</code><code class="o">,</code> <code class="m">0</code> <code class="m">50%</code><code class="p">)</code> <code class="c">/* clockwise from top */</code>&#13;
<code class="n">polygon</code><code class="p">(</code><code class="m">0</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">0</code><code class="o">,</code> <code class="m">100%</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">100%</code><code class="p">)</code> <code class="c">/* clockwise from left */</code>&#13;
<code class="n">polygon</code><code class="p">(</code><code class="m">50%</code> <code class="m">100%</code><code class="o">,</code> <code class="m">0</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">0</code><code class="o">,</code> <code class="m">100%</code> <code class="m">50%</code><code class="p">)</code> <code class="c">/* clockwise from bottom */</code>&#13;
<code class="n">polygon</code><code class="p">(</code><code class="m">0</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">100%</code><code class="o">,</code> <code class="m">100%</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">0</code><code class="p">)</code> <code class="c">/* counterclockwise from left */</code></pre>&#13;
&#13;
<p>As before, remember: if a shape definition exceeds the shape box, it will always be clipped to it. So even if you create a polygon with coordinates&#13;
that lie outside the shape box (by default, the margin box), the polygon&#13;
will get clipped. <a data-type="xref" href="#how_a_float_shape_is_clipped">Figure 20-31</a> demonstrates &#13;
<span class="keep-together">the result.</span></p>&#13;
&#13;
<figure><div class="figure" id="how_a_float_shape_is_clipped">&#13;
<img alt="image" src="assets/css5_2032.png"/>&#13;
<h6><span class="label">Figure 20-31. </span>How a float shape is clipped when it exceeds the shape box</h6>&#13;
</div></figure>&#13;
&#13;
<p class="pagebreak-before">Polygons have an extra wrinkle: you can toggle their fill rule. By default, the fill rule is <code>nonzero</code>, but the other possible value is <code>evenodd</code>. It’s easier to show the difference than to describe it, so here’s a star polygon with two fill rules, illustrated in <a data-type="xref" href="#the_two_polygonal_fills">Figure 20-32</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">polygon</code><code class="p">(</code><code class="n">nonzero</code><code class="o">,</code> <code class="m">51%</code> <code class="m">0%</code><code class="o">,</code> <code class="m">83%</code> <code class="m">100%</code><code class="o">,</code> <code class="m">0</code> <code class="m">38%</code><code class="o">,</code> <code class="m">100%</code> <code class="m">38%</code><code class="o">,</code> <code class="m">20%</code> <code class="m">100%</code><code class="p">)</code>&#13;
<code class="n">polygon</code><code class="p">(</code><code class="n">evenodd</code><code class="o">,</code> <code class="m">51%</code> <code class="m">0%</code><code class="o">,</code> <code class="m">83%</code> <code class="m">100%</code><code class="o">,</code> <code class="m">0</code> <code class="m">38%</code><code class="o">,</code> <code class="m">100%</code> <code class="m">38%</code><code class="o">,</code> <code class="m">20%</code> <code class="m">100%</code><code class="p">)</code></pre>&#13;
&#13;
<figure><div class="figure" id="the_two_polygonal_fills">&#13;
<img alt="image" src="assets/css5_2033.png"/>&#13;
<h6><span class="label">Figure 20-32. </span>The two polygonal fills</h6>&#13;
</div></figure>&#13;
&#13;
<p>The default <code>nonzero</code> case is what we tend to think of with filled polygons: a single shape, completely filled. The <code>evenodd</code> option has a different effect, in which some pieces of the polygon are filled and others are not.</p>&#13;
&#13;
<p>This particular example doesn’t show much difference, since the part of&#13;
the polygon that’s missing is completely enclosed by filled parts, so&#13;
the end result is the same either way. However, imagine a shape that has sideways spikes, and then a line that cuts vertically across&#13;
the middle of them. Rather than a comb shape, you’d end up with a set of&#13;
discontinuous triangles. There are a lot of possibilities.</p>&#13;
&#13;
<p>As you can imagine, a polygon can become very complex, with a large&#13;
number of vertices. You’re welcome to work out the coordinates of each&#13;
vertex on paper and type them in, but it makes a lot more sense to use a&#13;
tool to do this. A good example of such a tool is the CSS Shapes Editor extension&#13;
available for Chrome via the Chrome Web Store.&#13;
(Firefox has this capability built natively into its web inspector.) You can select a float in the DOM inspector, bring up the CSS Shapes Editor, select a polygon, and then start creating and moving vertices in the browser, with live reflowing of the content as you do so. Then, once you’re satisfied, you can drag-select-copy the polygon value for pasting into your stylesheet. <a data-type="xref" href="#the_chroms_shapes_editor">Figure 20-33</a> shows a screenshot of the Shapes Editor in action.</p>&#13;
&#13;
<figure><div class="figure" id="the_chroms_shapes_editor">&#13;
<img alt="image" src="assets/css5_2034.png"/>&#13;
<h6><span class="label">Figure 20-33. </span>The Chrome Shapes Editor in action</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Because of <a data-primary="CORS (cross-origin resource sharing)" data-type="indexterm" id="idm45176030569248"/><a data-primary="cross-origin resource sharing (CORS)" data-type="indexterm" id="idm45176030568640"/>cross-origin resource sharing (CORS) restrictions, shapes cannot be edited with the Shapes Editor unless they’re being loaded over HTTP(S) from the same origin server as the HTML and CSS.  Loading local files from your computer will prevent the shapes from being editable.  The same restriction prevents shapes from being loaded off local storage via the <code>url()</code> mechanism.<a data-primary="" data-startref="ix_inset_shapes" data-type="indexterm" id="idm45176030567520"/><a data-primary="" data-startref="ix_shape_float_inset" data-type="indexterm" id="idm45176030566512"/><a data-primary="" data-startref="ix_poly_float_shape" data-type="indexterm" id="idm45176030565568"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Adding a Shape Margin" data-type="sect2"><div class="sect2" id="adding_a_shape_margin">&#13;
<h2>Adding a Shape Margin</h2>&#13;
&#13;
<p>Once a <a data-primary="shaping content around floats" data-secondary="margins" data-type="indexterm" id="ix_shape_float2"/><a data-primary="margins" data-secondary="floating images" data-type="indexterm" id="ix_margin_float2"/><a data-primary="shape-margin property" data-type="indexterm" id="ix_shape_margin_prop"/><a data-primary="floating" data-secondary="margins and" data-type="indexterm" id="ix_float_margin"/>float of any kind of shape has been defined, it’s possible to add a “margin”—more properly, a <em>shape modifier</em>—to that shape by using the&#13;
property <code>shape-margin</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176030557696">&#13;
<h1>shape-margin</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Floats</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>The absolute length</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Much like a regular element margin, a <em>shape margin</em> pushes content away&#13;
by either a length or a percentage; a percentage is calculated with&#13;
respect to the width of the element’s containing block, just as are&#13;
regular margins.</p>&#13;
&#13;
<p>The advantage of a shape margin is that you can define a shape that&#13;
exactly matches the thing you want to shape, and then use the shape&#13;
margin to create extra space. Take an image-based shape, where&#13;
part of the image is visible and the rest is transparent.&#13;
Instead of having to add opaque portions to the image to keep text&#13;
and other content away from the visible part of the image, you can just&#13;
add a shape margin. <a data-primary="distance values" data-type="indexterm" id="idm45176030542704"/>This enlarges the shape by the distance supplied.</p>&#13;
&#13;
<p>In detail, the new shape is found by drawing a line perpendicular from&#13;
each point along the basic shape, with a length equal to the value of&#13;
<code>shape-margin</code>, to find a point in the new shape. At sharp corners, a&#13;
circle is drawn centered on that point with a radius equal to the value&#13;
of <code>shape-margin</code>. After all that, the new shape is the smallest shape&#13;
that can describe all those points and circles (if any).</p>&#13;
&#13;
<p>Remember, though, that a shape can never exceed the shape box. Thus, by&#13;
default, the shape can’t get any bigger than the margin box of the&#13;
unshaped float. Since <code>shape-margin</code> actually increases the size of the&#13;
shape, any part of the newly enlarged shape that exceeds&#13;
the shape box will be clipped.</p>&#13;
&#13;
<p>To see what this means, consider the following, as illustrated in <a data-type="xref" href="#adding_margins_to_float_shapes">Figure 20-34</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">float</code><code class="o">:</code> <code class="nb">left</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code> <code class="k">shape-outside</code><code class="o">:</code> <code class="sx">url(star.svg)</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="n">hsl</code><code class="p">(</code><code class="m">0</code> <code class="m">100%</code> <code class="m">50%</code> <code class="o">/</code> <code class="m">0</code><code class="o">.</code><code class="m">25</code><code class="p">);}</code>&#13;
<code class="nf">#one</code> <code class="p">{</code><code class="k">shape-margin</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="nf">#two</code> <code class="p">{</code><code class="k">shape-margin</code><code class="o">:</code> <code class="m">1.5em</code><code class="p">;}</code>&#13;
<code class="nf">#thr</code> <code class="o">(</code><code class="nt">shape-margin</code><code class="o">:</code> <code class="nt">10</code><code class="o">%;</code><code class="err">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="adding_margins_to_float_shapes">&#13;
<img alt="image" src="assets/css5_2035.png"/>&#13;
<h6><span class="label">Figure 20-34. </span>Adding margins to float shapes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice the way the content flows past the second and third examples.&#13;
There are definitely places where the content gets closer than the&#13;
specified <code>shape-margin</code>, because the shape has been clipped at the&#13;
margin box of the floated element. To make sure the separation distance is always observed, include standard margins that equal or exceed the <code>shape-margin</code> distance. For example, we could have avoided the problem by modifying two of the rules like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#two</code> <code class="p">{</code><code class="k">shape-margin</code><code class="o">:</code> <code class="m">1.5em</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">0</code> <code class="m">1.5em</code> <code class="m">1.5em</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="nf">#thr</code> <code class="o">(</code><code class="nt">shape-margin</code><code class="o">:</code> <code class="nt">10</code><code class="o">%;</code> <code class="nt">margin</code><code class="o">:</code> <code class="nt">0</code> <code class="nt">10</code><code class="o">%</code> <code class="nt">10</code><code class="o">%</code> <code class="nt">0</code><code class="o">;</code><code class="err">}</code></pre>&#13;
&#13;
<p>In both cases, the right and bottom margins are set to be the same as&#13;
the <code>shape-margin</code> value, ensuring that the enlarged shape will never&#13;
exceed the shape box on those sides. This is demonstrated in <a data-type="xref" href="#making_sure_the_shape_margins">Figure 20-35</a>.</p>&#13;
&#13;
<figure><div class="figure" id="making_sure_the_shape_margins">&#13;
<img alt="image" src="assets/css5_2036.png"/>&#13;
<h6><span class="label">Figure 20-35. </span>Making sure the shape margins don’t get clipped</h6>&#13;
</div></figure>&#13;
&#13;
<p>If you have a float go to the right, you’ll have to&#13;
adjust its margins to create space below and to the left, not the right,&#13;
but the principle is the same. You can also use <code>float: inline-end</code> and the <code>margin-inline</code> property to ensure that if the writing direction changes, your layout still works as intended.<a data-primary="" data-startref="ix_float_shaping" data-type="indexterm" id="idm45176030417760"/><a data-primary="" data-startref="ix_shape_float" data-type="indexterm" id="idm45176030416784"/><a data-primary="" data-startref="ix_text_float_shape" data-type="indexterm" id="idm45176030415840"/><a data-primary="" data-startref="ix_float_margin" data-type="indexterm" id="idm45176030414896"/><a data-primary="" data-startref="ix_margin_float2" data-type="indexterm" id="idm45176030413952"/><a data-primary="" data-startref="ix_shape_margin_prop" data-type="indexterm" id="idm45176030413008"/><a data-primary="" data-startref="ix_shape_float2" data-type="indexterm" id="idm45176030412064"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Clipping and Masking" data-type="sect1"><div class="sect1" id="clipping_and_masking">&#13;
<h1>Clipping and Masking</h1>&#13;
&#13;
<p>Similar to float shaping, CSS also offers clipping and masking of elements, albeit without any shaping of the element box.  These are methods of showing only portions of an element, using a variety of simple shapes as well as the application of complete images and SVG elements.  These can be used to make decorative bits of a layout more visually interesting, among other things—a common technique is to frame images or give them ragged edges.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Clipping" data-type="sect2"><div class="sect2" id="clip-path_property">&#13;
<h2>Clipping</h2>&#13;
&#13;
<p>If <a data-primary="clipping" data-type="indexterm" id="ix_clipping_ch20"/><a data-primary="masks" data-secondary="clipping" data-type="indexterm" id="ix_masks_clipping_ch20"/><a data-primary="clip-path property" data-type="indexterm" id="ix_clip_path_prop"/>all you want to do is visually clip away pieces of an element, you can use the property <code>clip-path</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176030374848">&#13;
<h1>clip-path</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | &lt;<em><code>url</code></em>&gt; | [ [ <code>inset()</code> | <code>circle()</code> | <code>ellipse()</code> | <code>polygon()</code> ] ‖ <br/>[ <code>border-box</code> | <code>padding-box</code> | <code>content-box</code> | <code>margin-box</code> | <code>fill-box</code> | <br/><code>stroke-box</code> | <code>view-box</code> ] ]</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes for <code>inset()</code>, <code>circle()</code>, <code>ellipse()</code>, and <code>polygon()</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>With <code>clip-path</code>, you’re able to define a <em>clipping shape</em>.  This is essentially the area of the element inside which visible portions are drawn.  Any part of the element that falls outside the shape is clipped away, leaving behind empty transparent space.  The following code gives an unclipped and a clipped example of the same paragraph, with the result depicted in <a data-type="xref" href="#clipping-compare">Figure 20-36</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code> <code class="k">padding</code><code class="o">:</code> <code class="m">0.75em</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.clipped</code> <code class="p">{</code><code class="k">clip-path</code><code class="o">:</code> <code class="sx">url(shapes.svg#cloud02)</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="clipping-compare">&#13;
<img alt="css5 2037" src="assets/css5_2037.png"/>&#13;
<h6><span class="label">Figure 20-36. </span>Unclipped and clipped paragraphs</h6>&#13;
</div></figure>&#13;
&#13;
<p>The default value, <code>none</code>, means no clipping is performed, as you’d probably expect.  Similarly, if a &lt;<em><code>url</code></em>&gt; value is given (as in the preceding code) and it points to a missing resource, or to an element in an SVG file that isn’t a <code>&lt;clipPath&gt;</code>, no clipping is &#13;
<span class="keep-together">performed.</span></p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, <a data-primary="SVG format" data-secondary="clip paths and" data-type="indexterm" id="idm45176030321792"/>URL-based clip paths work in most browsers only if the URL points to an embedded SVG inside the same document as the clipped element. External SVGs are not supported. Firefox is the only browser supporting clip paths from external SVGs.</p>&#13;
</div>&#13;
&#13;
<p>The rest of the values are either shapes written in CSS, reference boxes, or both.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Clip Shapes" data-type="sect2"><div class="sect2" id="clip_shapes">&#13;
<h2>Clip Shapes</h2>&#13;
&#13;
<p>You can define <a data-primary="clipping" data-secondary="based on simple shapes" data-type="indexterm" id="idm45176030318336"/><a data-primary="clipping shape" data-type="indexterm" id="idm45176030317328"/>clip shapes with one of a set of four simple shape functions.  These are identical to the shape functions used to define float shapes with <code>shape-outside</code>, so we won’t redescribe them in detail here.  Here’s a brief recap:</p>&#13;
<dl>&#13;
<dt><code>inset()</code></dt>&#13;
<dd>&#13;
<p>Accepts<a data-primary="inset() function, clip shapes" data-type="indexterm" id="idm45176030314128"/> from one to four lengths or percentage values, defining offsets from the edges of the bounding box, with optional corner rounding via the <code>round</code> keyword and another set of one to four lengths or percentages.</p>&#13;
</dd>&#13;
<dt><code>circle()</code></dt>&#13;
<dd>&#13;
<p>Accepts<a data-primary="circle() function, clip shapes" data-type="indexterm" id="idm45176030311312"/> a single length, percentage, or keyword defining the radius of the circle, with an optional position for the circle’s center with the <code>at</code> keyword followed by one or two lengths or percentages.</p>&#13;
</dd>&#13;
<dt><code>ellipse()</code></dt>&#13;
<dd>&#13;
<p>Accepts<a data-primary="ellipse() function, clip shapes" data-type="indexterm" id="idm45176030308496"/> a mandatory two lengths, percentages, or keywords defining the radii of the vertical and horizontal axes of the ellipse, with an optional position for the ellipse’s center with the <code>at</code> keyword followed by one or two lengths or percentages.</p>&#13;
</dd>&#13;
<dt><code>polygon()</code></dt>&#13;
<dd>&#13;
<p>Accepts<a data-primary="polygon() function, clip shapes" data-type="indexterm" id="idm45176030285072"/> a comma-separated list of space-separated <em>x</em> and <em>y</em> coordinates, using either lengths or percentages.  Can be prefaced by a keyword defining the fill rule for the polygon.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p><a data-type="xref" href="#clipping-shapes">Figure 20-37</a> shows a variety of examples of these clip shapes, corresponding to the following styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.ex01</code> <code class="p">{</code><code class="k">clip-path</code><code class="o">:</code> <code class="nb">none</code><code class="p">;}</code>&#13;
<code class="nc">.ex02</code> <code class="p">{</code><code class="k">clip-path</code><code class="o">:</code> <code class="nb">inset</code><code class="p">(</code><code class="m">10px</code> <code class="m">0</code> <code class="m">25%</code> <code class="m">2em</code><code class="p">);}</code>&#13;
<code class="nc">.ex03</code> <code class="p">{</code><code class="k">clip-path</code><code class="o">:</code> <code class="nb">circle</code><code class="p">(</code><code class="m">100px</code> <code class="n">at</code> <code class="m">50%</code> <code class="m">50%</code><code class="p">);}</code>&#13;
<code class="nc">.ex04</code> <code class="p">{</code><code class="k">clip-path</code><code class="o">:</code> <code class="n">ellipse</code><code class="p">(</code><code class="m">100px</code> <code class="m">50px</code> <code class="n">at</code> <code class="m">75%</code> <code class="m">25%</code><code class="p">);}</code>&#13;
<code class="nc">.ex05</code> <code class="p">{</code><code class="k">clip-path</code><code class="o">:</code> <code class="n">polygon</code><code class="p">(</code><code class="m">50%</code> <code class="m">0</code><code class="o">,</code> <code class="m">100%</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">100%</code><code class="o">,</code> <code class="m">0</code> <code class="m">50%</code><code class="p">);}</code>&#13;
<code class="nc">.ex06</code> <code class="p">{</code><code class="k">clip-path</code><code class="o">:</code> <code class="n">polygon</code><code class="p">(</code><code class="m">0</code> <code class="m">0</code><code class="o">,</code> <code class="m">50px</code> <code class="m">100px</code><code class="o">,</code> <code class="m">150px</code> <code class="m">5px</code><code class="o">,</code> <code class="m">200px</code> <code class="m">200px</code><code class="o">,</code> <code class="m">0</code> <code class="m">100%</code><code class="p">);}</code></pre>&#13;
&#13;
<figure><div class="figure" id="clipping-shapes">&#13;
<img alt="css5 2038" src="assets/css5_2038.png"/>&#13;
<h6><span class="label">Figure 20-37. </span>Various clip shapes</h6>&#13;
</div></figure>&#13;
&#13;
<p>As <a data-type="xref" href="#clipping-shapes">Figure 20-37</a> shows, the elements are visible only inside the clip shapes.  Anything outside that is just gone.  But note that the clipped elements still take up the same space they would if they weren’t clipped at all.  In other words, clipping doesn’t make the elements smaller.  It just limits the part of them that’s actually drawn.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Clip Boxes" data-type="sect2"><div class="sect2" id="clip_boxes">&#13;
<h2>Clip Boxes</h2>&#13;
&#13;
<p>Unlike <a data-primary="clipping" data-secondary="based on boxes" data-type="indexterm" id="ix_clip_box"/><a data-primary="boxes" data-secondary="clipping based on" data-type="indexterm" id="ix_box_clip"/>clip shapes, clip boxes aren’t specified using lengths or percentages.  They correspond, for the most part, directly to boundaries in the box model.</p>&#13;
&#13;
<p>If you just write <code>clip-path: border-box</code>, for example, the element is clipped along the outside edge of the border.  This is likely what you’d expect anyway, since margins are transparent.  Remember, however, that outlines can be drawn outside borders, so if you <em>do</em> clip at the border edge, any outlines will be clipped away. That includes any outlines, which can create a major accessibility problem, so be very careful clipping any element that can receive focus. (You probably just shouldn’t do it in those cases.)</p>&#13;
&#13;
<p>When used by themselves, the values <code>margin-box</code>, <code>padding-box</code>, and <code>content-box</code> dictate that the clipping occurs at the outer edges of the margin, padding, or content areas, respectively.  These are diagrammed in <a data-type="xref" href="#clipping-boxes">Figure 20-38</a>.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="clipping-boxes">&#13;
<img alt="css5 2039" src="assets/css5_2039.png"/>&#13;
<h6><span class="label">Figure 20-38. </span>Various clipping boxes</h6>&#13;
</div></figure>&#13;
&#13;
<p>There’s another part to <a data-type="xref" href="#clipping-boxes">Figure 20-38</a>, which <a data-primary="SVG format" data-secondary="object bounding box" data-type="indexterm" id="idm45176030142240"/><a data-primary="bounding box" data-type="indexterm" id="idm45176030141264"/>shows the SVG bounding boxes:</p>&#13;
<dl>&#13;
<dt><code>view-box</code></dt>&#13;
<dd>&#13;
<p>The <a data-primary="view-box, SVG" data-type="indexterm" id="idm45176030138640"/>nearest (the closest ancestor) SVG viewport is used as the clipping box.</p>&#13;
</dd>&#13;
<dt><code>fill-box</code></dt>&#13;
<dd>&#13;
<p>The <em>object bounding box</em> is <a data-primary="fill-box, SVG" data-type="indexterm" id="idm45176030135920"/>used as the clipping box.  The object bounding box is the smallest box that will fit every part of the element’s geometry, taking into account any transformations (e.g., rotation), not including any strokes along its outside.</p>&#13;
</dd>&#13;
<dt><code>stroke-box</code></dt>&#13;
<dd>&#13;
<p>The <em>stroke bounding box</em> is <a data-primary="stroke-box, SVG" data-type="indexterm" id="idm45176030133200"/>used as the clipping box. Similar to the fill box, the stroke box is the smallest box that will fit every part of the element’s geometry, taking into account any transformations (e.g., rotation), but the stroke box includes any strokes along its outside.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>These values apply only to SVG elements that don’t have an associated CSS layout box.  For such elements, if the CSS-style boxes (<code>margin-box</code>, <code>border-box</code>, <code>padding-box</code>, <code>content-box</code>) are given, <code>fill-box</code> is used instead.  Conversely, if one of the SVG bounding box values is applied to an element that <em>does</em> have a CSS layout box—which is most elements—<code>border-box</code> is used instead.</p>&#13;
&#13;
<p>It can be useful at times to be able to use something like <code>clip-path: content-box</code> just to clip away everything outside the content area, but these box values really come into their own in conjunction with a clipping shape.  Suppose you have an <code>ellipse()</code> clip shape you want to apply to an element, and furthermore, you want to have it just touch the outer edges of the padding box.  Rather than have to calculate the necessary radii by subtracting margins and borders from the overall element, you can just write <code>clip-path: ellipse(50% 50%) padding-box</code>.  That will center an elliptical clip shape at the center of the element, with horizontal and vertical radii half the element’s reference box, as shown in <a data-type="xref" href="#clipping-boxes-ellipse">Figure 20-39</a>, along with the effect of fitting to other boxes.</p>&#13;
&#13;
<figure><div class="figure" id="clipping-boxes-ellipse">&#13;
<img alt="css5 2040" src="assets/css5_2040.png"/>&#13;
<h6><span class="label">Figure 20-39. </span>Fitting an elliptical clip shape to various boxes</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that the ellipse is cut off in the <code>margin-box</code> example?  That’s because the margin is invisible, so while parts of it fall inside the elliptical clip shape, we can’t actually see those parts unless there’s a box shadow or an outset border image on the element.</p>&#13;
&#13;
<p>Interestingly, the bounding-box keywords can be used only in conjunction with clip shapes—<em>not</em> with an SVG-based clip path.  The keywords that relate to SVG bounding boxes apply only if an SVG image is being clipped via CSS.<a data-primary="" data-startref="ix_box_clip" data-type="indexterm" id="idm45176030122400"/><a data-primary="" data-startref="ix_clip_box" data-type="indexterm" id="idm45176030121424"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Clipping with SVG Paths" data-type="sect2"><div class="sect2" id="clipping_with_svg_points">&#13;
<h2>Clipping with SVG Paths</h2>&#13;
&#13;
<p>If you <a data-primary="clipping" data-secondary="based on an image" data-type="indexterm" id="idm45176030118400"/><a data-primary="SVG format" data-secondary="clip paths and" data-type="indexterm" id="idm45176030117392"/><a data-primary="clipping" data-secondary="with SVG paths" data-secondary-sortas="SVG paths" data-type="indexterm" id="idm45176030116448"/>happen to have an SVG path handy, or you’re comfortable writing your own, you can use it to define the clipping shape in the <code>clip-path</code> property. The syntax looks like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">clip-path</code><code class="o">:</code> <code class="n">path</code><code class="p">(</code><code class="s2">"…"</code><code class="p">);</code></pre>&#13;
&#13;
<p>Replace that ellipsis with the contents of an SVG <code>d</code> or <code>points</code> attribute, and that will give you a clipping shape.  Here’s an example of such an attribute:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;path</code><code class="w"> </code><code class="na">d=</code><code class="s">"M 500,0 L 1000,250 L 500,500 L 0,250"</code><code class="nt">/&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>This will draw a diamond from the point at <em>x</em>=500, <em>y</em>=0 to <em>x</em>=1000, <em>y</em>=250, and so on, forming a diamond shape 1,000 pixels across by 500 high.  If applied to an image exactly 1,000 pixels by 500 pixels, you’d get the result shown in <a data-type="xref" href="#clipping-svg-path">Figure 20-40</a>.</p>&#13;
&#13;
<figure class="width-50"><div class="figure" id="clipping-svg-path">&#13;
<img alt="css5 2041" src="assets/css5_2041.png"/>&#13;
<h6><span class="label">Figure 20-40. </span>An image clipped with an SVG clip path</h6>&#13;
</div></figure>&#13;
&#13;
<p>You’d get the same clip shape shown in <a data-type="xref" href="#clipping-svg-path">Figure 20-40</a> by using the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">clip-path</code><code class="o">:</code> <code class="n">polygon</code><code class="p">(</code><code class="m">50%</code> <code class="m">0</code><code class="o">,</code> <code class="m">100%</code> <code class="m">50%</code><code class="o">,</code> <code class="m">50%</code> <code class="m">100%</code><code class="o">,</code> <code class="m">0%</code> <code class="m">50%</code><code class="p">);</code></pre>&#13;
&#13;
<p>The difference here is that the clipping path defined with percentage values in a polygon is a lot more robust than one that requires images to be exactly 1,000 pixels wide by 500 pixels tall.  That’s because, as of late 2022, all SVG path coordinates are expressed in absolute units, and can’t be declared as percentages of the image’s height and width as the &#13;
<span class="keep-together"><code>polygon()</code></span> shape can.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This has been a necessarily very brief spotlight on the ability to use SVG paths in CSS, as describing all the ways paths can be shaped is far beyond the scope of this book.  If you want to know more, we recommend reading <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/using-svg-with/9781491921968"><em>Using SVG with CSS3 &amp; HTML5</em></a> by Amelia Bellamy-Royds et al. (O’Reilly).<a data-primary="" data-startref="ix_clip_path_prop" data-type="indexterm" id="idm45176030025248"/><a data-primary="" data-startref="ix_clipping_ch20" data-type="indexterm" id="idm45176030024336"/><a data-primary="" data-startref="ix_masks_clipping_ch20" data-type="indexterm" id="idm45176030023392"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Masks" data-type="sect1"><div class="sect1" id="masks">&#13;
<h1>Masks</h1>&#13;
&#13;
<p>When we <a data-primary="masks" data-type="indexterm" id="ix_masks_ch20"/>say <em>mask</em>, at least in this context, we mean a shape inside of which things are visible, and outside of which they are not.  Masks are thus very similar in concept to clipping paths.  The primary differences are twofold: first, with masks you can only use an image to define the areas of the element that are shown or clipped away; and second, a lot more properties are available to use with masks, allowing you to do things such as position, size, and repeat the masking image.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, the Chromium familiy supports most of the masking properties, but only with the <code>-webkit-</code> prefix.  So instead of <code>mask-image</code>, for example, Chrome and Edge support <code>-webkit-mask-image</code> instead.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Defining a Mask" data-type="sect2"><div class="sect2" id="defining_a_mask">&#13;
<h2>Defining a Mask</h2>&#13;
&#13;
<p>The first step to <a data-primary="masks" data-secondary="image for" data-type="indexterm" id="ix_mask_image2"/><a data-primary="mask-image property" data-type="indexterm" id="ix_mask_image_prop"/>applying a mask is to point to the image that you’ll be using to define the mask.  This is accomplished with <code>mask-image</code>, which accepts any image type.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176030010656">&#13;
<h1>mask-image</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>none</code> | &lt;<em><code>image</code></em>&gt; | &lt;<em><code>mask-source</code></em>&gt; ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Notes</strong></p></td>&#13;
<td><p>An &lt;<em><code>image</code></em>&gt; is any of the value types &lt;<em><code>url</code></em>&gt;, &lt;<em><code>image()</code></em>&gt;, &lt;<em><code>image-set()</code></em>&gt;, &lt;<em><code>element()</code></em>&gt;, &lt;<em><code>cross-fade()</code></em>&gt;, or &lt;<em><code>gradient</code></em>&gt;; &lt;<em><code>mask-source</code></em>&gt; is a <code>url()</code> that points to a <code>&lt;mask&gt;</code> element in an SVG image</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Assuming the image reference is valid, <code>mask-image</code> will give the browser an image to use as a mask for the element to which it’s being applied.</p>&#13;
&#13;
<p class="pagebreak-before">We’ll start with a simple situation: one image applied to another, where both are the same height and width. <a data-type="xref" href="#masks-image-simple">Figure 20-41</a> shows two images separately, along with the first image being masked by the second.</p>&#13;
&#13;
<figure><div class="figure" id="masks-image-simple">&#13;
<img alt="css5 2042" src="assets/css5_2042.png"/>&#13;
<h6><span class="label">Figure 20-41. </span>A simple image mask</h6>&#13;
</div></figure>&#13;
&#13;
<p>As the figure shows, in the parts of the second image that are opaque, the first image is visible.  In the parts that are transparent, the first image is not visible.  For the parts that are semitransparent, the first image is also semitransparent.</p>&#13;
&#13;
<p>Here’s the basic code for the end result shown in <a data-type="xref" href="#masks-image-simple">Figure 20-41</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.masked</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(theatre-masks.svg)</code><code class="p">;}</code></pre>&#13;
&#13;
<p>CSS doesn’t require that you apply mask images only to other images, though.  You can mask pretty much any element with an image, and that image can be a raster image (GIF, JPG, PNG) or a vector image (SVG).  The latter is usually a better choice, if available.  You can even construct your own image with gradients, whether linear or radial, repeated or otherwise.</p>&#13;
&#13;
<p>The following styles will have the result shown in <a data-type="xref" href="#masks-image-variety">Figure 20-42</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nc">.masked.theatre</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/theatre-masks.svg)</code><code class="p">;}</code>&#13;
<code class="o">*</code><code class="nc">.masked.compass</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/Compass_masked.png)</code><code class="p">;}</code>&#13;
<code class="o">*</code><code class="nc">.masked.lg-fade</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code>&#13;
	<code class="n">repeating</code><code class="o">-</code><code class="n">linear</code><code class="o">-</code><code class="n">gradient</code><code class="p">(</code><code class="m">135deg</code><code class="o">,</code> <code class="m">#000</code> <code class="m">0</code> <code class="m">1em</code><code class="o">,</code> <code class="nb">transparent</code> <code class="m">3em</code> <code class="m">4em</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<figure><div class="figure" id="masks-image-variety">&#13;
<img alt="css5 2043" src="assets/css5_2043.png"/>&#13;
<h6><span class="label">Figure 20-42. </span>A variety of image masks</h6>&#13;
</div></figure>&#13;
&#13;
<p>An important point to keep in mind is that when a mask clips away pieces of an element, it clips away <em>all</em> pieces.  The best example of this occurs when you apply an image that clips away the outer edges of elements, and the markers on list items can very easily become invisible. <a data-type="xref" href="#masks-image-listitems">Figure 20-43</a> shows an example, which is the result of the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code><code class="nc">.masked</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/Compass_masked.png)</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;ol</code><code class="w"> </code><code class="na">class=</code><code class="s">"masked"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>One<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Two<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Three<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Four<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="w">    </code><code class="nt">&lt;li&gt;</code>Five<code class="nt">&lt;/li&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/ol&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="masks-image-listitems">&#13;
<img alt="css5 2044" src="assets/css5_2044.png"/>&#13;
<h6><span class="label">Figure 20-43. </span>A PNG with areas of transparency masking an unordered list</h6>&#13;
</div></figure>&#13;
&#13;
<p>One other value option enables you to point directly at a <code>&lt;mask&gt;</code> element in SVG to use the mask it defines.  This is analogous to pointing to a <code>&lt;clipPath&gt;</code> or other SVG element from the property <code>clip-path</code>.  Here’s an example of how a mask might be defined:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;svg&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;mask</code><code class="w"> </code><code class="na">id=</code><code class="s">"hexlike"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="w">	   </code><code class="nt">&lt;path</code><code class="w"> </code><code class="na">fill=</code><code class="s">"#FFFFFF"</code><code class="w"/>&#13;
<code class="w">             </code><code class="na">d=</code><code class="s">"M 50,0 L 100,25 L 100,75 L 50,100 L 0,75 L 0,25"</code><code class="w"> </code><code class="nt">/&gt;</code><code class="w"/>&#13;
<code class="w">	</code><code class="nt">&lt;/mask&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;/svg&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>With that SVG embedded in the HTML file directly, the mask can be referenced like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.masked</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(#hexlike)</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If the SVG is in an external file, this is how to reference it from CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.masked</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(masks.svg#hexlike)</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The difference between using an image as a mask versus an SVG <code>&lt;mask&gt;</code> is that SVG masking is based on luminance, rather than alpha transparency. This difference can be inverted with the <code>mask-mode</code> property.<a data-primary="" data-startref="ix_mask_image_prop" data-type="indexterm" id="idm45176029687280"/><a data-primary="" data-startref="ix_mask_image2" data-type="indexterm" id="idm45176029686432"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Changing the Mask’s Mode" data-type="sect2"><div class="sect2" id="changing_the_masks_mode">&#13;
<h2>Changing the Mask’s Mode</h2>&#13;
&#13;
<p>You’ve just <a data-primary="masks" data-secondary="changing mode" data-type="indexterm" id="ix_mask_mode_chge"/><a data-primary="mask-mode property" data-type="indexterm" id="ix_mask_mode_prop"/>seen the two ways to use an image as a mask. Masking is accomplished by applying an image with an alpha channel to another element. Masking can also be done by using the brightness of each part of the masking image to define the mask. Switching between these two options is accomplished with the <code>mask-mode</code> property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176029685280">&#13;
<h1>mask-mode</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>alpha</code> | <code>luminance</code> | <code>match-source</code> ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>match-source</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Two of the three values are straightforward: <code>alpha</code> means the alpha channel of the image should be used to compute the mask, and <code>luminance</code> means the brightness levels should be used.  The difference is illustrated in <a data-type="xref" href="#masks-mode">Figure 20-44</a>, which is the result of the following code:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code><code class="nc">.theatre</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/theatre-masks.svg)</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.compass</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/Compass_masked.png)</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.lum</code> <code class="p">{</code><code class="k">mask-mode</code><code class="o">:</code> <code class="n">luminance</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"i/theatre-masks.svg"</code><code class="w"> </code><code class="na">role=</code><code class="s">"img"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"theater mask"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;img</code><code class="w"> </code><code class="na">class=</code><code class="s">"theatre"</code><code class="w"> </code><code class="na">src=</code><code class="s">"i/mask.jpg"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"mask"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;img</code><code class="w"> </code><code class="na">class=</code><code class="s">"theatre lum"</code><code class="w"> </code><code class="na">src=</code><code class="s">"i/mask.jpg"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"mask"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;img</code><code class="w"> </code><code class="na">src=</code><code class="s">"i/Compass_masked.png"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"mask"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;img</code><code class="w"> </code><code class="na">class=</code><code class="s">"compass"</code><code class="w"> </code><code class="na">src=</code><code class="s">"i/mask.jpg"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"mask"</code><code class="nt">&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;img</code><code class="w"> </code><code class="na">class=</code><code class="s">"compass lum"</code><code class="w"> </code><code class="na">src=</code><code class="s">"i/mask.jpg"</code><code class="w"> </code><code class="na">alt=</code><code class="s">"mask"</code><code class="nt">&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>When <code>luminance</code> is used to calculate the mask, brightness is treated the same way alpha values are in alpha masking.  Consider how alpha masking works: any part of the image with opacity of 0 hides that part of the masked element.  A part of the image with opacity of 1 (fully opaque) reveals that part of the masked element.</p>&#13;
&#13;
<p>The same is true with luminance-based masking.  A part of the mask with luminosity of 1 reveals that part of the masked element.  A part of the mask with luminosity of 0 (fully black) hides that part of the masked element.  But note that any fully transparent part of the mask is <em>also</em> treated as having a luminance of 0.  This is why the shadow portion of the theater-mask image doesn’t show any part of the masked image: its alpha value is greater than 0.</p>&#13;
&#13;
<figure><div class="figure" id="masks-mode">&#13;
<img alt="css5 2045" src="assets/css5_2045.png"/>&#13;
<h6><span class="label">Figure 20-44. </span>Alpha and luminance mask modes</h6>&#13;
</div></figure>&#13;
&#13;
<p>The third (and default) value, <code>match-source</code>, is a combination of <code>alpha</code> and <code>luminance</code>, choosing between them based on the actual source image for the mask as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>If the source is a type of &lt;<em><code>image</code></em>&gt;, use <code>alpha</code>. The &lt;<em><code>image</code></em>&gt; can be an image such as a PNG or visible SVG, a CSS gradient, or a piece of the page referred to by the &#13;
<span class="keep-together"><code>element()</code></span> function.</p>&#13;
</li>&#13;
<li>&#13;
<p>If the source is an SVG <code>&lt;mask&gt;</code> element, use <code>luminance</code>.<a data-primary="" data-startref="ix_mask_mode_prop" data-type="indexterm" id="idm45176029552992"/><a data-primary="" data-startref="ix_mask_mode_chge" data-type="indexterm" id="idm45176029551984"/></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sizing and Repeating Masks" data-type="sect2"><div class="sect2" id="sizing_and_repeating_masks">&#13;
<h2>Sizing and Repeating Masks</h2>&#13;
&#13;
<p>Thus far, <a data-primary="mask-size property" data-type="indexterm" id="ix_mask_size_prop"/><a data-primary="masks" data-secondary="sizing" data-type="indexterm" id="ix_mask_size"/>nearly all the examples have been carefully crafted to make each mask’s size match the size of the element it’s masking.  (This is why we keeping applying masks to images.)  In many cases, mask images may be a different size than the masked element. CSS has a couple of ways to deal with this, starting with <code>mask-size</code>.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176029494704">&#13;
<h1>mask-size</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ [ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | <code>auto</code> ]{1,2} | <code>cover</code> | <code>contain</code> ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>auto</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If you’ve ever sized background images, you know exactly how to size masks, because the value syntax is <em>exactly</em> the same, as are the behaviors.  As an example, consider the following styles, which have the result shown in <a data-type="xref" href="#masks-sizing">Figure 20-45</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/hexlike.svg)</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-size</code><code class="o">:</code> <code class="m">100%</code> <code class="m">100%</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-size</code><code class="o">:</code> <code class="m">50%</code> <code class="m">100%</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">3</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-size</code><code class="o">:</code> <code class="m">2em</code> <code class="m">3em</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">4</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-size</code><code class="o">:</code> <code class="n">cover</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">5</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-size</code><code class="o">:</code> <code class="n">contain</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">6</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-size</code><code class="o">:</code> <code class="m">200%</code> <code class="m">50%</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="masks-sizing">&#13;
<img alt="css5 2046" src="assets/css5_2046.png"/>&#13;
<h6><span class="label">Figure 20-45. </span>Sizing masks</h6>&#13;
</div></figure>&#13;
&#13;
<p>Again, these should be immediately familiar to you if you’ve ever sized backgrounds. If not, see <a data-type="xref" href="ch08.html#sizing-background-images">“Sizing Background Images”</a> for a more detailed exploration of the possibilities.</p>&#13;
&#13;
<p>In a like <a data-primary="mask-repeat property" data-type="indexterm" id="idm45176029421536"/><a data-primary="masks" data-secondary="repeating" data-type="indexterm" id="idm45176029420800"/>vein, just as the pattern of backgrounds repeating throughout the background area of the element can be changed or suppressed, mask images can be affected with <code>mask-repeat</code>.<a data-primary="" data-startref="ix_mask_size" data-type="indexterm" id="idm45176029419344"/><a data-primary="" data-startref="ix_mask_size_prop" data-type="indexterm" id="idm45176029418336"/></p>&#13;
<aside class="pagebreak-before less_space" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176029417264">&#13;
<h1>mask-repeat</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>repeat-x</code> | <code>repeat-y</code> | [ <code>repeat</code> | <code>space</code> | <code>round</code> | <code>no-repeat</code> ]{1,2} ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>repeat</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>The keywords for <code>mask-repeat</code> are reproduced from <code>background-repeat</code> and have the same behaviors</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The values available here are the same as those for <code>background-repeat</code>. <a data-type="xref" href="#masks-repeat">Figure 20-46</a> shows some examples, based on the following styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/theatre-masks.svg)</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-repeat</code><code class="o">:</code> <code class="nb">no-repeat</code><code class="p">;</code> <code class="k">mask-size</code><code class="o">:</code> <code class="m">10%</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-repeat</code><code class="o">:</code> <code class="nb">repeat-x</code><code class="p">;</code> <code class="k">mask-size</code><code class="o">:</code> <code class="m">10%</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">3</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-repeat</code><code class="o">:</code> <code class="nb">repeat-y</code><code class="p">;</code> <code class="k">mask-size</code><code class="o">:</code> <code class="m">10%</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">4</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-repeat</code><code class="o">:</code> <code class="nb">repeat</code><code class="p">;</code> <code class="k">mask-size</code><code class="o">:</code> <code class="m">30%</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">5</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-repeat</code><code class="o">:</code> <code class="nb">repeat</code> <code class="n">round</code><code class="p">;</code> <code class="k">mask-size</code><code class="o">:</code> <code class="m">30%</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">6</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-repeat</code><code class="o">:</code> <code class="n">space</code> <code class="nb">no-repeat</code><code class="p">;</code> <code class="k">mask-size</code><code class="o">:</code> <code class="m">21%</code> <code class="nb">auto</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="masks-repeat">&#13;
<img alt="css5 2047" src="assets/css5_2047.png"/>&#13;
<h6><span class="label">Figure 20-46. </span>Repeating masks</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Positioning Masks" data-type="sect2"><div class="sect2" id="idm45176029221552">&#13;
<h2>Positioning Masks</h2>&#13;
&#13;
<p>Given that <a data-primary="positioning" data-secondary="masks" data-type="indexterm" id="ix_pos_masks"/><a data-primary="masks" data-secondary="positioning" data-type="indexterm" id="ix_masks_position"/><a data-primary="mask-position property" data-type="indexterm" id="ix_mask_pos_prop"/>sizing and repetition of mask images mirrors the sizing and repetition of background images, you might think that the same is true for positioning the origin mask image, similar to <code>background-position</code>, as well as the origin box, similar to <code>background-origin</code>.  And you’d be exactly right.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176029187200">&#13;
<h1>mask-position</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>position</code></em>&gt;#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0% 0%</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>length</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Notes</strong></p></td>&#13;
<td><p>&lt;<em><code>position</code></em>&gt; is exactly the same as the values permitted for <code>background-position</code>, and has the same behaviors</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Once again, if you’ve ever positioned a background image, you know how to position mask images.  Following are a few examples, illustrated in <a data-type="xref" href="#masks-position">Figure 20-47</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/Compass_masked.png)</code><code class="p">;</code>&#13;
	<code class="k">mask-repeat</code><code class="o">:</code> <code class="nb">no-repeat</code><code class="p">;</code> <code class="k">mask-size</code><code class="o">:</code> <code class="m">67%</code> <code class="nb">auto</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-position</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-position</code><code class="o">:</code> <code class="nb">top</code> <code class="nb">right</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">3</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-position</code><code class="o">:</code> <code class="m">33%</code> <code class="m">80%</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">4</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-position</code><code class="o">:</code> <code class="m">5em</code> <code class="m">120%</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="masks-position">&#13;
<img alt="css5 2048" src="assets/css5_2048.png"/>&#13;
<h6><span class="label">Figure 20-47. </span>Positioning masks</h6>&#13;
</div></figure>&#13;
&#13;
<p>By default, the <a data-primary="mask-origin property" data-type="indexterm" id="idm45176029116896"/><a data-primary="masks" data-secondary="origin" data-type="indexterm" id="idm45176029116160"/>origin box for mask images is the outer border edge.  If you want to move it further inward, or define a specific origin box in an SVG context, then <code>mask-origin</code> does for masks what <code>background-origin</code> does for backgrounds.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176029114128">&#13;
<h1>mask-origin</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>content-box</code> | <code>padding-box</code> | <code>border-box</code> | <code>margin-box</code> | <code>fill-box</code> | <br/><code>stroke-box</code> | <code>view-box</code> ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>border-box</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>For the full story, see <a data-type="xref" href="ch08.html#changing-the-positioning-box">“Changing the positioning box”</a>, but for a quick example, see <a data-type="xref" href="#masks-origin">Figure 20-48</a>.<a data-primary="" data-startref="ix_mask_pos_prop" data-type="indexterm" id="idm45176029052272"/><a data-primary="" data-startref="ix_pos_masks" data-type="indexterm" id="idm45176029051296"/><a data-primary="" data-startref="ix_masks_position" data-type="indexterm" id="idm45176029050352"/></p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="masks-origin">&#13;
<img alt="css5 2049" src="assets/css5_2049.png"/>&#13;
<h6><span class="label">Figure 20-48. </span>Changing the origin box</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Clipping and Compositing Masks" data-type="sect2"><div class="sect2" id="idm45176029220896">&#13;
<h2>Clipping and Compositing Masks</h2>&#13;
&#13;
<p>One more <a data-primary="masks" data-secondary="clipping" data-type="indexterm" id="idm45176029045568"/><a data-primary="mask-clip property" data-type="indexterm" id="idm45176029044560"/><a data-primary="clipping" data-secondary="masks" data-type="indexterm" id="idm45176029043888"/>property echoes backgrounds, and that’s <code>mask-clip</code>, the mask equivalent of <code>background-clip</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176029041888">&#13;
<h1>mask-clip</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>content-box</code> | <code>padding-box</code> | <code>border-box</code> | <code>margin-box</code> | <code>fill-box</code> | <br/><code>stroke-box</code> | <code>view-box</code> | <code>no-clip</code> ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>border-box</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>All this does is clip the overall mask to a specific area of the masked element.  In other words, it restricts the area in which the visible parts of the element are in fact visible.  <a data-type="xref" href="#masks-clip">Figure 20-49</a> shows the result of the following styles:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">padding</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">2em</code> <code class="nb">solid</code> <code class="nb">purple</code><code class="p">;</code> <code class="k">margin</code><code class="o">:</code> <code class="m">2em</code><code class="p">;</code>&#13;
	<code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(i/Compass_masked.png)</code><code class="p">;</code>&#13;
	<code class="k">mask-repeat</code><code class="o">:</code> <code class="nb">no-repeat</code><code class="p">;</code> <code class="k">mask-size</code><code class="o">:</code> <code class="m">125%</code><code class="p">;</code>&#13;
	<code class="k">mask-position</code><code class="o">:</code> <code class="nb">center</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-clip</code><code class="o">:</code> <code class="nb">border-box</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-clip</code><code class="o">:</code> <code class="nb">padding-box</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nd">:nth-child</code><code class="o">(</code><code class="nt">3</code><code class="o">)</code> <code class="p">{</code><code class="k">mask-clip</code><code class="o">:</code> <code class="nb">content-box</code><code class="p">;}</code></pre>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="masks-clip">&#13;
<img alt="css5 2050" src="assets/css5_2050.png"/>&#13;
<h6><span class="label">Figure 20-49. </span>Clipping the mask</h6>&#13;
</div></figure>&#13;
&#13;
<p>The last <a data-primary="masks" data-secondary="compositing" data-type="indexterm" id="ix_mask_composite"/><a data-primary="mask-composite property" data-type="indexterm" id="ix_mask_composite_prop"/>longhand masking property, <code>mask-composite</code>, is quite interesting because it can radically change the way multiple masks interact.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of early 2023, <code>mask-composite</code> is supported only by Firefox, but all browsers (even Firefox) support the prefixed form <code>-webkit-mask-composite</code>.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028969248">&#13;
<h1>mask-composite</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>add</code> | <code>subtract</code>  | <code>intersect</code>  | <code>exclude</code> ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>add</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If you are not familiar with compositing operations, a diagram is in order. See <a data-type="xref" href="#masks-composite-diagram">Figure 20-50</a>.</p>&#13;
&#13;
<figure><div class="figure" id="masks-composite-diagram">&#13;
<img alt="css5 2051" src="assets/css5_2051.png"/>&#13;
<h6><span class="label">Figure 20-50. </span>Compositing operations</h6>&#13;
</div></figure>&#13;
&#13;
<p>The image on top in the operation is called the <em>source</em>, and the image beneath it is called the <em>destination</em>.</p>&#13;
&#13;
<p>This doesn’t particularly matter for three of the four operations: <code>add</code>, <code>intersect</code>, and <code>exclude</code>, all of which have the same result regardless of which image is the source and which the destination.  But for <code>subtract</code>, the question is: which image is being subtracted from which?  The answer: the destination is subtracted from the source.</p>&#13;
&#13;
<p>The distinction between source and destination also becomes important when compositing multiple masks together.  In these cases, the compositing order is from back to front, with each succeeding layer being the source and the already-composited layers beneath it being the destination.</p>&#13;
&#13;
<p>To see why, consider <a data-type="xref" href="#masks-composite-multiple">Figure 20-51</a>, which shows the various ways three overlapping masks are composited together, and how results change with changes to their order and compositing operations.</p>&#13;
&#13;
<p>The figure is constructed to show the bottommost mask at the bottom, the topmost above the other two, and the resulting mask at the very top.  Thus, in the first column, the triangle and circle are composited with an exclusion operation.  The resulting shape is then composited with the square using an additive operation.  That results in the mask shown at the top of the first column.</p>&#13;
&#13;
<p>Just remember that when doing a subtraction composite, the bottom shape is subtracted from the shape above it. Thus, in the third column, the addition of the triangle and circle is subtracted from the square above them.<a data-primary="" data-startref="ix_mask_composite_prop" data-type="indexterm" id="idm45176028894320"/><a data-primary="" data-startref="ix_mask_composite" data-type="indexterm" id="idm45176028893472"/> This is accomplished with <code>mask-composite: add, subtract</code>.</p>&#13;
&#13;
<figure><div class="figure" id="masks-composite-multiple">&#13;
<img alt="css5 2052" src="assets/css5_2052.png"/>&#13;
<h6><span class="label">Figure 20-51. </span>Compositing masks</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Bringing It All Together" data-type="sect2"><div class="sect2" id="idm45176029046608">&#13;
<h2>Bringing It All Together</h2>&#13;
&#13;
<p>All of the <a data-primary="mask property" data-type="indexterm" id="idm45176028888560"/><a data-primary="masks" data-secondary="shorthand property" data-type="indexterm" id="idm45176028887824"/>preceding mask properties are brought together in the shorthand property <code>mask</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028886240">&#13;
<h1>mask</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>mask-image</code></em>&gt; ‖ &lt;<em><code>mask-position</code></em>&gt; [ / &lt;<em><code>mask-size</code></em>&gt; ]? ‖ <br/>&lt;<em><code>mask-repeat</code></em>&gt; ‖ &lt;<em><code>mask-clip</code></em>&gt; ‖ &lt;<em><code>mask-origin</code></em>&gt; ‖ <br/>&lt;<em><code>mask-composite</code></em>&gt; ‖ &lt;<em><code>mask-mode</code></em>&gt; ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Refer to individual properties</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Like all the other masking properties, <code>mask</code> accepts a comma-separated list of masks.  The order of the values in each mask can be anything except for the mask size, which always follows the position and is separated from it by a forward slash (<code>/</code>).</p>&#13;
&#13;
<p>Thus, the following rules are equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#example</code> <code class="p">{</code>&#13;
    <code class="k">mask-image</code><code class="o">:</code> <code class="sx">url(circle.svg)</code><code class="o">,</code> <code class="sx">url(square.png)</code><code class="o">,</code> <code class="sx">url(triangle.gif)</code><code class="p">;</code>&#13;
    <code class="k">mask-repeat</code><code class="o">:</code> <code class="nb">repeat-y</code><code class="o">,</code> <code class="nb">no-repeat</code><code class="p">;</code>&#13;
    <code class="k">mask-position</code><code class="o">:</code> <code class="nb">top</code> <code class="nb">right</code><code class="o">,</code> <code class="nb">center</code><code class="o">,</code> <code class="m">25%</code> <code class="m">67%</code><code class="p">;</code>&#13;
    <code class="k">mask-composite</code><code class="o">:</code> <code class="n">subtract</code><code class="o">,</code> <code class="n">add</code><code class="p">;</code>&#13;
    <code class="k">mask-size</code><code class="o">:</code> <code class="nb">auto</code><code class="o">,</code> <code class="m">50%</code> <code class="m">33%</code><code class="o">,</code> <code class="n">contain</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nf">#example</code> <code class="p">{</code>&#13;
    <code class="k">mask</code><code class="o">:</code>&#13;
      <code class="sx">url(circle.svg)</code> <code class="nb">repeat-y</code> <code class="nb">top</code> <code class="nb">right</code> <code class="o">/</code> <code class="nb">auto</code> <code class="n">subtract</code><code class="o">,</code>&#13;
      <code class="sx">url(square.png)</code> <code class="nb">no-repeat</code> <code class="nb">center</code> <code class="o">/</code> <code class="m">50%</code> <code class="m">33%</code> <code class="n">add</code><code class="o">,</code>&#13;
      <code class="sx">url(triangle.gif)</code> <code class="nb">repeat-y</code> <code class="m">25%</code> <code class="m">67%</code> <code class="o">/</code> <code class="n">contain</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The triangle and square are added together, and then the result of that additive composite is subtracted from the circle.  The result is shown in <a data-type="xref" href="#masks-multiple">Figure 20-52</a> as applied to a square element (the teal shape on the left) and a shape wider than it is tall (the goldenrod shape on the right).</p>&#13;
&#13;
<figure><div class="figure" id="masks-multiple">&#13;
<img alt="css5 2053" src="assets/css5_2053.png"/>&#13;
<h6><span class="label">Figure 20-52. </span>Two masks</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Mask Types" data-type="sect2"><div class="sect2" id="idm45176028810960">&#13;
<h2>Setting Mask Types</h2>&#13;
&#13;
<p>When you’re <a data-primary="masks" data-secondary="setting types" data-type="indexterm" id="idm45176028809360"/><a data-primary="mask-type property" data-type="indexterm" id="idm45176028808352"/>using CSS to style SVG elements, and you want to set the SVG <code>&lt;mask&gt;</code> type, then <code>mask-type</code> is for you.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028742064">&#13;
<h1>mask-type</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>luminance</code> | <code>alpha</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>luminance</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>SVG <code>&lt;mask&gt;</code> elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This property is similar to <code>mask-mode</code>, except there is no <code>match-source</code> equivalent. You can choose only <code>luminance</code> or <code>alpha</code>.</p>&#13;
&#13;
<p>The interesting thing is that if <code>mask-type</code> is set for a <code>&lt;mask&gt;</code> element that’s used to mask an element, and <code>mask-mode</code> is declared for that masked element, <code>mask-mode</code> wins. As an example, consider the following rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">svg</code> <code class="nf">#mask</code> <code class="p">{</code><code class="k">mask-type</code><code class="o">:</code> <code class="n">alpha</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nc">.masked</code> <code class="p">{</code><code class="k">mask</code><code class="o">:</code> <code class="sx">url(#mask)</code> <code class="nb">no-repeat</code> <code class="nb">center</code><code class="o">/</code><code class="n">cover</code> <code class="n">luminance</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Given these rules, the masked images will have a mask with luminance compositing, not alpha compositing.  If the <code>mask-mode</code> value were left at its default value, <code>match-source</code>, then <code>mask-type</code>’s value would be used instead.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Border-Image Masking" data-type="sect2"><div class="sect2" id="border-image_masking">&#13;
<h2>Border-Image Masking</h2>&#13;
&#13;
<p>The <a data-primary="masks" data-secondary="border-image masking" data-type="indexterm" id="ix_mask_border_image"/>same specification that defines clipping paths and element masking, CSS Masking, also defines properties that are used to apply masking images in a way that mirrors border-image properties.  In fact, with one exception, the properties between border images and border masks are direct analogues, and the values the same.  Refer to <a data-type="xref" href="ch07.html#image-borders">“Image Borders”</a> for a detailed explanation of how these work, but here are some quick recaps.</p>&#13;
&#13;
<p>Remember that without having a border of some sort, none of these properties will have any visible effect. To apply a border and then mask it, you must first declare a border’s style, at a minimum.  If you intend your masked border to be 10 pixels wide, you would need something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">border</code><code class="o">:</code> <code class="m">10px</code> <code class="nb">solid</code><code class="p">;</code></pre>&#13;
&#13;
<p>Once that’s <a data-primary="mask-border-source property" data-type="indexterm" id="idm45176028696944"/>been established, you can begin masking the border.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of late 2022, all these properties are supported in Chromium and WebKit browsers as <code>-webkit-mask-box-image-*</code> instead of the names used in the specification. The actually supported names are noted in the property summary boxes that follow, but examples use the standard (unprefixed) property names. Also note: as of this writing, the Gecko (Firefox) family does not support border masks in any form.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028694800">&#13;
<h1>mask-border-source</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | &lt;<em><code>image</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements when <code>border-collapse</code> is <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p><code>none</code>, or the image with its URL made absolute</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Supported in Chromium and WebKit only as <code>-webkit-mask-box-image-source</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>mask-border-source</code> property<a data-primary="mask-border-slice property" data-type="indexterm" id="idm45176028630096"/> specifies the image to be used as a mask.  This can be a URL, gradient, or other supported &lt;<em><code>image</code></em>&gt; value type.  Once the masking image has been set up, you can move on to doing things like slicing it into sections, defining a distinct width for the mask, and so on.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028628480">&#13;
<h1>mask-border-slice</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>number</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; ]{1,4} &amp;&amp; <code>fill</code>?</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>100%</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements when <code>border-collapse</code> is <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Refer to size of the border image</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As four values, each a number or percentage, and optionally the <code>fill</code> keyword</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>&lt;<em><code>number</code></em>&gt;, &lt;<em><code>percentage</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Supported in Chromium and WebKit only as <code>-webkit-mask-box-image-slice</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>mask-border-slice</code> property establishes a set of four slice-lines that are laid over the border, and where they fall determines how the mask will be sliced up for use in each of the eight parts of the border area: the top, right, bottom, and left edges, as well as the top-left, top-right, bottom-right, and bottom-left corners.  The property takes up to four values, defining (in order) offsets from the top, right, bottom, and left edges.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>As of late 2022, no logical-property equivalent exists for <code>mask-border-slice</code>.  If the proposed addition of a <code>logical</code> keyword, or something equivalent, to this property is ever adopted and implemented, at that point it will be possible to use <code>mask-border-slice</code> in a writing-flow-relative fashion.</p>&#13;
</div>&#13;
&#13;
<p>Consider the following, diagrammed in <a data-type="xref" href="#mask-border-patterns">Figure 20-53</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#one</code> <code class="p">{</code><code class="k">mask-border-slice</code><code class="o">:</code> <code class="m">25%</code><code class="p">;}</code>&#13;
<code class="nf">#two</code> <code class="p">{</code><code class="k">mask-border-slice</code><code class="o">:</code> <code class="m">10%</code> <code class="m">20%</code><code class="p">;}</code>&#13;
<code class="nf">#thr</code> <code class="p">{</code><code class="k">mask-border-slice</code><code class="o">:</code> <code class="m">10</code> <code class="m">20</code> <code class="m">15</code> <code class="m">30</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="mask-border-patterns">&#13;
<img alt="css5 2054" src="assets/css5_2054.png"/>&#13;
<h6><span class="label">Figure 20-53. </span>Some mask border-slicing patterns</h6>&#13;
</div></figure>&#13;
&#13;
<p>You might think that numeric offsets need to be given a length unit to define a distance, but this is not so. Number values are interpreted in the coordinate system of the image used for the mask.  With a raster image like a PNG, the coordinate system will be the pixels of the image.  In an SVG image, the coordinate system defined by the SVG file is used.</p>&#13;
&#13;
<p>Using the optional <code>fill</code> keyword causes the center portion of the mask image to be applied to the element inside the border area.  By default, it is not used, allowing the element’s padding and content to be fully seen.  If you do use it by adding <code>fill</code>, the part of the mask image inside the four slice lines will be stretched over the element’s content and padding, and applied to them.  Consider the following, illustrated in <a data-type="xref" href="#mask-border-fill">Figure 20-54</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">mask-border</code><code class="o">-</code><code class="n">image</code><code class="o">:</code> <code class="sx">url(circles.png)</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.one</code> <code class="p">{</code><code class="k">mask-border-slice</code><code class="o">:</code> <code class="m">33%</code><code class="p">;}</code>&#13;
<code class="nt">p</code><code class="nc">.two</code> <code class="p">{</code><code class="k">mask-border-slice</code><code class="o">:</code> <code class="m">33%</code> <code class="n">fill</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="mask-border-fill">&#13;
<img alt="css5 2055" src="assets/css5_2055.png"/>&#13;
<h6><span class="label">Figure 20-54. </span>Applying the mask fill</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, a bug in browsers that support the prefixed property causes the content and padding of an element to be completely hidden unless the <code>fill</code> keyword is used.  Thus, in order to use border masks and show the content of an element, you need to fill the center of the mask image completely, <a data-primary="mask-border-width property" data-type="indexterm" id="idm45176028523072"/>and use <code>fill</code>.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028521568">&#13;
<h1>mask-border-width</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>percentage</code></em>&gt; | &lt;<em><code>number</code></em>&gt; | <code>auto</code> ]{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except table elements when <code>border-collapse</code> is <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>Relative to width/height of the entire border image area—that is, the outer edges of the border box</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Four values: each a percentage, number, <code>auto</code> keyword, or &lt;<em><code>length</code></em>&gt; made absolute</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Values can never be negative; supported in Chromium and WebKit only as <code>-webkit-mask-box-image-width</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>This property allows you to define a width (or individual widths) for the four edge slices of the border mask.  If the slices are not actually the size(s) you declare, they will be resized to fit.  For example, a masking image might be sliced and then sized as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">mask-border-slice</code><code class="o">:</code> <code class="m">33%</code><code class="p">;</code> <code class="k">mask-border</code><code class="o">-</code><code class="k">width</code><code class="o">:</code> <code class="m">1em</code><code class="p">;</code></pre>&#13;
&#13;
<p>This <a data-primary="mask-border-outset property" data-type="indexterm" id="idm45176028473136"/>allows you to slice up the masking image in one way, and then size it as needed for the context or define a universal size for masking image, regardless of the context in which it appears.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028472272">&#13;
<h1>mask-border-outset</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ &lt;<em><code>length</code></em>&gt; | &lt;<em><code>number</code></em>&gt; ]{1,4}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements when <code>border-collapse</code> is <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Percentages</strong></p></td>&#13;
<td><p>N/A</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Four values, each a number or &lt;<em><code>length</code></em>&gt; made absolute</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Supported in Chromium and WebKit only as <code>-webkit-mask-box-image-outset</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>With <code>mask-border-outset</code>, you can push the mask outside the border area.  This is useful only if you’re already pushing a border image outside the border area with <code>border-image-outset</code> and want to also apply the mask to that border image, or if you’ve applied an outline to the element and want to mask that as well. If neither is true, the masked area outside the border will mask only the margin area, which is already transparent and so can’t be visibly altered.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>As of late 2022, browsers supporting the prefixed property not only push the slices outward, but also expand the center area by the given amount, scaling up the masked area covered by the center slice in the process.  This behavior is not called for or apparently supported by the specifications current as of this writing, and is most likely a bug (unless the behavior is eventually made retroactively <a data-primary="mask-border-repeat property" data-type="indexterm" id="idm45176028422400"/>correct by a CSS Working Group decision).</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028421408">&#13;
<h1>mask-border-repeat</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ <code>stretch</code> | <code>repeat</code> | <code>round</code> | <code>space</code> ]{1,2}</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>stretch</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, except internal table elements when <code>border-collapse</code> is <code>collapse</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>Two keywords, one for each axis</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Supported in Chromium and WebKit only as <code>-webkit-mask-box-image-repeat</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>Thus far, our only example of border masking has used a masking image that is an exact fit for the element it’s masking.  This is unlikely to be the case, since elements can be resized by any number of factors.  The default is to stretch each slice to fit its part of the border area, but other options are possible. <a data-type="xref" href="#mask-border-repeating">Figure 20-55</a> illustrates the options (center areas have been removed for clarity).</p>&#13;
&#13;
<figure><div class="figure" id="mask-border-repeating">&#13;
<img alt="css5 2056" src="assets/css5_2056.png"/>&#13;
<h6><span class="label">Figure 20-55. </span>Various kinds of mask image repeating</h6>&#13;
</div></figure>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#mask-border-repeating">Figure 20-55</a>, <code>mask-border-repeat</code> can accept one or two repeat values.  If one is given, it’s applied to all sides of the border area.  If two are given, the first applies to the horizontal sides of the border area, and the second to the vertical sides.</p>&#13;
&#13;
<p>Border <a data-primary="mask-border-mode property" data-type="indexterm" id="idm45176028399488"/>masks have one styling aspect that image borders do not, and it’s set with the property <code>mask-border-mode</code>.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028398032">&#13;
<h1>mask-border-mode</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>alpha</code> | <code>luminance</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>alpha</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements (in SVG, applies to all graphics elements and all container elements except the <code>&lt;defs&gt;</code> element, all graphics elements, and the <code>&lt;use&gt;</code> element)</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Discrete</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Not yet supported in any browser, even with a <code>-webkit-</code> prefix</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>mask-border-mode</code> property sets whether the masking mode is alpha based, or luminance based.  <a data-primary="mask-border property" data-type="indexterm" id="idm45176028381040"/>For more details on the difference, see the <code>mask-mode</code> property discussed earlier in the chapter.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028379568">&#13;
<h1>mask-border</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>mask-border-source</code></em>&gt; ‖ &lt;<em><code>mask-border-slice</code></em>&gt; [ /&#13;
&lt;<em><code>mask-border-width</code></em>&gt;? [ / &lt;<em><code>mask-border-outset</code></em>&gt; ]? ]? ‖ &lt;<em><code>mask-border-repeat</code></em>&gt; ‖ &lt;<em><code>mask-border-mode</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>See individual properties</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Note</strong></p></td>&#13;
<td><p>Supported in Chromium and WebKit only as <code>-webkit-mask-box-image</code> without the <code>mask-border-mode</code> value</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The property <code>mask-border</code> incorporates all of the previous border-masking properties into one convenient shorthand.<a data-primary="" data-startref="ix_masks_ch20" data-type="indexterm" id="idm45176028360272"/><a data-primary="" data-startref="ix_mask_border_image" data-type="indexterm" id="idm45176028359296"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Object Fitting and Positioning" data-type="sect1"><div class="sect1" id="object-fitting-and-positioning">&#13;
<h1>Object Fitting and Positioning</h1>&#13;
&#13;
<p>One more <a data-primary="images" data-secondary="fitting and positioning" data-type="indexterm" id="ix_image_fit_pos"/><a data-primary="object-fit property" data-type="indexterm" id="ix_obj_fit_prop"/><a data-primary="fitting objects" data-type="indexterm" id="ix_fit_obj"/>variety of masking applies solely to replaced elements like images.  With <code>object-fit</code>, you can change the way the replaced element fills its element box—or even have it not fill that box completely.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028352528">&#13;
<h1>object-fit</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>fill</code> | <code>contain</code> | <code>cover</code> | <code>scale-down</code> | <code>none</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>fill</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Replaced elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>If you’ve ever worked with <code>background-size</code>, these values probably look familiar.  They do similar things, too, only with replaced elements.</p>&#13;
&#13;
<p>For example, assume a 50 × 50 pixel image. We can change its size via CSS with something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">250px</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">150px</code><code class="p">;}</code></pre>&#13;
&#13;
<p>The default expectation is that these style declarations will stretch the 50 × 50 image to be 250 × 150.  And if <code>object-fit</code> is its default value, <code>fill</code>, that’s exactly what happens.</p>&#13;
&#13;
<p>Change the value of <code>object-fit</code>, however, and other behaviors occur. The following examples are illustrated in <a data-type="xref" href="#object-fit">Figure 20-56</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">250px</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">150px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">3px</code> <code class="nb">solid</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">1</code><code class="o">)</code> <code class="p">{</code><code class="k">object-fit</code><code class="o">:</code> <code class="nb">none</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">object-fit</code><code class="o">:</code> <code class="n">fill</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">3</code><code class="o">)</code> <code class="p">{</code><code class="k">object-fit</code><code class="o">:</code> <code class="n">cover</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">4</code><code class="o">)</code> <code class="p">{</code><code class="k">object-fit</code><code class="o">:</code> <code class="n">contain</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="object-fit">&#13;
<img alt="css5 2057" src="assets/css5_2057.png"/>&#13;
<h6><span class="label">Figure 20-56. </span>Four kinds of object fitting</h6>&#13;
</div></figure>&#13;
&#13;
<p>In the first instance, <code>none</code>, the <code>&lt;img&gt;</code> element is drawn 250 pixels wide by 150 pixels tall.  The image itself, however, is drawn 50 × 50 pixels—its intrinsic size—because it was directed to <em>not</em> fit the element box.  The second instance, <code>fill</code>, is the default behavior, as mentioned. This is the only value that may distort the image, as the dimensions are the element’s dimensions, not the image’s intrinsic size.</p>&#13;
&#13;
<p>In the third instance, <code>cover</code>, the image is scaled up until no part of the element box is left “uncovered”—but the image itself keeps its intrinsic aspect ratio.  In other words, the image stays a square.  In this case, the longest axis of the <code>&lt;img&gt;</code> element is <code>250px</code> long, so the image is scaled up to be 250 × 250 pixels.  That 250 × 250 image is then placed in the 250 × 150 <code>&lt;img&gt;</code> element.</p>&#13;
&#13;
<p>The fourth instance, <code>contain</code>, is similar, except the image is only big enough to touch two sides of the <code>&lt;img&gt;</code> element.  This means the image is 150 × 150 pixels, and placed into the 250 × 150 pixel box of its <code>&lt;img&gt;</code> element.</p>&#13;
&#13;
<p>To reiterate, what you see in <a data-type="xref" href="#object-fit">Figure 20-56</a> is four <code>&lt;img&gt;</code> elements.  There are no wrapper <code>&lt;div&gt;</code> or <code>&lt;span&gt;</code> or other elements around those images.  The border and background color are part of the <code>&lt;img&gt;</code> element.  The image placed inside the <code>&lt;img&gt;</code> element is fitted according to <code>object-fit</code>.  The element box of the <code>&lt;img&gt;</code> element then acts rather like it’s a simple mask for the fitted image inside it.  (And then you can mask and clip the element box with the properties covered earlier in this chapter.)</p>&#13;
&#13;
<p>A fifth value for <code>object-fit</code>, not represented in <a data-type="xref" href="#object-fit">Figure 20-56</a>, is <code>scale-down</code>.  The meaning of <code>scale-down</code> is “do the same as either <code>none</code> or <code>contain</code>, whichever leads to a smaller size.”  This lets an image always be its intrinsic size unless the <code>&lt;img&gt;</code> element gets too small, in which case it’s scaled down à la <code>contain</code>.  This is illustrated in <a data-type="xref" href="#object-fit-scale-down">Figure 20-57</a>, where each <code>&lt;img&gt;</code> element is labeled with the <code>height</code> values it’s been given; the <code>width</code> in each case is <code>100px</code>.</p>&#13;
&#13;
<figure><div class="figure" id="object-fit-scale-down">&#13;
<img alt="css5 2058" src="assets/css5_2058.png"/>&#13;
<h6><span class="label">Figure 20-57. </span>Various <code>scale-down</code> scenarios</h6>&#13;
</div></figure>&#13;
&#13;
<p>So if a <a data-primary="positioning" data-secondary="object" data-type="indexterm" id="ix_pos_object"/><a data-primary="positioning" data-secondary="images" data-type="indexterm" id="ix_pos_image"/><a data-primary="object-position property" data-type="indexterm" id="ix_obj_pos_prop"/>replaced element is bigger or smaller than the element box into which it’s being fit, how can we affect its alignment within that box? Using <code>object-position</code> is the answer.<a data-primary="" data-startref="ix_fit_obj" data-type="indexterm" id="idm45176028181760"/><a data-primary="" data-startref="ix_obj_fit_prop" data-type="indexterm" id="idm45176028180752"/></p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176028179680">&#13;
<h1>object-position</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>position</code></em>&gt;</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>50% 50%</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>Replaced elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As declared</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>Yes</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Notes</strong></p></td>&#13;
<td><p>&lt;<em><code>position</code></em>&gt; is exactly the same as the values permitted for <code>background-position</code>, and has the same behaviors</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The value syntax here is just like that for <code>mask-position</code> or <code>background-position</code>, allowing you to position a replaced element within its element box if it isn’t set to <code>object-fit: fill</code>.  Thus, given the following CSS, we get the result shown in <a data-type="xref" href="#object-position">Figure 20-58</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">200px</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
     <code class="k">object-fit</code><code class="o">:</code> <code class="nb">none</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">object-position</code><code class="o">:</code> <code class="nb">top</code> <code class="nb">left</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">3</code><code class="o">)</code> <code class="p">{</code><code class="k">object-position</code><code class="o">:</code> <code class="m">67%</code> <code class="m">100%</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">4</code><code class="o">)</code> <code class="p">{</code><code class="k">object-position</code><code class="o">:</code> <code class="nb">left</code> <code class="m">142%</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="object-position">&#13;
<img alt="css5 2059" src="assets/css5_2059.png"/>&#13;
<h6><span class="label">Figure 20-58. </span>A variety of <code>object-position</code> values</h6>&#13;
</div></figure>&#13;
&#13;
<p>Notice that the first example has a value of <code>50% 50%</code>, even though that isn’t present in the CSS code.  That illustrates that the default value of <code>object-position</code> is <code>50% 50%</code>.  The next two examples show how various <code>object-position</code> values move the image around within the <code>&lt;img&gt;</code> element box.</p>&#13;
&#13;
<p>As the last example shows, it’s possible to move an unscaled replaced element like an image so that it’s partly clipped by its element box.  This is similar to positioning background images or masks so that they are clipped at the element boundaries.</p>&#13;
&#13;
<p>It’s also possible to position fitted elements that are larger than the element box, as can happen with <code>object-fit: cover</code>, although the results can be very different than with <code>object-fit: none</code>.  The following CSS will have results like those shown in <a data-type="xref" href="#object-position-cover">Figure 20-59</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">img</code> <code class="p">{</code><code class="k">width</code><code class="o">:</code> <code class="m">200px</code><code class="p">;</code> <code class="k">height</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code><code class="p">;</code>&#13;
     <code class="k">object-fit</code><code class="o">:</code> <code class="n">cover</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">2</code><code class="o">)</code> <code class="p">{</code><code class="k">object-position</code><code class="o">:</code> <code class="nb">top</code> <code class="nb">left</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">3</code><code class="o">)</code> <code class="p">{</code><code class="k">object-position</code><code class="o">:</code> <code class="m">67%</code> <code class="m">100%</code><code class="p">;}</code>&#13;
<code class="nt">img</code><code class="nd">:nth-of-type</code><code class="o">(</code><code class="nt">4</code><code class="o">)</code> <code class="p">{</code><code class="k">object-position</code><code class="o">:</code> <code class="nb">left</code> <code class="m">142%</code><code class="p">;}</code></pre>&#13;
&#13;
<figure><div class="figure" id="object-position-cover">&#13;
<img alt="css5 2060" src="assets/css5_2060.png"/>&#13;
<h6><span class="label">Figure 20-59. </span>Positioning a covered object</h6>&#13;
</div></figure>&#13;
&#13;
<p>If any of these results confuse you, review <a data-type="xref" href="ch08.html#background-positioning">“Positioning Background Images”</a> for more details.<a data-primary="" data-startref="ix_image_fit_pos" data-type="indexterm" id="idm45176028009280"/><a data-primary="" data-startref="ix_pos_image" data-type="indexterm" id="idm45176028008304"/><a data-primary="" data-startref="ix_obj_pos_prop" data-type="indexterm" id="idm45176028007360"/><a data-primary="" data-startref="ix_pos_object" data-type="indexterm" id="idm45176028006416"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45176028357440">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>With all of the effects available to CSS authors, we have an infinite variety of outcomes and thus an infinite variety of creative presentation of elements.  Whether it’s altering elements’ appearances with filters, changing how they’re composited with their backdrops, clipping or masking parts of elements, or altering the way images fill out their element boxes, there have never been more options at your fingertips.</p>&#13;
</div></section>&#13;
</div></section></body></html>