<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. 11 More Ways to Run a Command"><div class="chapter" id="ch_running_commands">
<h1><span class="label">Chapter 7. </span>11 More Ways to Run a Command</h1>


<p>Now that you have lots of commands in your toolbox and a thorough
understanding of the shell, it’s time to learn…how to run
commands. Wait a minute, haven’t you been running commands since the
beginning of the book? Well, yes, but only in two ways. The first is
the ordinary execution of a simple command:<a data-type="indexterm" data-primary="command" data-secondary="simple commands" id="idm46586639886720"/><a data-type="indexterm" data-primary="simple commands" id="idm46586639885712"/></p>

<pre data-type="programlisting">$ <strong>grep Nutshell animals.txt</strong></pre>

<p>The second is a pipeline<a data-type="indexterm" data-primary="pipes" data-secondary="pipelines" id="idm46586639883632"/> of simple commands, as covered in
<a data-type="xref" href="ch01.xhtml#ch_combining_commands">Chapter 1</a>:</p>

<pre data-type="programlisting">$ <strong>cut -f1 grades | sort | uniq -c | sort -nr</strong></pre>

<p>In this chapter, I’ll show you 11 more ways to run a command and why
you should care to learn them. Each technique has pros and cons, and
the more techniques you know, the more flexibly and efficiently you
can interact with Linux. I’ll stick to the basics of each technique
for now; you’ll see more intricate examples in the next two chapters.</p>






<section data-type="sect1" data-pdf-bookmark="List Techniques"><div class="sect1" id="idm46586639880160">
<h1>List Techniques</h1>

<p>A list is a sequence of commands on a single command line.  You’ve
already seen one type of list—a pipeline—but the shell supports
others with different behavior:</p>
<dl>
<dt>Conditional lists</dt>
<dd>
<p>Each command depends on the success or
failure of the previous one.</p>
</dd>
<dt>Unconditional lists</dt>
<dd>
<p>Commands simply run one after the other.</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Technique #1: Conditional Lists"><div class="sect2" id="section_conditional_lists">
<h2>Technique #1: Conditional Lists</h2>

<p><a data-type="indexterm" data-primary="conditional lists" id="idm46586639873056"/><a data-type="indexterm" data-primary="list of commands" data-secondary="conditional list" id="idm46586639872352"/><a data-type="indexterm" data-primary="running commands" data-secondary="conditional lists" id="idm46586639871408"/>
Suppose you want to create a file <em>new.txt</em> in a directory <em>dir</em>.
A typical sequence of commands might be:<a data-type="indexterm" data-primary="touch command" data-secondary="examples" id="idm46586639869504"/></p>

<pre data-type="programlisting">$ <strong>cd dir</strong>            <em>Enter the directory</em>
$ <strong>touch new.txt</strong>     <em>Make the file</em></pre>

<p>Notice how the second command depends on the success of the first. If
the directory <em>dir</em> doesn’t exist, there is no point in running the
<code>touch</code> command. The shell lets you make this dependency explicit. If
you place the operator <code>&amp;&amp;</code><a data-type="indexterm" data-primary="&amp;&amp; for conditional list" data-seealso="conditional lists" id="idm46586639864672"/><a data-type="indexterm" data-primary="ampersand (&amp;)" data-secondary="&amp;&amp; for conditional list" data-seealso="conditional lists" id="idm46586639863696"/> (pronounced “and”) between the two
commands on a single line:</p>

<pre data-type="programlisting">$ <strong>cd dir &amp;&amp; touch new.txt</strong></pre>

<p>then the second command (<code>touch</code>) runs only if the first command
(<code>cd</code>) succeeds. The preceding example is a <em>conditional list</em> of two
commands. (To learn what it means for a command to “succeed,” see
<a data-type="xref" href="#sidebar_exit_codes">“Exit Codes Indicate Success or Failure”</a>.)</p>

<p>Very likely, you run commands every day that depend on previous ones.
For example, have you ever made a backup copy of a file for
safekeeping, modified the original, and deleted the backup when done?</p>

<pre data-type="programlisting">$ <strong>cp myfile.txt myfile.safe</strong>      <em>Make a backup copy</em>
$ <strong>nano myfile.txt</strong>                <em>Change the original</em>
$ <strong>rm myfile.safe</strong>                 <em>Delete the backup</em></pre>

<p>Each of these commands makes sense only if the preceding command
succeeds. Therefore, this sequence is a candidate for a conditional list:</p>

<pre data-type="programlisting">$ <strong>cp myfile.txt myfile.safe &amp;&amp; nano myfile.txt &amp;&amp; rm myfile.safe</strong></pre>

<p>As another example, if you use the version-control system Git<a data-type="indexterm" data-primary="Git" id="idm46586639853120"/> to
maintain files, you’re probably familiar with the following sequence
of commands after you change some files: run <code>git add</code><a data-type="indexterm" data-primary="Git" data-secondary="git commands" id="idm46586639851952"/> to prepare
files for a commit, then <code>git commit</code>, and finally <code>git push</code> to share
your committed changes. If any of these commands failed, you wouldn’t
run the rest (until you fixed the cause of the failure). Therefore,
these three commands work well as a conditional list:</p>

<pre data-type="programlisting">$ <strong>git add . &amp;&amp; git commit -m"fixed a bug" &amp;&amp; git push</strong></pre>

<p>Just as the <code>&amp;&amp;</code> operator runs a second command only if the first
succeeds, the related operator <code>||</code><a data-type="indexterm" data-primary="|| for conditional list" data-seealso="conditional lists" id="idm46586639847440"/><a data-type="indexterm" data-primary="vertical bar (|)" data-secondary="|| for conditional list" data-seealso="conditional lists" id="idm46586639846464"/> (pronounced “or”) runs a second
command only if the first fails. For example, the following command
tries to enter <em>dir</em>, and if it fails to do so, it creates
<em>dir</em>:<sup><a data-type="noteref" id="idm46586639844176-marker" href="ch07.xhtml#idm46586639844176">1</a></sup></p>

<pre data-type="programlisting">$ <strong>cd dir || mkdir dir</strong></pre>

<p>You’ll commonly see the <code>||</code> operator in scripts, causing the script
to exit if an error occurs:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="c1"># If a directory can't be entered, exit with an error code of 1</code>
<code class="nb">cd</code> dir <code class="o">||</code> <code class="nb">exit</code> <code class="m">1</code></pre>

<p>Combine the <code>&amp;&amp;</code> and <code>||</code> operators to set up more complicated actions
for success and failure. The following command tries to enter
directory <em>dir</em>, and if it fails, it creates the directory and
enters it. If all fails, the command prints a failure message:</p>

<pre data-type="programlisting">$ <strong>cd dir || mkdir dir &amp;&amp; cd dir || echo "I failed"</strong></pre>

<p>The commands in a conditional list don’t have to be simple commands;
they can also be pipelines and other combined commands.</p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_exit_codes">
<h5>Exit Codes Indicate Success or Failure</h5>
<p>What<a data-type="indexterm" data-primary="exit code" id="idm46586639805056"/><a data-type="indexterm" data-primary="command" data-secondary="exit code" id="idm46586639837712"/> does it mean for a Linux command to succeed or fail? Every Linux
command produces a result when it terminates, called an <em>exit code</em>. By
convention, an exit code of zero means success and any nonzero value
means failure.<sup><a data-type="noteref" id="idm46586639836000-marker" href="ch07.xhtml#idm46586639836000">2</a></sup> View the exit code of a
shell’s most recently completed command by printing the special shell variable
whose name is a question mark (<code>?</code>):<a data-type="indexterm" data-primary="$? for exit code" id="idm46586639834656"/><a data-type="indexterm" data-primary="dollar sign ($)" data-secondary="$? for exit code" id="idm46586639833920"/></p>

<pre data-type="programlisting">$ <strong>ls myfile.txt</strong>
myfile.txt
$ <strong>echo $?</strong>                          <em>Print the value of the ? variable</em>
0                                  <em>ls succeeded</em>
$ <strong>cp nonexistent.txt somewhere.txt</strong>
cp: cannot stat 'nonexistent.txt': No such file or directory
$ <strong>echo $?</strong>
1                                  <em>cp failed</em></pre>
</div></aside>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Technique #2: Unconditional Lists"><div class="sect2" id="idm46586639874320">
<h2>Technique #2: Unconditional Lists</h2>

<p><a data-type="indexterm" data-primary="unconditional lists" id="idm46586639828528"/><a data-type="indexterm" data-primary="list of commands" data-secondary="unconditional list" id="idm46586639827824"/><a data-type="indexterm" data-primary="running commands" data-secondary="unconditional lists" id="idm46586639826880"/>
Commands in a list don’t have to depend on one another. If you
separate the commands with semicolons,<a data-type="indexterm" data-primary="; (semicolon) for unconditional list" data-seealso="unconditional lists" id="idm46586639825680"/><a data-type="indexterm" data-primary="semicolon (;) for unconditional list" data-seealso="unconditional lists" id="idm46586639794336"/>
they simply run in order. Success or failure of a
command does not affect later ones in the list.</p>

<p>I like unconditional lists for launching ad hoc commands after I’ve
left work for the day. Here’s one that sleeps (does nothing)<a data-type="indexterm" data-primary="sleep command" id="idm46586639792640"/> for two
hours (7,200 seconds) and then backs up my important files:</p>

<pre data-type="programlisting">$ <strong>sleep 7200; cp -a ~/important-files /mnt/backup_drive</strong></pre>

<p>Here’s a similar command that functions as a primitive reminder<a data-type="indexterm" data-primary="reminders, sending" id="idm46586639790448"/>
system, sleeping for five minutes and then sending me an
email:<sup><a data-type="noteref" id="idm46586639789616-marker" href="ch07.xhtml#idm46586639789616">3</a></sup><a data-type="indexterm" data-primary="mail command" id="idm46586639786720"/></p>

<pre data-type="programlisting">$ <strong>sleep 300; echo "remember to walk the dog" | mail -s reminder $USER</strong></pre>

<p>Unconditional lists are a convenience feature: they produce the same
results (mostly) as typing the commands individually and pressing
Enter after each. The only significant difference relates to exit
codes. In an unconditional list, the exit codes<a data-type="indexterm" data-primary="exit code" data-secondary="unconditional list" id="idm46586639784448"/><a data-type="indexterm" data-primary="unconditional lists" data-secondary="exit code" id="idm46586639783472"/> of the individual
commands are thrown away except the last one. Only the exit code of
the last command run in the list is assigned to the shell variable <code>?</code>:</p>

<pre data-type="programlisting">$ <strong>mv file1 file2; mv file2 file3; mv file3 file4</strong>
$ <strong>echo $?</strong>
0                           <em>The exit code for "mv file3 file4"</em></pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Substitution Techniques"><div class="sect1" id="idm46586639779600">
<h1>Substitution Techniques</h1>

<p><em>Substitution</em> means automatically replacing the text of a command with
other text. I’ll show you two types with powerful possibilities:</p>
<dl>
<dt>Command substitution</dt>
<dd>
<p>A command is replaced by its output.</p>
</dd>
<dt>Process substitution</dt>
<dd>
<p>A command is replaced by a file (sort of).</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Technique #3: Command Substitution"><div class="sect2" id="section_cmd_sub">
<h2>Technique #3: Command Substitution</h2>

<p><a data-type="indexterm" data-primary="command substitution" id="commandsubstitution"/><a data-type="indexterm" data-primary="substitution" data-secondary="command" data-see="command substitution" id="idm46586639771264"/><a data-type="indexterm" data-primary="running commands" data-secondary="command substitution" id="cmdsub2"/>
Suppose you have a few thousand text files representing songs. Each file
includes a song title, artist name, album title, and the song lyrics:</p>

<pre data-type="programlisting">Title: Carry On Wayward Son
Artist: Kansas
Album: Leftoverture

Carry on my wayward son
There'll be peace when you are done
⋮</pre>

<p>You’d like to organize the files into subdirectories by artist. To
perform this task by hand, you could search for all song files by
Kansas using <code>grep</code>:</p>

<pre data-type="programlisting">$ <strong>grep -l "Artist: Kansas" *.txt</strong>
carry_on_wayward_son.txt
dust_in_the_wind.txt
belexes.txt</pre>

<p>and then move each file to a directory <em>kansas</em>:</p>

<pre data-type="programlisting">$ <strong>mkdir kansas</strong>
$ <strong>mv carry_on_wayward_son.txt kansas</strong>
$ <strong>mv dust_in_the_wind.txt kansas</strong>
$ <strong>mv belexes.txt kansas</strong></pre>

<p>Tedious, right? Wouldn’t be great if you could tell the shell, “Move
all files that contain the string <em>Artist: Kansas</em> to the directory
<em>kansas</em>.”  In Linux terms, you’d like to take the list of names from
the preceding <code>grep -l</code> command and hand it to <code>mv</code>. Well, you can do
this easily with the help of a shell feature called <em>command
substitution</em>:<a data-type="indexterm" data-primary="$() for command substitution" data-seealso="command substitution" id="idm46586639759392"/><a data-type="indexterm" data-primary="dollar sign ($)" data-secondary="$() for command substitution" data-seealso="command substitution" id="idm46586639758320"/></p>
<pre data-type="programlisting">$ <strong>mv <mark class="box">$(grep -l "Artist: Kansas" *.txt)</mark> kansas</strong></pre>

<p>The syntax:</p>

<pre data-type="programlisting">$(<em>any command here</em>)</pre>

<p>executes the command inside the parentheses and replaces the command
by its output. So on the preceding command line, the <code>grep -l</code> command
is replaced by the list of filenames that it prints, as if you had
typed the filenames like this:</p>
<pre data-type="programlisting">$ <strong>mv <mark class="box">carry_on_wayward_son.txt dust_in_the_wind.txt belexes.txt</mark> kansas</strong></pre>

<p>Whenever you find yourself copying the output of one command into a
later command line, you can usually save time with command
substitution. You can even include aliases in command substitution,
because its contents are run in a subshell,<a data-type="indexterm" data-primary="subshell" data-secondary="command substitution" id="idm46586639750496"/> which includes copies of
its parent’s aliases.</p>
<div data-type="warning" epub:type="warning" id="warn_command_substitution"><h1>Special Characters and Command Substitution</h1>
<p>The preceding example with <code>grep -l</code> works<a data-type="indexterm" data-primary="command substitution" data-secondary="special characters in filenames" id="idm46586639746896"/><a data-type="indexterm" data-primary="filenames" data-secondary="special characters in" id="idm46586639745856"/><a data-type="indexterm" data-primary="whitespace" data-secondary="filenames containing" id="idm46586639744880"/> great for most Linux
filenames, but not for filenames that contain spaces or other
special characters. The shell evaluates these characters before the
output is handed to <code>mv</code>, potentially producing unexpected
results. For example, if <code>grep -l</code> printed <em>dust in the wind.txt</em>, the
shell would treat the spaces as separators, and <code>mv</code> would attempt to
move four nonexistent files named <em>dust</em>, <em>in</em>, <em>the</em>, and <em>wind.txt</em>.</p>
</div>

<p>Here’s another example. Suppose you have several years’ worth of bank
statements downloaded in PDF format<a data-type="indexterm" data-primary="PDF format" id="idm46586639739568"/>. The downloaded files have names
that include the statement’s year, month, and day, such as
<em>eStmt_2021-08-26.pdf</em> for the date August 26, 2021.<sup><a data-type="noteref" id="idm46586639738208-marker" href="ch07.xhtml#idm46586639738208">4</a></sup> You’d like to view the
most recent statement in the current directory. You could do it
manually: list the directory, locate the file with the most recent
date (which will be the final file in the listing), and display it
with a Linux PDF viewer such as <code>okular</code>.<a data-type="indexterm" data-primary="okular command" id="idm46586639736864"/><a data-type="indexterm" data-primary="PDF viewer okular" id="idm46586639736128"/> But why do all that manual
work? Let command substitution ease your way. Create a command that
prints the name of the latest PDF file in the directory:<a data-type="indexterm" data-primary="tail command" data-secondary="examples" id="idm46586639735328"/></p>

<pre data-type="programlisting">$ <strong>ls eStmt*pdf | tail -n1</strong></pre>

<p>and provide it to <code>okular</code> using command substitution:</p>

<pre data-type="programlisting">$ <strong>okular $(ls eStmt*pdf | tail -n1)</strong></pre>

<p>The <code>ls</code> command lists all the statement files, and <code>tail</code> prints only
the last one, such as <em>eStmt_2021-08-26.pdf</em>. Command substitution
places that single filename right onto the command line, as if you’d
typed <code>okular eStmt_2021-08-26.pdf</code>.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>The original syntax for command substitution was backquotes (backticks).<a data-type="indexterm" data-primary="backquote (`)" id="idm46586639728224"/><a data-type="indexterm" data-primary="` (backquote)" id="idm46586639727520"/><a data-type="indexterm" data-primary="backtick (`)" id="idm46586639726848"/>
The following two commands are equivalent:<a data-type="indexterm" data-primary="date command" data-secondary="examples" id="idm46586639725984"/></p>
<pre data-type="programlisting">$ <strong>echo Today is $(date +%A).</strong>
Today is Saturday.
$ <strong>echo Today is `date +%A`.</strong>
Today is Saturday.</pre>

<p>Backticks are supported by most shells. The <code>$()</code> syntax is simpler
to nest, however:<a data-type="indexterm" data-primary="command substitution" data-secondary="nesting" id="idm46586639722480"/></p>
<pre data-type="programlisting">$ <strong>echo $(date +%A) | tr a-z A-Z</strong>                    <em>Single</em>
SATURDAY
<strong>echo Today is $(<mark class="box">echo $(date +%A) | tr a-z A-Z</mark>)!</strong>   <em>Nested</em>
Today is SATURDAY!</pre>
</div>

<p>In scripts, a common use of command substitution is to store the<a data-type="indexterm" data-primary="variables" data-secondary="storing command output" id="idm46586639717728"/><a data-type="indexterm" data-primary="command substitution" data-secondary="assigning output to variable" id="idm46586639716672"/><a data-type="indexterm" data-primary="output redirection" data-secondary="variable holding output" id="idm46586639715664"/>
output of a command in a variable:</p>

<pre data-type="programlisting"><em>VariableName</em>=$(<em>some command here</em>)</pre>

<p>For example, to get the filenames containing Kansas songs and store them
in a variable, use command substitution like so:</p>

<pre data-type="programlisting">$ <strong>kansasFiles=$(grep -l "Artist: Kansas" *.txt) </strong></pre>

<p>The output might have multiple lines, so to preserve any newline characters,
make sure you quote the value wherever you use it:<a data-type="indexterm" data-primary="quoting" data-secondary="preserving newlines" id="idm46586639711008"/><a data-type="indexterm" data-primary="newline character" data-secondary="preserving in output" id="idm46586639710032"/><a data-type="indexterm" data-startref="commandsubstitution" id="idm46586639709088"/><a data-type="indexterm" data-startref="cmdsub2" id="idm46586639708416"/></p>

<pre data-type="programlisting">$ <strong>echo "$kansasFiles"</strong></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Technique #4: Process Substitution"><div class="sect2" id="section_process_substitution">
<h2>Technique #4: Process Substitution</h2>

<p><a data-type="indexterm" data-primary="running commands" data-secondary="process substitution" id="procsub2"/><a data-type="indexterm" data-primary="process substitution" id="processsubstitution"/><a data-type="indexterm" data-primary="substitution" data-secondary="process" data-see="process substitution" id="idm46586639702816"/>
Command substitution, which you just saw, replaces a command with its
output in place, as a string.  <em>Process substitution</em> also replaces a
command with its output, but it treats the output as if it were stored
in a file. This powerful difference may look confusing at first, so
I’ll explain it step-by-step.</p>

<p>Suppose you’re in a directory of JPEG image files named <em>1.jpg</em>
through <em>1000.jpg</em>, but some files are mysteriously missing <a data-type="indexterm" data-primary="missing filenames in a sequence" id="idm46586639699328"/><a data-type="indexterm" data-primary="filenames" data-secondary="missing in a sequence" id="idm46586639698608"/><a data-type="indexterm" data-primary="sequence of" data-secondary="filenames" id="idm46586639697664"/> and you
want to identify them. Produce such a directory with the following
commands:<a data-type="indexterm" data-primary="touch command" data-secondary="examples" id="idm46586639696592"/><a data-type="indexterm" data-primary="conditional lists" data-secondary="examples" id="idm46586639695648"/><a data-type="indexterm" data-primary="brace expansion" data-secondary="examples" id="idm46586639694704"/></p>

<pre data-type="programlisting">$ <strong>mkdir /tmp/jpegs &amp;&amp; cd /tmp/jpegs</strong>
$ <strong>touch {1..1000}.jpg</strong>
$ <strong>rm 4.jpg 981.jpg</strong></pre>

<p>A poor way to locate the missing files is to list the directory,
sorted<a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586639691664"/> numerically, and look for gaps by eye:</p>

<pre data-type="programlisting">$ <strong>ls -1 | sort -n | less</strong>
1.jpg
2.jpg
3.jpg
5.jpg            <em>4.jpg is missing</em>
⋮</pre>

<p>A more robust, automated solution is to compare the existing filenames
to a complete list of names from <em>1.jpg</em> to <em>1000.jpg</em>, using the
<code>diff</code><a data-type="indexterm" data-primary="diff command" data-secondary="examples" id="idm46586639687104"/> command. One way to achieve this solution is with temporary
files.  Store the existing filenames, sorted, in one temporary file,
<em>original-list</em>:</p>

<pre data-type="programlisting">$ <strong>ls *.jpg | sort -n &gt; /tmp/original-list</strong></pre>

<p>Then print a complete list of filenames from <em>1.jpg</em> to <em>1000.jpg</em> to
another temporary file, <em>full-list</em>, by generating the integers 1 to
1000 with <code>seq</code>,<a data-type="indexterm" data-primary="seq command" data-secondary="examples" id="idm46586639681952"/> and appending “.jpg” to each line with <code>sed</code>:</p>

<pre data-type="programlisting">$ <strong>seq 1 1000 | sed 's/$/.jpg/' &gt; /tmp/full-list</strong></pre>

<p>Compare the two temporary files with the <code>diff</code> command to discover that <em>4.jpg</em> and <em>981.jpg</em>
are missing, then delete the temporary files:</p>

<pre data-type="programlisting">$ <strong>diff /tmp/original-list /tmp/full-list</strong>
3a4
&gt; 4.jpg
979a981
&gt; 981.jpg
$ <strong>rm /tmp/original-list /tmp/full-list</strong>       <em>Clean up afterwards</em></pre>

<p>That’s a lot of steps. Wouldn’t it be grand to compare the two lists
of names directly and not bother with temporary files? The challenge
is that <code>diff</code> can’t compare two lists from stdin; it requires files
as arguments.<sup><a data-type="noteref" id="idm46586639674432-marker" href="ch07.xhtml#idm46586639674432">5</a></sup> Process
substitution solves the problem. It makes both lists appear to <code>diff</code>
as files. (The sidebar <a data-type="xref" href="#sidebar_process_substitution">“How Process Substitution Works”</a> provides the
technical details.) The syntax:<a data-type="indexterm" data-primary="&lt;() for process substitution" data-seealso="process substitution" id="idm46586639671872"/><a data-type="indexterm" data-primary="less than (&lt;)" data-secondary="&lt;() for process substitution" data-seealso="process substitution" id="idm46586639670912"/></p>

<pre data-type="programlisting">&lt;(<em>any command here</em>)</pre>

<p>runs the command in a subshell<a data-type="indexterm" data-primary="subshell" data-secondary="process substitution" id="idm46586639668192"/> and presents its
output as if it were contained in a file. For example, the following
expression represents the output of <code>ls -1 | sort -n</code> as if it were
contained in a file:</p>

<pre data-type="programlisting">&lt;(ls -1 | sort -n)</pre>

<p>You can <code>cat</code> the file:</p>

<pre data-type="programlisting">$ <strong>cat &lt;(ls -1 | sort -n)</strong>
1.jpg
2.jpg
⋮</pre>

<p>You can copy the file with <code>cp</code>:</p>

<pre data-type="programlisting">$ <strong>cp &lt;(ls -1 | sort -n) /tmp/listing</strong>
$ <strong>cat /tmp/listing</strong>
1.jpg
2.jpg
⋮</pre>

<p>and as you’ll now see, you can <code>diff</code> the file against another. Begin
with the two commands that generated your two temporary files:</p>

<pre data-type="programlisting">ls *.jpg | sort -n
seq 1 1000 | sed 's/$/.jpg/'</pre>

<p>Apply process substitution so <code>diff</code> can treat them as files, and you
get the same output as before, but without using temporary files:</p>
<pre data-type="programlisting">$ <strong>diff &lt;(<mark class="box">ls *.jpg | sort -n</mark>) &lt;(<mark class="box">seq 1 1000 | sed 's/$/.jpg/'</mark>)</strong>
3a4
&gt; 4.jpg
979a981
&gt; 981.jpg</pre>

<p>Clean up the output by grepping for lines beginning with <code>&gt;</code> and
stripping off the first two characters with <code>cut</code>, and you have your
missing files report:</p>

<pre data-type="programlisting">$ <strong>diff &lt;(ls *.jpg | sort -n) &lt;(seq 1 1000 | sed 's/$/.jpg/') \
    | grep '&gt;' \
    | cut -c3-</strong>
4.jpg
981.jpg</pre>

<p>Process substitution transformed how I use the command line. Commands
that read only from disk files suddenly could read from stdin. With
practice, commands that previously seemed impossible became easy.</p>
<aside data-type="sidebar" epub:type="sidebar" class="nobreakinside"><div class="sidebar" id="sidebar_process_substitution">
<h5>How Process Substitution Works</h5>
<p>When<a data-type="indexterm" data-primary="process substitution" data-secondary="internals" id="idm46586639650144"/> the Linux operating system opens a disk file, it represents that
file with an integer called a <em>file descriptor</em>.<a data-type="indexterm" data-primary="file" data-secondary="descriptor" id="idm46586639648512"/> Process substitution
mimicks a file by running a command and associating its output with a
file descriptor, so the output appears to be in a disk file from the
perspective of programs that access it. You can view the file
descriptor with <code>echo</code>:<a data-type="indexterm" data-primary="echo command" data-secondary="file descriptor viewing" id="idm46586639646736"/></p>

<pre data-type="programlisting">$ <strong>echo &lt;(ls)</strong>
/dev/fd/63</pre>

<p>In this case, the file descriptor for <code>&lt;(ls)</code> is 63, and it’s
tracked in the system directory <em>/dev/fd</em>.</p>

<p>Fun fact: stdin, stdout, and stderr are represented by the file
descriptors 0, 1, and 2, respectively.<a data-type="indexterm" data-primary="stdin" data-secondary="file descriptor" id="idm46586639642672"/><a data-type="indexterm" data-primary="stdout" data-secondary="file descriptor" id="idm46586639641696"/><a data-type="indexterm" data-primary="stderr" data-secondary="file descriptor" id="idm46586639640752"/> That’s why redirection of stderr
has the syntax <code>2&gt;</code>.<a data-type="indexterm" data-primary="2&gt; to redirect stderr" data-secondary="meaning" id="idm46586639639232"/><a data-type="indexterm" data-primary="stderr" data-secondary="redirection" id="idm46586639638224"/><a data-type="indexterm" data-primary="redirection" id="idm46586639637280"/></p>

<p>The expression <code>&lt;(…)</code> creates a file descriptor for reading. The
related expression <code>&gt;(…)</code> creates a file descriptor for writing, but
in 25 years I’ve never needed it.</p>

<p>Process substitution is a non-POSIX<a data-type="indexterm" data-primary="POSIX standard" id="idm46586639634816"/> feature that might be disabled in
your shell. To enable non-POSIX features in your current shell, run<a data-type="indexterm" data-startref="processsubstitution" id="idm46586639633872"/><a data-type="indexterm" data-startref="procsub2" id="idm46586639633200"/>
<code>set +o posix</code>.<a data-type="indexterm" data-primary="set command" id="idm46586639631984"/></p>
</div></aside>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Command-as-String Techniques"><div class="sect1" id="idm46586639705856">
<h1>Command-as-String Techniques</h1>

<p>Every command is a string, but some commands are more “stringy” than<a data-type="indexterm" data-primary="strings" data-secondary="commands as" id="cmdasstr"/>
others. I’ll show you several techniques that construct a string,
piece by piece, and then run the string as a command:</p>

<ul>
<li>
<p>Passing a command to <code>bash</code> as an argument</p>
</li>
<li>
<p>Piping commands to <code>bash</code> on stdin</p>
</li>
<li>
<p>Sending commands to another host with <code>ssh</code></p>
</li>
<li>
<p>Running a sequence of commands with <code>xargs</code></p>
</li>
</ul>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>The following techniques can be risky because they send unseen text
to a shell for execution. Never do this blindly. Always understand the
text (and trust its origin) before executing it. You don’t want to
execute the string <code>"rm -rf $HOME"</code> by mistake and wipe out all your files.</p>
</div>








<section data-type="sect2" data-pdf-bookmark="Technique #5: Passing a Command as an Argument to bash"><div class="sect2" id="idm46586639621184">
<h2>Technique #5: Passing a Command as an Argument to bash</h2>

<p><a data-type="indexterm" data-primary="bash" data-secondary="passing a command as an argument (-c option)" id="idm46586639619616"/><a data-type="indexterm" data-primary="running commands" data-secondary="command as argument to bash" id="idm46586639618320"/>
<code>bash</code> is a normal command like any other, as explained in
<a data-type="xref" href="ch06.xhtml#section_shell_executable">“Shells Are Executable Files”</a>, so you can run it by name on the
command line.  By default, running <code>bash</code> launches an interactive
shell for typing and executing commands, as you’ve
seen. Alternatively, you can pass a command to  <code>bash</code> as a string,
via the <code>-c</code> option, and <code>bash</code> will run that string as a command
and exit:</p>

<pre data-type="programlisting">$ <strong>bash -c "ls -l"</strong>
-rw-r--r-- 1 smith smith 325 Jul  3 17:44 animals.txt</pre>

<p>Why is this helpful? Because the new <code>bash</code> process is a child with
its own environment, including a current directory, variables with
values, and so on. Any changes to the child shell won’t affect your
currently running shell. Here’s a <code>bash -c</code> command that changes
directory to <em>/tmp</em> just long enough to delete a file, then exits:</p>

<pre data-type="programlisting">$ <strong>pwd</strong>
/home/smith
$ <strong>touch /tmp/badfile</strong>                           <em>Create a temporary file</em>
$ <strong>bash -c "cd /tmp &amp;&amp; rm badfile"</strong>
$ <strong>pwd</strong>
/home/smith                                    <em>Current directory is unchanged</em></pre>

<p>The most instructive and beautiful use of <code>bash -c</code>, however, arises
when you run certain commands as the superuser. Specifically, the
combination of <code>sudo</code><a data-type="indexterm" data-primary="sudo command" data-secondary="redirection" id="idm46586639606512"/><a data-type="indexterm" data-primary="redirection" data-secondary="sudo command" id="idm46586639605536"/> and input/output redirection produces an
interesting (sometimes maddening) situation in which <code>bash -c</code> is the
key to success.</p>

<p>Suppose you want to create a log file in the system directory
<em>/var/log</em>, which is not writable by ordinary users. You run the
following <code>sudo</code> command to gain superuser privileges and create the
log file, but it mysteriously fails:<a data-type="indexterm" data-primary="output redirection" data-secondary="in protected directory" id="idm46586639602416"/></p>

<pre data-type="programlisting">$ <strong>sudo echo "New log file" &gt; /var/log/custom.log</strong>
bash: /var/log/custom.log: Permission denied</pre>

<p>Wait a minute—<code>sudo</code> should give you permission to create any file
anywhere. How can this command possibly fail? Why didn’t <code>sudo</code> even
prompt you for a password? The answer is: because <code>sudo</code> didn’t run.
You applied <code>sudo</code> to the <code>echo</code> command but not to the output
redirection, which ran first and failed. In detail:</p>
<ol>
<li>
<p>You pressed Enter.</p>
</li>
<li>
<p>The shell began to evaluate the whole command, including redirection (<code>&gt;</code>).</p>
</li>
<li>
<p>The shell tried to create the file <em>custom.log</em> in a protected directory,
<em>/var/log</em>.</p>
</li>
<li>
<p>You didn’t have permission to write to <em>/var/log</em>, so the shell gave up
and printed the “Permission denied” message.</p>
</li>

</ol>

<p>That’s why <code>sudo</code> never ran. To solve this problem, you need to tell
the shell, “Run the entire command, including output redirection, as the
superuser.” This is exactly the kind of situation that <code>bash -c</code>
solves so well.  Construct the command you want to run, as a string:</p>

<pre data-type="programlisting">'echo "New log file" &gt; /var/log/custom.log'</pre>

<p>and pass it as an argument to <code>sudo bash -c</code>:</p>

<pre data-type="programlisting">$ <strong>sudo bash -c 'echo "New log file" &gt; /var/log/custom.log'</strong>
[sudo] password for smith: <strong>xxxxxxxx</strong>
$ <strong>cat /var/log/custom.log</strong>
New log file</pre>

<p>This time, you’ve run <code>bash</code>, not just <code>echo</code>, as the superuser, and
<code>bash</code> executes the entire string as a command. The redirection succeeds.
Remember this technique whenever you pair <code>sudo</code> with redirection.<a data-type="indexterm" data-startref="cmdasstr" id="idm46586639583904"/></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Technique #6: Piping a Command to bash"><div class="sect2" id="idm46586639620560">
<h2>Technique #6: Piping a Command to bash</h2>

<p><a data-type="indexterm" data-primary="bash" data-secondary="piping commands to" id="idm46586639581344"/><a data-type="indexterm" data-primary="pipes" data-secondary="piping commands to bash" id="idm46586639580144"/><a data-type="indexterm" data-primary="shell" data-secondary="piping commands to" id="idm46586639579200"/><a data-type="indexterm" data-primary="running commands" data-secondary="piping to bash" id="idm46586639578256"/>
The shell reads every command that you type on stdin. That means
<code>bash</code> the program can participate in pipelines. For example, print
the string <code>"ls -l"</code> and pipe it to <code>bash</code>, and <code>bash</code> will treat the
string as a command and run it:</p>

<pre data-type="programlisting">$ <strong>echo "ls -l"</strong>
ls -l
$ <strong>echo "ls -l" | bash</strong>
-rw-r--r-- 1 smith smith 325 Jul  3 17:44 animals.txt</pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Remember, never blindly pipe text to <code>bash</code>. Be aware of what you’re
executing.</p>
</div>

<p>This technique is terrific when you need to run many similar commands
in a row.<a data-type="indexterm" data-primary="running commands" data-secondary="many similar in a row" id="idm46586639571632"/> If you can print the commands as strings, then you can pipe
the strings to <code>bash</code> for execution. Suppose you’re in a directory
with many files, and you want to organize them into subdirectories by
their first character. A file named <em>apple</em> would be moved to
subdirectory <em>a</em>, a file named <em>cantaloupe</em> would move to subdirectory
<em>c</em>, and so on.<sup><a data-type="noteref" id="idm46586639568448-marker" href="ch07.xhtml#idm46586639568448">6</a></sup>  (For simplicity, we’ll assume all the
filenames begin with a lowercase letter and contain no spaces or
special characters.)</p>

<p>First, list the files, sorted. We’ll assume all the names are at least
two characters long (matching the pattern <code>??*</code>) so our commands don’t
collide with the subdirectories <em>a</em> through <em>z</em>:</p>

<pre data-type="programlisting">$ <strong>ls -1 ??* </strong>
apple
banana
cantaloupe
carrot
⋮</pre>

<p>Create the 26 subdirectories you need via brace expansion:<a data-type="indexterm" data-primary="brace expansion" data-secondary="examples" id="idm46586639563904"/></p>

<pre data-type="programlisting">$ <strong>mkdir {a..z}</strong></pre>

<p>Now generate the <code>mv</code> commands you’ll need, as strings. Start with a
regular expression for <code>sed</code> that captures the first character of the
filename as expression #1 (<code>\1</code>):</p>

<pre data-type="programlisting">^\(.\)</pre>

<p>Capture the rest of the filename as expression #2 (<code>\2</code>):</p>

<pre data-type="programlisting">\(.*\)$</pre>

<p>Connect the two regular expressions:</p>
<pre data-type="programlisting"><mark class="box">^\(.\)</mark><mark class="box">\(.*\)$</mark></pre>

<p>Now form an <code>mv</code> command with the word <em>mv</em> followed by a space, the
full filename (<code>\1\2</code>), another space, and the first character (<code>\1</code>):</p>

<pre data-type="programlisting">mv \1\2 \1</pre>

<p>The complete command generator is:</p>
<pre data-type="programlisting">$ <strong>ls -1 ??* | sed 's/^\(.\)\(.*\)$/mv \1\2 \1/'</strong>
mv apple a
mv banana b
mv cantaloupe c
mv carrot c
⋮</pre>

<p>Its output contains exactly the <code>mv</code> commands you need. Read the
output to convince yourself it’s correct, perhaps by piping it to
<code>less</code> for page-by-page viewing:</p>
<pre data-type="programlisting">$ <strong>ls -1 ??* | sed 's/^\(.\)\(.*\)$/mv \1\2\t\1/' | less</strong></pre>

<p>When you’re satisfied that your generated commands are correct, pipe
the output to <code>bash</code> for execution:</p>
<pre data-type="programlisting">$ <strong>ls -1 ??* | sed 's/^\(.\)\(.*\)$/mv \1\2\t\1/' | bash</strong></pre>

<p class="pagebreak-before">The steps you just completed are a repeatable pattern:</p>
<ol>
<li>
<p>Print a sequence of commands by manipulating strings.</p>
</li>
<li>
<p>View the results with <code>less</code> to check correctness.</p>
</li>
<li>
<p>Pipe the results to <code>bash</code>.</p>
</li>

</ol>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Technique #7: Executing a String Remotely with ssh"><div class="sect2" id="idm46586639582256">
<h2>Technique #7: Executing a String Remotely with ssh</h2>

<p><a data-type="indexterm" data-primary="SSH" data-secondary="ssh command" data-tertiary="executing remote commands" id="idm46586639540064"/><a data-type="indexterm" data-primary="running commands" data-secondary="ssh to execute remotely" id="idm46586639538752"/>
<em>Disclaimer</em>: this technique will make sense only if you’re familiar
with SSH, the secure shell, for logging into remote hosts. Setting up
SSH relationships between hosts is beyond the scope of this book; to
learn more about it, seek out an SSH 
<span class="keep-together">tutorial.</span></p>

<p>In addition to the usual way of logging into a remote host:</p>

<pre data-type="programlisting">$ <strong>ssh myhost.example.com</strong></pre>

<p>you also can execute a single command on the remote host—by passing
a string to <code>ssh</code> on the command line. Simply append the string to the
rest of the <code>ssh</code> command line:</p>

<pre data-type="programlisting">$ <strong>ssh myhost.example.com ls</strong>
remotefile1
remotefile2
remotefile3</pre>

<p>This technique is generally quicker than logging in, running a
command, and logging out. If the command includes special characters,
such as redirection symbols, that need to be evaluated on the remote
host, then quote or escape them. Otherwise, they’ll be evaluated by
your local shell. Both of the following commands run <code>ls</code> remotely,
but the output redirection occurs on different hosts:</p>

<pre data-type="programlisting">$ <strong>ssh myhost.example.com ls &gt; outfile</strong>       <em>Creates outfile on local host</em>
$ <strong>ssh myhost.example.com "ls &gt; outfile"</strong>     <em>Creates outfile on remote host</em></pre>

<p>You can also pipe commands to <code>ssh</code> to run them on the remote host,
much like you pipe them to <code>bash</code> to run locally:</p>

<pre data-type="programlisting">$ <strong>echo "ls &gt; outfile" | ssh myhost.example.com</strong></pre>

<p>When piping commands to <code>ssh</code>, the remote host might print diagnostic
or other messages. These generally do not affect the remote command,
and you can suppress them:</p>

<ul class="nobreakinside">
<li>
<p>If you see messages about pseudo-terminals or pseudo-ttys,<a data-type="indexterm" data-primary="pseudo-terminal" id="idm46586639524288"/><a data-type="indexterm" data-primary="terminal (tty)" data-secondary="pseudo-terminal" id="idm46586639523504"/> such as
“Pseudo-terminal will not be allocated because stdin is not a
terminal,” run <code>ssh</code> with the <code>-T</code><a data-type="indexterm" data-primary="SSH" data-secondary="ssh command" data-tertiary="terminal allocation (-T option)" id="idm46586639521520"/><a data-type="indexterm" data-primary="terminal (tty)" data-secondary="SSH allocation" id="idm46586639520208"/> option to prevent the remote SSH
server from allocating a terminal:</p>

<pre data-type="programlisting">$ <strong>echo "ls &gt; outfile" | ssh -T myhost.example.com</strong></pre>
</li>
<li>
<p>If you see welcome messages that normally appear when you log
in (“Welcome to Linux!”) or other unwanted messages, try telling <code>ssh</code>
explicitly to run <code>bash</code> on the remote host, and the messages should
disappear:</p>

<pre data-type="programlisting">$ <strong>echo "ls &gt; outfile" | ssh myhost.example.com bash</strong></pre>
</li>
</ul>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Technique #8: Running a List of Commands with xargs"><div class="sect2" id="idm46586639514528">
<h2>Technique #8: Running a List of Commands with xargs</h2>

<p><a data-type="indexterm" data-primary="xargs command" id="idm46586639512672"/><a data-type="indexterm" data-primary="list of commands" data-secondary="xargs execution" id="idm46586639511968"/><a data-type="indexterm" data-primary="running commands" data-secondary="xargs running a list" id="idm46586639511024"/>
Many Linux users have never heard of the command <code>xargs</code>, but it’s a
powerful tool for constructing and running multiple, similar commands.
Learning <code>xargs</code> was another transformative moment in my Linux
education, and I hope yours as well.</p>

<p><code>xargs</code> accepts two inputs:</p>

<ul>
<li>
<p>On stdin: A list of strings separated by whitespace. An example is
file paths produced by <code>ls</code> or <code>find</code>, but any strings will do. I’ll
call them the <em>input strings</em>.<a data-type="indexterm" data-primary="input strings, xargs" id="idm46586639505632"/></p>
</li>
<li>
<p>On the command line: An incomplete command that’s missing some arguments, which I’ll call the <em>command template</em>.<a data-type="indexterm" data-primary="command" data-secondary="template, xargs" id="idm46586639503536"/></p>
</li>
</ul>

<p><code>xargs</code> merges the input strings and the command template to produce
and run new, complete commands, which I’ll call the <em>generated
commands</em>.<a data-type="indexterm" data-primary="generated commands, xargs" id="idm46586639501056"/> I’ll demonstrate this process with a toy example. Suppose
you’re in a directory with three files:</p>

<pre data-type="programlisting">$ <strong>ls -1</strong>
apple
banana
cantaloupe</pre>

<p>Pipe the directory listing to <code>xargs</code> to serve as its input strings,
and provide <code>wc -l</code> to serve as the command template, like so:</p>

<pre data-type="programlisting">$ <strong>ls -1 | xargs wc -l</strong>
3 apple
4 banana
1 cantaloupe
8 total</pre>

<p>As promised, <code>xargs</code> applied the <code>wc -l</code> command template to
the input strings and counts lines in each file. To print the same
three files with <code>cat</code>, simply change the command template to “cat”:</p>

<pre data-type="programlisting">$ <strong>ls -1 | xargs cat</strong></pre>

<p>My toy examples with <code>xargs</code> have two shortcomings, one fatal and one
practical.  The fatal shortcoming is that <code>xargs</code> may do the wrong
thing if an input string contains special characters, such as
spaces. A robust solution is in the sidebar <a data-type="xref" href="#sidebar_find_xargs">“Safety with find and xargs”</a>.</p>

<p>The practical shortcoming is that you don’t need <code>xargs</code> here—you
can accomplish the same tasks more simply with file pattern matching:<a data-type="indexterm" data-primary="xargs command" data-secondary="filename pattern matching versus" id="idm46586639490272"/></p>

<pre data-type="programlisting">$ <strong>wc -l * </strong>
3 apple
4 banana
1 cantaloupe
8 total</pre>

<p>Why use <code>xargs</code>, then? Its power becomes apparent when the input
strings are more interesting than a simple directory listing. Suppose
you want to count lines in all files in a directory <em>and all its
subdirectories</em> (recursively), but only for Python source files with
names ending in <em>.py</em>. It’s easy to produce such a list of file
paths with <code>find</code>:<a data-type="indexterm" data-primary="xargs command" data-secondary="find command with" id="idm46586639485472"/><a data-type="indexterm" data-primary="find command" data-secondary="xargs command with" id="idm46586639484464"/></p>

<pre data-type="programlisting">$ <strong>find . -type f -name \*.py -print</strong>
fruits/raspberry.py
vegetables/leafy/lettuce.py
⋮</pre>

<p><code>xargs</code> can now apply the command template <code>wc -l</code> to each file path,
producing a recursive result that would be difficult to obtain
otherwise. For safety, I’ll replace the option <code>-print</code> with <code>-print0</code>,<a data-type="indexterm" data-primary="find command" data-secondary="print nulls (-print0 option)" id="idm46586639480144"/> and
<code>xargs</code> with <code>xargs -0</code>,<a data-type="indexterm" data-primary="xargs command" data-secondary="null separators (-0 option)" id="idm46586639478080"/> for reasons explained in the sidebar
<a data-type="xref" href="#sidebar_find_xargs">“Safety with find and xargs”</a>:</p>

<pre data-type="programlisting">$ <strong>find . -type f -name \*.py -print0 | xargs -0 wc -l</strong>
6 ./fruits/raspberry.py
3 ./vegetables/leafy/lettuce.py
⋮</pre>

<p>By combining <code>find</code> and <code>xargs</code>, you can empower any command to run
recursively through the filesystem, affecting only files (and/or
directories) that match your stated criteria. (In some cases, you can
produce the same effect with <code>find</code> alone, using its option <code>-exec</code>,<a data-type="indexterm" data-primary="find command" data-secondary="executing other commands (-exec option)" id="idm46586639472416"/>
but <code>xargs</code> is often a cleaner solution.)</p>

<p><code>xargs</code> has numerous options (see <code>man xargs</code>) that control how it
creates and runs the generated commands. The most important ones in my
view (other than <code>-0</code>) are <code>-n</code> and <code>-I</code>. The <code>-n</code><a data-type="indexterm" data-primary="xargs command" data-secondary="maximum arguments per command line (-n option)" id="idm46586639467872"/> option controls how
many arguments are appended by <code>xargs</code> onto each generated
command. The default behavior is to append as many arguments as will fit within the shell’s limits:<sup><a data-type="noteref" id="idm46586639466144-marker" href="ch07.xhtml#idm46586639466144">7</a></sup></p>

<pre data-type="programlisting">$ <strong>ls | xargs echo</strong>                     <em>Fit as many input strings as possible:</em>
apple banana cantaloupe carrot          <em>echo apple banana cantaloupe carrot</em>
$ <strong>ls | xargs -n1 echo</strong>                 <em>One argument per echo command:</em>
apple                                   <em>echo apple</em>
banana                                  <em>echo banana</em>
cantaloupe                              <em>echo cantaloupe</em>
carrot                                  <em>echo carrot</em>
$ <strong>ls | xargs -n2 echo</strong>                 <em>Two arguments per echo command:</em>
apple banana                            <em>echo apple banana</em>
cantaloupe carrot                       <em>echo cantaloupe carrot</em>
$ <strong>ls | xargs -n3 echo</strong>                 <em>Three arguments per echo command:</em>
apple banana cantaloupe                 <em>echo apple banana cantaloupe</em>
carrot                                  <em>echo carrot</em></pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_find_xargs">
<h5>Safety with find and xargs</h5>
<p>When<a data-type="indexterm" data-primary="xargs command" data-secondary="safety" id="idm46586639454432"/><a data-type="indexterm" data-primary="find command" data-secondary="xargs command with" data-tertiary="safety" id="idm46586639453456"/> combining <code>find</code> and <code>xargs</code>, use <code>xargs -0</code> (dash zero) rather than <code>xargs</code>
alone to protect against unexpected special characters in the input
strings. Pair it with the output produced by <code>find
-print0</code> (instead of <code>find -print</code>):</p>

<pre data-type="programlisting">$ <strong>find</strong> <em>options...</em> <strong>-print0 | xargs -0</strong> <em>options...</em></pre>

<p>Normally, <code>xargs</code> expects its input strings to be separated by
whitespace,<a data-type="indexterm" data-primary="xargs command" data-secondary="input string separators" id="idm46586639446048"/><a data-type="indexterm" data-primary="whitespace" data-secondary="separator" id="idm46586639444960"/><a data-type="indexterm" data-primary="separator" data-secondary="whitespace" id="idm46586639444016"/><a data-type="indexterm" data-primary="separator" data-secondary="xargs command" id="idm46586639443072"/> such as newline characters<a data-type="indexterm" data-primary="newline character" data-secondary="xargs input separator" id="idm46586639442000"/>. This is a problem when the
input strings themselves contain other whitespace, such as filenames
with spaces in them. By default, <code>xargs</code> will treat those spaces as
input separators and operate on incomplete strings, producing
incorrect results. For example, if the input to <code>xargs</code> includes a
line <em>prickly pear.py</em>, <code>xargs</code> will treat it as two input strings, and
you’re likely to see an error like this:</p>

<pre data-type="programlisting">prickly: No such file or directory
pear.py: No such file or directory</pre>

<p>To avoid this problem, use <code>xargs -0</code> (that’s a zero) to accept a
different character as the input separator, namely, the null character<a data-type="indexterm" data-primary="null character" id="idm46586639437248"/>
(ASCII zero).<a data-type="indexterm" data-primary="ASCII zero as null character" id="idm46586639436416"/><a data-type="indexterm" data-primary="zero" data-secondary="ASCII zero as null character" id="idm46586639435696"/> Nulls rarely appear in text, so they are ideal,
unambiguous separators for input strings.</p>

<p>How can you separate your input strings with nulls instead of
newlines? Fortunately, <code>find</code> has an option to do exactly that:
<code>-print0</code>, rather than <code>-print</code>.</p>

<p>The <code>ls</code> command unfortunately does not have an option to separate its
output with nulls, so my earlier toy examples with <code>ls</code> are not safe.
You can convert newlines to nulls with <code>tr</code>:<a data-type="indexterm" data-primary="tr command" data-secondary="converting newlines to nulls" id="idm46586639430592"/><a data-type="indexterm" data-primary="newline character" data-secondary="translating with tr" id="idm46586639429568"/><a data-type="indexterm" data-primary="newline character" data-secondary="converting to nulls" id="idm46586639428624"/><a data-type="indexterm" data-primary="null character" data-secondary="converting newlines to" id="idm46586639427680"/></p>
<pre data-type="programlisting">$ <strong>ls | tr '\n' '\0' | xargs -0 <em>...</em></strong></pre>

<p>Or use this handy alias that lists the current directory with entries
separated by nulls, suitable for piping to <code>xargs</code>:<a data-type="indexterm" data-primary="find command" data-secondary="maximum depth (-maxdepth option)" id="idm46586639424608"/></p>

<pre data-type="programlisting" data-code-language="bash"><code class="nb">alias</code> <code class="nv">ls0</code><code class="o">=</code><code class="s2">"find . -maxdepth 1 -print0"</code></pre>
</div></aside>

<p>The <code>-I</code><a data-type="indexterm" data-primary="xargs command" data-secondary="replacement string (-I option)" id="idm46586639409072"/> option controls where the input strings appear in the
generated command. By default, they’re appended to the command
template, but you can make them appear elsewhere. Follow <code>-I</code> with any
string (of your choice), and that string becomes a placeholder in the
command template, indicating exactly where input strings should be
inserted:</p>

<pre data-type="programlisting">$ <strong>ls | xargs -I XYZ echo XYZ is my favorite food</strong>      <em>Use XYZ as a placeholder</em>
apple is my favorite food
banana is my favorite food
cantaloupe is my favorite food
carrot is my favorite food</pre>

<p>I chose “XYZ” arbitrarily as a placeholder for input strings and positioned it
immediately after <code>echo</code>, moving the input string to the beginning of
each output line. Note that the <code>-I</code> option limits <code>xargs</code> to one
input string per generated command. I recommend reading the <code>xargs</code>
manpage thoroughly to learn what else you can control.</p>
<div data-type="tip" id="tip_xargs"><h1>Long Argument Lists</h1>
<p><code>xargs</code> is a problem solver<a data-type="indexterm" data-primary="long argument lists" id="idm46586639402240"/><a data-type="indexterm" data-primary="argument list too long (error)" id="idm46586639401504"/><a data-type="indexterm" data-primary="xargs command" data-secondary="solving “argument list too long” error" id="idm46586639400864"/> when command lines grow very long. Suppose
your current directory contains one million files named <em>file1.txt</em>
through <em>file1000000.txt</em> and you try to remove them by
pattern matching:</p>

<pre data-type="programlisting">$ <strong>rm *.txt</strong>
bash: /bin/rm: Argument list too long</pre>

<p>The pattern <code>*.txt</code> evaluates to a string of more than 14 million
characters, which is longer than Linux supports. To work around this
limitation, pipe a list of the files to <code>xargs</code> for deletion. <code>xargs</code>
will split the list of files across multiple <code>rm</code> commands. Form the
list of files by piping a full directory listing to <code>grep</code>, matching
only filenames ending in <em>.txt</em>, then pipe to
<code>xargs</code>:<a data-type="indexterm" data-primary="deleting files" data-secondary="mass deletion" data-tertiary="xargs command" id="idm46586639394096"/><a data-type="indexterm" data-primary="removing files" data-secondary="mass deletion" data-tertiary="xargs command" id="idm46586639392816"/></p>

<pre data-type="programlisting">$ <strong>ls | grep '\.txt$' | xargs rm</strong></pre>

<p>This solution is better than file pattern matching (<code>ls *.txt</code>), which will produce the
same “Argument list too long” error. Better yet, run <code>find -print0</code> as
described in <a data-type="xref" href="#sidebar_find_xargs">“Safety with find and xargs”</a>:<a data-type="indexterm" data-startref="cmdasstr" id="idm46586639388544"/></p>
<pre data-type="programlisting">$ <strong>find . -maxdepth 1 -name \*.txt -type f -print0 \
  | xargs -0 rm</strong></pre>
</div>
</div></section>





</div></section>













<section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Process-Control Techniques"><div class="sect1" id="idm46586639513616">
<h1>Process-Control Techniques</h1>

<p>So far, all commands I’ve discussed occupy the parent shell until they
finish. Let’s consider several techniques that forge a different
relationship with the parent shell:</p>
<dl>
<dt>Background commands</dt>
<dd>
<p>Immediately return the prompt and execute out
of sight</p>
</dd>
<dt>Explicit subshells</dt>
<dd>
<p>Can be launched in the middle of a combined command</p>
</dd>
<dt>Process replacement</dt>
<dd>
<p>Supersedes the parent shell</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="Technique #9: Backgrounding a Command"><div class="sect2" id="idm46586639367456">
<h2>Technique #9: Backgrounding a Command</h2>

<p><a data-type="indexterm" data-primary="background commands" id="back1"/><a data-type="indexterm" data-primary="running commands" data-secondary="job control" id="back2"/><a data-type="indexterm" data-primary="job control" id="jobcontrol"/><a data-type="indexterm" data-primary="job control" data-secondary="backgrounding a command" id="back3"/><a data-type="indexterm" data-primary="command" data-secondary="backgrounding" id="back4"/>
So far, all our techniques run a command to completion while you wait,
and then present the next shell prompt. But you don’t have to wait,
especially for commands that take a long time. You can launch commands
in a special way so they disappear from sight (sort of) yet continue
to run, freeing up the current shell immediately to run further commands. This
technique is called <em>backgrounding</em> a command or <em>running a command
in the background</em>. In contrast, commands that occupy the shell
are called <em>foreground</em><a data-type="indexterm" data-primary="foreground commands" id="idm46586639359104"/><a data-type="indexterm" data-primary="running commands" data-secondary="foreground commands" id="idm46586639358400"/> commands.
A shell instance runs at most one foreground command at a time plus
any number of background commands.</p>










<section data-type="sect3" data-pdf-bookmark="Launching a command in the background"><div class="sect3" id="idm46586639357200">
<h3>Launching a command in the background</h3>

<p>To run a command in the background, simply append an ampersand (<code>&amp;</code>).<a data-type="indexterm" data-primary="&amp; (ampersand) for job control" data-seealso="job control" id="idm46586639355376"/><a data-type="indexterm" data-primary="ampersand (&amp;)" data-secondary="&amp; for job control" data-seealso="job control" id="idm46586639354400"/>
The shell responds with a cryptic-looking message indicating that the
command is back­groun⁠ded and presents the next prompt:</p>

<pre data-type="programlisting">$ <strong>wc -c my_extremely_huge_file.txt &amp;</strong>     <em>Count characters in a huge file</em>
[1] 74931                                <em>Cryptic-looking response</em>
$</pre>

<p>You can then continue running foreground commands (or more background
commands) in this shell. Output from backgrounded commands may appear
at any time, even while you are typing.  If the backgrounded command
finishes successfully, the shell will inform you with a <em>Done</em><a data-type="indexterm" data-primary="Done message (job control)" id="idm46586639350288"/>
message:</p>

<pre data-type="programlisting">59837483748 my_extremely_huge_file.txt
[1]+  Done               wc -c my_extremely_huge_file.txt</pre>

<p>or if it fails, you’ll see an <em>Exit</em> message with an exit code:<a data-type="indexterm" data-primary="Exit message (job control)" id="idm46586639347712"/></p>

<pre data-type="programlisting">[1]+  Exit 1             wc -c my_extremely_huge_file.txt</pre>
<div data-type="tip"><h6>Tip</h6>
<p>The ampersand is also a list operator,<a data-type="indexterm" data-primary="list of commands" data-secondary="backgrounding" id="idm46586639345280"/> like <code>&amp;&amp;</code> and <code>||</code>:</p>

<pre data-type="programlisting">$ <strong><em>command1</em> &amp; <em>command2</em> &amp; <em>command3</em> &amp;</strong>   <em>All 3 commands</em>
[1] 57351                            <em>in background</em>
[2] 57352
[3] 57353
$ <strong><em>command4</em> &amp; <em>command5</em> &amp; echo hi</strong>      <em>All in background</em>
[1] 57431                            <em>but "echo"</em>
[2] 57432
hi</pre>
</div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Suspending a command and sending it to the background"><div class="sect3" id="idm46586639337648">
<h3>Suspending a command and sending it to the background</h3>

<p><a data-type="indexterm" data-primary="suspending a command" id="idm46586639336416"/><a data-type="indexterm" data-primary="sending a command to the background" id="idm46586639335488"/><a data-type="indexterm" data-primary="command" data-secondary="suspending" data-seealso="job control" id="idm46586639334848"/>
A related technique is to run a foreground command, change your mind
during execution, and send it to the background. Press Ctrl-Z to stop<a data-type="indexterm" data-primary="Control-Z (suspend current command)" id="idm46586639333344"/><a data-type="indexterm" data-primary="job control" data-secondary="suspending a command" id="idm46586639332656"/><a data-type="indexterm" data-primary="foreground commands" data-secondary="suspending" id="idm46586639331712"/><a data-type="indexterm" data-primary="running commands" data-secondary="foreground commands" data-tertiary="suspending" id="idm46586639330768"/>
the command temporarily (called <em>suspending</em> the command) and return
to the shell prompt; then type <code>bg</code><a data-type="indexterm" data-primary="bg command" id="idm46586639328752"/><a data-type="indexterm" data-primary="builtins" data-secondary="bg" id="idm46586639328048"/> to resume running the command in
the background.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Jobs and job control"><div class="sect3" id="idm46586639326784">
<h3>Jobs and job control</h3>

<p><a data-type="indexterm" data-primary="job" id="idm46586639325408"/><a data-type="indexterm" data-primary="job control" data-secondary="definition" id="idm46586639324704"/><a data-type="indexterm" data-primary="shell" data-secondary="job control" data-seealso="job control" id="idm46586639323760"/>
Background commands are part of a shell feature called <em>job control</em>
that manipulates running commands in various ways, like backgrounding,
suspending, and resuming them. A <em>job</em> is a shell’s unit of work: a single
instance of a command running in a shell. Simple commands, pipelines,
and conditional lists are all examples of jobs—basically anything
you can run at the command line.</p>

<p>A job is more than a Linux process.<a data-type="indexterm" data-primary="job" data-secondary="process versus" id="idm46586639321072"/><a data-type="indexterm" data-primary="process" data-secondary="shell job versus" id="idm46586639320096"/> A job may consist of one process,
two processes, or more. A pipeline<a data-type="indexterm" data-primary="pipes" data-secondary="pipelines" data-tertiary="single job" id="idm46586639319024"/> of six programs, for example, is a
single job that includes (at least) six processes. Jobs are a
construct of the shell. The Linux operating system doesn’t keep track
of jobs, just the underlying processes.</p>

<p>At any moment, a shell may have multiple jobs running. Each job in a
given shell has a positive integer ID, called the job ID or job
number.<a data-type="indexterm" data-primary="job" data-secondary="number (ID)" id="idm46586639316912"/> When you run a command in the background, the shell prints the
job number and the ID of the first process it runs within the job. In
the following command, the job number is 1 and the process ID is
74931:</p>

<pre data-type="programlisting">$ <strong>wc -c my_extremely_huge_file.txt &amp;</strong>
[1] 74931</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Common job-control operations"><div class="sect3" id="idm46586639314352">
<h3>Common job-control operations</h3>

<p>The shell has built-in commands for controlling jobs, listed in
<a data-type="xref" href="#table_job_control">Table 7-1</a>.<a data-type="indexterm" data-primary="job control" data-secondary="table of commands" id="idm46586639311664"/> I’ll demonstrate the most common job-control operations by running a
bunch of jobs and manipulating them. To keep the jobs simple and
predictable, I’ll run the command <code>sleep</code>,<a data-type="indexterm" data-primary="sleep command" id="idm46586639309984"/> which just sits there doing
nothing (“sleeping”) for a given number of seconds and then exits. For
example, <code>sleep 10</code> sleeps for 10 seconds.</p>
<table id="table_job_control" class="nobreakinside">
<caption><span class="label">Table 7-1. </span>Job control commands</caption>
<thead>
<tr>
<th>Command</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>bg</p></td>
<td><p>Move the current suspended job into the background <a data-type="indexterm" data-primary="bg command" id="idm46586639303488"/></p></td>
</tr>
<tr>
<td><p>bg %<em>n</em></p></td>
<td><p>Move suspended job number <em>n</em> into the background (example: <code>bg %1</code>)<a data-type="indexterm" data-primary="% (percent)" data-secondary="job control" id="idm46586639300000"/><a data-type="indexterm" data-primary="percent sign (%)" data-secondary="job control" id="idm46586639298992"/></p></td>
</tr>
<tr>
<td><p>fg</p></td>
<td><p>Move the current background job into the foreground <a data-type="indexterm" data-primary="fg command" id="idm46586639296448"/><a data-type="indexterm" data-primary="builtins" data-secondary="fg" id="idm46586639295744"/></p></td>
</tr>
<tr>
<td><p>fg %<em>n</em></p></td>
<td><p>Move background job number <em>n</em> into the foreground (example: <code>fg %2</code>)</p></td>
</tr>
<tr>
<td><p>kill %<em>n</em></p></td>
<td><p>Terminate background job number <em>n</em> (example: <code>kill %3</code>) <a data-type="indexterm" data-primary="kill command" id="idm46586639289248"/><a data-type="indexterm" data-primary="builtins" data-secondary="kill" id="idm46586639288512"/></p></td>
</tr>
<tr>
<td><p>jobs</p></td>
<td><p>View a shell’s jobs <a data-type="indexterm" data-primary="jobs command" id="idm46586639286032"/><a data-type="indexterm" data-primary="builtins" data-secondary="jobs" id="idm46586639285296"/></p></td>
</tr>
</tbody>
</table>

<p>Run a job in the background to completion:<a data-type="indexterm" data-primary="job control" data-secondary="examples of common operations" id="idm46586639283648"/></p>

<pre data-type="programlisting">$ <strong>sleep 20 &amp;</strong>                        <em>Run in the background</em>
[1] 126288
$ <strong>jobs</strong>                              <em>List this shell's jobs</em>
[1]+  Running          sleep 20 &amp;
$
<em>...eventually...</em>
[1]+  Done             sleep 20</pre>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>When jobs complete, the <em>Done</em> message might not appear until the next
time you press Enter.</p>
</div>

<p>Run a background job and bring it into the foreground:<a data-type="indexterm" data-primary="job control" data-secondary="foregrounding a command" id="idm46586639277600"/><a data-type="indexterm" data-primary="foreground commands" data-secondary="foregrounding a job" id="idm46586639276624"/><a data-type="indexterm" data-primary="background commands" data-secondary="foregrounding a job" id="idm46586639275680"/><a data-type="indexterm" data-primary="command" data-secondary="foregrounding" data-seealso="job control" id="idm46586639274736"/></p>

<pre data-type="programlisting">$ <strong>sleep 20 &amp;</strong>                        <em>Run in the background</em>
[1] 126362
$ <strong>fg</strong>                                <em>Bring into the foreground</em>
sleep 20
<em>...eventually...</em>
$</pre>

<p>Run a foreground job, suspend it, and bring it back into the foreground:</p>

<pre data-type="programlisting">$ <strong>sleep 20</strong>                          <em>Run in the foreground</em>
<strong>^Z</strong>                                  <em>Suspend the job</em>
[1]+  Stopped          sleep 20
$ <strong>jobs</strong>                              <em>List this shell's jobs</em>
[1]+  Stopped          sleep 20
$ <strong>fg</strong>                                <em>Bring into the foreground</em>
sleep 20
<em>...eventually...</em>
[1]+  Done             sleep 20</pre>

<p class="pagebreak-before">Run a foreground job and send it to the background:<a data-type="indexterm" data-primary="foreground commands" data-secondary="backgrounding a job" id="idm46586639264448"/><a data-type="indexterm" data-primary="background commands" data-secondary="foreground job backgrounded" id="idm46586639263472"/></p>

<pre data-type="programlisting">$ <strong>sleep 20</strong>                          <em>Run in the foreground</em>
<strong>^Z</strong>                                  <em>Suspend the job</em>
[1]+  Stopped          sleep 20
$ <strong>bg</strong>                                <em>Move to the background</em>
[1]+ sleep 20 &amp;
$ <strong>jobs</strong>                              <em>List this shell's jobs</em>
[1]+  Running          sleep 20 &amp;
$
<em>...eventually...</em>
[1]+  Done             sleep 20</pre>

<p>Work with multiple background jobs. Refer to a job by its job number<a data-type="indexterm" data-primary="job" data-secondary="number (ID)" id="idm46586639257296"/>
preceded by a percent sign (<code>%1</code>, <code>%2</code>, and so on):</p>

<pre data-type="programlisting">$ <strong>sleep 100 &amp;</strong>                        <em>Run 3 commands in the background</em>
[1] 126452
$ <strong>sleep 200 &amp;</strong>
[2] 126456
$ <strong>sleep 300 &amp;</strong>
[3] 126460
$ <strong>jobs</strong>                               <em>List this shell's jobs</em>
[1]   Running          sleep 100 &amp;
[2]-  Running          sleep 200 &amp;
[3]+  Running          sleep 300 &amp;
$ <strong>fg %2</strong>                              <em>Bring job 2 into the foreground</em>
sleep 200
<strong>^Z</strong>                                   <em>Suspend job 2</em>
[2]+  Stopped          sleep 200
$ <strong>jobs</strong>                               <em>See job 2 is suspended ("stopped")</em>
[1]   Running          sleep 100 &amp;
[2]+  Stopped          sleep 200
[3]-  Running          sleep 300 &amp;
$ <strong>kill %3</strong>                            <em>Terminate job 3</em>
[3]+  Terminated       sleep 300
$ <strong>jobs</strong>                               <em>See job 3 is gone</em>
[1]-  Running          sleep 100 &amp;
[2]+  Stopped          sleep 200
$ <strong>bg %2</strong>                              <em>Resume suspended job 2 in the background</em>
[2]+ sleep 200 &amp;
$ <strong>jobs</strong>                               <em>See job 2 is running again</em>
[1]-  Running          sleep 100 &amp;
[2]+  Running          sleep 200 &amp;
$</pre>
</div></section>













<section data-type="sect3" class="pagebreak-before less_space" data-pdf-bookmark="Output and input in the background"><div class="sect3" id="idm46586639313760">
<h3>Output and input in the background</h3>

<p><a data-type="indexterm" data-primary="job control" data-secondary="input/output" id="idm46586639243024"/><a data-type="indexterm" data-primary="background commands" data-secondary="input/output" id="idm46586639242048"/><a data-type="indexterm" data-primary="stdout" data-secondary="redirection" data-tertiary="background jobs" id="idm46586639241104"/><a data-type="indexterm" data-primary="redirection" data-secondary="background job stdout" id="idm46586639239888"/>
A backgrounded command may write to stdout, sometimes at inconvenient
or confusing times. Notice what happens if you sort the Linux
dictionary file (100,000 lines long) and print the first two lines in
the background. As expected, the shell immediately prints the job
number (1), a process ID (81089), and the next prompt:</p>

<pre data-type="programlisting">$ <strong>sort /usr/share/dict/words | head -n2 &amp;</strong>
[1] 81089
$</pre>

<p>If you wait until the job finishes, it prints two lines on stdout
wherever your cursor happens to be at the time. In this case, the
cursor is sitting at the second prompt, so you get this sloppy-looking
output:<a data-type="indexterm" data-primary="background commands" data-secondary="cursor placement after output" id="idm46586639237024"/></p>

<pre data-type="programlisting">$ <strong>sort /usr/share/dict/words | head -n2 &amp;</strong>
[1] 81089
$ A
A's</pre>

<p>Press Enter, and the shell will print a “job done” message:</p>

<pre data-type="programlisting">[1]+  Done               sort /usr/share/dict/words | head -n2
$</pre>

<p>Screen output from a background job can appear at any time while the
job runs. To avoid this sort of messiness, redirect stdout to a file,
then examine the file at your 
<span class="keep-together">leisure:</span></p>

<pre data-type="programlisting">$ <strong>sort /usr/share/dict/words | head -n2 &gt; /tmp/results &amp;</strong>
[1] 81089
$
[1]+  Done               sort /usr/share/dict/words | head -n2 &gt; /tmp/results
$ <strong>cat /tmp/results</strong>
A
A's
$</pre>

<p>Other odd things happen when a background job attempts to read from
stdin.<a data-type="indexterm" data-primary="stdin" data-secondary="redirection" data-tertiary="background jobs" id="idm46586639230560"/> The shell suspends the job, prints a <em>Stopped</em> message, and
waits for input in the background. Demonstrate this by backgrounding <code>cat</code>
with no arguments so it reads stdin:</p>

<pre data-type="programlisting">$ <strong>cat &amp;</strong>
[1] 82455
[1]+  Stopped            cat</pre>

<p>Jobs can’t read input in the background, so bring the job into the
foreground with <code>fg</code> and then supply the input:</p>

<pre data-type="programlisting">$ <strong>fg</strong>
cat
<strong>Here is some input</strong>
Here is some input
⋮</pre>

<p>After supplying all input, do any of the following:</p>

<ul>
<li>
<p>Continue running the command in the foreground until it completes.</p>
</li>
<li>
<p>Suspend and background the command again by pressing Ctrl-Z followed by <code>bg</code>.</p>
</li>
<li>
<p>End the input with Ctrl-D<a data-type="indexterm" data-primary="Control-D (end of file)" id="idm46586639220288"/>, or kill the command with Ctrl-C<a data-type="indexterm" data-primary="Control-C (kill current command)" id="idm46586639219408"/><a data-type="indexterm" data-primary="kill command" data-secondary="Control-C to kill current command" id="idm46586639218672"/><a data-type="indexterm" data-primary="command" data-secondary="killing current" id="idm46586639217712"/><a data-type="indexterm" data-primary="running commands" data-secondary="killing with Ctrl-C" id="idm46586639216768"/><a data-type="indexterm" data-primary="Ctrl" data-see="Control entries" id="idm46586639215824"/>.</p>
</li>
</ul>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Backgrounding tips"><div class="sect3" id="idm46586639214240">
<h3>Backgrounding tips</h3>

<p>Backgrounding is ideal for commands that take a long time to run, such
as text editors during long editing sessions, or any program that
opens its own windows. For example, programmers can save a lot of time
by suspending their text editor<a data-type="indexterm" data-primary="suspending a text editor" id="idm46586639212656"/><a data-type="indexterm" data-primary="text editors" data-secondary="suspending" id="idm46586639211936"/> rather than exiting. I’ve seen
experienced engineers modify some code in their text editor, save and
quit the editor, test the code, then relaunch the editor and hunt for
the spot in the code where they’d left off. They lose 10–15 seconds
to job-switching every time they quit the editor. If they instead
suspend the editor (Ctrl-Z), test their code, and resume the editor (<code>fg</code>), they
avoiding wasting time unnecessarily.</p>

<p>Backgrounding is also great for running a sequence of commands in the
background using a conditional list.<a data-type="indexterm" data-primary="conditional lists" data-secondary="backgrounding" id="idm46586639209872"/>
If any command within the list
fails, the rest won’t run and the job completes. (Just watch out for
commands that read input, since they’ll cause the job to suspend and
wait for input.)<a data-type="indexterm" data-startref="jobcontrol" id="idm46586639208768"/><a data-type="indexterm" data-startref="back1" id="idm46586639208096"/><a data-type="indexterm" data-startref="back2" id="idm46586639207424"/><a data-type="indexterm" data-startref="back3" id="idm46586639206752"/><a data-type="indexterm" data-startref="back4" id="idm46586639206080"/></p>

<pre data-type="programlisting">$ <strong><em>command1</em> &amp;&amp; <em>command2</em> &amp;&amp; <em>command3</em> &amp;</strong></pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Technique #10: Explicit Subshells"><div class="sect2" id="section_explicit_subshells">
<h2>Technique #10: Explicit Subshells</h2>

<p><a data-type="indexterm" data-primary="explicit subshell" id="idm46586639201248"/><a data-type="indexterm" data-primary="subshell" data-secondary="explicit" id="idm46586639200544"/><a data-type="indexterm" data-primary="running commands" data-secondary="explicit subshells" id="idm46586639199600"/>
Each time you launch a simple command, it runs in a child process, as
you saw in <a data-type="xref" href="ch06.xhtml#section_parent_child_processes">“Parent and Child Processes”</a>. Command substitution and process
substitution create subshells. There are times, however, when it’s
helpful to launch an extra subshell explicitly. To do so, simply
enclose a command in
parentheses<a data-type="indexterm" data-primary="() (parentheses)" data-secondary="subshell" id="idm46586639197440"/><a data-type="indexterm" data-primary="parentheses ()" data-secondary="subshell" id="idm46586639196496"/>
and it runs in a subshell:</p>

<pre data-type="programlisting">$ <strong>(cd /usr/local &amp;&amp; ls)</strong>
bin   etc   games   lib   man   sbin   share
$ <strong>pwd</strong>
/home/smith                   <em>"cd /usr/local" occurred in a subshell</em></pre>

<p>When applied to a whole command, this technique isn’t super useful,
except maybe to save you from running a second <code>cd</code> command to return
to your previous directory. However, if you place parentheses around
one piece of a combined command, you can perform some useful tricks. A
typical example is a pipeline that changes
directory<a data-type="indexterm" data-primary="changing" data-secondary="directory" data-tertiary="during pipeline execution" id="idm46586639192080"/><a data-type="indexterm" data-primary="directory" data-secondary="changing" data-tertiary="during pipeline execution" id="idm46586639190816"/>
in the middle of
execution. Suppose you have downloaded a compressed <code>tar</code><a data-type="indexterm" data-primary="tar command" id="idm46586639189120"/> file,
<em>package.tar.gz</em>, and you want to extract the files. A <code>tar</code> command
to extract the files is:</p>

<pre data-type="programlisting">$ <strong>tar xvf package.tar.gz</strong>
Makefile
src/
src/defs.h
src/main.c
⋮</pre>

<p>The extraction occurs relative to the current
directory.<sup><a data-type="noteref" id="idm46586639185696-marker" href="ch07.xhtml#idm46586639185696">8</a></sup> What if you want to extract them into a different
directory?  You could <code>cd</code> to the other directory first and run <code>tar</code>
(and then <code>cd</code> back), but you can also perform this task with a single
command. The trick is to pipe the tarred data to a subshell that
performs directory operations and runs <code>tar</code> as it reads from stdin:<sup><a data-type="noteref" id="idm46586639182704-marker" href="ch07.xhtml#idm46586639182704">9</a></sup></p>

<pre data-type="programlisting">$ <strong>cat package.tar.gz | (mkdir -p /tmp/other &amp;&amp; cd /tmp/other &amp;&amp; tar xzvf -)</strong></pre>

<p>This technique also works to copy files from one directory <em>dir1</em> to another
existing directory <em>dir2</em> using two <code>tar</code> processes,
one writing to stdout and one reading from stdin:</p>

<pre data-type="programlisting">$ <strong>tar czf - dir1 | (cd /tmp/dir2 &amp;&amp; tar xvf -)</strong></pre>

<p>The same technique can copy files to an existing directory on another host via SSH<a data-type="indexterm" data-primary="SSH" data-secondary="tar command with" id="idm46586639176224"/>:</p>

<pre data-type="programlisting">$ <strong>tar czf - dir1 | ssh myhost '(cd /tmp/dir2 &amp;&amp; tar xvf -)'</strong></pre>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_subshell_techniques">
<h5>Which Techniques Create Subshells?</h5>
<p>Many of the techniques in this chapter launch a subshell, which<a data-type="indexterm" data-primary="subshell" data-secondary="child process versus" id="idm46586639171984"/><a data-type="indexterm" data-primary="child process" data-secondary="subshell versus" id="idm46586639170928"/>
inherits the parent’s environment (variables and their values) plus
other shell context such as aliases. Other techniques only launch a
child process. The simplest way to distinguish them is to evaluate the
variable <code>BASH_SUBSHELL</code>,<a data-type="indexterm" data-primary="BASH_SUBSHELL variable" id="idm46586639169472"/><a data-type="indexterm" data-primary="variables" data-secondary="BASH_SUBSHELL" id="idm46586639168736"/> which will be nonzero for a subshell and
zero otherwise.<a data-type="indexterm" data-primary="command substitution" data-secondary="subshell" id="idm46586639167664"/><a data-type="indexterm" data-primary="process substitution" data-secondary="subshell" id="idm46586639166640"/>
More details are in <a data-type="xref" href="ch06.xhtml#section_subshells">“Child Shells Versus Subshells”</a>.</p>

<pre data-type="programlisting">$ <strong>echo $BASH_SUBSHELL</strong>                  <em>Ordinary execution</em>
0                                      <em>Not a subshell</em>
$ <strong>(echo $BASH_SUBSHELL)</strong>                <em>Explicit subshell</em>
1                                      <em>Subshell</em>
$ <strong>echo $(echo $BASH_SUBSHELL)</strong>          <em>Command substitution</em>
1                                      <em>Subshell</em>
$ <strong>cat &lt;(echo $BASH_SUBSHELL)</strong>           <em>Process substitution</em>
1                                      <em>Subshell</em>
$ <strong>bash -c 'echo $BASH_SUBSHELL'</strong>        <em>bash -c</em>
0                                      <em>Not a subshell</em></pre>
</div></aside>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>It’s tempting to view <code>bash</code> parentheses as if they simply group commands
together, like parentheses in arithmetic. They do not. Each pair of
parentheses causes a subshell to be launched.</p>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Technique #11: Process Replacement"><div class="sect2" id="idm46586639202400">
<h2>Technique #11: Process Replacement</h2>

<p><a data-type="indexterm" data-primary="process" data-secondary="replacement" id="idm46586639153760"/><a data-type="indexterm" data-primary="replacing a process" id="idm46586639152784"/><a data-type="indexterm" data-primary="running commands" data-secondary="process replacement" id="idm46586639152112"/>
Normally when you run a command, the shell runs it in a separate
process that is destroyed when the command exits, as described in
<a data-type="xref" href="ch06.xhtml#section_parent_child_processes">“Parent and Child Processes”</a>. You can change this behavior with the <code>exec</code><a data-type="indexterm" data-primary="exec command" id="idm46586639149760"/><a data-type="indexterm" data-primary="builtins" data-secondary="exec" id="idm46586639149056"/>
command, which is a shell 
<span class="keep-together">builtin.</span> It <em>replaces</em> the running shell (a
process) with another command of your choice (another process). When
the new command exits, no shell prompt will follow because the
original shell is gone.</p>

<p>To demonstrate this, run a new shell manually and change its prompt:</p>

<pre data-type="programlisting">$ <strong>bash</strong>                   <em>Run a child shell</em>
$ <strong>PS1="Doomed&gt; "</strong>         <em>Change the new shell's prompt</em>
Doomed&gt; <strong>echo hello</strong>       <em>Run any command you like</em>
hello</pre>

<p>Now <code>exec</code> a command and watch the new shell die:</p>

<pre data-type="programlisting">Doomed&gt; <strong>exec ls</strong>          <em>ls replaces the child shell, runs, and exits</em>
animals.txt
$                        <em>A prompt from the original (parent) shell</em></pre>
<div data-type="warning" epub:type="warning"><h1>Running exec May Be Fatal</h1>
<p>If you run <code>exec</code> in a shell, the shell exits afterward. If the shell
was running in a terminal window, the window closes. If the shell
was a login shell, you will be logged out.</p>
</div>

<p>Why would you ever run <code>exec</code>? One reason is to conserve resources by
not launching a second process. Shell scripts sometimes make use of
this optimization by running <code>exec</code> on the final command in the
script. If the script is run many times (say, millions or billions of
executions), the savings might be worth it.</p>

<p><code>exec</code> has a second ability—it can reassign stdin,<a data-type="indexterm" data-primary="stdin" data-secondary="reassigning with exec" id="idm46586639135776"/> stdout,<a data-type="indexterm" data-primary="stdout" data-secondary="reassigning with exec" id="idm46586639134672"/> and/or
stderr<a data-type="indexterm" data-primary="stderr" data-secondary="reassigning with exec" id="idm46586639133568"/> for the current shell. This is most practical in a shell
script, such as this toy example that prints information to a file,
<em>/tmp/outfile</em>:</p>

<pre data-type="programlisting" data-code-language="bash" class="pagebreak-before"><code class="ch">#!/bin/bash</code>
<code class="nb">echo</code> <code class="s2">"My name is </code><code class="nv">$USER</code><code class="s2">"</code>                                 &gt; /tmp/outfile
<code class="nb">echo</code> <code class="s2">"My current directory is </code><code class="nv">$PWD</code><code class="s2">"</code>                     &gt;&gt; /tmp/outfile
<code class="nb">echo</code> <code class="s2">"Guess how many lines are in the file /etc/hosts?"</code> &gt;&gt; /tmp/outfile
wc -l /etc/hosts                                        &gt;&gt; /tmp/outfile
<code class="nb">echo</code> <code class="s2">"Goodbye for now"</code>                                  &gt;&gt; /tmp/outfile</pre>

<p>Instead of redirecting the output of each command to <em>/tmp/outfile</em>
individually, use <code>exec</code> to redirect stdout to <em>/tmp/outfile</em> for the
entire script. Subsequent commands can simply print to stdout:</p>

<pre data-type="programlisting" data-code-language="bash"><code class="ch">#!/bin/bash</code>
<code class="c1"># Redirect stdout for this script</code>
<code class="nb">exec</code> &gt; /tmp/outfile2
<code class="c1"># All subsequent commands print to /tmp/outfile2</code>
<code class="nb">echo</code> <code class="s2">"My name is </code><code class="nv">$USER</code><code class="s2">"</code>
<code class="nb">echo</code> <code class="s2">"My current directory is </code><code class="nv">$PWD</code><code class="s2">"</code>
<code class="nb">echo</code> <code class="s2">"Guess how many lines are in the file /etc/hosts?"</code>
wc -l /etc/hosts
<code class="nb">echo</code> <code class="s2">"Goodbye for now"</code></pre>

<p>Run this script and examine the file <em>/tmp/outfile2</em> to see the results:</p>

<pre data-type="programlisting">$ <strong>cat /tmp/outfile2</strong>
My name is smith
My current directory is /home/smith
Guess how many lines are in the file /etc/hosts?
122 /etc/hosts
Goodbye for now</pre>

<p>You probably won’t use <code>exec</code> often, but it’s there when you need it.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586639155040">
<h1>Summary</h1>

<p>Now you have 13 techniques for running a command—the 11 in this
chapter plus simple commands and pipelines. <a data-type="xref" href="#table_umpteen_summary">Table 7-2</a>
reviews some common use cases for different techniques.<a data-type="indexterm" data-primary="running commands" data-secondary="overview" id="idm46586639062336"/></p>
<table id="table_umpteen_summary">
<caption><span class="label">Table 7-2. </span>Common idioms for running commands</caption>
<thead>
<tr>
<th>Problem</th>
<th>Solution</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Sending stdout from one program to stdin of another</p></td>
<td><p>Pipelines</p></td>
</tr>
<tr>
<td><p>Inserting output (stdout) into a command</p></td>
<td><p>Command substitution</p></td>
</tr>
<tr>
<td><p>Providing output (stdout) to a command that doesn’t read from stdin, but does read disk files</p></td>
<td><p>Process substitution</p></td>
</tr>
<tr>
<td><p>Executing one string as a command</p></td>
<td><p><code>bash -c</code>, or piping to <code>bash</code></p></td>
</tr>
<tr>
<td><p>Printing multiple commands on stdout and executing them</p></td>
<td><p>Piping to <code>bash</code></p></td>
</tr>
<tr>
<td><p>Executing many similar commands in a row</p></td>
<td><p><code>xargs</code>, or constructing the commands as strings and piping them to <code>bash</code></p></td>
</tr>
<tr>
<td><p>Managing commands that depend on one other’s success</p></td>
<td><p>Conditional lists</p></td>
</tr>
<tr>
<td><p>Running several commands at a time</p></td>
<td><p>Backgrounding</p></td>
</tr>
<tr>
<td><p>Running several commands at a time that depend on one another’s success</p></td>
<td><p>Backgrounding a conditional list</p></td>
</tr>
<tr>
<td><p>Running one command on a remote host</p></td>
<td><p>Run <code>ssh </code><em><code>host command</code></em></p></td>
</tr>
<tr>
<td><p>Changing directory in the middle of a pipeline</p></td>
<td><p>Explicit subshells</p></td>
</tr>
<tr>
<td><p>Running a command later</p></td>
<td><p>Unconditional list with <code>sleep</code> followed by the command</p></td>
</tr>
<tr>
<td><p>Redirecting to/from protected files</p></td>
<td><p>Run <code>sudo bash -c "</code><em><code>command</code></em> <code>&gt;</code> <em><code>file</code></em><code>"</code></p></td>
</tr>
</tbody>
</table>

<p>The next two chapters will teach you to combine techniques to achieve
business goals efficiently.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586639844176"><sup><a href="ch07.xhtml#idm46586639844176-marker">1</a></sup> The command <code>mkdir -p dir</code>, which creates a directory path only if it doesn’t already exist, would be a more elegant solution here.</p><p data-type="footnote" id="idm46586639836000"><sup><a href="ch07.xhtml#idm46586639836000-marker">2</a></sup> This behavior is opposite of what many programming languages do, where zero means failure.</p><p data-type="footnote" id="idm46586639789616"><sup><a href="ch07.xhtml#idm46586639789616-marker">3</a></sup> Alternatively, you could use <code>cron<a data-type="indexterm" data-primary="cron" id="idm46586639788800"/></code> for the backup job and <code>at</code><a data-type="indexterm" data-primary="at command" id="idm46586639787632"/> for reminders, but Linux is all about flexibility—finding multiple ways to achieve the same result.</p><p data-type="footnote" id="idm46586639738208"><sup><a href="ch07.xhtml#idm46586639738208-marker">4</a></sup> Bank of America’s downloadable statement files are named this way at press time.</p><p data-type="footnote" id="idm46586639674432"><sup><a href="ch07.xhtml#idm46586639674432-marker">5</a></sup> Technically, <code>diff</code> can read one list from stdin if you provide a dash as a filename, but not two lists.</p><p data-type="footnote" id="idm46586639568448"><sup><a href="ch07.xhtml#idm46586639568448-marker">6</a></sup> This directory structure is similar to a hashtable with chaining.</p><p data-type="footnote" id="idm46586639466144"><sup><a href="ch07.xhtml#idm46586639466144-marker">7</a></sup> The exact number depends on length limits on your Linux system; see <code>man xargs</code>.</p><p data-type="footnote" id="idm46586639185696"><sup><a href="ch07.xhtml#idm46586639185696-marker">8</a></sup> Assuming that the <code>tar</code> archive was built with relative paths—which is typical for downloaded software—not absolute paths.</p><p data-type="footnote" id="idm46586639182704"><sup><a href="ch07.xhtml#idm46586639182704-marker">9</a></sup> This specific problem can be solved more simply with the <code>tar</code> option <code>-C</code> or <code>--directory</code>, which specifies a target directory. I’m just demonstrating the general technique of using a subshell.</p></div></div></section></div></body></html>