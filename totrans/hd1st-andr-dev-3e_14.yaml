- en: 'Chapter 12\. Live Data: *Leaping into Action*'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0483-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Your code often needs to react to property value changes.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If a view model property changes value, for example, **the fragment might need
    to respond** by updating its views or navigating elsewhere. But **how does a fragment
    get to hear when a property’s been updated**? Here, we’ll introduce you to **live
    data**: a way of **telling interested parties when something’s changed**. You’ll
    learn all about ***MutableLiveData***, and how to **make your fragment observe
    properties** of this type. You’ll discover **how the *LiveData* type helps maintain
    your app’s integrity**. Soon, you’ll be writing apps that are **more responsive
    than ever before**...'
  prefs: []
  type: TYPE_NORMAL
- en: The Guessing Game app revisited
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we built a Guessing Game app that lets the user guess
    which letters are included in a secret word. When the user guesses all the letters
    or runs out of lives, the game ends.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the fragment code from becoming too bloated and maintain the app’s
    state when the user rotated the device screen, we used view models for the app’s
    game logic and data. `GameFragment` uses `GameViewModel` for its logic and data,
    and `ResultViewModel` holds the game result that’s needed by `ResultFragment`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0484-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When each fragment is displayed, or the user makes a guess, the fragments get
    the latest values from their view models and display them on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach works, however, there are some disadvantages.
  prefs: []
  type: TYPE_NORMAL
- en: The fragments decide when to update views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The downside to this approach is that each fragment decides when to fetch the
    latest property values from the view model and update its views. And some of the
    time, these values won’t have changed. If the user makes a correct guess, for
    example, `GameFragment` updates the text that’s displayed for the number of lives
    left and the incorrect guesses, even though these values won’t have changed.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0485-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Let the view model say when a value’s changed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An alternative approach is for `GameViewModel` to let `GameFragment` know when
    each of its properties has been updated. If the fragment is notified of these
    changes, it will no longer need to decide for itself when to fetch the latest
    property values from the view model and update its views. Instead, it will only
    need to update its views once it’s told that the underlying property has been
    updated.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0485-02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We’re going to implement this change in the Guessing Game app using Android’s
    **live data** library: part of Android Jetpack. Live data lets the view model
    tell interested parties—such as fragments and activities—when its property values
    have been updated. They can then react to these changes by updating views, or
    calling other methods.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0485-03.png)'
  prefs: []
  type: TYPE_IMG
- en: You’ll find out how to use live data through the rest of this chapter. First,
    let’s go through the steps we’ll take to update the app.
  prefs: []
  type: TYPE_NORMAL
- en: Here’s what we’re going to do
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0486-01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the steps that we’ll go through to write the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Make the Guessing Game app use live data.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll update `GameViewModel` so that the `livesLeft`, `incorrectGuesses,` and
    `secretWordDisplay` properties use live data. We’ll then make `GameFragment` update
    its views when the values of these properties change.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0486-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Protect GameViewModel’s properties and methods.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll restrict access to `GameViewModel`’s properties so that only `GameViewModel`
    can update them. We’ll also make sure that `GameFragment` only has access to the
    methods it requires to do its job.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0486-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Add a gameOver property.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll make `GameViewModel` decide when each game is over using a new `gameOver`
    property. `GameFragment` will navigate to `ResultFragment` when the value of this
    property changes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0486-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Add a live data dependency to the app build.gradle file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’re going to be using live data, we’ll begin by adding a live data dependency
    to the app’s *build.gradle* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the project for the Guessing Game app (if you haven’t already done so),
    open the file *GuessingGame/app/build.gradle*, and add the following line (in
    bold) to the `dependencies` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0486-05.png)'
  prefs: []
  type: TYPE_IMG
- en: When prompted, sync your changes.
  prefs: []
  type: TYPE_NORMAL
- en: GameViewModel and GameFragment need to use live data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We want to use live data in the Guessing Game app so that `GameViewModel` notifies
    `GameFragment` when its property values have changed. `GameFragment` will then
    react to these changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll tackle this in two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Specify which GameViewModel property changes GameFragment needs to know about.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Tell GameFragment how to respond to each change.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For now, we’ll focus on the `GameViewModel` code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Which view model properties should use live data?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`GameViewModel` includes three properties—`secretWordDisplay`, `incorrectGuesses,`
    and `livesLeft`—that `GameFragment` uses to update its views. We’ll specify that
    these three properties use live data so that `GameFragment` is notified when their
    values change.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You specify that a property uses live data by changing its type to `**MutableLiveData<Type>**`,
    where `Type` is the type of data the property should hold. The `livesLeft` property,
    for example, is currently defined as an `Int` using the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To make the property use live data, you change its type to `MutableLiveData<Int>`
    so that it looks like this instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0487-03.png)![image](Images/f0487-02.png)'
  prefs: []
  type: TYPE_IMG
- en: This specifies that `livesLeft` is now a `MutableLiveData<Int>` with an initial
    value of 8.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can define the `incorrectGuesses` and `secretWordDisplay` properties
    using code like this
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0487-04.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, each property’s type is set to `MutableLiveData<String>`. `incorrectGuesses`’s
    value is set to `""`, while `secretWordDisplay`’s value will get set in `GameViewModel`’s
    `init` block.
  prefs: []
  type: TYPE_NORMAL
- en: So that’s how you define a live data property. Next up, how to update its value.
  prefs: []
  type: TYPE_NORMAL
- en: Live data objects use a value property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you use `MutableLiveData` properties, you update their values using a
    property named `**value**`. To update the `secretWordDisplay` property with the
    `deriveSecretWordDisplay()` method’s return value, for example, you don’t use
    the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'as you did before. You use the following code instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Changing the `value` property in this way is important, because it’s how any
    interested parties—in this case `GameFragment`—get notified of any changes. Each
    time `secretWordDisplay`’s `value` property gets updated, `GameFragment` is informed,
    so it can respond by updating its views.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0488-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The value property can be null
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s one extra thing to be aware of when you use live data: the `value`’s
    type is *nullable*. This means that when you use live data values in your code,
    you need to perform null-safety checks, or your code won’t compile.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the `livesLeft` property is defined using the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0488-03.png)'
  prefs: []
  type: TYPE_IMG
- en: This property’s type is `MutableLiveData<Int>`, so its `value` property can
    accept an `Int`, or be `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the `value` property may be `null`, we can’t, say subtract one from its
    value using the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, we need to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0488-04.png)'
  prefs: []
  type: TYPE_IMG
- en: which subtracts 1 from its value so long as it isn’t `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the following `isLost()` method won’t compile because `liveLeft.value`
    may be `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can, however, change it to use Kotlin’s Elvis operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0488-05.png)![image](Images/f0489-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Live Data properties can be defined using val.**'
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, you use `val` and `var` in Kotlin to specify whether or
    not a property can be given a reference to a new object.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we first defined each property, we used `var` so that we could update
    it. We defined the `livesLeft` property, for example, using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'which initialized `livesLeft` with an `Int` object whose value is 8\. Each
    time the user made an incorrect guess, we subtracted 1 from `livesLeft`, which
    gave it a reference to a new `Int` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0489-03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With live data, you update the `value` property of the *existing* object, instead
    of replacing it with another object, and interested parties are notified of this
    change. As the object is no longer being replaced, you can define the property
    using `val` instead of `var` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0489-04.png)'
  prefs: []
  type: TYPE_IMG
- en: The full code for GameViewModel.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you know how live data works, let’s update `GameViewModel` so that
    its `livesLeft`, `incorrectGuesses`, and `secretWordDisplay` properties all use
    live data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for *GameViewModel.kt*; update the code to include the
    changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0490-02.png)![image](Images/f0491-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s everything that we need for `GameViewModel`. Next up, let’s make `GameFragment`
    respond when the `livesLeft`, `incorrectGuesses`, and `secretWordDisplay` properties
    get updated.
  prefs: []
  type: TYPE_NORMAL
- en: The fragment observes the view model properties and reacts to changes.
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You make a fragment respond to `value` changes in a view model’s `MutableLiveData`
    property by calling the property’s `**observe()**` method. If the following code
    is added to `GameFragment`, for example, it will observe the view model’s `livesLeft`
    property, and take action when it changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0492-02.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the above code passes `viewLifecycleOwner` and `Observer` arguments
    to the `observe()` method.
  prefs: []
  type: TYPE_NORMAL
- en: '`viewLifecycleOwner` refers to the lifecycle of the fragment’s views. It’s
    tied to when the fragment has access to its UI: from when it’s created in the
    fragment’s `onCreateView()` method, to when its destroyed, and `onDestroyView()`
    gets called.'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0492-03.png)'
  prefs: []
  type: TYPE_IMG
- en: '`Observer` is a class that can receive live data. It’s tied to the `viewLifecycleOwner`,
    so it’s only active—and able to receive live data notifications—when the fragment
    has access to its views. If the live data property’s value changes while the fragment
    doesn’t have access to its UI, the observer isn’t notified, so the fragment doesn’t
    respond. This stops the fragment from trying to update views when they’re not
    available, which might cause the app to crash.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It also makes your coding life easier because you don’t need to check whether
    the view’s available for yourself. Using live data handles it all for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Observer` class accepts a lambda parameter, which specifies how the property’s
    new value should be used. In the Guessing Game app, for example, we want `GameFragment`
    to update its `lives` text each time the view model’s `livesLeft` property gets
    updated, and we can achieve this using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0492-04.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s everything that we need to know in order to make `GameFragment` update
    its views when the view model property values get changed. Let’s update its code.
  prefs: []
  type: TYPE_NORMAL
- en: The full code for GameFragment.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here’s the updated code for `GameFragment`; make sure that the file *GameFragment.kt*
    includes the changes shown below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0493-02.png)![image](Images/f0494-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Those are all the changes we need to make to `GameFragment` so that it updates
    its views each time it observes changes to the `incorrectGuesses`, `livesLeft`,
    and `secretWordDisplay` properties.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now implemented live data in the Guessing Game app Let’s go through what
    happens when the app runs.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0495-02.png)'
  prefs: []
  type: TYPE_IMG
- en: '**ResultViewModel doesn’t need to use live data, so we don’t need to update
    it.**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may recall, `ResultViewModel` has one property (named `result`), which
    gets set when the view model gets created. The code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, result is defined using `val`, so once it’s been initialized,
    it can’t be updated to another value. `ResultFragment` doesn’t need to be notified
    when `result` changes because **once set,** `**result**` **can never change**.
    There’s no need to make `ResultFragment` respond to any changes, because there
    can’t be any.
  prefs: []
  type: TYPE_NORMAL
- en: So let’s walk through what happens when the code runs, and then take the app
    for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `GameViewModel` object is initialized, and the values of its three `MutableLiveData`
    properties—`livesLeft`, `incorrectGuesses`, and `secretWordDisplay`—are set.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0496-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes the livesLeft, incorrectGuesses, and secretWordDisplay
    properties in the GameViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0496-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment updates its views with the values of the properties it’s observing.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0496-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user makes a correct guess, secretWordDisplay’s value is updated,
    and the new value is passed to GameFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` responds by updating its `word` view, which is displayed on
    the screen.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0497-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When the user makes an incorrect guess, the values for incorrectGuesses and
    livesLeft are updated, and passed to GameFragment.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` responds by updating its views.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0497-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**When isWon() or isLost() return true, GameFragment navigates to ResultFragment,
    passing it the result.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ResultFragment` displays the result.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0497-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s take the app for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we run the app, `GameFragment` is displayed as before.
  prefs: []
  type: TYPE_NORMAL
- en: When we make a correct guess, the secret word display gets updated. When we
    make an incorrect guess, the lives left is updated, and our guess is added to
    the incorrect guesses display.
  prefs: []
  type: TYPE_NORMAL
- en: If we guess all the letters or lose all our lives, the app navigates to `ResultFragment`,
    which displays the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0498-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The game behaves in the same way as before, but behind the scenes, it responds
    using live data.
  prefs: []
  type: TYPE_NORMAL
- en: Fragments can update GameViewModel’s properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we’ve updated the code in `GameViewModel` and `GameFragment` so that
    it uses live data. Each time the value of a `MutableLiveData` property in `GameViewModel`
    gets updated, `GameFragment` responds by updating its views.
  prefs: []
  type: TYPE_NORMAL
- en: There’s a slight problem with the code, however. `GameFragment` has full access
    to `GameViewModel`’s properties and methods, so if it wanted to, it could use
    them inappropriately. There’s nothing to stop the fragment from, say, updating
    the `livesLeft` property to 100 so that the user can make many more guesses and
    win the game each time she plays.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this problem, we’re going to restrict direct access to the `GameViewModel`’s
    properties so that **only methods in the view model can update them**.
  prefs: []
  type: TYPE_NORMAL
- en: '**You can restrict direct access to a view model’s property by marking it private,
    and providing read-only access via another property’s getter.**'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Keep your privates private
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To protect `GameViewModel`’s properties, we’ll mark each one as `private` so
    that only code in `GameViewModel` can update their values. We’ll then expose a
    *read-only version* of each `MutableLiveData` property that `GameFragment` needs
    to observe. Instead of defining the `livesLeft` property using code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'we’ll use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0501-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, the `_livesLeft` property holds a reference to a `MutableLiveData` object.
    `GameFragment` doesn’t have access to this property because it’s marked as `private`.
  prefs: []
  type: TYPE_NORMAL
- en: '`GameFragment` can, however, access the value of this property using `livesLeft`’s
    getter. `livesLeft`’s type is `**LiveData**`, which is like `MutableLiveData`
    except that it can’t be used to update the underlying object’s `value` property:
    `GamesFragment` can read the value, but it can’t update it.'
  prefs: []
  type: TYPE_NORMAL
- en: When you structure your code in this way, the private property is sometimes
    called a **backing property**. It holds a reference to an object that other classes
    only have access to via another property.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s update the `GameViewModel` code.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0501-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The full code for GameViewModel.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0502-01.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ll update the code for `GameViewModel` so that it uses backing properties
    to restrict direct access to its live data properties. We’ll also mark as private
    any properties and methods that `GameFragment` doesn’t need to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for *GameViewModel.kt*; update the code to include our
    changes (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0502-02.png)![image](Images/f0503-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Let’s go through what happens when the code runs.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0504-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameViewModel’s properties are initialized.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`livesLeft`, `incorrectGuesses`, and `secretWordDisplay` are `LiveData` properties
    that refer to the same underlying objects as their `MutableLiveData` backing properties.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0504-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes the livesLeft, incorrectGuesses, and secretWordDisplay
    properties.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` can’t update any of these properties, but it responds when `GameViewModel`
    updates any of the backing properties because they refer to the same underlying
    object.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0504-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment continues to respond to value changes until isWon() or isLost()
    returns true.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` navigates to `ResultFragment`, passing it the result. `ResultFragment`
    displays the result.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0505-01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Let’s take the app for a test drive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0505-02.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the app, it works in the same way as before. This time, however,
    we’ve protected `GameViewModel`’s `MutableLiveData` properties by restricting
    `GameFragment`’s access to them.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0505-03.png)'
  prefs: []
  type: TYPE_IMG
- en: We’ve nearly finished updating the Guessing Game app. There’s just one more
    thing we need to change...
  prefs: []
  type: TYPE_NORMAL
- en: GameFragment still includes game logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0506-01.png)'
  prefs: []
  type: TYPE_IMG
- en: In the current version of the app, `GameFragment` decides when the game is finished
    by calling `GameViewModel`’s `isWon()` and `isLost()` methods after the user has
    made each guess. If either of these returns *true*, `GameFragment` navigates to
    `ResultFragment`, passing it the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the current code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The problem with this approach is that `GameFragment` decides when the game
    is over instead of `GameViewModel`. As determining when the game has finished
    is a game decision, it’s something that `GameViewModel` should be responsible
    for, not `GameFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: Make GameViewModel decide when the game is over
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To deal with this, we’ll add a `MutableLiveData<Boolean>` property named `_gameOver`
    to `GameViewModel`, whose value we’ll expose using a `LiveData` property named
    `gameOver`. We’ll set this property to *true* when the user wins or loses the
    game. When this happens, `GameFragment` will respond by navigating to `ResultFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0506-03.png)'
  prefs: []
  type: TYPE_IMG
- en: You’re already familiar with the changes that are required to do this, so before
    we show you the code, try the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **goal** is to add a `gameOver` property (with a `_gameOver` backing property)
    to `GameViewModel` so that `GameFragment` can respond when its value (a `Boolean`)
    gets updated. The property should be initialized with a value of *false*. Take
    code snippets from the pool and place them into the blank lines in the code. You
    may **not** use the same snippet more than once, and you won’t need to use all
    the snippets.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![image](Images/f0507-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '**Note: each thing from the pool can only be used once!**'
  prefs: []
  type: TYPE_NORMAL
- en: Pool Puzzle Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common01.png)'
  prefs: []
  type: TYPE_IMG
- en: Your **goal** is to add a `gameOver` property (with a `_gameOver` backing property)
    to `GameViewModel` so that `GameFragment` can respond when its value (a `Boolean`)
    gets updated. The property should be initialized with a value of *false*. Take
    code snippets from the pool and place them into the blank lines in the code. You
    may **not** use the same snippet more than once, and you won’t need to use all
    the snippets.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0508-01.png)![image](Images/f0508-02.png)'
  prefs: []
  type: TYPE_IMG
- en: The full code for GameViewModel.kt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to add a `gameOver` property to `GameViewModel`, along with a `_gameOver`
    backing property. We’ll get the `makeGuess()` method to set it to *true* when
    the user has guessed all of the letters in the secret word, or run out of lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the full code for `GameViewModel`; update the code in *GameViewModel.kt*
    to include the changes shown below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0509-02.png)![image](Images/f0510-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Make GameFragment observe the new property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we’ve added the `gameOver` property to `GameViewModel`, we need to
    make `GameFragment` respond to when it’s been updated. We’ll make the fragment
    observe the property, so that when its value is changed to *true*, the fragment
    will navigate to `ResultFragment`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the code for `GameFragment`; update the code in *GameFragment.kt* so
    that it includes the changes below (in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0511-01.png)![image](Images/f0512-02.png)'
  prefs: []
  type: TYPE_IMG
- en: That’s it! Let’s go through what happens when it runs.
  prefs: []
  type: TYPE_NORMAL
- en: What happens when the app runs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following things happen when the app runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GameFragment asks the ViewModelProvider class for an instance of GameViewModel.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0513-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameViewModel’s properties are initialized.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `_gameOver` and `gameOver` properties refer to a `MutableLiveData<Boolean>`
    object whose value is set to *false*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0513-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes the GameViewModel’s gameOver property.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`GameFragment` can’t update the `MutableLiveData` object that the `gameOver`
    property refers to, but it can respond to when its value changes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0513-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**Each time the GameViewModel’s makeGuess() method is called, it checks whether
    isWon() or isLost() returns true.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If either is *true*, it sets the value of its `_gameOver` property to *true*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0514-02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment observes the value has been updated to true via the GameViewModel’s
    gameOver property.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new value is passed to `GameFragment`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![image](Images/f0514-03.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '**GameFragment responds by navigating to ResultFragment, passing it the result.**'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![image](Images/f0514-04.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We’ll take the app for a test drive after the following exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment Magnets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  prefs: []
  type: TYPE_IMG
- en: Somebody wrote the code for a fragment named `LotteryFragment` on the fridge
    door, but a freak kitchen blizzard blew some of the code away. Can you piece it
    back together again?
  prefs: []
  type: TYPE_NORMAL
- en: 'The fragment needs to observe `LotteryViewModel`’s `winningNumbers` property,
    which is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When `winningNumbers` changes, `LotteryFragment` needs to update its `numbers`
    view with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0515-01.png)'
  prefs: []
  type: TYPE_IMG
- en: Fragment Magnets Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/common02.png)'
  prefs: []
  type: TYPE_IMG
- en: Somebody wrote the code for a fragment named `LotteryFragment` on the fridge
    door, but a freak kitchen blizzard blew some of the code away. Can you piece it
    back together again?
  prefs: []
  type: TYPE_NORMAL
- en: 'The fragment needs to observe `LotteryViewModel`’s `winningNumbers` property,
    which is defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When `winningNumbers` changes, `LotteryFragment` needs to update its `numbers`
    view with the new value.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0516-01.png)'
  prefs: []
  type: TYPE_IMG
- en: '![Images](Images/car.png) Test Drive'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/f0517-01.png)'
  prefs: []
  type: TYPE_IMG
- en: When we run the app, it works in the same way as before. This time, however,
    `GameViewModel` decides when the game is over instead of `GameFragment`. The fragment
    simply observes the view model’s `gameOver` property, and navigates to `ResultFragment`
    when it’s changed to *true*.
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0517-02.png)'
  prefs: []
  type: TYPE_IMG
- en: Congratulations! You’ve now built an app that uses live data to respond to changes
    as and when they occur. In the next chapter, we’ll build on this still further
    using a new technique called data binding.
  prefs: []
  type: TYPE_NORMAL
- en: Your Android Toolbox
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![image](Images/tools.png)'
  prefs: []
  type: TYPE_IMG
- en: '**You’ve got [Chapter 12](#live_datacolon_leaping_into_action) under your belt
    and now you’ve added live data to your toolbox.**'
  prefs: []
  type: TYPE_NORMAL
- en: '![image](Images/f0518-01.png)'
  prefs: []
  type: TYPE_IMG
