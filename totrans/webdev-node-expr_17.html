<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 17. Static Content"><div class="chapter" id="ch_static_content">
<h1><span class="label">Chapter 17. </span>Static Content</h1>


<p><a data-type="indexterm" data-primary="static content" id="ix_ch-17-static_content-asciidoc0"/><em>Static content</em> refers to the resources your app will be serving that don’t change on a per-request basis.  Here are the usual suspects:</p>
<dl>
<dt>Multimedia</dt>
<dd>
<p><a data-type="indexterm" data-primary="multimedia, as static content" id="idm45053577990152"/>Images, videos, and audio files.  It’s quite possible to generate image files on the fly, of course (and video and audio, though that’s far less common), but most multimedia resources are static.</p>
</dd>
<dt>HTML</dt>
<dd>
<p><a data-type="indexterm" data-primary="HTML" data-secondary="as static content" id="idm45053577987992"/>If our web application is using views to render dynamic HTML, it wouldn’t generally qualify as static HTML (though for performance reasons, you may dynamically generate HTML, cache it, and serve it as a static resource).  SPA applications, as we’ve seen, commonly send a single, static HTML file to the client, which is the most common reason to treat HTML as a static resource.  Note that requiring the client to use an <em>.html</em> extension is not very modern, so most servers now allow static HTML resources to be served without the extension (so <code>/foo</code> and <code>/foo.html</code> would return the same content).</p>
</dd>
<dt>CSS</dt>
<dd>
<p><a data-type="indexterm" data-primary="CSS" data-secondary="as static content" id="idm45053577983880"/>Even if you use an abstracted CSS language like LESS, Sass, or Stylus, at the end of the day, your browser needs plain CSS, which is a static resource.<sup><a data-type="noteref" id="idm45053577982616-marker" href="ch17.xhtml#idm45053577982616">1</a></sup></p>
</dd>
<dt>JavaScript</dt>
<dd>
<p><a data-type="indexterm" data-primary="JavaScript" data-secondary="as static content" id="idm45053577980760"/>Just because the server is running JavaScript doesn’t mean there won’t be client-side JavaScript.  Client-side JavaScript is considered a static resource.  Of course, now the line is starting to get a bit hazy: what if there was common code that we wanted to use on the backend and client side?  There are ways to solve this problem, but at the end of the day, the JavaScript that gets sent to the client is generally static.</p>
</dd>
<dt>Binary downloads</dt>
<dd>
<p><a data-type="indexterm" data-primary="binary files" data-secondary="as static content" id="idm45053577978056"/>This is the catchall category: any PDFs, ZIP files, Word documents, installers, and the like.</p>
</dd>
</dl>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>If you are building an API only, there may be no static resources.  If that’s the case, you may skip this chapter.</p>
</div>






<section data-type="sect1" data-pdf-bookmark="Performance Considerations"><div class="sect1" id="idm45053577975480">
<h1>Performance Considerations</h1>

<p><a data-type="indexterm" data-primary="static content" data-secondary="performance considerations" id="idm45053577974024"/>The way you handle static resources significantly impacts the real-world performance of your website, especially if your site is multimedia-heavy.  The two primary performance considerations are <em>reducing the number of requests</em> and <em>reducing content size</em>.</p>

<p><a data-type="indexterm" data-primary="HTTP" data-secondary="requests" id="idm45053577971528"/>Of the two, reducing the number of (HTTP) requests is more critical, especially for mobile (the overhead of making an HTTP request is significantly higher over a cellular network).  Reducing the number of requests can be accomplished in two ways: combining resources and browser caching.</p>

<p>Combining resources is primarily an architectural and frontend concern: as much as possible, small images should be combined into a single sprite.  Then use CSS to set the offset and size to display only the portion of the image you want.  <a data-type="indexterm" data-primary="SpritePad" id="idm45053577969480"/>For creating sprites, I highly recommend the free service <a href="http://bit.ly/33GYvwm">SpritePad</a>.  It makes generating sprites incredibly easy, and it generates the CSS for you as well.  Nothing could be easier.  SpritePad’s free functionality is probably all you’ll ever need, but if you find yourself creating a lot of sprites, you might find their premium offerings worth it.</p>

<p><a data-type="indexterm" data-primary="browser caching" id="idm45053577967400"/>Browser caching helps reduce HTTP requests by storing commonly used static resources in the client’s browser.  Though browsers go to great lengths to make caching as automatic as possible, it’s not magic: there’s a lot you can and should do to enable browser caching of your static resources.</p>

<p>Lastly, we can increase performance by reducing the size of static resources.  Some techniques are <a data-type="indexterm" data-primary="lossless/lossy size reduction" id="idm45053577965752"/><em>lossless</em> (size reduction can be achieved without losing any data), and some techniques are <em>lossy</em> (size reduction is achieved by reducing the quality of static resources).  Lossless techniques include minification of JavaScript and CSS, and optimizing PNG images.  Lossy techniques include increasing JPEG and video compression levels.  We’ll be discussing minification and bundling (which also reduces HTTP requests) in this chapter.</p>
<div data-type="tip"><h6>Tip</h6>
<p>The importance of reducing HTTP requests will diminish over time as HTTP/2
becomes more commonplace.  One of the primary improvements in HTTP/2 is
<em>request and response multiplexing</em>, which reduces the overhead of fetching
multiple resources in parallel.  See <a href="http://bit.ly/34TXhxR">“Introduction to HTTP/2”</a> by Ilya Grigorikfor more information.</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Content Delivery Networks"><div class="sect1" id="idm45053577961048">
<h1>Content Delivery Networks</h1>

<p><a data-type="indexterm" data-primary="content delivery networks (CDNs)" data-secondary="basics" id="idm45053577959784"/><a data-type="indexterm" data-primary="static content" data-secondary="content delivery network basics" id="idm45053577958744"/>When you move your website into production, the static resources must be hosted on the internet <em>somewhere</em>.  You may be used to hosting them on the same server where all your dynamic HTML is generated.  Our example so far has also taken this approach: the Node/Express server we spin up when we type <code>node meadowlark.js</code> serves all of the HTML as well as static resources.  However, if you want to maximize the performance of your site (or allow for doing so in the future), you will want to make it easy to host your static resources on a <em>content delivery network</em> (CDN).  A CDN is a server that’s optimized for delivering static resources.  It leverages special headers (that we’ll learn about soon) that enable browser caching.</p>

<p><a data-type="indexterm" data-primary="edge caching" id="idm45053577955432"/><a data-type="indexterm" data-primary="geographic optimization" id="idm45053577954728"/>CDNs also can enable <em>geographic optimization</em> (often called <em>edge caching</em>); that is, they can deliver your static content from a server that is geographically closer to your client.  While the internet is very fast indeed (not operating at the speed of light, exactly, but close enough), it is still faster to deliver data over a hundred miles than a thousand.  Individual time savings may be small, but if you multiply across all of your users, requests, and resources, it adds up fast.</p>

<p>Most of your static resources will be referenced in HTML views (<code>&lt;link&gt;</code>
elements to CSS files, <code>&lt;script&gt;</code> references to JavaScript files, <code>&lt;img&gt;</code>
tags referencing images, and multimedia embedding tags). It is also common to have static references in
CSS, usually the <code>background-image</code> property. Lastly, static resources are sometimes referenced in
JavaScript, such as JavaScript code that dynamically changes or inserts
<code>&lt;img&gt;</code> tags or the <code>background-image</code> property.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p><a data-type="indexterm" data-primary="cross-domain resource sharing" id="idm45053577948248"/>You generally don’t have to worry about cross-domain resource sharing (CORS) when using a CDN.  External resources loaded in HTML aren’t subject to CORS policy: you have to enable CORS only for resources that are loaded via Ajax (see <a data-type="xref" href="ch15.xhtml#ch_rest_apis_and_json">Chapter 15</a>).</p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Designing for CDNs"><div class="sect1" id="idm45053577946088">
<h1>Designing for CDNs</h1>

<p><a data-type="indexterm" data-primary="content delivery networks (CDNs)" data-secondary="designing for" id="ix_ch-17-static_content-asciidoc1"/><a data-type="indexterm" data-primary="static content" data-secondary="designing for CDNs" id="ix_ch-17-static_content-asciidoc2"/>The architecture of your site will influence how you use a CDN.  Most CDNs let you configure routing rules to determine where to send incoming requests.  While you can get arbitrarily sophisticated with those routing rules, it usually boils down to sending requests for static assets to one location (usually provided by your CDN) and requests for dynamic endpoints (like dynamic pages or API endpoints) to another.</p>

<p>Choosing and configuring a CDN is a big topic, which I won’t get into here, but I will arm you with background knowledge that will help you configure your CDN of choice.</p>

<p>The easiest approach to structuring your application is to make it easy to distinguish dynamic from static assets to make the CDN routing rules as simple as possible.  While it’s possible to do this using subdomains (dynamic assets are served from <code>meadowlark.com</code>, and static assets are served from <code>static.meadowlark.com</code>, for example), this approach has extra complications and makes local development more difficult.  The easier approach is to use the request paths: everything that starts with <code>/public/</code> is a static asset, and everything else is dynamic, for example.  The approach may be different if you’re generating your content with Express or using Express to provide an API for a single-page application.</p>








<section data-type="sect2" data-pdf-bookmark="Server-Rendered Website"><div class="sect2" id="idm45053577938568">
<h2>Server-Rendered Website</h2>

<p><a data-type="indexterm" data-primary="content delivery networks (CDNs)" data-secondary="server-rendered website" id="idm45053577937128"/><a data-type="indexterm" data-primary="websites" data-secondary="server-rendered" id="idm45053577936088"/>If you’re using Express to render your dynamic HTML, it’s easier to say, “Everything that starts with <code>/static/</code> is a static asset, and everything else is dynamic.”  With this approach, all of your (dynamically generated) URLs would be whatever you want them to be (as long as they don’t start with <code>/static/</code>, of course!), and all of your static assets will be prefixed with <code>/static/</code>:</p>

<pre data-type="programlisting" data-code-language="html">  <code class="nt">&lt;img</code> <code class="na">src=</code><code class="s">"/static/img/meadowlark-logo-1.png"</code> <code class="na">alt=</code><code class="s">"Meadowlark Logo"</code><code class="nt">&gt;</code>
  Welcome to <code class="nt">&lt;a</code> <code class="na">href=</code><code class="s">"/about"</code><code class="nt">&gt;</code>Meadowlark Travel<code class="nt">&lt;/a&gt;</code>.</pre>

<p><a data-type="indexterm" data-primary="static middleware" id="idm45053577861032"/>So far in this book, we’ve been using the Express <code>static</code> middleware as if
it were hosting all of the static assets at the root.  That is, if we put a
static asset <em>foo.png</em> in the <em>public</em> directory, we reference it with the
URL path <em>/foo.png</em>, not <em>/static/foo.png</em>.  We could, of course, create a
subdirectory <em>static</em> inside our existing <em>public</em> directory, so
<em>/public/static/foo.png</em> would have the URL <em>/static/foo.png</em> but that
seems a little silly.  Fortunately, the <code>static</code> middleware saves us from
that silliness.  All we have to do is specify a different path when we call
<code>app.use</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="s1">'/static'</code><code class="p">,</code> <code class="nx">express</code><code class="p">.</code><code class="kr">static</code><code class="p">(</code><code class="s1">'public'</code><code class="p">))</code></pre>

<p>Now we can use the same URL structure in our development environment that we will in production.  If we’re careful about keeping our <em>public</em> directory in sync with what’s in our CDN, we can reference the same static assets in both places, and move seamlessly between development and production.</p>

<p>When we configure routing for our CDN (you’ll have to consult your CDN’s documentation for this), your routing will look like this:</p>
<table>

<thead>
<tr>
<th>URL path</th>
<th>Routing destination / origin</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>/static/*</p></td>
<td><p>Static CDN file store</p></td>
</tr>
<tr>
<td><p>/* (everything else)</p></td>
<td><p>Your Node/Express server, proxy, or load balancer</p></td>
</tr>
</tbody>
</table>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Single-Page Applications"><div class="sect2" id="idm45053577836680">
<h2>Single-Page Applications</h2>

<p><a data-type="indexterm" data-primary="content delivery networks (CDNs)" data-secondary="single-page applications" id="idm45053577835464"/><a data-type="indexterm" data-primary="single-page applications (SPAs)" data-secondary="CDNs and" id="idm45053577834552"/>Single-page applications will typically be the opposite of a server-rendered website: only the API will be routed to your server (for example, any request prefixed with <em>/api</em>), and everything else will be rerouted to your static file store.</p>

<p>As we saw in <a data-type="xref" href="ch16.xhtml#ch_single_page_applications">Chapter 16</a>, you will have some way to create a production bundle for your application, which will include all of the static resources, which you’ll upload to your CDN.  Then all you have to do is make sure routing to your API is configured correctly.  So your routing will look like this:</p>
<table>

<thead>
<tr>
<th>URL path</th>
<th>Routing destination / origin</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>/api/*</p></td>
<td><p>Your Node/Express server, proxy, or load balancer</p></td>
</tr>
<tr>
<td><p>/* (everything else)</p></td>
<td><p>Static CDN file store</p></td>
</tr>
</tbody>
</table>

<p>Now that we’ve seen how we might structure an application so we can seamlessly move from development to production, let’s turn our attention to what’s actually happening with caching and how it improves performance.<a data-type="indexterm" data-startref="ix_ch-17-static_content-asciidoc2" id="idm45053577824936"/><a data-type="indexterm" data-startref="ix_ch-17-static_content-asciidoc1" id="idm45053577824216"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Caching Static Assets"><div class="sect1" id="idm45053577823400">
<h1>Caching Static Assets</h1>

<p><a data-type="indexterm" data-primary="caching" data-secondary="static assets" id="idm45053577821992"/><a data-type="indexterm" data-primary="static content" data-secondary="caching static assets" id="idm45053577801896"/>Whether you’re using Express to serve static assets or using a CDN, it’s helpful to understand the HTTP response headers your browser uses to determine when and how to cache static assets:</p>
<dl>
<dt><code>Expires</code>/<code>Cache-Control</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="Cache-Control header" id="idm45053577799048"/><a data-type="indexterm" data-primary="Expires header" id="idm45053577798440"/>These two headers tell your browser the maximum amount of time a resource can be cached.  They are taken seriously by the browser: if they inform the browser to cache something for a month, it simply won’t re-download it for a month, as long as it stays in the cache.  It’s important to understand that a browser may remove the image from the cache prematurely, for reasons you have no control over.  For example, the user could clear the cache manually, or the browser could clear your resource to make room for other resources the user is visiting more frequently.  You need one only of these headers, and <code>Expires</code> is more broadly supported, so it’s preferable to use that one.  If the resource is in the cache, and it has not expired yet, the browser will not issue a <code>GET</code> request at all, which improves performance, especially on mobile.</p>
</dd>
<dt><code>Last-Modified</code>/<code>ETag</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="ETag header" id="idm45053577794248"/><a data-type="indexterm" data-primary="Last-Modified header" id="idm45053577793320"/>These two tags provide a versioning of sorts: if the browser needs to fetch the resource, it will examine these tags <em>before</em> downloading the content.  A <code>GET</code> request is still issued to the server, but if the values returned by these headers satisfy the browser that the resource hasn’t changed, it will not proceed to download the file.  As the name indicates, <code>Last-Modified</code> allows you to specify the date the resource was last modified.  <code>ETag</code> allows you to use an arbitrary string, which is usually a version string or a content hash.</p>
</dd>
</dl>

<p>When serving static resources, you should use the <code>Expires</code> header <em>and</em> either <code>Last-Modified</code> or <code>ETag</code>.  The Express built-in <code>static</code> middleware sets <code>Cache-Control</code>, but doesn’t handle either <code>Last-Modified</code> or <code>ETag</code>.  So, while it’s suitable for development, it’s not a great solution for deployment.</p>

<p>If you choose to host your static resources on a CDN, such as Amazon CloudFront, Microsoft Azure, Fastly, Cloudflare, Akamai, or StackPath, the advantage is that they will handle most of these details for you.  You will be able to fine-tune the details, but the defaults provided by any of these services are usually good out of the box.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Changing Your Static Content"><div class="sect1" id="idm45053577785256">
<h1>Changing Your Static Content</h1>

<p><a data-type="indexterm" data-primary="static content" data-secondary="changing" id="idm45053577783912"/>Caching significantly improves the performance of your website, but it isn’t without its consequences.  In particular, if you change any of your static resources, clients may not see them until the cached versions expire in your browser.  Google recommends you cache for a month, preferably a year.  Imagine a user who uses your website every day on the same browser: that person might not see your updates for a whole year!</p>

<p>Clearly this is an undesirable situation, and you can’t just tell your users to clear their cache.  The solution is cache busting. <a data-type="indexterm" data-primary="cache busting" id="idm45053577781832"/><em>Cache busting</em> is a technique for giving you control of when your user’s browser is forced to re-download an asset.  Usually this amounts to versioning the asset (<em>main.2.css</em> or <em>main.css?version=2</em>) or adding some kind of hash (<em>main.e16b7e149dccfcc399e025e0c454bf77.css</em>).  Whatever technique you use, when you update the asset, the resource name changes, and the browser knows it needs to download it.</p>

<p>We can do the same thing with our multimedia assets.  Let’s take our logo, for example (<em>/static/img/meadowlark_logo.png</em>).  If we host it on a CDN for maximum performance, specifying an expiration of one year, and then change the logo, your users may not see the updated logo for up to a year.  However, if you rename your logo <em>/static/img/meadowlark_logo-1.png</em> (and reflect that name change in your HTML), the browser will be forced to download it, because it looks like a new resource.</p>

<p>If you’re using a single-page application framework, such as <code>create-react-app</code> or similar, they will provide a build step that will create production-ready resource bundles that have hashes appended.</p>

<p><a data-type="indexterm" data-primary="bundlers" id="idm45053577776200"/>If you’re starting from scratch, you’ll probably want to look into a <em>bundler</em> (which is what the SPA frameworks use under the hood).  Bundlers combine your JavaScript, CSS, and some other types of static assets into as few as possible, and minify the result (making it as small as possible).  Bundler configuration is a big topic, but fortunately there is a lot of good documentation out there.  The most popular bundlers available right now are as follows:</p>
<dl>
<dt><a href="https://webpack.js.org">Webpack</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="Webpack" id="idm45053577772584"/>Webpack was one of the first bundlers to really take off, and it still maintains a huge following.  It’s very sophisticated, but that sophistication comes at a cost: the learning curve is steep.  However, it’s good to at least know the basics.</p>
</dd>
<dt><a href="https://parceljs.org">Parcel</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="Parcel" id="idm45053577769944"/>Parcel is the newcomer, and it has made a big splash.  It’s extremely well-documented, extremely fast, and, best of all, has the shortest learning curve.  If you’re looking to get the job done quickly, without a lot of fuss, start here.</p>
</dd>
<dt><a href="https://rollupjs.org">Rollup</a></dt>
<dd>
<p><a data-type="indexterm" data-primary="Rollup" id="idm45053577767400"/>Rollup sits somewhere between Webpack and Parcel. Like Webpack, it’s very robust and has a lot of features. However, it is easier to get started with than Webpack, and not as simple as Parcel.</p>
</dd>
</dl>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45053577766200">
<h1>Conclusion</h1>

<p>For what seems like such a simple thing, static resources can be a lot of trouble.  However, they probably represent the bulk of the data actually being transferred to your visitors, so spending some time optimizing them will yield substantial payoff.</p>

<p>A viable solution to static assets not previously mentioned is to simply host your static resources on a CDN from the start, and always use the full URL to the resource in your views and CSS.  This has the advantage of simplicity, but if you ever want to spend a weekend hackathon at that cabin in the woods without internet access, you’d be in trouble!</p>

<p>Elaborate bundling and minification is another area in which you can save time if the payoff isn’t worth it for your application.  In particular, if your site includes only one or two JavaScript files, and all of your CSS lives in a single file, you could probably skip bundling altogether, but real-world applications have a tendency to grow over time.</p>

<p>Whatever technique you choose to use to serve your static resources, I highly recommend hosting them separately, preferably on a CDN.  If it sounds like a hassle to you, let me assure that it’s not nearly as difficult as it sounds, especially if you spend a little time on your deployment system, so deploying static resources to one location and your application to another is automatic.</p>

<p>If you’re concerned about the hosting costs of CDNs, I encourage you to take a look at what you’re paying now for hosting.  Most hosting providers essentially charge for bandwidth, even if you don’t know it.  However, if all of a sudden your site is mentioned on Slashdot, and you get “Slashdotted,” you may find yourself with a hosting bill you didn’t expect.  CDN hosting is usually set up so that you pay for what you use.  To give you an example, a website that I once managed for a medium-sized regional company, which used about 20 GB a month of bandwidth, paid only a few dollars per month to host static resources (and it was a very media-heavy site).</p>

<p>The performance gains you realize by hosting your static resources on a CDN are significant, and the cost and inconvenience of doing so is minimal, so I highly recommend going this route.<a data-type="indexterm" data-startref="ix_ch-17-static_content-asciidoc0" id="idm45053577760408"/></p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm45053577982616"><sup><a href="ch17.xhtml#idm45053577982616-marker">1</a></sup> It is possible to use uncompiled LESS in a browser, with some JavaScript magic.  There are performance consequences to this approach, so I don’t recommend it.</p></div></div></section></div>



  </body></html>