<html><head></head><body><div id="sbo-rt-content" class="calibre1"><section data-type="appendix" epub:type="appendix" data-pdf-bookmark="Appendix. Structured Clone Algorithm" class="calibre4"><div class="preface" id="app_sca">
<h1 class="calibre12"><span class="keep-together">Appendix. </span>Structured Clone Algorithm</h1>


<p class="author1">The <em class="calibre7">structured clone algorithm</em> is a mechanism <a data-type="indexterm" data-primary="structured clone algorithm" id="structclone" class="calibre6"/><a data-type="indexterm" data-primary="clones" data-see="structured clone algorithm" id="idm45995909008088" class="calibre6"/>that JavaScript engines use when copying objects using certain APIs. Most notably, it’s used when passing data between workers, though other APIs use it as well. With this mechanism, data is serialized and then later deserialized as an object inside another JavaScript realm.</p>

<p class="author1">When objects are cloned in this manner, such as from the main thread to a worker thread or from one worker to another, modifying an object on one side will not affect the object on the other side. There are essentially two copies of the data now. The purpose of the structured clone algorithm is to provide a friendlier mechanism for developers than what <code class="calibre18">JSON.stringify</code> does, while imposing reasonable limitations.</p>

<p class="author1">Browsers use the structured clone algorithm when <a data-type="indexterm" data-primary="browser" data-secondary="structured clone algorithm" id="idm45995908911528" class="calibre6"/>copying data between web workers. Node.js, similarly, uses it when copying data between worker threads. Basically, when you see a <code class="calibre18">.postMessage()</code> call, data being passed in is cloned in this way. Browsers and Node.js follow the same rules, but they each support additional object instances that can be copied.</p>

<p class="author1">As a quick rule of thumb, any data that can be cleanly represented as JSON can be safely cloned in this manner. Sticking to data represented in this manner will certainly lead to very few surprises. That said, the structured clone algorithm supports several other types of data as well.</p>

<p class="author1">First off, all of the primitive data types available in JavaScript, with the exception of the <code class="calibre18">Symbol</code> type, can be represented. This includes the <code class="calibre18">Boolean</code>, <code class="calibre18">null</code>, <code class="calibre18">undefined</code>, 
<span class="keep-together"><code class="calibre18">Number</code></span>, <code class="calibre18">BigInt</code>, and <code class="calibre18">String</code> types.</p>

<p class="author1">Instances of <code class="calibre18">Array</code>, <code class="calibre18">Map</code>, and <code class="calibre18">Set</code>, which are each used for storing collections of data, can also be cloned in this manner. Even <code class="calibre18">ArrayBuffer</code>, <code class="calibre18">ArrayBufferView</code>, and <code class="calibre18">Blob</code> instances, which store binary data, can be passed along.</p>

<p class="author1">Instances of some more complex objects, as long as they are quite universal and well understood, can also be passed through. This includes <a data-type="indexterm" data-primary="constructors" data-secondary="Boolean" id="idm45995908900840" class="calibre6"/><a data-type="indexterm" data-primary="constructors" data-secondary="String" id="idm45995908899864" class="calibre6"/>objects created using the <code class="calibre18">Boolean</code> and <code class="calibre18">String</code> constructor, <code class="calibre18">Date</code>, and even <code class="calibre18">RegExp</code> instances.<sup class="calibre39"><a data-type="noteref" id="idm45995908897064-marker" href="app01.xhtml#idm45995908897064" class="calibre40">1</a></sup></p>

<p class="author1">On the browser side, more complex and lesser-known object instances like those for <code class="calibre18">File</code>, <code class="calibre18">FileList</code>, <code class="calibre18">ImageBitmap</code>, and <code class="calibre18">ImageData</code> can be cloned.</p>

<p class="author1">On the Node.js side, special object instances that can be copied over include <code class="calibre18">WebAssembly.Module</code>, <code class="calibre18">CryptoKey</code>, <code class="calibre18">FileHandle</code>, <code class="calibre18">Histogram</code>, <code class="calibre18">KeyObject</code>, <code class="calibre18">MessagePort</code>, <code class="calibre18">net.BlockList</code>, <code class="calibre18">net.SocketAddress</code>, and <code class="calibre18">X509Certificate</code>. Even instances of <code class="calibre18">R⁠e⁠a⁠da⁠b⁠l⁠e⁠S⁠t⁠r⁠e⁠a⁠m</code>, <code class="calibre18">WritableStream</code>, and <code class="calibre18">TransformStream</code> can be copied.</p>

<p class="author1">Another notable difference that works with the structured clone algorithm, but doesn’t work with JSON objects, is that recursive objects (those with nested properties that reference another property) can also be cloned. The algorithm is smart enough to stop serializing an object once it encounters a duplicate, nested object.</p>

<p class="author1">There are several shortcomings that may affect your implementations. First, a function cannot be cloned in this manner. Functions can be pretty complex things. For example, they have a scope available and can access variables declared outside of them. Passing something like that between realms wouldn’t make a whole lot of sense.</p>

<p class="author1">Another missing feature, which will likely affect your implementations, is that DOM elements in the browser cannot be passed along. Does this mean that the work that a web worker performs can’t be displayed to the user in the DOM? Absolutely not. Instead, you’ll need to have a web worker return a value that the main JavaScript realm is then able to transform and display to the user. For example, if you were to calculate 1,000 iterations of <code class="calibre18">fibonacci</code> in a web worker, the numeric value could be returned, and the calling JavaScript code could then take that value and place it in the DOM.</p>

<p class="author1">Objects in JavaScript are fairly complex. Sometimes they can be created using the object literal syntax. Other times they can be created by instantiating a base class. And still other times they can be modified by setting property descriptors and setters and getters. When it comes to the structured clone algorithm, only the basic values of objects are retained.</p>

<p class="author1">Most notably, this means that, when you define a class of your own and pass an instance to be cloned, only the own properties of that instance will be cloned, and the resulting object will be an instance of <code class="calibre18">Object</code>. Properties defined in the prototype will not be cloned either. Even if you define <code class="calibre18">class Foo {}</code> both on the calling side and inside the web worker, the value will still be an instance of <code class="calibre18">Object</code>. This is because there’s no real way to guarantee that both sides of the clone are dealing with the exact same <code class="calibre18">Foo</code> class.<sup class="calibre39"><a data-type="noteref" id="idm45995908881016-marker" href="app01.xhtml#idm45995908881016" class="calibre40">2</a></sup></p>

<p class="author1">Certain objects will entirely refuse to be cloned. For example, if you try to pass <code class="calibre18">window</code> from the main thread to a worker thread, or if you try to return <code class="calibre18">self</code> in the opposite direction, you may receive one of the following errors, depending on the browser:</p>

<pre data-type="programlisting" class="calibre38">Uncaught DOMException: The object could not be cloned.
DataCloneError: The object could not be cloned.</pre>

<p class="author1">There are some inconsistencies across JavaScript <a data-type="indexterm" data-primary="structured clone algorithm" data-startref="structclone" id="idm45995908876904" class="calibre6"/>engines, so it’s best to test your code in multiple browsers. For example, Chrome and Node.js support cloning <code class="calibre18">Error</code> instances, but Firefox currently does not.<sup class="calibre39"><a data-type="noteref" id="idm45995908875256-marker" href="app01.xhtml#idm45995908875256" class="calibre40">3</a></sup> The general rule of thumb is that JSON-compatible objects should never be a problem, but more complex data might be. For that reason, passing around simpler data is usually best.</p>
<div data-type="footnotes" class="calibre41"><p data-type="footnote" id="idm45995908897064" class="calibre42"><sup class="calibre43"><a href="app01.xhtml#idm45995908897064-marker" class="calibre40">1</a></sup> There is a small caveat with <code class="calibre18">RegExp</code> instances. They contain a <code class="calibre18">.lastIndex</code> property, which is used when running a regular expression multiple times over the same string to know where the expression last ended. This property is not passed along.</p><p data-type="footnote" id="idm45995908881016" class="calibre42"><sup class="calibre43"><a href="app01.xhtml#idm45995908881016-marker" class="calibre40">2</a></sup> There are proposals to allow serializing and deserializing class instances, such as <a href="https://oreil.ly/HZUyz" class="calibre6">“User-defined structured clone for JavaScript objects”</a>, so this restriction might not be permanent.</p><p data-type="footnote" id="idm45995908875256" class="calibre42"><sup class="calibre43"><a href="app01.xhtml#idm45995908875256-marker" class="calibre40">3</a></sup> Firefox is planning on supporting this eventually. See <a href="https://oreil.ly/wT4NG" class="calibre6">“Allow structured cloning of native error types”</a>.</p></div></div></section></div></body></html>