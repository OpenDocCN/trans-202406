["```\nfun main() = runBlocking {\n    val job: Job = launch {\n        var i = 0\n        while (true) {\n            println(\"$i I'm working\")\n            i++\n            delay(10)\n        }\n    }\n\n    delay(30)\n    job.cancel()\n}\n```", "```\n0 I'm working\n1 I'm working\n2 I'm working\n```", "```\nfun main() = runBlocking {\n    val job: Job = launch {\n        while (true) {\n            println(\"I'm working\")\n            Thread.sleep(10L)\n        }\n    }\n\n    delay(30)\n    job.cancel()\n}\n```", "```\nI'm working\nI'm working\nI'm working\nI'm working\nI'm working\nI'm working\nI'm working\nI'm working\nI'm working\nI'm working\nI'm working\n.....\n```", "```\nclass WorkingClass() {\n    public CompletableFuture<SomeOtherResult> doBothAsync() {\n        somethingAsync().thenAcceptBoth(somethingElseAsync()) {\n            one, two ->\n            // combine results of both calls here\n        };\n    }\n}\n```", "```\nfun main() = runBlocking {\n    val slow: Deferred<Int> = async {\n        var result = 0\n        delay(1000)   // simulate some slow background work\n        for (i in 1..10) {\n            result += i\n        }\n        println(\"Call complete for slow: $result\")\n        result\n    }\n\n    val quick: Deferred<Int> = async {\n        delay(100)   // simulate some quick background work\n        println(\"Call complete for quick: 5\")\n        5\n    }\n\n    val result: Int = quick.await() + slow.await()\n    println(result)\n}\n```", "```\nCall complete for quick: 5\nCall complete for slow: 55\n60\n```", "```\ninterface UncaughtExceptionHandler {\n    fun uncaughtException(t: Thread, e: Throwable)\n}\n```", "```\nfun main() {\n   launch {\n       println(\"I'm working\")       // will not compile\n   }\n}\n```", "```\nfun <T> runBlocking(\n    // function arguments removed for brevity\n    block: suspend CoroutineScope.() -> T): T { // impl\n}\n```", "```\nfun main() = launch {\n    println(\"I'm a coroutine\")\n}\n```", "```\nfun CoroutineScope.launch(\n    context: CoroutineContext = EmptyCoroutineContext,\n    // other params removed for brevity,\n    block: suspend CoroutineScope.() -> Unit\n): Job { /* implementation */ }\n```", "```\ninterface CoroutineScope {\n    val coroutineContext: CoroutineContext\n}\n```", "```\nfun main() = runBlocking<Unit> {\n    launch(Dispatchers.Default) {\n        println(\"I'm executing in ${Thread.currentThread().name}\")\n    }\n}\n```", "```\nI'm executing in DefaultDispatcher-worker-2 @coroutine#2\n```", "```\nfun main() = runBlocking<Unit>(Dispatchers.Main) {\n    launch(Dispatchers.Default) {\n        val threadName = Thread.currentThread().name\n        println(\"I'm executing in $threadName\")\n    }\n}\n```", "```\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful\n     * or failed [result] as the return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n```", "```\nsuspend fun backgroundWork(): Int {\n    // some background work on another thread, which returns an Int\n}\n```", "```\nfun backgroundWork(callback: Continuation<Int>): Int {\n    // some background work on another thread, which returns an Int\n}\n```", "```\nsuspend fun renderImage() {\n    val path: String = getPath()\n    val image = fetchImage(path)    // first suspension point (fetchImage is a suspending function)\n    val clipped = clipImage(image)  // second suspension point (clipImage is a suspending function)\n    postProcess(clipped)\n}\n\n/** Here is an example of usage of the [renderImage] suspending function */\nfun onStart() {\n    viewModelScope.launch(Dispatchers.IO) {\n        renderImage()\n    }\n}\n```", "```\nobject : Continuation<Unit>  {\n   // state\n   private var state = 0\n\n   // fields\n   private var path: String? = null\n   private var image: Image? = null\n\n   fun resumeWith(result: Any) {\n      when (state) {\n         0 -> {\n            path = getPath()\n            state = 1\n            // Pass this state machine as Continuation.\n            val firstResult = fetchImage(path, this)\n            if (firstResult == COROUTINE_SUSPENDED) return\n            // If we didn't get COROUTINE_SUSPENDED, we received an\n            // actual Image instance, execution shall proceed to\n            // the next state.\n            resumeWith(firstResult)\n         }\n         1 -> {\n            image = result as Image\n            state = 2\n            val secondResult = clipImage(image, this)\n            if (secondResult == COROUTINE_SUSPENDED) return\n               resumeWith(secondResult)\n            }\n         2 -> {\n            val clipped = result as Image\n            postProcess(clipped)\n         }\n         else -> throw IllegalStateException()\n      }\n   }\n}\n```", "```\nfun fetchAndLoadProfile(id: String) {\n    scope.launch {                                          ![1](assets/1.png)\n        val profileDeferred = async(Dispatchers.Default) {  ![2](assets/2.png)\n            fetchProfile(id)\n        }\n        val profile = profileDeferred.await()               ![3](assets/3.png)\n        loadProfile(profile)                                ![4](assets/4.png)\n    }\n}\n```", "```\nsuspend fun backgroundWork(): Int {\n    // some background work on another thread, which returns an Int\n}\n```", "```\nsuspend fun fetchProfile(id: String): Profile {\n    // for now, weâ€™re not showing the implementation\n}\n```", "```\nfun fetchAndLoadProfile(id: String) {\n    scope.launch {\n        val profile = fetchProfile(id)   // suspends\n        loadProfile(profile)\n    }\n}\n```", "```\nsuspend fun fetchProfile(id: String) = withContext(Dispatchers.Default) {\n   // same implementation as the original fetchProfile, which returns a Profile instance\n}\n```", "```\n    launch(Dispatchers.Main) {\n       async {\n          // inherits the context of the parent, so is dispatched on\n          // the main thread\n       }\n    }\n    ```"]