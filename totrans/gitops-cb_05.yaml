- en: Chapter 4\. Kustomize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying to a Kubernetes cluster is, in summary, applying some YAML files and
    checking the result.
  prefs: []
  type: TYPE_NORMAL
- en: The hard part is developing the initial YAML files version; after that, usually,
    they suffer only small changes such as updating the container image tag version,
    the number of replicas, or a new configuration value. One option is to make these
    changes directly in the YAML files—it works, but any error in this version (modification
    of the wrong line, deleting something by mistake, putting in the wrong whitespace)
    might be catastrophic.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, some tools let you define base Kubernetes manifests (which
    change infrequently) and specific files (maybe one for each environment) for setting
    the parameters that change more frequently. One of these tools is Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you’ll learn how to use Kustomize to manage Kubernetes resource
    files in a template-free way without using any DSL.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a Kustomize project and deploy it to a Kubernetes
    cluster (see [Recipe 4.1](#recipe_4_1)).
  prefs: []
  type: TYPE_NORMAL
- en: After the first deployment, the application is automatically updated with a
    new container image, a new configuration value, or any other field, such as the
    replica number (see Recipes [4.2](#recipe_4_2) and [4.3](#recipe_4_3)).
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve got several running environments (i.e., staging, production, etc.),
    you need to manage them similarly. Still, with its particularities, Kustomize
    lets you define a set of custom values per environment (see [Recipe 4.4](#recipe_4_4)).
  prefs: []
  type: TYPE_NORMAL
- en: Application configuration values are properties usually mapped as a Kubernetes
    `ConfigMap`. Any change (and its consequent update on the cluster) on a `ConfigMap`
    doesn’t trigger a rolling update of the application, which means that the application
    will run with the previous version until you manually restart it.
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize provides some functions to automatically execute a rolling update
    when the `ConfigMap` of an application changes (see [Recipe 4.5](#recipe_4_5)).
  prefs: []
  type: TYPE_NORMAL
- en: 4.1 Using Kustomize to Deploy Kubernetes Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy several Kubernetes resources at once.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use [Kustomize](https://kustomize.io) to configure which resources to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying an application to a Kubernetes cluster isn’t as trivial as just applying
    one YAML/JSON file containing a Kubernetes `Deployment` object. Usually, other
    Kubernetes objects must be defined like `Service`, `Ingress`, `ConfigMaps`, etc.,
    which makes things a bit more complicated in terms of managing and updating these
    resources (the more resources to maintain, the more chance to update the wrong
    one) as well as applying them to a cluster (should we run multiple `kubectl` commands?).
  prefs: []
  type: TYPE_NORMAL
- en: Kustomize is a CLI tool, integrated within the `kubectl` tool to manage, customize,
    and apply Kubernetes resources in a *template-less* way.
  prefs: []
  type: TYPE_NORMAL
- en: With Kustomize, you need to set a base directory with standard Kubernetes resource
    files (no placeholders are required) and create a *kustomization.yaml* file where
    resources and customizations are declared, as you can see in [Figure 4-1](#fig-411).
  prefs: []
  type: TYPE_NORMAL
- en: '![Kustomize layout](assets/gocb_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-1\. Kustomize layout
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s deploy a simple web page with HTML, JavaScript, and CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: First, open a terminal window and create a directory named *pacman*, then create
    three Kubernetes resource files to create a `Namespace`, a `Deployment`, and a
    `Service` with the following content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The namespace at *pacman/namespace.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The deployment file at *pacman/deployment.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The service file at *pacman/service.yaml*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that these files are Kubernetes files that you could apply to a Kubernetes
    cluster without any problem as no special characters or placeholders are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second thing is to create the *kustomization.yaml* file in the *pacman*
    directory containing the list of resources that belongs to the application and
    are applied when running Kustomize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Kustomization file
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Resources belonging to the application processed in depth-first order
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can apply the kustomization file into a running cluster by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Prints the result of the kustomization run, without sending the result to the
    cluster
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: With `-k` option sets `kubectl` to use the kustomization file
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Directory with parent *kustomization.yaml* file
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We assume you’ve already started a *Minikube* cluster as shown in [Recipe 2.3](ch02.xhtml#recipe_2_3).
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is the YAML file that would be sent to the server if the `dry-run`
    option was not used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List of all Kubernetes objects defined in *kustomization.yaml* to apply
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The namespace document
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The service document
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_kustomize_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The deployment document
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `resources` section supports different inputs in addition to directly setting
    the YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can set a base directory with its own *kustomization.yaml*
    and Kubernetes resources files and refer it from another *kustomization.yaml*
    file placed in another directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following directory layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'And the Kustomization definitions in the *base* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see that the root directory has a link to the *base* directory and a
    `ConfigMap` definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: So, applying the root kustomization file will automatically apply the resources
    defined in the base kustomization file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, `resources` can reference external assets from a URL following the [HashiCorp
    URL](https://oreil.ly/lbeQC) format. For example, we refer to a GitHub repository
    by setting the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Repository with a root-level *kustomization.yaml* file
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Repository with a root-level *kustomization.yaml* file on branch test
  prefs: []
  type: TYPE_NORMAL
- en: You’ve seen the application of a Kustomize file using `kubectl`, but Kustomize
    also comes with its own CLI tool offering a set of commands to interact with Kustomize
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent command to build Kustomize resources using `kustomize` instead
    of `kubectl` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to apply this output generated by `kustomize` to the cluster, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kustomize](https://kustomize.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[kustomize/v4.4.1 on GitHub](https://oreil.ly/h2yNd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[HashiCorp URL format](https://oreil.ly/n7jwr)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.2 Updating the Container Image in Kustomize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to update the container image from a deployment file using Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `images` section to update the container image.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most important and most-used operations in software development is
    updating the application to a newer version either with a bug fix or with a new
    feature. In Kubernetes, this means that you need to create a new container image,
    and name it accordingly using the `tag` section (`<registry>/<username>/<project>:<tag>`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the following partial deployment file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Service 1.0.0 is deployed
  prefs: []
  type: TYPE_NORMAL
- en: 'We can update the version tag to 1.0.1 by using the `images` section in the
    *kustomization.yaml* file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`images` section'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the name of the image to *update*
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the new tag value for the image
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, use `kubectl` in `dry-run` or `kustomize` to validate that the output
    of the deployment file contains the new tag version. In a terminal window, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Version set in the `kustomize.yaml` file
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kustomize is not intrusive, which means that the original *deployment.yaml*
    file still contains the original tag (`1.0.0`).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way to update the `newTag` field is by editing the *kustomization.yaml*
    file, but you can also use the `kustomize` tool for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command in the same directory as the *kustomization.yaml*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the content of the *kustomization.yaml* file to see that the `newTag`
    field has been updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 4.3 Updating Any Kubernetes Field in Kustomize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to update a field (i.e., number of replicas) using Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `patches` section to specify a change using the JSON Patch specification.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous recipe, you saw how to update the container image tag, but sometimes
    you might change other parameters like the number of replicas or add annotations,
    labels, limits, etc.
  prefs: []
  type: TYPE_NORMAL
- en: To cover these scenarios, Kustomize supports the use of JSON Patch to modify
    any Kubernetes resource defined as a Kustomize resource. To use it, you need to
    specify the JSON Patch expression to apply and which resource to apply the patch
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can modify the number of replicas in the following partial
    deployment file from one to three:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'First, let’s update the *kustomization.yaml* file to modify the number of replicas
    defined in the deployment file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Patch resource.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '`target` section sets which Kubernetes object needs to be changed. These values
    match the deployment file created previously.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Patch expression.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_kustomize_CO8-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Modification of a value.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_kustomize_CO8-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Path to the field to modify.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_kustomize_CO8-6)'
  prefs: []
  type: TYPE_NORMAL
- en: New value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, use `kubectl` in `dry-run` or `kustomize` to validate that the output
    of the deployment file contains the new tag version. In a terminal window, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The *replicas* value can also be updated using the `replicas` field in the *kustomization.yaml*
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent Kustomize file using the `replicas` field is shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Deployment to update the replicas
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: New `replicas` value
  prefs: []
  type: TYPE_NORMAL
- en: 'Kustomize lets you add (or delete) values, in addition to modifying a value.
    Let’s see how to add a new label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a new field with value
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO10-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Path with the field to add
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO10-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The value to set
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of applying the file is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Added label
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of embedding a JSON Patch expression, you can create a YAML file with
    a Patch expression and refer to it using the `path` field instead of `patch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an external patch file named *external_patch* containing the JSON Patch
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'And change the `patch` field to `path` pointing to the patch file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Path to external patch file
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the JSON Patch expression, Kustomize also supports [Strategic
    Merge Patch](https://oreil.ly/vr3e3) to modify Kubernetes resources. In summary,
    a Strategic Merge Patch (or *SMP*) is an incomplete YAML file that is merged against
    a completed YAML file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only a minimal deployment file with container name information is required
    to update a container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO13-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Target is selected using label
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO13-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Patch is smart enough to detect if it is an SMP or JSON Patch
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO13-3)'
  prefs: []
  type: TYPE_NORMAL
- en: This is a minimal deployment file
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_kustomize_CO13-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets only the field to change, the rest is left as is
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated output is the original *deployment.yaml* file but with the new
    container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`path` is supported as well.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[RFC 6902: JavaScript Object Notation (JSON) Patch](https://oreil.ly/gDn1A)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Strategic Merge Patch](https://oreil.ly/vr3e3)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4.4 Deploying to Multiple Environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy the same application in different namespaces using Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `namespace` field to set the target namespace.
  prefs: []
  type: TYPE_NORMAL
- en: In some circumstances, it’s good to have the application deployed in different
    namespaces; for example, one namespace can be used as a *staging* environment,
    and another one as the *production* namespace. In both cases, the base Kubernetes
    files are the same, with minimal changes like the namespace deployed, some configuration
    parameters, or container version, to mention a few. [Figure 4-2](#fig-441) shows
    an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![Kustomize layout](assets/gocb_0402.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-2\. Kustomize layout
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`kustomize` lets you define multiple changes with a different namespace, as
    overlays on a common base using the `namespace` field. For this example, all base
    Kubernetes resources are put in the `base` directory and a new directory is created
    for customizations of each environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO14-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Base files
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO14-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Changes specific to production environment
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO14-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Changes specific to staging environment
  prefs: []
  type: TYPE_NORMAL
- en: 'The base kustomization file contains a reference to its resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There is a kustomization file with some parameters set for each environment
    directory. These reference the *base* directory, the namespace to inject into
    Kubernetes resources, and finally, the image to deploy, which in production is
    *1.1.0* but in staging is *1.2.0-beta*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the staging environment, *kustomization.yaml* content is shown in the following
    listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO15-1)'
  prefs: []
  type: TYPE_NORMAL
- en: References to *base* directory
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO15-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets namespace to *staging*
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO15-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the container tag for the *staging* environment
  prefs: []
  type: TYPE_NORMAL
- en: 'The kustomization file for production is similar to the staging one, but changes
    the namespace and the tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO16-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets namespace for *production*
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO16-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets the container tag for the *production* environment
  prefs: []
  type: TYPE_NORMAL
- en: 'Running `kustomize` produces different output depending on the directory where
    it is run; for example, running `kustomize build` in the *staging* directory produces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO17-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Namespace value is injected
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO17-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Container tag for the *staging* environment is injected
  prefs: []
  type: TYPE_NORMAL
- en: 'But if you run it in the *production* directory, the output is adapted to the
    production configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO18-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Injects the *production* namespace
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO18-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Container tag for the *production* environment
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kustomize can preappend/append a value to the names of all resources and references.
    This is useful when a different name in the resource is required depending on
    the environment, or to set the version deployed in the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO19-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Prefix to preappend
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO19-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Suffix to append
  prefs: []
  type: TYPE_NORMAL
- en: 'And the resulting output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO20-1)'
  prefs: []
  type: TYPE_NORMAL
- en: New name of the deployment file
  prefs: []
  type: TYPE_NORMAL
- en: 4.5 Generating ConfigMaps in Kustomize
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to generate Kubernetes `ConfigMap`s using Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the `ConfigMapGenerator` feature field to generate a Kubernetes `ConfigMap`
    resource on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Kustomize provides two ways of adding a `ConfigMap` as a Kustomize resource:
    either by declaring a `ConfigMap` as any other resource or declaring a `ConfigMap`
    from a `ConfigMapGenerator`.'
  prefs: []
  type: TYPE_NORMAL
- en: While using `ConfigMap` as a resource offers no other advantage than populating
    Kubernetes resources as any other resource, `ConfigMapGenerator` automatically
    appends a hash to the `ConfigMap` metadata name and also modifies the deployment
    file with the new hash. This minimal change has a deep impact on the application’s
    lifecycle, as we’ll see soon in the example.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider an application running in Kubernetes and configured using a `ConfigMap`—for
    example, a database timeout connection parameter. We decided to increase this
    number at some point, so the `ConfigMap` file is changed to this new value, and
    we deploy the application again. Since the `ConfigMap` is the only changed file,
    no rolling update of the application is done. A manual rolling update of the application
    needs to be triggered to propagate the change to the application. [Figure 4-3](#fig-451)
    shows what is changed when a `ConfigMap` object is updated.
  prefs: []
  type: TYPE_NORMAL
- en: '![A change on the ConfigMap object](assets/gocb_0403.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-3\. Change of a `ConfigMap`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But, if `ConfigMapGenerator` manages the `ConfigMap`, any change on the configuration
    file also changes the deployment Kubernetes resource. Since the deployment file
    has changed too, an automatic rolling update is triggered when the resources are
    applied, as shown in [Figure 4-4](#fig-452).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, when using `ConfigMapGenerator`, multiple configuration datafiles
    can be combined into a single `ConfigMap`, making a perfect use case when every
    environment has different configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: '![Change of a ConfigMap using ConfigMapGenerator](assets/gocb_0404.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4-4\. Change of a `ConfigMap` using `ConfigMapGenerator`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Let’s start with a simple example, adding the `ConfigMapGenerator` section in
    the *kustomization.yaml* file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The deployment file is similar to the one used in previous sections of this
    chapter but includes the `volumes` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO21-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfigMap` name is used in the *kustomization.yaml* file'
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration properties are embedded within the *kustomization.yaml* file.
    Notice that the `ConfigMap` object is created on the fly when the kustomization
    file is built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO22-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the `ConfigMap` set in the deployment file
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO22-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Embeds configuration values in the file
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO22-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a key/value pair for the properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, use `kubectl` in `dry-run` or `kustomize` to validate that the output
    of the deployment file contains the new tag version. In a terminal window, run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the preceding command is a new `ConfigMap` with the configuration
    values set in *kustomization.yaml*. Moreover, the name of the `ConfigMap` is updated
    by appending a hash in both the generated `ConfigMap` and deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO23-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConfigMap` with properties'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO23-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Name with hash
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO23-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Name field is updated to the one with the hash triggering a rolling update
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the hash is calculated for any change in the configuration properties,
    a change on them provokes a change on the output triggering a rolling update of
    the application. Open the *kustomization.yaml* file and update the `db-timeout`
    literal from 2000 to 1000 and run `kustomize build` again. Notice the change in
    the `ConfigMap` name using a new hashed value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO24-1)'
  prefs: []
  type: TYPE_NORMAL
- en: New hashed value
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ConfigMapGenerator` also supports merging configuration properties from different
    sources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new *kustomization.yaml* file in the *dev_literals* directory, setting
    it as the previous directory and overriding the `db-username` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO25-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Base directory
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO25-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Merge properties (can be `create` or `replace` too)
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_kustomize_CO25-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Overridden value
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `kustomize build` command produces a `ConfigMap` containing a merge
    of both configuration properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO26-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Inherits from base
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO26-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Overrides value
  prefs: []
  type: TYPE_NORMAL
- en: In addition to setting configuration properties as literals, Kustomize supports
    defining them as *.properties* files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a *connection.properties* file with two properties inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The *kustomization.yaml* file uses the `files` field instead of `literals`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_kustomize_CO27-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Sets a list of files to read
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_kustomize_CO27-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Path to the properties file
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `kustomize build` command produces a `ConfigMap` containing the
    name of the file as a key, and the value as the content of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kustomize offers a similar way to deal with Kubernetes Secrets. But as we’ll
    see in [Chapter 8](ch08.xhtml#ch_Advanced_Topics), the best way to deal with Kubernetes
    Secrets is using Sealed Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 4.6 Final Thoughts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kustomize is a simple tool, using template-less technology that allows you to
    define plain YAML files and override values either using a merge strategy or using
    JSON Patch expressions. The structure of a project is free as you define the directory
    layout you feel most comfortable with; the only requirement is the presence of
    a *kustomization.yaml* file.
  prefs: []
  type: TYPE_NORMAL
- en: But there is another well-known tool to manage Kubernetes resources files, that
    in our opinion, is a bit more complicated but more powerful, especially when the
    application/service to deploy has several dependencies such as databases, mail
    servers, caches, etc. This tool is Helm, and we’ll cover it in [Chapter 5](ch05.xhtml#ch_Helm).
  prefs: []
  type: TYPE_NORMAL
