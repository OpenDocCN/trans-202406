- en: Chapter 4\. Kustomize
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 Kustomize
- en: Deploying to a Kubernetes cluster is, in summary, applying some YAML files and
    checking the result.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，将一些 YAML 文件应用到 Kubernetes 集群中并检查结果就是部署到 Kubernetes 集群。
- en: The hard part is developing the initial YAML files version; after that, usually,
    they suffer only small changes such as updating the container image tag version,
    the number of replicas, or a new configuration value. One option is to make these
    changes directly in the YAML files—it works, but any error in this version (modification
    of the wrong line, deleting something by mistake, putting in the wrong whitespace)
    might be catastrophic.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 难点在于开发初始的 YAML 文件版本；之后，通常只会进行小的更改，例如更新容器镜像标签版本、副本数量或新的配置值。一种选项是直接在 YAML 文件中进行这些更改——虽然有效，但是版本中的任何错误（修改错误的行、误删内容、放入错误的空白符）可能是灾难性的。
- en: For this reason, some tools let you define base Kubernetes manifests (which
    change infrequently) and specific files (maybe one for each environment) for setting
    the parameters that change more frequently. One of these tools is Kustomize.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一些工具允许您定义基本的 Kubernetes 清单（这些清单不经常更改）和特定的文件（可能是每个环境一个文件），用于设置更频繁更改的参数。其中一个工具就是
    Kustomize。
- en: In this chapter, you’ll learn how to use Kustomize to manage Kubernetes resource
    files in a template-free way without using any DSL.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，您将学习如何使用 Kustomize 以无模板的方式管理 Kubernetes 资源文件，而不使用任何 DSL。
- en: The first step is to create a Kustomize project and deploy it to a Kubernetes
    cluster (see [Recipe 4.1](#recipe_4_1)).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个 Kustomize 项目并将其部署到 Kubernetes 集群中（参见 [4.1](#recipe_4_1) 节）。
- en: After the first deployment, the application is automatically updated with a
    new container image, a new configuration value, or any other field, such as the
    replica number (see Recipes [4.2](#recipe_4_2) and [4.3](#recipe_4_3)).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次部署后，应用程序将自动更新新的容器镜像、新的配置值或任何其他字段，例如副本数（参见 [4.2](#recipe_4_2) 和 [4.3](#recipe_4_3)
    节）。
- en: If you’ve got several running environments (i.e., staging, production, etc.),
    you need to manage them similarly. Still, with its particularities, Kustomize
    lets you define a set of custom values per environment (see [Recipe 4.4](#recipe_4_4)).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有多个运行环境（例如，预备、生产等），则需要类似的管理它们。尽管有其特殊性，Kustomize 允许您为每个环境定义一组自定义值（参见 [4.4](#recipe_4_4)
    节）。
- en: Application configuration values are properties usually mapped as a Kubernetes
    `ConfigMap`. Any change (and its consequent update on the cluster) on a `ConfigMap`
    doesn’t trigger a rolling update of the application, which means that the application
    will run with the previous version until you manually restart it.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序配置值通常被映射为 Kubernetes 的 `ConfigMap` 属性。在 `ConfigMap` 上进行任何更改（及其在集群上的后续更新）都不会触发应用程序的滚动更新，这意味着应用程序将继续以先前的版本运行，直到您手动重新启动它。
- en: Kustomize provides some functions to automatically execute a rolling update
    when the `ConfigMap` of an application changes (see [Recipe 4.5](#recipe_4_5)).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 提供了一些函数，用于在应用程序的 `ConfigMap` 更改时自动执行滚动更新（参见 [4.5](#recipe_4_5) 节）。
- en: 4.1 Using Kustomize to Deploy Kubernetes Resources
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.1 使用 Kustomize 部署 Kubernetes 资源
- en: Problem
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to deploy several Kubernetes resources at once.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望一次部署多个 Kubernetes 资源。
- en: Solution
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use [Kustomize](https://kustomize.io) to configure which resources to deploy.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [Kustomize](https://kustomize.io) 配置要部署的资源。
- en: Deploying an application to a Kubernetes cluster isn’t as trivial as just applying
    one YAML/JSON file containing a Kubernetes `Deployment` object. Usually, other
    Kubernetes objects must be defined like `Service`, `Ingress`, `ConfigMaps`, etc.,
    which makes things a bit more complicated in terms of managing and updating these
    resources (the more resources to maintain, the more chance to update the wrong
    one) as well as applying them to a cluster (should we run multiple `kubectl` commands?).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序部署到 Kubernetes 集群并不像只需应用一个包含 Kubernetes `Deployment` 对象的 YAML/JSON 文件那样简单。通常，必须定义其他
    Kubernetes 对象，如 `Service`、`Ingress`、`ConfigMaps` 等，这在管理和更新这些资源（维护的资源越多，更新错误的可能性就越大）以及将其应用于集群方面稍微复杂一些（我们应该运行多个
    `kubectl` 命令吗？）。
- en: Kustomize is a CLI tool, integrated within the `kubectl` tool to manage, customize,
    and apply Kubernetes resources in a *template-less* way.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 是一个 CLI 工具，集成在 `kubectl` 工具中，用于以*无模板*的方式管理、自定义和应用 Kubernetes 资源。
- en: With Kustomize, you need to set a base directory with standard Kubernetes resource
    files (no placeholders are required) and create a *kustomization.yaml* file where
    resources and customizations are declared, as you can see in [Figure 4-1](#fig-411).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kustomize，你需要设置一个基本目录，其中包含标准的 Kubernetes 资源文件（无需占位符），并创建一个名为 *kustomization.yaml*
    的文件，声明资源和自定义内容，正如你可以在 [图 4-1](#fig-411) 中看到的。
- en: '![Kustomize layout](assets/gocb_0402.png)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![Kustomize 布局](assets/gocb_0402.png)'
- en: Figure 4-1\. Kustomize layout
  id: totrans-19
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-1\. Kustomize 布局
- en: Let’s deploy a simple web page with HTML, JavaScript, and CSS files.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们部署一个简单的网页，包含 HTML、JavaScript 和 CSS 文件。
- en: First, open a terminal window and create a directory named *pacman*, then create
    three Kubernetes resource files to create a `Namespace`, a `Deployment`, and a
    `Service` with the following content.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在终端窗口中创建一个名为 *pacman* 的目录，然后创建三个 Kubernetes 资源文件，创建一个 `Namespace`，一个 `Deployment`
    和一个 `Service`，内容如下。
- en: 'The namespace at *pacman/namespace.yaml*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*pacman/namespace.yaml* 中的命名空间：'
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The deployment file at *pacman/deployment.yaml*:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '*pacman/deployment.yaml* 中的部署文件：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The service file at *pacman/service.yaml*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*pacman/service.yaml* 中的服务文件：'
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice that these files are Kubernetes files that you could apply to a Kubernetes
    cluster without any problem as no special characters or placeholders are used.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这些文件是 Kubernetes 文件，您可以将它们应用到 Kubernetes 集群中，因为它们没有使用任何特殊字符或占位符。
- en: 'The second thing is to create the *kustomization.yaml* file in the *pacman*
    directory containing the list of resources that belongs to the application and
    are applied when running Kustomize:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 第二步是在 *pacman* 目录中创建 *kustomization.yaml* 文件，其中包含属于应用程序的资源列表，在运行 Kustomize 时应用这些资源：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[![1](assets/1.png)](#co_kustomize_CO1-1)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO1-1)'
- en: Kustomization file
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomization 文件
- en: '[![2](assets/2.png)](#co_kustomize_CO1-2)'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO1-2)'
- en: Resources belonging to the application processed in depth-first order
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 深度优先顺序处理的属于应用程序的资源
- en: 'At this point, we can apply the kustomization file into a running cluster by
    running the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过运行以下命令将 kustomization 文件应用到运行中的集群：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_kustomize_CO2-1)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO2-1)'
- en: Prints the result of the kustomization run, without sending the result to the
    cluster
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 打印 kustomization 运行的结果，而不将结果发送到集群
- en: '[![2](assets/2.png)](#co_kustomize_CO2-2)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO2-2)'
- en: With `-k` option sets `kubectl` to use the kustomization file
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `-k` 选项设置 `kubectl` 使用 kustomization 文件
- en: '[![3](assets/3.png)](#co_kustomize_CO2-3)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO2-3)'
- en: Directory with parent *kustomization.yaml* file
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 具有父级 *kustomization.yaml* 文件的目录
- en: Note
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We assume you’ve already started a *Minikube* cluster as shown in [Recipe 2.3](ch02.xhtml#recipe_2_3).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设您已经启动了一个 *Minikube* 集群，如 [Recipe 2.3](ch02.xhtml#recipe_2_3) 所示。
- en: 'The output is the YAML file that would be sent to the server if the `dry-run`
    option was not used:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未使用 `dry-run` 选项，输出的 YAML 文件将发送到服务器：
- en: '[PRE5]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_kustomize_CO3-1)'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO3-1)'
- en: List of all Kubernetes objects defined in *kustomization.yaml* to apply
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 列出 *kustomization.yaml* 中定义的所有 Kubernetes 对象以应用
- en: '[![2](assets/2.png)](#co_kustomize_CO3-2)'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO3-2)'
- en: The namespace document
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间文档
- en: '[![3](assets/3.png)](#co_kustomize_CO3-3)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO3-3)'
- en: The service document
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 服务文档
- en: '[![4](assets/4.png)](#co_kustomize_CO3-4)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_kustomize_CO3-4)'
- en: The deployment document
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 部署文档
- en: Discussion
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: The `resources` section supports different inputs in addition to directly setting
    the YAML files.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources` 部分支持不同的输入，除了直接设置 YAML 文件之外。'
- en: For example, you can set a base directory with its own *kustomization.yaml*
    and Kubernetes resources files and refer it from another *kustomization.yaml*
    file placed in another directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，您可以设置一个具有自己的 *kustomization.yaml* 和 Kubernetes 资源文件的基本目录，并从另一个目录中的另一个 *kustomization.yaml*
    文件引用它。
- en: 'Given the following directory layout:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下目录布局：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And the Kustomization definitions in the *base* directory:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 和 *base* 目录中的 Kustomization 定义：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You’ll see that the root directory has a link to the *base* directory and a
    `ConfigMap` definition:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您会看到根目录链接到 *base* 目录，并包含一个 `ConfigMap` 定义：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: So, applying the root kustomization file will automatically apply the resources
    defined in the base kustomization file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用根 kustomization 文件将自动应用在基础 kustomization 文件中定义的资源。
- en: 'Also, `resources` can reference external assets from a URL following the [HashiCorp
    URL](https://oreil.ly/lbeQC) format. For example, we refer to a GitHub repository
    by setting the URL:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`resources` 可以按照 [HashiCorp URL](https://oreil.ly/lbeQC) 格式引用来自 URL 的外部资产。例如，我们通过设置
    URL 引用 GitHub 存储库：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_kustomize_CO4-1)'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO4-1)'
- en: Repository with a root-level *kustomization.yaml* file
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 具有根级 *kustomization.yaml* 文件的存储库
- en: '[![2](assets/2.png)](#co_kustomize_CO4-2)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO4-2)'
- en: Repository with a root-level *kustomization.yaml* file on branch test
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 分支测试上具有根级 *kustomization.yaml* 文件的存储库
- en: You’ve seen the application of a Kustomize file using `kubectl`, but Kustomize
    also comes with its own CLI tool offering a set of commands to interact with Kustomize
    resources.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经看到如何使用 `kubectl` 应用 Kustomize 文件，但 Kustomize 也配备了自己的 CLI 工具，提供一组命令与 Kustomize
    资源交互。
- en: 'The equivalent command to build Kustomize resources using `kustomize` instead
    of `kubectl` is:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `kubectl` 构建 Kustomize 资源的等效命令是：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And the output is:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 输出为：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If you want to apply this output generated by `kustomize` to the cluster, run
    the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要将 `kustomize` 生成的输出应用于集群，请在与 *kustomization.yaml* 文件相同的目录中运行以下命令：
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: See Also
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: '[Kustomize](https://kustomize.io)'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kustomize](https://kustomize.io)'
- en: '[kustomize/v4.4.1 on GitHub](https://oreil.ly/h2yNd)'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[kustomize/v4.4.1 on GitHub](https://oreil.ly/h2yNd)'
- en: '[HashiCorp URL format](https://oreil.ly/n7jwr)'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[HashiCorp URL 格式](https://oreil.ly/n7jwr)'
- en: 4.2 Updating the Container Image in Kustomize
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.2 在 Kustomize 中更新容器镜像
- en: Problem
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to update the container image from a deployment file using Kustomize.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Kustomize 从部署文件更新容器镜像。
- en: Solution
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `images` section to update the container image.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `images` 部分更新容器镜像。
- en: One of the most important and most-used operations in software development is
    updating the application to a newer version either with a bug fix or with a new
    feature. In Kubernetes, this means that you need to create a new container image,
    and name it accordingly using the `tag` section (`<registry>/<username>/<project>:<tag>`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发中最重要且最常用的操作之一是更新应用程序至新版本，无论是修复错误还是添加新功能。在 Kubernetes 中，这意味着您需要创建一个新的容器镜像，并使用
    `tag` 部分进行命名（`<registry>/<username>/<project>:<tag>`）。
- en: 'Given the following partial deployment file:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 给定以下部分部署文件：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_kustomize_CO5-1)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO5-1)'
- en: Service 1.0.0 is deployed
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 部署了 Service 1.0.0
- en: 'We can update the version tag to 1.0.1 by using the `images` section in the
    *kustomization.yaml* file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 *kustomization.yaml* 文件中的 `images` 部分将版本标签更新为 1.0.1：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[![1](assets/1.png)](#co_kustomize_CO6-1)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO6-1)'
- en: '`images` section'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`images` 部分'
- en: '[![2](assets/2.png)](#co_kustomize_CO6-2)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO6-2)'
- en: Sets the name of the image to *update*
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将图像名称设置为 *update*
- en: '[![3](assets/3.png)](#co_kustomize_CO6-3)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO6-3)'
- en: Sets the new tag value for the image
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置图像的新标签值
- en: 'Finally, use `kubectl` in `dry-run` or `kustomize` to validate that the output
    of the deployment file contains the new tag version. In a terminal window, run
    the following command:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `kubectl` 中的 `dry-run` 或 `kustomize` 来验证部署文件输出包含新的标签版本。在终端窗口中，运行以下命令：
- en: '[PRE15]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output of the preceding command is:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出为：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[![1](assets/1.png)](#co_kustomize_CO7-1)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO7-1)'
- en: Version set in the `kustomize.yaml` file
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `kustomize.yaml` 文件中设置版本号
- en: Note
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Kustomize is not intrusive, which means that the original *deployment.yaml*
    file still contains the original tag (`1.0.0`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 不会对原始的 *deployment.yaml* 文件造成影响，这意味着它仍然包含原始的标签（`1.0.0`）。
- en: Discussion
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: One way to update the `newTag` field is by editing the *kustomization.yaml*
    file, but you can also use the `kustomize` tool for this purpose.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `newTag` 字段的一种方法是编辑 *kustomization.yaml* 文件，但您也可以使用 `kustomize` 工具来实现这一目的。
- en: 'Run the following command in the same directory as the *kustomization.yaml*
    file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在与 *kustomization.yaml* 文件相同的目录中运行以下命令：
- en: '[PRE17]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Check the content of the *kustomization.yaml* file to see that the `newTag`
    field has been updated:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 *kustomization.yaml* 文件的内容，确认 `newTag` 字段已更新：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 4.3 Updating Any Kubernetes Field in Kustomize
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.3 在 Kustomize 中更新任何 Kubernetes 字段
- en: Problem
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to update a field (i.e., number of replicas) using Kustomize.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 Kustomize 更新字段（例如副本数）。
- en: Solution
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `patches` section to specify a change using the JSON Patch specification.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `patches` 部分指定使用 JSON Patch 规范进行更改。
- en: In the previous recipe, you saw how to update the container image tag, but sometimes
    you might change other parameters like the number of replicas or add annotations,
    labels, limits, etc.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，您看到如何更新容器镜像标签，但有时您可能会更改其他参数，例如副本数量或添加注解、标签、限制等。
- en: To cover these scenarios, Kustomize supports the use of JSON Patch to modify
    any Kubernetes resource defined as a Kustomize resource. To use it, you need to
    specify the JSON Patch expression to apply and which resource to apply the patch
    to.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了涵盖这些情况，Kustomize 支持使用 JSON 补丁来修改任何作为 Kustomize 资源定义的 Kubernetes 资源。要使用它，您需要指定要应用的
    JSON 补丁表达式以及应用补丁的资源。
- en: 'For example, we can modify the number of replicas in the following partial
    deployment file from one to three:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以在以下部分部署文件中，将副本数从一个修改为三：
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, let’s update the *kustomization.yaml* file to modify the number of replicas
    defined in the deployment file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们更新 *kustomization.yaml* 文件，以修改部署文件中定义的副本数：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[![1](assets/1.png)](#co_kustomize_CO8-1)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO8-1)'
- en: Patch resource.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁资源。
- en: '[![2](assets/2.png)](#co_kustomize_CO8-2)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO8-2)'
- en: '`target` section sets which Kubernetes object needs to be changed. These values
    match the deployment file created previously.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`target` 部分设置需要更改的 Kubernetes 对象。这些值与之前创建的部署文件匹配。'
- en: '[![3](assets/3.png)](#co_kustomize_CO8-3)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO8-3)'
- en: Patch expression.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁表达式。
- en: '[![4](assets/4.png)](#co_kustomize_CO8-4)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_kustomize_CO8-4)'
- en: Modification of a value.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 值的修改。
- en: '[![5](assets/5.png)](#co_kustomize_CO8-5)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_kustomize_CO8-5)'
- en: Path to the field to modify.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改的字段路径。
- en: '[![6](assets/6.png)](#co_kustomize_CO8-6)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_kustomize_CO8-6)'
- en: New value.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 新值。
- en: 'Finally, use `kubectl` in `dry-run` or `kustomize` to validate that the output
    of the deployment file contains the new tag version. In a terminal window, run
    the following command:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `kubectl` 中的 `dry-run` 或 `kustomize` 来验证部署文件的输出是否包含新的标签版本。在终端窗口中运行以下命令：
- en: '[PRE21]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The output of the preceding command is:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出是：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Tip
  id: totrans-141
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The *replicas* value can also be updated using the `replicas` field in the *kustomization.yaml*
    file.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*replicas* 值也可以通过 *kustomization.yaml* 文件中的 `replicas` 字段进行更新。'
- en: 'The equivalent Kustomize file using the `replicas` field is shown in the following
    snippet:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `replicas` 字段的等效 Kustomize 文件显示在以下片段中：
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[![1](assets/1.png)](#co_kustomize_CO9-1)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO9-1)'
- en: Deployment to update the replicas
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 更新副本的部署
- en: '[![2](assets/2.png)](#co_kustomize_CO9-2)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO9-2)'
- en: New `replicas` value
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 `replicas` 值
- en: 'Kustomize lets you add (or delete) values, in addition to modifying a value.
    Let’s see how to add a new label:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 允许您添加（或删除）值，除了修改值外。让我们看看如何添加一个新的标签：
- en: '[PRE24]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[![1](assets/1.png)](#co_kustomize_CO10-1)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO10-1)'
- en: Adds a new field with value
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个带有值的新字段
- en: '[![2](assets/2.png)](#co_kustomize_CO10-2)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO10-2)'
- en: Path with the field to add
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加的字段路径
- en: '[![3](assets/3.png)](#co_kustomize_CO10-3)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO10-3)'
- en: The value to set
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置的值
- en: 'The result of applying the file is:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 应用文件的结果是：
- en: '[PRE25]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[![1](assets/1.png)](#co_kustomize_CO11-1)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO11-1)'
- en: Added label
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的标签
- en: Discussion
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: Instead of embedding a JSON Patch expression, you can create a YAML file with
    a Patch expression and refer to it using the `path` field instead of `patch`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是嵌入 JSON 补丁表达式，您可以创建一个包含 JSON 补丁表达式的 YAML 文件，并使用 `path` 字段而不是 `patch` 来引用它。
- en: 'Create an external patch file named *external_patch* containing the JSON Patch
    expression:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 *external_patch* 的外部补丁文件，其中包含 JSON 补丁表达式：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And change the `patch` field to `path` pointing to the patch file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 并将 `patch` 字段更改为指向补丁文件的 `path`：
- en: '[PRE27]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[![1](assets/1.png)](#co_kustomize_CO12-1)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO12-1)'
- en: Path to external patch file
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 外部补丁文件路径
- en: In addition to the JSON Patch expression, Kustomize also supports [Strategic
    Merge Patch](https://oreil.ly/vr3e3) to modify Kubernetes resources. In summary,
    a Strategic Merge Patch (or *SMP*) is an incomplete YAML file that is merged against
    a completed YAML file.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 JSON 补丁表达式外，Kustomize 还支持 [Strategic Merge Patch](https://oreil.ly/vr3e3)
    来修改 Kubernetes 资源。简而言之，Strategic Merge Patch（或 *SMP*）是一个不完整的 YAML 文件，与一个完整的 YAML
    文件合并。
- en: 'Only a minimal deployment file with container name information is required
    to update a container image:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 仅需要一个包含容器名称信息的最小部署文件来更新容器映像：
- en: '[PRE28]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[![1](assets/1.png)](#co_kustomize_CO13-1)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO13-1)'
- en: Target is selected using label
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标签选择目标
- en: '[![2](assets/2.png)](#co_kustomize_CO13-2)'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO13-2)'
- en: Patch is smart enough to detect if it is an SMP or JSON Patch
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 补丁足够智能，可以检测到它是 SMP 还是 JSON 补丁
- en: '[![3](assets/3.png)](#co_kustomize_CO13-3)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO13-3)'
- en: This is a minimal deployment file
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个最小的部署文件
- en: '[![4](assets/4.png)](#co_kustomize_CO13-4)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_kustomize_CO13-4)'
- en: Sets only the field to change, the rest is left as is
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 只设置要更改的字段，其余保持不变
- en: 'The generated output is the original *deployment.yaml* file but with the new
    container image:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的输出是原始的*deployment.yaml* 文件，但包含新的容器镜像：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Tip
  id: totrans-182
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: '`path` is supported as well.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`path` 也受到支持。'
- en: See Also
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '[RFC 6902: JavaScript Object Notation (JSON) Patch](https://oreil.ly/gDn1A)'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RFC 6902：JavaScript 对象表示法（JSON）补丁](https://oreil.ly/gDn1A)'
- en: '[Strategic Merge Patch](https://oreil.ly/vr3e3)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[策略合并补丁](https://oreil.ly/vr3e3)'
- en: 4.4 Deploying to Multiple Environments
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.4 部署到多个环境
- en: Problem
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to deploy the same application in different namespaces using Kustomize.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 Kustomize 在不同的命名空间中部署相同的应用程序。
- en: Solution
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `namespace` field to set the target namespace.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `namespace` 字段来设置目标命名空间。
- en: In some circumstances, it’s good to have the application deployed in different
    namespaces; for example, one namespace can be used as a *staging* environment,
    and another one as the *production* namespace. In both cases, the base Kubernetes
    files are the same, with minimal changes like the namespace deployed, some configuration
    parameters, or container version, to mention a few. [Figure 4-2](#fig-441) shows
    an example.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，将应用程序部署到不同的命名空间是有好处的；例如，一个命名空间可以用作*演示*环境，另一个用作*生产*命名空间。在这两种情况下，基础的 Kubernetes
    文件是相同的，只有一些最小的更改，如部署的命名空间、一些配置参数或容器版本等。[图 4-2](#fig-441) 展示了一个例子。
- en: '![Kustomize layout](assets/gocb_0402.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![Kustomize 布局](assets/gocb_0402.png)'
- en: Figure 4-2\. Kustomize layout
  id: totrans-194
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 4-2\. Kustomize 布局
- en: '`kustomize` lets you define multiple changes with a different namespace, as
    overlays on a common base using the `namespace` field. For this example, all base
    Kubernetes resources are put in the `base` directory and a new directory is created
    for customizations of each environment:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`kustomize` 允许您使用 `namespace` 字段将多个更改定义为常见基础上的叠加。例如，所有基础 Kubernetes 资源放在 `base`
    目录中，并为每个环境的定制创建一个新目录：'
- en: '[PRE30]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[![1](assets/1.png)](#co_kustomize_CO14-1)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO14-1)'
- en: Base files
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 基础文件
- en: '[![2](assets/2.png)](#co_kustomize_CO14-2)'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO14-2)'
- en: Changes specific to production environment
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于生产环境的更改
- en: '[![3](assets/3.png)](#co_kustomize_CO14-3)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO14-3)'
- en: Changes specific to staging environment
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 特定于演示环境的更改
- en: 'The base kustomization file contains a reference to its resources:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基础 kustomization 文件包含其资源的引用：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There is a kustomization file with some parameters set for each environment
    directory. These reference the *base* directory, the namespace to inject into
    Kubernetes resources, and finally, the image to deploy, which in production is
    *1.1.0* but in staging is *1.2.0-beta*.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个环境目录都有一个 kustomization 文件，其中设置了一些参数。这些参数引用了*base*目录、要注入到 Kubernetes 资源中的命名空间以及最后要部署的镜像，在生产环境中是*1.1.0*，但在演示环境中是*1.2.0-beta*。
- en: 'For the staging environment, *kustomization.yaml* content is shown in the following
    listing:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*演示*环境，*kustomization.yaml* 的内容如下所示：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[![1](assets/1.png)](#co_kustomize_CO15-1)'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO15-1)'
- en: References to *base* directory
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对*base*目录的引用
- en: '[![2](assets/2.png)](#co_kustomize_CO15-2)'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO15-2)'
- en: Sets namespace to *staging*
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 将命名空间设置为*演示*
- en: '[![3](assets/3.png)](#co_kustomize_CO15-3)'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO15-3)'
- en: Sets the container tag for the *staging* environment
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 设置*演示*环境的容器标签
- en: 'The kustomization file for production is similar to the staging one, but changes
    the namespace and the tag:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 生产的 kustomization 文件与 staging 的类似，但更改了命名空间和标签：
- en: '[PRE33]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[![1](assets/1.png)](#co_kustomize_CO16-1)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO16-1)'
- en: Sets namespace for *production*
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 设置*生产*的命名空间
- en: '[![2](assets/2.png)](#co_kustomize_CO16-2)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO16-2)'
- en: Sets the container tag for the *production* environment
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 设置*生产*环境的容器标签
- en: 'Running `kustomize` produces different output depending on the directory where
    it is run; for example, running `kustomize build` in the *staging* directory produces:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `kustomize` 根据运行的目录不同生成不同的输出；例如，在*演示*目录中运行 `kustomize build` 会生成：
- en: '[PRE34]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[![1](assets/1.png)](#co_kustomize_CO17-1)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO17-1)'
- en: Namespace value is injected
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间值被注入
- en: '[![2](assets/2.png)](#co_kustomize_CO17-2)'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO17-2)'
- en: Container tag for the *staging* environment is injected
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为*演示*环境注入容器标签
- en: 'But if you run it in the *production* directory, the output is adapted to the
    production configuration:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您在*生产*目录中运行它，则输出会根据生产配置进行调整：
- en: '[PRE35]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[![1](assets/1.png)](#co_kustomize_CO18-1)'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO18-1)'
- en: Injects the *production* namespace
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注入*生产*命名空间
- en: '[![2](assets/2.png)](#co_kustomize_CO18-2)'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO18-2)'
- en: Container tag for the *production* environment
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*production* 环境的容器标签'
- en: Discussion
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Kustomize can preappend/append a value to the names of all resources and references.
    This is useful when a different name in the resource is required depending on
    the environment, or to set the version deployed in the name:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 可以在所有资源和引用的名称前添加/附加一个值。当需要根据环境要求不同名称的资源时，或者为了设置名称中部署的版本时，这非常有用：
- en: '[PRE36]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](assets/1.png)](#co_kustomize_CO19-1)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO19-1)'
- en: Prefix to preappend
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 要前置的前缀
- en: '[![2](assets/2.png)](#co_kustomize_CO19-2)'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO19-2)'
- en: Suffix to append
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加的后缀
- en: 'And the resulting output is as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE37]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[![1](assets/1.png)](#co_kustomize_CO20-1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO20-1)'
- en: New name of the deployment file
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 部署文件的新名称
- en: 4.5 Generating ConfigMaps in Kustomize
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.5 在 Kustomize 中生成 ConfigMaps
- en: Problem
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: You want to generate Kubernetes `ConfigMap`s using Kustomize.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 您希望使用 Kustomize 生成 Kubernetes `ConfigMap`。
- en: Solution
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决方案
- en: Use the `ConfigMapGenerator` feature field to generate a Kubernetes `ConfigMap`
    resource on the fly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ConfigMapGenerator` 功能字段即可即时生成 Kubernetes `ConfigMap` 资源。
- en: 'Kustomize provides two ways of adding a `ConfigMap` as a Kustomize resource:
    either by declaring a `ConfigMap` as any other resource or declaring a `ConfigMap`
    from a `ConfigMapGenerator`.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 提供两种方式将 `ConfigMap` 添加为 Kustomize 资源：一种是将 `ConfigMap` 声明为任何其他资源，另一种是从
    `ConfigMapGenerator` 声明 `ConfigMap`。
- en: While using `ConfigMap` as a resource offers no other advantage than populating
    Kubernetes resources as any other resource, `ConfigMapGenerator` automatically
    appends a hash to the `ConfigMap` metadata name and also modifies the deployment
    file with the new hash. This minimal change has a deep impact on the application’s
    lifecycle, as we’ll see soon in the example.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将 `ConfigMap` 作为资源使用与将 Kubernetes 资源填充为任何其他资源无异，但 `ConfigMapGenerator` 自动向
    `ConfigMap` 元数据名称附加哈希，并且还修改了部署文件与新哈希。这种微小的变化对应用程序的生命周期有深远影响，我们将在例子中很快看到。
- en: Let’s consider an application running in Kubernetes and configured using a `ConfigMap`—for
    example, a database timeout connection parameter. We decided to increase this
    number at some point, so the `ConfigMap` file is changed to this new value, and
    we deploy the application again. Since the `ConfigMap` is the only changed file,
    no rolling update of the application is done. A manual rolling update of the application
    needs to be triggered to propagate the change to the application. [Figure 4-3](#fig-451)
    shows what is changed when a `ConfigMap` object is updated.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个在 Kubernetes 中运行并使用 `ConfigMap` 配置的应用程序，例如数据库超时连接参数。我们决定在某个时候增加此数字，因此
    `ConfigMap` 文件更改为这个新值，并且重新部署应用程序。由于 `ConfigMap` 是唯一更改的文件，因此不会对应用程序进行滚动更新。需要手动触发应用程序的滚动更新以将更改传播到应用程序。[Figure 4-3](#fig-451)
    显示更新 `ConfigMap` 对象时发生的变化。
- en: '![A change on the ConfigMap object](assets/gocb_0403.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![更改 ConfigMap 对象](assets/gocb_0403.png)'
- en: Figure 4-3\. Change of a `ConfigMap`
  id: totrans-252
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 第 4-3 图。更改一个 `ConfigMap`
- en: But, if `ConfigMapGenerator` manages the `ConfigMap`, any change on the configuration
    file also changes the deployment Kubernetes resource. Since the deployment file
    has changed too, an automatic rolling update is triggered when the resources are
    applied, as shown in [Figure 4-4](#fig-452).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果 `ConfigMapGenerator` 管理 `ConfigMap`，则配置文件的任何更改也会更改部署的 Kubernetes 资源。由于部署文件也已更改，因此在应用资源时将触发自动滚动更新，如
    [Figure 4-4](#fig-452) 所示。
- en: Moreover, when using `ConfigMapGenerator`, multiple configuration datafiles
    can be combined into a single `ConfigMap`, making a perfect use case when every
    environment has different configuration files.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 `ConfigMapGenerator` 时，可以将多个配置数据文件合并为单个 `ConfigMap`，在每个环境具有不同配置文件的完美用例。
- en: '![Change of a ConfigMap using ConfigMapGenerator](assets/gocb_0404.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![使用 ConfigMapGenerator 更改 ConfigMap](assets/gocb_0404.png)'
- en: Figure 4-4\. Change of a `ConfigMap` using `ConfigMapGenerator`
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 第 4-4 图。使用 `ConfigMapGenerator` 更改一个 `ConfigMap`
- en: Let’s start with a simple example, adding the `ConfigMapGenerator` section in
    the *kustomization.yaml* file.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的示例开始，在 *kustomization.yaml* 文件中添加 `ConfigMapGenerator` 部分。
- en: 'The deployment file is similar to the one used in previous sections of this
    chapter but includes the `volumes` section:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 部署文件类似于本章前几节中使用的文件，但包括 `volumes` 部分：
- en: '[PRE38]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[![1](assets/1.png)](#co_kustomize_CO21-1)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO21-1)'
- en: '`ConfigMap` name is used in the *kustomization.yaml* file'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigMap` 名称在 *kustomization.yaml* 文件中使用'
- en: 'The configuration properties are embedded within the *kustomization.yaml* file.
    Notice that the `ConfigMap` object is created on the fly when the kustomization
    file is built:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 配置属性嵌入在 *kustomization.yaml* 文件中。注意，当构建 kustomization 文件时，`ConfigMap` 对象会即时创建：
- en: '[PRE39]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[![1](assets/1.png)](#co_kustomize_CO22-1)'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO22-1)'
- en: Name of the `ConfigMap` set in the deployment file
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署文件中设置的 `ConfigMap` 名称
- en: '[![2](assets/2.png)](#co_kustomize_CO22-2)'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO22-2)'
- en: Embeds configuration values in the file
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 将配置值嵌入文件中
- en: '[![3](assets/3.png)](#co_kustomize_CO22-3)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO22-3)'
- en: Sets a key/value pair for the properties
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 为属性设置键值对
- en: 'Finally, use `kubectl` in `dry-run` or `kustomize` to validate that the output
    of the deployment file contains the new tag version. In a terminal window, run
    the following command:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 `kubectl` 中的 `dry-run` 或 `kustomize` 来验证部署文件的输出是否包含新的标签版本。在终端窗口中运行以下命令：
- en: '[PRE40]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The output of the preceding command is a new `ConfigMap` with the configuration
    values set in *kustomization.yaml*. Moreover, the name of the `ConfigMap` is updated
    by appending a hash in both the generated `ConfigMap` and deployment:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出是一个新的 `ConfigMap`，其中包含在 *kustomization.yaml* 中设置的配置值。此外，`ConfigMap` 的名称通过在生成的
    `ConfigMap` 和部署文件中追加哈希来更新：
- en: '[PRE41]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[![1](assets/1.png)](#co_kustomize_CO23-1)'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO23-1)'
- en: '`ConfigMap` with properties'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 包含属性的 `ConfigMap`
- en: '[![2](assets/2.png)](#co_kustomize_CO23-2)'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO23-2)'
- en: Name with hash
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 带有哈希的名称
- en: '[![3](assets/3.png)](#co_kustomize_CO23-3)'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO23-3)'
- en: Name field is updated to the one with the hash triggering a rolling update
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 名称字段已更新为带有哈希的字段，触发滚动更新
- en: 'Since the hash is calculated for any change in the configuration properties,
    a change on them provokes a change on the output triggering a rolling update of
    the application. Open the *kustomization.yaml* file and update the `db-timeout`
    literal from 2000 to 1000 and run `kustomize build` again. Notice the change in
    the `ConfigMap` name using a new hashed value:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于哈希是根据配置属性的任何更改计算的，对它们的更改会触发输出的更改，从而触发应用程序的滚动更新。打开 *kustomization.yaml* 文件并将
    `db-timeout` 字面值从 2000 更新为 1000，然后再次运行 `kustomize build`。注意使用新的哈希值更改 `ConfigMap`
    名称：
- en: '[PRE42]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[![1](assets/1.png)](#co_kustomize_CO24-1)'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO24-1)'
- en: New hashed value
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 新的哈希值
- en: Discussion
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 讨论
- en: '`ConfigMapGenerator` also supports merging configuration properties from different
    sources.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConfigMapGenerator` 还支持从不同源合并配置属性。'
- en: 'Create a new *kustomization.yaml* file in the *dev_literals* directory, setting
    it as the previous directory and overriding the `db-username` value:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *dev_literals* 目录中创建一个新的 *kustomization.yaml* 文件，将其设置为上一个目录，并覆盖 `db-username`
    值：
- en: '[PRE43]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[![1](assets/1.png)](#co_kustomize_CO25-1)'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO25-1)'
- en: Base directory
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 基础目录
- en: '[![2](assets/2.png)](#co_kustomize_CO25-2)'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO25-2)'
- en: Merge properties (can be `create` or `replace` too)
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 合并属性（也可以是 `create` 或 `replace`）
- en: '[![3](assets/3.png)](#co_kustomize_CO25-3)'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_kustomize_CO25-3)'
- en: Overridden value
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖的值
- en: 'Running the `kustomize build` command produces a `ConfigMap` containing a merge
    of both configuration properties:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `kustomize build` 命令会生成一个包含两者配置属性合并的 `ConfigMap`：
- en: '[PRE44]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[![1](assets/1.png)](#co_kustomize_CO26-1)'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO26-1)'
- en: Inherits from base
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 继承自基础
- en: '[![2](assets/2.png)](#co_kustomize_CO26-2)'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO26-2)'
- en: Overrides value
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖值
- en: In addition to setting configuration properties as literals, Kustomize supports
    defining them as *.properties* files.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将配置属性设置为字面值外，Kustomize 还支持将它们定义为 *.properties* 文件。
- en: 'Create a *connection.properties* file with two properties inside:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个包含两个属性的 *connection.properties* 文件：
- en: '[PRE45]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The *kustomization.yaml* file uses the `files` field instead of `literals`:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '*kustomization.yaml* 文件使用 `files` 字段而不是 `literals`：'
- en: '[PRE46]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[![1](assets/1.png)](#co_kustomize_CO27-1)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_kustomize_CO27-1)'
- en: Sets a list of files to read
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 设置要读取的文件列表
- en: '[![2](assets/2.png)](#co_kustomize_CO27-2)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_kustomize_CO27-2)'
- en: Path to the properties file
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 属性文件的路径
- en: 'Running the `kustomize build` command produces a `ConfigMap` containing the
    name of the file as a key, and the value as the content of the file:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `kustomize build` 命令会生成一个包含文件名作为键和文件内容作为值的 `ConfigMap`：
- en: '[PRE47]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: See Also
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Kustomize offers a similar way to deal with Kubernetes Secrets. But as we’ll
    see in [Chapter 8](ch08.xhtml#ch_Advanced_Topics), the best way to deal with Kubernetes
    Secrets is using Sealed Secrets.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 提供了一种类似的方法来处理 Kubernetes Secrets。但正如我们将在 [第 8 章](ch08.xhtml#ch_Advanced_Topics)
    中看到的那样，处理 Kubernetes Secrets 的最佳方法是使用 Sealed Secrets。
- en: 4.6 Final Thoughts
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 4.6 最后的思考
- en: Kustomize is a simple tool, using template-less technology that allows you to
    define plain YAML files and override values either using a merge strategy or using
    JSON Patch expressions. The structure of a project is free as you define the directory
    layout you feel most comfortable with; the only requirement is the presence of
    a *kustomization.yaml* file.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Kustomize 是一个简单的工具，使用无模板技术，允许您定义普通的 YAML 文件，并使用合并策略或 JSON Patch 表达式覆盖值。项目的结构是自由的，您可以定义您感觉最舒适的目录布局；唯一的要求是存在一个*kustomization.yaml*文件。
- en: But there is another well-known tool to manage Kubernetes resources files, that
    in our opinion, is a bit more complicated but more powerful, especially when the
    application/service to deploy has several dependencies such as databases, mail
    servers, caches, etc. This tool is Helm, and we’ll cover it in [Chapter 5](ch05.xhtml#ch_Helm).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 但是还有另一个知名的工具来管理 Kubernetes 资源文件，据我们认为，它稍微复杂一些但更强大，特别是当要部署的应用/服务有多个依赖项，比如数据库、邮件服务器、缓存等。这个工具就是
    Helm，我们将在[第五章](ch05.xhtml#ch_Helm)中详细介绍它。
