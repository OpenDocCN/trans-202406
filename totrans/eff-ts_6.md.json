["```\n$ npx tsc\n```", "```\n$ npm install react\n```", "```\n$ npm install --save-dev @types/react\n```", "```\n{\n  \"devDependencies\": {\n    \"@types/lodash\": \"^16.8.19\",\n    \"typescript\": \"^3.5.3\"\n  },\n  \"dependencies\": {\n    \"react\": \"^16.8.6\"\n  }\n}\n```", "```\n$ npm install react\n+ react@16.8.6\n\n$ npm install --save-dev @types/react\n+ @types/react@16.8.19\n```", "```\nnpm install --save-dev @types/lodash@ts3.1\n```", "```\nnode_modules/\n  @types/\n    foo/\n      index.d.ts @1.2.3\n    bar/\n      index.d.ts\n      node_modules/\n        @types/\n          foo/\n            index.d.ts @2.3.4\n```", "```\n{\n  \"name\": \"left-pad\",\n  \"version\": \"1.3.0\",\n  \"description\": \"String left pad\",\n  \"main\": \"index.js\",\n  \"types\": \"index.d.ts\",\n  // ...\n}\n```", "```\ninterface SecretName {\n  first: string;\n  last: string;\n}\n\ninterface SecretSanta {\n  name: SecretName;\n  gift: string;\n}\n\nexport function getGift(name: SecretName, gift: string): SecretSanta {\n  // ...\n}\n```", "```\ntype MySanta = ReturnType<typeof getGift>;  // SecretSanta\ntype MyName = Parameters<typeof getGift>[0];  // SecretName\n```", "```\n// Generate a greeting. Result is formatted for display.\nfunction greet(name: string, title: string) {\n  return `Hello ${title} ${name}`;\n}\n```", "```\n/** Generate a greeting. Result is formatted for display. */\nfunction greetJSDoc(name: string, title: string) {\n  return `Hello ${title} ${name}`;\n}\n```", "```\n/**\n * Generate a greeting.\n * @param name Name of the person to greet\n * @param salutation The person's title\n * @returns A greeting formatted for human consumption.\n */\nfunction greetFullTSDoc(name: string, title: string) {\n  return `Hello ${title} ${name}`;\n}\n```", "```\n/** A measurement performed at a time and place. */\ninterface Measurement {\n  /** Where was the measurement made? */\n  position: Vector3D;\n  /** When was the measurement made? In seconds since epoch. */\n  time: number;\n  /** Observed momentum */\n  momentum: Vector3D;\n}\n```", "```\n/**\n * This _interface_ has **three** properties:\n * 1\\. x\n * 2\\. y\n * 3\\. z\n */\ninterface Vector3D {\n  x: number;\n  y: number;\n  z: number;\n}\n```", "```\nclass C {\n  vals = [1, 2, 3];\n  logSquares() {\n    for (const val of this.vals) {\n      console.log(val * val);\n    }\n  }\n}\n\nconst c = new C();\nc.logSquares();\n```", "```\n1\n4\n9\n```", "```\nconst c = new C();\nconst method = c.logSquares;\nmethod();\n```", "```\nUncaught TypeError: Cannot read property 'vals' of undefined\n```", "```\nconst c = new C();\nconst method = c.logSquares;\nmethod.call(c);  // Logs the squares again\n```", "```\ndocument.querySelector('input')!.addEventListener('change', function(e) {\n  console.log(this);  // Logs the input element on which the event fired.\n});\n```", "```\nclass ResetButton {\n  render() {\n    return makeButton({text: 'Reset', onClick: this.onClick});\n  }\n  onClick() {\n    alert(`Reset ${this}`);\n  }\n}\n```", "```\nclass ResetButton {\n  constructor() {\n    this.onClick = this.onClick.bind(this);\n  }\n  render() {\n    return makeButton({text: 'Reset', onClick: this.onClick});\n  }\n  onClick() {\n    alert(`Reset ${this}`);\n  }\n}\n```", "```\nclass ResetButton {\n  render() {\n    return makeButton({text: 'Reset', onClick: this.onClick});\n  }\n  onClick = () => {\n    alert(`Reset ${this}`);  // \"this\" always refers to the ResetButton instance.\n  }\n}\n```", "```\nclass ResetButton {\n  constructor() {\n    var _this = this;\n    this.onClick = function () {\n      alert(\"Reset \" + _this);\n    };\n  }\n  render() {\n    return makeButton({ text: 'Reset', onClick: this.onClick });\n  }\n}\n```", "```\nfunction addKeyListener(\n  el: HTMLElement,\n  fn: (this: HTMLElement, e: KeyboardEvent) => void\n) {\n  el.addEventListener('keydown', e => {\n    fn.call(el, e);\n  });\n}\n```", "```\nfunction addKeyListener(\n  el: HTMLElement,\n  fn: (this: HTMLElement, e: KeyboardEvent) => void\n) {\n  el.addEventListener('keydown', e => {\n    fn(el, e);\n        // ~ Expected 1 arguments, but got 2\n  });\n}\n```", "```\nfunction addKeyListener(\n  el: HTMLElement,\n  fn: (this: HTMLElement, e: KeyboardEvent) => void\n) {\n  el.addEventListener('keydown', e => {\n    fn(e);\n // ~~~~~ The 'this' context of type 'void' is not assignable\n //       to method's 'this' of type 'HTMLElement'\n  });\n}\n```", "```\ndeclare let el: HTMLElement;\naddKeyListener(el, function(e) {\n  this.innerHTML;  // OK, \"this\" has type of HTMLElement\n});\n```", "```\nclass Foo {\n  registerHandler(el: HTMLElement) {\n    addKeyListener(el, e => {\n      this.innerHTML;\n        // ~~~~~~~~~ Property 'innerHTML' does not exist on type 'Foo'\n    });\n  }\n}\n```", "```\nfunction double(x) {\n  return x + x;\n}\n```", "```\nfunction double(x: number|string): number|string;\nfunction double(x: any) { return x + x; }\n```", "```\nconst num = double(12);  // string | number\nconst str = double('x');  // string | number\n```", "```\nfunction double<T extends number|string>(x: T): T;\nfunction double(x: any) { return x + x; }\n\nconst num = double(12);  // Type is 12\nconst str = double('x');  // Type is \"x\"\n```", "```\nfunction double(x: number): number;\nfunction double(x: string): string;\nfunction double(x: any) { return x + x; }\n\nconst num = double(12);  // Type is number\nconst str = double('x');  // Type is string\n```", "```\nfunction f(x: number|string) {\n  return double(x);\n             // ~ Argument of type 'string | number' is not assignable\n             //   to parameter of type 'string'\n}\n```", "```\nfunction double<T extends number | string>(\n  x: T\n): T extends string ? string : number;\nfunction double(x: any) { return x + x; }\n```", "```\nconst num = double(12);  // number\nconst str = double('x');  // string\n\n// function f(x: string | number): string | number\nfunction f(x: number|string) {\n  return double(x);\n}\n```", "```\n   (number|string) extends string ? string : number\n-> (number extends string ? string : number) |\n   (string extends string ? string : number)\n-> number | string\n```", "```\nfunction parseCSV(contents: string | Buffer): {[column: string]: string}[]  {\n  if (typeof contents === 'object') {\n    // It's a buffer\n    return parseCSV(contents.toString('utf8'));\n  }\n  // ...\n}\n```", "```\nnpm install --save-dev @types/node\n```", "```\ninterface CsvBuffer {\n  toString(encoding: string): string;\n}\nfunction parseCSV(contents: string | CsvBuffer): {[column: string]: string}[]  {\n  // ...\n}\n```", "```\nparseCSV(new Buffer(\"column1,column2\\nval1,val2\", \"utf-8\"));  // OK\n```", "```\ndeclare function map<U, V>(array: U[], fn: (u: U) => V): V[];\n```", "```\nmap(['2017', '2018', '2019'], v => Number(v));\n```", "```\ntest('square a number', () => {\n  square(1);\n  square(2);\n});\n```", "```\nconst lengths: number[] = map(['john', 'paul'], name => name.length);\n```", "```\nfunction assertType<T>(x: T) {}\n\nassertType<number[]>(map(['john', 'paul'], name => name.length));\n```", "```\nconst n = 12;\nassertType<number>(n);  // OK\n```", "```\nconst beatles = ['john', 'paul', 'george', 'ringo'];\nassertType<{name: string}[]>(\n  map(beatles, name => ({\n    name,\n    inYellowSubmarine: name === 'ringo'\n  })));  // OK\n```", "```\nconst add = (a: number, b: number) => a + b;\nassertType<(a: number, b: number) => number>(add);  // OK\n\nconst double = (x: number) => 2 * x;\nassertType<(a: number, b: number) => number>(double);  // OK!?\n```", "```\nconst g: (x: string) => any = () => 12;  // OK\n```", "```\nmap(array, (name, index, array) => { /* ... */ });\n```", "```\nconst double = (x: number) => 2 * x;\nlet p: Parameters<typeof double> = null!;\nassertType<[number, number]>(p);\n//                           ~ Argument of type '[number]' is not\n//                             assignable to parameter of type [number, number]\nlet r: ReturnType<typeof double> = null!;\nassertType<number>(r);  // OK\n```", "```\nconst beatles = ['john', 'paul', 'george', 'ringo'];\nassertType<number[]>(map(\n  beatles,\n  function(name, i, array) {\n// ~~~~~~~ Argument of type '(name: any, i: any, array: any) => any' is\n//         not assignable to parameter of type '(u: string) => any'\n    assertType<string>(name);\n    assertType<number>(i);\n    assertType<string[]>(array);\n    assertType<string[]>(this);\n                      // ~~~~ 'this' implicitly has type 'any'\n    return name.length;\n  }\n));\n```", "```\ndeclare function map<U, V>(\n  array: U[],\n  fn: (this: U[], u: U, i: number, array: U[]) => V\n): V[];\n```", "```\ndeclare module 'overbar';\n```", "```\nconst beatles = ['john', 'paul', 'george', 'ringo'];\nmap(beatles, function(\n  name,  // $ExpectType string\n  i,     // $ExpectType number\n  array  // $ExpectType string[]\n) {\n  this   // $ExpectType string[]\n  return name.length;\n});  // $ExpectType number[]\n```"]