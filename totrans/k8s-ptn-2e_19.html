<html><head></head><body><section data-pdf-bookmark="Chapter 15. Init Container" data-type="chapter" epub:type="chapter"><div class="chapter" id="InitContainer">&#13;
<h1><span class="label">Chapter 15. </span>Init Container</h1>&#13;
&#13;
&#13;
<p>The<a data-primary="Init Container" data-type="indexterm" id="incont15"/> <em>Init Container</em> pattern enables separation of concerns by providing a separate lifecycle for initialization-related tasks distinct from the main application containers. In this chapter, we look closely at this fundamental Kubernetes concept that is used in many other patterns when initialization logic is required.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Problem" data-type="sect1"><div class="sect1" id="idm45902092034240">&#13;
<h1>Problem</h1>&#13;
&#13;
<p>Initialization<a data-primary="problems" data-secondary="initialization, separating from main duties" data-type="indexterm" id="idm45902092032912"/><a data-primary="initialization" data-secondary="separating from main duties" data-type="indexterm" id="idm45902092031808"/> is a widespread concern in many programming languages. Some languages have it covered as part of the language, and some use naming conventions and patterns to indicate a construct as the initializer. For example, in the Java programming language, to instantiate an object that requires some setup, we use the constructor (or static blocks for fancier use cases). Constructors are guaranteed to run as the first thing within the object, and they are guaranteed to run only once by the managing runtime (this is just an example; we don’t go into detail here on the different languages and corner cases). Moreover, we can use the constructor to validate preconditions such as mandatory parameters. We also use constructors to initialize the instance fields with incoming arguments or default values.</p>&#13;
&#13;
<p>Init containers are similar but are at the Pod level rather than at the Java class level. So if you have one or more<a data-primary="containers" data-secondary="separating initialization from main duties" data-type="indexterm" id="idm45902092030256"/> containers in a Pod that represent your main application, these containers may have prerequisites before starting up. These may include special permissions setup on the filesystem, database schema setup, or application seed data installation. Also, this initializing logic may require tools and libraries that cannot be included in the application image. For security reasons, the application image may not have permissions to perform the initializing activities. Alternatively, you may want to delay the startup of your application until an external dependency is satisfied. For all these kinds of use cases, Kubernetes uses init containers as implementation of this pattern, which allow separation of initializing activities from the main application duties.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Solution" data-type="sect1"><div class="sect1" id="idm45902092028864">&#13;
<h1>Solution</h1>&#13;
&#13;
<p>Init containers in Kubernetes are part of the Pod definition, and they separate all containers in a Pod into two groups: init containers and application containers. All init containers are executed in a sequence, one by one, and all of them have to terminate successfully before the application containers are started up. In that sense, init containers are like constructor instructions in a Java class that help object initialization. Application containers, on the other hand, run in parallel, and the startup order is arbitrary. The execution flow is demonstrated in <a data-type="xref" href="#img-init-container">Figure 15-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-init-container">&#13;
<img alt="Init and application containers in a Pod" src="assets/kup2_1501.png"/>&#13;
<h6><span class="label">Figure 15-1. </span>Init and application containers in a Pod</h6>&#13;
</div></figure>&#13;
&#13;
<p>Typically, init containers are expected to be small, run quickly, and complete successfully, except when an init container is used to delay the start of a Pod while waiting for a dependency, in which case it may not terminate until the dependency is satisfied. If an init container fails, the whole Pod is restarted (unless it is marked with <code>RestartNever</code>), causing all init containers to run again. Thus, to prevent any side effects, making init containers idempotent is a good practice.</p>&#13;
&#13;
<p>On one hand, init containers have all of the same capabilities as application containers: all of the containers are part of the same Pod, so they share resource limits, volumes, and security settings and end up placed on the same node. On the other hand, they have slightly different lifecycle, health-checking, and resource-handling semantics. There is no <code>livenessProbe</code>, <code>readinessProbe</code>, or <code>startupProbe</code> for init containers, as all init containers must terminate successfully before the Pod startup processes can continue with application <span class="keep-together">containers</span>.</p>&#13;
&#13;
<p>Init containers also affect the way Pod resource requirements are calculated for scheduling, autoscaling, and quota management. Given the ordering in the execution of all containers in a Pod (first, init containers run a sequence, then all application containers run in parallel), the effective Pod-level request and limit values become the highest values of the following two groups:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The highest init container request/limit value</p>&#13;
</li>&#13;
<li>&#13;
<p>The sum of all application container values for request/limit</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>A consequence of this behavior is that if you have init containers with high resource demands and application containers with low resource demands, the Pod-level request and limit values affecting the scheduling will be based on the higher value of the init containers, as demonstrated in <a data-type="xref" href="#img-init-container-resource">Figure 15-2</a>.</p>&#13;
&#13;
<figure><div class="figure" id="img-init-container-resource">&#13;
<img alt="Effective Pod request/limit calculation" src="assets/kup2_1502.png"/>&#13;
<h6><span class="label">Figure 15-2. </span>Effective Pod request/limit calculation</h6>&#13;
</div></figure>&#13;
&#13;
<p>This setup is not resource-efficient. Even if init containers run for a short period of time and there is available capacity on the node for the majority of the time, no other Pod can use it.</p>&#13;
&#13;
<p>Moreover, init containers enable separation of concerns and allow you to keep containers single-purposed. An application container can be created by the application engineer and focus on the application logic only. A deployment engineer can author an init container and focus on configuration and initialization tasks only. We demonstrate this in <a data-type="xref" href="#ex-init-container">Example 15-1</a>, which has one application container based on an HTTP server that serves files.</p>&#13;
&#13;
<p>The container provides a generic HTTP-serving capability and does not make any assumptions about where the files to serve might come from for the different use cases. In the same Pod, an init container provides Git client capability, and its sole purpose is to clone a Git repo. Since both containers are part of the same Pod, they can access the same volume to share data. We use the same mechanism to share the cloned files from the init container to the application container.</p>&#13;
&#13;
<p><a data-type="xref" href="#ex-init-container">Example 15-1</a> shows an init container that copies data into an empty volume.</p>&#13;
<div data-type="example" id="ex-init-container">&#13;
<h5><span class="label">Example 15-1. </span>Init Container</h5>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w">&#13;
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w">&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">www</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">www</code><code class="w">&#13;
</code><code class="nt">spec</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">initContainers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">download</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">axeclbr/git</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">command</code><code class="p">:</code><code class="w">                       </code><a class="co" href="#callout_init_container_CO1-1" id="co_init_container_CO1-1"><img alt="1" src="assets/1.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">git</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">clone</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">https://github.com/mdn/beginner-html-site-scripted</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/var/lib/data</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">                  </code><a class="co" href="#callout_init_container_CO1-2" id="co_init_container_CO1-2"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/lib/data</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">source</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">run</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">docker.io/centos/httpd</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">volumeMounts</code><code class="p">:</code><code class="w">                  </code><a class="co" href="#callout_init_container_CO1-2" id="co_init_container_CO1-3"><img alt="2" src="assets/2.png"/></a><code class="w">&#13;
</code><code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">mountPath</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">/var/www/html</code><code class="w">&#13;
</code><code class="w">      </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">source</code><code class="w">&#13;
</code><code class="w">  </code><code class="nt">volumes</code><code class="p">:</code><code class="w">                         </code><a class="co" href="#callout_init_container_CO1-3" id="co_init_container_CO1-4"><img alt="3" src="assets/3.png"/></a><code class="w">&#13;
</code><code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">emptyDir</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{</code><code class="p-Indicator">}</code><code class="w">&#13;
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">source</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_init_container_CO1-1" id="callout_init_container_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Clone an external Git repository into the mounted directory.</p></dd>&#13;
<dt><a class="co" href="#co_init_container_CO1-2" id="callout_init_container_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Shared volume used by both init container and the application container.</p></dd>&#13;
<dt><a class="co" href="#co_init_container_CO1-4" id="callout_init_container_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Empty directory used on the node for sharing data.</p></dd>&#13;
</dl></div>&#13;
&#13;
<p>We could have achieved the same effect by using ConfigMap or PersistentVolumes but want to demonstrate how init containers work here. This example illustrates a typical usage pattern of an init container sharing a volume with the main container.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>For debugging the outcome of init containers, it helps if the command of the application container is replaced temporarily with a dummy <code>sleep</code> command so that you have time to examine the situation. This trick is particularly useful if your init container fails to start up and your application fails to start because the configuration is missing or broken.&#13;
The following command within the Pod declaration gives you an hour to debug the volumes mounted by entering the Pod with<a data-primary="kubectl" data-secondary="debugging Pods" data-type="indexterm" id="idm45902091856752"/><a data-primary="Pods" data-secondary="debugging" data-type="indexterm" id="idm45902091855776"/> <code>kubectl exec -it <em>&lt;pod&gt;</em> sh</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="w">   </code><code class="nt">command</code><code class="p">:</code><code class="w"/>&#13;
<code class="w">   </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/bin/sh</code><code class="w"/>&#13;
<code class="w">   </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"-c"</code><code class="w"/>&#13;
<code class="w">   </code><code class="p-Indicator">-</code><code class="w"> </code><code class="s">"sleep</code><code class="nv"> </code><code class="s">3600"</code><code class="w"/></pre>&#13;
</div>&#13;
&#13;
<p>A similar effect can be achieved by using a<a data-primary="Sidecar" data-type="indexterm" id="idm45902091733792"/><a data-primary="Sidecar" data-secondary="Init Container" data-type="indexterm" id="idm45902091733184"/> sidecar, as described next in <a data-type="xref" data-xrefstyle="chap-num-title" href="ch16.html#Sidecar">Chapter 16, “Sidecar”</a>, where the HTTP server container and the Git container are running side by side as application containers. But with the sidecar approach, there is no way of knowing which container will run first, and sidecar is meant to be used when containers run side by side continuously. We could also use a sidecar and init container together if both a guaranteed initialization and a constant update of the data are required.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45902091757760">&#13;
<h1>More Initialization Techniques</h1>&#13;
<p>As<a data-primary="initialization" data-secondary="techniques for" data-type="indexterm" id="idm45902091756224"/> you have seen, an init container is a Pod-level construct that gets activated after a Pod has been started. A few other related techniques used to initialize Kubernetes resources are different from init containers and are worth listing here for &#13;
<span class="keep-together">completeness:</span></p>&#13;
<dl>&#13;
<dt>Admission controllers</dt>&#13;
<dd>&#13;
<p>This<a data-primary="Admission controller plugins" data-type="indexterm" id="idm45902091753056"/> set of plugins intercepts every request to the Kubernetes API Server before persistence of the object and can mutate or validate it. There are many admission controllers for applying checks, enforcing limits, and setting default values, but all are compiled into the <code>kube-apiserver</code> binary and configured by a cluster administrator when the API Server starts up. This plugin system is not very flexible, which is why admission webhooks were added to Kubernetes.</p>&#13;
</dd>&#13;
<dt>Admission webhooks</dt>&#13;
<dd>&#13;
<p>These<a data-primary="admission webhooks" data-type="indexterm" id="idm45902091750528"/> components are external admission controllers that perform HTTP callbacks for any matching request. There are two types of admission webhooks: the <em>mutating webhook</em> (which can change resources to enforce custom defaults) and the <em>validating webhook</em> (which can reject resources to enforce custom admission policies). This concept of external controllers allows admission webhooks to be developed out of Kubernetes and configured at runtime.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>There used to be other techniques for initializing Kubernetes resources, such as<a data-primary="initialization" data-secondary="initializers" data-type="indexterm" id="idm45902091748192"/> Initializers and<a data-primary="PodPresets" data-type="indexterm" id="idm45902091747088"/> PodPresets, which were eventually deprecated and removed. &#13;
<span class="keep-together">Nowadays</span> other projects such as Metacontroller and Kyverno use admission webhooks or the <em>Operator</em> pattern to mutate Kubernetes resources and intervene in the initialization process. These techniques differ from init containers because they validate and mutate resources at creation time.</p>&#13;
&#13;
<p>In contrast, the <em>Init Container</em>  pattern discussed in this chapter is something that activates and performs its responsibilities during startup of the Pod. You could use admission webhooks, for example, to inject an init container into any Pod that doesn’t have one already. For example, Istio, which is a popular<a data-primary="service meshes" data-type="indexterm" id="idm45902091744016"/> service mesh project, uses a combination of techniques discussed in this chapter to inject its proxies into application Pods. Istio<a data-primary="Istio" data-type="indexterm" id="idm45902091743184"/> uses Kubernetes mutating admission webhooks for automatic sidecar and init container injection into the Pod definition at Pod definition creation time. When such a Pod is starting up, Istio’s init container configures&#13;
the Pod environment to redirect inbound and outbound traffic from the application to the Envoy proxy sidecar. The init container runs before any other container and configures iptable rules to insert the Envoy proxy in the request path of the application before any traffic reaches the application. This separation of containers is good for lifecycle management and also because the init container in this case requires elevated permissions to configure traffic redirection, which can pose a security threat. This is an example of how many initialization activities can be performed before an application container starts up.</p>&#13;
&#13;
<p>In the end, the most significant difference is that init containers can be used by developers deploying on Kubernetes, whereas admission webhooks help administrators and various frameworks control and alter the container initialization process.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Discussion" data-type="sect1"><div class="sect1" id="idm45902092028272">&#13;
<h1>Discussion</h1>&#13;
&#13;
<p>So why separate containers in a Pod into two groups? Why not just use an application container with a bit of scripting in a Pod for initialization if required? The answer is that these two groups of containers have different lifecycles, purposes, and even authors in some cases.</p>&#13;
&#13;
<p>Having init containers run before application containers, and more importantly, having init containers run in stages that progress only when the current init container completes successfully, means you can be sure at every step of the initialization that the previous step has completed successfully, and you can progress to the next stage. Application containers, in contrast, run in parallel and do not provide similar guarantees as init containers. With this distinction in hand, we can create containers focused on initialization or application-focused tasks, and reuse them in different contexts by organizing them in Pods with predictable guarantees.<a data-primary="" data-startref="incont15" data-type="indexterm" id="idm45902091718064"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="More Information" data-type="sect1"><div class="sect1" id="idm45902091716960">&#13;
<h1>More Information</h1>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><a href="https://oreil.ly/dtC_W">Init Container Example</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/AcBVc">Init Containers</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/XJV9K">Configuring Pod Initialization</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/H1-va">Admission Controllers Reference</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/uOzBD">Dynamic Admission Control</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/f-P_d">Metacontroller</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/VnbkZ">Kyverno</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/a3kmy">Demystifying Istio’s Sidecar Injection Model</a></p>&#13;
</li>&#13;
<li>&#13;
<p><a href="https://oreil.ly/Wy-ca">Object Initialization in Swift</a></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section></body></html>