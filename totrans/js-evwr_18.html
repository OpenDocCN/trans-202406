<html><head></head><body><section data-pdf-bookmark="Chapter 17. Deploying a Web Application" data-type="chapter" epub:type="chapter"><div class="chapter" id="web-deployment">&#13;
<h1><span class="label">Chapter 17. </span>Deploying a Web Application</h1>&#13;
&#13;
&#13;
<p><a data-primary="web application" data-secondary="deployment" data-type="indexterm" id="ix_ch17-asciidoc0"/><a data-primary="web application deployment" data-type="indexterm" id="ix_ch17-asciidoc1"/>When I first began doing web development professionally, a “deployment” meant uploading files from my local machine to a web server through an FTP client. There weren’t any build steps or pipelines, meaning that the raw files on my machine were the same as those on my web server. If something went wrong, I would either frantically try to fix the issue or roll back the change by replacing it with copies of the old files. This wild west approach worked OK at the time, but also led to a lot of site downtime and unexpected issues.</p>&#13;
&#13;
<p>In today’s world of web development, the needs of our local development environment and our web servers are quite different. On my local machine, I want to see instant changes when I update a file and have uncompressed files for debugging. On my web server, I only expect to see changes when I deploy them and value small file sizes. In this chapter, we’ll look at one way that we can deploy a static application to the web.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Static Websites" data-type="sect1"><div class="sect1" id="idm45339487142296">&#13;
<h1>Static Websites</h1>&#13;
&#13;
<p><a data-primary="static websites" data-type="indexterm" id="idm45339487140856"/><a data-primary="web application deployment" data-secondary="static websites" data-type="indexterm" id="idm45339487140152"/>A web browser parses HTML, CSS, and JavaScript to generate the web pages that we interact with. Unlike frameworks such as Express, Rails, and Django, which generate the markup for a page server-side at the time of the request, static websites are simply a collection of HTML, CSS, and JavaScript stored on a server. This can range in complexity from a single HTML file containing markup to complicated frontend build processes that compile templating languages, multiple JavaScript files, and CSS pre-processors. In the end, however, static websites are a collection of those three file types.</p>&#13;
&#13;
<p class="pagebreak-before">Our application, Notedly, is a static web app. It contains some markup, CSS, and JavaScript. Our build tool, <a href="https://parceljs.org">Parcel</a>, compiles the components that we write into files usable by the browser. In local development, we run a web server and these files are updated on the fly using Parcel’s hot module replacement feature. If we look at our <em>package.json</em> file, you’ll see that I’ve included two <code>deploy</code> scripts:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="s2">"scripts"</code><code class="o">:</code> <code class="p">{</code>&#13;
  <code class="s2">"deploy:src"</code><code class="o">:</code> <code class="s2">"parcel build src/index.html --public-url ./"</code><code class="p">,</code>&#13;
  <code class="s2">"deploy:final"</code><code class="o">:</code> <code class="s2">"parcel build final/index.html --public-url ./"</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>To build the application, open your terminal application, <strong><code>cd</code></strong> into the root of your <em>web</em> directory, which contains the project, and then run the <strong><code>build</code></strong> command:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="c"># if you're not already in the web directory, be sure to cd into it</code>&#13;
<code class="nv">$ </code><code class="nb">cd </code>Projects/notedly/web&#13;
<code class="c"># build the files from the src directory</code>&#13;
<code class="nv">$ </code>npm run deploy:src</pre>&#13;
&#13;
<p>If you’ve been following along with the book and developing your web application in the <em>src</em> directory, running <code>npm run deploy:src</code> in the terminal, as just described, will generate the built application from your code. If you would prefer to use the final version of the application that is bundled with the sample code, using <code>npm run deploy:final</code> will build the code from the <em>final</em> application directory.</p>&#13;
&#13;
<p>In the rest of the chapter, I’ll demonstrate one way to deploy a statically built application, but these files could be hosted anywhere that can serve HTML—from a web hosting provider to a Raspberry Pi left running on your desk. While there are many tangible benefits to the type of process we’ll be working through, your deploy could be as simple as updating the <em>.env</em> file to point to the remote API, running the build script, and uploading the files.</p>&#13;
<div data-type="note" epub:type="note"><h1>Server-Side Rendered React</h1>&#13;
<p><a data-primary="universal Javascript" data-type="indexterm" id="idm45339487103992"/>Though we’re building our React application as a static web application, it is also possible to render JSX on the server. This technique is often referred to as “universal JavaScript” and can have many benefits, including performance gains, client-side JavaScript fallbacks, and SEO improvements. Frameworks such as <a href="https://nextjs.org">Next.js</a> have sought to simplify this setup. Though we’re not covering server-side rendered JavaScript applications in this book, I highly recommend exploring this approach once you’re comfortable with client-side JavaScript application development.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Our Deployment Pipeline" data-type="sect1"><div class="sect1" id="idm45339487116360">&#13;
<h1>Our Deployment Pipeline</h1>&#13;
&#13;
<p><a data-primary="deployment pipeline" data-type="indexterm" id="ix_ch17-asciidoc2"/><a data-primary="web application deployment" data-secondary="deployment pipeline" data-type="indexterm" id="ix_ch17-asciidoc3"/>For our application’s deployment, we’ll make use of a simple pipeline, which will allow us to automatically deploy changes to our codebase. For our pipeline we’ll be using two services. The first will be our source code repository, <a href="https://github.com">GitHub</a>. The second will be our web host, <a href="https://www.netlify.com">Netlify</a>. I’ve chosen Netlify for its extensive, but easy-to-use, feature set for deployments as well as its focus on static and serverless applications.</p>&#13;
&#13;
<p>Our goal is for any commit to the <code>master</code> branch of our application to be automatically deployed to our web host. We could visualize that process as shown in <a data-type="xref" href="#web_deploy">Figure 17-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="web_deploy">&#13;
<img alt="A diagram of our deployment process. Each commit is pushed to GitHub, then built by Netlify, and finally pushed to a public web server." src="assets/jsev_1701.png"/>&#13;
<h6><span class="label">Figure 17-1. </span>Our deployment process</h6>&#13;
</div></figure>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Hosting Source Code with Git" data-type="sect2"><div class="sect2" id="idm45339487074152">&#13;
<h2>Hosting Source Code with Git</h2>&#13;
&#13;
<p><a data-primary="deployment pipeline" data-secondary="hosting source code with Git" data-type="indexterm" id="idm45339487072712"/><a data-primary="Git" data-type="indexterm" id="idm45339487071672"/><a data-primary="web application deployment" data-secondary="hosting source code with Git" data-type="indexterm" id="idm45339487071000"/>The first step in our deployment process is to set up our source code repository. You may have already done this, in which case feel free to skip ahead. As noted before we’ll be using <a href="https://github.com">GitHub</a>, but this process could be configured with other public Git hosts, such as <a href="https://about.gitlab.com">GitLab</a> or <a href="https://bitbucket.org">Bitbucket</a>.</p>&#13;
<div data-type="note" epub:type="note"><h1>GitHub Repositories</h1>&#13;
<p>We’ll be creating a new GitHub repository, but if you prefer, you can use the official code sample at <a class="orm:hideurl" href="https://oreil.ly/MLMS7"><em>https://github.com/javascript​everywhere/web</em></a> by creating a fork to your GitHub account.</p>&#13;
</div>&#13;
&#13;
<p>First, navigate to GitHub and create an account or sign in to your existing account. Then click the New Repository button. Provide a name and click the Create Repository button (<a data-type="xref" href="#new_repo">Figure 17-2</a>).</p>&#13;
&#13;
<figure><div class="figure" id="new_repo">&#13;
<img alt="A screenshot of GitHub's new repository page" src="assets/jsev_1702.png"/>&#13;
<h6><span class="label">Figure 17-2. </span>GitHub’s new repository page</h6>&#13;
</div></figure>&#13;
&#13;
<p>Now, in your terminal application, navigate to your web application’s directory, set the Git origin to the new GitHub repository, and push the code. Because we are updating an existing Git repo, our instructions will differ slightly from GitHub’s:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting"><code class="c"># first navigate to the directory if you're not already there</code>&#13;
<code class="nb">cd </code>Projects/notedly/web&#13;
<code class="c"># update the GitHub remote origin to match your repository</code>&#13;
git remote <code class="nb">set</code>-url origin git://YOUR.GIT.URL&#13;
<code class="c"># push the code to the new GitHub repository</code>&#13;
git push -u origin master</pre>&#13;
&#13;
<p>Now, if you navigate to <em>https://github.com/&lt;your_username&gt;/&lt;your_repo_name&gt;</em>, you will see the source code of the application.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploy with Netlify" data-type="sect2"><div class="sect2" id="idm45339486993000">&#13;
<h2>Deploy with Netlify</h2>&#13;
&#13;
<p><a data-primary="deployment pipeline" data-secondary="Netlify" data-type="indexterm" id="idm45339486991688"/><a data-primary="Netlify" data-type="indexterm" id="idm45339486990712"/><a data-primary="web application deployment" data-secondary="Netlify" data-type="indexterm" id="idm45339486990040"/>With our source code in a remote Git repository, we can now configure our web host, Netlify, to build and deploy our code. First, go to <a class="orm:hideurl" href="https://www.netlify.com"><em>netlify.com</em></a> and register for an account. Once you’ve created an account, click the “New site from Git” button. This will walk you through setting up your site deployment:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Choose your Git provider by selecting GitHub, which will connect and authorize your GitHub account.</p>&#13;
</li>&#13;
<li>&#13;
<p>Next, select the repository that contains the source code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Finally, set up your build settings.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>For our build settings, add the following (<a data-type="xref" href="#web-netlify-deploy">Figure 17-3</a>):</p>&#13;
<ol>&#13;
<li>&#13;
<p>Build command: <code>npm run deploy:src</code> (or <code>npm run deploy:final</code>, if deploying the final example code).</p>&#13;
</li>&#13;
<li>&#13;
<p>Publish directory: <code>dist</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Under “Advanced settings,” click “New variable” and add a variable name of <code>API_URI</code> with a  variable value of <em>https://&lt;your_api_name&gt;.herokuapp.com/api</em> (this will be the URL of the API application, which we deployed to Heroku).</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Once you’ve configured the application, click the “Deploy site” button. After a few minutes your application will be running at the Netlify-supplied URL. Now, anytime we push a change to our GitHub repo, our site will be automatically deployed.</p>&#13;
<div data-type="note" epub:type="note"><h1>Slow Initial Load</h1>&#13;
<p>Our deployed web application will be loading data from our deployed Heroku API. With Heroku’s free plan, application containers sleep after one hour of inactivity. If you haven’t used your API in a while, the initial data load will be slow while the container spins back up.<a data-startref="ix_ch17-asciidoc3" data-type="indexterm" id="idm45339487025544"/><a data-startref="ix_ch17-asciidoc2" data-type="indexterm" id="idm45339487024840"/></p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="web-netlify-deploy">&#13;
<img alt="A screenshot of the Netlify deployment configuration" src="assets/jsev_1703.png"/>&#13;
<h6><span class="label">Figure 17-3. </span>With Netlify we can configure our build process and environment variables</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Conclusion" data-type="sect1"><div class="sect1" id="idm45339487021880">&#13;
<h1>Conclusion</h1>&#13;
&#13;
<p>In this chapter we’ve deployed a static web application. To do this, we’ve used Netlify’s deployment pipeline features to watch for changes to our Git repository, run our build processes, and store environment variables. With this foundation, we have everything we need to publicly release web applications.<a data-startref="ix_ch17-asciidoc1" data-type="indexterm" id="idm45339487020216"/><a data-startref="ix_ch17-asciidoc0" data-type="indexterm" id="idm45339487019512"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>