<html><head></head><body><section data-pdf-bookmark="Chapter 2. The Kotlin Collections Framework" data-type="chapter" epub:type="chapter"><div class="chapter" id="the_kotlin_collections_framework">&#13;
<h1><span class="label">Chapter 2. </span>The Kotlin Collections Framework</h1>&#13;
&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-type="indexterm" id="ix_ch02-asciidoc0"/>In the preceding chapter we offered an overview of the syntax of&#13;
the Kotlin language.  As with any language, syntax is a&#13;
foundation but, really, no more than that.  When it comes to&#13;
getting actual work done, syntax alone won’t carry the&#13;
water.  To do that you need expressions and idioms that are&#13;
easy to assemble into useful code, and that are as easy for&#13;
other developers to understand and modify.</p>&#13;
&#13;
<p>One important aspect of nearly every modern language is its&#13;
<em>collections framework</em>: ways of grouping objects, and&#13;
libraries of functions that manipulate them.</p>&#13;
&#13;
<p>At the time it was introduced, Java’s collection framework&#13;
was state of the art. Today, more than 20 years later, the&#13;
basic data structures provided by newer languages have not&#13;
changed much.  All of the containers that we’re familiar with from the Java framework (or even the earliest versions of the C++&#13;
<code>stdlib</code>) are still there: <code>Iterable</code>, &#13;
<span class="keep-together"><code>Collection</code>,</span> <code>List</code>,&#13;
<code>Set</code>, and <code>Map</code> (to use their Java names). In response to&#13;
broad acceptance of functional styles of programming,&#13;
however, collections frameworks for modern languages like&#13;
Swift and Scala usually provide a set of common,&#13;
higher-order functions that operate on the collections:&#13;
<code>filter</code>, <code>map</code>, <code>flatmap</code>, <code>zip</code>, and more. You will,&#13;
indeed, find these functions in the collections framework from the Kotlin Standard Library.</p>&#13;
&#13;
<p>In this chapter, we will first visit the collections&#13;
themselves and a few interesting extensions that the&#13;
Kotlin language empowers. After that, we will dig into&#13;
some of the powerful higher-order functions that&#13;
operate on the collections.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Collection Basics" data-type="sect1"><div class="sect1" id="idm46669757821952">&#13;
<h1>Collection Basics</h1>&#13;
&#13;
<p>Kotlin’s collections framework embeds the data structures&#13;
from the Java Collections Framework as a subset.  It wraps the&#13;
basic Java classes with some new features and adds&#13;
functional transformations that operate on them.</p>&#13;
&#13;
<p>Let’s start this deep dive into the collections library with&#13;
a quick look at some of the extensions to the data&#13;
structures themselves.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Java Interoperability" data-type="sect2"><div class="sect2" id="idm46669757819504">&#13;
<h2>Java Interoperability</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="java interoperability" data-type="indexterm" id="idm46669757818128"/><a data-primary="java interoperability" data-type="indexterm" id="idm46669757817184"/>Because seamless interoperablity with Java is a central goal of the&#13;
Kotlin language, Kotlin collection data types are based on their&#13;
Java counterparts. <a data-type="xref" href="#kotlin_collections">Figure 2-1</a> illustrates the&#13;
relationship.</p>&#13;
&#13;
<figure><div class="figure" id="kotlin_collections">&#13;
<img alt="Kotlin Collections" src="assets/pawk_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>The Kotlin collection type hierarchy and its relation to Java.</h6>&#13;
</div></figure>&#13;
&#13;
<p>By making Kotlin  collection types subtypes of their Java analogs,&#13;
Kotlin preserves all of functionality of the Java Collections&#13;
Framework. For the most part, Kotlin extends, but does not alter the&#13;
Java framework.  It just adds the new, functional methods.</p>&#13;
&#13;
<p>There is one significant exception:&#13;
mutability.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Mutability" data-type="sect2"><div class="sect2" id="idm46669757812096">&#13;
<h2>Mutability</h2>&#13;
&#13;
<p>It is, perhaps, only logical that a language that embeds mutability in its syntax would also embed mutability in its&#13;
collection system.</p>&#13;
&#13;
<p>Kotlin defines two distinct type hierarchies in its&#13;
collections framework, one for collections that are mutable&#13;
and one for collections that are not. This can be seen in <a data-type="xref" href="#mutability_in_collections">Example 2-1</a>.</p>&#13;
<div data-type="example" id="mutability_in_collections">&#13;
<h5><span class="label">Example 2-1. </span>Mutable and Immutable Lists</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">mutableList</code> <code class="p">=</code> <code class="n">mutableListOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">4</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">immutableList</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">4</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code>&#13;
<code class="n">mutableList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="m">4</code><code class="p">)</code>    <code class="c1">// compiles</code>&#13;
&#13;
<code class="c1">// doesn't compile: ImmutableList has no `add` method.</code>&#13;
<code class="n">immutableList</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="m">2</code><code class="p">)</code></pre></div>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p><em>Mutable</em> is the opposite of <em>immutable</em>. A mutable object&#13;
can be changed and an immutable one cannot. The distinction&#13;
is critical when trying to optimize code. Since they cannot&#13;
change, immutable objects can be shared safely among multiple&#13;
threads. A mutable object, however, must be made explicitly&#13;
thread-safe if it is to be shared. Thread safety requires&#13;
locking or copying, which may be expensive.</p>&#13;
</div>&#13;
&#13;
<p>Unfortunately, Kotlin cannot guarantee the immutablity of&#13;
its immutable collections. Immutable collections simply do&#13;
not have mutator functions (<code>add</code>, <code>remove</code>, <code>put</code>, etc.).&#13;
Especially when a Kotlin collection is passed to Java code—where Kotlin’s immutability constraints are not enforced by&#13;
the type system—there can be no assurance that the contents&#13;
of the collection will not change.</p>&#13;
&#13;
<p>Note that the mutability of a collection is not related to&#13;
the mutability of the object that the collection contains.&#13;
As a very simple example, consider the following code:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">deeplist</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="n">mutableListOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">),</code> <code class="n">mutableListOf</code><code class="p">(</code><code class="m">3</code><code class="p">,</code> <code class="m">4</code><code class="p">))</code>&#13;
&#13;
<code class="c1">// Does not compile: "Unresolved reference: add"</code>&#13;
<code class="n">deeplist</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">listOf</code><code class="p">(</code><code class="m">3</code><code class="p">))</code>&#13;
&#13;
<code class="n">deeplist</code><code class="p">[</code><code class="m">1</code><code class="p">][</code><code class="m">1</code><code class="p">]</code> <code class="p">=</code> <code class="m">5</code>      <code class="c1">// works</code>&#13;
<code class="n">deeplist</code><code class="p">[</code><code class="m">1</code><code class="p">].</code><code class="n">add</code><code class="p">(</code><code class="m">6</code><code class="p">)</code>      <code class="c1">// works</code></pre>&#13;
&#13;
<p>The variable <code>deeplist</code> is a <code>List&lt;MutableList&lt;Int&gt;&gt;</code>.  It is&#13;
and always will be a list of two lists.  The contents of the&#13;
lists that <code>deeplist</code> contains, however, can grow, shrink, and change.</p>&#13;
&#13;
<p>The creators of Kotlin are actively investigating all things&#13;
immutable. <a data-primary="kotlinx.collections.immutable library" data-type="indexterm" id="idm46669757655952"/>The prototype &#13;
<span class="keep-together"><code>kotlinx.collections.immutable</code></span> library is intended to be a set of truly immutable collections. To use them in&#13;
your own Android/Kotlin project, add the following&#13;
dependency to your <code>build.gradle</code> file:</p>&#13;
&#13;
<pre data-type="programlisting">implementation \&#13;
'org.jetbrains.kotlinx:kotlinx-collections-immutable:$IC_VERSION'</pre>&#13;
&#13;
<p>While the <em>Kotlinx Immutable Collections Library</em> uses&#13;
state-of-the-art algorithms and optimizes them so that they&#13;
are very fast compared to other JVM implementations &#13;
<span class="keep-together">of&#13;
immutable collections,</span> these true immutable collections are&#13;
still an order of magnitude slower than their mutable&#13;
analogs. Currently, there’s nothing to be done about&#13;
it. However, many modern developers are willing to sacrifice&#13;
some performance for the safety that immutability brings,&#13;
especially in the context of &#13;
<span class="keep-together">concurrency</span>.<sup><a data-type="noteref" href="ch02.html#idm46669757650256" id="idm46669757650256-marker">1</a></sup><a data-startref="ix_ch02-asciidoc3" data-type="indexterm" id="idm46669757649664"/><a data-startref="ix_ch02-asciidoc2" data-type="indexterm" id="idm46669757648992"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Overloaded Operators" data-type="sect2"><div class="sect2" id="idm46669757811504">&#13;
<h2>Overloaded Operators</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="overloaded operators" data-type="indexterm" id="idm46669757647040"/><a data-primary="overloaded operators" data-type="indexterm" id="idm46669757645824"/>Kotlin supports a  disciplined ability to overload the meanings of certain infix operators, in particular, <code>+</code> and <code>-</code>. Kotlin’s collections framework makes good use of this capability. To demonstrate, let’s&#13;
look at a naive implementation of a function to convert&#13;
a <code>List&lt;Int&gt;</code> to a <code>List&lt;Double&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">naiveConversion</code><code class="p">(</code><code class="n">intList</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Double</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">var</code> <code class="py">ints</code> <code class="p">=</code> <code class="n">intList</code>&#13;
    <code class="k">var</code> <code class="py">doubles</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">&lt;</code><code class="n">Double</code><code class="p">&gt;()</code>&#13;
    <code class="k">while</code> <code class="p">(!</code><code class="n">ints</code><code class="p">.</code><code class="n">isEmpty</code><code class="p">())</code> <code class="p">{</code>&#13;
        <code class="k">val</code> <code class="py">item</code> <code class="p">=</code> <code class="n">ints</code><code class="p">[</code><code class="m">0</code><code class="p">]</code>&#13;
        <code class="n">ints</code> <code class="p">=</code> <code class="n">ints</code> <code class="p">-</code> <code class="n">item</code>&#13;
        <code class="n">doubles</code> <code class="p">=</code> <code class="n">doubles</code> <code class="p">+</code> <code class="n">item</code><code class="p">.</code><code class="n">toDouble</code><code class="p">()</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">doubles</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Don’t do this.  The only thing that this example does&#13;
efficiently is demonstrate the use of the two infix&#13;
operators <code>+</code> and <code>-</code>.  The former adds an element to a list&#13;
and the latter removes an element from it.</p>&#13;
&#13;
<p>The operand to the&#13;
left of a <code>+</code> or <code>-</code> operator can define the behavior of that&#13;
operator. Containers, when they appear to the left of a <code>+</code>&#13;
or <code>-</code>, define two implementations for each of those two&#13;
operators: one when the right-hand operand is&#13;
another container and the other when it is not.</p>&#13;
&#13;
<p>Adding a noncontainer object to a container creates a new container that&#13;
has all of the elements from the left-hand operand (the&#13;
container) with the new element (the right-hand operand)&#13;
added. Adding two containers together creates a new container&#13;
that has all of the elements from both.</p>&#13;
&#13;
<p>Similarly, subtracting an object from a container creates a&#13;
new container with all but the first occurrence of the&#13;
left-hand operand. Subtracting one container from another&#13;
produces a new container that has the elements of the left-hand&#13;
operand, with <em>all</em> occurrences of <em>all</em> the elements in&#13;
the right-hand operand removed.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <code>+</code> and <code>-</code> operators preserve order when the underlying&#13;
container is ordered.  For instance:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="p">(</code><code class="n">listOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code> <code class="p">+</code> <code class="m">3</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="n">listOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">))</code>    <code class="c1">// true</code>&#13;
<code class="p">(</code><code class="n">listOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code> <code class="p">+</code> <code class="n">listOf</code><code class="p">(</code><code class="m">3</code><code class="p">,</code> <code class="m">4</code><code class="p">))</code>&#13;
    <code class="p">.</code><code class="n">equals</code><code class="p">(</code><code class="n">listOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">4</code><code class="p">))</code> <code class="c1">// true</code></pre>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating Containers" data-type="sect2"><div class="sect2" id="idm46669757536208">&#13;
<h2>Creating Containers</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="creating containers" data-type="indexterm" id="idm46669757457840"/><a data-primary="containers, creating" data-type="indexterm" id="idm46669757456768"/>Kotlin does not have a way to express container literals.&#13;
There is no syntactic way, for instance, of making a <code>List</code>&#13;
of the numbers 8, 9, and 54.  Nor is there a way of making a&#13;
<code>Set</code> of the strings “Dudley” and “Mather.” Instead, there&#13;
are handy methods for creating containers that are nearly as&#13;
elegant. The code in <a data-type="xref" href="#mutability_in_collections">Example 2-1</a> showed two simple examples of creating lists. There are also&#13;
<code>...Of</code> methods for creating mutable and immutable lists,&#13;
sets, and maps.</p>&#13;
&#13;
<p>Creating literal maps requires knowing a clever trick.  The<a data-primary="mapOf function" data-type="indexterm" id="idm46669757453216"/>&#13;
<code>mapOf</code> function takes a list of <code>Pairs</code> as its argument.&#13;
Each of the pairs provides a key (the pair’s first value)&#13;
and a value (the pair’s second value). Recall that Kotlin&#13;
supports an extended set of infix operators.  Among these&#13;
operators is <code>to</code>, which creates a new <code>Pair</code> with its left&#13;
operand as the first element and its right operand as the&#13;
second element. Combine these two features and you can,&#13;
conveniently, build a <code>Map</code> like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">map</code> <code class="p">=</code> <code class="n">mapOf</code><code class="p">(</code><code class="m">1</code> <code class="n">to</code> <code class="m">2</code><code class="p">,</code> <code class="m">4</code> <code class="n">to</code> <code class="m">5</code><code class="p">)</code></pre>&#13;
&#13;
<p>The type of the content of a container is expressed using a&#13;
generic syntax very similar to Java’s. The type of the variable&#13;
map in the preceding code, for instance, is <code>Map&lt;Int, Int&gt;</code>, a container&#13;
that maps <code>Int</code> keys to their <code>Int</code> values.</p>&#13;
&#13;
<p>The Kotlin compiler is quite clever about inferring the types of the&#13;
contents of containers created with their factory methods. Obviously&#13;
in this example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">map</code> <code class="p">=</code> <code class="n">mutableMapOf</code><code class="p">(</code><code class="s">"Earth"</code> <code class="n">to</code> <code class="m">3</code><code class="p">,</code> <code class="s">"Venus"</code> <code class="n">to</code> <code class="m">4</code><code class="p">)</code></pre>&#13;
&#13;
<p>the type of <code>map</code> is <code>MutableMap&lt;String, Int&gt;</code>.  But what about this?</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">list</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">1L</code><code class="p">,</code> <code class="m">3.14</code><code class="p">)</code></pre>&#13;
&#13;
<p>Kotlin will choose the nearest type in the type hierarchy&#13;
tree that is an ancestor of all of the elements of the&#13;
container (this type is called <a data-primary="upper bound type" data-type="indexterm" id="idm46669757394800"/>the <em>upper bound type</em>). In&#13;
this case it will choose <code>Number</code>, the nearest ancestor of&#13;
both <code>Long</code> and <code>Double</code>. The variable <code>list</code> has the&#13;
inferred type <code>List&lt;Number&gt;</code>.</p>&#13;
&#13;
<p>We can add a <code>String</code>, though, as in the following:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">list</code> <code class="p">=</code> <code class="n">mutablelistOf</code><code class="p">(</code><code class="m">1L</code><code class="p">,</code> <code class="m">3.14</code><code class="p">,</code> <code class="s">"e"</code><code class="p">)</code></pre>&#13;
&#13;
<p>The only type that is an ancestor to all of the elements, a&#13;
<code>Long</code>, a <code>Double</code>, and a <code>String</code>, &#13;
<span class="keep-together">is the</span> root of the Kotlin type hierarchy, <code>Any</code>. The type of the variable <code>list</code> is&#13;
&#13;
<span class="keep-together"><code>MutableList&lt;Any&gt;</code>.</span></p>&#13;
&#13;
<p>Once again, though, recall from <a data-type="xref" href="ch01.html#kotlin_essentials">Chapter 1</a> that the type <code>Any</code> is not&#13;
the same as the type <code>Any?</code>. The following will not compile (assuming&#13;
the definition from the preceding example):</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">list</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="k">null</code><code class="p">)</code>  <code class="c1">// Error: Null cannot be a value of a non-null type Any</code></pre>&#13;
&#13;
<p>In order to allow the list to contain <code>null</code>, we’d have to specify its&#13;
type explicitly:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">list</code><code class="p">:</code> <code class="n">MutableList</code><code class="p">&lt;</code><code class="n">Any</code><code class="p">?&gt;</code> <code class="p">=</code> <code class="n">mutablelistOf</code><code class="p">(</code><code class="m">1L</code><code class="p">,</code> <code class="m">3.14</code><code class="p">,</code> <code class="s">"e"</code><code class="p">)</code></pre>&#13;
&#13;
<p>We can create collections now. So, what do we do with them?</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functional Programming" data-type="sect1"><div class="sect1" id="idm46669757458688">&#13;
<h1>Functional Programming</h1>&#13;
&#13;
<p>We operate on them! Nearly all of the operations that we&#13;
will discuss here are based on the paradigm of functional&#13;
programming. In order to understand their context and&#13;
motivation, let’s review the paradigm.</p>&#13;
&#13;
<p><a data-primary="object-oriented programming (OOP)" data-type="indexterm" id="idm46669757249296"/><a data-primary="OOP (object-oriented programming)" data-type="indexterm" id="idm46669757248624"/><em>Object-oriented programming</em> (OOP) and <em>functional programming</em>&#13;
(FP) are both paradigms for software design. Software&#13;
architects understood the promise of functional programming&#13;
soon after its invention in the late 1950s. Early functional&#13;
programs tended to be slow, though, and it’s only recently&#13;
that the functional style has been able to challenge a more&#13;
pragmatic imperative model for performance. As programs&#13;
get more complex and difficult to understand, as concurrency&#13;
becomes inevitable, and as compiler optimization improves,&#13;
functional programming is changing from a cute academic toy&#13;
into a useful tool that every developer should be able to&#13;
wield.</p>&#13;
&#13;
<p>Functional programming encourages <em>immutability</em>.  Unlike&#13;
the functions in code, mathematical functions don’t change&#13;
things.  They don’t “return” anything.  They simply have a&#13;
value. Just as “4” and “2 + 2” are names for the same&#13;
number, a given function evaluated with given parameters is&#13;
simply a name (perhaps a verbose name!) for its value.&#13;
Because mathematical functions do not change, they are not&#13;
affected by time. This is immensely useful when working in&#13;
a concurrent environment.</p>&#13;
&#13;
<p>Though different, FP and OOP paradigms can coexist. Java was,&#13;
certainly, designed as an OO language, and Kotlin, fully interoperable,&#13;
can duplicate Java algorithms nearly word for word. As we&#13;
proclaimed in the preceding chapter, though, the true power of Kotlin lies&#13;
in its extensible functional programming capabilities. It’s not&#13;
uncommon for folks to start out writing “Java in Kotlin.” As they&#13;
start to feel more comfortable, they tend to gravitate toward more&#13;
idiomatic Kotlin, and much of that involves applying the power of FP.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functional Versus Procedural: A Simple Example" data-type="sect2"><div class="sect2" id="idm46669757244112">&#13;
<h2>Functional Versus Procedural: A Simple Example</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="example" data-type="indexterm" id="idm46669757242544"/><a data-primary="functional programming" data-secondary="procedural versus" data-type="indexterm" id="idm46669757241504"/><a data-primary="procedural programming" data-type="indexterm" id="idm46669757240560"/>The following code shows a procedural way of working with a&#13;
collection:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">forAll</code><code class="p">()</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">x</code> <code class="k">in</code> <code class="n">collection</code><code class="p">)</code> <code class="p">{</code> <code class="n">doSomething</code><code class="p">(</code><code class="n">x</code><code class="p">)</code> <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the example, a <code>for</code> loop iterates over a list.  It&#13;
selects an element from <code>collection</code> and assigns it to the&#13;
variable <code>x</code>. It then calls the method <code>doSomething</code> on the&#13;
element. It does this for each element in the list.</p>&#13;
&#13;
<p>The only constraint on the collection is that there must be&#13;
a way to fetch each of its elements exactly once.  That&#13;
capability is precisely what is encapsulated by the type&#13;
<code>Iterable&lt;T&gt;</code>.</p>&#13;
&#13;
<p>The functional paradigm is certainly less complicated: no extra variables and no special syntax. Just a single method call:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">forAll</code><code class="p">()</code> <code class="p">=</code> <code class="n">collection</code><code class="p">.</code><code class="n">forEach</code><code class="p">(</code><code class="o">::</code><code class="n">doSomething</code><code class="p">)</code></pre>&#13;
&#13;
<p><a data-primary="forEach method" data-type="indexterm" id="idm46669757152432"/>The <code>forEach</code> method takes a function as its argument. That argument, <code>doSomething</code> in this case, is a function that&#13;
takes a single parameter of the type contained in&#13;
&#13;
<span class="keep-together"><code>collection</code>.</span>  In other words, if <code>collection</code> is a&#13;
list of <code>String</code>s, <code>doSomething</code> must be &#13;
<span class="keep-together"><code>doSomething(s: String)</code>.</span> If <code>collection</code> is a <code>Set&lt;Freeptootsie&gt;</code>, then&#13;
&#13;
<span class="keep-together"><code>doSomething</code></span> must be <code>doSomething(ft: Freeptootsie)</code>. The&#13;
<code>forEach</code> method calls its argument (<code>doSomething</code>) with&#13;
each element in <code>collection</code> as its parameter.</p>&#13;
&#13;
<p>This might seem like an insignificant difference. It is not. The&#13;
<code>forEach</code> method is a much better separation of concerns.</p>&#13;
&#13;
<p>An <code>Iterable&lt;T&gt;</code> is stateful, ordered, and time dependent.&#13;
Anyone who has ever had to deal with a&#13;
<code>ConcurrentModificationException</code> knows it is entirely&#13;
possible that the state of an iterator may not match the&#13;
state of the collection over which it &#13;
<span class="keep-together">is iterating.</span> While&#13;
Kotlin’s <code>forEach</code> operator is not completely immune to&#13;
&#13;
<span class="keep-together"><code>ConcurrentModificationException</code>,</span> those exceptions occur in&#13;
code that is actually concurrent.</p>&#13;
&#13;
<p>More importantly, the mechanism that a collection uses to&#13;
apply a passed function to each of its elements is entirely&#13;
the business of the collection itself. In particular, there is&#13;
no intrinsic contract about the order in which the function&#13;
will be evaluated on the collection’s elements.</p>&#13;
&#13;
<p>A collection could, for instance, divide its elements into&#13;
groups. It could farm each of these groups out to a separate&#13;
processor and then reassemble the results. This approach is&#13;
particularly interesting at a time when the number of cores&#13;
in a processor is increasing rapidly. The <code>Iterator&lt;T&gt;</code>&#13;
contract cannot support this kind of parallel execution.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Functional Android" data-type="sect2"><div class="sect2" id="idm46669757243488">&#13;
<h2>Functional Android</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="functional Android" data-type="indexterm" id="idm46669757128016"/><a data-primary="functional Android" data-type="indexterm" id="idm46669757127168"/><a data-primary="functional programming" data-secondary="Android and" data-type="indexterm" id="idm46669757126496"/>Android has a quirky history with functional programming.&#13;
Because its virtual machine has nothing to do with Java’s,&#13;
improvements in the Java language have not necessarily been&#13;
available to Android developers. Some of the most important&#13;
changes in Java, including lambdas and method references,&#13;
were not supported in Android for quite a while after they&#13;
appeared in Java 8.</p>&#13;
&#13;
<p>Although Java could compile these new features and DEX&#13;
(Android’s bytecode) could even represent them (though,&#13;
perhaps, not efficiently), the Android toolchain couldn’t&#13;
convert the representations of these features—the&#13;
compiled Java bytecode—into the DEX code that could be run&#13;
on an Android system.</p>&#13;
&#13;
<p>The first attempt to fill the gap was a package called&#13;
<em>RetroLambda</em>. Other add-on library solutions followed,&#13;
sometimes with confusing rules (e.g., with the Android Gradle&#13;
Plugin [AGP] 3.0+, if you wanted to use the Java Streams API&#13;
you had to target, at a minimum, Android API 24).</p>&#13;
&#13;
<p>All of these constraints are now gone with Kotlin on&#13;
Android.  Recent versions of the AGP will support functional&#13;
programming even on older versions of Android. You can now&#13;
use the full Kotlin collection package on any supported&#13;
platform.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kotlin Transformation Functions" data-type="sect1"><div class="sect1" id="idm46669757122384">&#13;
<h1>Kotlin Transformation Functions</h1>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="transformation functions" data-type="indexterm" id="ix_ch02-asciidoc4"/><a data-primary="transformation functions" data-type="indexterm" id="ix_ch02-asciidoc5"/>In this section, you will see how Kotlin brings functional capabilities to collections to provide elegant&#13;
and safe ways of manipulating them. Just as in the previous&#13;
chapter we didn’t visit all of Kotlin’s syntax, we will&#13;
not in this chapter attempt to visit all of Kotlin’s&#13;
library functions. It isn’t necessary to memorize them all. It is&#13;
essential, though, for idiomatic and effective use of Kotlin,&#13;
to get comfortable with a few key transforms and to get a&#13;
feel for how they work.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Boolean Functions" data-type="sect2"><div class="sect2" id="idm46669757118128">&#13;
<h2>The Boolean Functions</h2>&#13;
&#13;
<p><a data-primary="Boolean functions" data-type="indexterm" id="idm46669757116784"/><a data-primary="collections framework (Kotlin)" data-secondary="Boolean functions" data-type="indexterm" id="idm46669757115856"/><a data-primary="transformation functions" data-secondary="Boolean functions" data-type="indexterm" id="idm46669757114944"/>A convenient set of collection functions return a <code>Boolean</code>&#13;
to indicate whether the collection has—or does not have—a given attribute. The <a data-primary="any() function" data-type="indexterm" id="idm46669757113408"/>function <code>any()</code>, for instance,&#13;
will return <code>true</code> when a collection contains at least one&#13;
element. If used with a predicate, as in <code>any { predicate(it) }</code>, <code>any</code> will return <code>true</code> if the predicate evaluates true&#13;
for any element in the collection:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">nums</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="m">20</code><code class="p">,</code> <code class="m">100</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">isAny</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">any</code><code class="p">()</code>                 <code class="c1">// true</code>&#13;
<code class="k">val</code> <code class="py">isAnyOdd</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">any</code> <code class="p">{</code> <code class="n">it</code> <code class="p">%</code> <code class="m">1</code> <code class="p">&gt;</code> <code class="m">0</code> <code class="p">}</code> <code class="c1">// true</code>&#13;
<code class="k">val</code> <code class="py">isAnyBig</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">any</code> <code class="p">{</code> <code class="n">it</code> <code class="p">&gt;</code> <code class="m">1000</code><code class="p">}</code>   <code class="c1">// false</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>When a lambda takes only a single argument and the Kotlin&#13;
compiler can figure that out using type inferencing (it&#13;
usually can), you can omit the parameter declaration and use&#13;
the implicit parameter named <code>it</code>. The preceding example uses&#13;
this shortcut twice, in the definitions of the predicates to&#13;
the <code>any</code> method.</p>&#13;
</div>&#13;
&#13;
<p>Another boolean function, <code>all { predicate }</code>, returns <code>true</code> only if&#13;
every element in the list matches the predicate:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">nums</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="m">20</code><code class="p">,</code> <code class="m">100</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">isAny</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">all</code> <code class="p">{</code> <code class="n">it</code> <code class="p">%</code> <code class="m">1</code> <code class="p">&gt;</code> <code class="m">0</code> <code class="p">}</code> <code class="c1">// false</code></pre>&#13;
&#13;
<p>The opposite of <code>any</code> is <code>none</code>. Without a predicate, <code>none()</code> returns&#13;
<code>true</code> only if there are no elements in a collection. With a predicate,&#13;
<code>none { predicate }</code> returns <code>true</code> only if the predicate evaluates to&#13;
true for none of the elements in the collection.  For example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">nums</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="m">20</code><code class="p">,</code> <code class="m">100</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">isAny</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">none</code><code class="p">()</code>              <code class="c1">// false</code>&#13;
<code class="k">val</code> <code class="py">isAny4</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">none</code> <code class="p">{</code> <code class="n">it</code> <code class="p">==</code> <code class="m">4</code> <code class="p">}</code>   <code class="c1">// true</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Filter Functions" data-type="sect2"><div class="sect2" id="idm46669756960048">&#13;
<h2>Filter Functions</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="filter functions" data-type="indexterm" id="ix_ch02-asciidoc6"/><a data-primary="filter functions" data-type="indexterm" id="ix_ch02-asciidoc7"/><a data-primary="transformation functions" data-secondary="filter functions" data-type="indexterm" id="ix_ch02-asciidoc8"/>The basic <code>filter</code> function will return a new collection&#13;
containing only the elements of the original&#13;
collection that match the given predicate. In this example,&#13;
for instance, the variable <code>numbers</code> will contain a list&#13;
with the single value <code>100</code>:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">nums</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="m">20</code><code class="p">,</code> <code class="m">100</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">numbers</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code> <code class="p">&gt;</code> <code class="m">20</code> <code class="p">}</code></pre>&#13;
&#13;
<p><a data-primary="filterNot function" data-type="indexterm" id="idm46669756888400"/>The <code>filterNot</code> function is the reverse.  It returns elements that do&#13;
<em>not</em> match the predicate. In this example, for instance, the&#13;
variable <code>numbers</code> will contain three elements, 10, 20,&#13;
and 5: the elements of <code>nums</code> that are not greater than 20:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">nums</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">10</code><code class="p">,</code> <code class="m">20</code><code class="p">,</code> <code class="m">100</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">numbers</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">filterNot</code> <code class="p">{</code> <code class="n">it</code> <code class="p">&gt;</code> <code class="m">20</code> <code class="p">}</code></pre>&#13;
&#13;
<p>A beautifully convenient special case of <code>filterNot</code> is the function&#13;
<code>filterNotNull</code>. It removes all of the <code>null</code>s from a collection:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">nums</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="k">null</code><code class="p">,</code> <code class="m">20</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="m">5</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">numbers</code> <code class="p">=</code> <code class="n">nums</code><code class="p">.</code><code class="n">filterNotNull</code><code class="p">()</code> <code class="c1">// { 20, 5 }</code></pre>&#13;
&#13;
<p>In this example, the variable <code>numbers</code> will be a list containing two&#13;
elements, 20 and 5.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Map" data-type="sect2"><div class="sect2" id="idm46669756772960">&#13;
<h2>Map</h2>&#13;
&#13;
<p><a data-primary="map function" data-type="indexterm" id="ix_ch02-asciidoc9"/>The <em>map</em> function applies its argument to each element&#13;
in a collection and returns a collection of the resulting values.&#13;
Note that it does not mutate the collection to which it is&#13;
applied; it returns a new, resulting, collection.</p>&#13;
&#13;
<p>Here is the definition of the <code>map</code> function, for the <code>Array</code> type:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">inline</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">,</code> <code class="n">R</code><code class="p">&gt;</code> <code class="n">Array</code><code class="p">&lt;</code><code class="k">out</code> <code class="n">T</code><code class="p">&gt;.</code><code class="n">map</code><code class="p">(</code><code class="n">transform</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">R</code><code class="p">):</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">R</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Let’s unpack this.</p>&#13;
&#13;
<p>Starting at the left, <code>map</code> is an inline function.  The “fun”&#13;
part should be clear by now.  But what about “inline.”</p>&#13;
&#13;
<p>The keyword <code>inline</code> tells the Kotlin compiler to copy the&#13;
bytecode for a function directly into the binary whenever&#13;
the method is called, instead of generating a transfer to a single&#13;
compiled version. When the number of&#13;
instructions necessary to call a function is a substantial&#13;
percentage of the total number necessary to run it, an&#13;
<code>inline</code> function makes sense as a trade-off of space for&#13;
time. Sometimes, too, it can remove the overhead of the&#13;
extra object allocation that some lambda expressions&#13;
require.</p>&#13;
&#13;
<p>Next, <code>&lt;T, R&gt;</code> are the two, free, type variables used in the function&#13;
definition.  We’ll get back to them.</p>&#13;
&#13;
<p>Next is the description of the receiver, <code>Array&lt;out T&gt;</code>.&#13;
This <code>map</code> function is an extension function on the <code>Array</code> type: it&#13;
is a function on an array whose elements are of type <code>T</code> (or one of&#13;
<code>T</code>’s superclasses, e.g., <code>Any</code>).</p>&#13;
&#13;
<p>Next is the <code>map</code>’s parameter. The parameter is a function named<a data-primary="transformation functions" data-type="indexterm" id="idm46669756679104"/> <em>transform</em>. Transform is a function <code>transform: (T) -&gt; R</code>: it takes as its argument something of type <code>T</code> and returns something of type <code>R</code>.  Well!  That’s interesting! The array to which the function will be applied is full of objects of type <code>T</code>!  The function can be applied to the elements of the array.</p>&#13;
&#13;
<p>Finally, there is <code>map</code>’s return.  It is a <code>List&lt;R&gt;</code>, a list&#13;
whose elements are of type <code>R</code>.  An <code>R</code> is what you get if you&#13;
apply <code>transform</code> to an elements of the array (a <code>T</code> ).</p>&#13;
&#13;
<p>It all works out.  Calling <code>map</code> on an array with a function&#13;
that can be applied to the elements of the array will&#13;
return a new <code>List</code> that contains the results of the&#13;
application of the function to each of the elements in the&#13;
array.</p>&#13;
&#13;
<p>Here’s an example that returns a list of starting dates for&#13;
employee records that have those starting dates stored as&#13;
strings:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Hire</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">position</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">startDate</code><code class="p">:</code> <code class="n">String</code>&#13;
<code class="p">)</code>&#13;
&#13;
<code class="k">fun</code> <code class="nf">List</code><code class="p">&lt;</code><code class="n">Hire</code><code class="p">&gt;.</code><code class="n">getStartDates</code><code class="p">():</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Date</code><code class="p">&gt;</code> <code class="p">{</code>&#13;
    <code class="k">val</code> <code class="py">formatter</code>&#13;
        <code class="p">=</code> <code class="n">SimpleDateFormat</code><code class="p">(</code><code class="s">"yyyy-MM-d"</code><code class="p">,</code> <code class="n">Locale</code><code class="p">.</code><code class="n">getDefault</code><code class="p">())</code>&#13;
    <code class="k">return</code> <code class="n">map</code> <code class="p">{</code>&#13;
        <code class="k">try</code> <code class="p">{</code>&#13;
            <code class="n">formatter</code><code class="p">.</code><code class="n">parse</code><code class="p">(</code><code class="n">it</code><code class="p">.</code><code class="n">startDate</code><code class="p">)</code>&#13;
        <code class="p">}</code> <code class="k">catch</code> <code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">Exception</code><code class="p">)</code> <code class="p">{</code>&#13;
            <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code>&#13;
                <code class="s">"getStartDates"</code><code class="p">,</code>&#13;
                <code class="s">"Unable to format first date. $e"</code><code class="p">)</code>&#13;
            <code class="n">Date</code><code class="p">()</code>&#13;
        <code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Perhaps you’re wondering: “What happens if the transform function doesn’t&#13;
return a value?” Ah! But Kotlin functions <em>always</em> have a value!</p>&#13;
&#13;
<p>For example:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">doubles</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Double</code><code class="p">?&gt;</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">1.0</code><code class="p">,</code> <code class="m">2.0</code><code class="p">,</code> <code class="m">3.0</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="m">5.0</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">squares</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Double</code><code class="p">?&gt;</code> <code class="p">=</code> <code class="n">doubles</code><code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">it</code><code class="o">?.</code><code class="n">pow</code><code class="p">(</code><code class="m">2</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
&#13;
<p>In this example, the variable <code>squares</code> will be the list [1.0,&#13;
4.0, 9.0, null, 25.0]. Because of the conditional operator, <code>?.</code>,&#13;
in the transform function, the function’s value is the&#13;
square of its argument, if that argument is not null.  If&#13;
the argument is null, however, the function has the value&#13;
<code>null</code>.</p>&#13;
&#13;
<p>There are several variations on the <code>map</code> function in the&#13;
Kotlin library.  One of them, <code>mapNotNull</code>, addresses situations like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">doubles</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Double</code><code class="p">?&gt;</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">1.0</code><code class="p">,</code> <code class="m">2.0</code><code class="p">,</code> <code class="m">3.0</code><code class="p">,</code> <code class="k">null</code><code class="p">,</code> <code class="m">5.0</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">squares</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Double</code><code class="p">?&gt;</code> <code class="p">=</code> <code class="n">doubles</code><code class="p">.</code><code class="n">mapNotNull</code> <code class="p">{</code> <code class="n">it</code><code class="o">?.</code><code class="n">pow</code><code class="p">(</code><code class="m">2</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
&#13;
<p>The value of the variable <code>squares</code> in this example is [1.0,&#13;
4.0, 9.0, 25.0].</p>&#13;
&#13;
<p>Another variant of <code>map</code> is<a data-primary="mapIndexed.mapIndexed" data-type="indexterm" id="idm46669756401616"/> <code>mapIndexed</code>. <code>mapIndexed</code> also&#13;
takes a function as its argument.  Unlike <code>map</code>, though,&#13;
<code>mapIndexed</code>’s functional argument takes an element of the&#13;
collection as its second parameter (not its first and only&#13;
parameter, as did <code>map</code>’s argument). <code>mapIndexed</code>’s&#13;
functional argument takes, as its first parameter, an <code>Int</code>.&#13;
The <code>Int</code> is the ordinal that gives the position  in the&#13;
collection of the element that is its second paramter: 0 for&#13;
the first element, 1 for the second, and so on.</p>&#13;
&#13;
<p>There are mapping functions for most collection-like&#13;
objects. There are even similar functions for <code>Map</code>s&#13;
(though they are not subtypes of <code>Collection</code>): the functions&#13;
<code>Map::mapKeys</code> and <code>Map::mapValues</code><a data-startref="ix_ch02-asciidoc9" data-type="indexterm" id="idm46669756395200"/>.<a data-startref="ix_ch02-asciidoc8" data-type="indexterm" id="idm46669756394368"/><a data-startref="ix_ch02-asciidoc7" data-type="indexterm" id="idm46669756393664"/><a data-startref="ix_ch02-asciidoc6" data-type="indexterm" id="idm46669756392992"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="flatMap" data-type="sect2"><div class="sect2" id="idm46669756772048">&#13;
<h2>flatMap</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="flatMap" data-type="indexterm" id="idm46669756391280"/><a data-primary="flatMap" data-type="indexterm" id="idm46669756390288"/><a data-primary="transformation functions" data-secondary="flatMap" data-type="indexterm" id="idm46669756389616"/>The thing that makes the <code>flatMap</code> function hard to understand&#13;
is that it may seem abstract and not particularly useful.&#13;
It turns out that, although it is abstract, it is quite&#13;
useful.</p>&#13;
&#13;
<p>Let’s start with an analogy. Suppose you decide to reach&#13;
out to the members of your old high school debate team. You&#13;
don’t know how to get in touch anymore. You do remember,&#13;
though, that you have yearbooks for all four years you&#13;
were in the school and that each yearbook has a picture of&#13;
the debate team.</p>&#13;
&#13;
<p>You decide to divide the process of contacting members into&#13;
two steps. First you will examine each photo of the&#13;
team and try to identify each person depicted there.&#13;
You will make a list of the people you identify. You will&#13;
then combine the four lists into a single list of all&#13;
debate-team members.</p>&#13;
&#13;
<p>That’s flatmapping! It’s all about containers. Let’s&#13;
generalize.</p>&#13;
&#13;
<p>Suppose you have some kind of container of something. It is a <code>CON&lt;T&gt;</code>. In the yearbook example, <code>CON&lt;T&gt;</code> was four&#13;
photographs, a <code>Set&lt;Photo&gt;</code>. Next you have a function that&#13;
maps <code>T -&gt; KON&lt;R&gt;</code>. That is, it takes an element of <code>CON</code> and&#13;
turns it into a new kind of container, a <code>KON</code>, whose elements&#13;
are of type <code>R</code>. In the example, this was you identifying&#13;
each person in one of the photos, and producing a&#13;
list of names of people in the photo. <code>KON</code> is a paper list&#13;
and <code>R</code> is the name of a person.</p>&#13;
&#13;
<p>The result of the <code>flatMap</code> function in the example is the&#13;
consolidated list of names.</p>&#13;
&#13;
<p>The flatmap on <code>CON&lt;T&gt;</code> is the function:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">,</code> <code class="n">R</code><code class="p">&gt;</code> <code class="n">CON</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">flatMap</code><code class="p">(</code><code class="n">transform</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">KON</code><code class="p">&lt;</code><code class="n">R</code><code class="p">&gt;):</code> <code class="n">KON</code><code class="p">&lt;</code><code class="n">R</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>Note, just for comparison, how <code>flatMap</code> is different from&#13;
<code>map</code>. The <code>map</code> function, for the container <code>CON</code>, using&#13;
the same transform function, has a signature like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">,</code> <code class="n">R</code><code class="p">&gt;</code> <code class="n">CON</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;.</code><code class="n">map</code><code class="p">(</code><code class="n">transform</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">KON</code><code class="p">&lt;</code><code class="n">R</code><code class="p">&gt;):</code> <code class="n">CON</code><code class="p">&lt;</code><code class="n">KON</code><code class="p">&lt;</code><code class="n">R</code><code class="p">&gt;&gt;</code></pre>&#13;
&#13;
<p>The <code>flatMap</code> function “flattens” away one of the&#13;
containers.</p>&#13;
&#13;
<p>While we’re on the subject, let’s take a look at an example&#13;
of the use of <code>flatMap</code> that is very common:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">list</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">List</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;&gt;</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="n">listOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">2</code><code class="p">,</code> <code class="m">3</code><code class="p">,</code> <code class="m">4</code><code class="p">),</code> <code class="n">listOf</code><code class="p">(</code><code class="m">5</code><code class="p">,</code> <code class="m">6</code><code class="p">))</code>&#13;
<code class="k">val</code> <code class="py">flatList</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Int</code><code class="p">&gt;</code> <code class="p">=</code> <code class="n">list</code><code class="p">.</code><code class="n">flatMap</code> <code class="p">{</code> <code class="n">it</code> <code class="p">}</code></pre>&#13;
&#13;
<p>The variable <code>flatList</code> will have the value [1, 2, 3, 4, 5, 6].</p>&#13;
&#13;
<p>This example can be confusing. Unlike the previous example,&#13;
which converted a set of photographs to lists of names and then&#13;
consolidated those lists, in this common example the two&#13;
container types <code>CON</code> and <code>KON</code> are the same: they are <code>List&lt;Int&gt;</code>.&#13;
That can make it difficult to see what’s actually going on.</p>&#13;
&#13;
<p>Just to prove that it works, though, let’s go through the&#13;
exercise of binding the quantities in this somewhat baffling&#13;
example to the types in the function description. The&#13;
function is applied to a <code>List&lt;List&lt;Int&gt;&gt;</code>, so <code>T</code> must be a&#13;
<code>List&lt;Int&gt;</code>. The transform function is the identity function.&#13;
In other words, it is <code>(List&lt;Int&gt;) -&gt; List&lt;Int&gt;</code>: it returns&#13;
its parameter.  This means that <code>KON&lt;R&gt;</code> must also be a&#13;
<code>List&lt;Int&gt;</code> and <code>R</code> must be an <code>Int</code>. The <code>flatMap</code> function,&#13;
then, will return a <code>KON&lt;R</code>&gt;, a <code>List&lt;Int&gt;</code>.</p>&#13;
&#13;
<p>It works.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Grouping" data-type="sect2"><div class="sect2" id="idm46669756392192">&#13;
<h2>Grouping</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="grouping" data-type="indexterm" id="idm46669756189056"/><a data-primary="transformation functions" data-secondary="grouping" data-type="indexterm" id="idm46669756188112"/>In addition to filtering, the Kotlin Standard Library provides another&#13;
small set of transformation extension functions that group elements of&#13;
a collection. The signature for the<a data-primary="groupBy function" data-type="indexterm" id="idm46669756186832"/> <code>groupBy</code> function, for instance,&#13;
looks like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">inline</code> <code class="k">fun</code> <code class="err">&lt;</code><code class="nf">T</code><code class="p">,</code> <code class="n">K</code><code class="p">&gt;</code> <code class="n">Array</code><code class="p">&lt;</code><code class="k">out</code> <code class="n">T</code><code class="p">&gt;</code>&#13;
    <code class="p">.</code><code class="n">groupBy</code><code class="p">(</code><code class="n">keySelector</code><code class="p">:</code> <code class="p">(</code><code class="n">T</code><code class="p">)</code> <code class="p">-&gt;</code> <code class="n">K</code><code class="p">):</code> <code class="n">Map</code><code class="p">&lt;</code><code class="n">K</code><code class="p">,</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">T</code><code class="p">&gt;&gt;</code></pre>&#13;
&#13;
<p>As is often the case, you can intuit this function’s&#13;
behavior just by looking at the type information.  <code>groupBy</code>&#13;
is a function that takes an <code>Array</code> of things (<code>Array</code> in&#13;
this case: there are equivalents for other container types).&#13;
For each of the things, it applies the <code>keySelector</code> method.&#13;
That method, somehow, labels the thing with a value of type&#13;
<code>K</code>. The return from the <code>groupBy</code> method is a map of each of those&#13;
labels to a list of the things to which the <code>keySelector</code>&#13;
assigned that label.</p>&#13;
&#13;
<p>An example will help:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">numbers</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code><code class="m">1</code><code class="p">,</code> <code class="m">20</code><code class="p">,</code> <code class="m">18</code><code class="p">,</code> <code class="m">37</code><code class="p">,</code> <code class="m">2</code><code class="p">)</code>&#13;
<code class="k">val</code> <code class="py">groupedNumbers</code> <code class="p">=</code> <code class="n">numbers</code><code class="p">.</code><code class="n">groupBy</code> <code class="p">{</code>&#13;
    <code class="k">when</code> <code class="p">{</code>&#13;
        <code class="n">it</code> <code class="p">&lt;</code> <code class="m">20</code> <code class="p">-&gt;</code> <code class="s">"less than 20"</code>&#13;
        <code class="k">else</code> <code class="p">-&gt;</code> <code class="s">"greater than or equal to 20"</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The variable <code>groupedNumbers</code> now contains a <code>Map&lt;String, List&lt;Int&gt;&gt;</code>.&#13;
The map has two keys, “less than 20” and “greater than or equal to&#13;
20.” The value for the first key is the list [1, 18, 2].  The value&#13;
for the second is [20, 37].</p>&#13;
&#13;
<p>Maps that are generated from grouping functions will&#13;
preserve  the order of the elements in the original&#13;
collection, in the lists that are the values of the keys of&#13;
the output map.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Iterators Versus Sequences" data-type="sect2"><div class="sect2" id="idm46669756056240">&#13;
<h2>Iterators Versus Sequences</h2>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="iterators versus sequences" data-type="indexterm" id="idm46669756054736"/><a data-primary="iterators, sequences" data-type="indexterm" id="idm46669756053680"/><a data-primary="sequences, iterators versus" data-type="indexterm" id="idm46669756053008"/><a data-primary="transformation functions" data-secondary="iterators versus sequences" data-type="indexterm" id="idm46669756052320"/>Suppose you are going to paint your desk.  You decide that it will&#13;
look much nicer if it is a nice shade of brown instead of that&#13;
generic tan. You head down to the paint store and discover that there&#13;
are around 57 colors that might be just the thing.</p>&#13;
&#13;
<p>What you do next? Do you buy samples of each of the colors to&#13;
take home? Almost certainly not! Instead, you buy samples of two or three that seem promising and try them. If they turn out not to be&#13;
all your heart desires, you go back to the store and buy three more.&#13;
Instead of buying samples of all the candidate colors and iterating over&#13;
them, you create a process that will let you get the next candidate&#13;
colors, given the ones you have already tried.</p>&#13;
&#13;
<p>A sequence differs from an iterator in a similar way. An iterator is&#13;
a way of getting each element from an existing collection exactly&#13;
once. The collection exists. All the iterator needs to do is order&#13;
it.</p>&#13;
&#13;
<p>A sequence, on the other hand, is not necessarily backed by a&#13;
collection. Sequences are backed by<a data-primary="generators" data-type="indexterm" id="idm46669756048928"/> <em>generators</em>. A generator is a&#13;
function that will provide the next item in the sequence. In this&#13;
example, if you need more paint samples, you have a way of&#13;
getting them: you go back to the store and buy more. You don’t have&#13;
to buy them all and iterate over them. You just need to buy a couple&#13;
because you know how to get more. You can stop when you find the&#13;
right color, and with luck, that will happen before you pay for&#13;
samples of all of the possible colors.</p>&#13;
&#13;
<p>In Kotlin, you might express your search for desk paint like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">deskColor</code> <code class="p">=</code> <code class="n">generateSequence</code><code class="p">(</code><code class="s">"burnt umber"</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">buyAnotherPaintSample</code><code class="p">(</code><code class="n">it</code><code class="p">)</code>&#13;
<code class="p">}.</code><code class="n">first</code> <code class="p">{</code> <code class="n">looksGreat</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code>&#13;
&#13;
<code class="n">println</code><code class="p">(</code><code class="s">"Start painting with ${deskColor}!"</code><code class="p">)</code></pre>&#13;
&#13;
<p>This algorithm is efficient.  On average, desk painters using it&#13;
will buy only 28 paint samples instead of 57.</p>&#13;
&#13;
<p>Because sequences are lazy—only generating the next element when it&#13;
is needed—they can be very, very useful in optimizing operations,&#13;
even on collections with fixed content. Suppose, for instance, that&#13;
you have a list of URLs, and you want to know which one is a link to a&#13;
page that contains an image of a cat. You might do it like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">catPage</code> <code class="p">=</code> <code class="n">listOf</code><code class="p">(</code>&#13;
    <code class="s">"http://ragdollies.com"</code><code class="p">,</code>&#13;
    <code class="s">"http://dogs.com"</code><code class="p">,</code>&#13;
    <code class="s">"http://moredogs.com"</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">fetchPage</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code>&#13;
    <code class="p">.</code><code class="n">first</code> <code class="p">{</code> <code class="n">hasCat</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
&#13;
<p>That algorithm will download all of the pages. If you do the same thing&#13;
using a &#13;
<span class="keep-together">sequence:</span></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">catPage</code> <code class="p">=</code> <code class="n">sequenceOf</code><code class="p">(</code>&#13;
    <code class="s">"http://ragdollies.com"</code><code class="p">,</code>&#13;
    <code class="s">"http://dogs.com"</code><code class="p">,</code>&#13;
    <code class="s">"http://moredogs.com"</code><code class="p">)</code>&#13;
    <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">fetchPage</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code>&#13;
    <code class="p">.</code><code class="n">first</code> <code class="p">{</code> <code class="n">hasCat</code><code class="p">(</code><code class="n">it</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
&#13;
<p>only the first page will be downloaded. The sequence will provide the&#13;
first URL, the <code>map</code> function will fetch it, and the <code>first</code> function&#13;
will be satisfied. None of the other pages will be downloaded.</p>&#13;
&#13;
<p>Be careful, though! Don’t ask for all of the elements of an infinite&#13;
collection! This code, for instance, will eventually produce an&#13;
<code>OutOfMemory</code> error:<a data-startref="ix_ch02-asciidoc5" data-type="indexterm" id="idm46669755917440"/><a data-startref="ix_ch02-asciidoc4" data-type="indexterm" id="idm46669755916736"/></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">nums</code> <code class="p">=</code> <code class="n">generateSequence</code><code class="p">(</code><code class="m">1</code><code class="p">)</code> <code class="p">{</code> <code class="n">it</code> <code class="p">+</code> <code class="m">1</code> <code class="p">}</code>&#13;
    <code class="p">.</code><code class="n">map</code> <code class="p">{</code> <code class="n">it</code> <code class="p">*</code> <code class="m">7</code> <code class="p">}</code>                 <code class="c1">// that's fine</code>&#13;
    <code class="p">.</code><code class="n">filter</code> <code class="p">{</code> <code class="n">it</code> <code class="n">mod</code> <code class="m">10000</code> <code class="p">=</code> <code class="m">0</code> <code class="p">}</code>    <code class="c1">// still ok</code>&#13;
    <code class="p">.</code><code class="n">asList</code><code class="p">()</code>                       <code class="c1">// FAIL!</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="An Example" data-type="sect1"><div class="sect1" id="idm46669756055648">&#13;
<h1>An Example</h1>&#13;
&#13;
<p><a data-primary="collections framework (Kotlin)" data-secondary="example" data-type="indexterm" id="ix_ch02-asciidoc10"/>Let’s make all this concrete with an example.</p>&#13;
&#13;
<p>We just met several of the handy functions that Kotlin’s Standard&#13;
Library provides for manipulating collections. Using those&#13;
functions, you can create robust implementations of complex logic. To&#13;
illustrate that, we’ll take an example inspired by a real&#13;
application used in an aircraft engine factory.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Problem" data-type="sect2"><div class="sect2" id="idm46669755814384">&#13;
<h2>The Problem</h2>&#13;
&#13;
<p>Bandalorium Inc. builds aircraft engines. Each engine part is&#13;
uniquely identifiable by its serial number. Each part goes&#13;
through a rigorous quality control process that records&#13;
numerical measurements for several of the part’s critical&#13;
attributes.</p>&#13;
&#13;
<p>An attribute for an engine part is any measurable feature.&#13;
For example, the outside diameter of a tube might be an&#13;
attribute. The electrical resistance of some wire might be&#13;
another. A third might be a part’s ability to reflect a&#13;
certain color of light.  The only requirement is that&#13;
measuring the attribute must produce a single numerical&#13;
value.</p>&#13;
&#13;
<p>One of the things that Bandalorium wants to track is the&#13;
precision of its production process. It needs to track&#13;
the measurements of the parts it produces and whether&#13;
they change over time.</p>&#13;
&#13;
<p>The challenge, then, is:</p>&#13;
&#13;
<p>Given a list of measurements for attributes of parts produced&#13;
during a certain interval (say, three months), create a CSV (comma-separated value) report similar to the one&#13;
shown in <a data-type="xref" href="#output_csv_id">Figure 2-2</a>.  As shown,&#13;
the report should be sorted by the time that the measurement&#13;
was taken.</p>&#13;
&#13;
<figure><div class="figure" id="output_csv_id">&#13;
<img alt="pawk 0202" src="assets/pawk_0202.png"/>&#13;
<h6><span class="label">Figure 2-2. </span>Example of CSV ouput.</h6>&#13;
</div></figure>&#13;
&#13;
<p>If we might make a suggestion—now would be a great time to put&#13;
this book aside for a moment and consider how you would&#13;
approach this problem. Maybe just sketch enough high-level&#13;
code to feel confident that you can solve it.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Implementation" data-type="sect2"><div class="sect2" id="idm46669755806592">&#13;
<h2>The Implementation</h2>&#13;
&#13;
<p>In Kotlin, we might represent an attribute like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Attr</code><code class="p">(</code><code class="k">val</code> <code class="py">name</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code> <code class="k">val</code> <code class="py">tolerance</code><code class="p">:</code> <code class="n">Tolerance</code><code class="p">)</code>&#13;
&#13;
<code class="k">enum</code> <code class="k">class</code> <code class="nc">Tolerance</code> <code class="p">{</code>&#13;
    <code class="n">CRITICAL</code><code class="p">,</code>&#13;
    <code class="n">IMPORTANT</code><code class="p">,</code>&#13;
    <code class="n">REGULAR</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The name is a unique identifier for the attribute. An&#13;
attribute’s tolerance indicates the significance of the&#13;
attribute to the quality of the final product: critical,&#13;
important, or just regular.</p>&#13;
&#13;
<p>Each attribute probably has lots of other associated information.&#13;
There is, surely, a record of the units of measurement&#13;
(centimeters, joules, etc.), a description of its acceptable&#13;
values, and perhaps the procedure used to measure it. We&#13;
will ignore those features for this example.</p>&#13;
&#13;
<p class="pagebreak-before">A measurement of an attribute for a specific engine part includes the following:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The serial number of the part being measured</p>&#13;
</li>&#13;
<li>&#13;
<p>A timestamp giving the time at which the measurement was made</p>&#13;
</li>&#13;
<li>&#13;
<p>The measured value</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>A measurement, then, might be modeled in Kotlin like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">Point</code><code class="p">(</code>&#13;
    <code class="k">val</code> <code class="py">serial</code><code class="p">:</code> <code class="n">String</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">date</code><code class="p">:</code> <code class="n">LocalDateTime</code><code class="p">,</code>&#13;
    <code class="k">val</code> <code class="py">value</code><code class="p">:</code> <code class="n">Double</code><code class="p">)</code></pre>&#13;
&#13;
<p>Finally, we need a way to connect a measurement to the&#13;
attribute it measures.  We model the relationship like this:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">data</code> <code class="k">class</code> <code class="nc">TimeSeries</code><code class="p">(</code><code class="k">val</code> <code class="py">points</code><code class="p">:</code> <code class="n">List</code><code class="p">&lt;</code><code class="n">Point</code><code class="p">&gt;,</code> <code class="k">val</code> <code class="py">attr</code><code class="p">:</code> <code class="n">Attr</code><code class="p">)</code></pre>&#13;
&#13;
<p>The <code>TimeSeries</code> relates a list of measurements to the <code>Attr</code>s&#13;
that they measure.</p>&#13;
&#13;
<p>First, we build the header of the CSV file: the column titles that comprise the first line (see <a data-type="xref" href="#making_header_id">Example 2-2</a>). The first two columns are named <code>date</code> and <code>serial</code>. The other column names are&#13;
the distinct names of the attributes in the dataset.</p>&#13;
<div data-type="example" id="making_header_id">&#13;
<h5><span class="label">Example 2-2. </span>Making the header</h5>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code><code> </code><code class="nf">createCsv</code><code class="p">(</code><code class="n">timeSeries</code><code class="p">:</code><code> </code><code class="n">List</code><code class="p">&lt;</code><code class="n">TimeSeries</code><code class="p">&gt;</code><code class="p">)</code><code class="p">:</code><code> </code><code class="n">String</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">distinctAttrs</code><code> </code><code class="p">=</code><code> </code><code class="n">timeSeries</code><code>&#13;
</code><code>        </code><code class="p">.</code><code class="n">distinctBy</code><code> </code><code class="p">{</code><code> </code><code class="n">it</code><code class="p">.</code><code class="n">attr</code><code> </code><code class="p">}</code><code> </code><a class="co" href="#callout_the_kotlin_collections_framework_CO1-1" id="co_the_kotlin_collections_framework_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>        </code><code class="p">.</code><code class="n">map</code><code> </code><code class="p">{</code><code> </code><code class="n">it</code><code class="p">.</code><code class="n">attr</code><code> </code><code class="p">}</code><code>        </code><a class="co" href="#callout_the_kotlin_collections_framework_CO1-2" id="co_the_kotlin_collections_framework_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>        </code><code class="p">.</code><code class="n">sortedBy</code><code> </code><code class="p">{</code><code> </code><code class="n">it</code><code class="p">.</code><code class="n">name</code><code> </code><code class="p">}</code><code>   </code><a class="co" href="#callout_the_kotlin_collections_framework_CO1-3" id="co_the_kotlin_collections_framework_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="k">val</code><code> </code><code class="py">csvHeader</code><code> </code><code class="p">=</code><code> </code><code class="s">"date;serial;"</code><code> </code><code class="p">+</code><code>&#13;
</code><code>        </code><code class="n">distinctAttrs</code><code class="p">.</code><code class="n">joinToString</code><code class="p">(</code><code class="s">";"</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><code class="n">it</code><code class="p">.</code><code class="n">name</code><code> </code><code class="p">}</code><code> </code><code class="p">+</code><code>&#13;
</code><code>        </code><code class="s">"\n"</code><code>&#13;
</code><code>&#13;
</code><code>    </code><code class="cm">/* Code removed for brevity */</code><code>&#13;
</code><code class="p">}</code></pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO1-1" id="callout_the_kotlin_collections_framework_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Use the <code>distinctBy</code> function to get a list of&#13;
<code>TimeSeries</code> instances that have distinct values for the <code>attr</code> attribute.</p></dd>&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO1-2" id="callout_the_kotlin_collections_framework_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We have a list of distinct <code>TimeSeries</code> from the previous step and we only want the <code>attr</code>, so we use the <code>map</code> function.</p></dd>&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO1-3" id="callout_the_kotlin_collections_framework_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Finally, we sort alphabetically using <code>sortedBy</code>. It wasn’t&#13;
required but why not?</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now that we have the list of distinct characteristics, formatting the&#13;
header is straightforward using the<a data-primary="joinToString function" data-type="indexterm" id="idm46669755532384"/> <code>joinToString</code> function. This&#13;
function transforms a list into a string by specifying a&#13;
string separator to insert between each element of the list. You can&#13;
even specify a prefix and/or a postfix if you need to.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>It is often useful to be able to find the types of the returns&#13;
from collection transformation functions. In&#13;
<a data-type="xref" href="#making_header_id">Example 2-2</a>, for instance, if you activate type hints,&#13;
you’ll only get the inferred type of the whole chain (the type of&#13;
the variable <code>distinctAttrs</code>). There is a nice&#13;
IntelliJ/Android Studio feature that can help!</p>&#13;
<ol>&#13;
<li>&#13;
<p>Click on <code>distinctCharacs</code> in the source code.</p>&#13;
</li>&#13;
<li>&#13;
<p>Hit Ctrl + Shift + P. You’ll see a drop-down window appear.</p>&#13;
&#13;
<figure class="width-100"><div class="figure">&#13;
<img alt="pawk 0203" src="assets/pawk_0203.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
<li>&#13;
<p>Select the step you want and the inferred type will appear before your eyes!</p>&#13;
&#13;
<figure class="width-100"><div class="figure">&#13;
<img alt="pawk 0204" src="assets/pawk_0204.png"/>&#13;
<h6/>&#13;
</div></figure>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div>&#13;
&#13;
<p>After building the header, we build the content of the CSV file. This is&#13;
the most technical and interesting part.</p>&#13;
&#13;
<p>The rest of the CSV file that we are trying to reproduce&#13;
sorts the data by date. For each given date, it gives a&#13;
part’s serial number and then that part’s measurement for&#13;
each attribute of interest. That’s going to take&#13;
some thought because, in the model we’ve created, those&#13;
things are not directly related. A <code>TimeSeries</code> contains&#13;
only data for a single attribute and we will need data for&#13;
multiple attributes.</p>&#13;
&#13;
<p>A common approach in this situation is to merge and flatten&#13;
the input data into a more convenient data structure, as shown in <a data-type="xref" href="#flattenex">Example 2-3</a>.</p>&#13;
<div data-type="example" id="flattenex">&#13;
<h5><span class="label">Example 2-3. </span>Merge and flatten the data</h5>&#13;
&#13;
<pre data-type="programlisting">fun createCsv(timeSeries: List&lt;TimeSeries&gt;): String {&#13;
    /* Code removed for brevity */&#13;
&#13;
    data class PointWithAttr(val point: Point, val attr: Attr)&#13;
&#13;
    // First merge and flatten so we can work with a list of PointWithAttr&#13;
    val pointsWithAttrs = timeSeries.flatMap { ts -&gt;&#13;
        ts.points.map { point -&gt; PointWithAttr(point, ts.attr) }&#13;
&#13;
   /* Code removed for brevity */&#13;
}</pre></div>&#13;
&#13;
<p>In this step, we associate each <code>Point</code> with its corresponding&#13;
<code>Attr</code>, in a single &#13;
<span class="keep-together"><code>PointAndAttr</code></span> object. This is much like&#13;
joining two tables in SQL.</p>&#13;
&#13;
<p><a data-primary="flatMap" data-type="indexterm" id="idm46669755513744"/>The <code>flatMap</code> function transforms a list of <code>TimeSeries</code>&#13;
objects. Internally, the function applied by <code>flatMap</code> uses&#13;
the <code>map</code> function, <code>series.points.map { ... }</code>, to create a&#13;
list of <code>PointAndAttr</code>s for each point in the <code>TimeSeries</code>.&#13;
If we had used <code>map</code> instead of <code>flatMap</code>, we would have produced&#13;
a <code>List&lt;List&lt;PointAndAttr&gt;&gt;</code>. Remember, though, that <code>flatMap</code>&#13;
flattens out the top layer of the container, so the result&#13;
here is a &#13;
<span class="keep-together"><code>List&lt;PointAndAttr&gt;</code>.</span></p>&#13;
&#13;
<p>Now that we have “spread” the attribute information into every <code>Point</code>,&#13;
creating the CSV file is fairly straightforward.</p>&#13;
&#13;
<p>We’ll group the list of <code>pointWithAttrs</code> by date to create a&#13;
<code>Map&lt;LocalDate, List&lt;PointWithAttr&gt;</code>. This map will contain&#13;
a list of <code>pointWithAttrs</code> for each date. Since the example&#13;
seems to have a secondary sort (by the part’s serial number), we’ll&#13;
have to group each of the lists in the previously grouped&#13;
<code>Map</code> by serial number. The rest is just string formatting, as shown in <a data-type="xref" href="#datarows">Example 2-4</a>.</p>&#13;
<div data-type="example" id="datarows">&#13;
<h5><span class="label">Example 2-4. </span>Create data rows</h5>&#13;
&#13;
<pre data-type="programlisting">fun createCsv(timeSeries: List&lt;TimeSeries&gt;): String {&#13;
    /* Code removed for brevity */&#13;
&#13;
    val rows = importantPointsWithAttrs.groupBy { it.point.date }  <a class="co" href="#callout_the_kotlin_collections_framework_CO2-1" id="co_the_kotlin_collections_framework_CO2-1"><img alt="1" src="assets/1.png"/></a>&#13;
    .toSortedMap()                                     <a class="co" href="#callout_the_kotlin_collections_framework_CO2-2" id="co_the_kotlin_collections_framework_CO2-2"><img alt="2" src="assets/2.png"/></a>&#13;
    .map { (date, ptsWithAttrs1) -&gt;&#13;
        ptsWithAttrs1&#13;
            .groupBy { it.point.serial }             <a class="co" href="#callout_the_kotlin_collections_framework_CO2-3" id="co_the_kotlin_collections_framework_CO2-3"><img alt="3" src="assets/3.png"/></a>&#13;
            .map { (serial, ptsWithAttrs2) -&gt;&#13;
                listOf(                                        <a class="co" href="#callout_the_kotlin_collections_framework_CO2-4" id="co_the_kotlin_collections_framework_CO2-4"><img alt="4" src="assets/4.png"/></a>&#13;
                    date.format(DateTimeFormatter.ISO_LOCAL_DATE),&#13;
                    serial&#13;
                ) + distinctAttrs.map { attr -&gt;&#13;
                    val value = ptsWithAttrs2.firstOrNull { it.attr == attr }&#13;
                    value?.point?.value?.toString() ?: ""&#13;
                }&#13;
            }.joinToString(separator = "") {        <a class="co" href="#callout_the_kotlin_collections_framework_CO2-5" id="co_the_kotlin_collections_framework_CO2-5"><img alt="5" src="assets/5.png"/></a>&#13;
                it.joinToString(separator = ";", postfix = "\n")&#13;
            }&#13;
    }.joinToString(separator = "")&#13;
&#13;
&#13;
    return csvHeader + rows                               <a class="co" href="#callout_the_kotlin_collections_framework_CO2-6" id="co_the_kotlin_collections_framework_CO2-6"><img alt="6" src="assets/6.png"/></a>&#13;
}</pre></div>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO2-1" id="callout_the_kotlin_collections_framework_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Group by date, using the <code>groupBy</code> function.</p></dd>&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO2-2" id="callout_the_kotlin_collections_framework_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Sort the map (by date). It’s not mandatory, but a sorted CSV is easier to read.</p></dd>&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO2-3" id="callout_the_kotlin_collections_framework_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Group by serial number.</p></dd>&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO2-4" id="callout_the_kotlin_collections_framework_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Build the list of values for each line.</p></dd>&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO2-5" id="callout_the_kotlin_collections_framework_CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Format each line and assemble all those lines using the <code>joinToString</code> function.</p></dd>&#13;
<dt><a class="co" href="#co_the_kotlin_collections_framework_CO2-6" id="callout_the_kotlin_collections_framework_CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>Finally, return the header and the rows as a single <code>String</code>.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Now, let’s suppose that you get an additional request to&#13;
report only on attributes that are <code>CRITICAL</code> or&#13;
<code>IMPORTANT</code>. You just have to use the <code>filter</code> function, as shown in <a data-type="xref" href="#filter">Example 2-5</a>.</p>&#13;
<div data-type="example" id="filter">&#13;
<h5><span class="label">Example 2-5. </span>Filter critical and important samples</h5>&#13;
&#13;
<pre data-type="programlisting">fun createCsv(timeSeries: List&lt;TimeSeries&gt;): String {&#13;
    /* Code removed for brevity */&#13;
&#13;
    val pointsWithAttrs2 = timeSeries.filter {&#13;
        it.attr.tolerance == Tolerance.CRITICAL&#13;
                || it.attr.tolerance == Tolerance.IMPORTANT&#13;
    }.map { series -&gt;&#13;
        series.points.map { point -&gt;&#13;
            PointWithAttr(point, series.attr)&#13;
        }&#13;
    }.flatten()&#13;
&#13;
    /* Code removed for brevity */&#13;
&#13;
    return csvHeader + rows&#13;
}</pre></div>&#13;
&#13;
<p>That’s it!</p>&#13;
&#13;
<p>To test that code, we can use a predefined input and check&#13;
that the output matches your expectations. We won’t show a full-blown&#13;
set of unit tests here—just an example of CSV output, as shown in <a data-type="xref" href="#demonstrates">Example 2-6</a>.</p>&#13;
<div data-type="example" id="demonstrates">&#13;
<h5><span class="label">Example 2-6. </span>Demonstrate the application</h5>&#13;
&#13;
<pre data-type="programlisting">fun main() {&#13;
    val dates = listOf&lt;LocalDateTime&gt;(&#13;
        LocalDateTime.parse("2020-07-27T15:15:00"),&#13;
        LocalDateTime.parse("2020-07-27T15:25:00"),&#13;
        LocalDateTime.parse("2020-07-27T15:35:00"),&#13;
        LocalDateTime.parse("2020-07-27T15:45:00")&#13;
    )&#13;
    val seriesExample = listOf(&#13;
        TimeSeries(&#13;
            points = listOf(&#13;
                Point("HC11", dates[3], 15.1),&#13;
                Point("HC12", dates[2], 15.05),&#13;
                Point("HC13", dates[1], 15.11),&#13;
                Point("HC14", dates[0], 15.08)&#13;
            ),&#13;
            attr = Attr("AngleOfAttack", Tolerance.CRITICAL)&#13;
        ),&#13;
        TimeSeries(&#13;
            points = listOf(&#13;
                Point("HC11", dates[3], 0.68),&#13;
                Point("HC12", dates[2], 0.7),&#13;
                Point("HC13", dates[1], 0.69),&#13;
                Point("HC14", dates[0], 0.71)&#13;
            ),&#13;
            attr = Attr("ChordLength", Tolerance.IMPORTANT)&#13;
        ),&#13;
        TimeSeries(&#13;
            points = listOf(&#13;
                Point("HC11", dates[3], 0x2196F3.toDouble()),&#13;
                Point("HC14", dates[0], 0x795548.toDouble())&#13;
            ),&#13;
            attr = Attr("PaintColor", Tolerance.REGULAR)&#13;
        )&#13;
    )&#13;
    val csv = createCsv(seriesExample)&#13;
    println(csv)&#13;
}</pre></div>&#13;
&#13;
<p>If you use the <code>csv</code> string as the content of a file with the “.csv”&#13;
extension, you can open it using your favorite spreadsheet&#13;
tool. <a data-type="xref" href="#finaloutput">Figure 2-3</a> shows what we got using FreeOffice.</p>&#13;
&#13;
<figure><div class="figure" id="finaloutput">&#13;
<img alt="pawk 0202" src="assets/pawk_0202.png"/>&#13;
<h6><span class="label">Figure 2-3. </span>Final output.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Using functional programming to transform data, as in&#13;
this example, is particularly robust. Why? By combining&#13;
Kotlin’s null safety and functions from the Standard&#13;
Library, you can produce code which has either few or no&#13;
side effects. Throw in any list of <code>PointWithAttr</code> you can&#13;
imagine. If even one <code>Point</code> instance has a <code>null</code> value, the&#13;
code won’t even compile. Anytime the result of transformation&#13;
returns a result which can be null, the language forces you&#13;
to account for that scenario.  Here we did this in&#13;
step 4, with the <code>firstOrNull</code> function.</p>&#13;
&#13;
<p>It’s always a thrill when your code compiles and does&#13;
exactly what you expect it to do on the first try. With&#13;
Kotlin’s null safety and functional programming, that&#13;
happens &#13;
<span class="keep-together">a lot.</span><a data-startref="ix_ch02-asciidoc10" data-type="indexterm" id="idm46669755453584"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm46669755805680">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>As a functional language, Kotlin employs great ideas&#13;
like mapping, zipping, and other functional transformations.&#13;
 It even allows you to create your own data transformations&#13;
with the power of higher-order functions and lambdas:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Kotlin collections include the entire Java collections API. In&#13;
addition, the library provides all the common functional transformations like&#13;
mapping, filtering, grouping, and more.</p>&#13;
</li>&#13;
<li>&#13;
<p>Kotlin supports inline functions for more performant&#13;
data transformations.</p>&#13;
</li>&#13;
<li>&#13;
<p>The Kotlin collections library supports sequences, a way of working with&#13;
collections that are defined by intention instead of extension.&#13;
Sequences are appropriate when getting the next element is&#13;
very expensive, or even on collections of unbounded size.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>If you’ve ever used languages like Ruby, Scala, or Python,&#13;
perhaps some of this feels familiar to you. It should!&#13;
Kotlin’s design is based on many of the same principles&#13;
that drove the development of those languages.</p>&#13;
&#13;
<p>Writing your Android code in a more functional way is as&#13;
easy as using data transformation operations offered with&#13;
the Kotlin Standard Library. Now that you are familiar&#13;
with Kotlin syntax and the spirit of functional programming&#13;
in Kotlin, the next chapter focuses on the Android OS&#13;
and other programming fundamentals. Android development&#13;
turned toward Kotlin as an official language back in 2017,&#13;
so Kotlin has heavily influenced Android’s evolution in recent years. It will continue to do so in the coming&#13;
years.<a data-startref="ix_ch02-asciidoc0" data-type="indexterm" id="idm46669755446256"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46669757650256"><sup><a href="ch02.html#idm46669757650256-marker">1</a></sup> Roman Elizarov; email interview on Kotlin Collections Immutable Library. Oct. 8, 2020.</p></div></div></section></body></html>