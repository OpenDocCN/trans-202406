- en: Chapter 4\. Dates and Fixed Income Securities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dates and date calculations might not seem like the most compelling topic to
    discuss, but they are vitally important in quantitative finance, particularly
    in fixed income trading and analytics.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with distributional random number generation in the past, financial C++
    programmers were left with similar options: either write their own date classes
    and functions or use a commercial or open source external library. This has changed
    with C++20\. It includes a date class that is determined by the integer year,
    month, and day values. This class relies both on the already existing (since C++11)
    `std::chrono` foundation of durations, timepoints, and the system clock – ie,
    chronological computations – as well as calendrical computations, which are based
    on the number of days relative to the epoch and take into account the non-uniform
    number of days in each month.'
  prefs: []
  type: TYPE_NORMAL
- en: While the goal of this chapter is to demonstrate how to use the new date features
    in financial applications, the author of `std::chrono`, Howard Hinnant, provides
    more details on his GitHub site containing the original development code for `std::chrono`
    dates{1}. (This will be referred to as “the GitHub date code site” going forward).
  prefs: []
  type: TYPE_NORMAL
- en: Adding years and months can be effected by using calendrical options in `std::chrono`,
    but adding days requires conversion to a chronological timepoint. These are important
    operations to be discussed in due course, but first let us cover how dates are
    represented and instantiated in C++20\. From there, we will look at common date
    calculations that are required in finance, a class that encapsulates the functions
    for us, day count conventions and yield curves, and finally an application in
    valuing a coupon-paying bond.
  prefs: []
  type: TYPE_NORMAL
- en: Representation of a Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'C++11 introduced the `std::chrono` library into the Standard Library, which
    provided the following abstractions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Duration of time: A method of measurement over a given time interval, such
    as in units of minutes, days, milliseconds, etc'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Timepoint: A duration of time relative to an epoch, such as the UNIX epoch
    1970-1-1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Clock: The object that specifies the epoch and normalizes duration measurements
    {0}'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dates in `std::chrono` are based on these chronological foundations, but as
    part of the new C++20 features, conversions to calendrical forms are also now
    available. These can be used for calculations involving years and months.
  prefs: []
  type: TYPE_NORMAL
- en: A standard date in `std::chrono` is represented by an object of the class `std::chrono::year_month_day`.
    There are a variety of constructors for this class, among which several are discussed
    here.
  prefs: []
  type: TYPE_NORMAL
- en: First, a constructor taking in the year, month, and day is provided. But instead
    of integer values for each, these constructor arguments must be defined as separate
    `std::chrono::year`, `std::chrono::month`, and `std::chrono::day` objects. For
    example, to create an object holding the date 14 November 2002, we would create
    it as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, individual constant `month` objects are defined in `std::chrono`
    by name, so an equivalent approach to constructing the same month above is to
    replace the constructed month object in the previous example with the pre-defined
    `November` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For assignment, the `/` operator has also been overloaded to define a `year_month_day`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Different orders can be used, along with integer types, as long as the first
    argument is obvious. For yyyy/mm/dd format, putting
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'would yield the same result, with the compiler interpreting the 11 and 14 as
    `unsigned` types. mm/dd/yyyy format can also be used: `auto mdy = std::chrono::November
    / 14 / 2002;`'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the 14 is recognized as `unsigned`, and the year as an `int`.
    In `std::chrono`, `month` and `day` types can be cast to `unsigned`, while a `year`
    can only be cast to an `int`. The examples above are non-exhaustive, and a more
    comprehensive list can be found on the GitHub date code site{1}.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the output stream operator is overloaded for `year_month_day`, so
    any of the above can be output to the console with `cout`. For example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: will display the date on the screen as `2002-11-14`
  prefs: []
  type: TYPE_NORMAL
- en: 1.1 Serial Representation and Date Differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `year_month_day` date can also be measured in terms of the number of days
    since an epoch, with the `system_clock` default being the UNIX epoch January 1,
    1970\. Similar to Excel – whose epoch is January 1, 1900 – this representation
    can be convenient for certain types of date arithmetic in finance, particularly
    in determining the number of days between two dates. Unlike Excel, however, the
    UNIX epoch is represented by 0 rather than 1, in the sense that serial dates are
    measured in *days since the epoch*. Consider the following example, with dates
    1970-1-1 and 1970-1-2.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the respective serial dates can be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: These return `int` values 0 and 1, respectively. Also unlike Excel, `std::chrono`
    dates before the epoch are also valid but carry a negative integer value. In the
    statement that follows, the returned value is -1.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: For typical financial trading, it is usually not necessary to go back before
    1970, but in some fields, such as actuarial valuations of pension liabilities,
    many retirees were born before this date. Historical simulations of markets also
    might use data going back many decades.
  prefs: []
  type: TYPE_NORMAL
- en: Recalling that the `year_month_day` class is built upon the three `std::chrono`
    abstractions listed at the outset, technically what is happening here is the `sys_days`
    operator returns the `ymd` date as a `std::chrono::time_point` object, where `sys_days`
    is an alias for `time_point`. Then, its `time_since_epoch` member function returns
    a `std::chrono::duration` type. The corresponding integer value is then accessed
    with the `count` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'An important calculation to have in finance is the number of days between two
    dates. Using `ymd` again as 2002-11-14, and initializing `ymd_later` to six months
    later – 2003-5-14 – take the difference between the two `sys_days` objects obtained
    with `sys_days` and apply the `count` function to the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The result of 181 is again returned as an `int`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, when working with dates, there are several checks that are often necessary
    to perform, namely whether a date is valid, whether it is in a leap year, finding
    the number of days in a month, and whether a date is a weekend. Some of the machinery
    for this is immediate with functions conveniently contained in `std::chrono`,
    but in other cases, there will be a little more work involved.
  prefs: []
  type: TYPE_NORMAL
- en: 1.2 Accessor Functions for Year, Month, and Day
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessor functions on `year_month_day` are provided for obtaining the year,
    month and day, but they are returned as their respective `year`, `month`, and
    `day` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Suppose we have two `year_month_day` objects `date1` and `date2` Then, conveniently,
    applying the `count` function on the difference (a `duration`), the results are
    `int` types.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Each of the individually accessed year, month, and day components can also be
    cast to integers (in the mathematical sense), but an important point to be aware
    of is a `year` can be cast to an `int`, but for a `month` or `day`, these need
    to be cast to `unsigned`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Going forward, for convenience we will use the namespace alias `namespace date
    = std::chrono;`
  prefs: []
  type: TYPE_NORMAL
- en: 1.3 Validity of a Date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to set `year_month_day` objects to invalid dates. For example,
    as will be seen shortly, adding a month to a date of January 31 will result in
    February 31\. In addition, the constructor will also allow month and day values
    out of range. Instead of throwing an exception, it is left up to the programmer
    to check if a date is valid. Fortunately, this is easily accomplished with the
    boolean `ok` member function. In the following example, the `ymd` date (same as
    above) is valid, while the two that follow are obviously not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `ok` member function will come in handy in subsequent examples, particularly
    in cases where a date operation results in the correct year and month, but an
    incorrect day setting in end-of-the month cases. This will be addressed shortly.
    The upshot is it is up to the consumer of the `year_month_day` class to check
    for validity, as it does not throw an exception or adjust automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 1.4 Leap Years and Last Day of the Month
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can easily check whether a date is a leap year or not. A boolean member
    function, not surprisingly called `is_leap`, takes care of this for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: There is no member function available on `year_month_day` that will return the
    last day of the month. A workaround exists using a separate class in std::chrono
    that represents an end-of-month date, `year_month_day_last`, from which the last
    day of its month can also be accessed as before, and then cast to unsigned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This can also be used as a device to check whether a date falls on the end
    of a month:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The last day of the month for an arbitrary date can also be determined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It should also be noted a `year_month_day_last` type is implicitly convertible
    to a `year_month_day` via reassignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: More background can be found in {2}.
  prefs: []
  type: TYPE_NORMAL
- en: Although this works, it carries the overhead of creating a `year_month_day_last`
    each time it is called, and additional object copy if reassigned, as shown in
    the last line of the code example just above. While your mileage may vary, it
    is possible this could have a negative performance impact in financial systems
    managing heavy trading volume and large portfolios containing fixed income securities.
  prefs: []
  type: TYPE_NORMAL
- en: A set of “`chrono`-Compatible Low-Level Date Algorithms” is provided elsewhere
    on the the GitHub date code site{3}. These alternatives apply methods that are
    independent of `year_month_day` class methods, and their description in the documentation
    states these low level algorithms are “key algorithms that enable one to write
    their own date class”. This is the direction in which we are eventually headed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To determine the last day of the month, a more efficient user-defined function
    can be derived from code provided in this set of algorithms, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is more of a brute force approach in hard-coding the days in each month
    of a non-leap year, but it does obviate additional object creation and copying.
  prefs: []
  type: TYPE_NORMAL
- en: 'One other point is the use here of `constexpr`, another language feature added
    to C++11\. Because the length of the `array` and its contents are known a priori,
    `constexpr` instructs the compiler to initialize `end_dates` at compile time,
    thus eliminating re-initialization every time the `last_day_of_the_month` function
    is called. Two related points follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Using `constexpr` in this specific case may or may not have a significant impact
    on performance, but it is possible in cases where the function is called many
    times in computationally intensive code, such as in portfolio risk simulations
    and calculations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most financial data, such as market and trade data, will be inevitably dynamic
    and thus unknown at compile time, so `constexpr` may be of limited use in financial
    applications. The example above, however, demonstrates an example of how and when
    it can potentially be used effectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 1.5 Weekdays and Weekends
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to end of the month dates, there is no member function to check whether
    a date falls on a weekend. There is again a workaround from which we can derive
    the result we need.
  prefs: []
  type: TYPE_NORMAL
- en: '`std::chrono` contains a `weekday` class that represents the day of the week
    – Monday through Sunday – not just weekdays per se (the terminology here might
    be slightly confusing). It can be constructed by again applying the `sys_days`
    operator in the constructor argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The day of the week can be identified by an `unsigned` integer value returned
    from the `iso_encoding` member function, where values 1 through 7 represent Monday
    through Sunday, respectively. The stream operator is overloaded so that the abbreviated
    day of the week is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The output is then `2022-10-26, Wed, 3` This allows us to define our own function,
    in this case a lambda, to determine whether a date falls on a weekend or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, also construct a `year_month_day` date that falls on a Saturday:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Then, we can use the lambda to test whether each day is a business day or not.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Supplemental information on weekends in `std::chrono` can be found in {4}.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6 Adding Years, Months, and Days
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more set of important date operations of finance is adding years, months,
    and days to existing dates. These are particularly useful for generating schedules
    of fixed payments. Adding years or months is very similar – relying on the `+=`
    operator – but adding days involves a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.1 Adding Years
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding years is very straightforward. For example, add two years to 2002-11-14,
    and then add another 18 years to the result. Note that the number of years being
    added needs to be expressed as a `std::chrono::years` object, an alias for a `duration`
    representing one year.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We run into a problem, however, if the date is the last day of February in a
    leap year. Adding two years to 2016-02-29 results in an invalid year.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Dates in `std::chrono` will again neither throw an exception or adjust the day,
    so it is up to the developer to handle the case where years are added to a February
    29 date in a leap year.
  prefs: []
  type: TYPE_NORMAL
- en: 1.6.2 Adding Months and End-of-the-Month Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding months to a `year_month_day` object is similar to adding years, but this
    now requires handling multiple end-of-month edge cases due to different numbers
    of days in different months, plus again the case of a February in a leap year.
  prefs: []
  type: TYPE_NORMAL
- en: When no end-of-month date is involved, the operation is straightforward, similar
    to adding years, using the addition assignment operator. Similar to adding years,
    the number of months needs to be represented as a `duration` object, in this case
    an alias for a period of one month.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Subtraction assignment is also available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'With end-of-the-month cases as well, the `+=` operation can again result in
    invalid dates. To see this, construct the following end-of-month dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Naively attempting month addition results in invalid dates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Although the results are not valid, the year and month of each is correct. That
    is, for example, adding one month to 2015-01-31 should map to 2015-02-28.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going the other way, if we were to start on 2015-02-28 and add one month, the
    result will be correct: 2015-03-28.'
  prefs: []
  type: TYPE_NORMAL
- en: Recalling the `last_day_of_the_month` function defined previously, a workaround
    is fairly straightforward. Addition assignment is naively applied, but if the
    result is invalid, it must be due to the day value exceeding the actual number
    of days in a month. In this case, because the resulting year and month will be
    valid, it just becomes a case of resetting the day with the number of days in
    the month.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 1.6.3 Adding Days
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unlike for years and months, there is no `+=` operator defined for adding days.
    For this reason, we will need to obtain the `sys_days` equivalent before adding
    the number of days.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that at this point, `ymd` has not been modified, and the result, `add_days`,
    is also a `sys_days` type. To set a `year_month_day` object to the equivalent,
    the assignment operator provides implicit conversion. Similar to previous applications
    of `sys_days`, we can just update the original `ymd` date to three days later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: More information on adding days can be found in {5}.
  prefs: []
  type: TYPE_NORMAL
- en: A Date Class Wrapper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you can probably see by now, managing all the intricacies of `std::chrono`
    dates can eventually become complicated. For this reason, we will now outline
    the typical requirements for financial date calculations and declare them in a
    class based on a `year_month_day` member. This way, the adjustments and `year_month_day`
    function calls are implemented once behind interfacing member functions and operators
    that are arguably more intuitive for the consumer. These can be divided into two
    broad categories, namely checking possible states of a date, and performing arithmetic
    operations on dates. A summary of what we have covered so far is provided in the
    list of requirements below. Most of these results will be integrated into the
    class implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**State**'
  prefs: []
  type: TYPE_NORMAL
- en: Days in month
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leap year
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Arithmetic Operations**'
  prefs: []
  type: TYPE_NORMAL
- en: Number of days between two dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Years
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Days
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Months
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional functionality that we will want to have is listed next. These additional
    requirements will be also be part of the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Accessors**'
  prefs: []
  type: TYPE_NORMAL
- en: Year, Month, Day
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serial date integer representation (days since epoch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`year_month_day` data member'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comparison operators**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: To begin, the class declaration will give us an implementation roadmap to follow.
  prefs: []
  type: TYPE_NORMAL
- en: Class Declaration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will incorporate the requirements listed above into a class called `ChronoDate`.
    It will wrap a `std::chrono::year_month_day` object along with some of its associated
    member functions that are useful in financial calculations. The only other data
    member will be the serial date representation of the date object.
  prefs: []
  type: TYPE_NORMAL
- en: Before working through the member functions, let us start with the constructors.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For convenience, a constructor is provided that takes in integer values for
    year, month, and day, rather than requiring the user to create individual `year`,
    `month`, and `day` objects. ChronoDate{ int year, unsigned month, unsigned day
    }; Note that the argument for the year is an `int`, while those for the month
    and day are `unsigned`. This is due to the design of the `year_month_day` class,
    as previously discussed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we will see for convenience later, a second constructor will take in a `year_month_day`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: And finally, a default constructor will construct a `ChronoDate` set to the
    UNIX epoch.
  prefs: []
  type: TYPE_NORMAL
- en: Public Member Functions and Operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These should mostly be self-explanatory from the member function declarations
    below. Furthermore, it will mainly be a case of integrating the previously developed
    functionality into the respective member functions. As for the comparison operators
    `==` and [PRE35], as well as the friend stream operator, these are already defined
    on the `year_month_day` class, so it is simply a matter of wrapping them into
    the same operators on `ChronoDate`.
  prefs: []
  type: TYPE_NORMAL
- en: There is one remaining public function in the declaration not yet covered, `weekend_roll`,
    which will be used to roll a date to the nearest business day in the event a date
    falls on a Saturday or Sunday. Its implementation will be covered shortly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Private Members and Helper Function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Two private member variables will store the underlying `year_month_day` object
    and serial representation of the date. One private function will wrap the function
    calls required to obtain the number of days since the UNIX epoch, so that the
    serial date can be set at construction, as well as updated anytime the state of
    an object of the class is modified.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Class Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have almost all of the necessary functionality, what remains is mostly
    a case of wrapping it into the member functions, plus implementing the `weekend_roll`
    function and a couple of private helper functions. In addition, two constructors
    are presented, as well as the private `reset_serial_date_` method that will calculate
    and set the serial representation of the date, either at construction, or whenever
    the state of an active `ChronoDate` is modified.
  prefs: []
  type: TYPE_NORMAL
- en: Constructors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of the first declared constructor allows one to create an
    instance of `ChronoDate` with integer values (`int` and `unsigned`) rather than
    require individual instances of `year`, `month`, and `day` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Recall also that because it is possible to construct invalid `year_month_day`
    objects, such as February 30, a validation check is also included in the constructor,
    utilizing the `ok` member function on `year_month_day`. One more setting that
    needs to occur when a date is constructed is the serial date. This is delegated
    to the private method `reset_serial_date_`. As shown at the outset of the chapter,
    this is an application of `sys_days` operator to provide the number of days since
    the UNIX epoch.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This function will also be called from each modifying member function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the default constructor just sets the date to the UNIX epoch, and
    initializes the serial date to 0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Member Functions and Operators
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The following describes implementation of the functions previously introduced
    in the declaration section.
  prefs: []
  type: TYPE_NORMAL
- en: Accessors
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Implementation of accessors for the serial date and `year_month_day` members
    is trivial, but a little more work is involved in returning integer values for
    the year, month, and day. a `std::chrono::year` object can be cast to an `int`,
    while `month` and `day` are castable to `unsigned` types. With this in mind, their
    accessors are straightforward to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: State Methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Checking whether a date is in a leap year simply involves wrapping the respective
    `year_month_day` member function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Obtaining the number of days in the month is more involved, but it is just a
    rehash of the function adapted from the `std::chrono` low-level algorithms in
    Section [1.4].
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic Operations
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: These are the core member functions that will be used for typical fixed income
    applications, such as in calculating year fractions and generating payment schedules.
    To start, let us revisit calculation of the number of days between two dates.
    As we already store the serial date on the class and update it only at construction
    or when a date is modified, we can remove the `sys_days` conversions and function
    calls, and implement the subtraction operator as the difference between the integer
    equivalents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Adding years and months are also pretty straightforward, as we now have ways
    to handle pesky end-of-month issues when they arise. The only issue when adding
    years is if the resulting date lands on the 29th of February in a non-leap year,
    so this case is easily addressed by resetting the day value to 28\. Note that
    because the result is based on the underlying `year_month_day` `+=` operator,
    the state of the object is modified, and thus it becomes necessary to update the
    serial date as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: When adding months to a date, the situation becomes more problematic with varying
    days in each month plus a leap year condition in February, but with the `days_in_month`
    member function now available, it becomes a reasonably easy exercise. The addition
    of months is again naively attempted, with the number of days adjusted if the
    resulting month is invalid. The only way this incorrect state can occur is if
    the naïve result has more days than in its respective month.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: As seen earlier, there is no addition assignment operator for adding days, so
    in `std::chrono` this will require conversion to `sys_days`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Note that the sum of the `sys_days` and the `days` to be added are implicitly
    converted back to a `year_month_day` object when assigned to the `date_` member.
    Further details behind this are also available in {5}.
  prefs: []
  type: TYPE_NORMAL
- en: Business Day Roll Rule
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: One important function we have not discussed yet is that which will roll a weekend
    date to the next business date.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, there are various commonly used roll methods. For the purposes
    of this discussion, we will choose one that is used quite often in practice, namely
    the Modified Following rule. Before proceeding, let us revisit determining the
    day of the week using the `weekday` class contained in `std::chrono`.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, the term “weekday” may be a little confusing. It does
    not mean “weekday” as in Monday through Friday, but rather “day of the week”.
    The `iso_encoding` member function will return an integer code for each day of
    the week, beginning with 1 for Monday and 7 for Sunday; therefore, a value of
    6 or 7 will indicate the date falls on a weekend.
  prefs: []
  type: TYPE_NORMAL
- en: The `weekend_roll` function will just reuse this functionality to first determine
    if the date falls on a weekend. If it does, it will first naively roll forward
    to the next Monday. However, if this new date advances to the next month, it will
    roll back to the previous business date, namely the Friday of the original month.
    This is why the original month is stored first.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: A rolled date will be modified, so it is necessary to update the serial date
    here as well.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison and Streaming Operators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The comparison operators `==` and [PRE49] are immediate as these are defined
    for `year_month_day`. We just need to be sure to use `std::strong_ordering` as
    the return type for [PRE50], as it is ultimately two integer values – the days
    since the epoch – that are being compared.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can also piggyback off of the stream operator for `year_month_day` and define
    it as a `friend` operator on `ChronoDate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Because this operator is a `friend` of the `ChronoDate` class, a separate `export`
    of the implementation is needed even when included in the same module.
  prefs: []
  type: TYPE_NORMAL
- en: With the `ChronoDate` class now ready to go, we can move on to day count conventions
    and other components that are typically required for programming related to fixed
    income trading.
  prefs: []
  type: TYPE_NORMAL
- en: Day Count Bases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Day count bases are used to convert the interval between two dates into time
    measured in units of years, or *year fractions*, as commonly referred to in fixed
    income trading. Day count bases are used whenever an interest calculation is made.
    Interest rates are defined by three attributes: an annual percentage value, e.g.
    3%, a type, e.g. simple or compound, and a day count basis. Consider a term deposit
    where 1000 dollars is invested at 3% compound interest, the investment being made
    on 25 October 2022 and maturing on 31 December 2023\. The formula for calculating
    F, the value of the investment at maturity, is'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper F equals 1000 left-parenthesis 1 plus 0.03 right-parenthesis
    Superscript t" display="block"><mrow><mi>F</mi> <mo>=</mo> <mn>1000</mn> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mn>0</mn><mo>.</mo><mn>03</mn><mo>)</mo></mrow>
    <mi>t</mi></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The value of *t* depends on the day count basis. Money market calculations
    in the US and the EU are most likely to use the Actual/360 day count basis:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper A c t Baseline 360 left-parenthesis d 1 comma d 2 right-parenthesis
    equals StartFraction d 2 minus d 1 Over 360 EndFraction" display="block"><mrow><mi>A</mi>
    <mi>c</mi> <mi>t</mi> <mn>360</mn> <mrow><mo>(</mo> <msub><mi>d</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>d</mi> <mn>2</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><msub><mi>d</mi>
    <mn>2</mn></msub> <mo>-</mo><msub><mi>d</mi> <mn>1</mn></msub></mrow> <mn>360</mn></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: In UK, Canadian, and Australian money markets, the Actual/365 day count basis — where
    the 360 swapped for 365 — is more common. Other common day count bases used in
    broader fixed income trading include the 30/360 method, which assumes every month
    has 30 days, and a year has 360 days. The Actual/Actual method uses the actual
    number of days in both the numerator and denominator. In equity portfolio management,
    An Actual/252 basis is often used, where 252 business days per year are assumed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing day count conventions in C++ is an example of where interface inheritance
    can be useful. We can define a pure abstract base class that mandates the implementation
    of the day count-adjusted year fraction, and then leave it to the derived classes
    to implement the specific calculations.
  prefs: []
  type: TYPE_NORMAL
- en: The interface simply declares a pure virtual `operator()` for the calculations
    on the derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'The Actual/365 year fraction calculation is trivial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: An `Act360` class would be the same, except with the denominator replaced by
    360.
  prefs: []
  type: TYPE_NORMAL
- en: The 30/360 case is a bit more complicated, in that the numerator must first
    be calculated according to the formula {put here}.
  prefs: []
  type: TYPE_NORMAL
- en: End-of-month adjustments for the day values will depend on the particular form
    of the 30/360, of which there are several that can depend upon the geographical
    location of a trading desk. In the United States, the ISDA version (International
    Swaps and Derivatives Association){6} is commonly used and is implemented in the
    example below as the private `date_diff_` helper function. The result is then
    divided by 360 in the public operator override.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, for some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The results are shown in the comments. Note that only the 30/360 day count basis
    yields year fractions to half of a year exactly.
  prefs: []
  type: TYPE_NORMAL
- en: As a quick application of day count bases {5.5} (Steiner), consider obtaining
    the price of a short-term government Treasury Bill. In the US, these have maturities
    from four months to a year, and pricing is based on an Actual/365 basis. In the
    UK, maturities may be up to six months and carry an Actual/360 basis. We can write
    a valuation function that will accommodate an arbitrary day count basis via runtime
    polymorphism, so both US and UK cases can priced using the same function.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Yield Curves
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A yield curve is derived from market data — a set of fixed points over discrete
    dates — as of its settle date (the day the prices are observed, eg the current
    trading day). The valuation process of fixed income positions depends on a normalized
    yield curve from discount factors can be obtained, so as to calculate present
    values of each future payment. A review of this process is detailed in the next
    section. These results will then be implemented within in the design of a yield
    curve class that follows afterward.
  prefs: []
  type: TYPE_NORMAL
- en: Deriving a Yield Curve from Market Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Essentially a yield is an interest rate, looked at from a different perspective.
    If money is invested in a deposit account at a known rate of interest, then the
    accumulated value of the investment at some future date can be calculated. However,
    suppose we can invest 1000 dollars on 25 October 2022 and receive 1035.60 dollars
    on 31 December 2023\. In order to compare this investment with other investments
    we calculate its yield. Assuming compounded interest and Actual/365 day count
    basis, then
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="1000 left-parenthesis 1 plus y right-parenthesis Superscript
    432 slash 365 Baseline equals 1035.60" display="block"><mrow><mn>1000</mn> <msup><mrow><mo>(</mo><mn>1</mn><mo>+</mo><mi>y</mi><mo>)</mo></mrow>
    <mrow><mn>432</mn><mo>/</mo><mn>365</mn></mrow></msup> <mo>=</mo> <mn>1035</mn>
    <mo>.</mo> <mn>60</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: from which we find the yield
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y equals exp left-parenthesis ln left-parenthesis 1035.60 slash
    1000 right-parenthesis times 365 slash 432 right-parenthesis minus 1 equals 3
    percent-sign" display="block"><mrow><mi>y</mi> <mo>=</mo> <mo form="prefix">exp</mo>
    <mo>(</mo> <mo form="prefix">ln</mo> <mo>(</mo> <mn>1035</mn> <mo>.</mo> <mn>60</mn>
    <mo>/</mo> <mn>1000</mn> <mo>)</mo> <mo>×</mo> <mn>365</mn> <mo>/</mo> <mn>432</mn>
    <mo>)</mo> <mo>-</mo> <mn>1</mn> <mo>=</mo> <mn>3</mn> <mo>%</mo></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: In general, the yield curve is a function of time, say <math alttext="y left-parenthesis
    t right-parenthesis"><mrow><mi>y</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></math>
    , and is constructed from market data, such as Treasury Bills, swaps and bonds.
    The time values are in units of years (or year fractions).
  prefs: []
  type: TYPE_NORMAL
- en: These products all have known future cash flows, and are known as fixed income
    securities. In addition, each type of fixed income security has its own yield
    type (simple, discount or compounded), and its own day count basis, and these
    may vary within a single product group. To avoid the use of multiple interest
    types and day count bases, yield curves typically define their yields as continuously
    compounded with an Actual/365 day count basis.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate how the inputs to the yield curve are derived, consider a US Treasury
    Bill; the yield type is discount, the day count basis is Act/360, and the market
    quote is the yield on the bill. Suppose the face value is *F*, the maturity date
    is *m*, the market yield is <math alttext="y Subscript m"><msub><mi>y</mi> <mi>m</mi></msub></math>
    for settlement on *s*. Then, the price, *P*, of the bill is
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P equals upper F left-parenthesis 1 minus normal upper
    A normal c normal t Baseline 360 left-parenthesis s comma m right-parenthesis
    y Subscript m Baseline right-parenthesis" display="block"><mrow><mi>P</mi> <mo>=</mo>
    <mi>F</mi> <mfenced separators="" open="(" close=")"><mn>1</mn> <mo>-</mo> <mi>Act</mi>
    <mn>360</mn> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>m</mi> <mo>)</mo></mrow>
    <msub><mi>y</mi> <mi>m</mi></msub></mfenced></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: For the yield curve, the corresponding yield is <math alttext="y left-parenthesis
    t right-parenthesis"><mrow><mi>y</mi> <mo>(</mo> <mi>t</mi> <mo>)</mo></mrow></math>
    , where <math alttext="t equals normal upper A normal c normal t Baseline 365
    left-parenthesis s comma m right-parenthesis"><mrow><mi>t</mi> <mo>=</mo> <mi>Act</mi>
    <mn>365</mn> <mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>m</mi> <mo>)</mo></mrow></math>
    , so that
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P e Superscript t y left-parenthesis t right-parenthesis
    Baseline equals upper F" display="block"><mrow><mi>P</mi> <msup><mi>e</mi> <mrow><mi>t</mi><mi>y</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></msup>
    <mo>=</mo> <mi>F</mi></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The value of $y(t)$ can be found from these two equations. It is
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="y left-parenthesis t right-parenthesis equals StartFraction minus
    ln left-parenthesis 1 minus normal upper A normal c normal t Baseline 360 left-parenthesis
    s comma m right-parenthesis y Subscript m Baseline right-parenthesis Over t EndFraction"
    display="block"><mrow><mi>y</mi> <mrow><mo>(</mo> <mi>t</mi> <mo>)</mo></mrow>
    <mo>=</mo> <mfrac><mrow><mo>-</mo><mo form="prefix">ln</mo><mo>(</mo><mn>1</mn><mo>-</mo>
    <mi>Act</mi> <mn>360</mn><mrow><mo>(</mo><mi>s</mi><mo>,</mo><mi>m</mi><mo>)</mo></mrow><msub><mi>y</mi>
    <mi>m</mi></msub> <mo>)</mo></mrow> <mi>t</mi></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: It is essential that any set of interest rate products used to create a yield
    curve have the same settle date. Let the maturity dates for the products be *d*[1],<
    *d*[2] < …​ < *d[n]*, with *s* < *d*[1], and the associated yields be *y*[1],
    *y*[2], …​, *y*[n], where <math alttext="y Subscript i Baseline equals y left-parenthesis
    t Subscript i Baseline right-parenthesis"><mrow><msub><mi>y</mi> <mi>i</mi></msub>
    <mo>=</mo> <mi>y</mi> <mrow><mo>(</mo> <msub><mi>t</mi> <mi>i</mi></msub> <mo>)</mo></mrow></mrow></math>
    and *t[i]* = Act365(*s*,*d[i]*). Since the yields are calculated for a date interval
    whose first date is the settlement date, these yields are known as spot yields.
  prefs: []
  type: TYPE_NORMAL
- en: There are many continuous curve which pass through the points
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="left-parenthesis t 1 comma y 1 right-parenthesis comma left-parenthesis
    t 2 comma y 2 right-parenthesis comma ellipsis comma left-parenthesis t Subscript
    n Baseline comma y Subscript n Baseline right-parenthesis" display="block"><mrow><mrow><mo>(</mo>
    <msub><mi>t</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mrow><mo>(</mo> <msub><mi>t</mi> <mn>2</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mo>⋯</mo>
    <mo>,</mo> <mrow><mo>(</mo> <msub><mi>t</mi> <mi>n</mi></msub> <mo>,</mo> <msub><mi>y</mi>
    <mi>n</mi></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The choice of an appropriate curve is a business decision made by the user of
    the yield curve. This typically based on a curve-fitting technique employing a
    particular interpolation method.
  prefs: []
  type: TYPE_NORMAL
- en: Discount Factors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Consider a unit payment amount made at time *m*. What is its value on a settle
    date, *s* < *m*? Let *P*(*s*,*m*) be the price, paid on the settle date, let *t*=Act365(*s*,*m*)
    and let *y*(*t*) be the associated yield. Then
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis s comma m right-parenthesis e Superscript
    t y left-parenthesis t right-parenthesis Baseline equals 1" display="block"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <mi>m</mi> <mo>)</mo></mrow> <msup><mi>e</mi>
    <mrow><mi>t</mi><mi>y</mi><mo>(</mo><mi>t</mi><mo>)</mo></mrow></msup> <mo>=</mo>
    <mn>1</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: from which *P*(*s*,*m*) = e^(*-ty*(*t*)). Now *P*(*s*,*m*) is the present value,
    as seen on date *s* for unit payment made on date *m*. In other words, it is the
    discount factor for the period *s* to *m*. Since *y*(*t*) is a spot yield, this
    is a spot discount factor.
  prefs: []
  type: TYPE_NORMAL
- en: Forward Discount Factors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: How do we calculate the discount factor for a period which begins at time *d*[1]
    and ends at time *d*[2], where *s* < *d*[1] \leq d_2?
  prefs: []
  type: TYPE_NORMAL
- en: Consider a unit payment to be made at time *d*[2] and let its value at *d*[1]
    be represented by *P*(*s*; *d*[1],*d*[2]). Its spot value – hence the parameter
    *s* – is
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis s comma d 1 right-parenthesis upper
    P left-parenthesis s semicolon d 1 comma d 2 right-parenthesis" display="block"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <msub><mi>d</mi> <mn>1</mn></msub> <mo>)</mo></mrow>
    <mi>P</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>;</mo> <msub><mi>d</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>d</mi> <mn>2</mn></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: To avoid arbitrage opportunities we must have
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis s comma d 2 right-parenthesis equals
    upper P left-parenthesis s comma d 1 right-parenthesis upper P left-parenthesis
    s semicolon d 1 comma d 2 right-parenthesis comma s o t h a t" display="block"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <msub><mi>d</mi> <mn>2</mn></msub> <mo>)</mo></mrow>
    <mo>=</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <msub><mi>d</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow> <mi>P</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>;</mo>
    <msub><mi>d</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>d</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mi>s</mi> <mi>o</mi> <mi>t</mi> <mi>h</mi> <mi>a</mi>
    <mi>t</mi></mrow></math><math alttext="upper P left-parenthesis s semicolon d
    1 comma d 2 right-parenthesis equals StartFraction upper P left-parenthesis s
    comma d 2 right-parenthesis Over upper P left-parenthesis s comma d 1 right-parenthesis
    EndFraction" display="block"><mrow><mi>P</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>;</mo>
    <msub><mi>d</mi> <mn>1</mn></msub> <mo>,</mo> <msub><mi>d</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow> <mo>=</mo> <mfrac><mrow><mi>P</mi><mo>(</mo><mi>s</mi><mo>,</mo><msub><mi>d</mi>
    <mn>2</mn></msub> <mo>)</mo></mrow> <mrow><mi>P</mi><mo>(</mo><mi>s</mi><mo>,</mo><msub><mi>d</mi>
    <mn>1</mn></msub> <mo>)</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Substituting for the spot discount factors:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper P left-parenthesis s semicolon d 1 comma d 2 right-parenthesis
    equals StartFraction e Superscript minus t 2 y left-parenthesis t 2 right-parenthesis
    Baseline Over e Superscript minus t 1 y left-parenthesis t 1 right-parenthesis
    Baseline EndFraction equals e Superscript t 1 y left-parenthesis t 1 right-parenthesis
    minus t 2 y left-parenthesis t 2 right-parenthesis" display="block"><mrow><mi>P</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>;</mo> <msub><mi>d</mi> <mn>1</mn></msub> <mo>,</mo>
    <msub><mi>d</mi> <mn>2</mn></msub> <mo>)</mo></mrow> <mo>=</mo> <mfrac><msup><mi>e</mi>
    <mrow><mo>-</mo><msub><mi>t</mi> <mn>2</mn></msub> <mi>y</mi><mrow><mo>(</mo><msub><mi>t</mi>
    <mn>2</mn></msub> <mo>)</mo></mrow></mrow></msup> <msup><mi>e</mi> <mrow><mo>-</mo><msub><mi>t</mi>
    <mn>1</mn></msub> <mi>y</mi><mrow><mo>(</mo><msub><mi>t</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow></mrow></msup></mfrac> <mo>=</mo> <msup><mi>e</mi> <mrow><msub><mi>t</mi>
    <mn>1</mn></msub> <mi>y</mi><mrow><mo>(</mo><msub><mi>t</mi> <mn>1</mn></msub>
    <mo>)</mo></mrow><mo>-</mo><msub><mi>t</mi> <mn>2</mn></msub> <mi>y</mi><mrow><mo>(</mo><msub><mi>t</mi>
    <mn>2</mn></msub> <mo>)</mo></mrow></mrow></msup></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Since *d*[1] > *s*, *P*(*s*;_d_[1],*d*[2]) is a forward discount factor.
  prefs: []
  type: TYPE_NORMAL
- en: The next sections will describe a framework for yield curves in C++, followed
    by a simple example of a yield curve and its use to value a bond
  prefs: []
  type: TYPE_NORMAL
- en: A Yield Curve Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The essential function on a yield curve class will return a continuously compounded
    forward discount factor between two arbitrary dates, as detailed in the previous
    section. Fitting the resulting curve through the points <math alttext="left-parenthesis
    t 1 comma y 1 right-parenthesis comma left-parenthesis t 2 comma y 2 right-parenthesis
    comma ellipsis comma left-parenthesis t Subscript n Baseline comma y Subscript
    n Baseline right-parenthesis"><mrow><mrow><mo>(</mo> <msub><mi>t</mi> <mn>1</mn></msub>
    <mo>,</mo> <msub><mi>y</mi> <mn>1</mn></msub> <mo>)</mo></mrow> <mo>,</mo> <mrow><mo>(</mo>
    <msub><mi>t</mi> <mn>2</mn></msub> <mo>,</mo> <msub><mi>y</mi> <mn>2</mn></msub>
    <mo>)</mo></mrow> <mo>,</mo> <mo>⋯</mo> <mo>,</mo> <mrow><mo>(</mo> <msub><mi>t</mi>
    <mi>n</mi></msub> <mo>,</mo> <msub><mi>y</mi> <mi>n</mi></msub> <mo>)</mo></mrow></mrow></math>
    can be based on a plethora of numerical methods in the literature. As examples,
    these can range from a simple linearly interpolated yield curve, to more sophisticated
    examples such as a cubic spline-interpolated curve, Smoothest Yield Curves {7},
    or the Monotone Convex Method {8}.
  prefs: []
  type: TYPE_NORMAL
- en: At a high level then, we could define an abstract base class that
  prefs: []
  type: TYPE_NORMAL
- en: Provides a common method to convert market yield data into continuously compounded
    yields, based on the results above {[4.1]}
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Requires a derived class to implement its own curve-fitting method as a private
    member function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '{UML Diagram Here}'
  prefs: []
  type: TYPE_NORMAL
- en: The base class will contain a non-virtual public function that calculates the
    forward discount factor between two dates, using interpolated yields from the
    overridden `yield_curve_` method on each derived class. The interpolated yields
    determined from each derived class are assumed to be continuously compounded with
    the Act/365 day count basis. The overridden `yield_curve_` method will depend
    on market data, related to a specific settle date.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The implementation of `discount_factor` then follows the mathematical derivation
    presented in [[4.1.2]]. Note that if the first date `d1` is the settle date, the
    result defaults to the spot discount factor at date `d2`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A Linearly Interpolated Yield Curve Class Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest curve fitting method – but still sometimes used in practice – is
    linear interpolation. More sophisticated interpolation methods also exist, such
    as those referenced above, but these require considerably more mathematical horsepower.
    So to keep the discussion concise, we will limit the example here to the linearly
    interpolated case, but it is important to remember that more advanced methods
    can also be integrated into the same inheritance structure.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The constructor will take in the maturities associated with each of the yield
    data points relative to the settle date, based on the Actual/365 day count basis.
    The corresponding spot yield values follow in the vector in the third argument.
    Its implementation will check whether the maturity and yield vectors are of the
    same length, and whether the settle date value is negative. If either is true,
    an exception is thrown. For the purposes of demonstration, we will just assume
    the maturities are in ascending order, but in production this would be another
    invariant to check.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The linear interpolation method is implemented in the mandated `yield_curve_`
    private member function. If the year fraction at which a yield is to be interpolated
    exceeds the maximum time value in the data, the result is just the last yield
    value. Otherwise, the `while` loop locates the interval of time points that surrounds
    the input value of time `t`. Then, the proportionally weighted yield is calculated
    and returned.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: A Bond Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are now in position to utilize objects of the preceding classes, along with
    a user-defined `Bond` class, to calculate the value of a coupon-paying bond. Common
    examples of bonds in the include government-issued Treasury Bonds, agency bonds
    (issued by a government-sponsored enterprise such as the Government National Mortgage
    Association (GNMA) in the US), corporate bonds, and local state and municipal
    bonds. As debt obligations, a series of regular payments over time is made in
    exchange for an amount borrowed by the issuer. The main difference with a traditional
    loan is the principal amount, ie the face value, is returned when the bond matures,
    rather than being amortized over time.
  prefs: []
  type: TYPE_NORMAL
- en: Bond Payments and Valuation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before proceeding with further code development, it is probably worthwhile to
    summarize the mechanics of how bond payments are structured, and how a bond is
    commonly valued. The details behind this are very important in writing real world
    bond trading software, yet it is surprising they are so often glossed over in
    computational finance courses and textbooks. The following discussion will then
    essentially become the design requirements for a `Bond` class, to subsequently
    follow.
  prefs: []
  type: TYPE_NORMAL
- en: The general idea is that a bond pays fixed amounts on dates in a regular schedule;
    for example, suppose a bond has a face value of $1000 and pays 5% of its face
    value every six months. Then the payment frequency is twice per year, and the
    coupon amount would be
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction 0.05 left-parenthesis 1000 right-parenthesis Over
    2 EndFraction equals 25" display="block"><mrow><mfrac><mrow><mn>0</mn><mo>.</mo><mn>05</mn><mo>(</mo><mn>1000</mn><mo>)</mo></mrow>
    <mn>2</mn></mfrac> <mo>=</mo> <mn>25</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: In general, the formula is
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="r e g u l a r c o u p o n a m o u n t equals left-parenthesis
    c o u p o n r a t e right-parenthesis StartFraction left-parenthesis f a c e v
    a l u e right-parenthesis Over left-parenthesis c o u p o n f r e q u e n c y
    right-parenthesis EndFraction" display="block"><mrow><mi>r</mi> <mi>e</mi> <mi>g</mi>
    <mi>u</mi> <mi>l</mi> <mi>a</mi> <mi>r</mi> <mi>c</mi> <mi>o</mi> <mi>u</mi> <mi>p</mi>
    <mi>o</mi> <mi>n</mi> <mi>a</mi> <mi>m</mi> <mi>o</mi> <mi>u</mi> <mi>n</mi> <mi>t</mi>
    <mo>=</mo> <mrow><mo>(</mo> <mi>c</mi> <mi>o</mi> <mi>u</mi> <mi>p</mi> <mi>o</mi>
    <mi>n</mi> <mi>r</mi> <mi>a</mi> <mi>t</mi> <mi>e</mi> <mo>)</mo></mrow> <mfrac><mrow><mo>(</mo><mi>f</mi><mi>a</mi><mi>c</mi><mi>e</mi><mi>v</mi><mi>a</mi><mi>l</mi><mi>u</mi><mi>e</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>o</mi><mi>n</mi><mi>f</mi><mi>r</mi><mi>e</mi><mi>q</mi><mi>u</mi><mi>e</mi><mi>n</mi><mi>c</mi><mi>y</mi><mo>)</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'The first task is to create a list of dates when payments are due and the coupon
    payment amounts for each of those dates. Along with the face value and annual
    coupon rate, the contractual conditions of the bond also include the following
    four dates:'
  prefs: []
  type: TYPE_NORMAL
- en: Issue date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First coupon date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Penultimate coupon date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maturity date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *issue date* is the date on which the bond is first put on sale. A stream
    of fixed payments is typically paid, eg every six months, beginning with the *first
    coupon date*. The second to last payment occurs on the *penultimate coupon date*,
    and the final payment, consisting of the last coupon payment plus repayment of
    the face value, occurs on the *maturity date*. We will again assume the coupon
    day is less than 29, to avoid problems with end of month cases.
  prefs: []
  type: TYPE_NORMAL
- en: Determining the Payment Schedule
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Returning to the example above, of a bond which pays 5% coupon on a face value
    of $1000 with a coupon frequency of 2, when will the payments be made?
  prefs: []
  type: TYPE_NORMAL
- en: For coupons between the first coupon date and the penultimate date, payment
    *due dates* fall on a *regular schedule*. This means a constant payment of $25
    is due every six months. To ensure these dates belong to a regular schedule of
    due dates, in general there are restrictions on the first and penultimate coupon
    dates, and the coupon frequency. These two dates must be business days having
    the same day of the month, the coupon frequency must be a divisor of twelve, and
    the two dates must differ by a multiple of 12/(coupon frequency) months.
  prefs: []
  type: TYPE_NORMAL
- en: Since the due dates may not fall on business dates, the bond also has associated
    *payment dates* that are adjusted for weekends and holidays. To simplify matters
    we will assume there are no holidays except Saturday and Sunday, as well as assume
    payments will not occur on any day with value greater than 28, so that if a due
    date falls on a weekend, the regular coupon payment will be made on the following
    Monday.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose the bond has a first coupon date of 17 Mar 2023 and a penultimate
    coupon date of 17 Mar 2025\. The two dates differ by 36 months, which is a multiple
    of 12/2=6, as required. Then, the intermediate due dates are 17 Sep 2023, 17 Mar
    2024, …​, 17 Mar 2025\. These due dates will not all fall on business days, so
    each will need to be checked and rolled forward if necessary to qualify as payment
    dates.
  prefs: []
  type: TYPE_NORMAL
- en: If the first and final payments also occur regular periods, they will be \$25
    and \$1025, respectively. However, first and last coupon periods may or may not
    be regular. The usually cited case is an irregular first payment period, but there
    can also be cases over of an irregular period from penultimate to maturity date.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a short first period, the coupon payment is calculated by multiplying
    the annual coupon rate by the ratio of actual days in the period over the number
    of days in what would be a normal first period. Again, let us use the example
    of a \$1000 face value bond paying an annual coupon of 5% semiannually (\$25 regular
    coupon payments). Suppose a ten-year bond is issued on 2022-7-12, with a first
    payment date of 2022-12-21\. Subsequent payment dates are then on 21 June and
    21 December. If the first payment period had been regular, the issue date would
    have been 2022-6-21\. This date is called the *first prior date*. Now, the first
    payment is prorated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction left-parenthesis c o u p o n p a y m e n t right-parenthesis
    left-parenthesis n u m b e r o f d a y s f r o m i s s u e t o Baseline 1 s t
    p m t right-parenthesis Over left-parenthesis n u m b e r o f d a y s f r o m
    Baseline 1 s t p r i o r t o Baseline 1 s t p m t EndFraction equals" display="block"><mrow><mfrac><mrow><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>o</mi><mi>n</mi><mi>p</mi><mi>a</mi><mi>y</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>)</mo><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>u</mi><mi>e</mi><mi>t</mi><mi>o</mi><mn>1</mn><mi>s</mi><mi>t</mi><mi>p</mi><mi>m</mi><mi>t</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mn>1</mn><mi>s</mi><mi>t</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>o</mi><mn>1</mn><mi>s</mi><mi>t</mi><mi>p</mi><mi>m</mi><mi>t</mi></mrow></mfrac>
    <mo>=</mo></mrow></math><math alttext="25 left-parenthesis StartFraction 162 Over
    183 EndFraction right-parenthesis equals normal dollar-sign 22.13" display="block"><mrow><mn>25</mn>
    <mo>(</mo> <mfrac><mn>162</mn> <mn>183</mn></mfrac> <mo>)</mo> <mo>=</mo> <mi>$</mi>
    <mn>22</mn> <mo>.</mo> <mn>13</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9-1: Irregular short first coupon period](Images/Fig_9_1.png)'
  prefs: []
  type: TYPE_IMG
- en: In the case of a long first period, suppose we have a bond with the same terms
    as in the short period example, but where the issue date is now 2022-5-12.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9-2: Irregular long first coupon period](Images/Fig_9_2.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the first coupon payment will be the regular coupon of $25 over
    the period from the first prior date to issue, *plus* a partial payment (in red)
    over the interval between issue and first prior date. This extra payment is prorated
    over the six-month period from the *second prior date* to the first. That is,
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction left-parenthesis c o u p o n p a y m e n t right-parenthesis
    left-parenthesis n u m b e r o f d a y s f r o m i s s u e t o Baseline 1 s t
    p r i o r right-parenthesis Over left-parenthesis n u m b e r o f d a y s f r
    o m Baseline 2 n d p r i o r t o Baseline 1 s t p r i o r right-parenthesis EndFraction
    equals" display="block"><mrow><mfrac><mrow><mo>(</mo><mi>c</mi><mi>o</mi><mi>u</mi><mi>p</mi><mi>o</mi><mi>n</mi><mi>p</mi><mi>a</mi><mi>y</mi><mi>m</mi><mi>e</mi><mi>n</mi><mi>t</mi><mo>)</mo><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mi>i</mi><mi>s</mi><mi>s</mi><mi>u</mi><mi>e</mi><mi>t</mi><mi>o</mi><mn>1</mn><mi>s</mi><mi>t</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mo>)</mo></mrow>
    <mrow><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>b</mi><mi>e</mi><mi>r</mi><mi>o</mi><mi>f</mi><mi>d</mi><mi>a</mi><mi>y</mi><mi>s</mi><mi>f</mi><mi>r</mi><mi>o</mi><mi>m</mi><mn>2</mn><mi>n</mi><mi>d</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>o</mi><mn>1</mn><mi>s</mi><mi>t</mi><mi>p</mi><mi>r</mi><mi>i</mi><mi>o</mi><mi>r</mi><mo>)</mo></mrow></mfrac>
    <mo>=</mo></mrow></math><math alttext="25 left-parenthesis StartFraction 40 Over
    182 EndFraction right-parenthesis equals normal dollar-sign 5.49" display="block"><mrow><mn>25</mn>
    <mo>(</mo> <mfrac><mn>40</mn> <mn>182</mn></mfrac> <mo>)</mo> <mo>=</mo> <mi>$</mi>
    <mn>5</mn> <mo>.</mo> <mn>49</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The total first coupon payment is then 25 + 5.49 = 30.49
  prefs: []
  type: TYPE_NORMAL
- en: Calculating prorated payments over irregular final periods are similar, except
    that prior payment periods preceding issue, extra payment periods extending later
    than maturity are utilized.
  prefs: []
  type: TYPE_NORMAL
- en: Valuing a Bond
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The issuer sells bonds on the issue date, pays the owners of the bonds the coupon
    amounts and, at maturity, also pays back the face value of the bond. The owner
    of a bond may then sell it on the secondary market, in which case the buyer and
    seller agree to a business date, known as the bond settle date, on which the sale
    will take place. On this settle date the seller receives his money, and the buyer
    becomes the registered owner, with the right to receive all payments which fall
    due after the settle date. Should the owner of the bond wish to value the bond
    at any time, this can be done by calculating the discounted value of the bond,
    using a yield curve of his own choice, and the discount factors calculated for
    the periods from the settlement date to the corresponding payment dates.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9-3: Bond valuation at settle date](Images/Fig_9_3.png)'
  prefs: []
  type: TYPE_IMG
- en: Revisiting the example in Figure 9-1, suppose a bond is exchanged for cash on
    2023-10-24, as indicated by the red hash mark in Figure 9-3 above. All preceding
    coupon payments have been paid to the previous owner, so the value of the bond
    will only depend on payments beginning with the third coupon payment through maturity.
    If the bond and yield curve settle dates are the same, then using the discount
    factor notation above, the value of the bond on this date will be
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="25 left-parenthesis upper P left-parenthesis s comma d 3 right-parenthesis
    plus ellipsis plus upper P left-parenthesis s comma d Subscript p Baseline right-parenthesis
    right-parenthesis plus left-parenthesis 1000 plus 25 right-parenthesis upper P
    left-parenthesis s comma d Subscript m Baseline right-parenthesis" display="block"><mrow><mn>25</mn>
    <mrow><mo>(</mo> <mi>P</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <msub><mi>d</mi>
    <mn>3</mn></msub> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <mo>+</mo> <mi>P</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <msub><mi>d</mi> <mi>p</mi></msub> <mo>)</mo></mrow>
    <mo>)</mo></mrow> <mo>+</mo> <mrow><mo>(</mo> <mn>1000</mn> <mo>+</mo> <mn>25</mn>
    <mo>)</mo></mrow> <mi>P</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>,</mo> <msub><mi>d</mi>
    <mi>m</mi></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where *s* = 2023-10-24 is the yield curve settlement date, *d[p]* = 2032-6-21
    is the penultimate coupon date, and *d[m]* = 2032-12-21 is the maturity date.
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible for a bond settle date to occur after the yield curve settle
    date. Suppose the bond transaction is to occur two business days after the yield
    curve settle date. If we let *s[b]* = 2023-10-26, then the bond value becomes
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="25 left-parenthesis upper P left-parenthesis s semicolon s Subscript
    b Baseline comma d 3 right-parenthesis plus ellipsis plus upper P left-parenthesis
    s semicolon s Subscript b Baseline comma d Subscript p Baseline right-parenthesis
    right-parenthesis plus left-parenthesis 1000 plus 25 right-parenthesis upper P
    left-parenthesis s semicolon s Subscript b Baseline comma d Subscript m Baseline
    right-parenthesis" display="block"><mrow><mn>25</mn> <mrow><mo>(</mo> <mi>P</mi>
    <mrow><mo>(</mo> <mi>s</mi> <mo>;</mo> <msub><mi>s</mi> <mi>b</mi></msub> <mo>,</mo>
    <msub><mi>d</mi> <mn>3</mn></msub> <mo>)</mo></mrow> <mo>+</mo> <mo>⋯</mo> <mo>+</mo>
    <mi>P</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>;</mo> <msub><mi>s</mi> <mi>b</mi></msub>
    <mo>,</mo> <msub><mi>d</mi> <mi>p</mi></msub> <mo>)</mo></mrow> <mo>)</mo></mrow>
    <mo>+</mo> <mrow><mo>(</mo> <mn>1000</mn> <mo>+</mo> <mn>25</mn> <mo>)</mo></mrow>
    <mi>P</mi> <mrow><mo>(</mo> <mi>s</mi> <mo>;</mo> <msub><mi>s</mi> <mi>b</mi></msub>
    <mo>,</mo> <msub><mi>d</mi> <mi>m</mi></msub> <mo>)</mo></mrow></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: Discounted valuations are also routine calculations in trading and risk management
    software. Modern professional traders use this value as a benchmark for determining
    the fair (or equilibrium) market price of a bond. Risk managers will calculate
    bonds under multiple shocked or random yield curve scenarios to derive measures
    of their portfolio exposures to market risk.
  prefs: []
  type: TYPE_NORMAL
- en: A Bond Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our task now is to implement the requirements above in a user-defined `Bond`
    class, using the contractual terms of a bond as input data. First, let us here
    consolidate and review the essential data inputs associated with a bond issue.
  prefs: []
  type: TYPE_NORMAL
- en: Face value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Annual coupon rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of coupon payments per year (coupon frequency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issue date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First coupon date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Penultimate coupon date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maturity date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Day count basis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our `Bond` class can be formally summarized as shown in the class declaration
    below.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Note that all the contractual information is captured in the constructor, and
    valuation of the bond will be delegated to the public `discounted_value` function.
    This separates what is essentially the “interface” – namely the input and processing
    of contractual bond data – from the “implementation” where the bond value is calculated.
    Per the discussion in {[5.1]}, this valuation function is based on the bond settlement
    date and the market yield curve, inputs that are independent from the constructor
    arguments. One specific advantage to this is a single `Bond` instance can be created,
    and its valuation function called many times under different market scenarios
    for risk reporting purposes, as noted previously.
  prefs: []
  type: TYPE_NORMAL
- en: There are three vectors of equal length, `due_dates_`, `payment_dates_`, and
    `payment_amounts_`, corresponding to the respective descriptions in Section {[5.1.1]}
    {Determining the Payment Schedule} above. All three are necessary for calculating
    the discounted value of a bond.
  prefs: []
  type: TYPE_NORMAL
- en: A bond ID field is also generally required for both trading and risk applications,
    so it is added as a constructor argument and data member, along with a public
    accessor. The `coupon_frequency` parameter represents the number of coupon payments
    per year – ie 2 for semiannual, and 4 for quarterly – as defined in the bond contract.
  prefs: []
  type: TYPE_NORMAL
- en: Bond Class Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will work through the class implementation step by step. The constructor
    will generate the due and payment dates, and the payment amounts. Note that `first_coupon_date`,
    `penultimate_coupon_date` and `maturity_date` are due dates which fall on business
    days. The `first_coupon_date` and `penultimate_coupon_date` input objects are
    also dates that are part of the regular schedule of due dates. The maturity date
    may or may not be part of the regular schedule of due dates, as discussed previously.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: First (1), although the `coupon_frequency` value is defined in the bond contract,
    and often stored in a bond database, it is easier to use the length of the regular
    coupon period – eg 3 months, 6 months, etc – in the tasks that follow. This equivalent
    number of months is calculated as shown above and stored as the constant integer
    value `months_in_regular_coupon_period`. Next (2), following the formula presented
    above {[5.1]}, `regular_coupon_payment` stores this value as a constant. Recall
    that regular coupon periods are those which span two adjacent due dates, and all
    coupon periods except the first and last are guaranteed to be regular.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the Date and Payment Vectors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now (3), the constructor implementation will generate the due and payment dates,
    and the payment amounts. The `due_dates_` vector will contain the regular dates
    that get generated for each respective coupon period – eg every six months – up
    to the contractual penultimate coupon date. These are not adjusted for weekends.
    Because the `+=` operator for months on `std::chrono::year_month_day` guarantees
    the same day value, with the correct year and month result, we are OK as long
    as the successive date is valid. Bonds have many variations, but since this is
    not production code it is simplified by assuming the coupon day is less than 29\.
    This avoids end of month calculations.
  prefs: []
  type: TYPE_NORMAL
- en: At point (4), the `weekend_roll` member function is applied to successive copies
    of each due date and pushed onto the `payment_dates_` vector prior to the penultimate
    payment date. Thus, any due date falling on a weekend is rolled to the next business
    date. The regular coupon payment amount is also appended to the `payment_amounts_`
    vector corresponding to each regular date.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous step, the first coupon payment was naively set to the regular
    amount, so in (5), a check is made whether the first payment period is irregular.
    If so, a nested conditional statement determines whether this period is short
    or long. In the event of a short period, the first prior date is found by subtracting
    the number of months in a regular period from the first payment date, and then
    the prorated coupon is calculated. In the event of a long period, the second prior
    date is determined, and then the prorated coupon over the interval from issue
    to the first prior date is calculated. The total first coupon payment is then
    this prorated amount plus a regular payment {[see 5.1.1]}.
  prefs: []
  type: TYPE_NORMAL
- en: The maturity date is a business day and is appended to each date vector. It
    is provisionally assumed to follow a normal payment period, and thus the final
    payment is set to the regular coupon amount plus the face value of the bond at
    this point (6). Then, one more conditional statement checks if the final period
    is regular or not. If so, an adjustment is made to the final payment. Similar
    calculations to an irregular first period are performed, but using prospective
    rather than retrospective extensions (7).
  prefs: []
  type: TYPE_NORMAL
- en: Finally (8), the final payment consisting of the final coupon payment and return
    of face value is appended to the vector of payments.
  prefs: []
  type: TYPE_NORMAL
- en: Bond Valuation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although bonds can be traded at whichever price a buyer and seller agree, traders
    will usually require having access to the benchmark “fair” price, namely the sum
    of the discounted payments remaining as of the bond settlement date. As noted
    in Section {[5.1.2]}, the buyer of a bond becomes entitled to receive all payments
    that are due strictly *after* the settlement date. This introduces a special case
    that is addressed in the code, namely if bond settlement occurs on a due date,
    the coupon payment is paid to the seller. Therefore, only those coupon payments
    due after settlement add to the bond value in the form of discounted amounts.
    If a due date falls on a weekend, it cannot be a settle date, and therefore the
    payment date is rolled to the next Monday and is payable to the buyer. It is for
    this reason the `Bond` class has both due date and payment date vectors as data
    members.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: The code will loop through the `due_dates_` member vector until the first due
    date strictly later than settlement is located. At this point, each remaining
    payment – starting with the same current index as `due_dates_` — is obtained from
    the `payment_amounts_` vector. Each payment value is discounted from the payment
    date back to the bond settlement date. The discount factor that multiplies each
    payment is easily obtained by the eponymous member function on the `yield_curve`
    input object. The cumulative sum of these discounted payments is then returned
    as the fair market value of the bond.
  prefs: []
  type: TYPE_NORMAL
- en: As you may notice, this valuation function is short and compact, as the due
    dates have been generated by the constructor, along with the payment dates adjusted
    for business days where necessary. The payment amounts – including the final payment
    comprised of the last coupon payment and return of face value – were also computed
    by the constructor, including any adjustment to the first payment in the event
    of an irregular short or long payment period.
  prefs: []
  type: TYPE_NORMAL
- en: The discount factors back to the bond settlement date are easily obtained from
    the member function `discounted_value` on the input `yield_curve` object, while
    all the date functionality is wrapped in the `ChronoDate` class. In essence, the
    `discounted_value` function doesn’t “need to care” about how the discount factors
    or date calculations are obtained. It just uses public member functions on the
    objects to get the information it needs and computes the result.
  prefs: []
  type: TYPE_NORMAL
- en: A Bond Valuation Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now put the individual classes previously presented into an example of
    pricing a bond. Recall that the `YieldCurve` abstract base class will required
    a derived curve fitting method. Again, there are many different approaches available,
    ranging from simple to highly advanced, but to keep the example concise, we will
    use linear interpolation. In constructing a `Bond` object, we will need to supply
    the face value, issue date, first coupon date, penultimate payment date, and maturity
    of the bond, along with its face value.
  prefs: []
  type: TYPE_NORMAL
- en: '{UML diagram here} As an example, suppose the term sheet of a 20-year bond
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-1\. Table 9-1: Contractual bond terms - example'
  prefs: []
  type: TYPE_NORMAL
- en: '|  |  |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Face Value | $1000 |'
  prefs: []
  type: TYPE_TB
- en: '| Annual Coupon Rate | 6.2% |'
  prefs: []
  type: TYPE_TB
- en: '| Payment Frequency | Every six months (semiannual) |'
  prefs: []
  type: TYPE_TB
- en: '| Issue Date | Mon 8 May 2023 |'
  prefs: []
  type: TYPE_TB
- en: '| First Coupon Date | Tue 7 Nov 2023 |'
  prefs: []
  type: TYPE_TB
- en: '| Penultimate Coupon Date | Wed 7 May 2042 |'
  prefs: []
  type: TYPE_TB
- en: '| Maturity Date | Fri 7 Nov 2042 |'
  prefs: []
  type: TYPE_TB
- en: 'Data in practice would be taken in from an interface and converted to `ChronoDate`
    types, but we can replicate the result as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Recall, however, the due dates, payment dates, and payment amounts are all
    generated and adjusted in the body of the constructor. Each due date will carry
    a day value of 7, and the payment dates are the same except for the due dates
    falling on weekends that are rolled to the next Monday:'
  prefs: []
  type: TYPE_NORMAL
- en: 2026-11-09, 2027-11-08, 2028-05-08,
  prefs: []
  type: TYPE_NORMAL
- en: 2032-11-08, 2033-05-09, 2034-05-08,
  prefs: []
  type: TYPE_NORMAL
- en: 2037-11-09, 2038-11-08, 2039-05-09
  prefs: []
  type: TYPE_NORMAL
- en: The regular coupon amount is
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="StartFraction 1000 left-parenthesis 0.0625 right-parenthesis
    Over 2 EndFraction equals normal dollar-sign 31.00" display="block"><mrow><mfrac><mrow><mn>1000</mn><mo>(</mo><mn>0</mn><mo>.</mo><mn>0625</mn><mo>)</mo></mrow>
    <mn>2</mn></mfrac> <mo>=</mo> <mi>$</mi> <mn>31</mn> <mo>.</mo> <mn>00</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: The only irregular period will be the from settle to the first coupon date,
    2023-05-08 to 2023-11-07, resulting in the calculated coupon amount as
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="31 left-parenthesis StartFraction 183 Over 184 EndFraction right-parenthesis
    equals normal dollar-sign 24.86" display="block"><mrow><mn>31</mn> <mo>(</mo>
    <mfrac><mn>183</mn> <mn>184</mn></mfrac> <mo>)</mo> <mo>=</mo> <mi>$</mi> <mn>24</mn>
    <mo>.</mo> <mn>86</mn></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: where <math alttext="StartFraction 183 Over 184 EndFraction"><mfrac><mn>183</mn>
    <mn>184</mn></mfrac></math> is the ratio of the actual number of days in the first
    period by the number of days from the first prior date to first coupon date.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, suppose we want to value the bond on a date between issue and first coupon
    date, say Tuesday, 10 October 2023\. Suppose also market data as of this date
    imply the following spot yields:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 4-2\. Table 9-2: Spot yields - example (figures rounded)'
  prefs: []
  type: TYPE_NORMAL
- en: '| Period | Maturity | Year Fraction | Yield |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Overnight | 2023-10-11 | 0.00274 | 2% |'
  prefs: []
  type: TYPE_TB
- en: '| 3 Month | 2024-01-10 | 0.25205 | 2.19% |'
  prefs: []
  type: TYPE_TB
- en: '| 6 Month | 2024-04-10 | 0.50137 | 2.37% |'
  prefs: []
  type: TYPE_TB
- en: '| 1 Year | 2024-10-10 | 1.00274 | 2.67% |'
  prefs: []
  type: TYPE_TB
- en: '| 2 Year | 2025-10-10 | 2.00274 | 3.12% |'
  prefs: []
  type: TYPE_TB
- en: '| 3 Year | 2026-10-12 | 3.00822 | 3.43% |'
  prefs: []
  type: TYPE_TB
- en: '| 5 Year | 2028-10-10 | 5.00548 | 3.78% |'
  prefs: []
  type: TYPE_TB
- en: '| 7 Year | 2030-10-10 | 7.00548 | 3.93% |'
  prefs: []
  type: TYPE_TB
- en: '| 10 Year | 2033-10-10 | 10.0082 | 4% |'
  prefs: []
  type: TYPE_TB
- en: '| 15 Year | 2038-10-11 | 15.0137 | 4.01% |'
  prefs: []
  type: TYPE_TB
- en: '| 20 Year | 2043-10-12 | 20.0192 | 4.01% |'
  prefs: []
  type: TYPE_TB
- en: '| 30 Year | 2053-10-10 | 30.0219 | 4% |'
  prefs: []
  type: TYPE_TB
- en: 'Create two vectors containing the maturities (as year fractions) and discount
    bond prices above (again, in place of containers that would normally be initialized
    in an interface):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'And also the settlement date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'With these, we can create an instance of a linearly interpolated yield curve:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to value the bond as of the same settlement date, provide the settlement
    date and yield curve data to the corresponding member function on the `Bond` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This function will locate the first due date after settlement (in this case
    the first coupon date), compute each continuously compounded discount factor from
    each payment date back to the settle date using interpolated rates off of the
    yield curve, multiply each payment by this discount factor, and sum the discounted
    values to determine the discounted value of the bond. In this example, the result
    is $1315.34.
  prefs: []
  type: TYPE_NORMAL
- en: Note the design separating the bond data “interface” from the “implementation”
    provides flexibility in two respects. First, as noted above, a `Bond` object can
    be created once, and then multiple random or shocked yield curve scenarios can
    be applied to the valuation of the same bond. This can make calculations of risk
    measures more efficient by obviating the need to create a whole new `Bond` object
    for each scenario. Thousands of scenarios are often applied in these situations,
    and there can be thousands of bonds in a portfolio, held in multiple bond portfolios
    across all the international trading operations within a financial institution.
    Avoiding new object creation at every step can make a measurable difference in
    the time required to calculate risk values.
  prefs: []
  type: TYPE_NORMAL
- en: The other case could be where the bond settlement date is set for some point
    in the (near) future, but an expected valuation as of current market conditions
    is needed today. As long as the bond settlement date is on or after yield curve
    settlement, the valuation will be valid.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TBD
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '{0} Nicolai Josuttis, The C++ Standard Library 2E, Sec 5.7.1, pp 143-44'
  prefs: []
  type: TYPE_NORMAL
- en: '{1} `std::chrono` date GitHub repository: [*https://github.com/HowardHinnant/date*](https://github.com/HowardHinnant/date)'
  prefs: []
  type: TYPE_NORMAL
- en: '{2} Howard Hinnant, Stack Overflow (Fact 5), [*https://stackoverflow.com/questions/59418514/using-c20-chrono-how-to-compute-various-facts-about-a-date*](https://stackoverflow.com/questions/59418514/using-c20-chrono-how-to-compute-various-facts-about-a-date)'
  prefs: []
  type: TYPE_NORMAL
- en: '{3} `chrono`-Compatible Low-Level Date Algorithms [*https://howardhinnant.github.io/date_algorithms.html*](https://howardhinnant.github.io/date_algorithms.html)'
  prefs: []
  type: TYPE_NORMAL
- en: '{4} Howard Hinnant, Stack Overflow, “C++ chrono: Determine Whether a Day is
    a Weekend” [*https://stackoverflow.com/questions/52776999/c-chrono-determine-whether-day-is-a-weekend*](https://stackoverflow.com/questions/52776999/c-chrono-determine-whether-day-is-a-weekend)'
  prefs: []
  type: TYPE_NORMAL
- en: '{5} Howard Hinnant, Stack Overflow, “How Do I Add a Number of Days to a Date
    in C++20 chrono” [*https://stackoverflow.com/questions/62734974/how-do-i-add-a-number-of-days-to-a-date-in-c20-chrono*](https://stackoverflow.com/questions/62734974/how-do-i-add-a-number-of-days-to-a-date-in-c20-chrono)'
  prefs: []
  type: TYPE_NORMAL
- en: '{6} ISDA 30/360 Day Count Basis [*https://www.iso20022.org/15022/uhb/mt565-16-field-22f.htm*](https://www.iso20022.org/15022/uhb/mt565-16-field-22f.htm)'
  prefs: []
  type: TYPE_NORMAL
- en: '{6.5} Steiner pp 40-41'
  prefs: []
  type: TYPE_NORMAL
- en: '{7} Kenneth J Adams, Smooth interpolation of zero curves, Algo Research Quarterly,
    4(1/2):11-22, 2001'
  prefs: []
  type: TYPE_NORMAL
- en: '{8} Hagan and West, Interpolation Methods for Curve Construction, Applied Mathematical
    Finance, Vol. 13, No. 2\. 89-129, June 2006'
  prefs: []
  type: TYPE_NORMAL
- en: '{9} C++ Add months to chrono::system_clock::time_point, Stack Overflow, [*https://stackoverflow.com/questions/43010362/c-add-months-to-chronosystem-clocktime-point/43018120#43018120*](https://stackoverflow.com/questions/43010362/c-add-months-to-chronosystem-clocktime-point/43018120#43018120)
    (Not referenced directly)'
  prefs: []
  type: TYPE_NORMAL
