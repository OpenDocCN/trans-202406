<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Scheduling and Tooling"><div class="chapter" id="scheduling_tooling">
<h1><span class="label">Chapter 4. </span>Scheduling and Tooling</h1>


<p><a data-type="indexterm" data-primary="scheduling and tooling" id="st_ch"/>The scheduling portion of the CKA focuses on the effects of defining resource boundaries when evaluated by the Kubernetes scheduler. The default runtime behavior of the scheduler can also be modified by defining node affinity rules, as well as taints and tolerations. Of those concepts, you are expected only to understand the nuances of resource boundaries and their effect on the scheduler in different scenarios. Finally, this domain of the curriculum mentions high-level knowledge of manifest management and templating tools.</p>

<p>At a high level, this chapter covers the following concepts:</p>

<ul>
<li>
<p>Resource boundaries for Pods</p>
</li>
<li>
<p>Imperative and declarative manifest management</p>
</li>
<li>
<p>Common templating tools like Kustomize, <code>yq</code>, and Helm</p>
</li>
</ul>






<section data-type="sect1" data-pdf-bookmark="Understanding How Resource Limits Affect &#10;Pod Scheduling"><div class="sect1" id="idm45322720335776">
<h1>Understanding How Resource Limits Affect 
<span class="keep-together">Pod Scheduling</span></h1>

<p><a data-type="indexterm" data-primary="Pods" data-secondary="effect of resource limits on scheduling" id="pod_rl"/><a data-type="indexterm" data-primary="resource limits, effect of, on scheduling Pods" id="rl_pod"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="how resource limits affect Pod scheduling" id="st_pod"/>A Kubernetes cluster can consist of multiple nodes. Depending on a variety of rules (e.g., <a href="https://oreil.ly/m5eep">node selectors</a>, <a href="https://oreil.ly/9Gf7E">node affinity</a>, <a href="https://oreil.ly/2SkeO">taints and tolerations</a>), the Kubernetes scheduler decides which node to pick for running the workload. The CKA exam doesn’t ask you to understand the scheduling concepts mentioned previously, but it would be helpful to have a rough idea how they work on a high level.</p>

<p>One metric that comes into play for workload scheduling is the resource <em>request</em> defined by the containers in a Pod. Commonly used resources that can be specified are CPU and memory. The scheduler ensures that the node’s resource capacity can fulfill the resource requirements of the Pod. More specifically, the scheduler 
<span class="keep-together">determines</span> the sum of resource requests per type across all containers defined in the Pod and compares them with the node’s available resources. <a data-type="xref" href="#pod_scheduling">Figure 4-1</a> illustrates the scheduling process based on the resource requests.</p>

<figure><div id="pod_scheduling" class="figure"><div class="border-box"><img src="Images/ckas_0401.png" alt="ckas 0401" width="1123" height="720"/></div><h6><span class="label">Figure 4-1. </span>Pod scheduling based on resource requests</h6></div></figure>








<section data-type="sect2" data-pdf-bookmark="Defining Container Resource Requests"><div class="sect2" id="idm45322720323360">
<h2>Defining Container Resource Requests</h2>

<p><a data-type="indexterm" data-primary="containers" data-secondary="defining requests" id="idm45322720321856"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="defining container resource requests" id="idm45322720320880"/>Each container in a Pod can define its own resource requests. <a data-type="xref" href="#options_resource_requests">Table 4-1</a> describes the available options including an example value.</p>
<table id="options_resource_requests">
<caption><span class="label">Table 4-1. </span>Options for resource requests</caption>
<thead>
<tr>
<th>YAML Attribute</th>
<th>Description</th>
<th>Example Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>spec.containers[].resources.requests.cpu</code></p></td>
<td><p>CPU resource type</p></td>
<td><p><code>500m</code> (five hundred millicpu)</p></td>
</tr>
<tr>
<td><p><code>spec.containers[].resources.requests.memory</code></p></td>
<td><p>Memory resource type</p></td>
<td><p><code>64Mi</code> (2^26 bytes)</p></td>
</tr>
<tr>
<td><p><code>spec.containers[].resources.requests.hugepages-&lt;size&gt;</code></p></td>
<td><p>Huge page resource type</p></td>
<td><p><code>hugepages-2Mi: 60Mi</code></p></td>
</tr>
<tr>
<td><p><code>spec.containers[].resources.requests.ephemeral-storage</code></p></td>
<td><p>Ephemeral storage resource type</p></td>
<td><p><code>4Gi</code></p></td>
</tr>
</tbody>
</table>

<p>Kubernetes uses resource units for resource types that deviate from standard resource units like megabytes and gigabytes. Explaining all intricacies of those units goes beyond the scope this book, but you can read up on the details in the <a href="https://oreil.ly/bweuT">documentation</a>.</p>

<p>To make the use of those resource requests transparent, we’ll take a look at an example definition. The Pod YAML manifest shown in <a data-type="xref" href="#setting_container_resource_requests">Example 4-1</a> defines two containers, each with their own resource requests. Any node that is allowed to run the Pod needs to be able to support a minimum memory capacity of 320Mi and 1250m CPU, the sum of resources across both containers.</p>
<div id="setting_container_resource_requests" data-type="example">
<h5><span class="label">Example 4-1. </span>Setting container resource requests</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rate-limiter</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">business-app</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/nodejs-business-app:1.0.0</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"256Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1"</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ambassador</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/nodejs-ambassador:1.0.0</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8081</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"64Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"250m"</code><code class="w"/></pre></div>

<p>In this scenario, we are dealing with a Minikube Kubernetes cluster consisting of three nodes, one control plane node, and two worker nodes. The following command lists all nodes:</p>

<pre data-type="programlisting"><strong>$ kubectl get nodes</strong>
NAME           STATUS   ROLES                  AGE   VERSION
minikube       Ready    control-plane,master   12d   v1.21.2
minikube-m02   Ready    &lt;none&gt;                 42m   v1.21.2
minikube-m03   Ready    &lt;none&gt;                 41m   v1.21.2</pre>

<p>In the next step, we’ll create the Pod from the YAML manifest. The scheduler places the Pod on the node named <code>minikube-m03</code>:</p>

<pre data-type="programlisting"><strong>$ kubectl create -f rate-limiter-pod.yaml</strong>
pod/rate-limiter created
<strong>$ kubectl get pod rate-limiter -o yaml | grep nodeName:</strong>
  nodeName: minikube-m03</pre>

<p>Upon further inspection of the node, you can inspect its maximum capacity, how much of this capacity is allocatable, and the memory requests of the Pods scheduled on the node. The following command lists the information and condenses the output to the relevant bits and pieces:</p>

<pre data-type="programlisting"><strong>$ kubectl describe node minikube-m03</strong>
...
Capacity:
  cpu:                2
  ephemeral-storage:  17784752Ki
  hugepages-2Mi:      0
  memory:             2186612Ki
  pods:               110
Allocatable:
  cpu:                2
  ephemeral-storage:  17784752Ki
  hugepages-2Mi:      0
  memory:             2186612Ki
  pods:               110
...
Non-terminated Pods:          (3 in total)
  Namespace                   Name                CPU Requests  CPU Limits  \
  Memory Requests  Memory Limits  AGE
  ---------                   ----                ------------  ----------  \
  ---------------  -------------  ---
  default                     rate-limiter        1250m (62%)   0 (0%)      \
  320Mi (14%)      0 (0%)         9m
...</pre>

<p>It’s certainly possible that a Pod cannot be scheduled due to insufficient resources available on the nodes. In those cases, the event log of the Pod will indicate this situation with the reasons <code>PodExceedsFreeCPU</code> or <code>PodExceedsFreeMemory</code>. For more information on how to troubleshoot and resolve this situation, see the relevant <a href="https://oreil.ly/ZzK0B">section in the documentation</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Defining Container Resource Limits"><div class="sect2" id="idm45322720322736">
<h2>Defining Container Resource Limits</h2>

<p><a data-type="indexterm" data-primary="containers" data-secondary="defining limits" id="idm45322720167200"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="defining container resource limits" id="idm45322720166224"/>Another metric you can set for a container are its resource <em>limits</em>. Resource limits ensure that the container cannot consume more than the allotted resource amounts. For example, you could express that the application running in the container should be constrained to 1000m of CPU and 512Mi of memory.</p>

<p>Depending on the container runtime used by the cluster, exceeding any of the allowed resource limits results in a termination of the application process running in the container or results in the system preventing the allocation of resources beyond the limits altogether. For an in-depth discussion on how resource limits are treated by 
<span class="keep-together">the container</span> runtime Docker, see the <a href="https://oreil.ly/szUaM">documentation</a>.</p>

<p class="less_space pagebreak-before"><a data-type="xref" href="#options_resource_limits">Table 4-2</a> describes the available options including an example value.</p>
<table id="options_resource_limits">
<caption><span class="label">Table 4-2. </span>Options for resource limits</caption>
<thead>
<tr>
<th>YAML Attribute</th>
<th>Description</th>
<th>Example Value</th>
</tr>
</thead>
<tbody>
<tr>
<td><p><code>spec.containers[].resources.limits.cpu</code></p></td>
<td><p>CPU resource type</p></td>
<td><p><code>500m</code> (500 millicpu)</p></td>
</tr>
<tr>
<td><p><code>spec.containers[].resources.limits.memory</code></p></td>
<td><p>Memory resource type</p></td>
<td><p><code>64Mi</code> (2^26 bytes)</p></td>
</tr>
<tr>
<td><p><code>spec.containers[].resources.limits.hugepages-&lt;size&gt;</code></p></td>
<td><p>Huge page resource type</p></td>
<td><p><code>hugepages-2Mi: 60Mi</code></p></td>
</tr>
<tr>
<td><p><code>spec.containers[].resources.limits.ephemeral-storage</code></p></td>
<td><p>Ephemeral storage resource type</p></td>
<td><p><code>4Gi</code></p></td>
</tr>
</tbody>
</table>

<p><a data-type="xref" href="#setting_container_resource_limits">Example 4-2</a> shows the definition of limits in action. Here, the container named <code>business-app</code> cannot use more than 512Mi of memory and 2000m of CPU. The container named <code>ambassador</code> defines a limit of 128Mi of memory and 500m of CPU.</p>
<div id="setting_container_resource_limits" data-type="example">
<h5><span class="label">Example 4-2. </span>Setting container resource limits</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rate-limiter</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">business-app</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/nodejs-business-app:1.0.0</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"512Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"2"</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ambassador</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/nodejs-ambassador:1.0.0</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8081</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"128Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"500m"</code><code class="w"/></pre></div>

<p>Assume that the Pod was scheduled on the node <code>minikube-m03</code>. Describing the node’s details reveals that the CPU and memory limits took effect. But there’s more. Kubernetes automatically assigns the same amount of resources for the requests if you only define the limits:</p>

<pre data-type="programlisting"><strong>$ kubectl describe node minikube-m03</strong>
...
Non-terminated Pods:          (3 in total)
  Namespace                   Name                CPU Requests  CPU Limits  \
   Memory Requests  Memory Limits  AGE
  ---------                   ----                ------------  ----------  \
  ---------------  -------------  ---
  default                     rate-limiter        1250m (62%)   1250m (62%) \
  320Mi (14%)      320Mi (14%)    11s
...</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Defining Container Resource Requests and Limits"><div class="sect2" id="idm45322720018528">
<h2>Defining Container Resource Requests and Limits</h2>

<p><a data-type="indexterm" data-primary="containers" data-secondary="defining limits" id="idm45322720017248"/><a data-type="indexterm" data-primary="containers" data-secondary="defining requests" id="idm45322720016272"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="defining container resource limits" id="idm45322720015328"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="defining container resource requests" id="idm45322720014416"/>It’s recommended practice that you specify resource requests and limits for every container. Determining those resource expectations is not always easy, specifically for applications that haven’t been exercised in a production environment yet. Load testing the application early on during the development cycle can help with analyzing the resource needs. Further adjustments can be made by monitoring the application’s resource consumption after deploying it to the cluster. <a data-type="xref" href="#settings_container_resource_requests_limits">Example 4-3</a> combines resource requests and limits in a single YAML manifest.</p>
<div id="settings_container_resource_requests_limits" data-type="example">
<h5><span class="label">Example 4-3. </span>Setting container resource requests and limits</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">rate-limiter</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">business-app</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/nodejs-business-app:1.0.0</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8080</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"256Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"1"</code><code class="w"/>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"512Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"2"</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ambassador</code><code class="w"/>
<code class="w">    </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/nodejs-ambassador:1.0.0</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">8081</code><code class="w"/>
<code class="w">    </code><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">requests</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"64Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"250m"</code><code class="w"/>
<code class="w">      </code><code class="nt">limits</code><code class="p">:</code><code class="w"/>
<code class="w">        </code><code class="nt">memory</code><code class="p">:</code><code class="w"> </code><code class="s">"128Mi"</code><code class="w"/>
<code class="w">        </code><code class="nt">cpu</code><code class="p">:</code><code class="w"> </code><code class="s">"500m"</code><code class="w"/></pre></div>

<p><a data-type="indexterm" data-primary="" data-startref="pod_rl" id="idm45322719757584"/><a data-type="indexterm" data-primary="" data-startref="rl_pod" id="idm45322719756736"/><a data-type="indexterm" data-primary="" data-startref="st_pod" id="idm45322719755856"/>As a result, you can see the different settings for resource requests and limits:</p>

<pre data-type="programlisting"><strong>$ kubectl describe node minikube-m03</strong>
...
Non-terminated Pods:          (3 in total)
  Namespace                   Name                CPU Requests  CPU Limits   \
   Memory Requests  Memory Limits  AGE
  ---------                   ----                ------------  ----------   \
  ---------------  -------------  ---
  default                     rate-limiter        1250m (62%)   2500m (125%) \
  320Mi (14%)      640Mi (29%)    3s
...</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Managing Objects"><div class="sect1" id="idm45322719788400">
<h1>Managing Objects</h1>

<p><a data-type="indexterm" data-primary="objects" data-secondary="managing" id="ob_man"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="managing objects" id="st_ob"/><a data-type="indexterm" data-primary="kubectl command" id="idm45322719784528"/><a data-type="indexterm" data-primary="commands" data-secondary="kubectl" id="idm45322719783856"/>Kubernetes objects can be created, modified, and deleted by using imperative <code>kubectl</code> commands or by running a <code>kubectl</code> command against a configuration file declaring the desired state of an object, a so-called manifest. The primary definition language of a manifest is YAML, though you can opt for JSON, which is the less widely adopted format among the Kubernetes community. It’s recommended that development teams commit and push those configuration files to version control repositories as it will help with tracking and auditing changes over time.</p>

<p>Modeling an application in Kubernetes often requires a set of supporting objects, each of which can have their own manifest. For example, you may want to create a Deployment that runs the application on five Pods, a ConfigMap to inject configuration data as environment variables, and a Service for exposing network access.</p>

<p>This section primarily focuses on the declarative object management support with the help of manifests. For a deeper discussion on the imperative support, see the relevant portions in the <a href="https://oreil.ly/Slw0h">documentation</a>. Furthermore, we’ll touch on tools like Kustomize and Helm to give you an impression of their benefits, capabilities, and workflows.</p>








<section data-type="sect2" data-pdf-bookmark="Declarative Object Management Using Configuration Files"><div class="sect2" id="idm45322719780336">
<h2>Declarative Object Management Using Configuration Files</h2>

<p><a data-type="indexterm" data-primary="configuration files, declarative object management using" id="cf_dom"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="declarative object management using configuration files" id="st_dom"/>Declarative object management requires one or several configuration files in the format of YAML or JSON describing the desired state of an object. You create, update, and delete objects with this approach.</p>










<section data-type="sect3" data-pdf-bookmark="Creating objects"><div class="sect3" id="idm45322719776544">
<h3>Creating objects</h3>

<p><a data-type="indexterm" data-primary="commands" data-secondary="apply" id="idm45322719774704"/><a data-type="indexterm" data-primary="apply command" id="idm45322719773728"/><a data-type="indexterm" data-primary="objects" data-secondary="creating" id="idm45322719773056"/>To create new objects, run the <code>apply</code> command by pointing to a file, a directory of files, or a file referenced by an HTTP(S) URL using the <code>-f</code> option. If one or many of the objects already exist, the command will synchronize the changes made to the configuration with the live object.</p>

<p>To demonstrate the functionality, we’ll assume the following directories and configuration files. The following commands create objects from a single file, from all files within a directory, and from all files in a directory recursively:</p>

<pre data-type="programlisting">.
├── app-stack
│   ├── mysql-pod.yaml
│   ├── mysql-service.yaml
│   ├── web-app-pod.yaml
│   └── web-app-service.yaml
├── nginx-deployment.yaml
└── web-app
    ├── config
    │   ├── db-configmap.yaml
    │   └── db-secret.yaml
    └── web-app-pod.yaml</pre>

<p>Creating an object from a single file:</p>

<pre data-type="programlisting"><strong>$ kubectl apply -f nginx-deployment.yaml</strong>
deployment.apps/nginx-deployment created</pre>

<p>Creating objects from multiple files within a directory:</p>

<pre data-type="programlisting"><strong>$ kubectl apply -f app-stack/</strong>
pod/mysql-db created
service/mysql-service created
pod/web-app created
service/web-app-service created</pre>

<p>Creating objects from a recursive directory tree containing files:</p>

<pre data-type="programlisting"><strong>$ kubectl apply -f web-app/ -R</strong>
configmap/db-config configured
secret/db-creds created
pod/web-app created</pre>

<p>Creating objects from a file referenced by an HTTP(S) URL:</p>

<pre data-type="programlisting"><strong>$ kubectl apply -f https://raw.githubusercontent.com/bmuschko/cka-study-guide/</strong> \
  <strong>master/ch04/object-management/nginx-deployment.yaml</strong>
deployment.apps/nginx-deployment created</pre>

<p>The <code>apply</code> command keeps track of the changes by adding or modifying the annotation with the key <code>kubectl.kubernetes.io/last-applied-configuration</code>. You can find an example of the annotation in the output of the <code>get pod</code> command here:</p>

<pre data-type="programlisting"><strong>$ kubectl get pod web-app -o yaml</strong>
apiVersion: v1
kind: Pod
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"v1","kind":"Pod","metadata":{"annotations":{}, \
      "labels":{"app":"web-app"},"name":"web-app","namespace":"default"}, \
      "spec":{"containers":[{"envFrom":[{"configMapRef":{"name":"db-config"}}, \
      {"secretRef":{"name":"db-creds"}}],"image":"bmuschko/web-app:1.0.1", \
      "name":"web-app","ports":[{"containerPort":3000,"protocol":"TCP"}]}], \
      "restartPolicy":"Always"}}
...</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Updating objects"><div class="sect3" id="idm45322719775952">
<h3>Updating objects</h3>

<p><a data-type="indexterm" data-primary="apply command" id="idm45322719716048"/><a data-type="indexterm" data-primary="commands" data-secondary="apply" id="idm45322719715120"/><a data-type="indexterm" data-primary="objects" data-secondary="updating" id="idm45322719714176"/>Updating an existing object is done with the same <code>apply</code> command. All you need to do is to change the configuration file and then run the command against it. <a data-type="xref" href="#modified_configuration_file_deployment">Example 4-4</a> modifies the existing configuration of a Deployment in the file <code>nginx-deployment.yaml</code>. We added a new label with the key <code>team</code> and changed the number of replicas from 3 to 5.</p>
<div id="modified_configuration_file_deployment" data-type="example">
<h5><span class="label">Example 4-4. </span>Modified configuration file for a Deployment</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-deployment</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">    </code><code class="nt">team</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">red</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">replicas</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">5</code><code class="w"/>
<code class="p">...</code><code class="w"/></pre></div>

<p>The following command applies the changed configuration file. As a result, the number of Pods controlled by the underlying ReplicaSet is 5. The Deployment’s annotation <code>kubectl.kubernetes.io/last-applied-configuration</code> reflects the latest change to the configuration:</p>

<pre data-type="programlisting"><strong>$ kubectl apply -f nginx-deployment.yaml</strong>
deployment.apps/nginx-deployment configured
<strong>$ kubectl get deployments,pods</strong>
NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx-deployment   5/5     5            5           10m

NAME                                    READY   STATUS    RESTARTS   AGE
pod/nginx-deployment-66b6c48dd5-79j6t   1/1     Running   0          35s
pod/nginx-deployment-66b6c48dd5-bkkgb   1/1     Running   0          10m
pod/nginx-deployment-66b6c48dd5-d26c8   1/1     Running   0          10m
pod/nginx-deployment-66b6c48dd5-fcqrs   1/1     Running   0          10m
pod/nginx-deployment-66b6c48dd5-whfnn   1/1     Running   0          35s
<strong>$ kubectl get deployment nginx-deployment -o yaml</strong>
apiVersion: apps/v1
kind: Deployment
metadata:
  annotations:
    kubectl.kubernetes.io/last-applied-configuration: |
      {"apiVersion":"apps/v1","kind":"Deployment","metadata":{"annotations":{}, \
      "labels":{"app":"nginx","team":"red"},"name":"nginx-deployment", \
      "namespace":"default"},"spec":{"replicas":5,"selector":{"matchLabels": \
      {"app":"nginx"}},"template":{"metadata":{"labels":{"app":"nginx"}}, \
      "spec":{"containers":[{"image":"nginx:1.14.2","name":"nginx", \
      "ports":[{"containerPort":80}]}]}}}}
...</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Deleting objects"><div class="sect3" id="idm45322719688160">
<h3>Deleting objects</h3>

<p><a data-type="indexterm" data-primary="" data-startref="cf_dom" id="idm45322719687168"/><a data-type="indexterm" data-primary="" data-startref="st_dom" id="idm45322719686192"/><a data-type="indexterm" data-primary="objects" data-secondary="deleting" id="idm45322719685248"/>While there is a way to delete objects using the <code>apply</code> command by providing the options <code>--prune -l &lt;labels&gt;</code>, it is recommended to delete an object using the <code>delete</code> command and point it to the configuration file. The following command deletes a Deployment and the objects it controls (ReplicaSet and Pods):</p>

<pre data-type="programlisting"><strong>$ kubectl delete -f nginx-deployment.yaml</strong>
deployment.apps "nginx-deployment" deleted
<strong>$ kubectl get deployments,replicasets,pods</strong>
No resources found in default namespace.</pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Declarative Object Management Using Kustomize"><div class="sect2" id="idm45322719680960">
<h2>Declarative Object Management Using Kustomize</h2>

<p><a data-type="indexterm" data-primary="Kustomize, declarative object management using" id="kus_dom"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="declarative object management using Kustomize" id="st_kus"/>Kustomize is a tool introduced with Kubernetes 1.14 that aims to make manifest management more convenient. It supports three different use cases:</p>

<ul>
<li>
<p>Generating manifests from other sources. For example, creating a ConfigMap and populating its key-value pairs from a properties file.</p>
</li>
<li>
<p>Adding common configuration across multiple manifests. For example, adding a namespace and a set of labels for a Deployment and a Service.</p>
</li>
<li>
<p>Composing and customizing a collection of manifests. For example, setting resource boundaries for multiple Deployments.</p>
</li>
</ul>

<p>The central file needed for Kustomize to work is the <em>kustomization file</em>. The standardized name for the file is <code>kustomization.yaml</code> and cannot be changed. A kustomization file defines the processing rules Kustomize works upon.</p>

<p>Kustomize is fully integrated with <code>kubectl</code> and can be executed in two modes: rendering the processing output on the console or creating the objects. Both modes can operate on a directory, tarball, Git archive, or URL as long as they contain the kustomization file and referenced resource files:</p>
<dl>
<dt><a data-type="indexterm" data-primary="kustomize command" id="idm45322719615136"/><a data-type="indexterm" data-primary="commands" data-secondary="kustomize" id="idm45322719614432"/><a data-type="indexterm" data-primary="run command" id="idm45322719613488"/><a data-type="indexterm" data-primary="commands" data-secondary="run" id="idm45322719612816"/>Rendering the produced output</dt>
<dd>
<p>The first mode uses the <code>kustomize</code> subcommand to render the produced result on the console but does not create the objects. This command works similar to the dry-run option you might know from the <code>run</code> command:</p>

<pre data-type="programlisting"><strong>$ kubectl kustomize &lt;target&gt;</strong></pre>
</dd>
<dt><a data-type="indexterm" data-primary="apply command" id="app_ab"/><a data-type="indexterm" data-primary="commands" data-secondary="apply" id="com_app"/>Creating the objects</dt>
<dd>
<p>The second mode uses the <code>apply</code> command in conjunction with the <code>-k</code> command-line option to apply the resources processed by Kustomize, as explained in the previous section:</p>

<pre data-type="programlisting"><strong>$ kubectl apply -k &lt;target&gt;</strong></pre>
</dd>
</dl>

<p>The following sections demonstrate each of the use cases by a single example. For a full coverage on all possible scenarios, refer to the <a href="https://oreil.ly/JUHXj">documentation</a> or the <a href="https://oreil.ly/4MirA">Kustomize GitHub repository</a>.</p>










<section data-type="sect3" data-pdf-bookmark="Composing Manifests"><div class="sect3" id="idm45322719601744">
<h3>Composing Manifests</h3>

<p><a data-type="indexterm" data-primary="manifests" data-secondary="creating" id="man_cr"/>One of the core functionalities of Kustomize is to create a composed manifest from other manifests. Combining multiple manifests into a single one may not seem that useful by itself, but many of the other features described later will build upon this capability. Say you wanted to compose a manifest from a Deployment and a Service resource file. All you need to do is to place the resource files into the same folder as the kustomization file:</p>

<pre data-type="programlisting">.
├── kustomization.yaml
├── web-app-deployment.yaml
└── web-app-service.yaml</pre>

<p>The kustomization file lists the resources in the <code>resources</code> section, as shown in <a data-type="xref" href="#kustomization_file_combining">Example 4-5</a>.</p>
<div id="kustomization_file_combining" data-type="example">
<h5><span class="label">Example 4-5. </span>A kustomization file combining two manifests</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">web-app-deployment.yaml</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">web-app-service.yaml</code><code class="w"/></pre></div>

<p>As a result, the <code>kustomize</code> subcommand renders the combined manifest containing all of the resources separated by three hyphens (<code>---</code>) to denote the different object definitions:</p>

<pre data-type="programlisting"><strong>$ kubectl kustomize ./</strong>
apiVersion: v1
kind: Service
metadata:
  labels:
    app: web-app-service
  name: web-app-service
spec:
  ports:
  - name: web-app-port
    port: 3000
    protocol: TCP
    targetPort: 3000
  selector:
    app: web-app
  type: NodePort
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: web-app-deployment
  name: web-app-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
  template:
    metadata:
      labels:
        app: web-app
    spec:
      containers:
      - env:
        - name: DB_HOST
          value: mysql-service
        - name: DB_USER
          value: root
        - name: DB_PASSWORD
          value: password
        image: bmuschko/web-app:1.0.1
        name: web-app
        ports:
        - containerPort: 3000</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Generating manifests from other sources"><div class="sect3" id="idm45322719585440">
<h3>Generating manifests from other sources</h3>

<p>Earlier in this chapter, we learned that ConfigMaps and Secrets can be created by pointing them to a file containing the actual configuration data for it. Kustomize can help with the process by mapping the relationship between the YAML manifest of those configuration objects and their data. Furthermore, we’ll want to inject the created ConfigMap and Secret in a Pod as environment variables. In this section, you will learn how to achieve this with the help of Kustomize.</p>

<p class="pagebreak-before">The following file and directory structure contains the manifest file for the Pod and the configuration data files we need for the ConfigMap and Secret. The mandatory kustomization file lives on the root level of the directory tree:</p>

<pre data-type="programlisting">.
├── config
│   ├── db-config.properties
│   └── db-secret.properties
├── kustomization.yaml
└── web-app-pod.yaml</pre>

<p>In <code>kustomization.yaml</code>, you can define that the ConfigMap and Secret object should be generated with the given name. The name of the ConfigMap is supposed to be <code>db-config</code>, and the name of the Secret is going to be <code>db-creds</code>. Both of the generator attributes, <code>configMapGenerator</code> and <code>secretGenerator</code>, reference an input file used to feed in the configuration data. Any additional resources can be spelled out with the <code>resources</code> attribute. <a data-type="xref" href="#kustomization_file_configmap_secret">Example 4-6</a> shows the contents of the kustomization file.</p>
<div id="kustomization_file_configmap_secret" data-type="example">
<h5><span class="label">Example 4-6. </span>A kustomization file using a ConfigMap and Secret generator</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">configMapGenerator</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-config</code><code class="w"/>
<code class="w">  </code><code class="nt">files</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">config/db-config.properties</code><code class="w"/>
<code class="nt">secretGenerator</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">db-creds</code><code class="w"/>
<code class="w">  </code><code class="nt">files</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">config/db-secret.properties</code><code class="w"/>
<code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">web-app-pod.yaml</code><code class="w"/></pre></div>

<p>Kustomize generates ConfigMaps and Secrets by appending a suffix to the name. You can see this behavior when creating the objects using the <code>apply</code> command. The ConfigMap and Secret can be referenced by name in the Pod manifest:</p>

<pre data-type="programlisting"><strong>$ kubectl apply -k ./</strong>
configmap/db-config-t4c79h4mtt unchanged
secret/db-creds-4t9dmgtf9h unchanged
pod/web-app created</pre>

<p id="NOTE">This naming strategy can be configured with the attribute <code>generatorOptions</code> in the kustomization file. See the <a href="https://oreil.ly/M7tlD">documentation</a> for more 
<span class="keep-together">information.</span></p>

<p class="pagebreak-before"><a data-type="indexterm" data-primary="" data-startref="man_cr" id="idm45322719528176"/>Let’s also try the <code>kustomize</code> subcommand. Instead of creating the objects, the command renders the processed output on the console:</p>

<pre data-type="programlisting"><strong>$ kubectl kustomize ./</strong>
apiVersion: v1
data:
  db-config.properties: |-
    DB_HOST: mysql-service
    DB_USER: root
kind: ConfigMap
metadata:
  name: db-config-t4c79h4mtt
---
apiVersion: v1
data:
  db-secret.properties: REJfUEFTU1dPUkQ6IGNHRnpjM2R2Y21RPQ==
kind: Secret
metadata:
  name: db-creds-4t9dmgtf9h
type: Opaque
---
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: web-app
  name: web-app
spec:
  containers:
  - envFrom:
    - configMapRef:
        name: db-config-t4c79h4mtt
    - secretRef:
        name: db-creds-4t9dmgtf9h
    image: bmuschko/web-app:1.0.1
    name: web-app
    ports:
    - containerPort: 3000
      protocol: TCP
  restartPolicy: Always</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Adding common configuration across multiple manifests"><div class="sect3" id="idm45322719584816">
<h3>Adding common configuration across multiple manifests</h3>

<p><a data-type="indexterm" data-primary="manifests" data-secondary="adding configuration across multiple" id="idm45322719524192"/>Application developers usually work on an application stack set comprised of multiple manifests. For example, an application stack could consist of a frontend microservice, a backend microservice, and a database. It’s common practice to use the same, cross-cutting configuration for each of the manifests. Kustomize offers a range of supported fields (e.g., namespace, labels, or annotations). Refer to the <a href="https://oreil.ly/OyNbh">documentation</a> to learn about all supported fields.</p>

<p>For the next example, we’ll assume that a Deployment and a Service live in the same namespace and use a common set of labels. The namespace is called <code>persistence</code> and the label is the key-value pair <code>team: helix</code>. <a data-type="xref" href="#kustomization_file_common_fields">Example 4-7</a> illustrates how to set those common fields in the kustomization file.</p>
<div id="kustomization_file_common_fields" data-type="example">
<h5><span class="label">Example 4-7. </span>A kustomization file using a common field</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">persistence</code><code class="w"/>
<code class="nt">commonLabels</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">team</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">helix</code><code class="w"/>
<code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">web-app-deployment.yaml</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">web-app-service.yaml</code><code class="w"/></pre></div>

<p>To create the referenced objects in the kustomization file, run the <code>apply</code> command. Make sure to create the <code>persistence</code> namespace beforehand:</p>

<pre data-type="programlisting"><strong>$ kubectl create namespace persistence</strong>
namespace/persistence created
<strong>$ kubectl apply -k ./</strong>
service/web-app-service created
deployment.apps/web-app-deployment created</pre>

<p><a data-type="indexterm" data-primary="" data-startref="app_ab" id="idm45322719446416"/><a data-type="indexterm" data-primary="" data-startref="com_app" id="idm45322719445440"/>The YAML representation of the processed files looks as follows:</p>

<pre data-type="programlisting"><strong>$ kubectl kustomize ./</strong>
apiVersion: v1
kind: Service
metadata:
  labels:
    app: web-app-service
    team: helix
  name: web-app-service
  namespace: persistence
spec:
  ports:
  - name: web-app-port
    port: 3000
    protocol: TCP
    targetPort: 3000
  selector:
    app: web-app
    team: helix
  type: NodePort
---
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: web-app-deployment
    team: helix
  name: web-app-deployment
  namespace: persistence
spec:
  replicas: 3
  selector:
    matchLabels:
      app: web-app
      team: helix
  template:
    metadata:
      labels:
        app: web-app
        team: helix
    spec:
      containers:
      - env:
        - name: DB_HOST
          value: mysql-service
        - name: DB_USER
          value: root
        - name: DB_PASSWORD
          value: password
        image: bmuschko/web-app:1.0.1
        name: web-app
        ports:
        - containerPort: 3000</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Customizing a collection of manifests"><div class="sect3" id="idm45322719442128">
<h3>Customizing a collection of manifests</h3>

<p><a data-type="indexterm" data-primary="manifests" data-secondary="customizing collections of" id="idm45322719440720"/>Kustomize can merge the contents of a YAML manifest with a code snippet from another YAML manifest. Typical use cases include adding security context configuration to a Pod definition or setting resource boundaries for a Deployment. The kustomization file allows for specifying different patch strategies like 
<span class="keep-together"><code>patchesStrategicMerge</code></span> and <code>patchesJson6902</code>. For a deeper discussion on the differences between patch strategies, refer to the documentation.</p>

<p><a data-type="xref" href="#kustomization_file_patch">Example 4-8</a> shows the contents of a kustomization file that patches a Deployment definition in the file <code>nginx-deployment.yaml</code> with the contents of the file <code>security-context.yaml</code>.</p>
<div id="kustomization_file_patch" data-type="example">
<h5><span class="label">Example 4-8. </span>A kustomization file defining a patch</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">resources</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-deployment.yaml</code><code class="w"/>
<code class="nt">patchesStrategicMerge</code><code class="p">:</code><code class="w"/>
<code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">security-context.yaml</code><code class="w"/></pre></div>

<p>The patch file shown in <a data-type="xref" href="#path_yaml_manifest">Example 4-9</a> defines a security context on the container-level for the Pod template of the Deployment. At runtime, the patch strategy tries to find the container named <code>nginx</code> and enhances the additional configuration.</p>
<div id="path_yaml_manifest" data-type="example">
<h5><span class="label">Example 4-9. </span>The patch YAML manifest</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">apps/v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Deployment</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx-deployment</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">template</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">nginx</code><code class="w"/>
<code class="w">        </code><code class="nt">securityContext</code><code class="p">:</code><code class="w"/>
<code class="w">          </code><code class="nt">runAsUser</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1000</code><code class="w"/>
<code class="w">          </code><code class="nt">runAsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3000</code><code class="w"/>
<code class="w">          </code><code class="nt">fsGroup</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2000</code><code class="w"/></pre></div>

<p><a data-type="indexterm" data-primary="" data-startref="ob_man" id="idm45322719342784"/><a data-type="indexterm" data-primary="" data-startref="st_ob" id="idm45322719319568"/><a data-type="indexterm" data-primary="" data-startref="kus_dom" id="idm45322719318688"/><a data-type="indexterm" data-primary="" data-startref="st_kus" id="idm45322719317744"/>The result is a patched Deployment definition, as shown in the output of the 
<span class="keep-together"><code>kustomize</code></span> subcommand shown next. The patch mechanism can be applied to other files that require a uniform security context definition:</p>

<pre data-type="programlisting"><strong>$ kubectl kustomize ./</strong>
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: nginx
  name: nginx-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - image: nginx:1.14.2
        name: nginx
        ports:
        - containerPort: 80
        securityContext:
          fsGroup: 2000
          runAsGroup: 3000
          runAsUser: 1000</pre>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Common Templating Tools"><div class="sect1" id="idm45322719680368">
<h1>Common Templating Tools</h1>

<p><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="common templating tools" id="st_ctt"/>As demonstrated in the previous section, Kustomize offers templating functionality. The Kubernetes ecosystem offers other solutions to the problem that we will discuss here. We will touch on the YAML processor <code>yq</code> and the templating engine Helm.</p>








<section data-type="sect2" data-pdf-bookmark="Using the YAML Processor yq"><div class="sect2" id="idm45322719311728">
<h2>Using the YAML Processor yq</h2>

<p><a data-type="indexterm" data-primary="YAML" data-secondary="yq tool" id="idm45322719310320"/><a data-type="indexterm" data-primary="yq tool" id="idm45322719309344"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="using YAML processor yq" id="idm45322719308672"/>The tool <code>yq</code> is used to read, modify, and enhance the contents of a YAML file. This section will demonstrate all three use cases. For a detailed list of usage example, see the <a href="https://oreil.ly/ORZDV">GitHub repository</a>. During the CKA exam, you may be asked to apply those techniques though you are not expected to understand all intricacies of the tools at hand. The version of <code>yq</code> used to describe the functionality below is 4.2.1.</p>










<section data-type="sect3" data-pdf-bookmark="Reading values"><div class="sect3" id="idm45322719256336">
<h3>Reading values</h3>

<p><a data-type="indexterm" data-primary="values, modifying/reading" id="idm45322719255088"/>Reading values from an existing YAML file requires the use of a YAML path expression. A path expression allows you to deeply navigate the YAML structure and extract the value of an attribute you are searching for. <a data-type="xref" href="#yaml_manifest_pod">Example 4-10</a> shows the YAML manifest of a Pod that defines two environment variables.</p>
<div id="yaml_manifest_pod" data-type="example">
<h5><span class="label">Example 4-10. </span>The YAML manifest of a Pod</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">spring-boot-app</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/spring-boot-app:1.5.3</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">spring-boot-app</code><code class="w"/>
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">SPRING_PROFILES_ACTIVE</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">prod</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">VERSION</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="s">'1.5.3'</code><code class="w"/></pre></div>

<p><a data-type="indexterm" data-primary="commands" data-secondary="eval" id="idm45322719189760"/><a data-type="indexterm" data-primary="eval command" id="idm45322719188912"/>To read a value, use the command <code>eval</code> or the short form <code>e</code>, provide the YAML path expression, and point it to the source file. The following two commands read the Pod’s name and the value of the second environment variable defined by a single container. Notice that the path expression needs to start with a mandatory dot character (<code>.</code>) to denote the root node of the YAML structure:</p>

<pre data-type="programlisting" class="pagebreak-before"><strong>$ yq e <em>.metadata.name</em> pod.yaml</strong>
spring-boot-app
<strong>$ yq e <em>.spec.containers[0].env[1].value</em> pod.yaml</strong>
1.5.3</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Modifying values"><div class="sect3" id="idm45322719205264">
<h3>Modifying values</h3>

<p>Modifying an existing value is as easy as using the same command and adding the <code>-i</code> flag. The assignment of the new value to an attribute happens by assigning it to the path expression. The following command changes the second environment variable of the Pod YAML file to the value 1.6.0:</p>

<pre data-type="programlisting"><strong>$ yq e -i <em>.spec.containers[0].env[1].value = "1.6.0"</em> pod.yaml</strong>
<strong>$ cat pod.yaml</strong>
...
    env:
    - name: SPRING_PROFILES_ACTIVE
      value: prod
    - name: VERSION
      value: <em>1.6.0</em></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Merging YAML files"><div class="sect3" id="idm45322719201024">
<h3>Merging YAML files</h3>

<p><a data-type="indexterm" data-primary="YAML" data-secondary="merging files" id="idm45322719136016"/>Similar to Kustomize, <code>yq</code> can merge multiple YAML files. Kustomize is definitely more powerful and convenient to use; however, <code>yq</code> can come in handy for smaller projects. Say you wanted to merge the sidecar container definition shown in <a data-type="xref" href="#yaml_manifest_container">Example 4-11</a> into the Pod YAML file.</p>
<div id="yaml_manifest_container" data-type="example">
<h5><span class="label">Example 4-11. </span>The YAML manifest of a container definition</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">envoyproxy/envoy:v1.19.1</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">proxy-container</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">80</code><code class="w"/></pre></div>

<p><a data-type="indexterm" data-primary="eval-all command" id="idm45322719109072"/><a data-type="indexterm" data-primary="commands" data-secondary="eval-all" id="idm45322719105824"/>The command to achieve this is <code>eval-all</code>. We won’t go into details given the multitude of configuration options for this command. For a deep dive, check the <code>yq</code> user manual on the <a href="https://oreil.ly/2I6ir">“Multiply (Merge)” operation</a>. The following command appends the sidecar container to the existing container array of the Pod manifest:</p>
<pre data-type="programlisting">
<strong>$ yq eval-all 'select(fileIndex == 0) *+ select(fileIndex == 1)' pod.yaml</strong> \
  <strong>sidecar.yaml</strong>
apiVersion: v1
kind: Pod
metadata:
  name: spring-boot-app
spec:
  containers:
  - image: bmuschko/spring-boot-app:1.5.3
    name: spring-boot-app
    env:
    - name: SPRING_PROFILES_ACTIVE
      value: prod
    - name: VERSION
      value: '1.5.3'
  - image: envoyproxy/envoy:v1.19.1
    name: proxy-container
    ports:
    - containerPort: 80
</pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Using Helm"><div class="sect2" id="idm45322719101424">
<h2>Using Helm</h2>

<p><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="using Helm" id="st_helm"/><a data-type="indexterm" data-primary="Helm" data-secondary="about" id="idm45322719098736"/><a href="https://helm.sh">Helm</a> is a templating engine and package manager for a set of Kubernetes manifests. At runtime, it replaces placeholders in YAML template files with actual, end-user defined values. The artifact produced by the Helm executable is a so-called <em>chart file</em> bundling the manifests that comprise the API resources of an application. This chart file can be uploaded to a package manager to be used during the deployment process. The Helm ecosystem offers a wide range of reusable charts for common use cases on a <a href="https://oreil.ly/1OLIi">central chart repository</a> (e.g., for running Grafana or PostgreSQL).</p>

<p>Due to the wealth of functionality available to Helm, we’ll discuss only the very basics. The CKA exam does not expect you be a Helm expert; rather, it wants to be familiar with the benefits and concepts. For more detailed information on Helm, see the <a href="https://helm.sh/docs">user documentation</a>. The version of Helm used to describe the functionality here is 3.7.0.</p>










<section data-type="sect3" data-pdf-bookmark="Standard Chart Structure"><div class="sect3" id="idm45322719094576">
<h3>Standard Chart Structure</h3>

<p><a data-type="indexterm" data-primary="Helm" data-secondary="standard chart structure" id="idm45322719093408"/>A chart needs to follow a predefined directory structure. You can choose any name for the root directory. Within the directory, two files need to exist: <code>Chart.yaml</code> and <code>values.yaml</code>. The file <code>Chart.yaml</code> describes the meta information of the chart (e.g., name and version). The file <code>values.yaml</code> contains the key-value pairs used at runtime to replace the placeholders in the YAML manifests. Any template file meant to be packaged into the chart archive file needs to be put in the <code>templates</code> directory. Files located in the <code>template</code> directory do not have to follow any naming conventions.</p>

<p class="pagebreak-before">The following directory structure shows an example chart. The <code>templates</code> directory contains a file for a Pod and a Service:</p>

<pre data-type="programlisting"><strong>$ tree</strong>
.
├── Chart.yaml
├── templates
│   ├── web-app-pod-template.yaml
│   └── web-app-service-template.yaml
└── values.yaml</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="The chart file"><div class="sect3" id="idm45322719053504">
<h3>The chart file</h3>

<p><a data-type="indexterm" data-primary="Helm" data-secondary="chart file" id="idm45322719052496"/><a data-type="indexterm" data-primary="chart file (Helm)" id="idm45322719051616"/>The file <code>Chart.yaml</code> describes the chart on a high level. Mandatory attributes include the chart’s API version, the name, and the version. Additionally, optional attributes can be provided. For a full list of attributes, see the relevant <a href="https://oreil.ly/VUrm1">documentation</a>. <a data-type="xref" href="#basic_helm_chart_file">Example 4-12</a> shows the bare minimum of a chart file.</p>
<div id="basic_helm_chart_file" data-type="example">
<h5><span class="label">Example 4-12. </span>A basic Helm chart file</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">1.0.0</code><code class="w"/>
<code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">web-app</code><code class="w"/>
<code class="nt">version</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">2.5.4</code><code class="w"/></pre></div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="The values file"><div class="sect3" id="idm45322719044416">
<h3>The values file</h3>

<p><a data-type="indexterm" data-primary="Helm" data-secondary="values file" id="idm45322719043408"/><a data-type="indexterm" data-primary="values file (Helm)" id="idm45322719042464"/>The file <code>values.yaml</code> defines key-value pairs to be used to replace placeholders in the YAML template files. <a data-type="xref" href="#helm_values_file">Example 4-13</a> specifies four key-value pairs. Be aware that the file can be empty if you don’t want to replace values at runtime.</p>
<div id="helm_values_file" data-type="example">
<h5><span class="label">Example 4-13. </span>A Helm values file</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">db_host</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mysql-service</code><code class="w"/>
<code class="nt">db_user</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">root</code><code class="w"/>
<code class="nt">db_password</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">password</code><code class="w"/>
<code class="nt">service_port</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3000</code><code class="w"/></pre></div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="The template files"><div class="sect3" id="idm45322719026224">
<h3>The template files</h3>

<p><a data-type="indexterm" data-primary="Helm" data-secondary="template files" id="idm45322718981840"/><a data-type="indexterm" data-primary="template files (Helm)" id="idm45322718980672"/>Template files need to live in the <code>templates</code> directory. A template file is a regular YAML manifest that can (optionally) define placeholders with the help of double curly braces (<code>{{ }}</code>). To reference a value from the <code>values.yaml</code> file, use the expression <code>{{ .Values.&lt;key&gt; }}</code>. For example, to replace the value of the key <code>db_host</code> at runtime, use the expression <code>{{ .Values.db_host }}</code>. <a data-type="xref" href="#yaml_template_manifest_pod">Example 4-14</a> defines a Pod as a template while defining three placeholders that reference values from <code>values.yaml</code>.</p>
<div id="yaml_template_manifest_pod" data-type="example">
<h5><span class="label">Example 4-14. </span>The YAML template manifest of a Pod</h5>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Pod</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">labels</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="nt">app</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">web-app</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">web-app</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bmuschko/web-app:1.0.1</code><code class="w"/>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">web-app</code><code class="w"/>
<code class="w">    </code><code class="nt">env</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DB_HOST</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.db_host</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DB_USER</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.db_user</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">DB_PASSWORD</code><code class="w"/>
<code class="w">      </code><code class="nt">value</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">{{</code><code class="w"> </code><code class="nv">.Values.db_password</code><code class="w"> </code><code class="p-Indicator">}}</code><code class="w"/>
<code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">3000</code><code class="w"/>
<code class="w">      </code><code class="nt">protocol</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">TCP</code><code class="w"/>
<code class="w">  </code><code class="nt">restartPolicy</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Always</code><code class="w"/></pre></div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Executing Helm commands"><div class="sect3" id="idm45322718889136">
<h3>Executing Helm commands</h3>

<p><a data-type="indexterm" data-primary="Helm" data-secondary="executing commands" id="idm45322718794384"/><a data-type="indexterm" data-primary="template command" id="idm45322718793440"/><a data-type="indexterm" data-primary="commands" data-secondary="template" id="idm45322718792768"/>The Helm executable comes with a wide range of commands. Let’s demonstrate some of them. The <code>template</code> command renders the chart templates locally and displays results on the console. You can see the operation in action in the following output. All placeholders have been replaced by their actual values sourced from the <code>values.yaml</code> file:</p>

<pre data-type="programlisting"><strong>$ helm template .</strong>
---
# Source: Web Application/templates/web-app-service-template.yaml
...
---
# Source: Web Application/templates/web-app-pod-template.yaml
apiVersion: v1
kind: Pod
metadata:
  labels:
    app: web-app
  name: web-app
spec:
  containers:
  - image: bmuschko/web-app:1.0.1
    name: web-app
    env:
    - name: DB_HOST
      value: mysql-service
    - name: DB_USER
      value: root
    - name: DB_PASSWORD
      value: password
    ports:
    - containerPort: 3000
      protocol: TCP
  restartPolicy: Always</pre>

<p>Once you are happy with the result, you’ll want to bundle the template files into a chart archive file. The chart archive file is a compressed TAR file with the file ending <code>.tgz</code>. The <code>package</code> command evaluates the metadata information from <code>Chart.yaml</code> to derive the chart archive filename:</p>

<pre data-type="programlisting"><strong>$ helm package .</strong>
Successfully packaged chart and saved it to: /Users/bmuschko/dev/projects/ \
cka-study-guide/ch04/templating-tools/helm/web-app-2.5.4.tgz</pre>

<p><a data-type="indexterm" data-primary="" data-startref="st_ctt" id="idm45322718786464"/><a data-type="indexterm" data-primary="" data-startref="st_helm" id="idm45322718785488"/>For a full list of commands and typical workflows, refer to the Helm <a href="https://oreil.ly/Jz6eD">documentation page</a>.</p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45322718783504">
<h1>Summary</h1>

<p><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="about" id="idm45322718782384"/>Resource boundaries are one of the many factors that the kube-scheduler algorithm considers when making decisions on which node a Pod can be scheduled. A container can specify resource requests and limits. The scheduler chooses a node based on its available hardware capacity.</p>

<p>Declarative manifest management is the preferred way of creating, modifying, and deleting objects in real-world, cloud-native projects. The underlying YAML manifest is meant to be checked into version control and automatically tracks the changes made to a object including its timestamp for a corresponding commit hash. The <code>kubectl apply</code> and <code>delete</code> command can perform those operations for one or many YAML manifests.</p>

<p>Additional tools emerged for more convenient manifest management. Kustomize is fully integrated with the <code>kubectl</code> tool chain. It helps with the generation, composition, and customization of manifests.  Tools with templating capabilities like <code>yq</code> and Helm can further ease various workflows for managing application stacks represented by a set of manifests.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Exam Essentials"><div class="sect1" id="idm45322718778272">
<h1>Exam Essentials</h1>
<dl>
<dt><a data-type="indexterm" data-primary="exam essentials" data-secondary="scheduling and tooling" id="idm45322718776528"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="exam essentials" id="idm45322718775552"/>Understand the effects of resource boundaries on scheduling</dt>
<dd>
<p>A container defined by a Pod can specify resource requests and limits. Work through scenarios where you define those boundaries individually and together for single- and multi-container Pods. Upon creation of the Pod, you should be able to see the effects on scheduling the object on a node. Furthermore, practice how to identify the available resource capacity of a node.</p>
</dd>
<dt>Manage objects using the imperative and declarative approach</dt>
<dd>
<p>YAML manifests are essential for expressing the desired state of an object. You will need to understand how to create, update, and delete objects using the <code>kubectl apply</code> command. The command can point to a single manifest file or a directory containing multiple manifest files.</p>
</dd>
<dt>Have a high-level understanding of common templating tools</dt>
<dd>
<p>Kustomize, <code>yg</code>, and Helm are established tools for managing YAML manifests. Their templating functionality supports complex scenarios like composing and merging multiple manifests. For the exam, take a practical look at the tools, their functionality, and the problems they solve.</p>
</dd>
</dl>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Sample Exercises"><div class="sect1" id="idm45322718749360">
<h1>Sample Exercises</h1>

<p><a data-type="indexterm" data-primary="sample exercises" data-secondary="scheduling and tooling" id="idm45322718748352"/><a data-type="indexterm" data-primary="scheduling and tooling" data-secondary="sample exercises" id="idm45322718747408"/><a data-type="indexterm" data-primary="" data-startref="st_ch" id="idm45322718746464"/>Solutions to these exercises are available in the <a data-type="xref" href="app01.xhtml#appendix-a">Appendix</a>.</p>
<ol>
<li>
<p>Write a manifest for a new Pod named <code>ingress-controller</code> with a single container that uses the image <code>bitnami/nginx-ingress-controller:1.0.0</code>. For the container, set the resource request to 256Mi for memory and 1 CPU. Set the resource limits to 1024Mi for memory and 2.5 CPU.</p>
</li>
<li>
<p>Using the manifest, schedule the Pod on a cluster with three nodes. Once created, identify the node that runs the Pod. Write the node name to the file <code>node.txt</code>.</p>
</li>
<li>
<p>Create the directory named <code>manifests</code>. Within the directory, create two files: <code>pod.yaml</code> and <code>configmap.yaml</code>. The <code>pod.yaml</code> file should define a Pod named <code>nginx</code> with the image <code>nginx:1.21.1</code>. The <code>configmap.yaml</code> file defines a ConfigMap named <code>logs-config</code> with the key-value pair <code>dir=/etc/logs/traffic.log</code>. Create both objects with a single, declarative command.</p>
</li>
<li>
<p>Modify the ConfigMap manifest by changing the value of the key <code>dir</code> to <code>/etc/logs/traffic-log.txt</code>. Apply the changes. Delete both objects with a single declarative command.</p>
</li>
<li>
<p>Use Kustomize to set a common namespace <code>t012</code> for the resource file <code>pod.yaml</code>. The file <code>pod.yaml</code> defines the Pod named <code>nginx</code> with the image <code>nginx:1.21.1</code> without a namespace. Run the Kustomize command that renders the transformed manifest on the console.</p>
</li>

</ol>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45322718730848">
<h5>Interactive Exam Practice</h5>
<p>Get more hands-on training and test your CKA exam readiness by working through our interactive CKA labs. Each step of the lab must be completed correctly before you can move to the next step. If you get stuck, you can view the solution and learn how to complete the step.</p>

<p>The following labs cover material from this chapter:</p>

<ul>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095620">Defining Resource Requirements for a Pod</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095637">Creating Objects in Declarative Batch Command</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095644">Transforming a Pod to Use a Namespace using Kustomize</a></p>
</li>
<li>
<p><a href="https://learning.oreilly.com/scenarios/-/9781492095651">Building a Helm Chart</a></p>
</li>
</ul>
</div></aside>
</div></section>







</div></section></div></body></html>