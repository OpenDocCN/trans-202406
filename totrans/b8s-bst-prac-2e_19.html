<html><head></head><body><section data-pdf-bookmark="Chapter 19. Security" data-type="chapter" epub:type="chapter"><div class="chapter" id="security">&#13;
<h1><span class="label">Chapter 19. </span>Security</h1>&#13;
&#13;
&#13;
<p>Kubernetes is a powerful platform for orchestrating cloud native applications. However, under the veneer and polish of the APIs and tooling we know and love lies a large, complex distributed system that requires specific knowledge to secure. Securing Kubernetes is a complex topic that honestly requires its own book; however, there’s so much at stake if you overlook taking the time to understand and implement security best practices that we cover it in brief here. The risk of not securing your Kubernetes clusters and workloads properly is the possibility of exposing your data and resources to hackers, malware, and unauthorized access. We would be remiss not to cover some of the main security areas and provide best practices to help along the way.</p>&#13;
&#13;
<p>Given the <a data-primary="security" data-secondary="strategies for" data-type="indexterm" id="id1086"/>complexity of Kubernetes, we recommend breaking the problem down into logical layers where you can focus on specific tooling at each layer. A great way to handle security is to follow the “defense in depth” strategy. This requires the use of multiple security measures at each layer to protect Kubernetes and your workloads. Additionally, keep the principle of least privilege in mind, which states that users and workloads should have access only to what they absolutely need to perform their functions. This all sounds great in theory, but what does it look like in practice? This chapter lays out an approach to bucketing security concerns into layers that will help you focus on the solutions and tooling available as well as cluster security, container security, and code security.</p>&#13;
&#13;
<p>Many security best practices have been covered in detail in other chapters, including Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch04.html#configuration_secrets_and_rbac">4</a> through <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch11.html#policy_and_governance_for_your_cluster">11</a>. We encourage you to review those chapters as we won’t cover those specific topics in the same level of detail again here but rather focus on areas we haven’t covered. In particular, this chapter will focus on layers; digging deeper into them, covering security areas, and providing best practices for each layer.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cluster Security" data-type="sect1"><div class="sect1" id="id253">&#13;
<h1>Cluster Security</h1>&#13;
&#13;
<p>Given that <a data-primary="clusters" data-secondary="security" data-type="indexterm" id="cluster-security"/><a data-primary="security" data-secondary="clusters" data-type="indexterm" id="security-cluster"/>the Kubernetes control plane is exposed via a set of APIs, the first&#13;
step in securing the cluster is to regulate and restrict who can access the cluster and&#13;
what actions they can perform. Next, we will cover the different parts of the Kubernetes&#13;
control plane and how to secure them.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="etcd Access" data-type="sect2"><div class="sect2" id="id153">&#13;
<h2>etcd Access</h2>&#13;
&#13;
<p>The default <a data-primary="etcd access" data-type="indexterm" id="id1087"/>storage system for Kubernetes is etcd. You must ensure that only the&#13;
Kubernetes API server has access to etcd by using strong credentials that aren’t shared. You&#13;
must also make sure that only the API servers have network access to etcd by using&#13;
network firewalls. Having direct access to etcd bypasses all the subsequent&#13;
security measures you have in place, so this is an incredibly important layer to secure.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authentication" data-type="sect2"><div class="sect2" id="id254">&#13;
<h2>Authentication</h2>&#13;
&#13;
<p>Kubernetes <a data-primary="authentication" data-secondary="cluster security" data-type="indexterm" id="id1088"/>provides several different authentication methods, from bearer tokens&#13;
and certificates to OpenID Connect (OIDC) and Lightweight Directory Access Protocol (LDAP) integrations. It’s important to choose the right&#13;
authentication model that suits the needs of your business. Security&#13;
challenges usually appear in the creation, distribution, and storage of Kubeconfig&#13;
files that users require to authenticate to Kubernetes using tools like <code>kubectl</code>.&#13;
Using authentication providers allows the retrieval of temporary dynamic tokens&#13;
rather that using static tokens or certificates that can be easily retrieved by a&#13;
malicious actor. Papers have been written about instances of malicious code&#13;
stored in Kubeconfig files, so it’s important to control their creation and distribution.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authorization" data-type="sect2"><div class="sect2" id="id255">&#13;
<h2>Authorization</h2>&#13;
&#13;
<p>We <a data-primary="authorization" data-secondary="cluster security" data-type="indexterm" id="id1089"/>covered authorization in <a data-type="xref" href="ch17.html#admission_control_and_authorization">Chapter 17</a>; however, in the context of&#13;
Kubernetes security it’s a powerful tool to enforce who can perform what actions&#13;
on what resources. The primary tool at your disposal is role-based access control&#13;
(RBAC). Thankfully,&#13;
Kubernetes ships with sane defaults; however, you will want to consider&#13;
incorporating attributes such as team membership as well as namespaces as a way of&#13;
scaling the number of RBAC resources that need to be created to support a growing&#13;
number of workloads and users. It’s also very important to lock down service&#13;
accounts using RBAC to confirm that workloads that need access to the Kubernetes&#13;
API can access only the minimum actions required to perform their function.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="TLS" data-type="sect2"><div class="sect2" id="id154">&#13;
<h2>TLS</h2>&#13;
&#13;
<p>By default, <a data-primary="TLS security" data-type="indexterm" id="id1090"/>Kubernetes ships with TLS-secured API endpoints enabled. However, different tools and platforms may enable HTTP plaintext communications,&#13;
which opens up an attack vector as the traffic will be unsecure. It’s important to&#13;
safely store and control access to any certificates and keys in use by Kubernetes&#13;
and create a plan to rotate them if they are lost or compromised. Having short lifetimes&#13;
on certificates helps decrease the security risk.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Kubelet and Cloud Metadata Access" data-type="sect2"><div class="sect2" id="id155">&#13;
<h2>Kubelet and Cloud Metadata Access</h2>&#13;
&#13;
<p>Kubelets are <a data-primary="Kubelet" data-type="indexterm" id="id1091"/><a data-primary="cloud metadata access" data-type="indexterm" id="id1092"/>the component that run on each node and are responsible for managing&#13;
the node and the pods that run on it. Unfortunately, Kubelet ships with&#13;
unauthenticated API enabled. The Kubelet API is extremely powerful and&#13;
hence should have authentication and authorization enabled. It is likely that your&#13;
Kubernetes provider has taken care of this for you; however, you should double check&#13;
if rolling your own Kubernetes cluster. In addition to the Kubelet API, if running&#13;
on a cloud provider it’s likely that the node has access to a cloud metadata API&#13;
that could be used to expose Kubernetes provisioning credentials. It’s&#13;
recommended that you lock down access to the metadata endpoint using network&#13;
policies.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Secrets" data-type="sect2"><div class="sect2" id="id256">&#13;
<h2>Secrets</h2>&#13;
&#13;
<p>It’s no <a data-primary="secrets management" data-secondary="cluster security" data-type="indexterm" id="id1093"/>secret that Kubernetes secrets are not encrypted by default. This means that malicious actors may be able to read these secrets at rest from other vectors. Thankfully, there are several different solutions to help with this. The Kubernetes API server provides the ability to configure an encryption provider&#13;
that is used in partnership with a configuration file to encrypt specific Kubernetes resources prior to storage in etcd. Encryption providers are typically cloud secret storage services. The only challenge with the current encryption provider implementation is that there is no way to encrypt everything, and the configuration is cumbersome and error prone. Another solution that the&#13;
Kubernetes community has built is <a href="https://oreil.ly/cbiYT">csi secret store</a>, which enables secrets to be mounted&#13;
directly into pods via a temporary RAMDISK filesystem. Using&#13;
<code>csi-secret-store</code> enables you to bypass the need to use Kubernetes secrets and&#13;
instead directly access them from another trusted secret store.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Logging and Auditing" data-type="sect2"><div class="sect2" id="id156">&#13;
<h2>Logging and Auditing</h2>&#13;
&#13;
<p>Kubernetes <a data-primary="logging" data-type="indexterm" id="id1094"/><a data-primary="audit logs" data-type="indexterm" id="id1095"/>ships with rich logging configured out of the box. In addition, it’s&#13;
important to also enable audit logging on the API server, which will enable a&#13;
chronological log of all security-specific events and is configurable via an&#13;
audit policy. Enabling auditing is only part of the solution; you also must make&#13;
sure that the audit logs are shipped to a point of aggregation and configure&#13;
triggers that, if detected, fire an alert to the security team that a suspicious&#13;
event has occurred.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cluster Security Posture Tooling" data-type="sect2"><div class="sect2" id="id388">&#13;
<h2>Cluster Security Posture Tooling</h2>&#13;
&#13;
<p>Getting Kubernetes security implemented can be challenging. The great news is that there&#13;
are open source tools that can scan your Kubernetes clusters, detect security risks,&#13;
and flag common misconfigurations. Additionally, they can scan all the resources on a cluster&#13;
and provide best practices. Tools like <a href="https://oreil.ly/qPoHQ">Kubescape</a>&#13;
are quick to run and provide outputs based on severity. It’s recommended that you&#13;
run these tools periodically on all clusters to determine the security posture of your&#13;
cluster and the resources deployed to it.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cluster Security Best Practices" data-type="sect1"><div class="sect1" id="id257">&#13;
<h1>Cluster Security Best Practices</h1>&#13;
&#13;
<p>Now that <a data-primary="best practices" data-secondary="cluster security" data-type="indexterm" id="id1096"/>we’ve covered the biggest security areas at the cluster layer, here is&#13;
a handy list of security best practices for you to check off:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Lock down etcd access and store access credentials and certificates in secure&#13;
locations.</p>&#13;
</li>&#13;
<li>&#13;
<p>Disable insecure and unauthenticated API endpoints.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use authentication providers that provide temporary dynamic tokens rather than&#13;
static configured tokens in Kubeconfig.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ensure users and services follow least privilege.</p>&#13;
</li>&#13;
<li>&#13;
<p>Rotate infrastructure credentials regularly.</p>&#13;
</li>&#13;
<li>&#13;
<p>Encrypt sensitive data at rest and in transit using keys and certificates.</p>&#13;
</li>&#13;
<li>&#13;
<p>Scan container images for vulnerabilities and malware before deploying&#13;
them to the cluster.</p>&#13;
</li>&#13;
<li>&#13;
<p>Enable audit logging and monitoring to detect and respond to suspicious&#13;
&#13;
<span class="keep-together">activities.</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Use security scanning tools such as Kubescape to baseline the security posture&#13;
of your Kubernetes cluster and <a data-primary="clusters" data-secondary="security" data-startref="cluster-security" data-type="indexterm" id="id1097"/><a data-primary="security" data-secondary="clusters" data-startref="security-cluster" data-type="indexterm" id="id1098"/>workloads.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Workload Container Security" data-type="sect1"><div class="sect1" id="id157">&#13;
<h1>Workload Container Security</h1>&#13;
&#13;
<p>Now that <a data-primary="security" data-secondary="workload containers" data-type="indexterm" id="security-workload-containers"/><a data-primary="workload security" data-type="indexterm" id="workload-security"/>we’ve covered the core components of cluster security we’ll look at the security mechanisms at the workload layer. Kubernetes offers many&#13;
security-focused APIs, which makes configuration simple via the same tooling that&#13;
you use to deploy your workloads.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Pod Security Admission" data-type="sect2"><div class="sect2" id="id158">&#13;
<h2>Pod Security Admission</h2>&#13;
&#13;
<p>Pod Security Admission <a data-primary="Pod Security Admission controller" data-type="indexterm" id="id1099"/>is a critical piece of your workload security story that&#13;
allows you to configure and manage all the security-sensitive components of your&#13;
pod configuration and apply out-of-the-box best practices either to a namespace or at the&#13;
cluster level. <a data-type="xref" href="ch10.html#pod_and_container_security">Chapter 10</a> is dedicated to container and pod security,&#13;
and we encourage you to review it for further detail.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Seccomp, AppArmor, and SELinux" data-type="sect2"><div class="sect2" id="id159">&#13;
<h2>Seccomp, AppArmor, and SELinux</h2>&#13;
&#13;
<p>Linux offers <a data-primary="Seccomp" data-type="indexterm" id="id1100"/><a data-primary="AppArmor" data-type="indexterm" id="id1101"/><a data-primary="SELinux" data-type="indexterm" id="id1102"/>several different security mechanisms that can be utilized in concert with Kubernetes to increase the security posture of your workloads running on Kubernetes. Seccomp allows the creation of syscall filtering profiles that can be used to restrict syscalls coming from a container. Unfortunately, Seccomp profiles aren’t talked about enough in the Kubernetes community and have not been&#13;
configured at all or are misconfigured, allowing containers access to syscalls that could be used for malicious purposes. The Kubernetes community has created a great tool called the <a href="https://oreil.ly/g0tNJ">security profile operator</a> that simplifies the management overhead in the configuration of Seccomp profiles. Seccomp is low-hanging fruit to configure from a security perspective, so you are strongly encouraged to enable the Seccomp default profile at a minimum.</p>&#13;
&#13;
<p>AppArmor and SELinux are Linux kernel security modules that allow the granular&#13;
configuration of per-container mandatory access control. These allow a cluster&#13;
administrator fine-grained control over what action a container can perform. Using&#13;
both Pod Security Admission and these Linux security mechanisms, you can control&#13;
the level of access a container should have to the operating system.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Admission Controllers" data-type="sect2"><div class="sect2" id="id258">&#13;
<h2>Admission Controllers</h2>&#13;
&#13;
<p>Admission controllers <a data-primary="admission controllers" data-secondary="workload security" data-type="indexterm" id="id1103"/>are a critical piece in securing your workloads. Kubernetes&#13;
ships with a set of integrated admission controllers, and all security-related&#13;
admission controllers are enabled by default. For example, the NodeRestriction&#13;
admission controller restricts Kubelet’s permissions to only be able to modify&#13;
pods assigned to that specific node. Admission controllers are a big topic, and we&#13;
suggest you look at <a data-type="xref" href="ch17.html#admission_control_and_authorization">Chapter 17</a> for&#13;
more details.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operators" data-type="sect2"><div class="sect2" id="id259">&#13;
<h2>Operators</h2>&#13;
&#13;
<p>Operators are <a data-primary="Operators" data-secondary="workload security" data-type="indexterm" id="id1104"/>controllers that use the Kubernetes APIs to provide custom resources&#13;
to support specific workloads that require application-specific knowledge. If you&#13;
would like to learn more about the Operator pattern, refer to <a data-type="xref" href="ch21.html#implementing_an_operator">Chapter 21</a> where we cover how to implement an operator in detail. In the context of security, unfortunately, many operators ship&#13;
with very permissive RBAC configuration, for ease of use. Many grant&#13;
cluster-admin or equivalent privileges, which may serve as an attack vector.&#13;
Additionally, though less common, these operators may expose other APIs directly,&#13;
which could provide a pathway to privilege escalation.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Network Policy" data-type="sect2"><div class="sect2" id="id160">&#13;
<h2>Network Policy</h2>&#13;
&#13;
<p>Kubernetes ships<a data-primary="network policies, workload security" data-type="indexterm" id="id1105"/><a data-primary="policy and governance" data-secondary="network policies" data-type="indexterm" id="id1106"/> with a network policy resource; however, you need to double check that your networking provider implements the resource at runtime. For more details on network security, refer to <a data-type="xref" href="ch09.html#networking_network_security_and_service_mesh">Chapter 9</a>.  Kubernetes network policy provides fine-grained control over what network traffic is allowed to enter or exit a service or namespace for resources both internal and external to your cluster. Network policy also allows cluster administrators to create cluster-wide or namespace-specific policies and delegate application-specific network policy to application developers. Network policy covers only IP addresses and TCP/UDP ports and not specific HTTP traffic or endpoint routing access control. If you require application-specific access policies, service meshes include higher-level access policies that aren’t part of the integrated APIs of Kubernetes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Runtime Security" data-type="sect2"><div class="sect2" id="id161">&#13;
<h2>Runtime Security</h2>&#13;
&#13;
<p>Most Kubernetes<a data-primary="runtime security" data-type="indexterm" id="id1107"/> clusters utilize container runtimes such as&#13;
<a href="https://oreil.ly/Vyq_N">containerd</a> or <a href="https://oreil.ly/OiXpP">CRI-O</a> by default, which&#13;
leverage Linux cgroups under the hood to provide a lightweight sandbox for the&#13;
container runtime. For some security-sensitive workloads, these security guarantees&#13;
may not be sufficient. There is an ecosystem of different container runtimes, including <a href="https://oreil.ly/ANDje">Kata containers</a> and&#13;
<a href="https://oreil.ly/fuNPn">gvisor</a>, that provide different security profiles&#13;
to suit the needs of the workload. Kubernetes supports the use of multiple&#13;
container runtimes on the same cluster using the <code>RuntimeClass</code> field in the pod&#13;
specification. Please refer to <a data-type="xref" href="ch10.html#pod_and_container_security">Chapter 10</a> for more&#13;
detail on <code>RuntimeClass</code>. If you still require a higher level of security then&#13;
<a href="https://oreil.ly/v66K0">Confidential Containers</a> may also be&#13;
something to consider. Confidential Containers leverage <a href="https://oreil.ly/eSJfX">trusted execution environments</a>, which are secure areas on the CPU to run the workload.</p>&#13;
&#13;
<p>Like audit logs<a data-primary="audit logs" data-type="indexterm" id="id1108"/><a data-primary="logging" data-type="indexterm" id="id1109"/> at the Kubernetes control plane, you should also invest in audit&#13;
logging inside the container runtime. Tooling like <a href="https://oreil.ly/9KOeg">Falco</a> provides&#13;
a way to enable audit logging and policy on what the application can do inside the&#13;
container runtime. Having visibility into the container runtime allows you to&#13;
monitor and catch malicious behavior as close to the source as possible.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Workload Container Security Best Practices" data-type="sect2"><div class="sect2" id="id162">&#13;
<h2>Workload Container Security Best Practices</h2>&#13;
&#13;
<p>Kubernetes <a data-primary="best practices" data-secondary="workload container security" data-type="indexterm" id="best-practice-workload"/>provides a rich set of security tooling for you to use that can&#13;
almost be overwhelming to grok. Here is a shortlist of best practices you can focus&#13;
on to quickly improve the security posture of the workloads running on your&#13;
cluster:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Use the Node and RBAC authorizers together, in combination with the&#13;
NodeRestriction admission plug-in.</p>&#13;
</li>&#13;
<li>&#13;
<p>Secure the cluster control plane with strong authentication and&#13;
authorization mechanisms.</p>&#13;
</li>&#13;
<li>&#13;
<p>Review operator API permissions and make sure that they follow least privilege.</p>&#13;
</li>&#13;
<li>&#13;
<p>Apply the principle of least privilege to limit the access and permissions&#13;
of users, pods, and service accounts.</p>&#13;
</li>&#13;
<li>&#13;
<p>Implement network policies to restrict the traffic between pods and namespaces.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ensure the recommended set of security-based admission controllers are enabled.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use Seccomp, AppArmor, and SELinux to minimize the Linux kernel attack surface area the container&#13;
runtime has access to.</p>&#13;
</li>&#13;
<li>&#13;
<p>Ensure dynamic webhook admission controllers are securely configured, scoped to only&#13;
the resources they need to validate/mutate, and follow least privilege RBAC.</p>&#13;
</li>&#13;
<li>&#13;
<p>Provide different container runtime sandboxes on your cluster and use&#13;
<code>RuntimeClass</code> to allow application developers to select the runtime to match&#13;
the security requirements.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use admission controllers to validate security best practices <a data-primary="security" data-secondary="workload containers" data-startref="security-workload-containers" data-type="indexterm" id="id1110"/><a data-primary="workload security" data-startref="workload-security" data-type="indexterm" id="id1111"/><a data-primary="best practices" data-secondary="workload container security" data-startref="best-practice-workload" data-type="indexterm" id="id1112"/>on application&#13;
&#13;
<span class="keep-together">workloads.</span></p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Security" data-type="sect1"><div class="sect1" id="id163">&#13;
<h1>Code Security</h1>&#13;
&#13;
<p>Good security <a data-primary="security" data-secondary="code security" data-type="indexterm" id="security-code"/><a data-primary="code security" data-type="indexterm" id="code-security"/>starts before the code even reaches Kubernetes. We’ll cover some&#13;
different tools and techniques that you can introduce to further improve your&#13;
security posture.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Non-Root and Distroless Containers" data-type="sect2"><div class="sect2" id="id164">&#13;
<h2>Non-Root and Distroless Containers</h2>&#13;
&#13;
<p>There are <a data-primary="non-root containers" data-type="indexterm" id="id1113"/><a data-primary="distroless images" data-type="indexterm" id="id1114"/>two quick wins when it comes to building containers with an improved security posture. Configure the application process to not run as the root user by specifying a non-root user as part of the container build file. Kubernetes allows for this also to be set as part of&#13;
the <code>securityContext</code> section of the pod specification via the <code>runAsUser</code>. This can be used as a fail-safe; however, configuring it in the &#13;
<span class="keep-together">container</span> build file is preferred.&#13;
Additionally, many base containers provide commonly used packages preinstalled in the container. These packages may not be used and can introduce vulnerabilities.&#13;
Tools like <a href="https://oreil.ly/tpSEA">distroless</a> and scratch&#13;
containers provide the smallest possible base container image, which again decreases the&#13;
attack surface area.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Container Vulnerability Scanning" data-type="sect2"><div class="sect2" id="id165">&#13;
<h2>Container Vulnerability Scanning</h2>&#13;
&#13;
<p>Many<a data-primary="image management" data-secondary="vulnerability scanning" data-type="indexterm" id="id1115"/><a data-primary="vulnerability scanning" data-type="indexterm" id="id1116"/> open source tools provide vulnerability scanning of container&#13;
images. These tools, like <a href="https://oreil.ly/pFbNN">Trivy</a>, are easy to use and can provide&#13;
a baseline of the vulnerabilities in a container image. You can then decide whether or not to deploy the container based on these results. However, these tools can be very noisy and provide inconsistent results. Many container&#13;
repository providers offer integrated vulnerability scanning, and some admission&#13;
controllers will either admit or deny a workload being deployed based on the&#13;
vulnerabilities present in the image.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Repository Security" data-type="sect2"><div class="sect2" id="id166">&#13;
<h2>Code Repository Security</h2>&#13;
&#13;
<p>Source code repositories <a data-primary="repositories" data-secondary="security" data-type="indexterm" id="id1117"/>are another great place to improve security, and thankfully&#13;
there is tooling and guidance to help improve the security posture at this layer.</p>&#13;
&#13;
<p><a href="https://oreil.ly/CWXWD">Supply-Chain Levels for Software Artifacts</a>, or SLSA, <a data-primary="Supply-Chain Levels for Software Artifacts (SLSA)" data-type="indexterm" id="id1118"/><a data-primary="SLSA (Supply-Chain Levels for Software Artifacts)" data-type="indexterm" id="id1119"/>is a framework&#13;
that provides a checklist of controls based on incremental levels that you can adopt&#13;
to help improve software security and integrity. Many open source projects are adopting&#13;
SLSA in an effort to improve software security. The levels are well-defined and when&#13;
implemented raise the security posture of your source code.</p>&#13;
&#13;
<p><a href="https://oreil.ly/q-NI3">OpenSSF Scorecard</a> gives an <a data-primary="OpenSSF Scorecard" data-type="indexterm" id="id1120"/>automated set of&#13;
tools that provide a 0–10 score on the security posture of an open source repository that&#13;
you might be using or considering to use as a dependency. The aggregate score provides&#13;
an at-a-glance view that can be used to evaluate how trustworthy an open&#13;
source project is. Many prominent open source projects are adopting this scorecard.</p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Code Security Best Practices" data-type="sect1"><div class="sect1" id="id167">&#13;
<h1>Code Security Best Practices</h1>&#13;
&#13;
<p>Good security<a data-primary="best practices" data-secondary="code security" data-type="indexterm" id="id1121"/> starts well before a container is deployed to a Kubernetes cluster.&#13;
The code repository is a great place to also implement security measures to build&#13;
your in-depth security strategy. Here are some best practices to help&#13;
guide you to some quick wins on your code security front:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Review operator API permissions and make sure that they follow least privilege.</p>&#13;
</li>&#13;
<li>&#13;
<p>Configure the container build file to run application processes as a non-root user.</p>&#13;
</li>&#13;
<li>&#13;
<p>Use container base images like scratch and distroless.</p>&#13;
</li>&#13;
<li>&#13;
<p>Perform vulnerability scanning on your containers, and implement policy on whether to allow a container to be deployed based on these vulnerabilities.</p>&#13;
</li>&#13;
<li>&#13;
<p>Review OpenSSF scorecards on open source projects that you depend on.</p>&#13;
</li>&#13;
<li>&#13;
<p>Implement SLSA level 1 to provide baseline-level transparency and integrity for&#13;
your <a data-primary="security" data-secondary="code security" data-startref="security-code" data-type="indexterm" id="id1122"/><a data-primary="code security" data-startref="code-security" data-type="indexterm" id="id1123"/>software.</p>&#13;
</li>&#13;
</ul>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="id389">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We’ve covered a lot of ground in this chapter. It’s important to understand the&#13;
full breadth of what it takes to secure Kubernetes so that you can start to break&#13;
down the problem into smaller pieces that you can implement. Security is a journey&#13;
and not a destination. It will always be a moving target, and by following these&#13;
best practices, you can improve the security posture of your&#13;
Kubernetes cluster and reduce the risk of data breaches or compromises.</p>&#13;
</div></section>&#13;
</div></section></body></html>