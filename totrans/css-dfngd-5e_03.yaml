- en: Chapter 3\. Pseudo-Class and -Element Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you saw how selectors can match a single element or
    a collection of elements, using fairly simple expressions that match HTML attributes
    in the document. Those are great if your need is just to style based on attributes,
    but what if you need to style part of a document based on its current state or
    structure? Or if you want to select all the form elements that are disabled, or
    those that are required for form submission to be allowed? For those things, and
    a great deal more, CSS has the pseudo-class and pseudo-element selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Pseudo-Class Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Pseudo-class selectors* let you assign styles to what are, in effect, phantom
    classes inferred by the state of certain elements, or markup patterns within the
    document, or even by the state of the document itself.'
  prefs: []
  type: TYPE_NORMAL
- en: The term *phantom classes* might seem a little odd, but it really is the best
    way to think of how pseudo-classes work. For example, suppose you want to highlight
    every other row of a data table. You could do that by marking up every other row
    with something like `class="even"` and then writing CSS to highlight rows with
    that class—or (as you’ll soon see) you could use a pseudo-class selector to achieve
    the same effect, one that will act as if you’ve added all those classes to the
    markup even though you haven’t.
  prefs: []
  type: TYPE_NORMAL
- en: 'One aspect of pseudo-classes needs to be made explicit here: pseudo-classes
    always refer to the element to which they’re attached, and to no other. Seems
    like a weirdly obvious thing to say, right? The reason we make it explicit is
    that for some pseudo-classes, it’s a common error to think they are descriptors
    that refer to descendant elements.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, Eric would like to share a personal anecdote:'
  prefs: []
  type: TYPE_NORMAL
- en: When my first child was born in 2003, I announced it online, as one does. A
    number of people responded with congratulations and CSS jokes, chief among them
    the selector `#ericmeyer:first-child` (we’ll get to `:first-child` in just a bit).
    But that selector would select me, not my daughter, and only if I were the first
    child of my own parents (which, as it happens, I am). To properly select *my*
    first child, that selector would need to be `#ericmeyer > :first-child`.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The confusion is understandable, which is why we’re addressing it here. Reminders
    are found throughout the following sections. Just always keep in mind that the
    effect of pseudo-classes is to apply a sort of phantom class to the element to
    which they’re attached, and you should be OK.
  prefs: []
  type: TYPE_NORMAL
- en: All pseudo-classes, without exception, are a word or hyphenated term preceded
    by a single colon (`:`), and they can appear anywhere in a selector.
  prefs: []
  type: TYPE_NORMAL
- en: Combining Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we really get started, a word about chaining. CSS makes it possible
    to combine (*chain*) pseudo-classes together. For example, you can make unvisited
    links red when they’re hovered and visited links maroon when they are hovered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The order you specify doesn’t matter; you could also write `a:hover:link` to
    the same effect as `a:link:hover`. It’s also possible to assign separate hover
    styles to unvisited and visited links that are in another language—for example,
    German:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Be careful not to combine mutually exclusive pseudo-classes. For example, a
    link cannot be both visited and unvisited, so `a:link:visited` doesn’t make any
    sense and will never match anything.
  prefs: []
  type: TYPE_NORMAL
- en: Structural Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first set of pseudo-classes we’ll explore are structural in nature; that
    is, they refer to the markup structure of the document. Most of them depend on
    patterns within the markup, such as choosing every third paragraph, but others
    allow you to address specific types of elements.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the root element
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is the quintessence of structural simplicity: the pseudo-class `:root`
    selects the root element of the document. In HTML, this is *always* the `<html>`
    element. The real benefit of this selector is found when writing stylesheets for
    XML languages, as the root element may be different in every language—for example,
    in SVG it’s the `<svg>` element, and in our earlier PlanetML examples it was the
    `<pml>` element—or even when you have more than one possible root element within
    a single language (though not a single document!).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of styling the root element in HTML, as illustrated in [Figure 3-1](#styling_the_root_element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0301](assets/css5_0301.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-1\. Styling the root element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In HTML documents, you can always select the `<html>` element directly, without
    having to use the `:root` pseudo-class. The two selectors differ in terms of specificity,
    which we’ll cover in [Chapter 4](ch04.html#specificity_comma_inheritance), but
    otherwise they’ll have the same effect.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting empty elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the pseudo-class `:empty`, you can select any element that has no children
    of any kind, *including* text nodes, which covers both text and whitespace. This
    can be useful in suppressing elements that a content management system (CMS) has
    generated without filling in any actual content. Thus, `p:empty {display: none;}`
    would prevent the display of any empty paragraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that in order to be matched, an element must be, from a parsing perspective,
    truly empty—no whitespace, visible content, or descendant elements. Of the following
    elements, only the first and last would be matched by `p:empty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The second and third paragraphs are not matched by `:empty` because they are
    not empty: they contain, respectively, a single space and a single newline character.
    Both are considered text nodes and thus prevent a state of emptiness. The last
    paragraph matches because comments are not considered content, not even whitespace.
    But put even one space or newline to either side of that comment, and `p:empty`
    would fail to match.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be tempted to just style all empty elements with something like `*:empty
    {display: none;}`, but there’s a hidden catch: `:empty` matches HTML’s empty elements,
    like `<img>`, `<hr>`, `<br>`, and `<input>`. It could even match `<textarea>`,
    unless you insert some default text into the `<textarea>` element.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in terms of matching elements, `img` and `img:empty` are effectively the
    same. (They are different in terms of specificity, which we’ll cover in the next
    chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: Selecting only children
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you’ve ever wanted to select all the images that are wrapped by a hyperlink
    element, the `:only-child` pseudo-class is for you. It selects elements when they
    are the only child element of another element. So let’s say you want to add a
    border to any image that’s the only child of another element. You’d write the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This would match any image that meets those criteria. Therefore, if you had
    a paragraph that contained an image and no other child elements, the image would
    be selected regardless of all the text surrounding it. If what you’re really after
    is images that are sole children and found inside hyperlinks, you just modify
    the selector like so (which is illustrated in [Figure 3-2](#selecting_images_that_are_only_children)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0302](assets/css5_0302.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-2\. Selecting images that are only children inside links
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You should remember two things about `:only-child`. The first is that you *always*
    apply it to the element you want to be an only child, not to the parent element,
    as explained earlier. That brings up the second thing to remember, which is that
    when you use `:only-child` in a descendant selector, you aren’t restricting the
    elements listed to a parent-child relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'To go back to the hyperlinked-image example, `a[href] img:only-child` matches
    any image that is an only child and is descended from an `a` element, whether
    or not it’s a *child* of an `a` element. To match, the element image must be the
    only child of its direct parent and also a descendant of an `a` element with an
    `href` attribute, but that parent can itself be a descendant of the same `<a>`
    element. Therefore, all three of the images in the following would be matched,
    as shown in [Figure 3-3](#selecting_images_that_are_only_child):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0303](assets/css5_0303.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-3\. Selecting images that are only children inside links, redux
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In each case, the image is the only child element of its parent, and it is also
    descended from an `<a>` element. Thus, all three images are matched by the rule
    shown. If you want to restrict the rule so that it matches images that are the
    only children of `<a>` elements, you add the child combinator to yield `a[href]
    > img:only-child`. With that change, only the first of the three images shown
    in [Figure 3-3](#selecting_images_that_are_only_child) would be matched.
  prefs: []
  type: TYPE_NORMAL
- en: Using only-of-type selection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'That’s all great, but what if you want to match images that are the only images
    inside hyperlinks, but other elements may be in there with them? Consider the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have an `a` element that has two children: `<b>` and `<img>`.
    That image, no longer the only child of its parent (the hyperlink), can never
    be matched using `:only-child`. However, it *can* be matched using `:only-of-type`.
    This is illustrated in [Figure 3-4](#selecting_images_that_are_the_only_sibli):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0304](assets/css5_0304.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-4\. Selecting images that are the only sibling of their type
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The difference is that `:only-of-type` will match any element that is the only
    one of its type among all its siblings, whereas `:only-child` will match only
    if an element has no siblings at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be very useful in cases such as selecting images within paragraphs
    without having to worry about the presence of hyperlinks or other inline elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As long as there aren’t multiple images that are children of the same paragraph,
    the image will be floated to the right.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use this pseudo-class to apply extra styles to an `<h2>` when
    it’s the only one in a given section of a document, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Given those rules, any `<section>` that has only one child `<h2>` will have
    that `<h2>` appear larger than usual. If a `section` has two or more `<h2>` children,
    neither will be larger than the other. The presence of other children—whether
    they are other heading levels, tables, paragraphs, lists, and so on—will not interfere
    with matching.
  prefs: []
  type: TYPE_NORMAL
- en: 'One more point to make clear is that `:only-of-type` refers to elements and
    nothing else. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this case, neither of the paragraphs will be selected. Why not? Because two
    paragraphs are descendants of the `<div>`, neither can be the only one of their
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The class name is irrelevant here. We can be fooled into thinking that *type*
    is a generic description, because of the way we parse language. *Type*, in the
    way `:only-of-type` means it, refers only to the element type, as with type selectors.
    Thus, `p.unique:only-of-type` means, “Select any `<p>` element that is the only
    `<p>` element among its siblings if it also has a `class` of `unique`.” It does
    *not* mean, “Select any `<p>` element whose `class` attribute contains the word
    `unique` when it’s the only sibling paragraph to meet that criterion.”
  prefs: []
  type: TYPE_NORMAL
- en: Selecting first children
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s pretty common to want to apply special styling to the first or last child
    of an element. A typical example is styling a bunch of navigation links in a tab
    bar and wanting to put special visual touches on the first or last tab (or both).
    If we didn’t have structural selectors, this could be done by applying special
    classes to those elements. We have pseudo-classes to carry the load for us, removing
    the need to manually figure out which elements are the first and last.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pseudo-class `:first-child` is used to select elements that are the first
    children of other elements. Consider the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the elements that are first children are the first `<p>`, the
    first `<li>`, and the `<strong>` and `<em>` elements, which are all the first
    children of their respective parents. Given the following two rules,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: we get the result shown in [Figure 3-5](#styling_first_children).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0305](assets/css5_0305.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-5\. Styling first children
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first rule boldfaces any `<p>` element that is the first child of another
    element. The second rule uppercases any `<li>` element that is the first child
    of another element (which, in HTML, must be either an `<ol>` or `<ul>` element).
  prefs: []
  type: TYPE_NORMAL
- en: 'As has been mentioned, the most common error is assuming that a selector like
    `p:first-child` will select the first child of a `<p>` element. Remember the nature
    of pseudo-classes, which is to attach a sort of phantom class to the anchor element,
    the element associated with the pseudo-class. If you were to add actual classes
    to the markup, it would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, if you want to select those `<em>` elements that are the first child
    of another element, you write `em:first-child`.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting last children
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The mirror image of `:first-child` is `:last-child`. If we take the previous
    example and just change the pseudo-classes, we get the result shown in [Figure 3-6](#styling_first_children-id1):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0306](assets/css5_0306.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-6\. Styling last children
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first rule boldfaces any `<p>` element that is the last child of another
    element. The second rule uppercases any `<li>` element that is the last child
    of another element. If you wanted to select the `<em>` element inside that last
    paragraph, you could use the selector `p:last-child em`, which selects any `<em>`
    element that descends from a `<p>` element that is itself the last child of another
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Interestingly, you can combine these two pseudo-classes to create a version
    of `:only-child`. The following two rules will select the same elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Either way, we get paragraphs with red foreground and background colors (not
    a good idea, to be clear).
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the first and last of a type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a manner similar to selecting the first and last children of an element,
    you can select the first or last of a type of element within another element.
    This permits actions like selecting the first `<table>` inside a given element,
    regardless of whatever elements come before it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note that this does *not* apply to the entire document; the rule shown will
    not select the first table in the document and skip all the others. It will instead
    select the first `<table>` element within each element that contains one, and
    skip any sibling `<table>` elements that come after the first. Thus, given the
    document structure shown in [Figure 3-7](#selecting_first-of-type_tables), the
    circled nodes are the ones that are selected.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0307](assets/css5_0307.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-7\. Selecting first-of-type tables
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Within the context of tables, a useful way to select the first data cell within
    a row regardless of whether a header cell comes before it in the row is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'That would select the first data cell in each of the following table rows (that
    is, the cells containing `7` and `R`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Compare that to the effects of `td:first-child`, which would select the first
    `<td>` element in the second row, but not in the first row.
  prefs: []
  type: TYPE_NORMAL
- en: The flip side is `:last-of-type`, which selects the last instance of a given
    type from among its sibling elements. In a way, it’s just like `:first-of-type`,
    except you start with the last element in a group of siblings and walk backward
    toward the first element until you reach an instance of the type. Given the document
    structure shown in [Figure 3-8](#selecting_last-of-type_tables), the circled nodes
    are the ones selected by `table:last-of-type`.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0308](assets/css5_0308.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-8\. Selecting last-of-type tables
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As was noted with `:only-of-type`, remember that you are selecting elements
    of a type from among their sibling elements; thus, every set of siblings is considered
    separately. In other words, you are *not* selecting the first (or last) of all
    the elements of a type within the entire document as a single group. Each set
    of elements that shares a parent is its own group, and you can select the first
    (or last) of a type within each group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to what was noted in the previous section, you can combine these two
    pseudo-classes to create a version of `:only-of-type`. The following two rules
    will select the same elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Selecting every nth child
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you can select elements that are the first, last, or only children of other
    elements, how about every third child? All even children? Only the ninth child?
    Rather than try to define a literally infinite number of named pseudo-classes,
    CSS has the `:nth-child()` pseudo-class. By filling integers or even basic algebraic
    expressions into the parentheses, you can select any arbitrarily numbered child
    element you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `:nth-child()` equivalent of `:first-child`, which is
    `:nth-child(1)`. In the following example, the selected elements will be the first
    paragraph and the first list item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change the numbers from `1` to `2`, however, then no paragraphs will
    be selected, and the middle (or second) list item will be selected, as illustrated
    in [Figure 3-9](#styling_second_children):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0309](assets/css5_0309.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-9\. Styling second children
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can insert any integer you choose. If you have a use case for selecting
    any ordered list that is the 93rd child element of its parent, `ol:nth-child(93)`
    is ready to serve. This will match the 93rd child of any parent as long as that
    child is an ordered list. (This does not mean the 93rd ordered list among its
    siblings; see [“Selecting every nth of a type”](#selecting_every_nth_of_a_type)
    for that.)
  prefs: []
  type: TYPE_NORMAL
- en: Is there a reason to use `:nth-child(1)` rather than `:first-child`? No. In
    this case, use whichever you prefer. There is literally no difference between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: More powerfully, you can use simple algebraic expressions in the form *`a`*`n`
    + *`b`* or *`a`*`n` `-` *`b`* to define recurring instances, where *`a`* and *`b`*
    are integers and `n` is present as itself. Furthermore, the `+` *`b`* or `−` *`b`*
    part is optional and thus can be dropped if it isn’t needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s suppose we want to select every third list item in an unordered list,
    starting with the first. The following makes that possible, selecting the first
    and fourth items, as shown in [Figure 3-10](#styling_every_third_list_item):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0310](assets/css5_0310.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-10\. Styling every third list item
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The way this works is that `n` represents the series 0, 1, 2, 3, 4, and on into
    infinity. The browser then solves for `3n + 1`, yielding 1, 4, 7, 10, 13, and
    so on. Were we to drop the `+ 1`, thus leaving us with simply `3n`, the results
    would be 0, 3, 6, 9, 12, and so on. Since there is no zeroth list item—all element
    counting starts with 1, to the likely chagrin of array-slingers everywhere—the
    first list item selected by this expression would be the third list item in the
    list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that element counting starts with 1, it is a minor trick to deduce that
    `:nth-child(2n)` will select even-numbered children, and either `:nth-child(2n+1)`
    or `:nth-child(2n-1)` will select odd-numbered children. You can commit that to
    memory, or you can use the two special keywords that `:nth-child()` accepts: `even`
    and `odd`. Want to highlight every other row of a table, starting with the first?
    Here’s how you do it, with the results shown in [Figure 3-11](#styling_every_other_table_row):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0311](assets/css5_0311.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-11\. Styling every other table row
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Anything more complex than every-other-element requires an *`a`*`n` `+` *`b`*
    expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when you want to use a negative number for *`b`*, you have to remove
    the `+` sign, or else the selector will fail entirely. Of the following two rules,
    only the first will do anything. The second will be dropped by the parser and
    the entire declaration block will be ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a negative value for *`a`* in the expression, which will effectively
    count backward from the term you use in *`b`*. Selecting the first five list items
    in a list can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This works because negative `n` goes 0, –1, –2, –3, –4, and so on. Add 5 to
    each of those, and you get 5, 4, 3, 2, 1, and so on. Put in a negative number
    for a multiplier on `n`, and you can get every second, third, or whatever-number-you-want
    element, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: That will select the 10th, 8th, 4th, and 2nd list items in a list.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might expect, a corresponding pseudo-class is `:nth-last-child()`. This
    lets you do the same thing as `:nth-child()`, except with `:nth-last-child()`
    you start from the last element in a list of siblings and count backward toward
    the beginning. If you’re intent on highlighting every other table row *and* making
    sure the very last row is one of the rows in the highlighting pattern, either
    one of these will work for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If the Document Object Model (DOM) is updated to add or remove table rows, there
    is no need to add or remove classes. By using structural selectors, these selectors
    will always match the odd rows of the updated DOM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any element can be matched using both `:nth-child()` and `:nth-last-child()`
    if it fits the criteria. Consider these rules, the results of which are shown
    in [Figure 3-12](#combining_patterns_of_colon_nth-child_op):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, using negative terms for *`a`* will essentially count backward, except
    since this pseudo-class is already counting from the end, a negative term counts
    forward. That is to say, you can select the last five list items in a list like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: An extension of `:nth-child()` and `:nth-last-child()` allows selecting from
    among elements matched by a simple or compound selector; for example, `:nth-child(2n
    + 1 of p.callout)`. As of early 2023, this is supported in Safari and Chrome beta
    releases. With it being included in Interop 2023, there are plans to have it fully
    supported in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0312](assets/css5_0312.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-12\. Combining patterns of `:nth-child()` and `:nth-last-child()`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You also can string these two pseudo-classes together as `:nth-child(1):nth-last-child(1)`,
    thus creating a more verbose restatement of `:only-child`. There’s no real reason
    to do so other than to create a selector with a higher specificity (discussed
    in [Chapter 4](ch04.html#specificity_comma_inheritance)), but the option is there.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use CSS to determine the number of items in a list and style them accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In these examples, if a list item is the only list item, the width is 100%.
    If a list item is the first item as well as the second-from-the-last item, that
    means there are two items, and the width is 50%. If an item is the first item
    as well as the third-from-the-last item, we make it, and the two sibling list
    items following it, 33% wide. Similarly, if a list item is the first item as well
    as the fourth-from-the-last item, it means that there are exactly four items,
    so we make it, and its three siblings, 25% of the width. (Note: this sort of thing
    is a lot easier with the `:has()` pseudo-class, covered in [“The :has() Pseudo-Class”](#the_has_pseudo_class).)'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting every nth of a type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In what may have become a familiar pattern, the `:nth-child()` and `:nth-last-child()`
    pseudo-classes have analogues in `:nth-of-type()` and `:nth-last-of-type()`. You
    can, for example, select every other hyperlink that’s a child of any given paragraph,
    starting with the second, using `p > a:nth-of-type(even)`. This will ignore all
    other elements (`<span>`, `<strong>`, etc.) and consider only the links, as demonstrated
    in [Figure 3-13](#selecting_the_even-numbered_links):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0313](assets/css5_0313.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-13\. Selecting the even-numbered links
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want to work from the last hyperlink backward, then you’d use `p > a:nth-last-of-type(even)`.
  prefs: []
  type: TYPE_NORMAL
- en: As before, these pseudo-classes select elements of a type from among their sibling
    elements, *not* from among all the elements of a type within the entire document
    as a single group. Each element has its own list of siblings, and selections happen
    within each group.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference between `:nth-of-type()` and `nth-child()` is that `:nth-of-type()`
    counts the instances of whatever you’re selecting, and does its counting within
    that collection of elements. Take, for example, the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wanted to select every table cell in a row when it’s in an even-numbered
    column, you would use `td:nth-child(even)`. But if you want to select every even-numbered
    instance of a table cell, that would be `td:nth-of-type(even)`. You can see the
    difference in [Figure 3-14](#nth-child_and_nth-of-type), which shows the result
    of the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0314](assets/css5_0314.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-14\. Selecting both `nth-child` and `nth-of-type` table cells
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first row, every other table data cell (`td`) is selected, starting with
    the first cell that comes after the table header cell (`th`). In the second row,
    since all the cells are `td` cells, that means all the cells in that row are of
    the same type and thus the counting starts at the first cell.
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, you can use `:nth-of-type(1):nth-last-of-type(1)` together
    to restate `:only-of-type`, only with higher specificity. (We *will* explain specificity
    in [Chapter 4](ch04.html#specificity_comma_inheritance), we promise.)
  prefs: []
  type: TYPE_NORMAL
- en: Location Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the *location pseudo-classes*, we cross into the territory of selectors
    that match pieces of a document based on something in addition to the structure
    of the document—something that cannot be precisely deduced simply by studying
    the document’s markup.
  prefs: []
  type: TYPE_NORMAL
- en: This may sound like we’re applying styles at random, but not so. Instead, we’re
    applying styles based on somewhat ephemeral conditions that can’t be predicted
    in advance. Nevertheless, the circumstances under which the styles will appear
    are, in fact, well-defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of it this way: during a sporting event, whenever the home team scores,
    the crowd will cheer. You don’t know exactly when during a game the team will
    score, but when it does, the crowd will cheer, just as predicted. The fact that
    you can’t predict the exact moment of the cheer doesn’t make it any less expected.'
  prefs: []
  type: TYPE_NORMAL
- en: Now consider the anchor element (`<a>`), which (in HTML and related languages)
    establishes a link from one document to another. Anchors are always anchors, but
    some anchors refer to pages that have already been visited, while others refer
    to pages that have yet to be visited. You can’t tell the difference by simply
    looking at the HTML markup, because in the markup, all anchors look the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only way to tell which links have been visited is by comparing the links
    in a document to the user’s browser history. So there are actually two basic types
    of links: visited and unvisited.'
  prefs: []
  type: TYPE_NORMAL
- en: Hyperlink-specific pseudo-classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS defines a few pseudo-classes that apply only to hyperlinks. In HTML, hyperlinks
    are any `<a>` elements with an `href` attribute; in XML languages, a hyperlink
    is any element that acts as a link to another resource. [Table 3-1](#link_pseudo-classes)
    describes the pseudo-classes you can apply to them.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-1\. Link pseudo-classes
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `:link` | Refers to any anchor that is a hyperlink (i.e., has an `href` attribute)
    and points to an address that has not been visited. |'
  prefs: []
  type: TYPE_TB
- en: '| `:visited` | Refers to any anchor that is a hyperlink to an already visited
    address. For security reasons, the styles that can be applied to visited links
    are severely limited; see [“Visited Links and Privacy”](#visited_links_and_privacy)
    for details. |'
  prefs: []
  type: TYPE_TB
- en: '| `:any-link` | Refers to any element that would be matched by either `:link`
    or `:visited`. |'
  prefs: []
  type: TYPE_TB
- en: '| `:local-link` | Refers to any link that points at the same URL as the page
    being styled. One example would be skip-links within a document. *Note: not supported
    as of early 2023.* |'
  prefs: []
  type: TYPE_TB
- en: 'The first of the pseudo-classes in [Table 3-1](#link_pseudo-classes) may seem
    a bit redundant. After all, if an anchor hasn’t been visited, it must be unvisited,
    right? If that’s the case, all we should need is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this format seems reasonable, it’s not quite enough. The first of
    the rules shown here applies not only to unvisited links, but also to any `<a>`
    element, even those without an `href` attribute such as this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting text would be blue, because the `<a>` element will match the
    rule `a {color`: `blue;}`. Therefore, to avoid applying your link styles to placeholder
    links, use the `:link` and `:visited` pseudo-classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a good place to revisit attribute and class selectors and show how
    they can be combined with pseudo-classes. For example, let’s say you want to change
    the color of links that point outside your own site. In most circumstances, we
    can use the starts-with attribute selector. However, some CMSs set all links to
    be absolute URLs, in which case you could assign a class to each of these anchors.
    It’s easy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'To apply different styles to the external link, all you need is a rule like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This rule will make the second anchor in the preceding markup slate blue by
    default and maroon once visited, while the first anchor will remain the default
    color for hyperlinks (usually blue when not visited and purple once visited).
    For improved usability and accessibility, visited links should be easily distinguished
    from unvisited links.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Styled visited links enable visitors to know where they have been and what they
    have yet to visit. This is especially important on large websites, where it may
    be difficult to remember which pages have been visited, especially for those with
    cognitive disabilities. Not only is highlighting visited links one of the W3C
    Web Content Accessibility Guidelines, but it makes searching for content faster,
    more efficient, and less stressful for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same general syntax is used for ID selectors as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to select all links, regardless of whether they’re visited or not,
    use `:any-link`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Nonhyperlink location pseudo-classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Hyperlinks aren’t the only elements that can be related to location. CSS also
    provides a few pseudo-classes that relate to the targets of hyperlinks, summarized
    in [Table 3-2](#non_link_pseudo-classes).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-2\. Nonlink location pseudo-classes
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `:target` | Refers to an element whose `id` attribute value matches the fragment
    selector in the URL used to load the page—that is, the element specifically targeted
    by the URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `:target-within` | Refers to an element that is the target of the URL, or
    that contains an element that is so targeted. *Note: not supported as of early
    2023.* |'
  prefs: []
  type: TYPE_TB
- en: '| `:scope` | Refers to elements that are a reference point for selector matching.
    |'
  prefs: []
  type: TYPE_TB
- en: Let’s talk about target selection. When a URL includes a fragment identifier,
    the piece of the document at which it points is called (in CSS) the *target*.
    Thus, you can uniquely style any element that is the target of a URL fragment
    identifier with the `:target` pseudo-class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you’re unfamiliar with the term *fragment identifier*, you’ve probably
    seen them in action. Consider this URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `target-pseudo` portion of the URL is the fragment identifier, which is
    marked by the `#` symbol. If the referenced page (*http://www.w3.org/TR/css3-selectors/*)
    has an element with an ID of `target-pseudo`, that element becomes the target
    of the fragment identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to `:target`, you can highlight any targeted element within a document,
    or you can devise different styles for various types of elements that might be
    targeted—say, one style for targeted headings, another for targeted tables, and
    so on. [Figure 3-15](#styling_a_fragment_identifier_target) shows an example of
    `:target` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0315](assets/css5_0315.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-15\. Styling a fragment identifier target
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `:target` styles will not be applied in three circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: The page is accessed via a URL that does not have a fragment identifier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The page is accessed via a URL that has a fragment identifier, but the identifier
    does not match any elements within the document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The page’s URL is updated in such a way that a scroll state is not created,
    which happens most often via JS shenanigans. (This isn’t a CSS rule, but it is
    how browsers behave.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More interestingly, though, what happens if multiple elements within a document
    can be matched by the fragment identifier—for example, if the author erroneously
    includes three separate instances of `<div id="target-pseudo">` in the same document?
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is that CSS doesn’t have or need rules to cover this case,
    because all CSS is concerned with is styling targets. Whether the browser picks
    just one of the three elements to be the target or designates all three as coequal
    targets, `:target` styles should be applied to anything that is a valid target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Closely related to the `:target` pseudo-class is the `:target-within` pseudo-class.
    The difference is that `:target-within` will match not only elements that are
    targets, but also elements that are the ancestors of targets. Thus, the following
    CSS would match any `<p>` element containing a target, or that was itself a target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Or it would, anyway, if any browser supported it. As of early 2023, this is
    not the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we consider the `:scope` pseudo-class. This is quite widely supported,
    but at present, it comes in handy only in scripting situations. Consider the following
    JS and HTML, which we’ll explain after the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The JS portion says, in effect, “Find the element with an ID of `output`. Then,
    find all the `<div>` elements that are children of the `output` element you just
    found.” (Yes, CSS selectors can be used in JS!) The `:scope` in that bit of JS
    refers to the scope of the thing that had been found, thus keeping the selection
    confined to just that instead of the whole document. The result is that, in the
    JS program’s memory, it now has a structure holding references to the two `<div>`
    elements in the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: If you use `:scope` in straight CSS, it will refer to the *scoping root*, which
    (at present) means the `<html>` element, assuming the document is HTML. Neither
    HTML nor CSS provides a way to set scoping roots other than the root element of
    the document. So, outside of JS, `:scope` is essentially equivalent to `:root`.
    That may change in the future, but for now, you should use `:scope` only in JS
    contexts.
  prefs: []
  type: TYPE_NORMAL
- en: User Action Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS defines a few pseudo-classes that can change a document’s appearance based
    on actions taken by the user. These *dynamic pseudo-classes* have traditionally
    been used to style hyperlinks, but the possibilities are much wider. Pseudo-classes
    are described in [Table 3-3](#user_action_pseudo-classes-id1).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-3\. User action pseudo-classes
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `:hover` | Refers to any element over which the mouse pointer is placed—e.g.,
    a hyperlink over which the mouse pointer is hovering |'
  prefs: []
  type: TYPE_TB
- en: '| `:active` | Refers to any element that has been activated by user input—e.g.,
    a hyperlink on which a user clicks during the time the mouse button is held down,
    or an element a user has tapped via touch screen |'
  prefs: []
  type: TYPE_TB
- en: '| `:focus` | Refers to any element that currently has the input focus—i.e.,
    can accept keyboard input or otherwise be activated in some way |'
  prefs: []
  type: TYPE_TB
- en: '| `:focus-within` | Refers to any element that currently has the input focus—i.e.,
    can accept keyboard input or be activated in some way—or an element containing
    an element that is so focused |'
  prefs: []
  type: TYPE_TB
- en: '| `:focus-visible` | Refers to any element that currently has the input focus,
    but only if the user agent thinks it is an element type that should have visible
    focus |'
  prefs: []
  type: TYPE_TB
- en: Elements that can become `:active` or have `:focus` include links, buttons,
    menu items, any element with a `tabindex` value, and all other interactive elements,
    including form controls and elements containing content that can be edited (by
    having the attribute, `contenteditable`, added to the element’s opening tag).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with `:link` and `:visited`, these pseudo-classes are most familiar in the
    context of hyperlinks. Many web pages have styles that look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The order of the pseudo-classes is more important than it might seem at first.
    The usual recommendation is `link`, `visited`, `focus`, `hover`, and `active`.
    The next chapter explains why this particular order is important and discusses
    several reasons you might choose to change or even ignore the recommendation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the dynamic pseudo-classes can be applied to any element, which
    is good since it’s often useful to apply dynamic styles to elements that aren’t
    links. Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: By using this markup, you could highlight a form element that is ready to accept
    keyboard input, as shown in [Figure 3-16](#highlighting_a_form_element_that_has_foc).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0316](assets/css5_0316.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-16\. Highlighting a form element that has focus
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Two relatively new additions to the user-action pseudo-classes are `:focus-within`
    and `:focus-visible`. Let’s take the second one first.
  prefs: []
  type: TYPE_NORMAL
- en: The :focus-visible pseudo-class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `:focus-visible` class is very much like `:focus` in that it applies to
    elements that have focus, but there’s a big difference: it will match only if
    the element that has focus is an element that the user agent thinks should be
    given visible focus styles in a given situation.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, consider HTML buttons. When a button is clicked via a mouse, that
    button is given focus, the same as if we had used a keyboard interface to move
    the focus to it. As authors who care about accessibility and aesthetics, we want
    the button to have focus when it’s focused via the keyboard or another assistive
    technology, but we might not like it getting focus styles when it’s clicked or
    tapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can split this difference by using CSS such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This will put a thick dark-red outline around the button when tabbing to it
    via keyboard, but the rule won’t be applied when the button is clicked with the
    mouse.
  prefs: []
  type: TYPE_NORMAL
- en: The :focus-within pseudo-class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Building on that, `:focus-within` applies to any element that has focus, or
    any element that has a descendant with focus. Given the following CSS and HTML,
    we’ll get the result shown in [Figure 3-17](#selecting_with_focus_within):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0317](assets/css5_0317.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-17\. Selecting elements by using `:focus-within`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The third link currently has focus, having received it by the user tabbing to
    that link, and is styled with a 2-pixel outline. The `<nav>` element that contains
    it is also being given focus styling via `:focus-within`, because an element within
    itself (that is, an element descended from it) currently has focus. This adds
    a little more visual weight to that area of the page, which can be helpful. Be
    careful of overdoing it, though. Too many focus styles can create visual overload,
    potentially confusing users.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While you can style elements with `:focus` any way you like, do *not* remove
    all styling from focused elements. Differentiating which element currently has
    focus is vital for accessibility, especially for those navigating your site or
    application with a keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world issues with dynamic styling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dynamic pseudo-classes present some interesting issues and peculiarities. For
    example, you can set visited and unvisited links to one font size and make hovered
    links a larger size, as shown in [Figure 3-18](#changing_layout_with_dynamic_pseudo-clas):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0318](assets/css5_0318.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-18\. Changing layout with dynamic pseudo-classes
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, the user agent increases the size of the anchor while the mouse
    pointer hovers over it—or, thanks to the `:active` setting, when a user touches
    it on a touch screen. Because we are changing a property that impacts line height,
    a user agent that supports this behavior must redraw the document while an anchor
    is in the hover state, which could force a reflow of all the content that follows
    the link.
  prefs: []
  type: TYPE_NORMAL
- en: UI-State Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Closely related to the dynamic pseudo-classes are the *user-interface (UI) state
    pseudo-classes*, which are summarized in [Table 3-4](#ui_state_pseudo-classes-id1).
    These pseudo-classes allow for styling based on the current state of UI elements
    such as checkboxes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-4\. UI-state pseudo-classes
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `:enabled` | Refers to UI elements (such as form elements) that are enabled—that
    is, available for input |'
  prefs: []
  type: TYPE_TB
- en: '| `:disabled` | Refers to UI elements (such as form elements) that are disabled—that
    is, not available for input |'
  prefs: []
  type: TYPE_TB
- en: '| `:checked` | Refers to radio buttons or checkboxes that have been selected,
    either by the user or by defaults within the document itself |'
  prefs: []
  type: TYPE_TB
- en: '| `:indeterminate` | Refers to radio buttons or checkboxes that are neither
    checked nor unchecked; this state can be set only via DOM scripting, and not by
    user input |'
  prefs: []
  type: TYPE_TB
- en: '| `:default` | Refers to the radio button, checkbox, or option that was selected
    by default |'
  prefs: []
  type: TYPE_TB
- en: '| `:autofill` | Refers to a user input that has been autofilled by the browser
    |'
  prefs: []
  type: TYPE_TB
- en: '| `:placeholder-shown` | Refers to a user input that has placeholder (not value)
    text prefilled |'
  prefs: []
  type: TYPE_TB
- en: '| `:valid` | Refers to a user input that meets all of its data validity requirements
    |'
  prefs: []
  type: TYPE_TB
- en: '| `:invalid` | Refers to a user input that does not meet all of its data validity
    requirements |'
  prefs: []
  type: TYPE_TB
- en: '| `:in-range` | Refers to a user input whose value is between the minimum and
    maximum values |'
  prefs: []
  type: TYPE_TB
- en: '| `:out-of-range` | Refers to a user input whose value is below the minimum
    or above the maximum values allowed by the control |'
  prefs: []
  type: TYPE_TB
- en: '| `:required` | Refers to a user input that must have a value set |'
  prefs: []
  type: TYPE_TB
- en: '| `:optional` | Refers to a user input that does not need to have a value set
    |'
  prefs: []
  type: TYPE_TB
- en: '| `:read-write` | Refers to a user input that is editable by the user |'
  prefs: []
  type: TYPE_TB
- en: '| `:read-only` | Refers to a user input that is not editable by the user |'
  prefs: []
  type: TYPE_TB
- en: Although the state of a UI element can certainly be changed by user action—for
    example, a user checking or unchecking a checkbox—UI-state pseudo-classes are
    not classified as purely dynamic because they can also be affected by the document
    structure or scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Enabled and disabled UI elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thanks to both DOM scripting and HTML, you can mark a UI element (or group of
    UI elements) as being disabled. A disabled element is displayed but cannot be
    selected, activated, or otherwise interacted with by the user. Authors can set
    an element to be disabled either through DOM scripting or by adding a `disabled`
    attribute to the element’s markup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any element that can be disabled, but hasn’t been, is by definition enabled.
    You can style these two states by using the `:enabled` and `:disabled` pseudo-classes.
    It’s much more common to style disabled elements and leave enabled elements alone,
    but both have their uses, as illustrated in [Figure 3-19](#styling_enabled_and_disabled_ui_elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0319](assets/css5_0319.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-19\. Styling enabled and disabled UI elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Check states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to being enabled or disabled, certain UI elements can be checked
    or unchecked—in HTML, the input types `checkbox` and `radio` fit this definition.
    CSS offers a `:checked` pseudo-class to handle elements in that state. In addition,
    the `:indeterminate` pseudo-class matches any checkable UI element that is neither
    checked nor unchecked. These states are illustrated in [Figure 3-20](#styling_checked_and_indeterminate_ui_ele):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0320](assets/css5_0320.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-20\. Styling checked and indeterminate UI elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although checkable elements are unchecked by default, an HTML author can toggle
    them on by adding the `checked` attribute to an element’s markup. An author can
    also use DOM scripting to flip an element’s checked state to checked or unchecked,
    whichever they prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of early 2023, the indeterminate state can be set only through DOM scripting
    or by the user agent itself; no markup-level method exists to set elements to
    an indeterminate state. The purpose of styling an indeterminate state is to visually
    indicate that the element needs to be checked (or unchecked) by the user. However,
    this is purely a visual effect: it does not affect the underlying state of the
    UI element, which is either checked or unchecked, depending on document markup
    and the effects of any DOM scripting.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the previous examples show styled radio buttons, remember that direct
    styling of radio buttons and checkboxes with CSS is actually very limited. Nevertheless,
    that shouldn’t limit your use of the selected-option pseudo-classes. As an example,
    you can style the labels associated with your checkboxes and radio buttons by
    using a combination of `:checked` and the adjacent sibling combinator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'If you need to select all checkboxes that are not checked, use the negation
    pseudo-class (which is covered later in the chapter) like this: `input[type="checkbox"]:not(:checked)`.
    Only radio buttons and checkboxes can be checked. Note that every element, and
    these two when not checked, are `:not(:checked)`. This approach does not fill
    the gap left by the absence of an `:unchecked` pseudo-class, and such a pseudo-class
    should match only elements that should be checkable.'
  prefs: []
  type: TYPE_NORMAL
- en: Default-value pseudo-classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Three pseudo-classes relate to default values and filler text: `:default`,
    `:placeholder-shown`, and `:autofill`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `:default` pseudo-class matches the UI elements that are the default among
    a set of similar elements. This typically applies to context menu items, buttons,
    and select lists/menus. If there are several same-named radio buttons, the one
    that was originally selected (if any) matches `:default`, even if the UI has been
    updated by the user so that it no longer matches `:checked`. If a checkbox was
    checked on page load, `:default` matches it. Any initially selected option(s)
    in a `select` element will match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `:default` pseudo-class will also match a form’s default button, which is
    generally the first `button` element in DOM order that is a member of a given
    form. This could be used to indicate to users which button will be activated if
    they just hit Enter, instead of explicitly selecting a button to activate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `:placeholder-shown` pseudo-class is similar in that it will select any
    input that has placeholder text defined at the markup level while that placeholder
    text is visible. The placeholder is no longer shown when the input has a value.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the value of a `placeholder` attribute will be placed into the
    input fields in a browser, usually in a lighter color than normal text. If you
    want to style those input elements in a consistent way, you can do something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: This selects the input as a whole, not the placeholder text. (To style the placeholder
    text itself, see [“The Placeholder Text Pseudo-Element”](#the_placeholder_text_pseudo).)
  prefs: []
  type: TYPE_NORMAL
- en: 'The `:autofill` pseudo-class is a little bit different from the other two:
    it matches any element that has had its value automatically filled in or auto-completed
    by the browser. This may be familiar to you if you’ve ever filled out a form by
    having the browser fill in stored values of your name, email, mailing address,
    and so on. The input fields that are filled in usually get a distinct style, like
    a yellowish background. You can add to that using `:autofill`, perhaps like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While you can add to default browser styling of autofilled text, overriding
    the browser’s built-in styles for things such as background colors is difficult.
    This is because the browsers’ styles for autofilled fields are set to override
    just about anything else, largely as a way to provide users with a consistent
    experience of autofilled content and to protect the user.
  prefs: []
  type: TYPE_NORMAL
- en: Optionality pseudo-classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `:required` pseudo-class matches any user-input element that is required,
    as denoted by the presence of the `required` attribute. The `:optional` pseudo-class
    matches user-input elements that do not have the `required` attribute, or whose
    `required` attribute has a value of `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user-input element is `:required` if the user must provide a value for before
    submitting the form to which it belongs. All other user-input elements are matched
    by `:optional`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The first email input will match the `:required` pseudo-class because of the
    presence of the `required` attribute. The second input is optional and therefore
    will match the `:optional` pseudo-class. The same is true for the third input,
    which has a `required` attribute, but the value is `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Elements that are not user-input elements can be neither required nor optional.
    Including the `required` attribute on a non-user-input element won’t lead to an
    optionality pseudo-class match.
  prefs: []
  type: TYPE_NORMAL
- en: Validity pseudo-classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `:valid` pseudo-class refers to a user input that meets all of its data
    validity requirements. The `:invalid` pseudo-class, on the other hand, refers
    to a user input that does not meet all of its data validity requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The validity pseudo-classes `:valid` and `:invalid` apply only to elements
    having the capacity for data validity requirements: a `<div>` will never match
    either selector, but an `<input>` could match either, depending on the current
    state of the interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, an image is dropped into the background of any email
    input that has focus, with one image being used when the input is invalid and
    another used when the input is valid, as illustrated in [Figure 3-21](#styling_valid_and_invalid_inputs):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0321](assets/css5_0321.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-21\. Styling valid and invalid UI elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Keep in mind that these pseudo-class states may not act as you might expect.
    For example, as of late 2022, any empty email input that isn’t required matches
    `:valid`. Even though a null input is not a valid email address, failing to enter
    an email address is a valid response for an optional input. If you try to fill
    in a malformed address or just some random text, that will be matched by `:invalid`
    because it isn’t a valid email address.
  prefs: []
  type: TYPE_NORMAL
- en: Range pseudo-classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The range pseudo-classes include `:in-range`, which refers to a user input whose
    value is between the minimum and maximum values set by HTML’s `min` and `max`
    attributes, and `:out-of-range`, which refers to a user input whose value is below
    the minimum or above the maximum values allowed by the control.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider a number input that accepts numbers in the range 0 to
    1,000:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a value from 0 to 1,000, inclusive, would mean the `input`
    element is matched by `:in-range`. Any value outside that range, whether input
    by the user or assigned via the DOM, will cause the `input` to match `:out-of-range`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: The `:in-range` and `:out-of-range` pseudo-classes apply *only* to elements
    with range limitations. User inputs that don’t have range limitations, like links
    for inputs of type `tel`, will not be matched by either pseudo-class.
  prefs: []
  type: TYPE_NORMAL
- en: HTML also has a `step` attribute. If a value is invalid because it does not
    match the `step` value, but is still between or equal to the `min` and `max` values,
    it will match `:invalid` while *also* still matching `:in-range`. A value can
    be in range while also being invalid.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, in the following scenario, the input’s value will be both red and boldfaced,
    because the value `23` is in range but is not evenly divisible by 10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Mutability pseudo-classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mutability pseudo-classes include `:read-write`, which refers to a user
    input that is editable by the user; and `:read-only`, which matches user inputs
    that are not editable, including radio buttons and checkboxes. Only elements that
    can have their values altered by user input can match `:read-write`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in HTML, a nondisabled, non-read-only `input` element is `:read-write`,
    as is any element with the `contenteditable` attribute. Everything else matches
    `:read-only`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, neither of the following rules would ever match, because `<textarea>`
    elements are read-write, and `<pre>` elements are read-only:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'However, each can be made to match as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Because `<textarea>` is given a `disabled` attribute, it becomes read-only,
    and so will have the first rule apply. Similarly, the `<pre>` here has been made
    editable via the `contenteditable` attribute, so now it is a read-write element.
    This will be matched by the second rule.
  prefs: []
  type: TYPE_NORMAL
- en: The :lang() and :dir() Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to select an element based on its language, you can use the `:lang()`
    pseudo-class. In terms of its matching patterns, this pseudo-class is similar
    to the `|=` attribute selector (see [“Selection Based on Partial Attribute Values”](ch02.html#selection_based_on_partial_attribute_val)).
    For example, to italicize elements whose content is written in French, you could
    write either of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary difference between the pseudo-class selector and the attribute
    selector is that language information can be derived from multiple sources, some
    of which are outside the element itself. For the attribute selector, the element
    must have the attribute present to match. The `:lang()` pseudo-class, on the other
    hand, matches descendants of an element with the language declaration. As [Selectors
    Level 3](https://www.w3.org/TR/selectors-3/#lang-pseudo) states:'
  prefs: []
  type: TYPE_NORMAL
- en: In HTML, the language is determined by a combination of the `lang` attribute,
    and possibly information from the `meta` elements and the protocol (such as HTTP
    headers). XML uses an attribute called `xml:lang`, and there may be other document
    language-specific methods for determining the language.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The pseudo-class will operate on all of that information, whereas the attribute
    selector can work only if a `lang` attribute is present in the element’s markup.
    Therefore, the pseudo-class is more robust than the attribute selector and is
    probably a better choice in most cases where language-specific styling is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'CSS also has a `:dir()` pseudo-class, which selects elements based on the HTML
    direction of an element. So you could, for example, select all the elements whose
    direction is right to left like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The thing to watch out for here is that the `:dir()` pseudo-class selects elements
    based on their directionality in HTML, and not the value of the `direction` property
    in CSS that may be applied to them. Thus, the only two values you can really use
    for selection are `ltr` (left to right) and `rtl` (right to left) because those
    are the only direction values that HTML supports.
  prefs: []
  type: TYPE_NORMAL
- en: Logical Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Beyond structure and language, some pseudo-classes are intended to bring a touch
    of logic and flexibility to CSS selectors.
  prefs: []
  type: TYPE_NORMAL
- en: The negation pseudo-class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every selector we’ve covered thus far has had one thing in common: they’re
    all positive selectors. They are used to identify the things that should be selected,
    thus excluding by implication all the things that don’t match and are thus not
    selected.'
  prefs: []
  type: TYPE_NORMAL
- en: For those times when you want to invert this formulation and select elements
    based on what they are *not*, CSS provides the negation pseudo-class, `:not()`.
    It’s not quite like any other selector, fittingly enough, and it does have some
    restrictions on its use, but let’s start with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us suppose you want to apply a style to every list item that does not have
    a `class` of `moreinfo`, as illustrated in [Figure 3-22](#styling_list_items_that_donat_have_a_cer).
    That used to be very difficult, and in certain cases impossible, to make happen.
    Now we can declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0322](assets/css5_0322.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-22\. Styling list items that don’t have a certain class
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The way `:not()` works is that you attach it to a selector, and then in the
    parentheses you fill in a selector or group of selectors describing what the original
    selector cannot match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s flip around the previous example and select all elements with a class
    of `moreinfo` that are not list items. This is illustrated in [Figure 3-23](#styling_elements_with_a_certain_class_th):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0323](assets/css5_0323.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-23\. Styling elements with a certain class that aren’t list items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Translated into English, the selector would say, “Select all elements with a
    class whose value contains the word `moreinfo` as long as they are not `<li>`
    elements.” Similarly, the translation of `li:not(.moreinfo)` would be, “Select
    all `<li>` elements as long as they do not have a class whose value contains the
    word `moreinfo`.”
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the negation pseudo-class at any point in a more complex selector.
    Thus, to select all tables that are not children of a `<section>` element, you
    would write `*:not(section) > table`. Similarly, to select table header cells
    that are not part of the table header, you’d write something like `table *:not(thead)
    > tr > th`, with a result like that shown in [Figure 3-24](#styling_table_cells_that_arenat_in_the_t).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0324](assets/css5_0324.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-24\. Styling header cells outside the table’s head area
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What you cannot do is nest negation pseudo-classes; thus, `p:not(:not(p))` is
    not valid and will be ignored. It’s also, logically, the equivalent of just writing
    `p`, so there’s no point anyway. Furthermore, you cannot reference pseudo-elements
    (which we’ll cover shortly) inside the parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, you can put a universal selector into the parentheses, but there’s
    little point. After all, `p:not(*)` would mean “select any `<p>` element as long
    as it isn’t any element,” and there’s no such thing as an element that is not
    an element. Similarly, `p:not(p)` would also select nothing. It’s also possible
    to write things like `p:not(div)`, which will select any `<p>` element that is
    not a `<div>` element—in other words, all of them. Again, there is little reason
    to do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, it’s possible to chain negations together to create a sort
    of “and also not this” effect. For example, you might want to select all elements
    with a class of `link` that are neither list items nor paragraphs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'That translates to “select all elements with a class whose value contains the
    word `link` as long as they are neither `<li>` nor `<p>` elements.” This used
    to be the only way to exclude a group of elements, but CSS (and browsers) support
    selector lists in negations. That allows us to rewrite the previous example like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Along with this came the ability to use more complex selectors, such as those
    using descendant combinators. If you need to select all elements that are descended
    from a `<form>` element but do not immediately follow a `<p>` element, you could
    write it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'Translated, that’s “select any element that is not the adjacent sibling `<p>`
    element, and is also the descendant of a `<form>` element.” And you can put these
    into groups, so if you also want to exclude list items and table-header cells,
    it would go something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ability to use complex selectors in `:not()` came to browsers in only early
    2021, so exercise caution when using it, especially in legacy settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing to watch out for with `:not()` is that in some situations rules can
    combine in unexpected ways, mostly because we’re not used to thinking of selection
    in the negative. Consider this test case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'The paragraph will be boldfaced, not normal weight. This is because both rules
    match: the `<p>` element is descended from a `<div>` whose class does not contain
    the word `one` (`<div class="two">`), but it is *also* descended from a `<div>`
    whose class contains the word `one`. Both rules match, so both apply. Since a
    conflict exists, the cascade (which is explained in [Chapter 4](ch04.html#specificity_comma_inheritance))
    is used to resolve the conflict, and the second rule wins. The structural arrangement
    of the markup, with the `div.two` being “closer” to the paragraph than `div.one`,
    is irrelevant.'
  prefs: []
  type: TYPE_NORMAL
- en: The :is() and :where() pseudo-classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSS has two pseudo-classes that allow for group matching within a complex selector,
    `:is()` and `:where()`. These are almost identical to each other, with just a
    minor difference that we’ll cover once you understand how they work. Let’s start
    with `:is()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to select all list items, whether or not they are part of
    an ordered or an unordered list. The traditional way to do that is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'With `:is()`, we can rewrite that like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'The matched elements will be exactly the same: all list items that are part
    of either ordered or unordered lists.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem slightly pointless: the syntax is not only slightly less clear,
    but also one character longer. And it’s true that in simple situations like that,
    `:is()` isn’t terribly compelling. The more complex the situation, though, the
    more likely `:is()` will really shine.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, what if we want to style all list items that are at least two
    levels deep in nested lists, no matter what combination of ordered and unordered
    lists are above them? Compare the following rules, both of which will have the
    effect shown in [Figure 3-25](#using_matches_any_to_select), except one uses the
    traditional approach and the other uses `:is()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0325](assets/css5_0325.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-25\. Using `:is()` to select elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now consider what the traditional approach would look like for three, four,
    or even more levels deep of nested lists!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `:is()` pseudo-class can be used in all sorts of situations; selecting
    all links inside lists that are themselves inside headers, footers, and `<nav>`
    elements could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'Even better: the list of selectors inside `:is()` is what’s called a *forgiving
    selector list*. By default, if any one thing in a selector is invalid, the whole
    rule is marked invalid. Forgiving selector lists, on the other hand, will throw
    any part that’s invalid and honor the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: So, given all that, what’s the difference between `:is()` and `:where()`? The
    sole difference is that `:is()` takes the specificity of the most-specific selector
    in its selector list, whereas `:where()` has zero specificity. If that last sentence
    didn’t make sense to you, don’t worry! We haven’t discussed specificity yet but
    will in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`:is()` and `:where()` came to browsers in only early 2021, so exercise caution
    when using them, especially in legacy settings.'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting defined elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the web has advanced, it’s added more and more capabilities. One of the more
    recent is the ability to add custom HTML elements to your markup in a standardized
    way. This happens a lot with pattern libraries, which often define Web Components
    based on elements that are specific to the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing such libraries do to be more efficient is hold off on defining an
    element until it’s needed, or it’s ready to be populated with whatever content
    is supposed to go into it. Such a custom element might look like this in markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: The actual goal is to fill that combobox (a drop-down list that also allows
    users to enter arbitrary values) with whatever options the backend CMS provides
    for it, downloaded via a script that requests the latest data in order to build
    the list locally, and removing the placeholder text in the process. However, what
    happens if the server fails to respond, leaving the custom element undefined and
    stuck with its placeholder text? Without taking steps, the text “options go here”
    will get inserted into the page, probably with minimal styling.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s where `:defined` comes in. You can use it to select any defined element,
    and combine it with `:not()` to select elements that aren’t yet defined. Here’s
    a simple way to hide undefined comboboxes, as well as to apply styles to defined
    comboboxes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: The :has() Pseudo-Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `:has()` pseudo-class is a little bit tricky, because it doesn’t quite follow
    all the rules we’ve been working under until now—but as a result, it’s also *insanely*
    powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you want to apply special styles to any `<div>` element that contains
    an image. In other words, if a `<div>` element *has* an `<img>` element inside
    it, you want to apply certain styles to the `<div>`. And that’s exactly what `:has()`
    makes possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous example would be written something like this, with the result
    illustrated in [Figure 3-26](#using_has_to_select_elements):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0326](assets/css5_0326.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-26\. Using `:has()` to select elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The second `<div>`, which does not have an `<img>` element as a descendant,
    doesn’t get the border. If you wanted only the first `<div>` to get the border,
    because you actually wanted to style only `<div>` elements that have images as
    direct children, just modify the selector to use the child combinator, like this:
    `div:has(> img)`. That would prevent the third `<div>` from getting the border.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `:has()` pseudo-class is, in one real sense, the mythical “parent selector” CSS
    authors have wished for since the beginning of CSS itself. Except it isn’t just
    for parent selection, because you can select based on siblings, or make the selection
    happen as far up the ancestry chain as you like. And if all that didn’t quite
    make sense to you, hang on: we’ll explain further.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two facts to note right off the bat:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the parentheses of `:has()`, you can provide a comma-separated list of
    selectors, and each of those selectors can be simple, compound, or complex.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those selectors are considered relative to the anchor element, the element to
    which `:has()` is attached.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let’s take those in order. All of the following are valid `:has()` uses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'That last example might be a bit overwhelming, so let’s break it down a bit
    further. We could restate in a longer way, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'And here are two examples of the markup patterns that would be selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: In the first example, the selection isn’t based on parentage or any other ancestry;
    instead, the `<section>` is selected because its immediate sibling (the `<h2>`)
    has an `<em>` element as one of its descendants. In the second, the `<section>`
    is selected because it has a descendant `<table>` that’s immediately followed
    by another `<table>`, both of which happen in this case to be inside an `<aside>`
    element. That makes this specific example one of grandparent selection, not parent
    selection, because the `<section>` is a grandparent to the tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right, so that’s the first point that we raised earlier. The second is that
    the selectors inside the parentheses are relative to the element bearing the `:has()`.
    That means, for example, that the following selector is never going to match anything:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: That’s because while an `<h1>` can certainly be a descendant of a `<div>`, the
    `<html>` and `<body>` elements cannot. What that selector means, translated into
    English, is “select any `<div>` that has a descendant `<html>` which itself has
    a descendant `<body>` which has a descendant `<h1>`.” The `<html>` element will
    never be a descendant of `<div>`, so this selector can’t match.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pick something a little more realistic, here’s a bit of markup showing lists
    nested inside one another, which has the document structure shown in [Figure 3-27](#a_fragment_of_a_doc):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0327](assets/css5_0327.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-27\. A fragment of a document’s structure
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To that structure, we’ll apply the following rules. Spoiler alert: one of them
    will match an element, and the other will not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: The first causes the browser to look at all the `<ul>` elements. For any `<ul>`
    it finds, it looks at the structure of the elements that descend from that `<ul>`.
    If it finds an `li ol` relationship in the elements that descend from the `<ul>`,
    then the `<ul>` is matched, and in this case will be given a red border.
  prefs: []
  type: TYPE_NORMAL
- en: If we study the markup structure, either in the code or in [Figure 3-27](#a_fragment_of_a_doc),
    we can see two `<ul>` elements. The first has `<li>` descendants but not any `<ol>`
    descendants, so it won’t be matched. The second `<ul>` also has `<li>` descendants,
    and one of them has an `<ol>` descendant. It’s a match! The `<ul>` will be given
    a red border.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second rule also causes the browser to look at all the `<ul>` elements.
    In this case, for any `<ul>` it finds, the browser looks for an `ol ul ol` relationship
    within the descendants of the `<ul>`. Elements outside the `<ul>` don’t count:
    only those within it are considered. Of the two `<ul>` elements in the document,
    neither has an `<ol>` inside a `<ul>` that’s inside another `<ol>` that is itself
    descended from the `<ul>` being considered. There’s no match, so neither of the
    `<ul>` elements will be italicized.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even more powerfully, you’re free to mix `:has()` with other pseudo-classes.
    You might, for example, want to select any heading level if it has an image inside.
    You can do this in two ways: the long, clumsy way or the compact way. Both are
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: 'The two selectors have the same outcome: if an element *is* one of the listed
    heading elements, and that element *has* among its descendant elements an `<img>`
    element, then the heading will be selected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For that matter, you could select any headings that *don’t* have images inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: Here, if an element *is* one of the listed heading levels, but an `<img>` element
    is *not* one of the descendants it has, then the heading will be selected. If
    we bring them together and apply them to numerous headings, we get the results
    shown in [Figure 3-28](#to_has_and_has_not).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0328](assets/css5_0328.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-28\. To has and has not
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As you can already see, this selector has a lot of power. Dangers also exist:
    it is entirely possible to write selectors that cause major performance hits to
    the browser, especially in settings where scripting may be used to modify the
    document structure. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: This is saying, “Apply these styles to any `<div>` that has an element with
    a class of `popup` as a descendant.” When the page is loaded into the browser,
    it has to check all the `<div>` elements to see if they match this selector. That
    could mean a few trips up and down the document’s structural tree, but ideally
    it would resolve in a few milliseconds, and the page can then be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: But suppose we have a script that can add `.popup` to an element, or even several
    elements, on the page. As soon as the class values change, the browser has to
    check not only whether any styles apply to `.popup` elements and their descendants,
    but also whether any ancestor or sibling elements are affected by this change.
    Instead of looking only down the document tree, the browser now has to look up
    as well. And any change triggered by this could mean changes all throughout the
    page’s layout, both when an element is marked as `.popup` and whenever a `.popup`
    element loses that class value, potentially affecting elements in entirely different
    parts of the document.
  prefs: []
  type: TYPE_NORMAL
- en: This sort of performance hit is why there hasn’t been a “parent selector” or
    anything like it before. Computers are getting fast enough, and browser engines
    smart enough, that this is much less of a worry than it was in the past—but it’s
    still something to keep in mind and test out thoroughly.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It is not possible to nest pseudo-elements like `::first-line` or `::selection`
    in `has()`. (We’ll discuss pseudo-elements shortly.)
  prefs: []
  type: TYPE_NORMAL
- en: Other Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even more pseudo-classes are defined in the CSS Selectors specification, but
    they are partially supported in browsers, or in some cases not supported at all
    as of early 2023, or else are things we’ll cover elswhere in the book. We’re listing
    them in [Table 3-5](#other_pseudo-classes) for the sake of completeness, and to
    point you toward pseudo-classes that might be supported between this edition of
    the book and the next one. (Or could be replaced with an equivalent pseudo-class
    with a different name; that happens sometimes.)
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-5\. Other pseudo-classes
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `:nth-col()` | Refers to table cells or grid items that are in an nth column,
    which is found using the *an* + *b* pattern; essentially the same as `:nth-child()`,
    but refers specifically to table or grid columns |'
  prefs: []
  type: TYPE_TB
- en: '| `:nth-last-col()` | Refers to table cells or grid items that are in an nth-last
    column, which is found using the *an* + *b* pattern; essentially the same as `:nth-last-child()`,
    but refers specifically to table or grid columns |'
  prefs: []
  type: TYPE_TB
- en: '| `:left` | Refers to any lefthand page in a printed document; see [Chapter 21](ch21.html#css-at-rules)
    for more |'
  prefs: []
  type: TYPE_TB
- en: '| `:right` | Refers to any righthand page in a printed document; see [Chapter 21](ch21.html#css-at-rules)
    for more |'
  prefs: []
  type: TYPE_TB
- en: '| `:fullscreen` | Refers to an element that is being displayed full-screen
    (e.g., a video that’s in full-screen mode) |'
  prefs: []
  type: TYPE_TB
- en: '| `:past` | Refers to an element that appeared before (in time) an element
    being matched by `:current` |'
  prefs: []
  type: TYPE_TB
- en: '| `:current` | Refers to an element, or the ancestor of an element, that is
    currently being displayed in a time-based format like a video (e.g., an element
    containing closed-caption text) |'
  prefs: []
  type: TYPE_TB
- en: '| `:future` | Refers to an element that will appear after (in time) an element
    being matched by `:current` |'
  prefs: []
  type: TYPE_TB
- en: '| `:paused` | Refers to any element that can have the states “playing” or “paused”
    (e.g., audio, video, etc.) when it is in the “paused” state |'
  prefs: []
  type: TYPE_TB
- en: '| `:playing` | Refers to any element that can have the states “playing” or
    “paused” (e.g., audio, video, etc.) when it is in the “playing” state |'
  prefs: []
  type: TYPE_TB
- en: '| `:picture-in-picture` | Refers to an element that is used as a picture-in-picture
    display |'
  prefs: []
  type: TYPE_TB
- en: Pseudo-Element Selectors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much as pseudo-classes assign phantom classes to anchors, *pseudo-elements*
    insert fictional elements into a document in order to achieve certain effects.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the single colon of pseudo-classes, pseudo-elements employ a double-colon
    syntax, like `::first-line`. This is meant to distinguish pseudo-elements from
    pseudo-classes. This was not always the case—in CSS2, both selector types used
    a single colon—so for backward compatibility, browsers may accept some single-colon
    pseudo-type selectors. Don’t take this as an excuse to be sloppy, though! Use
    the proper number of colons at all times to future-proof your CSS; after all,
    there is no way to predict when browsers will stop accepting single-colon pseudo-type
    selectors.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the First Letter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `::first-letter` pseudo-element styles the first letter, or a leading punctuation
    character and the first letter (if the text starts with punctuation), of any non-inline
    element. This rule causes the first letter of every paragraph to be colored red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'The `::first-letter` pseudo-element is most commonly used to create an initial-cap
    or drop-cap typographic effect. You could make the first letter of each `<p>`
    twice as big as the rest of the heading, though you may want to apply this styling
    to only the first letter of the first paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 3-29](#the_colon_colon_first-letter_pseudo-elem) illustrates the result
    of this rule.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0329](assets/css5_0329.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-29\. The `::first-letter` pseudo-element in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This rule effectively causes the user agent to style a fictional, or faux,
    element that encloses the first letter of each `<p>`. It would look something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: The `::first-letter` styles are applied only to the contents of the fictional
    element shown in the example. This `<p-first-letter>` element does *not* appear
    in the document source, nor even in the DOM tree. Instead, its existence is constructed
    on the fly by the user agent and is used to apply the `::first-letter` style(s)
    to the appropriate bit of text. In other words, `<p-first-letter>` is a pseudo-element.
    Remember, you don’t have to add any new tags. The user agent styles the first
    letter for you as if you had encased it in a styled element.
  prefs: []
  type: TYPE_NORMAL
- en: The first letter is defined as the first typographic letter unit of the originating
    element, if it is not preceded by other content, like an image. The specifications
    use the term letter unit because some languages have letters made up of more than
    one character, like *œ* in Old West Norse. Punctuation that precedes or follows
    the first letter unit, even if there are several such symbols, should be included
    in the `::first-letter` pseudo-element. The browser does this for you.
  prefs: []
  type: TYPE_NORMAL
- en: Styling the First Line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Similarly, `::first-line` can be used to affect the first line of text in an
    element. For example, you could make the first line of each paragraph in a document
    large and purple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: In [Figure 3-30](#the_colon_colon_first-line_pseudo-elemen), the style is applied
    to the first displayed line of text in each paragraph. This is true no matter
    how wide or narrow the display region is. If the first line contains only the
    first five words of the paragraph, only those five words will be big and purple.
    If the first line contains the first 30 words of the element, all 30 will be big
    and purple.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0330](assets/css5_0330.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-30\. The `::first-line` pseudo-element in action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Because the text from “This” to “only” should be big and purple, the user agent
    employs a fictional markup that looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If the first line of text were edited to include only the first seven words
    of the paragraph, the fictional `</p-first-line>` would move back and occur just
    after the word “that.” If the user were to increase or decrease the font-size
    rendering, or expand or contract the browser window causing the width of the text
    to change, thereby causing the number of words on the first line to increase or
    decrease, the browser automatically sets only the words in the currently displayed
    first line to be both big and purple.
  prefs: []
  type: TYPE_NORMAL
- en: The length of the first line depends on multiple factors, including the font
    size, letter spacing, and width of the parent container. Depending on the markup
    and the length of that first line, the end of the first line could come in the
    middle of a nested element. If the `::first-line` breaks up a nested element,
    such as an `em` or a hyperlink, the properties attached to the `::first-line`
    will apply to only the portion of that nested element that is displayed on the
    first line.
  prefs: []
  type: TYPE_NORMAL
- en: Restrictions on ::first-letter and ::first-line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `::first-letter` and `::first-line` pseudo-elements currently can be applied
    only to block-display elements such as headings or paragraphs, and not to inline-display
    elements such as hyperlinks. There are also limits on the CSS properties that
    may be applied to `::first-line` and `::first-letter`. [Table 3-6](#properties_permitted_on_pseudo-elements)
    gives an idea of these limitations. Like all pseudo-elements, neither can be included
    in `:has()` or `:not()`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-6\. Properties permitted on pseudo-elements
  prefs: []
  type: TYPE_NORMAL
- en: '| `::first-letter` | `::first-line` |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: All font properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All background properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All text decoration properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All inline typesetting properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All inline layout properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All border properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`box-shadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opacity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: All font properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All background properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All margin properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All padding properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All border properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All text decoration properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All inline typesetting properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opacity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: The Placeholder Text Pseudo-Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As it happens, the restrictions on what styles can be applied via `::first-line`
    are exactly the same as the restrictions on styles applied via `::placeholder`.
    This pseudo-element matches any placeholder text placed into text inputs and textareas.
    You could, for example, italicize text input placeholder text and turn textarea
    placeholder text a dusky blue like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'For both `<input>` and `<textarea>` elements, this text is defined by the `placeholder`
    attribute in HTML. The markup will look something very much like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: If text is prefilled using the `value` attribute on `<input>` elements, or by
    placing content inside the `<textarea>` element, that will override the value
    of any `placeholder` attribute, and the resulting text won’t be selected with
    the `::placeholder` pseudo-element.
  prefs: []
  type: TYPE_NORMAL
- en: The Form Button Pseudo-Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Speaking of form elements, it’s also possible to directly select the file-selector
    button—and *only* the file-selector button—in an `<input>` element that has a
    `type` of `file`. This gives you a way to call attention to the button a user
    needs to click to open the file-selection dialog, even if no other part of the
    input can be directly styled.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’ve never seen a file-selection input, it usually looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'That second line gets replaced with a control whose appearance is dependent
    on the combination of operating system and browser, so it tends to look at least
    a little different (sometimes a lot different) from one user to the next. [Figure 3-31](#styling_button_file_submission)
    shows one possible rendering of the input, with the button styled by the following
    CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0331](assets/css5_0331.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-31\. Styling the button in a file-submission input
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Generating Content Before and After Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say you want to preface every `<h2>` element with a pair of silver square
    brackets as a typographical effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: CSS lets you insert *generated content*, and then style it directly using the
    pseudo-elements `::before` and `::after`. [Figure 3-32](#inserting_content_before_an_element)
    illustrates an example.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0332](assets/css5_0332.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-32\. Inserting content before an element
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The pseudo-element is used to insert the generated content and to style it.
    To place content at the end of an element, right before the closing tag, use the
    pseudo-element `::after`. You could end your documents with an appropriate finish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: Conversely, if you want to insert some content at the beginning of an element,
    right after the opening tag, use `::before`. Just remember that in either case,
    you have to use the `content` property in order to insert something to style.
  prefs: []
  type: TYPE_NORMAL
- en: Generated content is its own subject, and the entire topic (including more detail
    on `::before`, `::after`, and `content`) is covered more thoroughly in [Chapter 16](ch16.html#lists-and-generated-content).
  prefs: []
  type: TYPE_NORMAL
- en: Highlight Pseudo-Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A relatively new concept in CSS is the ability to style pieces of content that
    have been highlighted, either by user selection or by the user agent itself. These
    are summarized in [Table 3-7](#highlight_pseudo-elements).
  prefs: []
  type: TYPE_NORMAL
- en: Table 3-7\. Highlight pseudo-elements
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `::selection` | Refers to any part of a document that has been highlighted
    for user operation (e.g., text that has been drag-selected with a mouse) |'
  prefs: []
  type: TYPE_TB
- en: '| `::target-text` | Refers to the text of a document that has been targeted;
    this is distinct from the `:target` pseudo-class, which refers to a targeted element
    as a whole, not a fragment of text |'
  prefs: []
  type: TYPE_TB
- en: '| `::spelling-error` | Refers to the part of a document that has been marked
    by the user agent as a misspelling |'
  prefs: []
  type: TYPE_TB
- en: '| `::grammar-error` | Refers to the part of a document that has been marked
    by the user agent as a grammar error |'
  prefs: []
  type: TYPE_TB
- en: Of the four pseudo-elements in [Table 3-7](#highlight_pseudo-elements), only
    one, `::selection`, has any appreciable support as of early 2023\. So we’ll explore
    it and leave the others for a future edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'When someone uses a mouse pointer to click-hold-and-drag in order to highlight
    some text, that’s a selection. Most browsers have default styles set for text
    selection. Authors can apply a limited set of CSS properties to such selections,
    overriding the browser’s default styles, by styling the `::selection` pseudo-element.
    Let’s say you want selected text to be white on a navy-blue background. The CSS
    would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'The primary use cases for `::selection` are specifying a color scheme for selected
    text that doesn’t clash with the rest of the design, or defining different selection
    styles for different parts of a document. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Be careful in styling selection highlights: users generally expect text they
    select to look a certain way, usually defined by settings in their operating system.
    Thus, if you get too clever with selection styling, you could confuse users. That
    said, if you know that selected text can be difficult to see because your design’s
    colors tend to obscure it, defining more obvious highlight styles is probably
    a good idea.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that selected text can cross element boundaries, and that multiple selections
    can occur within a given document. Imagine that a user selects text starting from
    the middle of one paragraph to the middle of the next. In effect, each paragraph
    will get its own selection pseudo-element nested inside, and selection styling
    will be handled as appropriate for the context. Given the following CSS and HTML,
    you’ll get a result like that shown in [Figure 3-33](#selection_styling):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0333](assets/css5_0333.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-33\. Selection styling
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'This underscores a point made earlier: *be careful* with your selection styling.
    It is all too easy to make text unreadable for some users, particularly if your
    selection styles interact badly with the user’s default selection styles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, for user privacy reasons, you can apply only a limited number
    of CSS properties to selections: `color`, `background-color`, `text-decoration`
    and related properties, `text-shadow`, and the `stroke` properties (in SVG).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As of early 2023, selections do not have their styles inherited: selecting
    text containing some inline elements will apply the selection styling to the text
    outside the inline elements, but not within the inline elements. It is not clear
    if this behavior is intended, but it is consistent across major browsers.'
  prefs: []
  type: TYPE_NORMAL
- en: Beyond `::selection`, there will likely be increasing support for `::target-text`.
    As of early 2023, this is supported in only Chromium browsers, which introduced
    a feature that needs it. With this feature, text can be added to the end of a
    URL as part of the fragment identifier for highlighting, in order to draw attention
    to one or more parts of the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a URL might look something like: `https://example.org/#:~:text=for%20use%20in%20illustrative%20examples`.
    The part at the end says to the browser, “Once you’ve loaded the page, highlight
    any examples of this text.” The text is encoded for use in URLs, which is why
    it’s filled with `%20` strings—they represent spaces. The result will look something
    like [Figure 3-34](#target_text_styling).'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0334](assets/css5_0334.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3-34\. Targeted text styling
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you wanted to suppress this content highlighting on your own pages, you
    might do something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: As for `::spelling-error` and `::grammar-error`, these are meant to apply highlighting
    of some sort to any spelling or grammar errors within a document. You can see
    the utility for something like Google Docs or the editing fields of CMSs like
    WordPress or Craft. For most other applications, though, they seem unlikely to
    be very popular. Regardless, as of this writing, there is no browser support for
    either, and the Working Group is still hashing out the details of how they should
    work.
  prefs: []
  type: TYPE_NORMAL
- en: The Backdrop Pseudo-Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Suppose you have an element that’s being presented full-screen, like a video.
    Furthermore, suppose that element doesn’t neatly fill the screen all the way to
    the edges, perhaps because the aspect ratio of the element doesn’t match the aspect
    ratio of the screen. What should be filled in for the parts of the screen that
    the element doesn’t cover? And how would you select that non-element region with
    CSS?
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `::backdrop` pseudo-element. This represents a box that’s the exact
    size of the full-screen viewport, and it is always drawn beneath a full-screen
    element. So you might put a dark-gray backdrop behind any full-screen video like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: CSS doesn’t restrict which styles can be applied to backdrops, but since they’re
    essentially empty boxes placed behind a full-screen element, most of the time
    you’ll probably be setting background colors or images.
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to remember is that backdrops do *not* participate in inheritance.
    They can’t inherit styles from ancestor elements, nor do they pass any of their
    styles on to any children. Whatever styles you apply to the backdrop will exist
    in their own little pocket universe.
  prefs: []
  type: TYPE_NORMAL
- en: The Video-Cue Pseudo-Element
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the subject of videos, videos often have Web Video Text Tracks (WebVTT) data
    containing the text captions enabling accessibility. These captions are known
    as *cues* and can be styled with the `::cue` pseudo-element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have a video that’s mostly dark, with a few light segments. You
    might style the cues to be a lightish-gray text on a translucent dark background,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: This will always apply to the currently visible cue.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also select parts of individual cues by using a selector pattern inside
    parentheses. This can be used to style specific elements defined in the WebVTT
    data, drawn from a small list allowed by the WebVTT specification. For example,
    any italicized cue text could be selected as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'You could use structural pseudo-classes like `:nth-child`, but these will apply
    only within a given cue, not across cues. You can’t select every other cue for
    styling, but you can select every other element within a given cue. Assume the
    following WebVTT data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'The second cue includes two lines of text. These are treated as separate elements,
    in effect, even though no elements are specified. Thus, we could make the line
    Hildy says (indicated with `<v Hildy>`, which is the WebVTT equivalent of `<v
    voice="Hildy">`) boldface, and give alternate colors to the two lines of dialog
    in the second cue, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'As of early 2023, a limited range of properties can be applied to cues:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`background` and its associated longhand properties (e.g., `background-color`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-decoration` and its associated longhand properties (e.g., `text-decoration-thickness`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-shadow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`text-combine-upright`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`font` and its associated longhand properties (e.g., `font-weight`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ruby-position`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opacity`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`visibility`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`white-space`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`outline` and its associated longhand properties (e.g., `outline-width`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shadow Pseudo-Classes and -Elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another recent innovation in HTML has been the introduction of the shadow DOM,
    which is a deep and complex subject we don’t have the space to explore here. At
    a basic level, the *shadow DOM* allows developers to create encapsulated markup,
    style, and scripting within the regular (or *light*) DOM. This keeps the styles
    and scripts of one shadow DOM from affecting any other part of the document, whether
    those parts are in the light or shadow DOM.
  prefs: []
  type: TYPE_NORMAL
- en: We’re bringing this up here because CSS does provide ways to hook into shadow
    DOMs, as well as to reach up from within a shadow DOM to select the piece of the
    light DOM that hosts the shadow. (This all sounds very panel-van artistic, doesn’t
    it?)
  prefs: []
  type: TYPE_NORMAL
- en: Shadow Pseudo-Classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see what this means, let’s bring back the combobox example from earlier
    in the chapter. It looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'All the CSS (and JS) within this custom element apply *only* to the `<mylib-combobox>`
    element. Even if the CSS within the custom element says something like `li {color:
    red;}`, that will apply to only `<li>` elements constructed within the `<mylib-combobox>`.
    It can’t leak out to turn list items elsewhere on the page red.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s all good, but what if you want to style the host element in a certain
    way from within the custom element? The host element, more generally called the
    *shadow host*, is in this case `<mylib-combobox>`. From within the shadow host,
    CSS can select the host by using the `:host` pseudo-class. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: That will reach up, so to speak, “pierce through the shadow boundary” (to use
    an evocative phrase from the specification), and select the `<mylib-combobox>`
    element, or whatever the name of the custom element containing the shadow DOM
    CSS is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, suppose there can be different kinds of comboboxes, each with its own
    class. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'You might want to style each class of combobox differently. For that, the `:host()`
    pseudo-class exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: These rules could then be included in the styles that are loaded by all comboboxes,
    using the presence of classes on the shadow hosts to style as appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: 'But wait! What if, instead of latching on to classes, we want to style our
    shadow hosts based on where they appear in the light DOM? In that case, `:host-context()`
    has you covered. Thus, we can style our comboxes one way if they’re part of a
    form, and a different way if they’re part of a header navigation element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: The first of these means “if the shadow host is the descendant of a `<form>`
    element, apply these styles.” The second means “if the shadow host is the descendant
    of a `<nav>` element that is itself descended from a `<header>` element, apply
    these styles.” To be clear, `form` and `<nav>` are *not* the shadow hosts in these
    situations! The selector in `:host-context()` is describing only the context in
    which the host needs to be placed in order to be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The four selectors that cross the shadow DOM/light DOM boundary—`:host`, `:host()`,
    and `:host-content()`, along with the `:slotted()` selector discussed next—are
    supported only when declared within the context of the shadow DOM. As of early
    2023, `:host-context()` isn’t supported in Safari or Firefox and is at risk of
    being removed from the specification.
  prefs: []
  type: TYPE_NORMAL
- en: Shadow Pseudo-Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to having hosts, shadow DOMs can also define *slots*. These are
    elements that are meant to have other things slotted into them, much as you would
    place an expansion card into an expansion slot. Let’s expand the markup of the
    combobox a little bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: Now, to be clear, the `shadow tree` isn’t actual markup. It’s just there to
    represent the shadow DOM that gets constructed by whatever script builds it. So
    please don’t go writing square-bracketed quoted element names into your documents;
    they will fail.
  prefs: []
  type: TYPE_NORMAL
- en: That said, given a setup like the preceding one, `<span>` would be slotted into
    the `slot` element, because the names match. You could try applying styles to
    the slot, but what if you’d rather style the thing that got plugged into the slot?
    That’s represented by the `::slotted()` pseudo-element, which accepts a selector
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, if you want to style all slotted elements one way and then add some extra
    style if the slotted element is a `<span>`, you would write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'More practically, you could style all slots red, and then remove that red from
    any slot that’s been slotted with content, thus making the slots that failed to
    get any content stand out. Something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The shadow DOM and its use is a complex topic, and one that we have not even
    begun to scratch the surface of in this section. Our only goal is to introduce
    the pseudo-classes and -elements that pertain to the shadow DOM, not explain the
    shadow DOM or illustrate best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in this chapter, pseudo-classes and pseudo-elements bring a whole
    lot of power and flexibility to the table. Whether selecting hyperlinks based
    on their visited state, matching elements based on their placement in the document
    structure, or styling pieces of the shadow DOM, there’s a pseudo selector for
    nearly every taste.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter and the preceding one, we’ve mentioned the concepts of specificity
    and the cascade a few times and promised to talk about them soon. Well, soon is
    now. That’s exactly what we’ll do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
