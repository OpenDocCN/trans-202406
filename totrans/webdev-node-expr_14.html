<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Routing"><div class="chapter" id="ch_routing">
<h1><span class="label">Chapter 14. </span>Routing</h1>


<p><a data-type="indexterm" data-primary="routing" id="ix_ch-14-routing-asciidoc0"/>Routing is one of the most important aspects of your website or web service; fortunately, routing in Express is simple, flexible, and robust. <a data-type="indexterm" data-primary="routing" data-secondary="basics" id="ix_ch-14-routing-asciidoc1"/><em>Routing</em> is the mechanism by which requests (as specified by a URL and HTTP method) are routed to the code that handles them. As we’ve already noted, routing used to be file based and simple. For example, if you put the file <em>foo/about.html</em> on your website, you would access it from the browser with the path <em>/foo/about.html</em>. Simple but inflexible. And, in case you hadn’t noticed, having <em>html</em> in your URL is extremely passé these days.</p>

<p><a data-type="indexterm" data-primary="information architecture (IA)" id="idm45053582514552"/>Before we dive into the technical aspects of routing with Express, we should discuss the concept of <em>information architecture</em> (IA). IA refers to the conceptual organization of your content. Having an extensible (but not overcomplicated) IA before you begin thinking about routing will pay huge dividends down the line.</p>

<p><a data-type="indexterm" data-primary="Berners-Lee, Tim" id="idm45053582512792"/>One of the most intelligent and timeless essays on IA is by Tim Berners-Lee, who practically <em>invented the internet</em>. You can (and should) read it now: <a href="http://www.w3.org/Provider/Style/URI.html"><em class="hyperlink">http://www.w3.org/Provider/Style/URI.html</em></a>. It was written in 1998. Let that sink in for a minute; there’s not much that was written on internet technology in 1998 that is just as true today as it was then.</p>

<p>From that essay, here is the lofty responsibility we are being asked to take on:</p>
<blockquote>
<p>It is the duty of a Webmaster to allocate URIs which you will be able to stand by in 2 years, in 20 years, in 200 years. This needs thought, and organization, and commitment.</p>
<p data-type="attribution">Tim Berners-Lee</p>
</blockquote>

<p><a data-type="indexterm" data-primary="URLs" data-secondary="creating for lasting IA" id="ix_ch-14-routing-asciidoc2"/><a data-type="indexterm" data-primary="URLs" data-seealso="routing" id="idm45053582506296"/>I like to think that if web design ever required professional licensing, like other kinds of engineering, that we would take an oath to that effect. (The astute reader of that article will find humor in the fact that the URL to that article ends with <em>.html</em>.)</p>

<p>To make an analogy (that may sadly be lost on the younger audience), imagine that every two years your favorite library completely reordered the Dewey decimal system. You would walk into the library one day and you wouldn’t be able to find anything. That’s exactly what happens when you redesign your URL structure.</p>

<p>Put some serious thought into your URLs. Will they still make sense in 20 years? (200 years may be a bit of a stretch: who knows if we’ll even be using URLs by then. Still, I admire the dedication of thinking that far into the future.) Carefully consider the breakdown of your content. Categorize things logically, and try not to paint yourself into a corner. It’s a science, but it’s also an art.</p>

<p>Perhaps most important, work with others to design your URLs. Even if you are the best information architect for miles around, you might be surprised at how people look at the same content with a different perspective. I’m not saying that you should try for an IA that makes sense from <em>everyone’s</em> perspective (because that is usually quite impossible), but being able to see the problem from multiple perspectives will give you better ideas and expose the flaws in your own IA.</p>

<p>Here are some suggestions to help you achieve a lasting IA:</p>
<dl>
<dt>Never expose technical details in your URLs</dt>
<dd>
<p>Have you ever been to a website, noticed that the URL ended in <em>.asp</em>, and thought that the website was hopelessly out-of-date? Remember that, once upon a time, ASP was cutting-edge. Though it pains me to say it, so too shall fall JavaScript and JSON and Node and Express. I hope it’s not for many, many productive years, but time is not often kind to technology.</p>
</dd>
<dt>Avoid meaningless information in your URLs</dt>
<dd>
<p>Think carefully about every word in your URL. If it doesn’t mean anything, leave it out. For example, it always makes me cringe when websites use the word <em>home</em> in URLs. Your root URL <em>is</em> your home page. You don’t need to additionally have URLs like <em>/home/directions</em> and <em>/home/contact</em>.</p>
</dd>
<dt>Avoid needlessly long URLs</dt>
<dd>
<p>All things being equal, a short URL is better than a longer URL. However, you should not try to make URLs short at the expense of clarity or SEO. Abbreviations are tempting, but think carefully about them. They should be common and ubiquitous before you immortalize them in a URL.</p>
</dd>
<dt>Be consistent with word separators</dt>
<dd>
<p>It’s quite common to separate words with hyphens, and a little less common to do so with underscores. Hyphens are generally considered more aesthetically pleasing than underscores, and most SEO experts recommend them. Whether you choose hyphens or underscores, be consistent in their use.</p>
</dd>
<dt>Never use whitespace or untypable characters</dt>
<dd>
<p>Whitespace in a URL is not recommended. It will usually just be converted to a plus sign (+), leading to confusion. It should be obvious that you should avoid untypable characters, and I caution you strongly against using any characters other than alphanumeric characters, numbers, dashes, and underscores. It may feel clever at the time, but “clever” has a way of not standing the test of time. Obviously, if your website is not for an English audience, you may use non-English characters (using percent codes), though that can cause headaches if you ever want to localize your website.</p>
</dd>
<dt>Use lowercase for your URLs</dt>
<dd>
<p>This one will cause some debate. There are those who feel that mixed case in URLs is not only acceptable, but preferable. I don’t want to get in a religious debate over this, but I will point out that the advantage of lowercase is that it can always automatically be generated by code. If you’ve ever had to go through a website and sanitize thousands of links or do string comparisons, you will appreciate this argument. I personally feel that lowercase URLs are more aesthetically pleasing, but in the end, this decision is up to you<a data-type="indexterm" data-startref="ix_ch-14-routing-asciidoc2" id="idm45053582470136"/>.<a data-type="indexterm" data-startref="ix_ch-14-routing-asciidoc1" id="idm45053582469240"/></p>
</dd>
</dl>






<section data-type="sect1" data-pdf-bookmark="Routes and SEO"><div class="sect1" id="idm45053582482296">
<h1>Routes and SEO</h1>

<p><a data-type="indexterm" data-primary="routing" data-secondary="SEO and" id="idm45053582467224"/><a data-type="indexterm" data-primary="search engine optimization (SEO)" id="idm45053582466056"/><a data-type="indexterm" data-primary="SEO (search engine optimization)" id="idm45053582465416"/>If you want your website to be discoverable (and most people do), then you need to think about SEO and how your URLs can affect it. In particular, if there are certain keywords that are important—<em>and it makes sense</em>—consider making them part of the URL. For example, Meadowlark Travel offers several Oregon Coast vacations. To ensure high search engine ranking for these vacations, we use the string “Oregon Coast” in the title, header, body, and meta description, and the URLs start with <em>/vacations/oregon-coast</em>. The Manzanita vacation package can be found at <em>/vacations/oregon-coast/manzanita</em>. If, to shorten the URL, we simply used <em>/vacations/manzanita</em>, we would be losing out on valuable SEO.</p>

<p>That said, resist the temptation to carelessly jam keywords into URLs in an attempt to improve your rankings. It will fail. For example, changing the Manzanita vacation URL to <em>/vacations/oregon-coast-portland-and-hood-river/oregon-coast/manzanita</em> in an effort to say “Oregon Coast” one more time, and also work the “Portland” and “Hood River” keywords in at the same time, is wrong-headed. It flies in the face of good IA and will likely backfire.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Subdomains"><div class="sect1" id="idm45053582460968">
<h1>Subdomains</h1>

<p><a data-type="indexterm" data-primary="routing" data-secondary="subdomains" id="ix_ch-14-routing-asciidoc3"/><a data-type="indexterm" data-primary="subdomains" data-secondary="routes and" id="ix_ch-14-routing-asciidoc4"/>Along with the path, subdomains are the other part of the URL that is commonly used to route requests. Subdomains are best reserved for significantly different parts of your application—for example, a REST API (<em>api.meadowlarktravel.com</em>) or an admin interface (<em>admin.meadowlarktravel.com</em>). Sometimes subdomains are used for technical reasons. For example, if we were to build our blog with WordPress (while the rest of our site uses Express), it can be easier to use <em>blog.meadowlarktravel.com</em> (a better <span class="keep-together">solution</span> would be to use a proxy server, such as NGINX). There are usually SEO <span class="keep-together">consequences</span> to partitioning your content using subdomains, which is why you should generally reserve them for areas of your site that aren’t important to SEO, such as admin areas and APIs. Keep this in mind and make sure there’s no other option before using a subdomain for content that is important to your SEO plan.</p>

<p>The routing mechanism in Express does not take subdomains into account by
default: <code>app.get(<em>/about</em>)</code> will handle requests for
<em>http://meadowlarktravel.com/about</em>,
<em>http://www.meadowlarktravel.com/about</em>, and
<em>http://admin.meadowlarktravel.com/about</em>. If you want to handle a subdomain separately, you can use
a package called <code>vhost</code> (for “virtual host,” which comes from an Apache
mechanism commonly used for handling subdomains). First, install the
package (<code>npm install vhost</code>). To test domain-based routing on your dev
machine, you’ll need some way to “fake” domain names. Fortunately,
this is what your <em>hosts file</em> is for. On macOS and Linux machines, it can
be found at <em>/etc/hosts</em>, and on Windows, it’s at
<em>c:\windows\system32\drivers\etc\hosts</em>. Add the following to your hosts
file (you will need admin privileges to edit it):</p>

<pre data-type="programlisting">127.0.0.1 admin.meadowlark.local
127.0.0.1 meadowlark.local</pre>

<p>This tells your computer to treat <code>meadowlark.local</code> and
<code>admin.meadowlark.local</code> just like regular internet domains but to map
them to localhost (127.0.0.1). We use the <code>.local</code> top-level domain so as
not to get confused (you could use <code>.com</code> or any other internet domain, but
it would override the real domain, which can lead to frustration).</p>

<p><a data-type="indexterm" data-primary="vhost middleware" id="idm45053582444888"/>Then you can use the <code>vhost</code> middleware to use domain-aware routing
(<em>ch14/00-subdomains.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// create "admin" subdomain...this should appear</code>
<code class="c1">// before all your other routes</code>
<code class="kd">var</code> <code class="nx">admin</code> <code class="o">=</code> <code class="nx">express</code><code class="p">.</code><code class="nx">Router</code><code class="p">()</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">vhost</code><code class="p">(</code><code class="s1">'admin.meadowlark.local'</code><code class="p">,</code> <code class="nx">admin</code><code class="p">))</code>

<code class="c1">// create admin routes; these can be defined anywhere</code>
<code class="nx">admin</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'*'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'Welcome, Admin!'</code><code class="p">))</code>

<code class="c1">// regular routes</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'*'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'Welcome, User!'</code><code class="p">))</code></pre>

<p><a data-type="indexterm" data-primary="express.Router()" id="idm45053582440600"/><code>express.Router()</code> essentially creates a new instance of the Express
router. You can treat this instance just like your
original instance (<code>app</code>). You can add routes and middleware just as you
would to <code>app</code>. However, it won’t do anything until you add it to <code>app</code>.
We add it through <code>vhost</code>, which binds that router instance to that
subdomain.</p>
<div data-type="tip"><h6>Tip</h6>
<p><code>express.Router</code> is also useful for partitioning your routes so that you
can link in many route handlers at once. See the
<a href="http://bit.ly/2X8VC59">Express routing documentation</a>
for more information.<a data-type="indexterm" data-startref="ix_ch-14-routing-asciidoc4" id="idm45053582388664"/><a data-type="indexterm" data-startref="ix_ch-14-routing-asciidoc3" id="idm45053582387992"/></p>
</div>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Route Handlers Are Middleware"><div class="sect1" id="idm45053582336536">
<h1>Route Handlers Are Middleware</h1>

<p><a data-type="indexterm" data-primary="middleware" data-secondary="route handlers as" id="idm45053582335160"/><a data-type="indexterm" data-primary="route handlers" data-secondary="as middleware" id="idm45053582333960"/><a data-type="indexterm" data-primary="routing" data-secondary="route handlers as middleware" id="idm45053582333016"/>We’ve already seen basic routing of matching a given path. <a data-type="indexterm" data-primary="app.get() method" id="idm45053582331976"/>But what does
<code>app.get(\'/foo', ...)</code> actually <em>do</em>? As we saw in
<a data-type="xref" href="ch10.xhtml#ch_middleware">Chapter 10</a>, it’s simply a specialized piece of middleware, down to
having a <code>next</code> method passed in. Let’s look at some more sophisticated
examples (<em>ch14/01-fifty-fifty.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/fifty-fifty'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="k">if</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mf">0.5</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'sometimes this'</code><code class="p">)</code>
<code class="p">})</code>
<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/fifty-fifty'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'and sometimes that'</code><code class="p">)</code>
<code class="p">})</code></pre>

<p>In the previous example, we have two handlers for the same route.
Normally, the first one would win, but in this case, the first one is going
to pass approximately half the time, giving the second one a chance. We
don’t even have to use <code>app.get</code> twice: you can use as many handlers as you
want for a single <code>app.get</code> call. Here’s an example that has an
approximately equal chance of three different responses
(<em>ch14/02-red-green-blue.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/rgb'</code><code class="p">,</code>
  <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// about a third of the requests will return "red"</code>
    <code class="k">if</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mf">0.33</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>
    <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'red'</code><code class="p">)</code>
  <code class="p">},</code>
  <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
    <code class="c1">// half of the remaining 2/3 of requests (so another third)</code>
    <code class="c1">// will return "green"</code>
    <code class="k">if</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">&lt;</code> <code class="mf">0.5</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>
    <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'green'</code><code class="p">)</code>
  <code class="p">},</code>
  <code class="kd">function</code><code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">){</code>
    <code class="c1">// and the last third returns "blue"</code>
    <code class="nx">res</code><code class="p">.</code><code class="nx">send</code><code class="p">(</code><code class="s1">'blue'</code><code class="p">)</code>
  <code class="p">},</code>
<code class="p">)</code></pre>

<p>While this may not seem particularly useful at first, it allows you to
create generic functions that can be used in any of your routes. For
example, let’s say we have a mechanism that shows special offers on certain
pages. The special offers change frequently, and they’re not shown on
every page. We can create a function to inject the specials into the
<code>res.locals</code> property (which you’ll remember from <a data-type="xref" href="ch07.xhtml#ch_templating">Chapter 7</a>)
(<em>ch14/03-specials.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">specials</code><code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="p">{</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">locals</code><code class="p">.</code><code class="nx">special</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getSpecialsFromDatabase</code><code class="p">()</code>
  <code class="nx">next</code><code class="p">()</code>
<code class="p">}</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/page-with-specials'</code><code class="p">,</code> <code class="nx">specials</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'page-with-specials'</code><code class="p">)</code>
<code class="p">)</code></pre>

<p>We could also implement an authorization mechanism with this approach.
Let’s say our user authorization code sets a session variable called
<code>req.session.authorized</code>. We can use the following to
make a reusable authorization filter (<em>ch14/04-authorizer.js</em> in the
companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">authorize</code><code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">session</code><code class="p">.</code><code class="nx">authorized</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'not-authorized'</code><code class="p">)</code>
<code class="p">}</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/public'</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'public'</code><code class="p">))</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/secret'</code><code class="p">,</code> <code class="nx">authorize</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'secret'</code><code class="p">))</code></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Route Paths and Regular Expressions"><div class="sect1" id="idm45053582069896">
<h1>Route Paths and Regular Expressions</h1>

<p><a data-type="indexterm" data-primary="regular expressions (regex)" id="idm45053581951480"/><a data-type="indexterm" data-primary="routing" data-secondary="route paths and regular expressions" id="idm45053581950616"/>When you specify a path (like <em>/foo</em>) in your route, it’s eventually converted to a regular expression by Express. Some regular expression metacharacters are available in route paths: <code>+</code>, <code>?</code>, <code>*</code>, <code>(</code>, and <code>)</code>. Let’s look at a couple of examples. Let’s say you want the URLs <em class="keep-together">/user</em> and <em>/username</em> to be handled by the same route:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/user(name)?'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'user'</code><code class="p">))</code></pre>

<p>One of my favorite novelty websites—now sadly defunct—was <em>http://khaaan.com</em>. All it was was everyone’s favorite starship captain belting his most iconic line. Useless, but made me smile every time. Let’s say we want to make our own “KHAAAAAAAAN” page but we don’t want our users to have to remember if it’s 2 <em>a</em>’s or 3 or 10. The following will get the job done:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/khaa+n'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'khaaan'</code><code class="p">))</code></pre>

<p>Not all normal regex metacharacters have meaning in route paths, though—only the ones listed earlier. This is important, because periods, which are normally a regex metacharacter meaning “any character,” can be used in routes unescaped.</p>

<p>Lastly, if you really need the full power of regular expressions for your route, that is supported:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="sr">/crazy|mad(ness)?|lunacy/</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'madness'</code><code class="p">)</code>
<code class="p">)</code></pre>

<p>I have yet to find a good reason for using regex metacharacters in my route paths, much less full regexes, but it’s good to be aware the functionality is there.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Route Parameters"><div class="sect1" id="idm45053581837464">
<h1>Route Parameters</h1>

<p><a data-type="indexterm" data-primary="route parameters" id="idm45053581836312"/><a data-type="indexterm" data-primary="routing" data-secondary="route parameters" id="idm45053581835608"/>While regex routes may find little day-to-day use in your Expression
toolbox, you’ll most likely be using route parameters quite
frequently. In short, it’s a way to
turn part of your route into a variable parameter. Let’s say in our
website we want to have a page for each staff member. We have a database
of staff members with bios and pictures. As our company grows, it becomes
more and more unwieldy to add a new route for each staff member. Let’s see
how route parameters can help us (<em>ch14/05-staff.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">staff</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">mitch</code><code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Mitch"</code><code class="p">,</code>
    <code class="nx">bio</code><code class="o">:</code> <code class="s1">'Mitch is the man to have at your back in a bar fight.'</code> <code class="p">},</code>
  <code class="nx">madeline</code><code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Madeline"</code><code class="p">,</code> <code class="nx">bio</code><code class="o">:</code> <code class="s1">'Madeline is our Oregon expert.'</code> <code class="p">},</code>
  <code class="nx">walt</code><code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Walt"</code><code class="p">,</code> <code class="nx">bio</code><code class="o">:</code> <code class="s1">'Walt is our Oregon Coast expert.'</code> <code class="p">},</code>
<code class="p">}</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/staff/:name'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">info</code> <code class="o">=</code> <code class="nx">staff</code><code class="p">[</code><code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">name</code><code class="p">]</code>
  <code class="k">if</code><code class="p">(</code><code class="o">!</code><code class="nx">info</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>   <code class="c1">// will eventually fall through to 404</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'05-staffer'</code><code class="p">,</code> <code class="nx">info</code><code class="p">)</code>
<code class="p">})</code></pre>

<p>Note how we used <em>:name</em> in our route. That will match any string (that doesn’t include a forward slash) and put it in the <code>req.params</code> object with the key <code>name</code>. This is a feature we will be using often, especially when creating a REST API. You can have multiple parameters in our route. For example, if we want to break up our staff listing by city, we can use this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">staff</code> <code class="o">=</code> <code class="p">{</code>
  <code class="nx">portland</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">mitch</code><code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Mitch"</code><code class="p">,</code> <code class="nx">bio</code><code class="o">:</code> <code class="s1">'Mitch is the man to have at your back.'</code> <code class="p">},</code>
    <code class="nx">madeline</code><code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Madeline"</code><code class="p">,</code> <code class="nx">bio</code><code class="o">:</code> <code class="s1">'Madeline is our Oregon expert.'</code> <code class="p">},</code>
  <code class="p">},</code>
  <code class="nx">bend</code><code class="o">:</code> <code class="p">{</code>
    <code class="nx">walt</code><code class="o">:</code> <code class="p">{</code> <code class="nx">name</code><code class="o">:</code> <code class="s2">"Walt"</code><code class="p">,</code> <code class="nx">bio</code><code class="o">:</code> <code class="s1">'Walt is our Oregon Coast expert.'</code> <code class="p">},</code>
  <code class="p">},</code>
<code class="p">}</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/staff/:city/:name'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">cityStaff</code> <code class="o">=</code> <code class="nx">staff</code><code class="p">[</code><code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">city</code><code class="p">]</code>
  <code class="k">if</code><code class="p">(</code><code class="o">!</code><code class="nx">cityStaff</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>  <code class="c1">// unrecognized city -&gt; 404</code>
  <code class="kr">const</code> <code class="nx">info</code> <code class="o">=</code> <code class="nx">cityStaff</code><code class="p">[</code><code class="nx">req</code><code class="p">.</code><code class="nx">params</code><code class="p">.</code><code class="nx">name</code><code class="p">]</code>
  <code class="k">if</code><code class="p">(</code><code class="o">!</code><code class="nx">info</code><code class="p">)</code> <code class="k">return</code> <code class="nx">next</code><code class="p">()</code>       <code class="c1">// unrecognized staffer -&gt; 404</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'staffer'</code><code class="p">,</code> <code class="nx">info</code><code class="p">)</code>
<code class="p">})</code></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Organizing Routes"><div class="sect1" id="idm45053581671688">
<h1>Organizing Routes</h1>

<p><a data-type="indexterm" data-primary="routing" data-secondary="organizing routes" id="idm45053581670440"/>It may be clear to you already that it would be unwieldy to define all of our routes in the main application file. Not only will that file grow over time, it’s also not a great separation of functionality because there’s a lot going on in that file already. A simple site may have only a dozen routes or fewer, but a larger site could have hundreds of routes.</p>

<p>So how to organize your routes? Well, how do you <em>want</em> to organize your routes? Express is not opinionated about how you organize your routes, so how you do it is limited only by your own imagination.</p>

<p>I’ll cover some popular ways to handle routes in the next sections, but at the end of the day, I recommend four guiding principles for deciding how to organize your routes:</p>
<dl>
<dt>Use named functions for route handlers</dt>
<dd>
<p>Writing route handlers inline by actually defining the function that handles the route right then and there is fine for small applications or prototyping, but it will quickly become unwieldy as your website grows.</p>
</dd>
<dt>Routes should not be mysterious</dt>
<dd>
<p>This principle is intentionally vague because a large, complex website may by necessity require a more complicated organizational scheme than a 10-page website. At one end of the spectrum is simply putting <em>all</em> of the routes for your website in one single file so you know where they are. For large websites, this may be undesirable, so you break the routes out by functional areas. However, even then, it should be clear where you should go to look for a given route. When you need to fix something, the last thing you want to do is have to spend an hour figuring out where the route is being handled. I had an ASP.NET MVC project at work that was a nightmare in this respect. The routes were handled in at least 10 different places, and it wasn’t logical or consistent and was often contradictory. Even though I was intimately familiar with that (very large) website, I still had to spend a significant amount of time tracking down where certain URLs were handled.</p>
</dd>
<dt>Route organization should be extensible</dt>
<dd>
<p>If you have 20 or 30 routes now, defining them all in one file is probably fine. What about in three years when you have 200 routes? It can happen. Whatever method you choose, you should ensure you have room to grow.</p>
</dd>
<dt>Don’t overlook automatic view-based route handlers</dt>
<dd>
<p>If your site consists of many pages that are static and have fixed URLs, all of your routes will end up looking like this: <code>app.get('/static/thing', (req, res) =&gt; res.render(\'static/thing'))</code>. To reduce needless code repetition, consider using an automatic view-based route handler. This approach is described later in this chapter and can be used together with custom routes.</p>
</dd>
</dl>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Declaring Routes in a Module"><div class="sect1" id="idm45053581532184">
<h1>Declaring Routes in a Module</h1>

<p><a data-type="indexterm" data-primary="modules" data-secondary="declaring routes in" id="idm45053581530776"/><a data-type="indexterm" data-primary="routing" data-secondary="declaring routes in a module" id="idm45053581529800"/>The first step to organizing our routes is getting them all into their own module. There are multiple ways to do this. One approach is to have your module return an array of objects containing method and handler properties. Then you could define the routes in your application file thusly:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">routes</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./routes.js'</code><code class="p">)</code>

<code class="nx">routes</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">route</code> <code class="o">=&gt;</code> <code class="nx">app</code><code class="p">[</code><code class="nx">route</code><code class="p">.</code><code class="nx">method</code><code class="p">](</code><code class="nx">route</code><code class="p">.</code><code class="nx">handler</code><code class="p">))</code></pre>

<p>This method has its advantages and could be well suited to storing our routes dynamically, such as in a database or a JSON file. However, if you don’t need that functionality, I recommend passing the <code>app</code> instance to the module and letting it add the routes. That’s the approach we’ll take for our example. Create a file called <em>routes.js</em> and move all of our existing routes into it:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">app</code> <code class="o">=&gt;</code> <code class="p">{</code>

  <code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code><code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">app</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'home'</code><code class="p">))</code>

  <code class="c1">//...</code>

<code class="p">}</code></pre>

<p>If we just cut and paste, we’ll probably run into some problems. For example, if we have inline route handlers that use variables or methods not available in the new context, those references will now be broken. We could add the necessary imports, but hold off on that. We’ll be moving the handlers into their own module soon, and we’ll solve the problem then.</p>

<p>So how do we link our routes in? Simple: in <em>meadowlark.js</em>, we simply import our routes:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">require</code><code class="p">(</code><code class="s1">'./routes'</code><code class="p">)(</code><code class="nx">app</code><code class="p">)</code></pre>

<p>Or we could be more explicit and add a named import (which we name <code>addRoutes</code> to better reflect its nature as a function; we could also name the file this way if we wanted):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">addRoutes</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./routes'</code><code class="p">)</code>

<code class="nx">addRoutes</code><code class="p">(</code><code class="nx">app</code><code class="p">)</code></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Grouping Handlers Logically"><div class="sect1" id="idm45053581531720">
<h1>Grouping Handlers Logically</h1>

<p><a data-type="indexterm" data-primary="route handlers" data-secondary="grouping logically" id="idm45053581335736"/><a data-type="indexterm" data-primary="routing" data-secondary="grouping handlers logically" id="idm45053581334760"/>To meet our first guiding principle (use named functions for route handlers), we’ll need somewhere to put those handlers. One rather extreme option is to have a separate JavaScript file for every handler. It’s hard for me to imagine a situation in which this approach would have benefit. It’s better to somehow group related functionality together. That makes it easier not only to leverage shared functionality, but also to make changes in related methods.</p>

<p>For now, let’s group our functionality into separate files: <em>handlers/main.js</em>, where we’ll put the home page handler, the “about” handler, and generally any handler that doesn’t have another logical home; <em>handlers/vacations.js</em>, where vacation-related handlers will go; and so on.</p>

<p>Consider <em>handlers/main.js</em>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fortune</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'../lib/fortune'</code><code class="p">)</code>

<code class="nx">exports</code><code class="p">.</code><code class="nx">home</code> <code class="o">=</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'home'</code><code class="p">)</code>

<code class="nx">exports</code><code class="p">.</code><code class="nx">about</code> <code class="o">=</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">fortune</code> <code class="o">=</code> <code class="nx">fortune</code><code class="p">.</code><code class="nx">getFortune</code><code class="p">()</code>
  <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="s1">'about'</code><code class="p">,</code> <code class="p">{</code> <code class="nx">fortune</code> <code class="p">})</code>
<code class="p">}</code>

<code class="c1">//...</code></pre>

<p>Now let’s modify <em>routes.js</em> to make use of this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">main</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'./handlers/main'</code><code class="p">)</code>

<code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">app</code><code class="p">)</code> <code class="p">{</code>

  <code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/'</code><code class="p">,</code> <code class="nx">main</code><code class="p">.</code><code class="nx">home</code><code class="p">)</code>
  <code class="nx">app</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s1">'/about'</code><code class="p">,</code> <code class="nx">main</code><code class="p">.</code><code class="nx">about</code><code class="p">)</code>
  <code class="c1">//...</code>

<code class="p">}</code></pre>

<p>This satisfies all of our guiding principles. <em>/routes.js</em> is <em>very</em> straightforward. It’s easy to see at a glance what routes are in your site and where they are being handled. We’ve also left ourselves plenty of room to grow. We can group related functionality in as many different files as we need. And if <em>routes.js</em> ever gets unwieldy, we can use the same technique again and pass the <code>app</code> object on to another module that will in turn register more routes (though that is starting to veer into the “overcomplicated” territory—make sure you can really justify an approach that complicated!).</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Automatically Rendering Views"><div class="sect1" id="idm45053581159864">
<h1>Automatically Rendering Views</h1>

<p><a data-type="indexterm" data-primary="routing" data-secondary="automatically rendering views" id="idm45053581158456"/><a data-type="indexterm" data-primary="views" data-secondary="automatically rendering" id="idm45053581157512"/>If you ever find yourself wishing for the days of old where you could just put an HTML file in a directory and—presto!—your website would serve it, then you’re not alone. If your website is content-heavy without a lot of functionality, you may find it a needless hassle to add a route for every view. Fortunately, we can get around this <span class="keep-together">problem.</span></p>

<p>Let’s say you want to add the file <em>views/foo.handlebars</em> and just
magically have it available on the route <em>/foo</em>. Let’s see how we might
do that. In our application file, right before the 404 handler, add the
following middleware (<em>ch14/06-auto-views.js</em> in the companion repo):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">autoViews</code> <code class="o">=</code> <code class="p">{}</code>
<code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'fs'</code><code class="p">)</code>
<code class="kr">const</code> <code class="p">{</code> <code class="nx">promisify</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s1">'util'</code><code class="p">)</code>
<code class="kr">const</code> <code class="nx">fileExists</code> <code class="o">=</code> <code class="nx">promisify</code><code class="p">(</code><code class="nx">fs</code><code class="p">.</code><code class="nx">exists</code><code class="p">)</code>

<code class="nx">app</code><code class="p">.</code><code class="nx">use</code><code class="p">(</code><code class="nx">async</code> <code class="p">(</code><code class="nx">req</code><code class="p">,</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">next</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
  <code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">req</code><code class="p">.</code><code class="nx">path</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">()</code>
  <code class="c1">// check cache; if it's there, render the view</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">autoViews</code><code class="p">[</code><code class="nx">path</code><code class="p">])</code> <code class="k">return</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="nx">autoViews</code><code class="p">[</code><code class="nx">path</code><code class="p">])</code>
  <code class="c1">// if it's not in the cache, see if there's</code>
  <code class="c1">// a .handlebars file that matches</code>
  <code class="k">if</code><code class="p">(</code><code class="nx">await</code> <code class="nx">fileExists</code><code class="p">(</code><code class="nx">__dirname</code> <code class="o">+</code> <code class="s1">'/views'</code> <code class="o">+</code> <code class="nx">path</code> <code class="o">+</code> <code class="s1">'.handlebars'</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">autoViews</code><code class="p">[</code><code class="nx">path</code><code class="p">]</code> <code class="o">=</code> <code class="nx">path</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="sr">/^\//</code><code class="p">,</code> <code class="s1">''</code><code class="p">)</code>
    <code class="k">return</code> <code class="nx">res</code><code class="p">.</code><code class="nx">render</code><code class="p">(</code><code class="nx">autoViews</code><code class="p">[</code><code class="nx">path</code><code class="p">])</code>
  <code class="p">}</code>
  <code class="c1">// no view found; pass on to 404 handler</code>
  <code class="nx">next</code><code class="p">()</code>
<code class="p">})</code></pre>

<p>Now we can just add a <em>.handlebars</em> file to the <em>view</em> directory and have it magically render on the appropriate path. Note that regular routes will circumvent this mechanism (because we placed the automatic view handler after all other routes), so if you have a route that renders a different view for the route <em>/foo</em>, that will take precedence.</p>

<p>Note that this approach will run into problems if you <em>delete</em> a view that had been visited; it will have been added to the <code>autoViews</code> object, so subsequent views will try to render it even though it’s been deleted, resulting in an error. The problem could be solved by wrapping the rendering in a <code>try/catch</code> block and removing the view from <code>autoViews</code> when an error is discovered; I will leave this enhancement as a reader’s exercise.</p>
</div></section>













<section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm45053580994792">
<h1>Conclusion</h1>

<p>Routing is an important part of your project, and there are many more possible approaches to organizing your route handlers than outlined here, so feel free to experiment and find a technique that works for you and your project. I encourage you to favor techniques that are clear and easy to trace. Routing is very much a map from the outside world (the client, usually a browser) to the server-side code that responds to it. If that map is convoluted, it makes it difficult for you to trace the flow of information in your application, which will hinder both development and debugging.<a data-type="indexterm" data-startref="ix_ch-14-routing-asciidoc0" id="idm45053580992584"/></p>
</div></section>







</div></section></div>



  </body></html>