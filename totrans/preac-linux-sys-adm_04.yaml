- en: Chapter 4\. Managing Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a system administrator, you’ll spend a significant portion of your time managing
    users. You’ll also spend time troubleshooting user problems that aren’t account-
    or permissions-related, such as connectivity problems, broken applications, data
    corruption, training issues, security issues, and user-created problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Managing users covers the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removing user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting access to files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting access to files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing security policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting permissions on files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some user management tasks can be learned from this book, while others are purely
    experiential and on-the-job training for you. No two user environments are exactly
    alike, and no two user experiences are exactly alike. In this chapter, you learn
    some preemptive user management methods, but problems still occur. The techniques
    you learn in this chapter will get you started on being able to handle an array
    of user-related problems.
  prefs: []
  type: TYPE_NORMAL
- en: User and Group ID Numbering Conventions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are some guidelines associated with creating and maintaining user accounts
    on Linux systems, as shown in [Table 4-1](#numbering_conventions_for_user_and_grou).
    These aren’t hard and fast rules, but they’re generally followed on most corporate
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Table 4-1\. Numbering conventions for user and group accounts
  prefs: []
  type: TYPE_NORMAL
- en: '| UID | GID | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 0 | 0 | Root |'
  prefs: []
  type: TYPE_TB
- en: '| 1–999 | 1–999 | System/service accounts |'
  prefs: []
  type: TYPE_TB
- en: '| 1000+ | 1000+ | User accounts |'
  prefs: []
  type: TYPE_TB
- en: User account UID and GID numbers typically begin at 1000 and increment by one
    for each new account. The UID and GID for the root user are always 0; no other
    user on the system has these user and group IDs.
  prefs: []
  type: TYPE_NORMAL
- en: System and service accounts aren’t human user accounts and typically don’t have
    an interactive shell associated with them. These accounts are given UIDs and GIDs
    ranging from 1–999\. These separations make system housekeeping much easier than
    randomly assigning UIDs and GIDs to user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating User Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like most tasks in Linux, there’s more than one way to create user accounts.
    For this book, I stick with the two mainstream methods of creating accounts: `useradd`
    and `adduser`.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding Users with useradd
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `useradd` command is the standard command-line Linux method of adding new
    users to a system. The `useradd` command is simple; all you really need to supply
    is a username as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates the home directory, */home/jsmith*, fills it with the default
    complement of hidden environment files, and places an entry into */etc/passwd*.
    When I create a user account with `useradd`, I supply a single argument and bit
    of information (the user’s full name) that otherwise requires me to edit the */etc/passwd*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-c` option writes the information you supply to it to the fifth field
    of the `/etc/passwd` file. If you wish to supply more information, such as phone
    number, email address, or whatever you wish to include, use commas (`,`) to separate
    the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The new user’s */etc/passwd* entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The individual fields in a user’s */etc/passwd* entry are as follows (from
    left to right):'
  prefs: []
  type: TYPE_NORMAL
- en: Username
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*/etc/shadow* password field'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Primary group ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The comment field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Home directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Passwords are not stored in the */etc/passwd* file. The */etc/shadow* field
    refers to the */etc/shadow* file that contains each user’s encrypted password
    and is readable only by the root user. Note the */etc/shadow* file’s permissions
    are `000` on Red Hat Enterprise Linux–based systems. The file permissions vary
    among distributions but are never readable by regular users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Although Jane Smith’s user account is created, her home directory exists, and
    there’s an entry in the */etc/passwd* file for the account, Jane can’t log into
    the system. Do you know why? It’s because the account has no password. As the
    sysadmin, you have to supply an initial password to Jane so that the user can
    log in. Since you haven’t supplied a password for the account, the */etc/shadow*
    entry shows that there is no password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `passwd` command to supply a password to the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, you have to give the password to Jane before she can successfully log into
    the system.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Users with adduser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'On some Linux distributions, `adduser` is a symbolic link to `useradd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: On other distributions, `adduser` is an interactive Perl script that steps you
    through adding a new user, and `useradd` is a separate utility with its standard
    switches and arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying User Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There’s rarely such a thing as a static user account. Therefore, the `usermod`
    command exists to assist you in making those required changes without editing
    */etc/passwd*, a home directory, or configuration files. The `usermod` command
    is the catchall for changing all things user account related. The following is
    an abbreviated list of modifications that you can make with the `usermod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the user to a supplementary group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the user’s comment field in */etc/passwd*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the user’s home directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set an account expiry date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove an expiry date
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change a user’s login name (username)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lock/unlock a user’s account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move the contents of a user’s home directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change a user’s login shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change a user’s ID
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these options are more frequently used than others. For example, it’s
    completely reasonable to change a user’s login shell, lock and unlock an account,
    set or remove an expiry date, or add a user to a supplementary group. Changing
    a user’s ID once it’s set during account creation is rare, as is relocating a
    user’s home directory.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, I give examples of the most commonly requested user
    account changes. Check the man page for details if you need to alter other aspects
    of a user’s account.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Supplementary Group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you create a new user account, the system assigns the user a user ID (UID)
    and a primary group ID (GID). (They can be the same sequential number, but that
    isn’t always the case.) For example, for the account created earlier for Jane
    Smith, the UID is `1007`, and the GID is `1007`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Jane’s primary GID is `1007`, but she might also work in an area of the company,
    such as IT, engineering, or application development, that requires her to have
    access to a group-owned directory. For this exercise, Jane works in the engineering
    department as an associate engineer. The engineering department’s shared directory
    GID is `8020`. Using `usermod`, here’s how to grant Jane access to that group’s
    shared directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This adds Jane’s user account to the engineering group in the */etc/group*
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now Jane can access the engineering group’s shared directory. To correctly
    add Jane’s account to a new group, use the `-a` (append) and the `-G` (supplementary
    group) together. For example, if you want Jane to access the finance department’s
    shared directory, you must append her to that group. When adding a user, you can
    use the GID number or the group’s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You must use the `-a` (append) and the `-G` (supplementary group) together.
    If you don’t use the `-a` option, your user will be removed from all other supplementary
    groups and added only to the one you specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user can be a member of several other groups. For example, a user might be
    in the finance department (GID `8342`) but also require access to human resources
    (GID `8901`) information. You can also add a user to more than one group at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This command adds Jane Smith to the finance and the human resources group with
    a single command.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the User Comments Field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Changing the user comments (GECOS) field is a common task. You can edit the
    */etc/passwd* file directly, although it comes with significant risk. The rule
    of thumb is that if there’s a tool to perform some action or task, you should
    use it rather than directly editing configuration files. You can easily change
    the GECOS field using the `usermod` command and the `-c` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say the company has recently hired a second person named Jane Smith,
    so you need to distinguish between them by adding a middle initial to the first
    Jane Smith’s GECOS field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command replaces `Jane Smith` with `Jane R Smith`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `-c` option tells the `usermod` command that you’re editing the “comments”
    field. You can also change this information using the `chfn` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `chfn` command changes your finger information. Finger is an old daemon
    that ran on early Unix systems and some Linux systems and supplied information
    about users. Almost no one uses it these days because of security issues, but
    the information is still referred to as finger information. The `-f` option changes
    the user’s full name field for the specified account. There are other options
    for office (`-o`), office phone (`-p`), and home phone (`-h`). Generally, only
    the user’s full name or the service’s name and purpose are used for the GECOS
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Setting an Expiration (Expiry) Date on an Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a user gives notice at a company, moves to a different business unit, or
    goes on parental leave, sysadmins might decide to disable that user’s account
    for security reasons until the person returns or before removing the account from
    a system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Rob Smith’s account will be disabled (expired) on the specified date in the
    format YYYY-MM-DD. The `-e` option sets the account for expiration.
  prefs: []
  type: TYPE_NORMAL
- en: Changing a User’s Login Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The default Linux shell is bash, but some users prefer to use a different shell,
    so they request that their default shell be changed to one of the many other available
    shell options. There are three methods of changing a user’s default shell: `usermod`,
    `chsh`, and directly editing */etc/passwd*. Direct editing of the */etc/passwd*
    file is not recommended.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `usermod` command method uses the `-s` option, the new shell, and the username
    to make the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The updated */etc/passwd* file is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Only a user with root privileges may edit the */etc/passwd* file or use the
    `usermod` command. However, any user may change their shell with the `chsh` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting */etc/passwd* entry is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: For other changes, consult the man page for `usermod`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'At the end of any man page, you’ll find a list of related alternative commands,
    links to external documentation, and configuration files referenced in the “See
    Also” section. These are handy to explore and might prove more efficient for making
    changes. The following is the “See Also” section excerpted from the [`usermod`
    man page](https://oreil.ly/nqaH_):'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: chfn(1), chsh(1), passwd(1), crypt(3), gpasswd(8), groupadd(8), groupdel(8),
    groupmod(8), login.defs(5), useradd(8), userdel(8).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Now that you’ve learned to create and modify user accounts, let’s discuss how
    to remove user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Removing User Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortunately, system administrators and developers who give names to commands
    do so in a way that makes them easy to remember. Command names often describe
    their functions. The `useradd` command is one such example. To remove a user account
    from a system, you use the `userdel` command, which is just as easy to use as
    `useradd` is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove a user account from your system, issue the `userdel` command and
    supply the username for the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This command removes the user’s entry from */etc/passwd* and from */etc/shadow*
    but leaves the user’s home directory (*/home/jsmith*) intact. Why do you think
    that’s a good option? Sysadmins often leave a user’s home directory intact after
    a user has separated from a company or has changed jobs within the company but
    no longer requires access to a system. Retaining the user’s home directory ensures
    that only the root user can access any documents left by the user that might be
    important to the company.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you make nightly backups of users’ home directories, you don’t necessarily
    need to retain the user’s home directory. The following `userdel` command removes
    the user’s home directory and all files inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Destructive Linux commands, such as `userdel` and `rm`, are irreversible and
    can’t be undone once executed. Always be sure that you have the correct user account
    before pressing the Enter key—and have good backups.
  prefs: []
  type: TYPE_NORMAL
- en: When it’s time to change passwords, you need to know how to force users to do
    it. Our next section shows you how.
  prefs: []
  type: TYPE_NORMAL
- en: Forcing Password Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s a matter of trust that the user will change their password when you provide
    them with an initial password. Sysadmins who regularly audit their users’ passwords
    realize that this “honor system” level of trust doesn’t work 100% of the time.
    You can easily audit a user’s account settings using the `chage` command. The
    `-l` option lists the current settings for the specified user account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this account’s password never expires, which is a security violation
    that needs to be fixed. In addition to a regular forced change, you should also
    set a minimum change period. For example, as shown in the following code listing,
    I set the `rsmith` account to force a password change every 90 days (`-M 90`)
    with a minimum number of days between password changes to 1 (`-m 1`). Setting
    a minimum number of days ensures that users don’t change their passwords 10 times
    (or whatever the number of the system’s remembered passwords is set to) to reset
    it to their original password, which amounts to no net password change.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The expiration date set by the system is 90 days after the last password change.
    If the last password change is in the past, the user must change their password
    on the next login.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'From the [`chage` man page](https://oreil.ly/-NeGX): “The `chage` command changes
    the number of days between password changes and the last password change date.
    The system uses this information to determine when users must change their passwords.”'
  prefs: []
  type: TYPE_NORMAL
- en: Passwords are a weak form of authentication because they can be guessed, cracked,
    or read in plain text if users write them down. Thus, you must ensure that passwords
    are changed often and not reused.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Service Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing stirs controversy among sysadmins and security administrators like the
    mere mention of service accounts. I’m not sure what all the controversy is about
    because every Linux system has more than 30 service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of a service account is the *nobody* account, which is the Kernel
    Overflow User account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally, you can spot a service account because in the */etc/passwd* file,
    you see that the user account has no assigned shell. Service accounts have */sbin/nologin,*
    where the user’s shell should be. This means that the service accounts have no
    interactive shell or passwords. That doesn’t mean their passwords are blank or
    null, they simply don’t exist. In other words, if a user account has */sbin/nologin*
    as their shell, they can’t log into the system with any password. And no user,
    not even the root user, can `su` or `sudo` to those accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Because service accounts have no interactive shell and no method of switching
    to one via `su` or `sudo`, there’s no security violation associated with having
    service accounts on a system. The controversy comes from the fact that some system
    administrators don’t know that service accounts don’t usually have interactive
    shells or passwords. Services may require an interactive shell account for their
    service to function. For those services, extreme scrutiny and other security measures
    should be in place to thwart potential clandestine logins on those accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Groups Rather Than Users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When managing permissions for a set of users, it’s more convenient to define
    and manage a group than to manage each user separately. Group management allows
    you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Manage permissions on assets such as folders and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage permissions according to job function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change permissions for a large number of users rather than for each user individually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easily add users to and remove users from a group’s shared folders and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restrict permissions to sensitive folders and files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s very difficult to manage permissions for individual users because if those
    permissions need to change, you have to trace permissions for that user on every
    system on which they have an account. Managing permissions for groups allows sysadmins
    to manage fine-grained user access on a more global level.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have a user who works in the human resources (HR) department
    and then moves to the finance department, it’s easy to remove that user from the
    HR group and add them to the finance group. The user immediately has access to
    all shared files and folders that other finance group members do. And the user
    no longer has access to HR files and folders.
  prefs: []
  type: TYPE_NORMAL
- en: You learned earlier in this chapter how to add users to supplementary groups.
    You should practice adding directories to the system, adding a group account,
    setting that particular group ownership to the directory, and then adding users
    to the group. You can then `su - *username*`, becoming that user to test your
    permissions settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is one possible scenario for you to work through to learn group
    management. This example assumes you already have a finance group and users assigned
    to it. Notice that during this example, the root user exits and returns to a regular
    account that is part of the finance group. And users can change group ownership
    and permissions of files they own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you understand everything that’s going on in this example, then you’re ready
    to move on to the next chapter. If you haven’t yet mastered these concepts, work
    through the chapter examples again and return to this exercise. Remember that
    creating users, groups, and directories and changing permissions are daily tasks
    for sysadmins, and practicing these skills is the only way to acquire them and
    become comfortable using them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter taught you how to create, remove, and change user accounts. You
    also learned how to set up service accounts and had a brief overview of managing
    groups. In the next chapter, you will learn about Linux networking, from the basics
    of why networks are important to more-complex concepts such as network troubleshooting.
  prefs: []
  type: TYPE_NORMAL
