- en: Chapter 17\. Authentication, Authorization, and Admission Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The API server is the gateway to the Kubernetes cluster. Any human user, client
    (e.g., `kubectl`), cluster component, or service account will access the API server
    by making a RESTful API call via HTTPS. It is *the* central point for performing
    operations like creating a Pod or deleting a Service.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll focus on the security-specific aspects relevant to the
    API server. For a detailed discussion on the inner workings of the API server
    and use of the Kubernetes API, refer to [*Managing Kubernetes*](https://learning.oreilly.com/library/view/managing-kubernetes/9781492033905)
    by Brendan Burns and Craig Tracey (O’Reilly).
  prefs: []
  type: TYPE_NORMAL
- en: Processing a Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Figure 17-1](#api_server_request_processing) illustrates the stages a request
    goes through when a call is made to the API server. For reference, you can find
    more information in the [Kubernetes documentation](https://kubernetes.io/docs/concepts/security/controlling-access/).'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1701](Images/ckd2_1701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-1\. API server request processing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first stage of request processing is *authentication*. Authentication validates
    the identity of the caller by inspecting the client certificates or bearer tokens.
    If the bearer token is associated with a service account, then it will be verified
    here.
  prefs: []
  type: TYPE_NORMAL
- en: The second stage determines if the identity provided in the first stage can
    access the verb and HTTP path request. Therefore, stage two deals with *authorization*
    of the request, which is implemented with the standard Kubernetes RBAC model.
    Here, we ensure that the service account is allowed to list Pods or create a new
    Service object if that has been requested.
  prefs: []
  type: TYPE_NORMAL
- en: The third stage of request processing deals with *admission control*. Admission
    control verifies if the request is well formed or potentially needs to be modified
    before the request is processed. An admission control policy could, for example,
    ensure that the request for creating a Pod includes the definition of a specific
    label. If the request doesn’t define the label, then it is rejected.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication with kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers interact with the Kubernetes API by running the `kubectl` command
    line tool. Whenever you execute a command with `kubectl`, the underlying HTTPS
    call to the API server needs to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubeconfig
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Credentials for the use of `kubectl` are stored in the file *$HOME/.kube/config*,
    also known as the *kubeconfig file*. The kubeconfig file defines the API server
    endpoints of the clusters we want to interact with, as well as a list of users
    registered with the cluster, including their credentials in the form of client
    certificates. The mapping between a cluster and user for a given namespace is
    called a *context*. `kubectl` uses the currently selected context to know which
    cluster to talk to and which credentials to use.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can point the environment variable `KUBECONFIG` to a set of kubeconfig files.
    At runtime, `kubectl` will merge the contents of the set of defined kubeconfig
    files and use them. By default, `KUBECONFIG` is not set and falls back to *$HOME/.kube/config*.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 17-1](#kubeconfig) shows a kubeconfig file. Be aware that file paths
    assigned in the example are user-specific and may differ in your own environment.
    You can find a detailed description of all configurable attributes in the [Config
    resource type](https://kubernetes.io/docs/reference/config-api/kubeconfig.v1/)
    API documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-1\. A kubeconfig file
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication__authorization____span_class__keep_together__and_admission_control__span__CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A list of referential names to clusters and their API server endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication__authorization____span_class__keep_together__and_admission_control__span__CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A list of referential names to contexts (a combination of cluster and user).
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication__authorization____span_class__keep_together__and_admission_control__span__CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The currently selected context.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_authentication__authorization____span_class__keep_together__and_admission_control__span__CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A list of referential names to users and their credentials.
  prefs: []
  type: TYPE_NORMAL
- en: User management is handled by the cluster administrator. The administrator creates
    a user representing the developer and hands the relevant information (username
    and credentials) to the human wanting to interact with the cluster via `kubectl`.
    Alternatively, it is also possible to integrate with external identity providers
    for authentication purposes, e.g., via [OpenID Connect](https://kubernetes.io/docs/reference/access-authn-authz/authentication/#openid-connect-tokens).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new user manually consists of multiple steps, as described in the
    [Kubernetes documentation](https://kubernetes.io/docs/reference/access-authn-authz/certificate-signing-requests/#normal-user).
    The developer would then add the user to the kubeconfig file on the machine intended
    to interact with the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Managing Kubeconfig Using kubectl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You do not have to manually edit the kubeconfig file(s) to change or add configuration.
    `Kubectl` provides commands for reading and modifying its contents. The following
    commands provide an overview. You can find additional examples for commands in
    the [kubectl cheatsheet](https://kubernetes.io/docs/reference/kubectl/cheatsheet/#kubectl-context-and-configuration).
  prefs: []
  type: TYPE_NORMAL
- en: 'To view the merged contents of the kubeconfig file(s), run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To render the currently selected context, use the `current-context` subcommand.
    The context named `minikube` is the active one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the context, provide the name with the `use-context` subcommand.
    Here, we are switching to the context `bmuschko`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To register a user with the kubeconfig file(s), use the `set-credentials` subcommand.
    We are choosing to assign the username `myuser` and point to the client certificate
    by providing the corresponding CLI flags:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the exam, familiarize yourself with the `kubectl config` command. Every
    task in the exam will require you to work with a specific context and/or namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization with Role-Based Access Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve learned that the API server will try to authenticate any request sent
    using `kubectl` by verifying the provided credentials. An authenticated request
    will then need be checked against the permissions assigned to the requestor. The
    authorization phase of the API processing workflow checks if the operation is
    permitted against the requested API resource.
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, those permissions can be controlled using Role-Based Access Control
    (RBAC). In a nutshell, RBAC defines policies for users, groups, and service accounts
    by allowing or disallowing access to manage API resources. Enabling and configuring
    RBAC is mandatory for any organization with a strong emphasis on security.
  prefs: []
  type: TYPE_NORMAL
- en: Setting permissions is the responsibility of a cluster administrator. In the
    following sections, we’ll briefly talk about the effects of RBAC on requests from
    users and service accounts.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC Overview
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RBAC helps with implementing a variety of use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Establishing a system for users with different roles to access a set of Kubernetes
    resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling processes (associated with a service account) running in a Pod and
    performing operations against the Kubernetes API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the visibility of certain resources per namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RBAC consists of three key building blocks, as shown in [Figure 17-2](#rbac_key_building_blocks).
    Together, they connect API primitives and their allowed operations to the so-called
    subject, which is a user, a group, or a service account.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1702](Images/ckd2_1702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-2\. RBAC key building blocks
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Each block’s responsibilities are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Subject
  prefs: []
  type: TYPE_NORMAL
- en: The user or service account that wants to access a resource
  prefs: []
  type: TYPE_NORMAL
- en: Resource
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes API resource type (e.g., a Deployment or node)
  prefs: []
  type: TYPE_NORMAL
- en: Verb
  prefs: []
  type: TYPE_NORMAL
- en: The operation that can be executed on the resource (e.g., creating a Pod or
    deleting a Service)
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RBAC API Primitives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With these key concepts in mind, let’s look at the Kubernetes API primitives
    that implement the RBAC functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Role
  prefs: []
  type: TYPE_NORMAL
- en: The Role API primitive declares the API resources and their operations this
    rule should operate on in a specific namespace. For example, you may want to say
    “allow listing and deleting of Pods,” or you may express “allow watching the logs
    of Pods,” or even both with the same Role. Any operation that is not spelled out
    explicitly is disallowed as soon as it is bound to the subject.
  prefs: []
  type: TYPE_NORMAL
- en: RoleBinding
  prefs: []
  type: TYPE_NORMAL
- en: The RoleBinding API primitive *binds* the Role object to the subject(s) in a
    specific namespace. It is the glue for making the rules active. For example, you
    may want to say “bind the Role that permits updating Services to the user John
    Doe.”
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 17-3](#rbac_primitives) shows the relationship between the involved
    API primitives. Keep in mind that the image renders only a selected list of API
    resource types and operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1703](Images/ckd2_1703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-3\. RBAC primitives
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The following sections demonstrate the namespace-wide usage of Roles and RoleBindings,
    but the same operations and attributes apply to cluster-wide Roles and RoleBindings,
    discussed in [“Namespace-Wide and Cluster-Wide RBAC”](#cluster-wide-rbac).
  prefs: []
  type: TYPE_NORMAL
- en: Default User-Facing Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes defines a set of default Roles. You can assign them to a subject
    via a RoleBinding or define your own, custom Roles depending on your needs. [Table 17-1](#default_user_facing_roles)
    describes the default user-facing Roles.
  prefs: []
  type: TYPE_NORMAL
- en: Table 17-1\. Default user-facing Roles
  prefs: []
  type: TYPE_NORMAL
- en: '| Default ClusterRole | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| cluster-admin | Allows read and write access to resources across all namespaces.
    |'
  prefs: []
  type: TYPE_TB
- en: '| admin | Allows read and write access to resources in namespace including
    Roles and RoleBindings. |'
  prefs: []
  type: TYPE_TB
- en: '| edit | Allows read and write access to resources in namespace except Roles
    and RoleBindings. Provides access to Secrets. |'
  prefs: []
  type: TYPE_TB
- en: '| view | Allows read-only access to resources in namespace except Roles, RoleBindings,
    and Secrets. |'
  prefs: []
  type: TYPE_TB
- en: To define new Roles and RoleBindings, you will have to use a context that allows
    for creating or modifying them, that is, cluster-admin or admin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Roles can be created imperatively with the `create role` command. The most
    important options for the command are `--verb` for defining the verbs, aka operations,
    and `--resource` for declaring a list of API resources (core primitives as well
    as CRDs). The following command creates a new Role for the resources Pod, Deployment,
    and Service with the verbs `list`, `get`, and `watch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Declaring multiple verbs and resources for a single imperative `create role`
    command can be declared as a comma-separated list for the corresponding command-line
    option or as multiple arguments. For example, `--verb=list,get,watch` and `--verb=list
    --verb=get --verb=watch` carry the same instructions. You also can use the wildcard
    “*” to refer to all verbs or resources.
  prefs: []
  type: TYPE_NORMAL
- en: The command-line option `--resource-name` spells out one or many object names
    that the policy rules should apply to. A name of a Pod could be `nginx` and listed
    here with its name. Providing a list of resource names is optional. If no names
    have been provided, then the provided rules apply to all objects of a resource
    type.
  prefs: []
  type: TYPE_NORMAL
- en: The declarative approach can become a little lengthy. As you can see in [Example 17-2](#a_yaml_manifest_defining_a_role),
    the section `rules` lists the resources and verbs. Resources with an API group,
    like Deployments that use the API version `apps/v1`, need to explicitly declare
    it under the attribute `apiGroups`. All other resources (e.g., Pods and Services),
    simply use an empty string, as their API version doesn’t contain a group. Be aware
    that the imperative command for creating a Role automatically determines the API
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-2\. A YAML manifest defining a Role
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication__authorization____span_class__keep_together__and_admission_control__span__CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Any resource that belongs to an API group need to be listed as an explicit rule
    in addition to the API resources that do not belong to an API group.
  prefs: []
  type: TYPE_NORMAL
- en: Listing Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the Role has been created, its object can be listed. The list of Roles
    renders only the name and the creation timestamp. Each of the listed roles does
    not give away any of its details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Rendering Role Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can inspect the details of a Role using the `describe` command. The output
    renders a table that maps a resource to its permitted verbs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This cluster has no resources created, so the list of resource names in the
    following console output is currently empty.
  prefs: []
  type: TYPE_NORMAL
- en: Creating RoleBindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The imperative command creating a RoleBinding object is `create rolebinding`.
    To bind a Role to the RoleBinding, use the `--role` command-line option. The subject
    type can be assigned by declaring the options `--user`, `--group`, or `--serviceaccount`.
    The following command creates the RoleBinding with the name `read-only-binding`
    to the user called `bmuschko`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[Example 17-3](#a_yaml_manifest_defining_a_rolebinding) shows a YAML manifest
    representing the RoleBinding. You can see from the structure that a role can be
    mapped to one or many subjects. The data type is an array indicated by the dash
    character under the attribute `subjects`. At this time, only the user `bmuschko`
    has been assigned.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-3\. A YAML manifest defining a RoleBinding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Listing RoleBindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most important information the list of RoleBindings displays is the associated
    Role. The following command shows that the RoleBinding `read-only-binding` has
    been mapped to the Role `read-only`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The output does not provide an indication of the subjects. You will need to
    render the details of the object for more information, as described in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering RoleBinding Details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'RoleBindings can be inspected using the `describe` command. The output renders
    a table of subjects and the assigned role. The following example renders the descriptive
    representation of the RoleBinding named `read-only-binding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Seeing the RBAC Rules in Effect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see how Kubernetes enforces the RBAC rules for the scenario we set up
    so far. First, we’ll create a new Deployment with the `cluster-admin` permissions.
    In Minikube, those permissions are available to the context `minikube` by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll switch the context for the user `bmuschko`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that the user `bmuschko` is permitted to list Deployments. We’ll verify
    that by using the `get deployments` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The RBAC rules allow listing Deployments, Pods, and Services only. The following
    command tries to list the ReplicaSets, which results in an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A similar behavior can be observed when trying to use verbs other than `list`,
    `get`, or `watch`. The following command tries to delete a Deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At any given time, you can check a user’s permissions with the `auth can-i`
    command. The command gives you the option to list all permissions or check a specific
    permission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Namespace-Wide and Cluster-Wide RBAC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Roles and RoleBindings apply to a particular namespace. You will have to specify
    the namespace when creating both objects. Sometimes, a set of Roles and RoleBindings
    needs to apply to multiple namespaces or even to the whole cluster. For a cluster-wide
    definition, Kubernetes offers the API resource types ClusterRole and ClusterRoleBinding.
    The configuration elements are effectively the same. The only difference is the
    value of the `kind` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: To define a cluster-wide Role, use the imperative subcommand `clusterrole` or
    the kind `ClusterRole` in the YAML manifest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To define a cluster-wide RoleBinding, use the imperative subcommand `clusterrolebinding`
    or the kind `ClusterRoleBinding` in the YAML manifest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ClusterRoles and ClusterRoleBindings not only set up cluster-wide permissions
    to a namespaced resource, but they can also be used to set up permissions for
    non-namespaced resources like CRDs and nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Service Accounts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve been using the `kubectl` executable to run operations against a Kubernetes
    cluster. Under the hood, its implementation calls the API server by making an
    HTTP call to the exposed endpoints. Some applications running inside of a Pod
    may have to communicate with the API server as well. For example, the application
    may ask for specific cluster node information or available namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: Pods can use a service account to authenticate with the API server through an
    authentication token. A Kubernetes administrator assigns rules to a service account
    via RBAC to authorize access to specific resources and actions as illustrated
    in [Figure 17-4](#service_account).
  prefs: []
  type: TYPE_NORMAL
- en: '![ckd2 1704](Images/ckd2_1704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 17-4\. Using a service account to communicate with an API server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A Pod doesn’t necessarily need to be involved in the process. Other use cases
    call for leveraging a service account outside of a Kubernetes cluster. For example,
    you may want to communicate with the API server as part of CI/CD pipeline automation
    step. The service account can provide the credentials to authenticate with the
    API server.
  prefs: []
  type: TYPE_NORMAL
- en: The Default Service Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we haven’t defined a service account for a Pod. If not assigned explicitly,
    a Pod uses the [`default` service account](https://kubernetes.io/docs/concepts/security/service-accounts/#default-service-accounts),
    which has the same permissions as an unauthenticated user. This means that the
    Pod cannot view or modify the cluster state or list or modify any of its resources.
    The `default` service account can however request basic cluster information via
    the assigned `system:discovery` Role.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can query for the available service accounts with the subcommand `serviceaccounts`.
    You should see only the `default` service account listed in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While you can execute the `kubectl` operation to delete the `default` service
    account, Kubernetes will reinstantiate the service account immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Service Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can create a custom service account object using the imperative and declarative
    approach. This command creates a service account object with the name `cicd-bot`.
    The assumption here is to use the service account for calls to the API server
    made by a CI/CD pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can also represent the service account in the form of a manifest. In its
    simplest form, the definition assigns the kind `ServiceAccount` and a name, as
    shown in [Example 17-4](#service-account-pod-setup).
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-4\. YAML manifest for a service account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You can set a couple of [configuration options](https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/)
    for a service account. For example, you may want to disable automounting of the
    authentication token when assigning the service account to a Pod. Although you
    will not need to understand those configuration options for the exam, it makes
    sense to dive deeper into security best practices by reading up on them in the
    Kubernetes documentation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting Permissions for a Service Account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s important to limit the permissions to only the service accounts that are
    necessary for the application to function. The next sections will explain how
    to achieve this to minimize the potential attack surface.
  prefs: []
  type: TYPE_NORMAL
- en: For this scenario to work, you’ll need to create a ServiceAccount object and
    assign it to the Pod. Service accounts can be tied in with RBAC and assigned a
    Role and RoleBinding to define which operations they should be allowed to perform.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the service account to a Pod
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a starting point, we will set up a Pod that lists all Pods and Deployments
    in the namespace `k97` by calling the Kubernetes API. The call is made as part
    of an infinite loop every ten seconds. The response from the API call will be
    written to standard output accessible via the Pod’s logs.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the API server endpoint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Accessing the Kubernetes API from a Pod is straightforward. Instead of using
    the IP address and port for the API server Pod, you can simply refer to a Service
    named `kubernetes.default.svc` instead. This special Service lives in the `default`
    namespace and is stood up by the cluster automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'To authenticate against the API server, we’ll send a bearer token associated
    with the service account used by the Pod. The default behavior of a service account
    is to auto-mount API credentials on the path */var/run/secrets/kubernetes.io/serviceaccount/token*.
    We’ll simply get the contents of the file using the `cat` command-line tool and
    send them along as a header for the HTTP request. [Example 17-5](#service-account-pod-setup2)
    defines the namespace, the service account, and the Pod in a single YAML manifest
    file: *setup.yaml*.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-5\. YAML manifest for assigning a service account to a Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](Images/1.png)](#co_authentication__authorization____span_class__keep_together__and_admission_control__span__CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The service account referenced by name used for communicating with the Kubernetes
    API.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_authentication__authorization____span_class__keep_together__and_admission_control__span__CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Performs an API call to retrieve the list of Pods in the namespace `k97`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_authentication__authorization____span_class__keep_together__and_admission_control__span__CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Performs an API call to retrieve the list of Deployments in the namespace `k97`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the objects from the YAML manifest with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the default permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Pod named `list-objects` makes a call to the API server to retrieve the
    list of Pods and Deployments in dedicated containers. The container `pods` performs
    the call to list Pods. The container `deployments` sends a request to the API
    server to list Deployments.
  prefs: []
  type: TYPE_NORMAL
- en: 'As explained in the [Kubernetes documentation](https://oreil.ly/gBp30), the
    default RBAC policies do not grant any permissions to service accounts outside
    of the `kube-system` namespace. The logs of the containers `pods` and `deployments`
    return an error message indicating that the service account `sa-api` is not authorized
    to list the resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Next up, we’ll stand up a Role and RoleBinding object with the required API
    permissions to perform the necessary calls.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Start by defining the Role named `list-pods-role` shown in [Example 17-6](#list-pods-role)
    in the file `role.yaml`. The set of the rules adds only the Pod resource and the
    verb `list`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-6\. YAML manifest for a Role that allows listing Pods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the object by pointing to its corresponding YAML manifest file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Creating the RoleBinding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[Example 17-7](#rolebinding-service-account) defines the YAML manifest for
    the RoleBinding in the file `rolebinding.yaml`. The RoleBinding maps the Role
    `list-pods-role` to the service account named `sa-pod-api` and applies it only
    to the namespace `k97`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 17-7\. YAML manifest for a RoleBinding attached to a service account
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Create both RoleBinding objects using the `apply` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Verifying the granted permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the granted `list` permissions, the service account can now properly retrieve
    all the Pods in the `k97` namespace. The `curl` command in the `pods` container
    succeeds, as shown in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We did not grant any permissions to the service account for other resources.
    Listing the Deployments in the `k97` namespace still fails. The following output
    shows the response from the `curl` command in the `deployments` namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to modify the Role object to allow listing Deployment objects as well.
  prefs: []
  type: TYPE_NORMAL
- en: Admission Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last phase of processing a request to the API server is admission control.
    Admission control is implemented by admission controllers. An admission controller
    provides a way to approve, deny, or mutate a request before it takes effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Admission controllers can be registered with the configuration of the API server.
    By default, the configuration file can be found at */etc/kubernetes/manifests/kube-apiserver.yaml*.
    It is the cluster administrator’s job to manage the API server configuration.
    The following command-line invocation of the API server enables the [admission
    control plugins](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do)
    named `NamespaceLifecycle`, `PodSecurity` and `LimitRanger`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As a developer, you are inadvertently using admission control plugins that have
    been configured for you. One example is the [LimitRanger](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#limitranger)
    and the [ResourceQuota](https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#resourcequota),
    we’ll discuss in [“Working with Limit Ranges”](ch18.xhtml#limit_ranges) and [“Working
    with Resource Quotas”](ch18.xhtml#resource_quotas).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The API server processes requests to the Kubernetes API. Every request has
    to go through three phases: authentication, authorization, and admission control.
    Every phase can short-circuit the processing. For example, if the credentials
    sent with the request cannot be authenticated, then the request will be dropped
    immediately.'
  prefs: []
  type: TYPE_NORMAL
- en: We looked at examples of all phases. The authentication phase covered `kubectl`
    as the client making a call to the Kubernetes API. The kubeconfig file serves
    as configuration source for named cluster, users, and their credentials. In Kubernetes,
    authorization is handled by RBAC. We learned the Kubernetes primitives that let
    you configure permissions for API resources tied to one or many subjects. Finally,
    we briefly covered the purpose of admission control and listed some plugins that
    act as controllers for validating or mutating a request to the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practice interacting with the Kubernetes API
  prefs: []
  type: TYPE_NORMAL
- en: This chapter demonstrated some ways to communicate with the Kubernetes API.
    We performed API requests by switching to a user context and with the help of
    a RESTful API call using `curl`. Explore the [Kubernetes API](https://kubernetes.io/docs/concepts/overview/kubernetes-api/)
    and its endpoints on your own for broader exposure.
  prefs: []
  type: TYPE_NORMAL
- en: Understand the implications of defining RBAC rules for users and service accounts
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous user requests to the Kubernetes API will not allow any substantial
    operations. For requests coming from a user or a service account, you will need
    to carefully analyze permissions granted to the subject. Learn the ins and outs
    of defining RBAC rules by creating the relevant objects to control permissions.
    Service accounts automount a token when used in a Pod. Expose the token as a volume
    only if you are intending to make API calls from the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Learn about the basic need for admission control
  prefs: []
  type: TYPE_NORMAL
- en: For the exam you will not need to understand how to configure admission control
    plugins in the API server. Developers interact with them, but configuration tasks
    are up to the cluster administrator. Read up on different plugins to gain a better
    understanding of the admission control landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in [Appendix A](app01_split_013.xhtml#appendix_a_authentication_authorization_admission_control).
  prefs: []
  type: TYPE_NORMAL
- en: The premise of this exercise is to create a new user and add her to the kubeconfig
    file. You will then define a context that uses the user, switch to the context,
    and execute a `kubectl` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a certificate for a user named `mary`. Do not provide any permissions
    to the user.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the user to the kubeconfig file. Define the context named `mary-context`
    that assigns the user to a cluster already available in the kubeconfig file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Set the currently selected context to `mary-context`. Create a Pod using `kubectl`.
    What result do you expect to see?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You will use RBAC to grant permissions to a service account. The permissions
    should apply only to certain API resources and operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new namespace named `t23`. Create a Pod named service-list in the namespace
    `t23`. The container uses the image `alpine/curl:3.14` and makes a `curl` call
    to the Kubernetes API that lists Service objects in the default namespace in an
    infinite loop.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create and attach the service account `api-call` to the Pod.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inspect the container logs after the Pod has been started. What response do
    you expect to see from the `curl` command?
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Assign a ClusterRole and RoleBinding to the service account that allows only
    the operation needed by the Pod. Note the response from the `curl` command.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identify the admission controller plugins that have been configured for the
    API server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the configuration file of the API server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Inspect the command-line flag that defines the admission controller plugins.
    Capture the value.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
