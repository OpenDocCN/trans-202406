["```\n// An existing user that we got from the server\ntype ExistingUser = {\n  id: number\n  name: string\n}\n\n// A new user that hasn't been saved to the server yet\ntype NewUser = {\n  name: string\n}\n```", "```\nfunction deleteUser(user: {id?: number, name: string}) {\n  delete user.id\n}\n\nlet existingUser: ExistingUser = {\n  id: 123456,\n  name: 'Ima User'\n}\n\ndeleteUser(existingUser)\n```", "```\ntype LegacyUser = {\n  id?: number | string\n  name: string\n}\n\nlet legacyUser: LegacyUser = {\n  id: '793331',\n  name: 'Xin Yang'\n}\n\ndeleteUser(legacyUser) // Error TS2345: Argument of type 'LegacyUser' is not\n                       // assignable to parameter of type '{id?: number |\n                       // undefined, name: string}'. Type 'string' is not\n                       // assignable to type 'number | undefined'.\n```", "```\nclass Animal {}\nclass Bird extends Animal {\n  chirp() {}\n}\nclass Crow extends Bird {\n  caw() {}\n}\n```", "```\nfunction chirp(bird: Bird): Bird {\n  bird.chirp()\n  return bird\n}\n```", "```\nchirp(new Animal) // Error TS2345: Argument of type 'Animal' is not assignable\nchirp(new Bird)   // to parameter of type 'Bird'.\nchirp(new Crow)\n```", "```\nfunction clone(f: (b: Bird) => Bird): void {\n  // ...\n}\n```", "```\nfunction birdToBird(b: Bird): Bird {\n  // ...\n}\nclone(birdToBird) // OK\n```", "```\nfunction birdToCrow(d: Bird): Crow {\n  // ...\n}\nclone(birdToCrow) // OK\n\nfunction birdToAnimal(d: Bird): Animal {\n  // ...\n}\nclone(birdToAnimal) // Error TS2345: Argument of type '(d: Bird) => Animal' is\n                    // not assignable to parameter of type '(b: Bird) => Bird'.\n                    // Type 'Animal' is not assignable to type 'Bird'.\n```", "```\nfunction clone(f: (b: Bird) => Bird): void {\n  let parent = new Bird\n  let babyBird = f(parent)\n  babyBird.chirp()\n}\n```", "```\nfunction animalToBird(a: Animal): Bird {\n  // ...\n}\nclone(animalToBird) // OK\n\nfunction crowToBird(c: Crow): Bird {\n  // ...\n}\nclone(crowToBird) // Error TS2345: Argument of type '(c: Crow) => Bird' is not\n                  // assignable to parameter of type '(b: Bird) => Bird'.\n```", "```\nfunction crowToBird(c: Crow): Bird {\n  c.caw()\n  return new Bird\n}\n```", "```\nlet a = 'x'               // string\nlet b = 3                 // number\nvar c = true              // boolean\nconst d = {x: 3}          // {x: number}\n\nenum E {X, Y, Z}\nlet e = E.X               // E\n```", "```\nconst a = 'x'             // 'x'\nconst b = 3               // 3\nconst c = true            // true\n\nenum E {X, Y, Z}\nconst e = E.X             // E.X\n```", "```\nlet a: 'x' = 'x'          // 'x'\nlet b: 3 = 3              // 3\nvar c: true = true        // true\nconst d: {x: 3} = {x: 3}  // {x: 3}\n```", "```\nconst a = 'x'             // 'x'\nlet b = a                 // string\n\nconst c: 'x' = 'x'        // 'x'\nlet d = c                 // 'x'\n```", "```\nlet a = null              // any\na = 3                     // any\na = 'b'                   // any\n```", "```\n`function` `x() {`\n  let a = null            *`// any`*\n  a = 3                   *`// any`*\n  a = 'b'                 *`// any`*\n  `return` `a`\n`}`\n\n`x``(``)`                       *`// string`*\n\n```", "```\nlet a = {x: 3}                // {x: number}\nlet b: {x: 3}                 // {x: 3}\nlet c = {x: 3} as const       // {readonly x: 3}\n```", "```\nlet d = [1, {x: 2}]           // (number | {x: number})[]\nlet e = [1, {x: 2}] as const  // readonly [1, {readonly x: 2}]\n```", "```\ntype Options = {\n  baseURL: string\n  cacheSize?: number\n  tier?: 'prod' | 'dev'\n}\n\nclass API {\n  constructor(private options: Options) {}\n}\n\nnew API({\n  baseURL: 'https://api.mysite.com',\n  tier: 'prod'\n})\n```", "```\nnew API({\n  baseURL: 'https://api.mysite.com',\n  tierr: 'prod'      // Error TS2345: Argument of type '{tierr: string}'\n})                   // is not assignable to parameter of type 'Options'.\n                     // Object literal may only specify known properties,\n                     // but 'tierr' does not exist in type 'Options'.\n                     // Did you mean to write 'tier'?\n```", "```\ntype Options = {\n  baseURL: string\n  cacheSize?: number\n  tier?: 'prod' | 'dev'\n}\n\nclass API {\n  constructor(private options: Options) {}\n}\n\nnew API({ ![1](assets/1.png)\n  baseURL: 'https://api.mysite.com',\n  tier: 'prod'\n})\n\nnew API({ ![2](assets/2.png)\n  baseURL: 'https://api.mysite.com',\n  badTier: 'prod'    // Error TS2345: Argument of type '{baseURL: string; badTier: })                   // string}' is not assignable to parameter of type 'Options'. \nnew API({ ![3](assets/3.png)\n  baseURL: 'https://api.mysite.com',\n  badTier: 'prod'\n} as Options)\n\nlet badOptions = { ![4](assets/4.png)\n  baseURL: 'https://api.mysite.com',\n  badTier: 'prod'\n}\nnew API(badOptions)\n\nlet options: Options = { ![5](assets/5.png)\n  baseURL: 'https://api.mysite.com',\n  badTier: 'prod'    // Error TS2322: Type '{baseURL: string; badTier: string}' }                    // is not assignable to type 'Options'. new API(options)\n```", "```\n// We use a union of string literals to describe\n// the possible values a CSS unit can have\ntype Unit = 'cm' | 'px' | '%'\n\n// Enumerate the units\nlet units: Unit[] = ['cm', 'px', '%']\n\n// Check each unit, and return null if there is no match\nfunction parseUnit(value: string): Unit | null {\n  for (let i = 0; i < units.length; i++) {\n    if (value.endsWith(units[i])) {\n      return units[i]\n    }\n  }\n  return null\n}\n```", "```\ntype Width = {\n  unit: Unit,\n  value: number\n}\n\nfunction parseWidth(width: number | string | null | undefined): Width | null {\n  // If width is null or undefined, return early\n  if (width == null) { ![1](assets/1.png)\n    return null\n  }\n\n  // If width is a number, default to pixels\n  if (typeof width === 'number') { ![2](assets/2.png)\n    return {unit: 'px', value: width}\n  }\n\n  // Try to parse a unit from width\n  let unit = parseUnit(width)\n  if (unit) { ![3](assets/3.png)\n    return {unit, value: parseFloat(width)}\n  }\n\n  // Otherwise, return null\n  return null ![4](assets/4.png)\n}\n```", "```\ntype UserTextEvent = {value: string}\ntype UserMouseEvent = {value: [number, number]}\n\ntype UserEvent = UserTextEvent | UserMouseEvent\n\nfunction handle(event: UserEvent) {\n  if (typeof event.value === 'string') {\n    event.value  // string\n    // ...\n    return\n  }\n  event.value    // [number, number]\n}\n```", "```\ntype UserTextEvent = {value: string`,` `target``:` `HTMLInputElement`}\ntype UserMouseEvent = {value: [number, number]`,` `target``:` `HTMLElement`}\n\ntype UserEvent = UserTextEvent | UserMouseEvent\n\nfunction handle(event: UserEvent) {\n  if (typeof event.value === 'string') {\n    event.value  *`// string`*\n    `event``.``target` *`// HTMLInputElement | HTMLElement (!!!)`*\n    // ...\n    return\n  }\n  event.value    *`// [number, number]`*\n  `event``.``target`   *`// HTMLInputElement | HTMLElement (!!!)`*\n}\n\n```", "```\ntype UserTextEvent = {`type``:` `'TextEvent'``,` value: string, target: HTMLInputElement}\ntype UserMouseEvent = {`type``:` `'MouseEvent'``,` value: [number, number],\n                       target: HTMLElement}\n\ntype UserEvent = UserTextEvent | UserMouseEvent\n\nfunction handle(event: UserEvent) {\n  if (`event``.``type` `===` `'TextEvent'`) {\n    event.value  *`// string`*\n    event.target *`// HTMLInputElement`*\n    // ...\n    return\n  }\n  event.value    *`// [number, number]`*\n  event.target   *`// HTMLElement`*\n}\n\n```", "```\ntype Weekday = 'Mon' | 'Tue'| 'Wed' | 'Thu' | 'Fri'\ntype Day = Weekday | 'Sat' | 'Sun'\n\nfunction getNextDay(w: Weekday): Day {\n  switch (w) {\n    case 'Mon': return 'Tue'\n  }\n}\n```", "```\nError TS2366: Function lacks ending return statement and\nreturn type does not include 'undefined'.\n```", "```\nfunction isBig(n: number) {\n  if (n >= 100) {\n    return true\n  }\n}\n```", "```\nError TS7030: Not all code paths return a value.\n```", "```\nlet nextDay = {\n  Mon: 'Tue'\n}\n\nnextDay.Mon // 'Tue'\n```", "```\ntype APIResponse = {\n  user: {\n    userId: string\n    friendList: {\n      count: number\n      friends: {\n        firstName: string\n        lastName: string\n      }[]\n    }\n  }\n}\n```", "```\nfunction getAPIResponse(): Promise<APIResponse> {\n  // ...\n}\n\nfunction renderFriendList(friendList: unknown) {\n  // ...\n}\n\nlet response = await getAPIResponse()\nrenderFriendList(response.user.friendList)\n```", "```\ntype FriendList = {\n  count: number\n  friends: {\n    firstName: string\n    lastName: string\n  }[]\n}\n\ntype APIResponse = {\n  user: {\n    userId: string\n    friendList: FriendList\n  }\n}\n\nfunction renderFriendList(friendList: FriendList) {\n  // ...\n}\n```", "```\ntype APIResponse = {\n  user: {\n    userId: string\n    friendList: {\n      count: number\n      friends: {\n        firstName: string\n        lastName: string\n      }[]\n    }\n  }\n}\n\n`type` `FriendList` `=` `APIResponse``[``'user'``]``[``'friendList'``]`\n\nfunction renderFriendList(friendList: FriendList) {\n  *`// ...`*\n}\n\n```", "```\ntype Friend = FriendList['friends'][number]\n```", "```\ntype ResponseKeys = keyof APIResponse // 'user'\ntype UserKeys = keyof APIResponse['user'] // 'userId' | 'friendList'\ntype FriendListKeys =\n  keyof APIResponse['user']['friendList'] // 'count' | 'friends'\n```", "```\nfunction get< ![1](assets/1.png)\n  O extends object,\n  K extends keyof O ![2](assets/2.png)\n>(\n  o: O,\n  k: K\n): O[K] { ![3](assets/3.png)\n  return o[k]\n}\n```", "```\ntype ActivityLog = {\n  lastEvent: Date\n  events: {\n    id: string\n    timestamp: Date\n    type: 'Read' | 'Write'\n  }[]\n}\n\nlet activityLog: ActivityLog = // ...\nlet lastEvent = get(activityLog, 'lastEvent') // Date\n```", "```\ntype Get = { ![1](assets/1.png)\n  <\n    O extends object,\n    K1 extends keyof O\n  >(o: O, k1: K1): O[K1] ![2](assets/2.png)\n  <\n    O extends object,\n    K1 extends keyof O,\n    K2 extends keyof O[K1] ![3](assets/3.png)\n  >(o: O, k1: K1, k2: K2): O[K1][K2] ![4](assets/4.png)\n  <\n    O extends object,\n    K1 extends keyof O,\n    K2 extends keyof O[K1],\n    K3 extends keyof O[K1][K2]\n  >(o: O, k1: K1, k2: K2, k3: K3): O[K1][K2][K3] ![5](assets/5.png)\n}\n\nlet get: Get = (object: any, ...keys: string[]) => {\n  let result = object\n  keys.forEach(k => result = result[k])\n  return result\n}\n\nget(activityLog, 'events', 0, 'type') // 'Read' | 'Write' \n\nget(activityLog, 'bad') // Error TS2345: Argument of type '\"bad\"'\n                        // is not assignable to parameter of type\n                        // '\"lastEvent\" | \"events\"'.\n```", "```\ntype Weekday = 'Mon' | 'Tue'| 'Wed' | 'Thu' | 'Fri'\ntype Day = Weekday | 'Sat' | 'Sun'\n\nlet nextDay: Record<Weekday, Day> = {\n  Mon: 'Tue'\n}\n```", "```\nError TS2739: Type '{Mon: \"Tue\"}' is missing the following properties\nfrom type 'Record<Weekday, Day>': Tue, Wed, Thu, Fri.\n```", "```\nlet nextDay: {[K in Weekday]: Day} = {\n  Mon: 'Tue'\n}\n```", "```\nError TS2739: Type '{Mon: \"Tue\"}' is missing the following properties\nfrom type '{Mon: Weekday; Tue: Weekday; Wed: Weekday; Thu: Weekday;\nFri: Weekday}': Tue, Wed, Thu, Fri.\n```", "```\ntype MyMappedType = {\n  [Key in UnionType]: ValueType\n}\n```", "```\ntype Record<K extends keyof any, T> = {\n  [P in K]: T\n}\n```", "```\ntype Account = {\n  id: number\n  isEmployee: boolean\n  notes: string[]\n}\n\n// Make all fields optional type OptionalAccount = {\n  [K in keyof Account]?: Account[K] ![1](assets/1.png)\n}\n\n// Make all fields nullable type NullableAccount = {\n  [K in keyof Account]: Account[K] | null ![2](assets/2.png)\n}\n\n// Make all fields read-only type ReadonlyAccount = {\n  readonly [K in keyof Account]: Account[K] ![3](assets/3.png)\n}\n\n// Make all fields writable again (equivalent to Account) type Account2 = {\n  -readonly [K in keyof ReadonlyAccount]: Account[K] ![4](assets/4.png)\n}\n\n// Make all fields required again (equivalent to Account) type Account3 = {\n  [K in keyof OptionalAccount]-?: Account[K] ![5](assets/5.png)\n}\n```", "```\ntype Currency = {\n  unit: 'EUR' | 'GBP' | 'JPY' | 'USD'\n  value: number\n}\n\nlet Currency = {\n  DEFAULT: 'USD',\n  from(value: number, unit = Currency.DEFAULT): Currency {\n    return {unit, value}\n  }\n}\n```", "```\nimport {Currency} from './Currency'\n\nlet amountDue: Currency = { ![1](assets/1.png)\n  unit: 'JPY',\n  value: 83733.10\n}\n\nlet otherAmountDue = Currency.from(330, 'EUR') ![2](assets/2.png)\n```", "```\nlet a = [1, true] // (number | boolean)[]\n```", "```\nfunction tuple< ![1](assets/1.png)\n  T extends unknown[] ![2](assets/2.png)\n>(\n  ...ts: T ![3](assets/3.png)\n): T { ![4](assets/4.png)\n  return ts ![5](assets/5.png)\n}\n\nlet a = tuple(1, true) // [number, boolean]\n```", "```\nfunction isString(a: unknown): boolean {\n  return typeof a === 'string'\n}\n\nisString('a') // evaluates to true\nisString([7]) // evaluates to false\n```", "```\nfunction parseInput(input: string | number) {\n  let formattedInput: string\n  if (isString(input)) {\n    formattedInput = input.toUpperCase() // Error TS2339: Property 'toUpperCase'\n  }                                      // does not exist on type 'number'.\n}\n```", "```\nfunction isString(a: unknown): `a` `is` `string` {\n  return typeof a === 'string'\n}\n\n```", "```\ntype LegacyDialog = // ...\ntype Dialog = // ...\n\nfunction isLegacyDialog(\n  dialog: LegacyDialog | Dialog\n): dialog is LegacyDialog {\n  // ...\n}\n```", "```\ntype IsString<T> = T extends string ![1](assets/1.png)\n  ? true ![2](assets/2.png)\n  : false ![3](assets/3.png)\n\ntype A = IsString<string> // true type B = IsString<number> // false\n```", "```\ntype ToArray<T> = T[]\ntype A = ToArray<number>          // number[]\ntype B = ToArray<number | string> // (number | string)[]\n```", "```\ntype ToArray2<T> = T extends unknown ? T[] : T[]\ntype A = ToArray2<number> *`// number[]`*\ntype B = ToArray2<number | string> *`// number[] | string[]`*\n\n```", "```\ntype Without<T, U> = T extends U ? never : T\n```", "```\ntype A = Without<\n  boolean | number | string,\n  boolean\n> // number | string\n```", "```\n    type A = Without<boolean | number | string, boolean>\n    ```", "```\n    type A = Without<boolean, boolean>\n           | Without<number, boolean>\n           | Without<string, boolean>\n    ```", "```\n    type A = (boolean extends boolean ? never : boolean)\n           | (number extends boolean ? never : number)\n           | (string extends boolean ? never : string)\n    ```", "```\n    type A = never\n           | number\n           | string\n    ```", "```\n    type A = number | string\n    ```", "```\ntype ElementType<T> = T extends unknown[] ? T[number] : T\ntype A = ElementType<number[]> // number\n```", "```\ntype ElementType2<T> = T extends (infer U)[] ? U : T\ntype B = ElementType2<number[]> // number\n```", "```\ntype ElementUgly<T, U> = T extends U[] ? U : T\ntype C = ElementUgly<number[]> // Error TS2314: Generic type 'ElementUgly'\n                               // requires 2 type argument(s).\n```", "```\ntype SecondArg<F> = F extends (a: any, b: infer B) => any ? B : never\n\n// Get the type of Array.slice\ntype F = typeof Array['prototype']['slice']\n\ntype A = SecondArg<F> // number | undefined\n```", "```\ntype A = number | string\ntype B = string\ntype C = Exclude<A, B>  // number\n```", "```\ntype A = number | string\ntype B = string\ntype C = Extract<A, B>  // string\n```", "```\ntype A = {a?: number | null}\ntype B = NonNullable<A['a']>  // number\n```", "```\ntype F = (a: number) => string\ntype R = ReturnType<F>  // string\n```", "```\ntype A = {new(): B}\ntype B = {b: number}\ntype I = InstanceType<A>  // {b: number}\n```", "```\nfunction formatInput(input: string) {\n  // ... }\n\nfunction getUserInput(): string | number {\n  // ... }\n\nlet input = getUserInput()\n\n// Assert that input is a string formatInput(input as string) ![1](assets/1.png)\n\n// This is equivalent to formatInput(<string>input) ![2](assets/2.png)\n```", "```\nfunction addToList(list: string[], item: string) {\n  // ...\n}\n\naddToList('this is really,' as any, 'really unsafe')\n```", "```\ntype Dialog = {\n  id?: string\n}\n\nfunction closeDialog(dialog: Dialog) {\n  if (!dialog.id) { ![1](assets/1.png)\n    return\n  }\n  setTimeout(() => ![2](assets/2.png)\n    removeFromDOM(\n      dialog,\n      document.getElementById(dialog.id) // Error TS2345: Argument of type\n                                         // 'string | undefined' is not assignable\n                                         // to parameter of type 'string'. ![3](assets/3.png)\n    )\n  )\n}\n\nfunction removeFromDOM(dialog: Dialog, element: Element) {\n  element.parentNode.removeChild(element) // Error TS2531: Object is possibly\n                                          //'null'. ![4](assets/4.png)\n  delete dialog.id\n}\n```", "```\ntype Dialog = {\n  id?: string\n}\n\nfunction closeDialog(dialog: Dialog) {\n  if (!dialog.id) {\n    return\n  }\n  setTimeout(() =>\n    removeFromDOM(\n      dialog,\n      document.getElementById(dialog.id`!`)`!`\n    )\n  )\n}\n\nfunction removeFromDOM(dialog: Dialog, element: Element) {\n  element.parentNode`!`.removeChild(element)\n  delete dialog.id\n}\n\n```", "```\ntype VisibleDialog = {id: string}\ntype DestroyedDialog = {}\ntype Dialog = VisibleDialog | DestroyedDialog\n```", "```\nfunction closeDialog(dialog: Dialog) {\n  if (!`(``'id'` `in` `dialog``)`) {\n    return\n  }\n  setTimeout(() =>\n    removeFromDOM(\n      dialog,\n      document.getElementById(`dialog``.``id`)!\n    )\n  )\n}\n\nfunction removeFromDOM(dialog: `VisibleDialog`, element: Element) {\n  element.parentNode!.removeChild(element)\n  delete dialog.id\n}\n\n```", "```\nlet userId: string\n\nuserId.toUpperCase() // Error TS2454: Variable 'userId' is used\n                     // before being assigned.\n```", "```\nlet userId: string\n`fetchUser``(``)`\n\nuserId.toUpperCase() *`// Error TS2454: Variable 'userId' is used`*\n                     *`// before being assigned.`*\n\n`function` `fetchUser() {`\n  `userId` `=` `globalCache``.``get``(``'userId'``)`\n`}`\n\n```", "```\nlet userId`!`: string\nfetchUser()\n\nuserId.toUpperCase() *`// OK`*\n\nfunction fetchUser() {\n  userId = globalCache.get('userId')\n}\n\n```", "```\ntype CompanyID = string\ntype OrderID = string\ntype UserID = string\ntype ID = CompanyID | OrderID | UserID\n```", "```\nfunction queryForUser(id: UserID) {\n  // ...\n}\n```", "```\nlet id: CompanyID = 'b4843361'\nqueryForUser(id) // OK (!!!)\n```", "```\n`type` `CompanyID` `=` `string` `&` `{``readonly` `brand``:` `unique` `symbol``}`\n`type` `OrderID` `=` `string` `&` `{``readonly` `brand``:` `unique` `symbol``}`\n`type` `UserID` `=` `string` `&` `{``readonly` `brand``:` `unique` `symbol``}`\ntype ID = CompanyID | OrderID | UserID\n\n```", "```\nfunction CompanyID(id: string) {\n  return id as CompanyID\n}\n\nfunction OrderID(id: string) {\n  return id as OrderID\n}\n\nfunction UserID(id: string) {\n  return id as UserID\n}\n```", "```\nfunction queryForUser(id: UserID) {\n  // ...\n}\n\nlet companyId = CompanyID('8a6076cf')\nlet orderId = OrderID('9994acc1')\nlet userId = UserID('d21b1dbf')\n\nqueryForUser(userId)    // OK\nqueryForUser(companyId) // Error TS2345: Argument of type 'CompanyID' is not\n                        // assignable to parameter of type 'UserID'.\n```", "```\n// Tell TypeScript about .zip interface Array<T> { ![1](assets/1.png)\n  zip<U>(list: U[]): [T, U][]\n}\n\n// Implement .zip Array.prototype.zip = function<T, U>(\n  this: T[], ![2](assets/2.png)\n  list: U[]\n): [T, U][] {\n  return this.map((v, k) =>\n    tuple(v, list[k]) ![3](assets/3.png)\n  )\n}\n```", "```\n`declare` `global` `{`\n  interface Array<T> {\n    zip<U>(list: U[]): [T, U][]\n  }\n`}`\n\n```", "```\n{\n  *exclude*: [\n    \"./zip.ts\"\n  ]\n}\n```", "```\nimport './zip'\n\n[1, 2, 3]\n  .map(n => n * 2)        // number[]\n  .zip(['a', 'b', 'c'])   // [number, string][]\n```", "```\n[\n  [2, 'a'],\n  [4, 'b'],\n  [6, 'c']\n]\n```"]