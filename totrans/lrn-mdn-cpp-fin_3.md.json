["```\nimport <chrono>;\n\nstd::chrono::year_month_day ymd{ std::chrono::year{2002},\n\tstd::chrono::month{11}, std::chrono::day{14} };\n```", "```\nstd::chrono::year_month_day ymd_alt{ std::chrono::year{2002},\n\tstd::chrono::November, std::chrono::day(14) };\n```", "```\nymd = std::chrono::year{ 2002 } / std::chrono::month{11} / std::chrono::day{14};\n```", "```\nymd = std::chrono::year{ 2002 } / 11 / 14;\n```", "```\ncout << ymd << endl;\n```", "```\nstd::chrono::year_month_day epoch{ date::year{1970}, date::month{1}, date::day{1} };\nstd::chrono::year_month_day epoch_plus_1{ date::year{1970}, date::month{1}, date::day{2} };\n```", "```\nint first_days_test =\n\tstd::chrono::sys_days(epoch).time_since_epoch().count();\t\t// 0\n\nfirst_days_test =\n\tstd::chrono::sys_days(epoch_plus_1).time_since_epoch().count();\t// 1\n```", "```\nfirst_days_test =\n\tstd::chrono::sys_days(epoch_minus_1).time_since_epoch().count();\t// -1\n```", "```\n// ymd = 2002-11-14\n// ymd_later = 2003-5-14\n\nauto diff = (std::chrono::sys_days(ymd_later) –\n\tstd::chrono::sys_days(ymd)).count();\t\t// 181\n```", "```\nyear()\t\t// returns std::chrono::year\nmonth()\t\t// returns std::chrono::month\nday()\t\t// returns std::chrono::day\n```", "```\n(date2.year() - date1.year()).count()\t\t// returns int\n(date2.month() - date1.month()).count()\t\t// returns int\n(date2.day() - date1.day()).count()\t\t\t// returns int\n```", "```\nauto the_year = static_cast<int>(date1.year());\nauto the_month = static_cast<unsigned>(date1.month());\nauto the_day = static_cast<unsigned>(date1.day());\n```", "```\n// date is now an alias for std::chrono\n\ndate::year_month_day ymd{ date::year{2002},\n\tdate::month{11}, date::day{14} };\n\nbool torf = ymd.ok();\t\t\t// true\n\ndate::year_month_day negative_year{ date::year{-1000},\n\tdate::October, date::day{10} };\n\ntorf = negative_year.ok();\t\t// true – negative year is valid\n\ndate::year_month_day ymd_invalid{ date::year{2018},\n\tdate::month{2}, date::day{31} };\n\ntorf = ymd_invalid.ok();\t\t\t// false\n\ndate::year_month_day ymd_completely_bogus{ date::year{-2004},\n\tdate::month{19}, date::day{58} };\n\ntorf = ymd_completely_bogus.ok();\t// false\n```", "```\ndate::year_month_day ymd_leap{ date::year{2016},\n\tdate::month{10}, date::day{26} };\n\ntorf = ymd_leap.year().is_leap()\t\t// true\n```", "```\ndate::year_month_day_last\n\teom_apr{ date::year{ 2009 } / date:April / date::last };\n\nauto last_day = static_cast<unsigned>(eom_apr.day());\t// result = 30\n```", "```\ndate::year_month_day ymd_eom{ date::year{2009},\n\tdate::month{4}, date::day{30} };\n\nbool torf = ymd_eom == eom_apr;\t\t// Returns true (torf = \"true or false\")\n```", "```\ndate::year_month_day ymd = date::year{ 2024 } / 2 / 21;\n\nyear_month_day_last\n\teom{ date::year{ ymd.year() } / date::month{ ymd.month() } / date::last };\n\nlast_day = static_cast<unsigned>(eom.day());\t// result = 29\n```", "```\nymd = eom_apr;\t\t\t// ymd is now 2009-04-30\n```", "```\n// User-defined last_day_of_the_month\nunsigned last_day_of_the_month(const std::chrono::year_month_day& ymd)\n{\n    constexpr std::array<unsigned, 12>\n        normal_end_dates{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\n    if (!(ymd.month() == date::February && ymd.year().is_leap()))\n    {\n        unsigned m = static_cast<unsigned>(ymd.month());\n        return normal_end_dates[m - 1];\n    }\n    else\n    {\n        return 29;\n    }\n}\n```", "```\n// Define a year_month_day date that falls on a business day (Wednesday)\n\ndate::year_month_day ymd_biz_day{ date::year{2022},\n\tdate::month{10}, date::day{26} };\t// Wednesday\n\n// Its day of the week can be constructed as a weekday object:\ndate::weekday dw{ date::sys_days(ymd_biz_day) };\n```", "```\nunsigned iso_code = dw.iso_encoding();\ncout << ymd_biz_day << \", \" << dw << \", \" << iso_code << endl;\n```", "```\nauto is_weekend = [](const date::year_month_day& ymd)->bool\n{\n\tdate::weekday dw{ date::sys_days(ymd) };\n\treturn dw.iso_encoding() >= 6;\n};\n```", "```\ndate::year_month_day ymd_weekend{ date::year{2022},\n\tdate::month{10}, date::day{29} };\t// Saturday\n```", "```\ntorf = is_weekend(ymd_biz_day);\t\t// false (Wed)\ntorf = is_weekend(ymd_weekend);\t\t// true (Sat)\n```", "```\n// Start with 2002-11-14\ndate::year_month_day ymd{ date::year{2002}, date::month{11}, date::day{14} };\n\nymd += date::years{ 2 };\t\t// ymd is now 2004-11-14\nymd += date::years{ 18 };\t\t// ymd is now 2022-11-14\n```", "```\ndate::year_month_day\n\tymd_feb_end{ date::year{2016}, date::month{2}, date::day{29} };\n\nymd_feb_end += date::years{ 2 };\t// Invalid result: 2018-02-29\n```", "```\ndate::year_month_day ymd{ date::year{2002}, date::month{11}, date::day{14} };\nymd += date::months(1);\t\t\t// Result: 2002-12-14\nymd += date::months(18);\t\t// Result: 2004-06-14\n```", "```\nymd -= date::months(2);\t\t// Result: 2004-04-14\n```", "```\ndate::year_month_day ymd_eom_1{ date::year{2015}, date::month{1},\n\tdate::day{31} };\ndate::year_month_day ymd_eom_2{ date::year{2014}, date::month{8},\n\tdate::day{31} };\ndate::year_month_day ymd_eom_3{ date::year{2016}, date::month{2},\n\tdate::day{29} };\n```", "```\nymd_eom_1 += date::months{ 1 };\t\t// 2015-02-31 is not a valid date\nymd_eom_2 += date::months{ 1 };\t\t// 2014-09-31 is not a valid date\nymd_eom_3 += date::months{ 12 };\t// 2017-02-29 is not a valid date\n```", "```\nauto add_months = [](date::year_month_day& ymd, unsigned mths) -> void\n{\n    ymd += date::months(mths);    // Naively attempt the addition\n\n    if (!ymd.ok())\n    {\n        ymd = ymd.year() / ymd.month() / date::day{ last_day_of_the_month(ymd) };\n    }\n}\n```", "```\ndate::year_month_day ymd{date::year(2022), date::month(10), date::day(7)};\n\n// Obtain the sys_days equivalent of ymd, and then add three days:\nauto add_days = date::sys_days(ymd3) + date::days(3);  // ymd still = 2022/10/07\n```", "```\nymd = add_days;\t// Implicit conversion to year_month_day\n\t\t\t\t// ymd is now = 2022-10-10\n```", "```\n==\n<=>\n```", "```\nChronoDate{ date::year_month_day };\n```", "```<⇒```", "```\n// Check state:\nint days_in_month() const;\nbool leap_year() const;\n\n// Arithmetic operations:\nunsigned operator - (const ChronoDate& rhs) const;\nChronoDate& add_years(int rhs_years);\nChronoDate& add_months(int rhs_months);\nChronoDate& add_days(int rhs_days);\n\n// Accessors\nint year() const;\nunsigned month() const;\nunsigned day() const;\nint serial_date() const;\ndate::year_month_day ymd() const;\n\n// Modfying function\nChronoDate& weekend_roll(); \t\t // Roll to business day if weekend\n\n// Operators\nbool operator == (const ChronoDate& rhs) const;\nstd::strong_ordering operator <=> (const ChronoDate& rhs) const;\n\n// friend operator so that we can output date details with cout\nfriend std::ostream& operator << (std::ostream& os, const ChronoDate& rhs);\n```", "```\nprivate:\n    date::year_month_day date_;\n    int serial_date_;\n    void reset_serial_date_();\n```", "```\nChronoDate::ChronoDate(int year, unsigned month, unsigned day) :\n\tdate_{ date::year{year} / date::month{month} / date::day{day} }\n{\n\tif(!date_.ok())\t\t// std::chrono member function to check if valid date\n\t{\n\t\tthrow std::exception e{ \"ChronoDate constructor: Invalid date.\" };\n\t}\n\treset_serial_date_();\n}\n```", "```\nvoid ChronoDate::reset_serial_date_()\n{\n\tserial_date_ = date::sys_days(date_).time_since_epoch().count();\n}\n```", "```\nChronoDate::ChronoDate():date_{date::year(1970), date::month{1}, date::day{1} } :\n    serial_date_{0} {}\n```", "```\nint ChronoDate::year() const\n{\n\treturn static_cast<int>(date_.year());\n}\n\nunsigned ChronoDate::month() const\n{\n\treturn static_cast<unsigned>(date_.month());\n}\n\nunsigned ChronoDate::day() const\n{\n\treturn static_cast<unsigned>(date_.day());\n}\n```", "```\nbool ChronoDate::leap_year() const\n{\n\treturn date_.year().is_leap();\n}\n```", "```\nunsigned ChronoDate::days_in_month() const\n{\n\tunsigned m = static_cast<unsigned>(date_.month());\n\tstd::array<unsigned, 12>\n        normal_end_dates{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };\n\n\treturn (m != 2 || !date_.year().is_leap() ? normal_end_dates[m - 1] : 29);\n}\n```", "```\nunsigned ChronoDate::operator - (const ChronoDate& rhs) const\n{\n\treturn this->serial_date_ - rhs.serial_date_;\n}\n```", "```\nChronoDate& ChronoDate::add_years(int rhs_years)\n{\n\t// Proceed naively:\n\tdate_ += date::years(rhs_years);\n\n\tif (!date_.ok())\n\t{\n\t\tdate_ = date_.year() / date_.month() / 28;\n\t}\n\n\treset_serial_date_();\n\n\treturn *this;\n}\n```", "```\nChronoDate& ChronoDate::add_months(int rhs_months)\n{\n\tdate_ += date::months(rhs_months);    // Naively attempt the addition\n\n\t// If the date is invalid, it is because the\n\t// result is an invalid end-of-month:\n\tif (!date_.ok())\n\t{\n\t\tdate_ = date_.year() / date_.month() / date::day{ days_in_month() };\n\t}\n\n\treset_serial_date_();\n\n\treturn *this;\n}\n```", "```\nChronoDate& ChronoDate::add_days(int rhs_days)\n{\n\tdate_ = date::sys_days(date_) + date::days(rhs_days);\n\n\treturn *this;\n}\n```", "```\nChronoDate& ChronoDate::weekend_roll() {\n    date::weekday wd{ sys_days(date_) };\n    month orig_mth{ date_.month() };\n\n    unsigned wdn{ wd.iso_encoding() }; // Mon =  1, ..., Sat = 6, Sun = 7\n    if (wdn > 5) date_ = sys_days(date_) + days(8 - wdn);\n\n    // If advance to next month, roll back; also handle roll to January\n    if (orig_mth < date_.month()\n        || (orig_mth == December && date_.month() == January))\n            date_ = sys_days(date_) - days(3);\n\n    reset_serial_date_();\n    return *this;\n}\n```", "```<⇒```", "```<⇒```", "```\nbool ChronoDate::operator == (const ChronoDate& rhs) const\n{\n\treturn date_ == rhs.date_;\n}\n\nstd::strong_ordering ChronoDate::operator <=> (const ChronoDate& rhs) const\n{\n\treturn date_ <=> rhs.date_;\n}\n```", "```\n// This is a 'friend' of the ChronoDate class\nexport std::ostream& operator << (std::ostream& os, const ChronoDate& rhs)\n{\n\tos << rhs.ymd();\n\treturn os;\n}\n```", "```\nexport class DayCount\n{\npublic:\n\tvirtual double operator()\n        (const ChronoDate& date1, const ChronoDate& date2) const = 0;\n\n\tvirtual ~DayCount() = default;\n};\n```", "```\nexport class Act365 : public DayCount\n{\npublic:\n\tdouble operator() (const ChronoDate& date1, const ChronoDate& date2) const\n        override\n    {\n        return (date2 - date1) / 365.0;\n    }\n};\n```", "```\nexport class Thirty360 : public DayCount\n{\npublic:\n\tdouble operator()\n        (const ChronoDate& date1, const ChronoDate& date2) const override\n    {\n        return static_cast<double>( date_diff_(date1, date2)) / 360.0;\n    }\n\nprivate:\n\tunsigned date_diff_(const ChronoDate& date1, const ChronoDate& date2) const\n\t{\n\t    unsigned d1, d2;\n        d1 = date1.day();\n        d2 = date2.day();\n\n        auto f = [](unsigned& d) {\n\t    if (d == 31)\n\t\t{\n\t\t\td = 30;\n\t\t}\n\t}\n\n        f(d1);\n        f(d2);\n\n        return 360 * (date2.year() - date1.year()) + 30 * (date2.month() –\n            date1.month()) + d2 - d1;\n    }\n};\n```", "```\n\tAct365 act_365{};\n\tAct360 act_360{};\n\tThirty360 thirty_360{};\n\n\tChronoDate sd1{ 2021, 4, 26 };\n\tChronoDate ed1{ 2023, 10, 26 };\n\tChronoDate sd2{ 2022, 10, 10 };\n\tChronoDate ed2{ 2023, 4, 10 };\n\n\tauto yf_act_365_01 = act_365(sd1, ed1);\t// 2.50137\n\tauto yf_act_365_02 = act_365(sd2, ed2);\t// 0.49863\n\n\tauto yf_act_360_01 = act_360(sd1, ed1);\t// 2.53611\n\tauto yf_act_360_02 = act_360(sd2, ed2);\t// 0.505556\n\n\tauto yf_thirty_01 = thirty_360(sd1, ed1);\t// 2.5\n\tauto yf_thirty_02 = thirty_360(sd2, ed2);\t// 0.5\n```", "```\ndouble treasury_bill(const ChronoDate& sett_date,\n\tconst ChronoDate& maturity_date, double mkt_yield, double face_value,\n\tconst DayCount& dc)\n{\n\t// pp 40-41, Steiner\n\treturn face_value / (1.0 + mkt_yield * dc(sett_date, maturity_date));\n}\n```", "```\nexport class YieldCurve\n{\npublic:\n\t// d1 <= d2 < infinity\n\tdouble discount_factor(const ChronoDate& d1, const ChronoDate& d2) const;\n\tvirtual ~YieldCurve() = default;\n\nprotected:\n\tChronoDate settle_;\n\nprivate:\n\tAct365 act365_{};\n\n\tvirtual double yield_curve_(double t) const = 0;\n};\n```", "```\ndouble YieldCurve::discount_factor(const ChronoDate& d1, const ChronoDate& d2) const\n{\n\tif (d2 < d1)\n\t\tthrow std::exception(\"YieldCurve::discount_factor: d2 < d1\");\n\n\tif (d1 < settle_ || d2 < settle_)\n\t\tthrow std::exception(\"YieldCurve::discount_factor: date < settle\");\n\n\t// P(t1, t2) = exp( -(t2-t1) * f(t1, t2) )\n\n\t// if d1 == settle_ then P(t1,t2) = P(0,t2) = exp(-t2 * y2 )\n\tdouble t2 = act365_(settle_, d2);\n\tdouble y2 = yield_curve_(t2);\n\tif (d1 == settle_) return exp(-t2 * y2);\n\n\tdouble t1 = act365_(settle_, d1);\n\tdouble y1 = yield_curve_(t1);\n\t// (t2-t1) f(t1,t2) = t2 * y2 - t1 * y1\n\treturn exp(t1 * y1 - t2 * y2);\n}\n```", "```\nexport class LinearInterpYieldCurve final : public YieldCurve\n{\npublic:\n\tLinearInterpYieldCurve(\n\t\tconst ChronoDate& settle_date,\n\t\tconst vector<double>& maturities,   \t// In Act/365 years.\n\t\tconst vector<double>& spot_yields); \t// Continuously compounded,\n\t\t\t\t\t\t\t\t\t\t\t\t// Act/365 day count basis\n\nprivate:\n\tvector<double> maturities_; // maturities in years\n\tvector<double> yields_;\n\n\tdouble yield_curve_(const double t) const override;\n};\n```", "```\nLinearInterpYieldCurve::LinearInterpYieldCurve(\n\tconst ChronoDate& settle_date,\n\tconst vector<double>& maturities,\n\tconst vector<double>& spot_yields) : maturities_{ maturities },\n\t\tyields_{ spot_yields }\t// Maybe move semantics instead?\n{\n\tsettle_ = settle_date;\n\n\tif (maturities.size() != spot_yields.size())\n    throw std::exception(\"LinearInterpYieldCurve: maturities and spot_yields are different lengths\");\n\n\tif (maturities.front() < 0.0 )\n\t  throw std::exception(\"LinearInterpYieldCurve: first maturity cannot be negative\");\n\n\t// Assume maturities are in order\n}\n```", "```\ndouble LinearInterpYieldCurve::yield_curve_(const double t) const\n{\n\t// interp_yield called from discount_factor, so maturities_front() <= t\n\n\tif (t >= maturities_.back())\n\t{\n\t\tauto check{ maturities_.back() };\n\t\treturn yields_.back();\n\t}\n\n\t// Now know maturities_front() <= t < maturities_.back()\n\tsize_t indx{ 0 };\n\twhile (maturities_[indx + 1] < t) ++indx;\n\treturn yields_[indx] + (yields_[indx + 1] - yields_[indx])\n\t\t/ (maturities_[indx + 1] - maturities_[indx]) * (t - maturities_[indx]);\n}\n```", "```\nexport class Bond\n{\npublic:\n\tBond(string bond_id, const ChronoDate& issue_date, const ChronoDate& first_coupon_date,\n\t\tconst ChronoDate& penultimate_couppn_date, const ChronoDate& maturity_date,\n\t\tint coupon_frequency, double coupon_rate, double face_value);\n\n\tdouble discounted_value(const ChronoDate& bond_settle_date,\n\t\tconst YieldCurve& yield_curve);\n\n\tstring bond_id() const;\n\nprivate:\n\tstring bond_id_;\n\n\tvector<ChronoDate> due_dates_;    \t// Dates on which payments are due,\n\t\t\t\t\t\t\t\t\t\t// whether business days or not.\n\tvector<ChronoDate> payment_dates_;\t// Business dates on which payments are made.\n\tvector<double> payment_amounts_;\n};\n```", "```\nBond::Bond(string bond_id, const ChronoDate& issue_date, const ChronoDate& first_coupon_date,\n\tconst ChronoDate& penultimate_coupon_date, const ChronoDate& maturity_date,\n\tint coupon_frequency, double coupon_rate, double face_value) : bond_id_(bond_id)\n{\n\n \t// (1) Number of months in coupon period:\n\tconst int months_in_regular_coupon_period = 12 / coupon_frequency;\n\n\t// (2) Regular coupon payment:\n\tconst double regular_coupon_payment = coupon_rate * face_value / coupon_frequency;\n\n\t// (3) Generate vectors containing due dates, payment dates,\n\t// and regular coupon payment amounts:\n\tfor (ChronoDate regular_due_date{ first_coupon_date };\n\t\tregular_due_date <= penultimate_coupon_date;\n\t\tregular_due_date.add_months(months_in_regular_coupon_period))\n\t{\n\t\t// The due and payment Dates\n\t\tdue_dates_.push_back(regular_due_date);\n\t\tChronoDate payment_date{ regular_due_date };\n\n\t\t// (4) Roll any due dates falling on a weekend:\n\t\tpayment_dates_.push_back(payment_date.weekend_roll());\n\t\t// Assume all coupons are regular; deal with short first period later.\n\t\tpayment_amounts_.push_back(regular_coupon_payment);\n\t}\n\n\t// (5) If first coupon is irregular, amend the coupon payment:\n\t// Calculate the first_prior, the last regular date before first_coupon_date.\n\tChronoDate first_prior{ first_coupon_date };\n\tfirst_prior.add_months(-months_in_regular_coupon_period);\n\tif (first_prior != issue_date) // if true then irregular coupon\n\t{\n\t\tif (first_prior < issue_date) // if true then short coupon period\n\t\t{\n\t\t\tdouble coupon_fraction =\n\t\t\t\tstatic_cast<double>(first_coupon_date - issue_date) /\n\t\t\t\tstatic_cast<double>(first_coupon_date - first_prior );\n\t\t\tpayment_amounts_[0] *= coupon_fraction;\n\t\t}\n\t\telse // issue_date < first_prior, so long coupon period\n\t\t{\n\t\t\t// long_first_coupon = regular_coupon + extra_interest\n\t\t\t// Calculate the second_prior, the last regular date before the first_prior\n\t\t\tChronoDate second_prior{ first_prior };\n\t\t\tsecond_prior.add_months(-months_in_regular_coupon_period);\n\t\t\tdouble coupon_fraction =\n\t\t\t\tstatic_cast<double>(first_prior - issue_date) /\n\t\t\t\t\tstatic_cast<double>(first_prior - second_prior);\n\t\t\tpayment_amounts_[0] += coupon_fraction * regular_coupon_payment;\n\t\t}\n\t}\n\n  // (6) The maturity date is a due date which falls on a business day:\n\tdue_dates_.push_back( maturity_date );\n\tpayment_dates_.push_back( maturity_date );\n\t// Assume maturity date is a regular due date:\n\tdouble final_coupon{ regular_coupon_payment };\n\n  // (7) If final coupon period is irregular amend the coupon payment\n  // Calculate maturity_regular_date, the first regular date after penultimate_coupon_date\n\tChronoDate maturity_regular_date{ penultimate_coupon_date };\n\tmaturity_regular_date.add_months(months_in_regular_coupon_period);\n\tif (maturity_regular_date != maturity_date) // if true then irregular coupon period\n\t{\n\t\tif (maturity_date < maturity_regular_date) // if true then short coupon period\n\t\t{\n\t\t\tdouble coupon_fraction =\n\t\t\t\tstatic_cast<double>(maturity_date - penultimate_coupon_date) /\n\t\t\t\tstatic_cast<double>(maturity_regular_date - penultimate_coupon_date);\n\t\t\tfinal_coupon *= coupon_fraction;\n\t\t}\n\t\telse  // maturity_regular_date < maturity_date, do long coupon period\n\t\t{\n\t\t\t// final_coupon = regular_coupon_amount + extra_interest\n\t\t\t// Calculate the next_regular_date, the first regular date\n\t\t\t// after the maturity_regular_date\n\t\t\tChronoDate next_regular_date{ maturity_regular_date };\n\t\t\tnext_regular_date.add_months(months_in_regular_coupon_period);\n\t\t\tdouble extra_coupon_fraction =\n\t\t\t\tstatic_cast<double>(maturity_date - maturity_regular_date) /\n\t\t\tstatic_cast<double>(next_regular_date - maturity_regular_date);\n\t\t\tfinal_coupon += extra_coupon_fraction * regular_coupon_payment;\n\t  }\n\t}\n\n\t// (8) Calculate final payment:\n\tpayment_amounts_.push_back(face_value + final_coupon);\n\n}\n```", "```\ndouble Bond::discounted_value(const ChronoDate& bond_settle_date,\n     const YieldCurve& yield_curve)\n{\n\t// The buyer receives the payments which fall due after the bond_settle_date\n\t// If the bond_settle_date falls on a due_date the seller receives the payment\n\tdouble pv{ 0.0 };\n\tfor (size_t i{ 0 }; i < due_dates_.size(); i++)\n\t{\n\t\tif (bond_settle_date < due_dates_[i])\n\t\t\tpv += yield_curve.discount_factor(bond_settle_date, payment_dates_[i])\n\t\t\t\t* payment_amounts_[i];\n\t}\n\treturn pv;\n}\n```", "```\nstd::string bond_id = \"20 yr bond\"; // normal 20 year bond\n\nChronoDate issue_date{ 2023, 5, 8 };\t\t   \t\t// (Mon)\nChronoDate first_coupon_date{ 2023, 11, 7 };       \t// Short first coupon (Tue)\nChronoDate penultimate_coupon_date{ 2042, 5, 7 };  \t// (Wed)\nChronoDate maturity_date{ 2042, 11, 7 };           \t// Long final coupon (Fri)\n\nint coupon_frequency{ 2 };\ndouble coupon_rate{ 0.062 };\ndouble face_value{ 1000.00 };\nConstruction of the bond is then straightforward:\nBond bond_20_yr{ bond_id, issue_date, first_coupon_date, penultimate_coupon_date,\n\t\tmaturity_date, coupon_frequency, coupon_rate, face_value, day_count };\n```", "```\nstd::vector<double> maturities{0.00273973, 0.252055, . . ., 30.0219};\nstd::vector<double> spot_yields{0.0200219, 0.021924, . . ., 0.0400049};\n```", "```\nChronoDate spot_settle_date{ 2023, 10, 10 };\n```", "```\nLinearInterpYieldCurve yc{ spot_settle_date, maturities , spot_yields };\n```", "```\ndouble value = bond_20_yr.discounted_value(spot_settle_date, yc);\n```"]