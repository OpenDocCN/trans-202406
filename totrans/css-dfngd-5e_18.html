<html><head></head><body><section data-pdf-bookmark="Chapter 18. Transitions" data-type="chapter" epub:type="chapter"><div class="chapter" id="x-transitions">&#13;
<h1><span class="label">Chapter 18. </span>Transitions</h1>&#13;
&#13;
&#13;
<p>CSS <a data-primary="transitions" data-type="indexterm" id="ix_transition_ch18"/>transitions allow us to animate CSS properties from an original&#13;
value to a new value over time.  These changes <em>transition</em> an element from one state to another, in response to a change. This usually involves a user interaction but can also be due to a scripted change of class, ID, or other state.</p>&#13;
&#13;
<p>Normally, when a CSS property value changes—when a <em>style change&#13;
event</em> occurs—the change is instantaneous. The new property value&#13;
replaces the old property in the milliseconds it takes to repaint the page (or to reflow and repaint, when necessary). Most value&#13;
changes seem instantaneous, taking fewer than 16 milliseconds to render. Even if the changes take longer than that (like when a large image is replaced with one that isn’t pre-fetched—which isn’t a transition, just poor performance), it is still a single step from one value to the&#13;
next. For example, when changing a background color on mouse hover, the&#13;
background immediately changes from one color to the other, with no gradual transition.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CSS Transitions" data-type="sect1"><div class="sect1" id="css-transitions">&#13;
<h1>CSS Transitions</h1>&#13;
&#13;
<p>CSS transitions provide a way to control how a property changes from one value to the next over a period of time.  Thus, we can make the property values change gradually, creating (hopefully) pleasant and unobtrusive effects. For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">button</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">magenta</code><code class="p">;</code>&#13;
    <code class="k">transition</code><code class="o">:</code> <code class="n">color</code> <code class="m">200ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code> <code class="m">50ms</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">button</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">rebeccapurple</code><code class="p">;</code>&#13;
    <code class="k">transition</code><code class="o">:</code> <code class="n">color</code> <code class="m">200ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">out</code> <code class="m">50ms</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, instead of instantaneously changing a&#13;
button’s <code>color</code> value on hover, that <code>transition</code> property means the button’s <code>color</code> will gradually fade from <code>magenta</code> to <code>rebeccapurple</code> over 200 milliseconds, even adding a 50-millisecond delay before starting &#13;
<span class="keep-together">the transition.</span></p>&#13;
&#13;
<p>In the unlikely event that a browser doesn’t support CSS transition properties, the change is immediate instead of gradual, which is completely fine. If a given property or some property values aren’t&#13;
animatable, again, the change will be immediate instead of gradual.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>When <a data-primary="animatable properties" data-type="indexterm" id="idm45176041173760"/><a data-primary="properties" data-secondary="animatable" data-type="indexterm" id="idm45176041173024"/><a data-primary="transitions" data-secondary="animatable properties for" data-type="indexterm" id="idm45176041172080"/>we say <em>animatable</em>, we mean any properties that can be animated, whether through transitions or animations (the subject of the next chapter, <a data-type="xref" href="ch19.html#animation">Chapter 19</a>). The property definition boxes throughout the book indicate whether a given property is &#13;
<span class="keep-together">animatable.</span></p>&#13;
</div>&#13;
&#13;
<p>Often you will want instantaneous value changes. For example,&#13;
link colors usually change instantly on&#13;
hover or focus, informing sighted users that an interaction is occurring&#13;
and that the focused content is a link. Similarly, options in an&#13;
autocomplete listbox shouldn’t fade in: you want the options to appear&#13;
instantly, rather than fade in more slowly than the user types. Instantaneous&#13;
value changes are often the best user experience.</p>&#13;
&#13;
<p>At other times, you’ll want a property’s value to change more gradually,&#13;
bringing attention to what is occurring.&#13;
For example, you may want to make a card game more realistic by taking&#13;
200 milliseconds to animate the flipping of a card, as the user may not&#13;
realize what happened if there is no animation. <a class="play" href="https://meyerweb.github.io/csstdg5figs/18-transitions/cardflip.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Look for the Play symbol <span class="play"><img src="assets/play-icon-round.png"/></span> to know when an online example is available. All of the examples in this chapter can be found at <a class="bare" href="https://meyerweb.github.io/csstdg5figs/18-transitions"><em class="hyperlink">https://meyerweb.github.io/csstdg5figs/18-transitions</em></a>.</p>&#13;
</div>&#13;
&#13;
<p>As another example, you may want some drop-down menus to expand&#13;
<span class="keep-together">or become</span> visible over 200 milliseconds (instead of instantly, which may be&#13;
jarring). With transitions, you can make a drop-down menu appear&#13;
slowly. In <a data-type="xref" href="#tr_fig01">Figure 18-1</a> <a class="play" href="https://meyerweb.github.io/csstdg5figs/18-transitions/menus-initial-midtransition-and-final-state.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a>, we transition the submenu’s height by making a scale transform. This is a common use for CSS transitions, which we will also explore later in this chapter.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Especially <a data-primary="accessibility issues" data-secondary="rapid transitions" data-type="indexterm" id="idm45176041131328"/>rapid transitions, particularly those that move over&#13;
large distances or take up major parts of a page,&#13;
 <em>can potentially lead to seizures in some users.</em>&#13;
To reduce or eliminate this risk, use the <code>prefers-reduced-motion</code> media query&#13;
(see <a data-type="xref" href="ch21.html#css-at-rules">Chapter 21</a>).&#13;
Always keep these concerns in mind, and ensure the accessibility of your designs to&#13;
people with epilepsy and other seizure disorders.</p>&#13;
</div>&#13;
&#13;
<figure><div class="figure" id="tr_fig01">&#13;
<img alt="css5 1801" src="assets/css5_1801.png"/>&#13;
<h6><span class="label">Figure 18-1. </span>Initial transition, midtransition, and final state</h6>&#13;
</div></figure>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transition Properties" data-type="sect1"><div class="sect1" id="transition-properties">&#13;
<h1>Transition Properties</h1>&#13;
&#13;
<p>In CSS, transitions are written using four transition properties:&#13;
<code>transition-property</code>, <code>transition-duration</code>,&#13;
<code>transition-timing-function</code>, and <code>transition-delay</code>, along with the&#13;
<code>transition</code> property as a shorthand for those four.</p>&#13;
&#13;
<p>To <a data-primary="transitions" data-secondary="on transform property" data-secondary-sortas="transform property" data-type="indexterm" id="ix_transition_transform"/>create the drop-down navigation in <a data-type="xref" href="#tr_fig01">Figure 18-1</a>, we used all four CSS transition properties, as well as some transform properties defining the beginning and end states of the transition. The following code defines the transition for that example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="nt">li</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">transform</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="p">;</code>&#13;
    <code class="k">transition-delay</code><code class="o">:</code> <code class="m">50ms</code><code class="p">;</code>&#13;
    <code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="o">,</code> <code class="m">0</code><code class="p">);</code>&#13;
    <code class="k">transform-origin</code><code class="o">:</code> <code class="nb">top</code> <code class="nb">center</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">nav</code> <code class="nt">li</code><code class="nd">:is</code><code class="o">(</code><code class="nd">:hover</code><code class="o">,</code> <code class="nd">:focus</code><code class="o">)</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="o">,</code> <code class="m">1</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Although we are using the <code>:hover</code> and <code>:focus</code> states for the style change event in this example, you can transition properties in other scenarios too. For example, you might add or remove a class, or otherwise change the state—say, by changing an input from <code>:invalid</code> to <code>:valid</code> or from <code>:checked</code> to <code>:not(:checked)</code>. Or you might append a table row at the end of a zebra-striped table or a list item at the end of a list with styles based on <code>:nth-last-of-type</code> selectors.</p>&#13;
&#13;
<p>In <a data-type="xref" href="#tr_fig01">Figure 18-1</a>, the initial <a data-primary="initial state, transitions and animations" data-type="indexterm" id="ix_initial_transition"/><a data-primary="transitions" data-secondary="initial state" data-type="indexterm" id="ix_transition_initial_state"/>state of the nested&#13;
lists is <code class="keep-together">transform:</code> <code>scale(1, 0)</code> with a&#13;
<code>transform-origin: top center</code>. The final state <span class="keep-together"> is <code>transform:</code></span> <code>scale(1, 1)</code>, while the <code>transform-origin</code> remains the same.&#13;
(For more information on transform properties, see <a data-type="xref" href="ch17.html#transforms">Chapter 17</a>.)</p>&#13;
&#13;
<p>In this example, the transition properties define a transition on the <code>transform</code> property: when the new <code>transform</code> value is set on <code>hover</code>, the nested unordered list scales to its original, default size, changing&#13;
smoothly between the old value of <code>transform: scale(1, 0)</code> and the new&#13;
value of <code>transform: scale(1, 1)</code>, all over a period of 200 milliseconds.&#13;
This transition starts after a 50-millisecond delay, and <em>eases in</em>, which means it proceeds slowly at first, then picks up speed as it progresses.</p>&#13;
&#13;
<p>Whenever an animatable target property changes, if a transition is set on that property, the browser will apply a transition to make the change&#13;
gradual.</p>&#13;
&#13;
<p>Note that all the transition properties were set for the default unhovered/unfocused state of the <code>&lt;ul&gt;</code> elements.  These states were used to change only the transform, not the transition.  There’s a very good reason for this: it means that the menus not only will slide open when the state change happens, but also will slide closed when the hover or focus state ends.</p>&#13;
&#13;
<p>Imagine that the transition properties were applied to the interaction states instead, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="nt">li</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="o">,</code> <code class="m">0</code><code class="p">);</code>&#13;
    <code class="k">transform-origin</code><code class="o">:</code> <code class="nb">top</code> <code class="nb">center</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">nav</code> <code class="nt">li</code><code class="nd">:is</code><code class="o">(</code><code class="nd">:hover</code><code class="o">,</code> <code class="nd">:focus</code><code class="o">)</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">transform</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="p">;</code>&#13;
    <code class="k">transition-delay</code><code class="o">:</code> <code class="m">50ms</code><code class="p">;</code>&#13;
    <code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="o">,</code> <code class="m">1</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>That would mean that when <em>not</em> hovered or focused, the element would have default transition values—which is to say, no transitions or instantaneous transitions. The menus in our previous example would slide open, but instantly disappear when the interaction state ends—because no longer being in an interactive state, the transition properties would no longer apply!</p>&#13;
&#13;
<p>Maybe you want exactly this effect: slide smoothly open but instantly disappear. If so, then apply the transitions as shown in the previous example. Otherwise, apply them to the element in the default state directly so that the transitions will apply as the interaction state is both entered and exited. When the state change is exited, the transition timing is reversed. You can override this default reverse&#13;
transition by declaring different transitions in both the initial and&#13;
changed states.</p>&#13;
&#13;
<p>By <em>initial state</em>, we mean a state that matches&#13;
the element at page load time.  It could mean a content-editable element that could get&#13;
<code>:focus</code>, as in the following: <a class="play" href="https://meyerweb.github.io/csstdg5figs/18-transitions/contenteditable.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></p>&#13;
<pre data-code-language="css" data-type="programlisting"><code class="c">/* selector that matches elements </code><strong><code class="c">all</code></strong><code class="c"> the time */</code><code>&#13;
</code><code class="nt">p</code><code class="o">[</code><code class="nt">contenteditable</code><code class="o">]</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">background-color</code><code class="o">:</code><code> </code><code class="k">background-color</code><code class="o">:</code><code> </code><code class="nb">rgb</code><code class="p">(</code><code class="m">0</code><code> </code><code class="m">0</code><code> </code><code class="m">0</code><code> </code><code class="o">/</code><code> </code><code class="m">0</code><code class="p">);</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="c">/* selector that matches elements </code><strong><code class="c">some</code></strong><code class="c"> of the time */</code><code>&#13;
</code><code class="nt">p</code><code class="o">[</code><code class="nt">contenteditable</code><code class="o">]</code><code class="nd">:focus</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="c">/* overriding declaration */</code><code>&#13;
    </code><code class="k">background-color</code><code class="o">:</code><code> </code><code class="k">background-color</code><code class="o">:</code><code> </code><code class="nb">rgb</code><code class="p">(</code><code class="m">0</code><code> </code><code class="m">0</code><code> </code><code class="m">0</code><code> </code><code class="o">/</code><code> </code><code class="m">0</code><code class="o">.</code><code class="m">1</code><code class="p">);</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>In this example, the fully transparent background is always the initial&#13;
state, changing only when the user gives the element focus. This is what we mean when we say <em>initial</em> or <em>default</em> value throughout this chapter. The transition properties included in the selector that matches the element all the time will impact that element whenever the state changes, including from the initial state to the changed state (being focused, in the preceding example).</p>&#13;
&#13;
<p>An initial state could also be a temporary state that may change, such&#13;
as a <code>:checked</code> checkbox or a <code>:valid</code> form control, or even a class&#13;
that gets toggled on and off:</p>&#13;
<pre data-code-language="css" data-type="programlisting"><code class="c">/* selector that matches elements </code><strong><code class="c">some</code></strong><code class="c"> of the time */</code><code>&#13;
</code><code class="nt">input</code><code class="nd">:valid</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">border-color</code><code class="o">:</code><code> </code><code class="nb">green</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="c">/* selector that matches elements </code><strong><code class="c">some</code></strong><code class="c"> of the time,&#13;
   when the prior selector does NOT match. */</code><code>&#13;
</code><code class="nt">input</code><code class="nd">:invalid</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="k">border-color</code><code class="o">:</code><code> </code><code class="nb">red</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="c">/* selector that matches elements </code><strong><code class="c">some</code></strong><code class="c"> of the time,&#13;
   whether the input is valid or invalid */</code><code>&#13;
</code><code class="nt">input</code><code class="nd">:focus</code><code> </code><code class="p">{</code><code>&#13;
    </code><code class="c">/* alternative declaration */</code><code>&#13;
    </code><code class="k">border-color</code><code class="o">:</code><code> </code><code class="nb">yellow</code><code class="p">;</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code></pre>&#13;
&#13;
<p>In this example, either the <code>:valid</code> or <code>:invalid</code> selector can match any given element, but&#13;
never both.  The <code>:focus</code> selector, as shown in <a data-type="xref" href="#tr_fig0202">Figure 18-2</a>, matches whenever an input has focus, regardless of whether the&#13;
input is matching the <code>:valid</code> or <code>:invalid</code> selector &#13;
<span class="keep-together">simultaneously.</span></p>&#13;
&#13;
<p>In&#13;
this case, when we refer to the initial state, we are referring to the&#13;
original value, which could be either <code>:valid</code> or <code class="keep-together">:invalid</code>.&#13;
The changed state for a given element is the opposite of the initial <code>:valid</code>&#13;
or <code>:invalid</code> state. <a class="play" href="https://meyerweb.github.io/csstdg5figs/18-transitions/input-appearance-valid-invalid-focus.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></p>&#13;
&#13;
<figure><div class="figure" id="tr_fig0202">&#13;
<img alt="css5 1802" src="assets/css5_1802.png"/>&#13;
<h6><span class="label">Figure 18-2. </span>The input’s appearance in the valid, invalid, and focused states</h6>&#13;
</div></figure>&#13;
&#13;
<p>Remember, you can apply different transition values to the initial and changed states, but you always want to apply the value used when you <em>enter</em> a given state.  Take the following code as an example, where the transitions are set up to have menus slide open over 2 seconds but close in just 200 milliseconds:<a data-primary="" data-startref="ix_initial_transition" data-type="indexterm" id="idm45176040749552"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="nt">li</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">transform</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="p">;</code>&#13;
    <code class="k">transition-delay</code><code class="o">:</code> <code class="m">50ms</code><code class="p">;</code>&#13;
    <code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="o">,</code> <code class="m">0</code><code class="p">);</code>&#13;
    <code class="k">transform-origin</code><code class="o">:</code> <code class="nb">top</code> <code class="nb">center</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">nav</code> <code class="nt">li</code><code class="nd">:is</code><code class="o">(</code><code class="nd">:hover</code><code class="o">,</code> <code class="nd">:focus</code><code class="o">)</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">transform</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">2s</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">linear</code><code class="p">;</code>&#13;
    <code class="k">transition-delay</code><code class="o">:</code> <code class="m">1s</code><code class="p">;</code>&#13;
    <code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="o">,</code> <code class="m">1</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This provides a horrible user experience, but it illustrates the point. <a class="play" href="https://meyerweb.github.io/csstdg5figs/18-transitions/menus-very-slow-transition.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a> When hovered or focused, the opening of the&#13;
navigation takes a full 2 seconds. When closing, it quickly closes over&#13;
0.2 seconds. The transition properties in the changed state&#13;
are in force when a list item is hovered or focused.  Thus, the <code>transition-duration: 2s</code> defined for these states takes effect.&#13;
When a menu is no longer hovered or focused, it&#13;
returns to the default scaled-down state, and the transition properties of&#13;
the initial state—the <code>nav li ul</code> condition—are used, causing the menu to take 200 milliseconds to close.</p>&#13;
&#13;
<p>Look more closely at the example, specifically the default transition styles.&#13;
When the user stops hovering over or focusing on the parent&#13;
navigational element or the child drop-down menu, the drop-down menu&#13;
delays 50 milliseconds before starting the <code>200ms</code> transition to close.  This is actually a decent user experience style, because it give users a chance (however brief) to get the mouse pointer or focused ring back on a menu before it starts <span class="keep-together">closing</span>.</p>&#13;
&#13;
<p>While the four transition properties can be declared separately, you&#13;
will probably always use the shorthand. We’ll take a look at the four&#13;
properties individually first so you have a good understanding of what&#13;
each one does.<a data-primary="" data-startref="ix_transition_transform" data-type="indexterm" id="idm45176040629600"/><a data-primary="" data-startref="ix_transition_initial_state" data-type="indexterm" id="idm45176040628624"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Limiting Transition Effects by Property" data-type="sect2"><div class="sect2" id="the-transition-property-property">&#13;
<h2>Limiting Transition Effects by Property</h2>&#13;
&#13;
<p>The <code>transition-property</code> property<a data-primary="transitions" data-secondary="limiting effects by property" data-type="indexterm" id="ix_transition_limits"/><a data-primary="transition-property property" data-type="indexterm" id="ix_transition_prop_prop"/> specifies the names of the CSS&#13;
properties you want to transition.  This allows you to limit the transition to only certain properties, while having other properties change instantaneously. And, yes, it’s weird to say “the <code>transition-property</code> property.”</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="transition-property">&#13;
<h1>transition-property</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p><code>none</code> | [ <code>all</code> | &lt;<em><code>property-name</code></em>&gt; ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>all</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements and <code>:before</code> and <code>:after</code> pseudo-elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The value of <code>transition-property</code> is a comma-separated list of&#13;
properties; the keyword <code>none</code> if you want no properties transitioned;&#13;
or the default <code>all</code>, which means “transition all the animatable&#13;
properties.” You can also include the keyword <code>all</code> within a&#13;
comma-separated list of properties.</p>&#13;
&#13;
<p>If you include <code>all</code> as the only keyword—or default to <code>all</code>—all animatable&#13;
properties will transition in unison. Let’s say you want to change a box’s appearance on hover:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#ff0000</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#00ff00</code><code class="p">;</code>&#13;
    <code class="k">border-radius</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">1</code><code class="p">)</code> <code class="n">rotate</code><code class="p">(</code><code class="m">0deg</code><code class="p">);</code>&#13;
    <code class="k">opacity</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">box-shadow</code><code class="o">:</code> <code class="m">3px</code> <code class="m">3px</code> <code class="nb">rgb</code><code class="p">(</code><code class="m">0</code> <code class="m">0</code> <code class="m">0</code> <code class="o">/</code> <code class="m">0</code><code class="o">.</code><code class="m">1</code><code class="p">);</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">div</code><code class="nd">:hover</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#000000</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">5px</code> <code class="nb">dashed</code> <code class="m">#000000</code><code class="p">;</code>&#13;
    <code class="k">border-radius</code><code class="o">:</code> <code class="m">50%</code><code class="p">;</code>&#13;
    <code class="k">transform</code><code class="o">:</code> <code class="n">scale</code><code class="p">(</code><code class="m">2</code><code class="p">)</code> <code class="n">rotate</code><code class="p">(</code><code class="m">-10deg</code><code class="p">);</code>&#13;
    <code class="k">opacity</code><code class="o">:</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">;</code>&#13;
    <code class="k">box-shadow</code><code class="o">:</code> <code class="m">-3px</code> <code class="m">-3px</code> <code class="nb">rgb</code><code class="p">(</code><code class="m">255</code> <code class="m">0</code> <code class="m">0</code> <code class="o">/</code> <code class="m">0</code><code class="o">.</code><code class="m">5</code><code class="p">);</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">20px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When the mouse pointer hovers over the <code>&lt;div&gt;</code>, every property that has a different value in the initial state versus the hovered (changed) state will change to the hover-state values. <a data-primary="animatable properties" data-type="indexterm" id="idm45176040599760"/><a data-primary="properties" data-secondary="animatable" data-type="indexterm" id="idm45176040599152"/><a data-primary="transitions" data-secondary="animatable properties for" data-type="indexterm" id="idm45176040437664"/>The <code>transition-property</code> property is used to define which of those properties are animated over time (versus those that change instantly, without animating). All the properties change from the default value to the hovered value on <code>hover</code>, but only the animatable properties included in the <code>transition-property</code> will change over the transition’s duration. Nonanimatable properties like <code>border-style</code> change from one value to the next instantly.</p>&#13;
&#13;
<p>If <code>all</code> is the only value or the last value&#13;
in the comma-separated value for <code>transition-property</code>, all the&#13;
animatable properties will transition in unison.  Otherwise, provide a comma-separated list of properties to be affected by the transition properties.</p>&#13;
&#13;
<p>Thus, if we want to transition all the properties, the following statements&#13;
are almost equivalent:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#ff0000</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#00ff00</code><code class="p">;</code>&#13;
    <code class="k">border-radius</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">opacity</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code> <code class="n">opacity</code><code class="o">,</code>&#13;
        <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">1s</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#ff0000</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#00ff00</code><code class="p">;</code>&#13;
    <code class="k">border-radius</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">opacity</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">all</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">1s</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Both <code>transition-property</code> property declarations will transition all the&#13;
properties listed—but the former will transition only the six&#13;
properties that may change.</p>&#13;
&#13;
<p>The <code>transition-property: all</code> in the latter rule ensures that <em>all</em> animatable property values that would change based on any style change event—no matter which CSS rule block includes the changed property value—transitions over 1 second. The transition applies to all animatable properties applied to all the elements matched by the selector, not just the properties declared in the same style block as the <code>all</code>.</p>&#13;
&#13;
<p>In this case, the first version limits the transition to only the six&#13;
properties listed, but enables us to provide more control over how each&#13;
property will transition. Declaring the properties individually lets&#13;
us provide different speeds, delays, <span class="keep-together">and/or</span> durations to each&#13;
property’s transition:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#ff0000</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#0f0</code><code class="p">;</code>&#13;
    <code class="k">border-radius</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">opacity</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nc">.foo</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#00ff00</code><code class="p">;</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code> <code class="n">opacity</code><code class="o">,</code>&#13;
        <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">1s</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<pre data-code-language="html" data-type="programlisting"><code class="p">&lt;</code><code class="nt">div</code> <code class="na">class</code><code class="o">=</code><code class="s">"foo"</code><code class="p">&gt;</code>Hello<code class="p">&lt;/</code><code class="nt">div</code><code class="p">&gt;</code></pre>&#13;
&#13;
<p>If you want to define the transitions for each property separately,&#13;
write them all out, separating each of the properties with a comma. If&#13;
you want to animate almost all the properties with the same duration, delay,&#13;
and pace, with a few exceptions, you can use a combination of <code>all</code> and&#13;
the individual properties you want to transition at different times,&#13;
speeds, or paces. Just make sure to use <code>all</code> as the first value, because&#13;
any properties&#13;
listed before the <code>all</code> will be included in the <code>all</code>, overriding any&#13;
other transition property values you intended to apply to those now&#13;
overridden properties:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#f00</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#00ff00</code><code class="p">;</code>&#13;
    <code class="k">border-radius</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">opacity</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">all</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code> <code class="n">opacity</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">1s</code><code class="o">,</code> <code class="m">2s</code><code class="o">,</code> <code class="m">3s</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>all</code> part of the comma-separated value includes all the properties&#13;
listed in the example, as well as all the inherited CSS properties, and&#13;
all the properties defined in any other CSS rule block matching or inherited by the element.</p>&#13;
&#13;
<p>In the preceding example, all the properties getting new values&#13;
will transition at the same duration, delay, and timing function, with&#13;
the exception of <code>border-radius</code> and <code>opacity</code>, which we’ve explicitly&#13;
included separately. Because we included them as part of a comma-separated&#13;
list after the <code>all</code>, we can transition them at the same time,&#13;
delay, and timing function as all the other properties, or we can provide&#13;
different times, delays, and timing functions for these two properties. In this case, we transition all the <span class="keep-together">properties</span> over 1 second, except for <code>border-radius</code> and <code>opacity</code>, which we transition over 2 seconds and 3 seconds, respectively.  (The <code>transition-duration</code> property is covered in an &#13;
<span class="keep-together">upcoming section.</span>)</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Suppressing transitions via property limits" data-type="sect3"><div class="sect3" id="idm45176040093024">&#13;
<h3>Suppressing transitions via property limits</h3>&#13;
&#13;
<p>While <a data-primary="transitions" data-secondary="suppressing" data-type="indexterm" id="idm45176040091696"/>transitioning over time doesn’t happen by default, if you do include a CSS transition and want to override that transition in a particular scenario, you can set <code>transition-property: none</code> to override the entire transition and ensure that no properties are transitioned.</p>&#13;
&#13;
<p>The <code>none</code> keyword can be used as only a unique value of the property—you can’t include it as part of a comma-separated list of properties. If you want to override the transition of a limited set of properties, you will have to list all of the properties you still want to transition. You can’t use the <code>transition-property</code> property to exclude properties; rather, you can use that property only to include them.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Another method is to set the delay and duration of the property to <code>0s</code>. That way, it will appear instantaneously, as if no CSS transition is being applied to it.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Transition events" data-type="sect3"><div class="sect3" id="transition-event-transitionend">&#13;
<h3>Transition events</h3>&#13;
&#13;
<p>The <a data-primary="transitionend event" data-type="indexterm" id="ix_transitionend"/><a data-primary="transitions" data-secondary="events" data-type="indexterm" id="ix_transition_event"/><a data-primary="events" data-secondary="transition" data-type="indexterm" id="ix_event_transition"/><a data-primary="TransitionEvent Interface" data-type="indexterm" id="idm45176040081200"/>TransitionEvent Interface provides for four transition-related events: <code>transitionstart</code>, <code>transitionrun</code>, <code>transitionend</code>, and <code>transitioncancel</code>.  We’ll concentrate on <code>transitionend</code>, as it’s the one that can be triggered multiple times by a single piece of CSS.</p>&#13;
&#13;
<p>A <code>transitionend</code> event is fired at the end of every transition, in either direction, for every property that is transitioned over any amount of time <em>or</em> after any delay.  This happens whether the property is declared individually or is part of the <code>all</code> declaration. Some seemingly simple property declarations will use several <code>transitionend</code> events, as every animatable property within a shorthand property gets its own <code class="keep-together">transitionend</code> event. Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#f00</code><code class="p">;</code>&#13;
    <code class="k">border</code><code class="o">:</code> <code class="m">1px</code> <code class="nb">solid</code> <code class="m">#00ff00</code><code class="p">;</code>&#13;
    <code class="k">border-radius</code><code class="o">:</code> <code class="m">0</code><code class="p">;</code>&#13;
    <code class="k">opacity</code><code class="o">:</code> <code class="m">1</code><code class="p">;</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">50px</code><code class="p">;</code>&#13;
    <code class="k">padding</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">all</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code> <code class="n">opacity</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">1s</code><code class="o">,</code> <code class="m">2s</code><code class="o">,</code> <code class="m">3s</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>When the transitions conclude, well over six <code>transitionend</code> events will have occurred. For example, the <code>border-radius</code> transition alone produces four <code>transitionend</code> events, one each for the following:</p>&#13;
&#13;
<ul class="pagebreak-before">&#13;
<li>&#13;
<p><code>border-bottom-left-radius</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-bottom-right-radius</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-top-right-radius</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-top-left-radius</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The <code>padding</code> property is also shorthand for four longhand properties:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>padding-top</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>padding-right</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>padding-bottom</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>padding-left</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The <code>border</code> shorthand property produces eight <code>transitionend</code> events:&#13;
four values for the four properties represented by the <code>border-width</code> shorthand, and four for the properties represented by <code>border-color</code>:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>border-left-width</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-right-width</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-top-width</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-bottom-width</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-top-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-left-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-right-color</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>border-bottom-color</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The <code>border-style</code> properties have no <code>transitionend</code> events, however, as&#13;
<code>border-style</code> is not an animatable property.</p>&#13;
&#13;
<p>There will be 19 <code>transitionend</code> events in the scenario where six&#13;
specific properties—<code>color</code>, <code>border</code>, <code>border-radius</code>, <code>opacity</code>, <code>width</code>, and <code>padding</code>—are listed, as those six include several shorthand&#13;
properties.&#13;
In the case of <code>all</code>, there will be at least 19 <code class="keep-together">transitionend</code> events:&#13;
one for each of the longhand values making up the six properties we know are included in the pre- and&#13;
post-transition states, and possibly from others that are inherited or declared in&#13;
other style blocks impacting the element. <a class="play" href="https://meyerweb.github.io/csstdg5figs/18-transitions/transitionend.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></p>&#13;
&#13;
<p>You can listen for <code>transitionend</code> events like this:</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s2">"div"</code><code class="p">).</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s2">"transitionend"</code><code class="p">,</code>&#13;
    <code class="p">,</code> <code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>&#13;
      <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">propertyName</code><code class="p">);</code>&#13;
<code class="p">});</code></pre>&#13;
&#13;
<p>The <code>transitionend</code> event includes three <a data-primary="attributes" data-secondary="event-specific" data-type="indexterm" id="idm45176039923024"/><a data-primary="event-specific attributes" data-type="indexterm" id="idm45176039922112"/>event-specific attributes:</p>&#13;
<dl>&#13;
<dt><code>propertyName</code></dt>&#13;
<dd>&#13;
<p>The name of the CSS property that just finished transitioning.</p>&#13;
</dd>&#13;
<dt><code>pseudoElement</code></dt>&#13;
<dd>&#13;
<p>The pseudo-element upon which the transition occurred, preceded by two semicolons, or an empty string if the transition was on a regular DOM node.</p>&#13;
</dd>&#13;
<dt><code>elapsedTime</code></dt>&#13;
<dd>&#13;
<p>The amount of time the transition took <span class="keep-together">to run,</span> in seconds; usually this is the time listed in the <code>transition-duration</code> property.</p>&#13;
</dd>&#13;
</dl>&#13;
&#13;
<p>A <code>transitionend</code> event will occur for each property that successfully transitions to a new value. It will not fire if the transition is interrupted, such as by removing the state change that initiated the transition or by another change to the same property on the same element. That said, a <code>transitionend</code> event <em>will</em> occur when it reverts back to its initial value, or when it finishes transitioning to the value made by that other property value change on the element.</p>&#13;
&#13;
<p>When the properties return to their initial value, another&#13;
<code>transitionend</code> event occurs. This event occurs as long as the&#13;
transition started, even if it didn’t finish its initial transition in the&#13;
original direction.<a data-primary="" data-startref="ix_transition_prop_prop" data-type="indexterm" id="idm45176039941552"/><a data-primary="" data-startref="ix_transition_limits" data-type="indexterm" id="idm45176039940576"/><a data-primary="" data-startref="ix_event_transition" data-type="indexterm" id="idm45176039900672"/><a data-primary="" data-startref="ix_transitionend" data-type="indexterm" id="idm45176039899824"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Transition Duration" data-type="sect2"><div class="sect2" id="the-transition-duration-property">&#13;
<h2>Setting Transition Duration</h2>&#13;
&#13;
<p>The <code>transition-duration</code> property<a data-primary="transitions" data-secondary="duration" data-type="indexterm" id="ix_transition_duration"/><a data-primary="transition-duration property" data-type="indexterm" id="ix_transition_dur_prop"/> takes as its value a comma-separated&#13;
list of lengths of time, in seconds (<code>s</code>) or milliseconds (<code>ms</code>).  These time values describe the time it will&#13;
take to transition from one state to another.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="transition-duration">&#13;
<h1>transition-duration</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>time</code></em>&gt;#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0s</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements and <code>:before</code> and <code>:after</code> pseudo-elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p class="pagebreak-before">When moving between two states, if a duration is declared for only one of those states, the transition duration will be used for only the transition <em>to</em> that state. Consider the <span class="keep-together">following</span>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">input</code> <code class="p">{</code>&#13;
    <code class="k">transition</code><code class="o">:</code> <code class="n">background</code><code class="o">-</code><code class="n">color</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">input</code><code class="nd">:invalid</code> <code class="p">{</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">1s</code><code class="p">;</code>&#13;
    <code class="k">background-color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">input</code><code class="nd">:valid</code> <code class="p">{</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">0.2s</code><code class="p">;</code>&#13;
    <code class="k">background-color</code><code class="o">:</code> <code class="nb">green</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Thus, it will take 1 second for the input to change to a red background when it becomes invalid, and only 200 milliseconds to transition to a green background when it becomes valid. <a class="play" href="https://meyerweb.github.io/csstdg5figs/18-transitions/transition-duration-revert-difference.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></p>&#13;
&#13;
<p>The value of the <code>transition-duration</code> property is positive in either seconds (<code>s</code>) or milliseconds (<code>ms</code>). The time unit of <code>ms</code> or <code>s</code> is required by the specification, even if the duration is set to <code>0s</code>. By default, properties change from one value to the next instantly, showing no visible animation, which is why the default value for the duration of a transition is <code>0s</code>.</p>&#13;
&#13;
<p>Unless a positive value for <code>transition-delay</code> is set on a property, if <code>transition-duration</code> is omitted, it is as if no <code>transition-property</code> declaration had been applied, and no <code>transitionend</code> event will occur. As long as the total duration time for a transition is greater than 0 seconds—as long as the <code>transition-duration</code> is greater than the <code>transition-delay</code>, including greater than the default <code>0s</code> delay—the transition will still be applied, and a <code>transitionend</code> event will occur when the transition&#13;
finishes.</p>&#13;
&#13;
<p>Negative values for <code>transition-duration</code> are invalid, and, if included, will invalidate the entire <code>transition-duration</code> declaration.</p>&#13;
&#13;
<p>Using the same lengthy <code>transition-property</code> declaration from before, we&#13;
can declare a single duration for all the properties, individual&#13;
durations for each property, or we can make alternate properties animate&#13;
for the same length of time. We can declare a <span class="keep-together">single</span> duration that applies to all properties during the transition by including a single <code>transition-duration</code> value:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"> <code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#ff0000</code><code class="p">;</code>&#13;
    <code class="err">…</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code> <code class="n">opacity</code><code class="o">,</code>&#13;
        <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">We can also declare the same number of comma-separated time&#13;
values for the <code>transition-duration</code> property value as the CSS&#13;
properties listed in the <code>transition-property</code> property value. If&#13;
we want each property to transition over a different length of time, we&#13;
have to include a different comma-separated value for each property name&#13;
declared:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">color</code><code class="o">:</code> <code class="m">#ff0000</code><code class="p">;</code>&#13;
    <code class="err">…</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code> <code class="n">opacity</code><code class="o">,</code>&#13;
        <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="o">,</code> <code class="m">180ms</code><code class="o">,</code> <code class="m">160ms</code><code class="o">,</code> <code class="m">120ms</code><code class="o">,</code> <code class="m">1s</code><code class="o">,</code> <code class="m">2s</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If the number of properties declared does not match the number of&#13;
durations declared, the browser has specific rules on how to handle the&#13;
mismatch. If we have more durations than properties, the extra&#13;
durations are ignored. If we have more properties than durations, the&#13;
durations are repeated.  In the following example,&#13;
<code>color</code>, <code>border-radius</code>, and <code>width</code> have a duration of 100 milliseconds;&#13;
<code>border</code>, <code>opacity</code>, and <code>padding</code> will be set to 200 milliseconds:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="err">…</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code> <code class="n">opacity</code><code class="o">,</code>&#13;
        <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">100ms</code><code class="o">,</code> <code class="m">200ms</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we declare exactly two comma-separated durations, every odd property&#13;
will transition over the first time declared, and every even property&#13;
will transition over the second time value declared.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>Always remember that user experience is important.&#13;
If a transition is too slow, the website will appear slow or&#13;
unresponsive, drawing unwanted focus to what should be a subtle effect.&#13;
If a transition is too fast, it may be too subtle to be noticed.&#13;
Visual effects should last long enough to be seen,&#13;
but not so long as to make themselves the center of attention.&#13;
Generally, the best duration for a visible, yet not&#13;
distracting, transition is 100 to 300 milliseconds.<a data-primary="" data-startref="ix_transition_dur_prop" data-type="indexterm" id="idm45176039671056"/><a data-primary="" data-startref="ix_transition_duration" data-type="indexterm" id="idm45176039659440"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Altering the Internal Timing of Transitions" data-type="sect2"><div class="sect2" id="the-transition-timing-function-property">&#13;
<h2>Altering the Internal Timing of Transitions</h2>&#13;
&#13;
<p>Do you want your <a data-primary="transition-timing-function property" data-type="indexterm" id="ix_transition_time_func_prop"/><a data-primary="transitions" data-secondary="timing of" data-type="indexterm" id="ix_transition_timing"/><a data-primary="timing functions" data-secondary="transitions" data-type="indexterm" id="ix_time_transition"/>transition to start off slow and get faster, start off&#13;
fast and end slower, advance at an even keel, jump through various steps,&#13;
or even bounce? The <code>transition-timing-function</code> provides a way to&#13;
control the pace of the transition.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="transition-timing-function">&#13;
<h1>transition-timing-function</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>timing-function</code></em>&gt;#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>ease</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements and <code>:before</code> and <code>:after</code> pseudo-elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>transition-timing-function</code> values include <code>ease</code>, <code>linear</code>,&#13;
<code>ease-in</code>, <code>ease-out</code>, <code>ease-in-out</code>, <code>step-start</code>, <code>step-end</code>,&#13;
<code>steps(</code><em><code>n</code></em><code>, start)</code>—where <em><code>n</code></em> is the number of steps—<code>steps(</code><em><code>n</code></em><code>, end)</code>, and <code>cubic-bezier(x1, y1, x2, y2)</code>. (These values are&#13;
also the valid values for the <code>animation-timing-function</code>, and they are&#13;
described in great detail in <a data-type="xref" href="ch19.html#animation">Chapter 19</a>.)</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cubic Bézier timing" data-type="sect3"><div class="sect3" id="idm45176039602368">&#13;
<h3>Cubic Bézier timing</h3>&#13;
&#13;
<p>The <a data-primary="cubic-Bézier timing functions" data-type="indexterm" id="ix_cubic_bezier_func2"/><a data-primary="Bézier curve functions" data-type="indexterm" id="ix_bezier_func2"/>nonstep keywords are easing timing functions that serve as aliases for cubic Bézier mathematical functions that provide smooth curves. The&#13;
specification provides for five predefined easing functions, as shown in <a data-type="xref" href="#cubic_bezier">Table 18-1</a>.</p>&#13;
<table class="fixed" id="cubic_bezier">&#13;
<caption><span class="label">Table 18-1. </span>&#13;
    Supported keywords for cubic Bézier timing functions&#13;
</caption>&#13;
<thead>&#13;
    <tr>&#13;
        <th class="w100">Timing function</th>&#13;
        <th>Description</th>&#13;
        <th class="w200">Cubic Bézier value</th>&#13;
    </tr>&#13;
</thead>&#13;
<tbody>&#13;
    <tr>&#13;
        <td><code>cubic-bezier()</code></td>&#13;
        <td>&#13;
            Specifies a cubic Bézier curve&#13;
        </td>&#13;
        <td>&#13;
            <code>cubic-bezier(<em>x1, y1, x2, y2</em>)</code>&#13;
        </td>&#13;
    </tr>&#13;
    <tr>&#13;
        <td><code>ease</code></td>&#13;
        <td>&#13;
            Starts slow, then speeds up, then slows down, then ends very slowly&#13;
        </td>&#13;
        <td>&#13;
            <code>cubic-bezier(0.25, 0.1, 0.25, 1)</code>&#13;
        </td>&#13;
    </tr>&#13;
    <tr>&#13;
        <td><code>linear</code></td>&#13;
        <td>&#13;
            Proceeds at the same speed throughout transition&#13;
        </td>&#13;
        <td>&#13;
            <code>cubic-bezier(0, 0, 1, 1)</code>&#13;
        </td>&#13;
    </tr>&#13;
    <tr>&#13;
        <td><code>ease-in</code></td>&#13;
        <td>&#13;
            Starts slow, then speeds up&#13;
        </td>&#13;
        <td>&#13;
            <code>cubic-bezier(0.42, 0, 1, 1)</code>&#13;
        </td>&#13;
    </tr>&#13;
    <tr>&#13;
        <td><code>ease-out</code></td>&#13;
        <td>&#13;
            Starts fast, then slows down&#13;
        </td>&#13;
        <td>&#13;
            <code>cubic-bezier(0, 0, 0.58, 1)</code>&#13;
        </td>&#13;
    </tr>&#13;
    <tr>&#13;
        <td><code>ease-in-out</code></td>&#13;
        <td>&#13;
            Similar to <code>ease</code>; faster in the middle, with a slow start but not as slow at <span class="keep-together">the end</span>&#13;
        </td>&#13;
        <td>&#13;
            <code>cubic-bezier(0.42, 0, 0.58, 1)</code>&#13;
        </td>&#13;
    </tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>Cubic Bézier curves, including the underlying curves defining the&#13;
five named easing functions in <a data-type="xref" href="#cubic_bezier">Table 18-1</a> and displayed in <a data-type="xref" href="#tr_fig0203">Figure 18-3</a>, take four numeric parameters. For example,&#13;
<code>linear</code> is the same as <code>cubic-bezier(0, 0, 1, 1)</code>. The first and third&#13;
cubic Bézier function parameter values need to be between 0 and 1.</p>&#13;
&#13;
<figure><div class="figure" id="tr_fig0203">&#13;
<img alt="css5 1803" src="assets/css5_1803.png"/>&#13;
<h6><span class="label">Figure 18-3. </span>Curve representations of named cubic Bézier functions</h6>&#13;
</div></figure>&#13;
&#13;
<p>The four numbers in a <code>cubic-bezier()</code> function define the <em>x</em> and <em>y</em> coordinates of two <em>handles</em> within a box.  These handles are the endpoints of lines that stretch from the bottom-left and top-right corners of the box.  The curve is constructed using the two corners, and the two handles’ coordinates, via a Bézier function.</p>&#13;
&#13;
<p>To get an idea of how this works, look at the curves and their corresponding values shown in <a data-type="xref" href="#taic_css4_cubic-bezier-coordinates">Figure 18-4</a>.</p>&#13;
&#13;
<figure><div class="figure" id="taic_css4_cubic-bezier-coordinates">&#13;
<img alt="css5 1804" src="assets/css5_1804.png"/>&#13;
<h6><span class="label">Figure 18-4. </span>Four Bézier curves and their <code>cubic-bezier()</code> values (from <a class="bare" href="http://cubic-bezier.com"><em class="hyperlink">http://cubic-bezier.com</em></a>)</h6>&#13;
</div></figure>&#13;
&#13;
<p>Consider the first example.  The first two values, corresponding to <em>x1</em> and <em>y1</em>, are <code>0.5</code> and <code>1</code>.  If you go halfway across the box (<em>x1</em> = 0.5) and all the way to the top of the box (<em>y1</em> = 1), you land at the spot where the first handle is placed.  Similarly, the coordinates <code>0.5,0</code> for <em>x2,y2</em> describe the point at the center bottom of the box, which is where the second handle is placed.  The curve shown there results from those handle placements.</p>&#13;
&#13;
<p>In the second example, the handle positions are switched, with the resulting change in the curve.  Ditto for the third and fourth examples, which are inversions of each other.  Notice how the resulting curve differs when switching the handle positions.</p>&#13;
&#13;
<p>The predefined key terms are fairly limited. To better follow the principles of animation, you may want to use a cubic Bézier function with four float values instead of the predefined key words. If you’re a whiz at calculus or have a lot of experience with programs like Illustrator, you might be able to invent cubic Bézier functions in your head; otherwise, online tools let you play with different values, such as <a class="bare" href="http://cubic-bezier.com"><em class="hyperlink">http://cubic-bezier.com</em></a>, which lets you compare the common keywords against each other or against your own cubic &#13;
<span class="keep-together">Bézier function.</span></p>&#13;
&#13;
<p>As shown in <a data-type="xref" href="#tr_fig0204">Figure 18-5</a>, the website <a class="bare" href="http://easings.net"><em class="hyperlink">http://easings.net</em></a> provides many additional cubic Bézier function&#13;
values you can use to provide for a more realistic, delightful&#13;
animation.</p>&#13;
&#13;
<figure><div class="figure" id="tr_fig0204">&#13;
<img alt="css5 1805" src="assets/css5_1805.png"/>&#13;
<h6><span class="label">Figure 18-5. </span>Useful author-defined cubic Bézier functions (from <a class="bare" href="http://easings.net"><em class="hyperlink">http://easings.net</em></a>)</h6>&#13;
</div></figure>&#13;
&#13;
<p>While the authors of the site named their animations, the&#13;
preceding names are not part of the CSS specifications, and must be written as shown in <a data-type="xref" href="#cubic_bezier_timings">Table 18-2</a>.<a data-primary="" data-startref="ix_bezier_func2" data-type="indexterm" id="idm45176039542688"/><a data-primary="" data-startref="ix_cubic_bezier_func2" data-type="indexterm" id="idm45176039541712"/></p>&#13;
<table id="cubic_bezier_timings">&#13;
<caption><span class="label">Table 18-2. </span>Cubic Bézier timings</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Unofficial name</th>&#13;
<th>Cubic Bézier function value</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>easeInSine</code></p></td>&#13;
<td><p><code>cubic-bezier(0.47, 0, 0.745, 0.715)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeOutSine</code></p></td>&#13;
<td><p><code>cubic-bezier(0.39, 0.575, 0.565, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInOutSine</code></p></td>&#13;
<td><p><code>cubic-bezier(0.445, 0.05, 0.55, 0.95)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInQuad</code></p></td>&#13;
<td><p><code>cubic-bezier(0.55, 0.085, 0.68, 0.53)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeOutQuad</code></p></td>&#13;
<td><p><code>cubic-bezier(0.25, 0.46, 0.45, 0.94)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInOutQuad</code></p></td>&#13;
<td><p><code>cubic-bezier(0.455, 0.03, 0.515, 0.955)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInCubic</code></p></td>&#13;
<td><p><code>cubic-bezier(0.55, 0.055, 0.675, 0.19)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeOutCubic</code></p></td>&#13;
<td><p><code>cubic-bezier(0.215, 0.61, 0.355, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInOutCubic</code></p></td>&#13;
<td><p><code>cubic-bezier(0.645, 0.045, 0.355, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInQuart</code></p></td>&#13;
<td><p><code>cubic-bezier(0.895, 0.03, 0.685, 0.22)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeOutQuart</code></p></td>&#13;
<td><p><code>cubic-bezier(0.165, 0.84, 0.44, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInOutQuart</code></p></td>&#13;
<td><p><code>cubic-bezier(0.77, 0, 0.175, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInQuint</code></p></td>&#13;
<td><p><code>cubic-bezier(0.755, 0.05, 0.855, 0.06)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeOutQuint</code></p></td>&#13;
<td><p><code>cubic-bezier(0.23, 1, 0.32, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInOutQuint</code></p></td>&#13;
<td><p><code>cubic-bezier(0.86, 0, 0.07, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInExpo</code></p></td>&#13;
<td><p><code>cubic-bezier(0.95, 0.05, 0.795, 0.035)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeOutExpo</code></p></td>&#13;
<td><p><code>cubic-bezier(0.19, 1, 0.22, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInOutExpo</code></p></td>&#13;
<td><p><code>cubic-bezier(1, 0, 0, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInCirc</code></p></td>&#13;
<td><p><code>cubic-bezier(0.6, 0.04, 0.98, 0.335)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeOutCirc</code></p></td>&#13;
<td><p><code>cubic-bezier(0.075, 0.82, 0.165, 1)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInOutCirc</code></p></td>&#13;
<td><p><code>cubic-bezier(0.785, 0.135, 0.15, 0.86)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInBack</code></p></td>&#13;
<td><p><code>cubic-bezier(0.6, -0.28, 0.735, 0.045)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeOutBack</code></p></td>&#13;
<td><p><code>cubic-bezier(0.175, 0.885, 0.32, 1.275)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>easeInOutBack</code></p></td>&#13;
<td><p><code>cubic-bezier(0.68, -0.55, 0.265, 1.55)</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Step timing" data-type="sect3"><div class="sect3" id="idm45176039593792">&#13;
<h3>Step timing</h3>&#13;
&#13;
<p>Step <a data-primary="step timing functions" data-type="indexterm" id="ix_step_time_func"/>timing functions also are available, as well as four predefined step values; see <a data-type="xref" href="#step_timing_functions">Table 18-3</a>.</p>&#13;
<table class="full-width" id="step_timing_functions">&#13;
<caption><span class="label">Table 18-3. </span>Step timing functions</caption>&#13;
<thead>&#13;
<tr>&#13;
<th>Timing function</th>&#13;
<th>Definition</th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>steps(&lt;integer&gt;, jump-start)</code></p></td>&#13;
<td><p>Displays &lt;<em><code>integer</code></em>&gt; keyframes, showing the last keyframe for the last <em>n</em>/100% of the transition duration; the first jump happens at the very beginning of the transition.  <code>start</code> can be used in place of <code>jump-start</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>steps(&lt;integer&gt;, jump-end)</code></p></td>&#13;
<td><p>Displays &lt;<em><code>integer</code></em>&gt; keyframes, staying on the initial state for the first <em>n</em>/100% of the transition duration;  the last jump happens at the very end of the transition.  <code>end</code> can be used in place of <code>jump-end</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>steps(&lt;integer&gt;, jump-both)</code></p></td>&#13;
<td><p>Displays &lt;<em><code>integer</code></em>&gt; keyframes, starting with an immediate jump and taking the final jump at the very end of the transition duration; this effectively adds one step to the transition</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>steps(&lt;integer&gt;, jump-none)</code></p></td>&#13;
<td><p>Displays &lt;<em><code>integer</code></em>&gt; keyframes, but there is no jump at either the beginning or end of the transition duration, instead staying on the initial values for the first <em>n</em>/100% of the time <em>and</em> showing the final values for the last <em>n</em>/100% of the time; this effectively removes one step from the transition</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>step-start</code></p></td>&#13;
<td><p>Stays on the final keyframe throughout transition duration; equal to <code>steps(1, jump-start)</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>step-end</code></p></td>&#13;
<td><p>Stays on the initial keyframe throughout transition duration; equal to <code>steps(1, jump-end)</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
<p>As <a data-type="xref" href="#steptiming">Figure 18-6</a> shows, the step timing functions show the progression of the transition from the initial value to the final value in steps, rather than as a smooth curve.</p>&#13;
&#13;
<figure><div class="figure" id="steptiming">&#13;
<img alt="css5 1806" src="assets/css5_1806.png"/>&#13;
<h6><span class="label">Figure 18-6. </span>Step timing functions</h6>&#13;
</div></figure>&#13;
&#13;
<p>The step timing functions allow you to divide the transition over equidistant steps, by defining the number and direction of steps.</p>&#13;
&#13;
<p>With <code>jump-start</code>, the first step happens at the animation or transition start. With <code>jump-end</code>, the last step happens at the animation or transition end. For example, <code>steps(5, jump-end)</code> would jump through the equidistant steps at 0%, 20%, 40%, 60%, and 80%; and <code>steps(5, jump-start)</code> would jump through the equidistant steps at 20%, 40%, 60%, 80%, and 100%.</p>&#13;
&#13;
<p>The <code>step-start</code> function is the same as <code>steps(1, jump-start)</code>. When used, transitioned property values stay on their <em>final</em> values from the&#13;
beginning until the end of the <span class="keep-together">transition.</span> The <code>step-end</code> function,&#13;
which is the same as <code>steps(1, jump-end)</code>, sets transitioned values to their <em>initial</em> values, staying there throughout the transition’s duration.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Step timing, especially the precise meaning of <code>jump-start</code> and <code>jump-end</code>, is discussed in depth in <a data-type="xref" href="ch19.html#animation">Chapter 19</a>.</p>&#13;
</div>&#13;
&#13;
<p>Continuing on with the same lengthy <code>transition-property</code> declaration we’ve used before, we can declare a single timing function for all the properties, or define individual timing functions for each property, and so on.  Here, we’ve set all the transitioned properties to a single duration and timing function:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border-width</code><code class="o">,</code> <code class="n">border-color</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code>&#13;
        <code class="n">opacity</code><code class="o">,</code> <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Always remember that the <code>transition-timing-function</code> does&#13;
not change the time it takes to transition properties: that is set with&#13;
the <code>transition-duration</code> property. It just changes how the&#13;
transition progresses during that set time.  Consider the <span class="keep-together">following:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="err">…</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border-width</code><code class="o">,</code> <code class="n">border-color</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code>&#13;
        <code class="n">opacity</code><code class="o">,</code> <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="o">,</code> <code class="n">ease</code><code class="o">-</code><code class="n">out</code><code class="o">,</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="o">-</code><code class="n">out</code><code class="o">,</code>&#13;
        <code class="n">step</code><code class="o">-</code><code class="n">end</code><code class="o">,</code> <code class="n">step</code><code class="o">-</code><code class="n">start</code><code class="o">,</code> <code class="n">steps</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="n">jump</code><code class="o">-</code><code class="n">start</code><code class="p">)</code><code class="o">,</code> <code class="n">steps</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="n">jump</code><code class="o">-</code><code class="n">end</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we include these seven timing functions for the seven properties, as long as they have the same transition duration and delay, all the properties start and finish transitioning at the same time. (The preceding transition would be a terrible user experience, by the way.  Please don’t do that.)</p>&#13;
&#13;
<p>The best way to familiarize yourself with&#13;
the various timing functions is to play with them and see which one works best&#13;
for the effect you’re looking for. While testing, set a relatively long&#13;
<code>transition-duration</code> to better visualize the difference between the&#13;
various functions. At higher speeds, you may not be able to tell the difference between different easing functions.&#13;
Just don’t forget to set the transition back to a faster speed before publishing the result!<a data-primary="" data-startref="ix_time_transition" data-type="indexterm" id="idm45176039343136"/><a data-primary="" data-startref="ix_transition_timing" data-type="indexterm" id="idm45176039336032"/><a data-primary="" data-startref="ix_transition_time_func_prop" data-type="indexterm" id="idm45176039335088"/><a data-primary="" data-startref="ix_step_time_func" data-type="indexterm" id="idm45176039334176"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Delaying Transitions" data-type="sect2"><div class="sect2" id="the-transition-delay-property">&#13;
<h2>Delaying Transitions</h2>&#13;
&#13;
<p>The <code>transition-delay</code> property<a data-primary="transitions" data-secondary="delaying" data-type="indexterm" id="ix_transition_delay2"/><a data-primary="transition-delay property" data-type="indexterm" id="ix_transition_delay"/> enables you to introduce a delay&#13;
between the time that the change initiating the transition is applied to an element and the time the transition actually begins.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="transition-delay">&#13;
<h1>transition-delay</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>&lt;<em><code>time</code></em>&gt;#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>0s</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements, <code>:before</code> and <code>:after</code> pseudo-elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>A <code>transition-delay</code> of <code>0s</code> (the default) means the transition will begin immediately; it will start executing as soon as the state of the element is altered. This is familiar from the instant-change effect of <code>a:hover</code>, for example.</p>&#13;
&#13;
<p>With a value other than <code>0s</code>, the &lt;<em><code>time</code></em>&gt; value of&#13;
<code>transition-delay</code> defines the time offset from the moment the property&#13;
values would ordinarily have changed until the property values declared in the <code>transition</code> or&#13;
<code>transition-property</code> values begin animating to their final values.</p>&#13;
&#13;
<p>Interestingly, negative values of time are valid. The effects you can create with&#13;
negative <code>transition-delay</code>s are described in <a data-type="xref" href="#negative-delay-values">“Negative delay values”</a>.</p>&#13;
&#13;
<p>Continuing with the 6- (or 19-) property <code>transition-property</code> declaration we’ve been using, we <span class="keep-together">can make</span> all the properties start transitioning right away by omitting the <code>transition-delay</code> property, or by including it with a value of <code>0s</code>.  Another possibility is to start half the transitions right away, and the rest 200 milliseconds later, as in the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code> <code class="n">opacity</code><code class="o">,</code>&#13;
        <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">linear</code><code class="p">;</code>&#13;
    <code class="k">transition-delay</code><code class="o">:</code> <code class="m">0s</code><code class="o">,</code> <code class="m">200ms</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>By including <code>transition-delay: 0s, 200ms</code> on a series of properties,&#13;
each taking 200 milliseconds to transition, we make <code>color</code>, <code>border-radius</code>,&#13;
and <code>width</code> begin their&#13;
transitions immediately. All the rest begin&#13;
their transitions as soon as the other transitions have completed, because their <code>transition-delay</code> is equal to the <code>transition-duration</code> applied to all the properties.</p>&#13;
&#13;
<p>As with <code>transition-duration</code> and <code>transition-timing-function</code>, when the comma-separated <code>transition-delay</code> values outnumber the comma-separated <code>transition-property</code> values, the extra delay&#13;
values are ignored. When the comma-separated&#13;
<code>transition-property</code> values outnumber the comma-separated&#13;
<code>transition-delay</code> values, the delay values are repeated.</p>&#13;
&#13;
<p>We can even declare seven <code>transition-delay</code> values so that each&#13;
property begins transitioning after the previous property has&#13;
transitioned, as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="err">…</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border-width</code><code class="o">,</code> <code class="n">border-color</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code>&#13;
        <code class="n">opacity</code><code class="o">,</code> <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">linear</code><code class="p">;</code>&#13;
    <code class="k">transition-delay</code><code class="o">:</code> <code class="m">0s</code><code class="o">,</code> <code class="m">0.2s</code><code class="o">,</code> <code class="m">0.4s</code><code class="o">,</code> <code class="m">0.6s</code><code class="o">,</code> <code class="m">0.8s</code><code class="o">,</code> <code class="m">1s</code><code class="o">,</code> <code class="m">1.2s</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, we declare each transition to last 200 milliseconds with the <code>transition-duration</code> property. We then declare a <code>transition-delay</code> that provides comma-separated delay values for each property that increments by 200 milliseconds, or 0.2 seconds—the same time as the duration of each property’s transition. The end result is that each property starts transitioning at the point the previous property has finished.</p>&#13;
&#13;
<p>We can use math to give every transitioning property different&#13;
durations and delays, ensuring that they all complete transitioning at the same time:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="err">…</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border-width</code><code class="o">,</code> <code class="n">border-color</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code>&#13;
        <code class="n">opacity</code><code class="o">,</code> <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">1.4s</code><code class="o">,</code> <code class="m">1.2s</code><code class="o">,</code> <code class="m">1s</code><code class="o">,</code> <code class="m">0.8s</code><code class="o">,</code> <code class="m">0.6s</code><code class="o">,</code> <code class="m">0.4s</code><code class="o">,</code> <code class="m">0.2s</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">linear</code><code class="p">;</code>&#13;
    <code class="k">transition-delay</code><code class="o">:</code> <code class="m">0s</code><code class="o">,</code> <code class="m">0.2s</code><code class="o">,</code> <code class="m">0.4s</code><code class="o">,</code> <code class="m">0.6s</code><code class="o">,</code> <code class="m">0.8s</code><code class="o">,</code> <code class="m">1s</code><code class="o">,</code> <code class="m">1.2s</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this example, each property completes transitioning at the&#13;
1.4-second mark, but each with a different duration and delay. For each&#13;
property, the <code>transition-duration</code> value plus the <code>transition-delay</code>&#13;
value will add up to 1.4 seconds.</p>&#13;
&#13;
<p>Generally, you’ll want all the transitions to begin at the same time. You can make that happen by&#13;
including a single <code>transition-delay</code> value, which gets applied to all&#13;
the properties. In our drop-down menu in <a data-type="xref" href="#tr_fig01">Figure 18-1</a>, we included a delay of&#13;
50 milliseconds. This delay is not long enough for the user to notice and will not&#13;
cause the application to appear slow. Rather, a 50-millisecond delay can help&#13;
prevent the navigation from shooting open unintentionally as the user accidentally hovers over the menu items while moving the cursor from one part of the page or app to another, or as they quickly move the focus ring through the document.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Negative delay values" data-type="sect3"><div class="sect3" id="negative-delay-values">&#13;
<h3>Negative delay values</h3>&#13;
&#13;
<p>A <a data-primary="negative delay values, transition delays" data-type="indexterm" id="idm45176039012960"/>negative value for&#13;
<code>transition-delay</code> that is smaller than the <code>transition-duration</code> will&#13;
cause the transition to&#13;
start immediately, partway through the transition.  For &#13;
<span class="keep-together">example</span>: <a class="play" href="https://meyerweb.github.io/csstdg5figs/18-transitions/transition-delay-negative.html"><span class="play"><img src="assets/play-icon-round.png"/></span></a></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
  <code class="k">transform</code><code class="o">:</code> <code class="n">translateX</code><code class="p">(</code><code class="m">0</code><code class="p">);</code>&#13;
  <code class="k">transition-property</code><code class="o">:</code> <code class="n">transform</code><code class="p">;</code>&#13;
  <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="p">;</code>&#13;
  <code class="k">transition-delay</code><code class="o">:</code> <code class="m">-150ms</code><code class="p">;</code>&#13;
  <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">linear</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">div</code><code class="nd">:hover</code> <code class="p">{</code>&#13;
  <code class="k">transform</code><code class="o">:</code> <code class="n">translateX</code><code class="p">(</code><code class="m">200px</code><code class="p">);</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Given the <code>transition-delay</code> of <code>-150ms</code> on a <code>200ms</code>&#13;
transition, the transition will start three-quarters of the way through&#13;
the transition and will last 50 milliseconds. In that scenario, given the linear timing function, the <code>&lt;div&gt;</code> jumps to being translated <code>150px</code> along the x-axis immediately on hover and then animates the translation from 150 pixels to 200 pixels over 50 milliseconds.</p>&#13;
&#13;
<p>If the absolute value of the negative <code>transition-delay</code> is greater than&#13;
or equal to the <code>transition-duration</code>, the change of property values is&#13;
immediate, as if no <code>transition</code> had been applied, <em>and</em> no <code class="keep-together">transitionend</code> event occurs.</p>&#13;
&#13;
<p>When transitioning back from the hovered state to the original state, by&#13;
default, the same value for the <code>transition-delay</code> is applied. In the&#13;
preceding scenario, since the <code>transition-delay</code> is not overridden in the&#13;
hover state, when the user stops hovering over the element, the <code>&lt;div&gt;</code> will jump to being translated 50 pixels along the x-axis and then take 50 milliseconds to return to its initial position of being translated 0 pixels along the x-axis.<a data-primary="" data-startref="ix_transition_delay" data-type="indexterm" id="idm45176038969184"/><a data-primary="" data-startref="ix_transition_delay2" data-type="indexterm" id="idm45176038968208"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Using the transition Shorthand" data-type="sect2"><div class="sect2" id="the-transition-shorthand-property">&#13;
<h2>Using the transition Shorthand</h2>&#13;
&#13;
<p>The <code>transition</code> property<a data-primary="transitions" data-secondary="shorthand property" data-type="indexterm" id="ix_transition_shorthand"/><a data-primary="transition property" data-type="indexterm" id="ix_transition_prop2"/> combines the four properties we’ve covered thus far—<code>transition-property</code>, <code>transition-duration</code>,&#13;
<code>transition-timing-function</code>, and <code>transition-delay</code>—into a single&#13;
shorthand property.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45176038928112">&#13;
<h1>transition</h1><table>&#13;
&#13;
<tbody>&#13;
<tr>&#13;
<td><p><strong>Values</strong></p></td>&#13;
<td><p>[ [ <code>none</code> | &lt;<em><code>transition-property</code></em>&gt; ] ‖ &lt;<em><code>time</code></em>&gt; ‖ &lt;<em><code>transition-timing-function</code></em>&gt; ‖ &lt;<em><code>time</code></em>&gt; ]#</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Initial value</strong></p></td>&#13;
<td><p><code>all 0s ease 0s</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Applies to</strong></p></td>&#13;
<td><p>All elements and <code>:before</code> and <code>:after</code> pseudo-elements</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Computed value</strong></p></td>&#13;
<td><p>As specified</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Inherited</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><strong>Animatable</strong></p></td>&#13;
<td><p>No</p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
</div></aside>&#13;
&#13;
<p>The <code>transition</code> property accepts the value of <code>none</code>, or any number of&#13;
comma-separated list of <em>single transitions</em>. A single transition&#13;
contains a single property to transition, or the keyword <code>all</code> to&#13;
transition all the properties; the duration of the&#13;
transition; the timing function; and the transition delay.</p>&#13;
&#13;
<p>If a single transition within the <code>transition</code> shorthand omits the&#13;
property to transition, that single transition&#13;
will default to <code>all</code>. If the <code>transition-timing-function</code> value is&#13;
omitted, it will default to <code>ease</code>. If only one time value is included,&#13;
that will be the duration, and no delay will occur, as if <code>transition-delay</code> were set to <code>0s</code>.</p>&#13;
&#13;
<p>Within each single transition, the order of the duration versus the delay&#13;
is important: the first value that can be parsed as a time will be set&#13;
as the duration. If an additional time value is found before the comma or the&#13;
end of the statement, that will be set as the delay.</p>&#13;
&#13;
<p>Here are three equivalent ways to write the same transition effects:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="nt">li</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transition</code><code class="o">:</code> <code class="n">transform</code> <code class="m">200ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code> <code class="m">50ms</code><code class="o">,</code>&#13;
                  <code class="n">opacity</code> <code class="m">200ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code> <code class="m">50ms</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">nav</code> <code class="nt">li</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transition</code><code class="o">:</code> <code class="n">all</code> <code class="m">200ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code> <code class="m">50ms</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">nav</code> <code class="nt">li</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
    <code class="k">transition</code><code class="o">:</code> <code class="m">200ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code> <code class="m">50ms</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In the first example, we see a shorthand way to express each of&#13;
the two properties that are being transitioned.&#13;
Because we are transitioning all the properties that will be changed (in other rules not shown in the code block), we could use the keyword <code>all</code>, as shown in the second&#13;
example. And, since <code>all</code> is the default value, we could write the&#13;
shorthand with just the duration, timing function, and delay. Had we used&#13;
<code>ease</code> instead of <code>ease-in</code>, we could have omitted the timing function,&#13;
since <code>ease</code> is the default.  Had we not wanted a delay, we could have omitted the second time value, since <code>0s</code> is the default.</p>&#13;
&#13;
<p>We did have to include the duration, or no transition would be visible. In other words, the only portion of the <code>transition</code> property value that can truly be considered required is <code>transition-duration</code>.</p>&#13;
&#13;
<p>If we wanted to only delay the change from closed menu to open menu&#13;
without a gradual transition, we would still need to include a duration of <code>0s</code>. Remember, the first value parsable as time will be set as the&#13;
duration and the second one will be set as the delay:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">nav</code> <code class="nt">li</code> <code class="nt">ul</code> <code class="p">{</code>&#13;
  <code class="k">transition</code><code class="o">:</code> <code class="m">0s</code> <code class="m">200ms</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>This transition will wait 200 milliseconds, then show the drop-down fully open and opaque with no gradual transition. Creating delays with no transitions is a horrible user experience, so please do not do it.</p>&#13;
</div>&#13;
&#13;
<p>If we have a comma-separated list of transitions (versus just a single&#13;
declaration) and the word <code>none</code> is included, the entire transition&#13;
declaration is invalid and will be ignored. You can declare comma-separated values for the four longhand transition properties, or you can include a comma-separated list of multiple shorthand transitions:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">transition-property</code><code class="o">:</code> <code class="n">color</code><code class="o">,</code> <code class="n">border-width</code><code class="o">,</code> <code class="n">border-color</code><code class="o">,</code> <code class="n">border-radius</code><code class="o">,</code>&#13;
        <code class="n">opacity</code><code class="o">,</code> <code class="n">width</code><code class="o">,</code> <code class="n">padding</code><code class="p">;</code>&#13;
    <code class="k">transition-duration</code><code class="o">:</code> <code class="m">200ms</code><code class="o">,</code> <code class="m">180ms</code><code class="o">,</code> <code class="m">160ms</code><code class="o">,</code> <code class="m">140ms</code><code class="o">,</code> <code class="m">100ms</code><code class="o">,</code> <code class="m">2s</code><code class="o">,</code> <code class="m">3s</code><code class="p">;</code>&#13;
    <code class="k">transition-timing-function</code><code class="o">:</code> <code class="n">ease</code><code class="o">,</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="o">,</code> <code class="n">ease</code><code class="o">-</code><code class="n">out</code><code class="o">,</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="o">-</code><code class="n">out</code><code class="o">,</code>&#13;
        <code class="n">step</code><code class="o">-</code><code class="n">end</code><code class="o">,</code> <code class="n">steps</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="n">start</code><code class="p">)</code><code class="o">,</code> <code class="n">steps</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="n">end</code><code class="p">);</code>&#13;
    <code class="k">transition-delay</code><code class="o">:</code> <code class="m">0s</code><code class="o">,</code> <code class="m">0.2s</code><code class="o">,</code> <code class="m">0.4s</code><code class="o">,</code> <code class="m">0.6s</code><code class="o">,</code> <code class="m">0.8s</code><code class="o">,</code> <code class="m">1s</code><code class="o">,</code> <code class="m">1.2s</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">transition</code><code class="o">:</code>&#13;
        <code class="n">color</code> <code class="m">200ms</code> <code class="n">ease</code><code class="o">,</code>&#13;
        <code class="n">border-width</code> <code class="m">180ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code> <code class="m">200ms</code><code class="o">,</code>&#13;
        <code class="n">border-color</code> <code class="m">160ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">out</code> <code class="m">400ms</code><code class="o">,</code>&#13;
        <code class="n">border-radius</code> <code class="m">140ms</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code><code class="o">-</code><code class="n">out</code> <code class="m">600ms</code><code class="o">,</code>&#13;
        <code class="n">opacity</code> <code class="m">100ms</code> <code class="n">step</code><code class="o">-</code><code class="n">end</code> <code class="m">0.8s</code><code class="o">,</code>&#13;
        <code class="n">width</code> <code class="m">2s</code> <code class="n">steps</code><code class="p">(</code><code class="m">5</code><code class="o">,</code> <code class="n">start</code><code class="p">)</code> <code class="m">1s</code><code class="o">,</code>&#13;
        <code class="n">padding</code> <code class="m">3s</code> <code class="n">steps</code><code class="p">(</code><code class="m">3</code><code class="o">,</code> <code class="n">end</code><code class="p">)</code> <code class="m">1.2s</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The two preceding CSS rule blocks are functionally equivalent. Use care when stringing multiple shorthand transitions into a list of transitions: <code>transition: color, opacity 200ms ease-in 50ms</code> will ease in the&#13;
opacity over 200 milliseconds after a 50-millisecond delay, but the <code>color</code> change will be instantaneous, with no <code>transitionend</code> event. It is still valid, but may not be the effect you were seeking.<a data-primary="" data-startref="ix_transition_prop2" data-type="indexterm" id="idm45176038575888"/><a data-primary="" data-startref="ix_transition_shorthand" data-type="indexterm" id="idm45176038575008"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Reversing Interrupted Transitions" data-type="sect2"><div class="sect2" id="idm45176038967008">&#13;
<h2>Reversing Interrupted Transitions</h2>&#13;
&#13;
<p>When a <a data-primary="transitions" data-secondary="reversing interrupted" data-type="indexterm" id="idm45176038622128"/><a data-primary="transitions" data-secondary="timing of" data-type="indexterm" id="idm45176038621120"/>transition is interrupted before it is able to finish (such as&#13;
mousing off a drop-down menu before it finishes its opening transition),&#13;
property values are reset to the values they had before the transition&#13;
began, and the properties transition back to those values. Because&#13;
repeating the duration and timing functions on a reverting partial&#13;
transition can lead to an odd or even bad user experience, the CSS&#13;
Transitions specification provides for making the reverting transition&#13;
shorter.</p>&#13;
&#13;
<p>Let’s say we have a <code>transition-delay</code> of&#13;
<code>50ms</code> set on the default state of a menu, and no transition properties declared on the hover state; thus, browsers will wait 50 milliseconds before beginning the&#13;
reverse (or closing) transition.</p>&#13;
&#13;
<p>When the forward animation finishes transitioning to the final values and the <code class="keep-together">transitionend</code> event&#13;
is fired, all browsers will duplicate the <code>transition-delay</code> in the&#13;
reverse states.&#13;
Let’s say the user moves off that menu 75 milliseconds after it started&#13;
transitioning. This means the drop-down menu will animate closed without ever being fully opened and fully opaque. The browser should have&#13;
a 50-millisecond delay before closing the menu, just as it waited 50 milliseconds before&#13;
starting to open it.&#13;
This is actually a good user experience, as it&#13;
provides a few milliseconds of delay before closing, preventing jerky&#13;
behavior if the user accidentally navigates off the menu.</p>&#13;
&#13;
<p>In the case of a step timing function,&#13;
if the transition is 10 seconds with 10 steps, and the properties&#13;
revert after 3.25 seconds, ending a quarter of the way between the&#13;
third and fourth steps (completing three steps, or 30% of the transition), it will take 3 seconds to revert to the previous values. In the following example, the width of our <code>&lt;div&gt;</code> will grow to 130 pixels wide before it begins reverting back to 100 pixels wide on mouseout:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="p">{</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">100px</code><code class="p">;</code>&#13;
    <code class="k">transition</code><code class="o">:</code> <code class="n">width</code> <code class="m">10s</code> <code class="n">steps</code><code class="p">(</code><code class="m">10</code><code class="o">,</code> <code class="n">jump</code><code class="o">-</code><code class="n">start</code><code class="p">);</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">div</code><code class="nd">:hover</code> <code class="p">{</code>&#13;
    <code class="k">width</code><code class="o">:</code> <code class="m">200px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>While the <a data-primary="transitions" data-secondary="duration" data-type="indexterm" id="idm45176038503136"/>reverse duration will be rounded down to the time it took to&#13;
reach the most recently executed step, the reverse <em>direction</em> will be split by the originally&#13;
declared number of steps, not the number of steps that completed. In our&#13;
3.25-second case, it will take &#13;
<span class="keep-together">3 seconds</span> to revert through 10 steps. These&#13;
reverse transition steps will be shorter in duration at 300 milliseconds each, each step shrinking the width by 3 pixels, instead of &#13;
<span class="keep-together">10 pixels.</span></p>&#13;
&#13;
<p>If the&#13;
timing function is linear, the duration will be the same in both&#13;
directions. All other <code>cubic-bezier</code> functions will have a <span class="keep-together">duration</span> that is proportional to progress the initial transition made before being interrupted. Negative <code>transition-delay</code> values are also proportionally shortened. Positive delays remain unchanged in both directions.</p>&#13;
&#13;
<p>No browser will have a <code>transitionend</code> for the hover state, as the&#13;
transition did not end; but all browsers will have a <code>transitionend</code>&#13;
event in the reverse state when the menu finishes collapsing. The&#13;
<code>elapsedTime</code> for that reverse transition depends on whether the browser&#13;
took the full 200 milliseconds to close the menu, or if the browser takes as long to close the menu as it did to partially open the menu.</p>&#13;
&#13;
<p>To override these values, include transition properties in both the initial and final states (e.g., both the unhovered and hovered styles). While this does not impact the reverse shortening, it does provide more control.</p>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>Beware of having <a data-primary="inheritance" data-secondary="transitions" data-type="indexterm" id="idm45176038524096"/>transitions on both ancestors and descendants. For example, transitioning inherited properties on an element soon after transitioning the same property on ancestor or descendant nodes can have unexpected outcomes. If the transition on the descendant completes before the transition on the ancestor, the descendant will then resume inheriting the (still transitioning) value from its parent. This effect may not be what you expect.</p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Animatable Properties and Values" data-type="sect1"><div class="sect1" id="animatable-properties-and-values">&#13;
<h1>Animatable Properties and Values</h1>&#13;
&#13;
<p>Before <a data-primary="properties" data-secondary="animatable" data-type="indexterm" id="ix_prop_animatable"/><a data-primary="animatable properties" data-type="indexterm" id="ix_animatable_prop"/>implementing transitions and animations, it’s important to&#13;
understand that not all properties are animatable. You can&#13;
transition (or animate) any animatable CSS properties; but which&#13;
properties are animatable?</p>&#13;
&#13;
<p>One <a data-primary="interpolation, transitions" data-type="indexterm" id="idm45176038518528"/>key to developing a sense for which properties can be animated is to identify which have values that can be interpolated.&#13;
<em>Interpolation</em> is the construction of data points between the values of&#13;
known data points. <a data-primary="computed value" data-type="indexterm" id="idm45176038517312"/>The key guideline to determining if a property value&#13;
is animatable is whether the <em>computed value</em> can be interpolated. If a property’s computed values are keywords, they can’t be interpolated; if its keywords compute to a number of some sort, they can be.&#13;
The quick gut check is that if you can determine a midpoint&#13;
between two property values, those property values are probably&#13;
animatable.</p>&#13;
&#13;
<p>For example, <a data-primary="display property" data-secondary="animatability" data-type="indexterm" id="idm45176038515456"/>the <code>display</code> values like&#13;
<code>block</code> and <code>inline-block</code> aren’t numeric and therefore don’t have a&#13;
midpoint; they aren’t animatable. The <code>transform</code> property values of&#13;
<code>rotate(10deg)</code> and <code>rotate(20deg)</code> have a midpoint of <code>rotate(15deg)</code>; they are &#13;
<span class="keep-together">animatable.</span></p>&#13;
&#13;
<p>The <code>border</code> property<a data-primary="border property" data-secondary="animatability" data-type="indexterm" id="idm45176038481760"/> is shorthand for <code>border-style</code>, <code>border-width</code>,&#13;
and <code>border-color</code> (which, in turn, are themselves shorthand properties&#13;
for the four side values). While there is no midpoint between any of the&#13;
<code>border-style</code> values, the <code>border-width</code> property length units are&#13;
numeric, so they can be animated. The keyword values of <code>medium</code>, <code>thick</code>, and&#13;
<code>thin</code> have numeric equivalents and can be interpolated: the computed&#13;
value of the <code>border-width</code> property translates those keywords to lengths.</p>&#13;
&#13;
<p>In the <code>border-color</code> value, colors are numeric—the named&#13;
colors can all be represented using hexadecimal or other numeric color values—so colors are&#13;
animatable as well. If you transition from <code>border: red solid 3px</code> to&#13;
<code>border: blue dashed 10px</code>, the border width and border colors will&#13;
transition at the defined speed, but <code>border-style</code> will jump from&#13;
<code>solid</code> to <code>dashed</code> immediately.</p>&#13;
&#13;
<p>In the same vein, CSS <a data-primary="visibility property" data-secondary="animatability" data-type="indexterm" id="idm45176038473392"/>functions that take numeric values as parameters generally are animatable. An exception to this rule is properties with discrete animation types like <code class="keep-together">visibility</code>: while there is no&#13;
midpoint between the values of <code>visible</code> and <code>hidden</code>, <code class="keep-together">visibility</code>&#13;
values jump between the discrete values, jumping from visible to not visible. With the <code>visibility</code> property, when the initial value or the destination value is <code>visible</code>, the value will change at the end of the transition from <code>visible</code> to <code>hidden</code>. For a transition from <code>hidden</code> to <code>visible</code>, the value changes at the start of the transition.</p>&#13;
&#13;
<p>The <code>auto</code> value should generally be considered nonanimatable and should&#13;
be avoided for animations and transitions. According to the&#13;
specification, it is not an animatable value, but some browsers&#13;
interpolate the current numeric value of <code>auto</code> (such as <code>height: auto</code>)&#13;
to be <code>0px</code> or possibly a <code>fit-content()</code> function. The <code>auto</code> value is nonanimatable for properties like <code>height</code>, <code>width</code>, <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>, and <code>margin</code>.</p>&#13;
&#13;
<p>Often an alternative property or value may work. For example,&#13;
instead of changing <code>height: 0</code> to <code>height: auto</code>, use <code>max-height: 0</code>&#13;
to <code>max-height: 100vh</code>, which will generally create the expected&#13;
effect. The <code>auto</code> value is animatable for <code>min-height</code> and <code>min-width</code>,&#13;
since <code>min-height: auto</code> actually computes to 0.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="How Property Values Are Interpolated" data-type="sect2"><div class="sect2" id="how-property-values-are-interpolated">&#13;
<h2>How Property Values Are Interpolated</h2>&#13;
&#13;
<p>Numbers are <a data-primary="transitions" data-secondary="animatable properties for" data-type="indexterm" id="idm45176038454976"/><a data-primary="values" data-secondary="interpolated" data-type="indexterm" id="ix_value_interpol"/><a data-primary="interpolation, transitions" data-type="indexterm" id="ix_interpol_transition"/>interpolated as floating-point numbers. Integers are&#13;
interpolated as whole numbers, and thus increment or decrement as whole&#13;
numbers.</p>&#13;
&#13;
<p>In CSS, length and percentage units are translated into real numbers.&#13;
When transitioning or animating <code>calc()</code>, from one type of length to&#13;
or from a percentage, the values will be converted into a <code>calc()</code>&#13;
function and interpolated as real numbers.</p>&#13;
&#13;
<p>Colors, <a data-primary="colors" data-secondary="in transitions" data-secondary-sortas="transitions" data-type="indexterm" id="idm45176038449744"/>whether they are HSLA, RGB, or named colors like <code>aliceblue</code>, are translated to their RGBA equivalent values for transitioning, and interpolated across the RGBA color space.&#13;
If you want to interpolate across a different color space, such as HSL, ensure the pre- and post-transition colors are in the same color space (in this case, HSL).</p>&#13;
&#13;
<p>When animating font weights, if you use keywords like <code>bold</code>, they’ll&#13;
be converted to numeric values and animated.</p>&#13;
&#13;
<p>When including animatable property values that have more than one&#13;
component, each component is interpolated appropriately for that&#13;
component. For example, <code>text-shadow</code> has up to four components: the&#13;
color, <code>x</code>, <code>y</code>, and <code>blur</code>. The color is interpolated as <code>color</code>, whereas the <code>x</code>, <code>y</code>,&#13;
and <code>blur</code> components are interpolated as lengths.</p>&#13;
&#13;
<p>Box <a data-primary="shadows" data-secondary="box-shadow property" data-type="indexterm" id="idm45176038442160"/><a data-primary="text shadows, transitions" data-type="indexterm" id="idm45176038441184"/><a data-primary="box-shadow property" data-type="indexterm" id="idm45176038440512"/>shadows have two additional optional keywords: <code>inset</code> (or lack thereof) and <code>spread</code>. Because <code>spread</code> is a length, it is interpolated. The <code>inset</code> keyword cannot be converted to a numeric equivalent, so there is no way to gradually transition between inset and drop shadows.</p>&#13;
&#13;
<p>Similar to <a data-primary="gradients" data-secondary="in transitions" data-secondary-sortas="transitions" data-type="indexterm" id="idm45176038437664"/>values with more than one component, gradients can be&#13;
transitioned only if you are transitioning gradients of the same type&#13;
(linear, radial, or conic) with equal numbers of color stops. The colors of each&#13;
color stop are then interpolated as colors, and the position of each&#13;
color stop is interpolated as length and percentage units.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Interpolating Repeating Values" data-type="sect2"><div class="sect2" id="idm45176038436128">&#13;
<h2>Interpolating Repeating Values</h2>&#13;
&#13;
<p>When you have simple lists of other types of properties, each item in the list is interpolated appropriately for that type—as long as the&#13;
lists have the same number of items or repeatable items, and each pair&#13;
of values can be interpolated.  For example:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.img</code> <code class="p">{</code>&#13;
    <code class="k">background-image</code><code class="o">:</code>&#13;
        <code class="sx">url(1.gif)</code><code class="o">,</code> <code class="sx">url(2.gif)</code><code class="o">,</code> <code class="sx">url(3.gif)</code><code class="o">,</code> <code class="sx">url(4.gif)</code><code class="o">,</code>&#13;
        <code class="sx">url(5.gif)</code><code class="o">,</code> <code class="sx">url(6.gif)</code><code class="o">,</code> <code class="sx">url(7.gif)</code><code class="o">,</code> <code class="sx">url(8.gif)</code><code class="o">,</code>&#13;
        <code class="sx">url(9.gif)</code><code class="o">,</code> <code class="sx">url(10.gif)</code><code class="o">,</code> <code class="sx">url(11.gif)</code><code class="o">,</code> <code class="sx">url(12.gif)</code><code class="p">;</code>&#13;
    <code class="k">transition</code><code class="o">:</code> <code class="k">background-size</code> <code class="m">1s</code> <code class="n">ease</code><code class="o">-</code><code class="n">in</code> <code class="m">0s</code><code class="p">;</code>&#13;
    <code class="k">background-size</code><code class="o">:</code> <code class="m">10px</code> <code class="m">10px</code><code class="o">,</code> <code class="m">20px</code> <code class="m">20px</code><code class="o">,</code> <code class="m">30px</code> <code class="m">30px</code><code class="o">,</code> <code class="m">40px</code> <code class="m">40px</code><code class="p">;</code>&#13;
<code class="p">}</code>&#13;
<code class="nc">.img</code><code class="nd">:hover</code> <code class="p">{</code>&#13;
    <code class="k">background-size</code><code class="o">:</code> <code class="m">25px</code> <code class="m">25px</code><code class="o">,</code> <code class="m">50px</code> <code class="m">50px</code><code class="o">,</code> <code class="m">75px</code> <code class="m">75px</code><code class="o">,</code> <code class="m">100px</code> <code class="m">100px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In transitioning four <code>background-sizes</code>, with all the sizes in&#13;
both lists listed in pixels, the third <code>background-size</code> from the&#13;
pretransitioned state can gradually transition to the third&#13;
<code>background-size</code> of the transitioned list. In the preceding example,&#13;
background images 1, 5, and 9 will transition from <code>10px</code> to <code>25px</code> in height and width when hovered. Similarly, images 3, 7, and 11&#13;
will transition from <code>30px</code> to <code>75px</code>, and so forth.</p>&#13;
&#13;
<p>Thus, the <code>background-size</code> values are repeated three times, as if the CSS had been written as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.img</code> <code class="p">{</code>&#13;
    <code class="err">…</code>&#13;
    <code class="k">background-size</code><code class="o">:</code> <code class="m">10px</code> <code class="m">10px</code><code class="o">,</code> <code class="m">20px</code> <code class="m">20px</code><code class="o">,</code> <code class="m">30px</code> <code class="m">30px</code><code class="o">,</code> <code class="m">40px</code> <code class="m">40px</code><code class="o">,</code>&#13;
                     <code class="m">10px</code> <code class="m">10px</code><code class="o">,</code> <code class="m">20px</code> <code class="m">20px</code><code class="o">,</code> <code class="m">30px</code> <code class="m">30px</code><code class="o">,</code> <code class="m">40px</code> <code class="m">40px</code><code class="o">,</code>&#13;
                     <code class="m">10px</code> <code class="m">10px</code><code class="o">,</code> <code class="m">20px</code> <code class="m">20px</code><code class="o">,</code> <code class="m">30px</code> <code class="m">30px</code><code class="o">,</code> <code class="m">40px</code> <code class="m">40px</code><code class="p">;</code>&#13;
    <code class="err">…</code>&#13;
<code class="p">}</code>&#13;
<code class="nc">.img</code><code class="nd">:hover</code> <code class="p">{</code>&#13;
    <code class="k">background-size</code><code class="o">:</code> <code class="m">25px</code> <code class="m">25px</code><code class="o">,</code> <code class="m">50px</code> <code class="m">50px</code><code class="o">,</code> <code class="m">75px</code> <code class="m">75px</code><code class="o">,</code> <code class="m">100px</code> <code class="m">100px</code><code class="o">,</code>&#13;
                     <code class="m">25px</code> <code class="m">25px</code><code class="o">,</code> <code class="m">50px</code> <code class="m">50px</code><code class="o">,</code> <code class="m">75px</code> <code class="m">75px</code><code class="o">,</code> <code class="m">100px</code> <code class="m">100px</code><code class="o">,</code>&#13;
                     <code class="m">25px</code> <code class="m">25px</code><code class="o">,</code> <code class="m">50px</code> <code class="m">50px</code><code class="o">,</code> <code class="m">75px</code> <code class="m">75px</code><code class="o">,</code> <code class="m">100px</code> <code class="m">100px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If a property doesn’t have enough comma-separated values to match the&#13;
number of background images, the list of values is repeated until there are&#13;
enough, even when the list in the animated state doesn’t match the&#13;
initial state:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.img</code><code class="nd">:hover</code> <code class="p">{</code>&#13;
    <code class="k">background-size</code><code class="o">:</code> <code class="m">33px</code> <code class="m">33px</code><code class="o">,</code> <code class="m">66px</code> <code class="m">66px</code><code class="o">,</code> <code class="m">99px</code> <code class="m">99px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If we transition from four <code>background-size</code> declarations in the initial&#13;
state to three <code>background-size</code> declarations in the animated state, all in pixels and still with 12 background images, the animated and initial state values are repeated (three and four times, respectively) until we have the 12 necessary values, as if the following had been declared:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nc">.img</code> <code class="p">{</code>&#13;
    <code class="err">…</code>&#13;
    <code class="k">background-size</code><code class="o">:</code> <code class="m">10px</code> <code class="m">10px</code><code class="o">,</code> <code class="m">20px</code> <code class="m">20px</code><code class="o">,</code> <code class="m">30px</code> <code class="m">30px</code><code class="o">,</code>&#13;
                     <code class="m">40px</code> <code class="m">40px</code><code class="o">,</code> <code class="m">10px</code> <code class="m">10px</code><code class="o">,</code> <code class="m">20px</code> <code class="m">20px</code><code class="o">,</code>&#13;
                     <code class="m">30px</code> <code class="m">30px</code><code class="o">,</code> <code class="m">40px</code> <code class="m">40px</code><code class="o">,</code> <code class="m">10px</code> <code class="m">10px</code><code class="o">,</code>&#13;
                     <code class="m">20px</code> <code class="m">20px</code><code class="o">,</code> <code class="m">30px</code> <code class="m">30px</code><code class="o">,</code> <code class="m">40px</code> <code class="m">40px</code><code class="p">;</code>&#13;
    <code class="err">…</code>&#13;
<code class="p">}</code>&#13;
<code class="nc">.img</code><code class="nd">:hover</code> <code class="p">{</code>&#13;
    <code class="k">background-size</code><code class="o">:</code> <code class="m">33px</code> <code class="m">33px</code><code class="o">,</code> <code class="m">66px</code> <code class="m">66px</code><code class="o">,</code> <code class="m">99px</code> <code class="m">99px</code><code class="o">,</code>&#13;
                     <code class="m">33px</code> <code class="m">33px</code><code class="o">,</code> <code class="m">66px</code> <code class="m">66px</code><code class="o">,</code> <code class="m">99px</code> <code class="m">99px</code><code class="o">,</code>&#13;
                     <code class="m">33px</code> <code class="m">33px</code><code class="o">,</code> <code class="m">66px</code> <code class="m">66px</code><code class="o">,</code> <code class="m">99px</code> <code class="m">99px</code><code class="o">,</code>&#13;
                     <code class="m">33px</code> <code class="m">33px</code><code class="o">,</code> <code class="m">66px</code> <code class="m">66px</code><code class="o">,</code> <code class="m">99px</code> <code class="m">99px</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>If a pair of values cannot be interpolated—for example, if the <code>background-size</code> changes from <code>contain</code> in the default state to <code>cover</code> when hovered—then, according to the&#13;
specification, the lists are not interpolatable. However, some browsers&#13;
ignore that particular pair of values for the purposes of the transition, and still animate the interpolatable values.</p>&#13;
&#13;
<p>Some property values can animate if the browser can infer&#13;
implicit <span class="keep-together">values.</span> For example, for shadows, the browser will&#13;
infer an implicit shadow <code>box-shadow: transparent 0 0 0</code> or&#13;
<code>box-shadow: inset transparent 0 0 0</code>, replacing any values not&#13;
explicitly included in the pre- or post-transition state. These examples are in the <a href="https://meyerweb.github.io/csstdg5figs">chapter files for this book</a>.</p>&#13;
&#13;
<p>Only animatable property value changes trigger <code>transitionend</code> events.</p>&#13;
&#13;
<p>If you accidentally include a property that can’t be transitioned, fear&#13;
not. The entire <span class="keep-together">declaration</span> will not fail: the browser will simply not transition the property that is not animatable.</p>&#13;
&#13;
<p>Note that a nonanimatable property or nonexistent CSS property is not exactly ignored. The browser passes over unrecognized or nonanimatable properties, keeping their place in the property list order to ensure that the other comma-separated transition properties described next are not applied to the wrong properties.<sup><a data-type="noteref" href="ch18.html#idm45176064085488" id="idm45176064085488-marker">1</a></sup></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Transitions can occur only on properties that are not currently&#13;
being impacted by a CSS animation. If the element is being animated,&#13;
properties may still transition, as long as they are not properties that&#13;
are currently controlled by the animation. CSS animations are covered in&#13;
<a data-type="xref" href="ch19.html#animation">Chapter 19</a>.<a data-primary="" data-startref="ix_animatable_prop" data-type="indexterm" id="idm45176064083120"/><a data-primary="" data-startref="ix_prop_animatable" data-type="indexterm" id="idm45176064082144"/><a data-primary="" data-startref="ix_interpol_transition" data-type="indexterm" id="idm45176064081200"/><a data-primary="" data-startref="ix_transition_animat_prop" data-type="indexterm" id="idm45176064080256"/><a data-primary="" data-startref="ix_value_interpol" data-type="indexterm" id="idm45176064079344"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Printing Transitions" data-type="sect1"><div class="sect1" id="printing-transitions">&#13;
<h1>Printing Transitions</h1>&#13;
&#13;
<p>When <a data-primary="printing" data-secondary="transitions and" data-type="indexterm" id="idm45176064076336"/><a data-primary="transitions" data-secondary="printing" data-type="indexterm" id="idm45176064075328"/>web pages or web applications are printed, the stylesheet for print&#13;
media is used. If your style element’s media attribute matches only&#13;
<code>screen</code>, the CSS will not impact the printed page at all.</p>&#13;
&#13;
<p>Often, no media attribute is included; it is as if <code>media="all"</code> were&#13;
set, which is the default. Depending on the browser, when a transitioned&#13;
element is printed, either <span class="keep-together">the interpolating</span> values are ignored or the&#13;
property values in their current state <span class="keep-together">are printed.</span></p>&#13;
&#13;
<p>You can’t see the element transitioning on a piece of paper, but in some&#13;
browsers, like Chrome, if an element transitioned from one state to&#13;
another, the current state at the time the <code>print</code> function is called will be the value on the printed page, if that property is printable. For&#13;
example, if a background color changed, neither the pre-transition or the&#13;
post-transition background color will be printed, as background colors&#13;
are generally not printed. However, if the text color mutated from one&#13;
value to another, the current value of <code>color</code> will get printed&#13;
on a color printer or to a PDF.</p>&#13;
&#13;
<p>In other browsers, like Firefox, whether the pre-transition or&#13;
post-transition value is printed depends on how the transition was&#13;
initiated. If it’s initiated with a hover, for example, the nonhovered value will be&#13;
printed, as you are no longer hovering over the element while you interact&#13;
with the print dialog. If it transitioned with a class addition, the&#13;
post-transition value will be printed, even if the transition hasn’t&#13;
completed. The printing acts as if the transition properties are ignored.</p>&#13;
&#13;
<p>Given that CSS has separate print stylesheets or <code>@media</code> rules for&#13;
print, browsers compute style separately. In the print style, styles&#13;
don’t change, so there just aren’t any transitions. The printing acts as&#13;
if the property values changed instantly instead of transitioning over&#13;
time.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45176064069040">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Transitions are a useful and quite powerful way to add UI enhancements. Worrying about archaic browsers should not prevent you from including them, since if a browser doesn’t support CSS transitions, the changes will still be applied. They’ll just “transition” from the initial state to the end state instantaneously when the style recomputation occurs. A user may miss out on an interesting (or possibly annoying)&#13;
effect, but will not miss out on any content.<a data-primary="" data-startref="ix_transition_ch18" data-type="indexterm" id="idm45176064067824"/></p>&#13;
&#13;
<p>The defining feature of transitions is that they are applied when an element transitions from one state to another, whether that happens because of user action or some kind of scripted change to the DOM.  If you want elements to animate regardless of user action or DOM changes, the next chapter will show you the way.</p>&#13;
</div></section>&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm45176064085488"><sup><a href="ch18.html#idm45176064085488-marker">1</a></sup> This might change. The CSS Working Group is considering making all property values animatable, switching from one value to the next at the midpoint of the timing function if there is no midpoint between the pre and post values.</p></div></div></section></body></html>