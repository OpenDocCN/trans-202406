<html><head></head><body><section data-pdf-bookmark="Part I Conclusion" data-type="afterword" epub:type="afterword"><div class="appendix" id="idm46466887179688">&#13;
<h1>Part I Conclusion</h1>&#13;
&#13;
<p>In Part I, we’ve been talking about storage engines. We started from high-level database system architecture and classification, learned how to implement on-disk storage structures, and how they fit into the full picture with other components.</p>&#13;
&#13;
<p>We’ve<a data-primary="database systems" data-secondary="buffering, immutability, and ordering in" data-type="indexterm" id="idm46466887176248"/><a data-primary="immutability" data-type="indexterm" id="idm46466887177800"/><a data-primary="ordering" data-type="indexterm" id="idm46466887182664"/> seen several storage structures, starting from B-Trees. The discussed structures do not represent an entire field, and there are many other interesting developments. However, these examples are still a good illustration of the three properties we identified at the beginning<a data-primary="buffering" data-type="indexterm" id="idm46466887182056"/> of this part: <em>buffering</em>, <em>immutability</em>, and <em>ordering</em>. These properties are useful for describing, memorizing, and expressing different aspects of the storage structures.</p>&#13;
&#13;
<p><a href="#buffering_immutability_ordering_img">Figure I-1</a> summarizes the discussed storage structures and shows whether or not they’re using these properties.</p>&#13;
&#13;
<p>Adding in-memory buffers<a data-primary="immutable storage structures" data-type="indexterm" id="idm46466887174360"/><a data-primary="mutable storage structures" data-type="indexterm" id="idm46466887173352"/> always has a positive impact on write amplification. In in-place update structures like WiredTiger and LA-Trees, in-memory buffering helps to amortize the cost of multiple same-page writes by combining them. In other words, buffering helps to reduce write amplification.<a data-primary="WiredTiger" data-type="indexterm" id="idm46466887171560"/><a data-primary="lazy B-Trees" data-secondary="WiredTiger" data-type="indexterm" id="idm46466887170920"/><a data-primary="lazy B-Trees" data-secondary="Lazy-Adaptive Tree (LA-Tree)" data-type="indexterm" id="idm46466887169944"/><a data-primary="Lazy-Adaptive Tree (LA-Tree)" data-type="indexterm" id="idm46466887169000"/><a data-primary="two-component LSM Trees" data-type="indexterm" id="idm46466887168328"/><a data-primary="multicomponent LSM Trees" data-type="indexterm" id="idm46466887167624"/><a data-primary="B-Trees, variants of" data-secondary="copy-on-write B-Trees" data-type="indexterm" id="idm46466887166536"/><a data-primary="copy-on-write B-Trees" data-type="indexterm" id="idm46466887165688"/><a data-primary="B-Trees, variants of" data-secondary="FD-Trees" data-type="indexterm" id="idm46466887164984"/><a data-primary="Bitcask" data-type="indexterm" id="idm46466887163976"/><a data-primary="unordered storage structures" data-secondary="Bitcask" data-type="indexterm" id="idm46466887163176"/><a data-primary="WiscKey" data-type="indexterm" id="idm46466887162136"/><a data-primary="unordered storage structures" data-secondary="WiscKey" data-type="indexterm" id="idm46466887161336"/><a data-primary="B-Trees, variants of" data-secondary="Bw-Trees" data-type="indexterm" id="idm46466887160296"/><a data-primary="Bw-Trees (Buzzword-Trees)" data-secondary="buffering, immutability, and ordering" data-type="indexterm" id="idm46466887159224"/></p>&#13;
&#13;
<p>In immutable structures, such as multicomponent LSM Trees and FD-Trees, buffering has a similar positive effect, but at a cost of future rewrites when moving data from one immutable level to the other. In other words, using immutability may lead to deferred write amplification. At the same time, using immutability has a positive impact on concurrency and space amplification, since most of the discussed immutable structures use fully occupied pages.</p>&#13;
&#13;
<p>When using immutability, unless we <em>also</em> use buffering, we end up with unordered storage structures like Bitcask and WiscKey (with the exception of copy-on-write B-Trees, which copy, re-sort, and relocate their pages). WiscKey stores <em>only keys</em> in sorted LSM Trees and allows retrieving records in key order using the key index. In Bw-Trees, <em>some</em> of the nodes (ones that were consolidated) hold data records in key order, while the rest of the logical Bw-Tree nodes may have their delta updates scattered across different pages.</p>&#13;
&#13;
<figure class="afterword_label width-75"><div class="figure" id="buffering_immutability_ordering_img">&#13;
<img alt="dbin 0001" src="assets/dbin_0001.png"/>&#13;
<h6><span class="label">Figure I-1. </span>Buffering, immutability, and ordering properties of discussed storage structures. (1) WiscKey uses buffering only for keeping keys sorted order. (2) Only consolidated nodes in Bw-Trees hold ordered records.</h6>&#13;
</div></figure>&#13;
&#13;
<p>You see that these three properties can be mixed and matched in order to achieve the desired characteristics. Unfortunately, storage engine design usually involves trade-offs: you increase the cost of one operation in favor of the other.</p>&#13;
&#13;
<p>Using this knowledge, you should be able to start looking closer at the code of most modern database systems. Some of the code references and starting points can be found across the entire book. Knowing and understanding the terminology will make this process easier for you.</p>&#13;
&#13;
<p>Many modern database systems are powered by probabilistic data structures <a data-type="xref" href="app01.html#FLAJOLET12">[FLAJOLET12]</a> <a data-type="xref" href="app01.html#CORMODE04">[CORMODE04]</a>, and there’s new research being done on bringing ideas from machine learning into database systems <a data-type="xref" href="app01.html#KRASKA18">[KRASKA18]</a>. We’re about to experience further changes in research and industry as nonvolatile and byte-addressable storage becomes more prevalent and widely available <a data-type="xref" href="app01.html#VENKATARAMAN11">[VENKATARAMAN11]</a>.</p>&#13;
&#13;
<p>Knowing the fundamental concepts described in this book should help you to understand and implement newer research, since it borrows from, builds upon, and is inspired by the same concepts. The major advantage of knowing the theory and history is that there’s nothing entirely new and, as the narrative of this book shows, progress is incremental.</p>&#13;
</div></section></body></html>