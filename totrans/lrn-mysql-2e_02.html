<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Modeling and Designing Databases"><div class="chapter" id="CH2_DESIGN">
<h1><span class="label">Chapter 2. </span>Modeling and Designing Databases</h1>


<p>When implementing a new database, it’s easy to fall into the trap of <a data-type="indexterm" data-primary="database design" data-secondary="about" id="idm46177499280680"/><a data-type="indexterm" data-primary="designing a database" data-see="database design" id="idm46177499279704"/>quickly getting something up and running without dedicating adequate time and effort to the design. This carelessness frequently leads to costly redesigns and reimplementations down the road. Designing a database is like drafting the blueprints for a house; it’s silly to start building without detailed plans. Notably, good design allows you to extend the original building without pulling everything down and starting from scratch. And as you will see, bad designs are directly related to poor database performance.</p>






<section data-type="sect1" data-pdf-bookmark="How Not to Develop a Database"><div class="sect1" id="idm46177499277976">
<h1>How Not to Develop a Database</h1>

<p>Database design is probably not the most exciting task in the world, <a data-type="indexterm" data-primary="CREATE DATABASE" data-secondary="creating tables" data-tertiary="about how not to" id="ch02-not4"/><a data-type="indexterm" data-primary="database design" data-secondary="about how not to" id="ch02-not"/><a data-type="indexterm" data-primary="tables" data-secondary="creating tables" data-tertiary="about how not to" id="ch02-not2"/><a data-type="indexterm" data-primary="CREATE TABLE" data-secondary="about how not to" id="ch02-not3"/>but indeed it is becoming one of the most important ones. Before we describe how to go about the design process, let’s look at an example of database design on the run.</p>

<p>Imagine we want to create a database to store student grades for a university computer science department. We could create a <code>Student_Grades</code> table to store grades for each student and each course. The table would have columns for the given names and the surname of each student and each course they have taken, the course name, and the percentage result (shown as <code>Pctg</code>). We’d have a different row for each student for each of their courses:</p>

<pre data-type="programlisting">+------------+---------+-----------------------+------+
| GivenNames | Surname | CourseName            | Pctg |
+------------+---------+-----------------------+------+
| John Paul  | Bloggs  | Data Science          |   72 |
| Sarah      | Doe     | Programming 1         |   87 |
| John Paul  | Bloggs  | Computing Mathematics |   43 |
| John Paul  | Bloggs  | Computing Mathematics |   65 |
| Sarah      | Doe     | Data Science          |   65 |
| Susan      | Smith   | Computing Mathematics |   75 |
| Susan      | Smith   | Programming 1         |   55 |
| Susan      | Smith   | Computing Mathematics |   80 |
+------------+---------+-----------------------+------+</pre>

<p>The list is nice and compact, we can easily access grades for any student or any course, and it looks similar to a spreadsheet. However, we could have more than one student with the same name. For instance, there are two entries for Susan Smith and the Computing Mathematics course in the sample data. Which Susan Smith got 75% and which got 80%? A common way to differentiate duplicate data entries is to assign a unique number to each entry. Here, we can assign a unique <code>StudentID</code> number to each student:</p>

<pre data-type="programlisting">+------------+------------+---------+-----------------------+------+
| StudentID  | GivenNames | Surname | CourseName            | Pctg |
+------------+------------+---------+-----------------------+------+
| 12345678   | John Paul  | Bloggs  | Data Science          |   72 |
| 12345121   | Sarah      | Doe     | Programming 1         |   87 |
| 12345678   | John Paul  | Bloggs  | Computing Mathematics |   43 |
| 12345678   | John Paul  | Bloggs  | Computing Mathematics |   65 |
| 12345121   | Sarah      | Doe     | Data Science          |   65 |
| 12345876   | Susan      | Smith   | Computing Mathematics |   75 |
| 12345876   | Susan      | Smith   | Programming 1         |   55 |
| 12345303   | Susan      | Smith   | Computing Mathematics |   80 |
+------------+------------+---------+-----------------------+------+</pre>

<p>Now we know which Susan Smith got 80%: the one with the student ID number 12345303.</p>

<p>There’s another problem. In our table, John Paul Bloggs has two scores for the Computing Mathematics course: he failed it once with 43%, and then passed it with 65% on his second attempt. <a data-type="indexterm" data-primary="relational databases" data-secondary="rows forming sets" id="idm46177499263544"/>In a relational database, the rows form a set, and there is no implicit ordering between them. Looking at this table we might guess that the pass happened after the failure, but we can’t be sure. There’s no guarantee that the newer grade will appear after the older one, so we need to add information about when each grade was awarded, say by adding a year (<code>Year</code>) and semester (<code>Sem</code>):</p>

<pre data-type="programlisting">+------------+------------+---------+-----------------------+------+-----+------+
| StudentID  | GivenNames | Surname | CourseName            | Year | Sem | Pctg |
+------------+------------+---------+-----------------------+------+-----+------+
| 12345678   | John Paul  | Bloggs  | Data Science          | 2019 |   2 |   72 |
| 12345121   | Sarah      | Doe     | Programming 1         | 2020 |   1 |   87 |
| 12345678   | John Paul  | Bloggs  | Computing Mathematics | 2019 |   2 |   43 |
| 12345678   | John Paul  | Bloggs  | Computing Mathematics | 2020 |   1 |   65 |
| 12345121   | Sarah      | Doe     | Data Science          | 2020 |   1 |   65 |
| 12345876   | Susan      | Smith   | Computing Mathematics | 2019 |   1 |   75 |
| 12345876   | Susan      | Smith   | Programming 1         | 2019 |   2 |   55 |
| 12345303   | Susan      | Smith   | Computing Mathematics | 2020 |   1 |   80 |
+------------+------------+---------+-----------------------+------+-----+------+</pre>

<p>Notice that the <code>Student_Grades</code> table has become a bit bloated. We’ve repeated the student ID, given names, and surname for every year. We could split up the information and create a <code>Student_Details</code> table:</p>

<pre data-type="programlisting">+------------+------------+---------+
| StudentID  | GivenNames | Surname |
+------------+------------+---------+
| 12345121   | Sarah      | Doe     |
| 12345303   | Susan      | Smith   |
| 12345678   | John Paul  | Bloggs  |
| 12345876   | Susan      | Smith   |
+------------+------------+---------+</pre>

<p>And we could keep less information in the <code>Student_Grades</code> table:</p>

<pre data-type="programlisting">+------------+-----------------------+------+-----+------+
| StudentID  | CourseName            | Year | Sem | Pctg |
+------------+-----------------------+------+-----+------+
| 12345678   | Data Science          | 2019 |   2 |   72 |
| 12345121   | Programming 1         | 2020 |   1 |   87 |
| 12345678   | Computing Mathematics | 2019 |   2 |   43 |
| 12345678   | Computing Mathematics | 2020 |   1 |   65 |
| 12345121   | Data Science          | 2020 |   1 |   65 |
| 12345876   | Computing Mathematics | 2019 |   1 |   75 |
| 12345876   | Programming 1         | 2019 |   2 |   55 |
| 12345303   | Computing Mathematics | 2020 |   1 |   80 |
+------------+-----------------------+------+-----+------+</pre>

<p>To look up a student’s grades, we would need to first look up their student ID from the <code>Student_Details</code> table and then read the grades for that student ID from the 
<span class="keep-together"><code>Student_Grades</code></span> table.</p>

<p>There are still issues we haven’t considered, though. For example, should we keep information on a student’s enrollment date, postal and email addresses, fees, or attendance? Should we store different types of postal addresses? How should we store addresses so that things don’t break when students change their addresses?</p>

<p>Implementing a database in this way is problematic; we keep running into things we hadn’t thought about and have to keep changing our database structure. We can save a lot of reworking by carefully documenting the requirements up front and then working through them to develop a coherent design.<a data-type="indexterm" data-startref="ch02-not" id="idm46177499251368"/><a data-type="indexterm" data-startref="ch02-not2" id="idm46177499250664"/><a data-type="indexterm" data-startref="ch02-not3" id="idm46177499249992"/><a data-type="indexterm" data-startref="ch02-not4" id="idm46177499249320"/></p>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="The Database Design Process"><div class="sect1" id="idm46177499277384">
<h1>The Database Design Process</h1>

<p>There are three major stages in the database design, each producing a progressively lower-level description:<a data-type="indexterm" data-primary="database design" data-secondary="about process" id="idm46177499246744"/></p>
<dl>
<dt>Requirements analysis</dt>
<dd>
<p>First, we determine and write down what we need from the database, what data we will store, and how the data items relate to each other. In practice, this might involve a detailed study of the application requirements and talking to people in various roles that will interact with the database and application.</p>
</dd>
<dt>Conceptual design</dt>
<dd>
<p>Once we know the database requirements, we distill them into a formal description of the database design. Later in this chapter we’ll see how to use modeling to produce the conceptual design.</p>
</dd>
<dt>Logical design</dt>
<dd>
<p>Finally, we map the database design onto an existing database management system and database tables.</p>
</dd>
</dl>

<p>At the end of the chapter, we’ll look at how we can use the open source MySQL Workbench tool to convert the conceptual design to a MySQL database schema.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="The Entity Relationship Model"><div class="sect1" id="idm46177499239960">
<h1>The Entity Relationship Model</h1>

<p>At a basic level, databases store information <a data-type="indexterm" data-primary="database design" data-secondary="entities" data-tertiary="about Entity Relationship model" id="idm46177499238264"/><a data-type="indexterm" data-primary="database design" data-secondary="relationships" data-tertiary="about Entity Relationship model" id="idm46177499236952"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="about" id="idm46177499235720"/>about distinct objects, or <em>entities</em>, and the associations, or <em>relationships</em>, between these entities. For example, a university database might store information about students, courses, and enrollment. A student and a course are entities, whereas enrollment is a relationship between a student and a course. Similarly, an inventory and sales database might store information about products, customers, and sales. A product and a customer are entities, and a sale is a relationship between a customer and a product. It is common to get confused between entities and relationships when you’re starting out, and you may end up designing relationships as entities and vice versa. The best way to improve your database design skills is by practicing a lot.</p>

<p>A popular approach to conceptual design uses the <em>Entity Relationship</em> (ER) model, which helps transform the requirements into a formal description of the entities and relationships in the database. We’ll start by looking at how the ER modeling process works and then observe it in <a data-type="xref" href="#BAS-SEC-MODELING-EXAMPLES">“Entity Relationship Modeling Examples”</a> for three sample databases.</p>








<section data-type="sect2" data-pdf-bookmark="Representing Entities"><div class="sect2" id="idm46177499230952">
<h2>Representing Entities</h2>

<p>To help visualize the design, the ER modeling approach <a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="entities" id="idm46177499229256"/><a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="entities" id="idm46177499227944"/>involves drawing an ER diagram. In the ER diagram, we represent an entity set by a rectangle containing the entity name. For our sales database example, our ER diagram would show the product and customer entity sets, as shown in <a data-type="xref" href="#FIG-DESIGN-ENTITY">Figure 2-1</a>.</p>

<figure class="width-50"><div id="FIG-DESIGN-ENTITY" class="figure">
<img src="Images/lm2e_0201.png" alt="lm2e 0201" width="844" height="122"/>
<h6><span class="label">Figure 2-1. </span>An entity set is represented by a named rectangle</h6>
</div></figure>

<p>We typically use the database to store <a data-type="indexterm" data-primary="database design" data-secondary="entities" data-tertiary="attributes of entities" id="ch02-atet"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="attributes of entities" id="ch02-atet2"/><a data-type="indexterm" data-primary="attributes" data-secondary="entities" id="ch02-atet3"/>specific characteristics, or <em>attributes</em>, of the entities. We could record the name, email address, postal address, and telephone number of each customer in a sales database. <a data-type="indexterm" data-primary="customer relationship management databases" id="idm46177499218168"/><a data-type="indexterm" data-primary="CRM databases" id="idm46177499217368"/>In a more elaborate customer relationship management (CRM) application, we could also store the names of the customer’s spouse and children, the languages the customer speaks, the customer’s history of interaction with our company, and so on. Attributes describe the entity they belong to.</p>

<p>We may form an attribute from smaller parts; <a data-type="indexterm" data-primary="attributes" data-secondary="entities" data-tertiary="composite versus simple" id="idm46177499215880"/><a data-type="indexterm" data-primary="simple entity attributes" id="idm46177499214632"/><a data-type="indexterm" data-primary="composite entity attributes" id="idm46177499213896"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="attributes of entities" data-tertiary="composite versus simple" id="idm46177499213208"/>for example, we compose a postal address from a street number, city, zip code, and country. We classify attributes as <em>composite</em> if they’re composed of smaller parts in this way, and as <em>simple</em> otherwise.</p>

<p>Some attributes can have multiple values for a given entity—for example, a customer can provide several telephone numbers, so the telephone number attribute is 
<span class="keep-together"><em>multivalued</em>.</span></p>

<p>Attributes help distinguish one entity from other entities of the same type. We could use the name attribute to differentiate between customers, but this could be an inadequate solution because several customers could have identical names. To tell them apart, we need an attribute (or a minimal combination of attributes) guaranteed to be unique to each customer. <a data-type="indexterm" data-primary="database design" data-secondary="primary key" id="ch02-pk5"/><a data-type="indexterm" data-primary="database design" data-secondary="entities" data-tertiary="primary key" id="ch02-pk"/><a data-type="indexterm" data-primary="attributes" data-secondary="entities" data-tertiary="primary key" id="ch02-pk3"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="attributes of entities" data-tertiary="primary key" id="ch02-pk2"/><a data-type="indexterm" data-primary="primary key" data-secondary="database design" id="ch02-pk4"/>The identifying attribute or attributes form a unique key, and in this particular case, we call it a <em>primary key</em>.</p>

<p>In our example, we can assume that no two customers have the same email address, so the email address can be the primary key. However, when designing a database, we need to think carefully about the implications of our choices. For example, if we decide to identify customers by their email addresses, how will we handle a customer having multiple email addresses? Any applications we build to use this database might treat each email address as a separate person. It could be hard to adapt everything to allow people to have more than one. Using the email address as the key also means that every customer must have an email address; otherwise, we can’t distinguish between customers who don’t have one.</p>

<p class="pagebreak-before">Looking at the other attributes for one that can serve as an alternative key, we see that while it’s possible that two customers could have the same telephone number (and so we cannot use the telephone number as a key), it’s likely that people who have the same telephone number will not have the same name, so we can use the combination of the telephone number and the name as <a data-type="indexterm" data-primary="composite entity attributes" data-secondary="composite keys" id="idm46177499198824"/><a data-type="indexterm" data-primary="attributes" data-secondary="entities" data-tertiary="composite keys" id="idm46177499197832"/>a composite key.</p>

<p>Clearly, there may be several possible keys that could be used to identify an entity; we choose one of the alternatives, or <em>candidate</em> keys, to be our main or <em>primary</em> key. We usually choose based on how confident we are that the attribute will be nonempty and unique for each entity and how small the key is (shorter keys are faster to maintain and to use to perform lookup operations).</p>

<p>In the ER diagram, attributes are represented<a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="attributes" id="idm46177499194376"/><a data-type="indexterm" data-primary="attributes" data-secondary="entities" data-tertiary="ER diagrams" id="idm46177499193064"/><a data-type="indexterm" data-primary="composite entity attributes" data-secondary="ER diagrams" id="idm46177499191848"/><a data-type="indexterm" data-primary="primary key" data-secondary="ER diagrams" id="idm46177499190888"/><a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="attributes" id="idm46177499189944"/> as labeled ovals connected to their entity, as shown in <a data-type="xref" href="#FIG-DESIGN-CUSTOMER">Figure 2-2</a>. Attributes comprising the primary key are shown underlined. The parts of any composite attributes are drawn connected to the composite attribute’s oval, and multivalued attributes are shown as double-lined ovals.</p>

<figure class="width-50"><div id="FIG-DESIGN-CUSTOMER" class="figure">
<img src="Images/lm2e_0202.png" alt="lm2e 0202" width="846" height="1176"/>
<h6><span class="label">Figure 2-2. </span>The ER diagram representation of the customer entity</h6>
</div></figure>

<p>Attribute values are chosen from a domain of legal values. For example, we could specify that a customer’s given names and surname attributes can each be a string of up to 100 characters, while a telephone number can be a string of up to 40 characters. Similarly, a product price could be a positive rational number.</p>

<p>Attributes can be empty; for example, some customers may not provide their telephone numbers. However, the primary key of an entity (including the components of a multiattribute primary key) must never be unknown (technically, it must be <code>NOT NULL</code>). So, if it’s possible for a customer to not provide an email address, we cannot use the email address as the key.</p>

<p>You should think carefully when classifying an attribute as multivalued: are all the values equivalent, or do they in fact represent different things? For example, when listing multiple telephone numbers for a customer, would they be more usefully labeled separately as the customer’s business phone number, home phone number, cell phone number, and so on?</p>

<p>Let’s look at another example. The sales database requirements may specify that a product has a name and a price. We can see that the product is an entity because it’s a distinct object. However, the product’s name and price aren’t distinct objects; they’re attributes that describe the product entity. Note that if we want to have different prices for different markets, then the price is no longer just related to the product entity, and we will need to model it differently.</p>

<p>For some applications, no combination of attributes can uniquely identify an entity (or it would be too unwieldy to use a large composite key), so we create an artificial attribute that’s defined to be unique and can therefore be used as a key: student numbers, Social Security numbers, driver’s license numbers, and library card numbers are examples of unique attributes created for various applications. In our inventory and sales application, it’s possible that we could stock different products with the same name and price. For example, we could sell two models of “Four-Port USB 2.0 Hub,” both at $4.95 each. To distinguish between products, we can assign a unique product ID number to each item we stock; this would be the primary key. Each product entity would have name, price, and product ID attributes. This is shown in the ER diagram in<a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="entities" id="idm46177499180024"/><a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="attributes" id="idm46177499178776"/><a data-type="indexterm" data-primary="attributes" data-secondary="entities" data-tertiary="ER diagrams" id="idm46177499177560"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="entities" id="idm46177499176344"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="attributes" id="idm46177499175160"/><a data-type="indexterm" data-startref="ch02-atet" id="idm46177499173928"/><a data-type="indexterm" data-startref="ch02-atet2" id="idm46177499173256"/><a data-type="indexterm" data-startref="ch02-atet3" id="idm46177499172584"/><a data-type="indexterm" data-startref="ch02-pk" id="idm46177499171912"/><a data-type="indexterm" data-startref="ch02-pk2" id="idm46177499171240"/><a data-type="indexterm" data-startref="ch02-pk3" id="idm46177499170568"/><a data-type="indexterm" data-startref="ch02-pk4" id="idm46177499169896"/><a data-type="indexterm" data-startref="ch02-pk5" id="idm46177499169224"/> <a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_PRODUCT">Figure 2-3</a>.</p>

<figure class="width-50"><div id="BAS-FIG-ER_TUTORIAL_PRODUCT" class="figure">
<img src="Images/lm2e_0203.png" alt="lm2e 0203" width="846" height="385"/>
<h6><span class="label">Figure 2-3. </span>The ER diagram representation of the product entity</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Representing Relationships"><div class="sect2" id="idm46177499230360">
<h2>Representing Relationships</h2>

<p>Entities can participate in relationships with other entities.<a data-type="indexterm" data-primary="database design" data-secondary="relationships" data-tertiary="about" id="idm46177499163928"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="relationships" data-tertiary="about" id="idm46177499162600"/><a data-type="indexterm" data-primary="relationships" data-secondary="about" id="idm46177499161368"/> For example, a customer can buy a product, a student can take a course, an employee can have an address, and so on.</p>

<p>Like entities, relationships can have<a data-type="indexterm" data-primary="relationships" data-secondary="attributes" id="idm46177499159784"/><a data-type="indexterm" data-primary="attributes" data-secondary="relationships" id="idm46177499158808"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="relationships" data-tertiary="attributes" id="idm46177499157864"/><a data-type="indexterm" data-primary="database design" data-secondary="relationships" data-tertiary="attributes" id="idm46177499156584"/> attributes: we can define a sale to be a relationship between a customer entity (identified by the unique email address) and a given number of the product entity (identified by the unique product ID) that exists at a particular date and time (the timestamp).</p>

<p>Our database could then record each sale and tell us, for example, that at 3:13 p.m. on Wednesday, March 22, Marcos Albe bought one “Raspberry Pi 4,” one “500 GB SSD M.2 NVMe,” and two sets of “2000 Watt 5.1 Channel Sub-Woofer Speakers.”</p>

<p>Different numbers of entities can appear on each side of a relationship. For example, each customer can buy any number of products, and each product can be bought by any number of customers. <a data-type="indexterm" data-primary="relationships" data-secondary="many-to-many relationships" id="idm46177499153352"/><a data-type="indexterm" data-primary="many-to-many relationships" id="idm46177499152360"/>This is known as a <em>many-to-many</em> relationship. <a data-type="indexterm" data-primary="relationships" data-secondary="one-to-many relationships" id="idm46177499151128"/><a data-type="indexterm" data-primary="one-to-many relationships" id="idm46177499150104"/><a data-type="indexterm" data-primary="many-to-one relationships" id="idm46177499149416"/>We can also have <em>one-to-many</em> relationships. For example, one person can have several credit cards, but each credit card belongs to just one person. Looking at it the other way, a <em>one-to-many</em> relationship becomes a <em>many-to-one</em> relationship; for example, many credit cards belong to a single person. <a data-type="indexterm" data-primary="relationships" data-secondary="one-to-one relationships" id="idm46177499147192"/><a data-type="indexterm" data-primary="one-to-one relationships" id="idm46177499146152"/>Finally, the serial number on a car engine is an example of a <em>one-to-one</em> relationship; each engine has just one serial number, and each serial number belongs to just one engine. We use the shorthand terms <em>1:1</em>, <em>1:N</em>, and <em>M:N</em> for one-to-one, one-to-many, and many-to-many relationships.</p>

<p>The number of entities on either side of a relationship<a data-type="indexterm" data-primary="database design" data-secondary="relationships" data-tertiary="cardinality" id="idm46177499142984"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="relationships" data-tertiary="cardinality" id="idm46177499141736"/><a data-type="indexterm" data-primary="relationships" data-secondary="cardinality" id="idm46177499140552"/><a data-type="indexterm" data-primary="cardinality" data-secondary="relationships" id="idm46177499139608"/><a data-type="indexterm" data-primary="database design" data-secondary="relationships" data-tertiary="key constraints" id="idm46177499138664"/><a data-type="indexterm" data-primary="relationships" data-secondary="key constraints" id="idm46177499137448"/><a data-type="indexterm" data-primary="keys" data-secondary="key constraints of a relationship" id="idm46177499136504"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="relationships" data-tertiary="key constraints" id="idm46177499135592"/><a data-type="indexterm" data-primary="constraints" data-secondary="foreign key constraints" data-see="foreign key constraints" id="idm46177499134360"/><a data-type="indexterm" data-primary="foreign key constraints" data-secondary="relationships" id="idm46177499133144"/> (the <em>cardinality</em> of the relationship) define the <em>key constraints</em> of the relationship. It’s important to think about the cardinality of relationships carefully. There are many relationships that may at first seem to be one-to-one, but turn out to be more complex. For example, people sometimes change their names; in some applications, such as police databases, this is of particular interest, and so it may be necessary to model a many-to-many relationship between a person entity and a name entity. Redesigning a database can be costly and time-consuming if you assume a relationship is simpler than it really is.</p>

<p>In an ER diagram, we represent a relationship set <a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="relationship sets" id="idm46177499130312"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="relationship sets" id="idm46177499129064"/><a data-type="indexterm" data-primary="relationships" data-secondary="ER diagrams" id="idm46177499127832"/><a data-type="indexterm" data-primary="cardinality" data-secondary="relationships" data-tertiary="ER diagrams" id="idm46177499126888"/>with a named diamond. The cardinality of the relationship is often indicated alongside the relationship diamond; this is the style we use in this book. (Another common style is to have an arrowhead on the line connecting the entity on the “1” side to the relationship diamond.) <a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_BOUGHT">Figure 2-4</a> shows the relationship between the customer and product entities, along with the number and timestamp attributes of the sale relationship.</p>

<figure><div id="BAS-FIG-ER_TUTORIAL_BOUGHT" class="figure">
<img src="Images/lm2e_0204.png" alt="lm2e 0204" width="1438" height="1054"/>
<h6><span class="label">Figure 2-4. </span>The ER diagram representation of the customer and product entities, and the sale relationship between them</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Partial and Total Participation"><div class="sect2" id="SEC-PartialTotalParticipation">
<h2>Partial and Total Participation</h2>

<p>Relationships between entities can be<a data-type="indexterm" data-primary="partial participation" id="idm46177499120296"/><a data-type="indexterm" data-primary="total participation" id="idm46177499119592"/> optional or compulsory. In our example, we could decide that a person is considered to be a customer only if they have bought a product. On the other hand, we could say that a customer is a person whom we know about and whom we hope might buy something—that is, we can have people listed as customers in our database who never buy a product. In the first case, the customer entity has <em>total participation</em> in the bought relationship (all customer have bought a product, and we can’t have a customer who hasn’t bought a product), while in the second case it has <em>partial participation</em> (a customer can buy a product). <a data-type="indexterm" data-primary="database design" data-secondary="relationships" data-tertiary="participation constraints" id="idm46177499117368"/><a data-type="indexterm" data-primary="constraints" data-secondary="participation constraints" id="idm46177499116056"/><a data-type="indexterm" data-primary="participation constraints" id="idm46177499115096"/><a data-type="indexterm" data-primary="relationships" data-secondary="participation constraints" id="idm46177499114408"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="relationships" data-tertiary="participation constraints" id="idm46177499113448"/>These are referred to as the <em>participation constraints</em> of the relationship. In an ER diagram, we indicate total participation with a double line between the entity box and the relationship diamond.</p>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Entity or Attribute?"><div class="sect2" id="idm46177499111352">
<h2>Entity or Attribute?</h2>

<p>From time to time, we encounter cases where we wonder<a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="attributes of entities" data-tertiary="entity or attribute" id="idm46177499109528"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="entity or attribute" id="idm46177499108264"/><a data-type="indexterm" data-primary="attributes" data-secondary="entities" data-tertiary="entity or attribute" id="idm46177499107304"/><a data-type="indexterm" data-primary="database design" data-secondary="entities" data-tertiary="entity or attribute" id="idm46177499106088"/> whether an item should be an attribute or an entity on its own. For example, an email address could be modeled as an entity in its own right. When in doubt, consider these rules of thumb:</p>
<dl>
<dt><em>Is the item of direct interest to the database?</em></dt>
<dd>
<p>Objects of direct interest should be entities, and information that describes them should be stored in attributes. Our inventory and sales database is really interested in customers, not their email addresses, so the email address would be best modeled as an attribute of the customer entity.</p>
</dd>
<dt><em>Does the item have components of its own?</em></dt>
<dd>
<p>If so, we must find a way of representing these components; a separate entity might be the best solution. In the student grades example at the start of the chapter, we stored the course name, year, and semester for each course that a student takes. It would be more compact to treat the course as a separate entity and to create a class ID number to identify each time a course is offered to students (the “offering”).</p>
</dd>
<dt><em>Can the object have multiple instances?</em></dt>
<dd>
<p>If so, we must find a way to store data on each instance. The cleanest way to do this is to represent the object as a separate entity. In our sales example, we must ask whether customers are allowed to have more than one email address; if they are, we should model the email address as a separate entity.</p>
</dd>
<dt><em>Is the object often nonexistent or unknown?</em></dt>
<dd>
<p>If so, it is effectively an attribute of only some of the entities, and it would be better to model it as a separate entity rather than as an attribute that is often empty. Consider a simple example: to store student grades for different courses, we could have an attribute for the student’s grade in every possible course, as shown in <a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_STUDENT_COURSE_ATTRIBUTES">Figure 2-5</a>. But because most students will have grades for only a few of these courses, it’s better to represent the grades as a separate entity set, as in <a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_STUDENT_COURSE_ENTITY">Figure 2-6</a>.</p>
</dd>
</dl>

<figure><div id="BAS-FIG-ER_TUTORIAL_STUDENT_COURSE_ATTRIBUTES" class="figure">
<img src="Images/lm2e_0205.png" alt="lm2e 0205" width="682" height="1307"/>
<h6><span class="label">Figure 2-5. </span>The ER diagram representation of student grades as attributes of the student entity</h6>
</div></figure>

<figure><div id="BAS-FIG-ER_TUTORIAL_STUDENT_COURSE_ENTITY" class="figure">
<img src="Images/lm2e_0206.png" alt="lm2e 0206" width="848" height="1012"/>
<h6><span class="label">Figure 2-6. </span>The ER diagram representation of student grades as a separate entity</h6>
</div></figure>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Entity or Relationship?"><div class="sect2" id="idm46177499090744">
<h2>Entity or Relationship?</h2>

<p>An easy way to decide whether an object <a data-type="indexterm" data-primary="database design" data-secondary="entities" data-tertiary="entity or relationship" id="idm46177499089336"/><a data-type="indexterm" data-primary="database design" data-secondary="relationships" data-tertiary="entity or relationship" id="idm46177499088088"/><a data-type="indexterm" data-primary="relationships" data-secondary="entity or relationship" id="idm46177499086872"/>should be an entity or a relationship is to map nouns in the requirements to entities, and map verbs to relationships. For example, in the statement “A degree program is made up of one or more courses,” we can identify the entities “program” and “course,” and the relationship “is made up of.” Similarly, in the statement “A student enrolls in one program,” we can identify the entities “student” and “program,” and the relationship “enrolls in.” Of course, we can choose different terms for entities and relationships than those that appear in the relationships, but it’s a good idea not to deviate too far from the naming conventions used in the requirements so that the design can be checked against the requirements. All else being equal, try to keep the design simple, and avoid introducing trivial entities where possible. That is, there’s no need to have a separate entity for the student’s enrollment when we can model it as a relationship between the existing student and program entities.</p>
</div></section>













<section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Intermediate Entities"><div class="sect2" id="SEC-ER-INTERMEDIATE">
<h2>Intermediate Entities</h2>

<p>It is often possible to conceptually simplify a <a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="intermediate (associate) entities" id="idm46177499082008"/><a data-type="indexterm" data-primary="many-to-many relationships" data-secondary="intermediate (associate) entities" id="idm46177499081048"/><a data-type="indexterm" data-primary="relationships" data-secondary="many-to-many relationships" data-tertiary="intermediate (associate) entities" id="idm46177499080072"/><a data-type="indexterm" data-primary="one-to-many relationships" data-secondary="intermediate (associate) entities" id="idm46177499078824"/><a data-type="indexterm" data-primary="relationships" data-secondary="one-to-many relationships" data-tertiary="intermediate (associate) entities" id="idm46177499077848"/><a data-type="indexterm" data-primary="intermediate entities" id="idm46177499076600"/><a data-type="indexterm" data-primary="associate entities" data-see="intermediate entities" id="idm46177499075928"/>many-to-many relationship by replacing it with a new <em>intermediate</em> entity (sometimes called an <em>associate</em> entity) and connecting the original entities through a many-to-one and a one-to-many relationship.</p>

<p>Consider this statement: “A passenger can book a seat on a flight.” This is a many-to-many relationship between the entities “passenger” and “flight.” The related ER diagram fragment is shown in <a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_BOOKING">Figure 2-7</a>.</p>

<figure><div id="BAS-FIG-ER_TUTORIAL_BOOKING" class="figure">
<img src="Images/lm2e_0207.png" alt="lm2e 0207" width="852" height="122"/>
<h6><span class="label">Figure 2-7. </span>A passenger participates in an M:N relationship with a flight</h6>
</div></figure>

<p>However, let’s look at this from both sides of the relationship:</p>

<ul>
<li>
<p>Any given flight can have many passengers with a booking.</p>
</li>
<li>
<p>Any given passenger can have bookings on many flights.</p>
</li>
</ul>

<p>Hence, we can consider the many-to-many relationship to be in fact two one-to-many relationships, one each way. This points us to the existence of a hidden intermediate entity, the booking, between the flight and passenger entities. The requirement could be better worded as: “A passenger can make a booking for a seat on a flight.” The updated ER diagram fragment is shown in <a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_INTERMEDIATE">Figure 2-8</a>.</p>

<figure><div id="BAS-FIG-ER_TUTORIAL_INTERMEDIATE" class="figure">
<img src="Images/lm2e_0208.png" alt="lm2e 0208" width="852" height="606"/>
<h6><span class="label">Figure 2-8. </span>The intermediate booking entity between the passenger and flight entities</h6>
</div></figure>

<p class="pagebreak-before">Each passenger can be involved in multiple bookings, but each booking belongs to a single passenger, so the cardinality of this relationship is 1:N. Similarly, there can be many bookings for a given flight, but each booking is for a single flight, so this relationship also has cardinality 1:N. Since each booking must be associated with a particular passenger and flight, the booking entity participates totally in the relationships with these entities (as described in <a data-type="xref" href="#SEC-PartialTotalParticipation">“Partial and Total Participation”</a> on page 77). This total participation could not be captured effectively in the representation in <a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_BOOKING">Figure 2-7</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Weak and Strong Entities"><div class="sect2" id="idm46177499084056">
<h2>Weak and Strong Entities</h2>

<p>Context is very important in our daily interactions; if we know the context, <a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="weak entities" id="idm46177499059320"/><a data-type="indexterm" data-primary="weak entities" id="idm46177499058376"/><a data-type="indexterm" data-primary="relationships" data-secondary="identifying relationships" id="idm46177499057704"/><a data-type="indexterm" data-primary="identifying relationships" id="idm46177499056744"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="relationships" data-tertiary="identifying relationships" id="idm46177499056056"/><a data-type="indexterm" data-primary="database design" data-secondary="entities" data-tertiary="weak or strong" id="idm46177499054808"/>we can work with a much smaller amount of information. For example, we generally call family members by only their first name or nickname. Where ambiguity exists, we add further information such as the surname to clarify our intent. In database design, we can omit some key information for entities that are dependent on other entities. For example, if we wanted to store the names of our customers’ children, we could create a child entity and store only enough key information to identify it in the context of its parent. We could simply list a child’s first name on the assumption that a customer will never have several children with the same first name. Here, the child entity is a <em>weak</em> entity, and its relationship with the customer entity is called an <em>identifying relationship</em>. Weak entities participate totally in the identifying relationship, since they can’t exist in the database independently of their owning entity.</p>

<p>In the ER diagram, we show weak entities and<a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="identifying relationships" id="idm46177499051240"/><a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="weak entities" id="idm46177499050024"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="weak entities" id="idm46177499048808"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="identifying relationships" id="idm46177499047576"/><a data-type="indexterm" data-primary="identifying relationships" data-secondary="ER diagrams" id="idm46177499046328"/><a data-type="indexterm" data-primary="weak entities" data-secondary="ER diagrams" id="idm46177499045368"/> identifying relationships with double lines and the partial key of a weak entity with a dashed underline, as in <a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_WEAK">Figure 2-9</a>. <a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="strong entities" id="idm46177499043352"/><a data-type="indexterm" data-primary="strong entities" id="idm46177499042360"/>A weak entity is uniquely identified in the context of its owning (or <em>strong</em>) entity, and so the full key for a weak entity is the combination of its own (partial) key with the key of its owning entity. To uniquely identify a child in our example, we need the first name of the child and the email address of the child’s parent.</p>

<p><a data-type="xref" href="#BAS-FIG-ER_TUTORIAL_LEGEND">Figure 2-10</a> shows a summary of the symbols we’ve explained for ER diagrams.</p>

<figure><div id="BAS-FIG-ER_TUTORIAL_WEAK" class="figure">
<img src="Images/lm2e_0209.png" alt="lm2e 0209" width="1438" height="1052"/>
<h6><span class="label">Figure 2-9. </span>The ER diagram representation of a weak entity</h6>
</div></figure>

<figure><div id="BAS-FIG-ER_TUTORIAL_LEGEND" class="figure">
<img src="Images/lm2e_0210.png" alt="lm2e 0210" width="1439" height="711"/>
<h6><span class="label">Figure 2-10. </span>A summary of the ER diagram symbols</h6>
</div></figure>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Database Normalization"><div class="sect1" id="BAS-NORMALIZATION">
<h1>Database Normalization</h1>

<p>Database normalization is an important concept when designing the <a data-type="indexterm" data-primary="database design" data-secondary="database normalization" id="idm46177499033816"/><a data-type="indexterm" data-primary="normalization of database" id="idm46177499032760"/><a data-type="indexterm" data-primary="Codd, Edgar F." id="idm46177499032120"/><a data-type="indexterm" data-primary="relational databases" data-secondary="normalization" id="idm46177499031448"/>relational data structure. Dr. Edgar F. Codd, the inventor of the relational database model, proposed the normal forms in the early ’70s, and these are still widely used by the industry nowadays. Even with the advent of the NoSQL databases, there is no evidence in the short or medium term that relational databases will disappear or that the normal forms will fall into disuse.</p>

<p>The main objective of the normal forms is to reduce data redundancy and improve data integrity. Normalization also facilitates the process of redesigning and extending the database structure.</p>

<p>Officially, there are six normal forms, but most database architects deal only with the first three forms. That is because the normalization process is progressive, and we cannot achieve a higher level of database normalization unless the previous levels have been satisfied. Using all six norms constricts the database model too much, however, and in general, they become very complex to implement.</p>

<p>In real workloads, usually there are performance issues.<a data-type="indexterm" data-primary="normalization of database" data-secondary="denormalizing for performance" id="idm46177499028136"/><a data-type="indexterm" data-primary="performance" data-secondary="denormalizing data for" id="idm46177499027048"/><a data-type="indexterm" data-primary="extract, transform, load (ETL) jobs" id="idm46177499026104"/><a data-type="indexterm" data-primary="database design" data-secondary="normalization of database" data-tertiary="denormalizing for performance" id="idm46177499025416"/> This is one reason for extract, transform, load (<em>ETL</em>) jobs to exist: they denormalize the data to process it.</p>

<p>Let’s take a look at the first three normal forms:</p>
<dl>
<dt>The first<a data-type="indexterm" data-primary="attributes" data-secondary="normalization of databases" id="idm46177499022360"/> normal form (<em>1NF</em>) has the following goals</dt>
<dd>
<div class="openblock">
<ul>
<li>
<p>Eliminate repeating groups in individual tables.</p>
</li>
<li>
<p>Create a separate table for each set of related data.</p>
</li>
<li>
<p>Identify each set of related data with a primary key.</p>
</li>
</ul>

<p>If a relation contains composite or multivalued attributes, it violates the first normal form. Conversely, a relation is in first normal form if it does not contain any composite or multivalued attributes. So, a relation is in first normal form if every attribute in that relation has a single value of the appropriate type.</p>
</div>

</dd>
</dl>
<dl>
<dt>The goals of second normal form<a data-type="indexterm" data-primary="primary key" data-secondary="normalization of databases" id="idm46177499014728"/> (<em>2NF</em>) are</dt>
<dd>
<div class="openblock">
<ul>
<li>
<p>Create separate tables for sets of values that apply to multiple records.</p>
</li>
<li>
<p>Relate these tables with a foreign key.</p>
</li>
</ul>

<p>Records should not depend on anything other than a table’s primary key (a compound key, if necessary).</p>
</div>

</dd>
<dt>Third normal form (<em>3NF</em>) adds one more goal</dt>
<dd>
<div class="openblock">
<ul>
<li>
<p>Eliminate fields that do not depend on the key.</p>
</li>
</ul>

<p>Values in a record that are not part of that record’s key do not belong in the table. In general, any time the contents of a group of fields may apply to more than a single record in the table, you should consider placing those fields in a separate table.</p>
</div>

</dd>
</dl>

<p>Table 2-1 lists the normal forms, from the least normalized to the most normalized. <a data-type="indexterm" data-primary="database design" data-secondary="normalization of database" data-tertiary="unnormalized form" id="idm46177499004552"/><a data-type="indexterm" data-primary="unnormalized form of database" id="idm46177499003240"/><a data-type="indexterm" data-primary="normalization of database" data-secondary="unnormalized form" id="idm46177499002552"/>The unnormalized form (UNF) is a database model that does not meet any of the database normalization conditions. Other normalization forms exist, but they are beyond the scope of this discussion.</p>
<table>
<caption><span class="label">Table 2-1. </span>The normal forms (from least to most normalized)</caption>
<thead>
<tr>
<th/>
<th>UNF (1970)</th>
<th>1NF (1970)</th>
<th>2NF (1971)</th>
<th>3NF (1971)</th>
<th>4NF (1977)</th>
<th>5NF (1979)</th>
<th>6NF (2003)</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Primary key (no duplicate tuples)</p></td>
<td><p>Maybe</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr>
<td><p>No repeating groups</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr>
<td><p>Atomic columns (cells have single value)</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr>
<td><p>Every nontrivial functional dependency either does not begin with a proper subset of a candidate key or ends with a prime attribute (no partial functional dependencies of nonprime attributes on candidate keys)</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr>
<td><p>Every nontrivial functional dependency begins with a superkey or ends with a prime attribute (no transitive functional dependencies of nonprime attributes on candidate keys)</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
</tr>
<tr>
<td><p>Every nontrivial functional dependency either begins with a superkey or ends with an elementary prime attribute</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p>Every nontrivial functional dependency begins with a superkey</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p>Every nontrivial multivalued dependency begins with a superkey</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>Yes</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p>Every join dependency has a superkey component</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p>Every join dependency has only superkey components</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p>Every constraint is a consequence of domain constraints and key constraints</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>N/A</p></td>
</tr>
<tr>
<td><p>Every join dependency is trivial</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>No</p></td>
<td><p>Yes</p></td>
</tr>
</tbody>
</table>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Normalizing an Example Table"><div class="sect1" id="BAS-NORMALIZATION_EXAMPLE">
<h1>Normalizing an Example Table</h1>

<p>To make these concepts clearer let’s walk through an example of normalizing a fictional student table.<a data-type="indexterm" data-primary="normalization of database" data-secondary="example of normalizing" id="ch02-norm"/><a data-type="indexterm" data-primary="database design" data-secondary="normalization of database" data-tertiary="example of normalizing" id="ch02-norm2"/></p>

<p>We’ll start with the unnormalized table:</p>

<pre data-type="programlisting">Student#   Advisor   Adv-Room   Class1   Class2   Class3
1022       Jones     412        101-07   143-01   159-02
4123       Smith     216        201-01   211-02   214-01</pre>








<section data-type="sect2" data-pdf-bookmark="First Normal Form: No Repeating Groups"><div class="sect2" id="idm46177498926664">
<h2>First Normal Form: No Repeating Groups</h2>

<p>Tables should have only a single field for each attribute.<a data-type="indexterm" data-primary="attributes" data-secondary="normalization of databases" id="idm46177498925368"/> Since one student has several classes, these classes should be listed in a separate table. The fields <code>Class1</code>, <code>Class2</code>, and <code>Class3</code> in our unnormalized table are indications of design trouble.</p>

<p>Spreadsheets often have multiple fields for the same attribute (e.g., <code>address1</code>, <code>address2</code>, <code>address3</code>), but tables should not. Here’s another way to look at this problem: <a data-type="indexterm" data-primary="one-to-many relationships" data-secondary="normalization of table" id="idm46177498920696"/><a data-type="indexterm" data-primary="relationships" data-secondary="one-to-many relationships" data-tertiary="normalization of table" id="idm46177498919752"/>with a one-to-many relationship, don’t put the one side and the many side in the same table. Instead, create another table in first normal form by eliminating the repeating group—for example, with <code>Class#</code>, as shown here:</p>

<pre data-type="programlisting">Student#   Advisor   Adv-Room   Class#
1022       Jones     412        101-07
1022       Jones     412        143-01
1022       Jones     412        159-02
4123       Smith     216        201-01
4123       Smith     216        211-02
4123       Smith     216        214-01</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Second Normal Form: Eliminate Redundant Data"><div class="sect2" id="idm46177498916648">
<h2>Second Normal Form: Eliminate Redundant Data</h2>

<p>Note the multiple <code>Class#</code> values for each <code>Student#</code> value in the previous table. <code>Class#</code> is not functionally dependent on<a data-type="indexterm" data-primary="primary key" data-secondary="normalization of databases" id="idm46177498913576"/> <code>Student#</code> (the primary key), so this relationship is not in second normal form.</p>

<p>The following two tables demonstrate the conversion to second normal form. We now have a <code>Students</code> table:</p>

<pre data-type="programlisting">Student#    Advisor   Adv-Room
1022        Jones     412
4123        Smith     216</pre>

<p>and a <code>Registration</code> table:</p>

<pre data-type="programlisting">Student#  Class#
1022      101-07
1022      143-01
1022      159-02
4123      201-01
4123      211-02
4123      214-01</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Third Normal Form: Eliminate Data Not Dependent on Key"><div class="sect2" id="idm46177498908584">
<h2>Third Normal Form: Eliminate Data Not Dependent on Key</h2>

<p>In the previous example, <code>Adv-Room</code> (the advisor’s office number) is functionally dependent on the <code>Advisor</code> attribute. The solution is to move that attribute from the <code>Students</code> table to a <code>Faculty</code> table, as shown next.</p>

<p>The <code>Students</code> table now looks like this:</p>

<pre data-type="programlisting">Student#  Advisor
1022      Jones
4123      Smith</pre>

<p>And here’s the <code>Faculty</code> table:<a data-type="indexterm" data-startref="ch02-norm" id="idm46177498902680"/><a data-type="indexterm" data-startref="ch02-norm2" id="idm46177498901944"/></p>

<pre data-type="programlisting">Name  Room  Dept
Jones 412 42
Smith 216 42</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Entity Relationship Modeling Examples"><div class="sect1" id="BAS-SEC-MODELING-EXAMPLES">
<h1>Entity Relationship Modeling Examples</h1>

<p>In the previous sections, we walked though hypothetical examples<a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="examples of databases" id="ch02-erex"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" data-tertiary="examples of ER model" id="ch02-erex2"/><a data-type="indexterm" data-primary="database design" data-secondary="examples of Entity Relationship model" id="ch02-erex3"/><a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="examples of database design" id="ch02-erex6"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="examples of database design" id="ch02-erex4"/><a data-type="indexterm" data-primary="normalization of database" data-secondary="example of normalizing" data-tertiary="examples of database design" id="ch02-erex5"/> to help you understand the basics of database design, ER diagrams, and normalization. Now we’re going to look at some ER examples from sample databases available for MySQL. To visualize the ER diagrams, we are going to use <a href="https://oreil.ly/1971c"><em>MySQL Workbench</em></a>.</p>

<p>MySQL Workbench uses a physical ER representation. Physical ER diagram models are more granular, showing the processes necessary to add information to a database. Rather than using symbols, we use tables in the ER diagram, making it closer to the real database. <a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="enhanced ER diagrams" id="ch02-eer3"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="enhanced ER diagrams" id="ch02-eer"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="enhanced ER diagrams" id="ch02-eer2"/>MySQL Workbench goes one step further and uses <em>enhanced entity-relationship (EER) diagrams</em>. EER diagrams are an expanded version of ER diagrams.</p>

<p>We won’t go into all the details, but the main advantage of an EER diagram is that it provides all the elements of an ER diagram while adding support for:</p>

<ul>
<li>
<p>Attribute and relationship inheritance</p>
</li>
<li>
<p>Category or union types</p>
</li>
<li>
<p>Specialization and generalization</p>
</li>
<li>
<p>Subclasses and superclasses</p>
</li>
</ul>

<p>Let’s start with the process to download the sample databases and visualize their EER diagrams in MySQL Workbench.</p>

<p>The first one we’ll use is the <code>sakila</code> database. <a data-type="indexterm" data-primary="sakila example database" data-secondary="about" id="idm46177498876584"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" data-tertiary="DVD rental store" id="idm46177498875576"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="examples of databases" data-tertiary="DVD rental store" id="idm46177498874296"/><a data-type="indexterm" data-primary="DVD rental store example database" data-see="sakila example database" id="idm46177498873064"/><a data-type="indexterm" data-primary="database design" data-secondary="examples of Entity Relationship model" data-tertiary="DVD rental store" id="idm46177498872104"/>Development of this database began in 2005. Early designs were based on the database used in the Dell whitepaper <a href="https://oreil.ly/aDDlO">“Three Approaches to MySQL Applications on Dell PowerEdge Servers”</a>, which was designed to represent an online DVD store. Similarly, the <code>sakila</code> sample database is designed to represent a DVD rental store, and it borrows film and actor names from the Dell sample database. You can use the following commands to import the <code>sakila</code> database to your MySQL instance:<a data-type="indexterm" data-primary="sakila example database" data-secondary="importing" id="idm46177498868808"/></p>

<pre data-type="programlisting"># <strong>wget https://downloads.mysql.com/docs/sakila-db.tar.gz</strong>
# <strong>tar -xvf sakila-db.tar.gz</strong>
# <strong>mysql -uroot -pmsandbox &lt; sakila-db/sakila-schema.sql</strong>
# <strong>mysql -uroot -pmsandbox &lt; sakila-db/sakila-data.sql</strong></pre>

<p><code>sakila</code> also provides the EER model, in the <em>sakila.mwb</em> file.<a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="enhanced ER diagram for sakila" id="idm46177498864408"/><a data-type="indexterm" data-primary="sakila example database" data-secondary="EER model" id="idm46177498863064"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="enhanced ER diagram for sakila" id="idm46177498862120"/> You can open the file with MySQL Workbench, as shown in <a data-type="xref" href="#FIG-SAKILA-ER">Figure 2-11</a>.</p>

<figure><div id="FIG-SAKILA-ER" class="figure">
<img src="Images/lm2e_0211.png" alt="lm2e 0211" width="1556" height="1290"/>
<h6><span class="label">Figure 2-11. </span>The <code>sakila</code> database EER model; note the physical representation of the entities instead of using symbols</h6>
</div></figure>

<p class="pagebreak-before">Next is the <code>world</code> database, which uses sample data from <a href="https://oreil.ly/0Y9tZ">Statistics Finland</a>.<a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" data-tertiary="world database" id="idm46177498855512"/><a data-type="indexterm" data-primary="database design" data-secondary="examples of Entity Relationship model" data-tertiary="world database" id="idm46177498854168"/><a data-type="indexterm" data-primary="world example database" id="idm46177498852936"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="examples of databases" data-tertiary="world database" id="idm46177498852264"/></p>

<p>The following commands will import the <code>world</code> database to your MySQL instance:</p>

<pre data-type="programlisting"># <strong>wget https://downloads.mysql.com/docs/world-db.tar.gz</strong>
# <strong>tar -xvf world-db.tar.gz</strong>
# <strong>mysql -uroot -plearning_mysql &lt; world-db/world.sql</strong></pre>

<p>The <code>world</code> database does not come with<a data-type="indexterm" data-primary="world example database" data-secondary="creating EER diagram" id="idm46177498847112"/><a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="enhanced ER diagrams created" id="idm46177498846136"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="enhanced ER diagrams created" id="idm46177498844856"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="enhanced ER diagrams" data-tertiary="creating" id="idm46177498843608"/> an EER file as <code>sakila</code> does, but you can create the EER model from the database using MySQL Workbench. To do this, select Reverse Engineer from the Database menu, as in <a data-type="xref" href="#FIG-WOKBENCH-REVERSE">Figure 2-12</a>.</p>

<figure><div id="FIG-WOKBENCH-REVERSE" class="figure">
<img src="Images/lm2e_0212.png" alt="lm2e 0212" width="1454" height="756"/>
<h6><span class="label">Figure 2-12. </span>Reverse engineering from the <code>world</code> database</h6>
</div></figure>

<p>Workbench will connect to the database (if not connected already) and prompt you to choose the schema you want to reverse engineer, as shown in <a data-type="xref" href="#FIG-WORKBENCH-CHOOSE">Figure 2-13</a>.</p>

<p>Click Continue, and then click Execute on the next screen, shown in <a data-type="xref" href="#FIG-WORKBENCH-FORWARDENG">Figure 2-14</a>.</p>

<figure><div id="FIG-WORKBENCH-CHOOSE" class="figure">
<img src="Images/lm2e_0213.png" alt="lm2e 0213" width="1782" height="1114"/>
<h6><span class="label">Figure 2-13. </span>Choosing the schema</h6>
</div></figure>

<figure><div id="FIG-WORKBENCH-FORWARDENG" class="figure">
<img src="Images/lm2e_0214.png" alt="lm2e 0214" width="1780" height="1226"/>
<h6><span class="label">Figure 2-14. </span>Click <em>Execute</em> to start the reverse-engineering process</h6>
</div></figure>

<p>This produces the ER model for the <code>world</code> database, shown in <a data-type="xref" href="#FIG-WORLD-ER">Figure 2-15</a>.</p>

<figure><div id="FIG-WORLD-ER" class="figure">
<img src="Images/lm2e_0215.png" alt="lm2e 0215" width="819" height="1169"/>
<h6><span class="label">Figure 2-15. </span>The ER model for the <code>world</code> database</h6>
</div></figure>

<p>The last database you’ll import is the <code>employees</code> database.<a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" data-tertiary="employees database" id="idm46177498826280"/><a data-type="indexterm" data-primary="database design" data-secondary="examples of Entity Relationship model" data-tertiary="employees database" id="idm46177498824936"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="examples of databases" data-tertiary="employees database" id="idm46177498823704"/><a data-type="indexterm" data-primary="employees example database" data-secondary="about" id="idm46177498822472"/> Fusheng Wang and Carlo Zaniolo created the <a href="https://oreil.ly/1rvPc">original data</a> at Siemens Corporate Research. Giuseppe Maxia made the relational schema, and Patrick Crews exported the data in relational format.</p>

<p>To import the database, first you need to clone the Git repository:<a data-type="indexterm" data-primary="employees example database" data-secondary="importing" id="idm46177498820104"/></p>

<pre data-type="programlisting"># <strong>git clone https://github.com/datacharmer/test_db.git</strong>
# <strong>cd test_db</strong>
# <strong>cat employees.sql | mysql -uroot -psekret</strong></pre>

<p>Then you can use the reverse engineering procedure in MySQL Workbench again to create the ER model for the <code>employees</code> database, as shown in <a data-type="xref" href="#FIG-EMPLOYEE-ER">Figure 2-16</a>.</p>

<figure><div id="FIG-EMPLOYEE-ER" class="figure">
<img src="Images/lm2e_0216.png" alt="lm2e 0216" width="1400" height="1689"/>
<h6><span class="label">Figure 2-16. </span>The ER model for the <code>employees</code> database</h6>
</div></figure>

<p>It is important that you carefully review the ER models shown here so you understand the relationships between entities and their attributes. Once the concepts are solidified, start practicing. You will see how to do that in the next section. We’ll show you how to create a database on your MySQL server in<a data-type="indexterm" data-startref="ch02-erex" id="idm46177498811864"/><a data-type="indexterm" data-startref="ch02-erex2" id="idm46177498811160"/><a data-type="indexterm" data-startref="ch02-erex3" id="idm46177498810488"/><a data-type="indexterm" data-startref="ch02-erex4" id="idm46177498809816"/><a data-type="indexterm" data-startref="ch02-erex5" id="idm46177498809144"/><a data-type="indexterm" data-startref="ch02-erex6" id="idm46177498808472"/><a data-type="indexterm" data-startref="ch02-eer" id="idm46177498807800"/><a data-type="indexterm" data-startref="ch02-eer2" id="idm46177498807128"/><a data-type="indexterm" data-startref="ch02-eer3" id="idm46177498806456"/> <a data-type="xref" href="ch04.xhtml#CH4_MODIFY">Chapter 4</a>.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Using the Entity Relationship Model"><div class="sect1" id="CH-DESIGN-ER-MAPPING">
<h1>Using the Entity Relationship Model</h1>

<p>This section looks at the steps required to create an ER model<a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" id="ch02-cre"/><a data-type="indexterm" data-primary="database design" data-secondary="Entity Relationship model" id="ch02-cre2"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="creating a database" id="ch02-cre3"/><a data-type="indexterm" data-primary="CREATE DATABASE" data-secondary="Entity Relationship model" id="ch02-cre4"/> and deploy it into database tables. We saw previously that MySQL Workbench lets us reverse engineer an existing database. But how do we model a new database and deploy it? We can automate this process with the MySQL Workbench tool.</p>








<section data-type="sect2" data-pdf-bookmark="Mapping Entities and Relationships to Database Tables"><div class="sect2" id="idm46177498797928">
<h2>Mapping Entities and Relationships to Database Tables</h2>

<p>When converting an ER model to a database schema, we work through each entity and then through each relationship according to the rules discussed in the following sections to end up with a set of database tables.</p>










<section data-type="sect3" data-pdf-bookmark="Map the entities to database tables"><div class="sect3" id="idm46177498796312">
<h3>Map the entities to database tables</h3>

<p>For each strong entity, create a table comprising<a data-type="indexterm" data-primary="CREATE DATABASE" data-secondary="Entity Relationship model" data-tertiary="mapping entities to tables" id="idm46177498794952"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="creating a database" data-tertiary="mapping entities to tables" id="idm46177498793624"/><a data-type="indexterm" data-primary="database design" data-secondary="Entity Relationship model" data-tertiary="mapping entities to tables" id="idm46177498792376"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" data-tertiary="mapping entities to tables" id="idm46177498791128"/><a data-type="indexterm" data-primary="attributes" data-secondary="creating a database" data-tertiary="mapping entities to tables" id="idm46177498789880"/><a data-type="indexterm" data-primary="primary key" data-secondary="creating a database" data-tertiary="mapping entities to tables" id="idm46177498788648"/> its attributes and designate the primary key. The parts of any composite attributes are also included here.</p>

<p>For each weak entity, create a table comprising its attributes<a data-type="indexterm" data-primary="weak entities" data-secondary="mapping entities to tables" id="idm46177498786776"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="weak entities" data-tertiary="creating a database" id="idm46177498785704"/> and including the primary key of its owning entity. The owning entity’s primary key is a foreign key here because it’s a key not of this table but another table. The table’s primary key for the weak entity is the combination of the foreign key and the partial key of the weak entity. If the relationship with the owning entity has any attributes, add them to this table.</p>

<p>For each entity’s multivalued attribute, create a table comprising the entity’s primary key and the attribute.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Map the relationships to database tables"><div class="sect3" id="idm46177498783176">
<h3>Map the relationships to database tables</h3>

<p>Each one-to-one relationship between two entities includes <a data-type="indexterm" data-primary="CREATE DATABASE" data-secondary="Entity Relationship model" data-tertiary="mapping relationships to tables" id="idm46177498781640"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" data-tertiary="mapping relationships to tables" id="idm46177498780280"/><a data-type="indexterm" data-primary="database design" data-secondary="Entity Relationship model" data-tertiary="mapping relationships to tables" id="idm46177498779032"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="creating a database" data-tertiary="mapping relationships to tables" id="idm46177498777784"/><a data-type="indexterm" data-primary="relationships" data-secondary="mapping relationships to tables" id="idm46177498776536"/><a data-type="indexterm" data-primary="primary key" data-secondary="creating a database" data-tertiary="mapping relationships to tables" id="idm46177498775576"/><a data-type="indexterm" data-primary="one-to-one relationships" data-secondary="creating a database" id="idm46177498774344"/><a data-type="indexterm" data-primary="relationships" data-secondary="one-to-one relationships" data-tertiary="creating a database" id="idm46177498773384"/>the primary key of one entity as a foreign key in the table belonging to the other. If one entity participates totally in the relationship, place the foreign key in its table. If both participate totally in the relationship, consider merging them into a single table.</p>

<p>For each nonidentifying one-to-many relationship <a data-type="indexterm" data-primary="one-to-many relationships" data-secondary="creating a database" id="idm46177498771288"/><a data-type="indexterm" data-primary="relationships" data-secondary="one-to-many relationships" data-tertiary="creating a database" id="idm46177498770296"/><a data-type="indexterm" data-primary="attributes" data-secondary="creating a database" data-tertiary="mapping relationships to tables" id="idm46177498769064"/>between two entities, include the entity’s primary key on the “1” side as a foreign key in the table for the entity on the “N” side. Add any attributes of the relationship in the table alongside the foreign key. Note that identifying one-to-many relationships (between a weak entity and its owning entity) are captured as part of the entity-mapping stage.</p>

<p>For each many-to-many relationship between two entities, <a data-type="indexterm" data-primary="many-to-many relationships" data-secondary="creating a database" id="idm46177498766936"/><a data-type="indexterm" data-primary="relationships" data-secondary="many-to-many relationships" data-tertiary="creating a database" id="idm46177498765864"/>create a new table containing each entity’s primary key as the primary key and add any attributes of the relationship. This step helps to identify intermediate entities.</p>

<p>For each relationship involving more than two entities, create a table with the primary keys of all the participating entities, and add any relationship attributes.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating a Bank Database ER Model"><div class="sect2" id="CREATE-BANK">
<h2>Creating a Bank Database ER Model</h2>

<p>We’ve discussed database models for student grades and<a data-type="indexterm" data-primary="CREATE DATABASE" data-secondary="Entity Relationship model" data-tertiary="bank database" id="idm46177498761688"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" data-tertiary="bank database" id="idm46177498760344"/><a data-type="indexterm" data-primary="database design" data-secondary="Entity Relationship model" data-tertiary="bank database" id="idm46177498759112"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="creating a database" data-tertiary="bank database" id="idm46177498757880"/><a data-type="indexterm" data-primary="bank database created" id="idm46177498756648"/> customer information, plus the three open source EERs available for MySQL. Now let’s see how we could model a bank database. We’ve collected all the requisites from the stakeholders and defined our requirements for the online banking system, and we’ve decided we need to have the following entities:</p>

<ul>
<li>
<p>Employees</p>
</li>
<li>
<p>Branches</p>
</li>
<li>
<p>Customers</p>
</li>
<li>
<p>Accounts</p>
</li>
</ul>

<p>Now, following the mapping rules as just described, we are going to create the tables and attributes for each table. We established primary keys to ensure every table has a unique identifier column for its records. Next, we need to define the relationships between the tables.</p>










<section data-type="sect3" data-pdf-bookmark="Many to many relationships (N:M)"><div class="sect3" id="idm46177498750696">
<h3>Many to many relationships (N:M)</h3>

<p>We’ve established this type of relationship between branches<a data-type="indexterm" data-primary="intermediate entities" data-secondary="bank database" id="idm46177498749160"/><a data-type="indexterm" data-primary="many-to-many relationships" data-secondary="creating a database" data-tertiary="bank database" id="idm46177498748104"/><a data-type="indexterm" data-primary="relationships" data-secondary="many-to-many relationships" data-tertiary="bank database" id="idm46177498746824"/> and employees, and between accounts and customers. An employee can work for any number of branches, and a branch could have any number of employees. Similarly, a customer could have many accounts, and an account could be a joint account held by more than two customers.</p>

<p>To model these relationships, we need two more intermediate entities. We create them as follows:</p>

<ul>
<li>
<p>account_customers</p>
</li>
<li>
<p>branch_employees</p>
</li>
</ul>

<p>The account_customers and branch_employees entities will be the bridges between account and customer entities and branch and employee entities, respectively. We are converting the N:M relationship into two 1:N relationships. You will see how the design looks in the next section.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="One to many relationship (1:N)"><div class="sect3" id="idm46177498741608">
<h3>One to many relationship (1:N)</h3>

<p>This type of relationship exists between branches and accounts<a data-type="indexterm" data-primary="one-to-many relationships" data-secondary="bank database" id="idm46177498740008"/><a data-type="indexterm" data-primary="relationships" data-secondary="one-to-many relationships" data-tertiary="bank database" id="idm46177498738936"/><a data-type="indexterm" data-primary="relationships" data-secondary="nonidentifying relationships" id="idm46177498737704"/><a data-type="indexterm" data-primary="nonidentifying relationships" id="idm46177498736744"/><a data-type="indexterm" data-primary="one-to-many relationships" data-secondary="nonidentifying relationships" id="idm46177498736056"/><a data-type="indexterm" data-primary="relationships" data-secondary="one-to-many relationships" data-tertiary="nonidentifying relationships" id="idm46177498735080"/><a data-type="indexterm" data-primary="primary key" data-secondary="creating a database" data-tertiary="bank database" id="idm46177498733832"/> and between customers and account_customers. This brings up the concept of the <em>nonidentifying relationship</em>. For example, in the <code>accounts</code> table, the <code>branch_id</code> field is not part of the primary key (one reason for this is that you can move your bank account to another branch). It is common nowadays to keep a surrogate key as the primary key in each table; therefore, a genuine identifying relationship where the foreign key is also part of the primary key in a data model is rare.</p>

<p>Because we’re creating a physical EER model, we are also going to define the primary keys. It is common and recommended to use auto-incrementing unsigned fields for the primary key.</p>

<p><a data-type="xref" href="#FIG-WORKBENCH-BANKMODEL">Figure 2-17</a> shows the final representation of the bank model.</p>

<figure><div id="FIG-WORKBENCH-BANKMODEL" class="figure">
<img src="Images/lm2e_0217.png" alt="lm2e 0217" width="1457" height="803"/>
<h6><span class="label">Figure 2-17. </span>The EER model for the <code>bank</code> database</h6>
</div></figure>

<p>Note that there are items we haven’t considered for this model. For example, our model does not support a customer with multiple addresses (say, a work address and a home address). We did this intentionally to emphasize the importance of collecting the requisites prior to database deployment.</p>

<p>You can download the model from the book’s <a href="https://oreil.ly/FJm12">GitHub repository</a>. The file is <em>bank_model.mwb</em>.</p>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="Converting the EER to a MySQL Database Using Workbench"><div class="sect2" id="BAS-SEC-USING-TOOLS">
<h2>Converting the EER to a MySQL Database Using Workbench</h2>

<p>It’s a good idea to use a tool to draw your ER diagrams; <a data-type="indexterm" data-primary="CREATE DATABASE" data-secondary="Entity Relationship model" data-tertiary="EER diagrams to MySQL" id="ch02-e2my8"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="enhanced ER diagrams" data-tertiary="converting to MySQL database" id="ch02-e2my"/><a data-type="indexterm" data-primary="database design" data-secondary="ER diagrams" data-tertiary="enhanced ER to MySQL" id="ch02-e2my2"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="ER diagrams" data-tertiary="enhanced ER to MySQL" id="ch02-e2my3"/><a data-type="indexterm" data-primary="database design" data-secondary="Entity Relationship model" data-tertiary="EER diagrams to MySQL" id="ch02-e2my4"/><a data-type="indexterm" data-primary="MySQL Workbench" data-secondary="databases with Entity Relationship" data-tertiary="EER diagrams to MySQL" id="ch02-e2my5"/><a data-type="indexterm" data-primary="Entity Relationship (ER) model" data-secondary="creating a database" data-tertiary="EER diagrams to MySQL" id="ch02-e2my6"/><a data-type="indexterm" data-primary="data definition language (DDL)" data-secondary="EER diagrams to MySQL" id="ch02-e2my7"/>this way, you can easily edit and redefine them until the final diagrams are clear and unambiguous. Once you’re comfortable with the model, you can deploy it. MySQL Workbench allows the conversion of the EER model into data definition language (DDL) statements to create a MySQL database, using the Forward Engineer option in the database menu (<a data-type="xref" href="#FIG-WORKBENCH-LAST">Figure 2-18</a>).</p>

<figure><div id="FIG-WORKBENCH-LAST" class="figure">
<img src="Images/lm2e_0218.png" alt="lm2e 0218" width="1592" height="878"/>
<h6><span class="label">Figure 2-18. </span>Forward Engineering a database in MySQL Workbench</h6>
</div></figure>

<p>You’ll need to enter the credentials to connect to the database, and after that MySQL Workbench will present some options. For this model, we are going to use the standard options as shown in <a data-type="xref" href="#FIG-SETTING-OPT">Figure 2-19</a>, with all but the last option unchecked.</p>

<figure><div id="FIG-SETTING-OPT" class="figure">
<img src="Images/lm2e_0219.png" alt="lm2e 0219" width="1776" height="1172"/>
<h6><span class="label">Figure 2-19. </span>Database creation options</h6>
</div></figure>

<p>The next screen will ask which elements of the model we want to generate. Since we do not have anything special like triggers, stored procedures, users, and so on, we will only create the table objects and their relationships; the rest of the options are unchecked.</p>

<p>MySQL Workbench will then present us with the SQL script that will be executed to create the database from our model, as shown in <a data-type="xref" href="#FIG-SQL-STATEMENTS">Figure 2-20</a>.</p>

<figure><div id="FIG-SQL-STATEMENTS" class="figure">
<img src="Images/lm2e_0220.png" alt="lm2e 0220" width="1790" height="1390"/>
<h6><span class="label">Figure 2-20. </span>The script generated to create the database</h6>
</div></figure>

<p>When we click Continue, MySQL Workbench will execute the statements on our MySQL server, as shown in <a data-type="xref" href="#FIG-RUN-SCRIPT">Figure 2-21</a>.</p>

<p>We cover the details of the statements in this script in <a data-type="xref" href="ch04.xhtml#MOD-SEC-CREATETABLE">“Creating Tables”</a>.<a data-type="indexterm" data-startref="ch02-cre" id="idm46177498696776"/><a data-type="indexterm" data-startref="ch02-cre2" id="idm46177498696072"/><a data-type="indexterm" data-startref="ch02-cre3" id="idm46177498695400"/><a data-type="indexterm" data-startref="ch02-cre4" id="idm46177498694728"/><a data-type="indexterm" data-startref="ch02-e2my" id="idm46177498694056"/><a data-type="indexterm" data-startref="ch02-e2my2" id="idm46177498693384"/><a data-type="indexterm" data-startref="ch02-e2my3" id="idm46177498692712"/><a data-type="indexterm" data-startref="ch02-e2my4" id="idm46177498692040"/><a data-type="indexterm" data-startref="ch02-e2my5" id="idm46177498691368"/><a data-type="indexterm" data-startref="ch02-e2my6" id="idm46177498690696"/><a data-type="indexterm" data-startref="ch02-e2my7" id="idm46177498690024"/><a data-type="indexterm" data-startref="ch02-e2my8" id="idm46177498689352"/></p>

<figure><div id="FIG-RUN-SCRIPT" class="figure">
<img src="Images/lm2e_0221.png" alt="lm2e 0221" width="1782" height="1146"/>
<h6><span class="label">Figure 2-21. </span>MySQL Workbench starts running the script</h6>
</div></figure>
</div></section>





</div></section>







</div></section></div></body></html>