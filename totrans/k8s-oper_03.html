<html><head></head><body><section data-pdf-bookmark="Chapter 3. Operators at the Kubernetes Interface" data-type="chapter" epub:type="chapter"><div class="chapter" id="operators_at_the_kubernetes_interface">&#13;
<h1><span class="label">Chapter 3. </span>Operators at the Kubernetes Interface</h1>&#13;
&#13;
&#13;
<p>Operators extend two key Kubernetes concepts: <em>resources</em> and <em>controllers</em>. The Kubernetes API includes a mechanism, the CRD, for defining new resources.<a data-primary="controllers" data-secondary="Operators extending" data-type="indexterm" id="idm45261334814744"/> This chapter examines the Kubernetes objects Operators build on to add new capabilities to a cluster. It will help you understand how Operators fit into the Kubernetes architecture and why it is valuable to make an application a Kubernetes native.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Standard Scaling: The ReplicaSet Resource" data-type="sect1"><div class="sect1" id="idm45261334813240">&#13;
<h1>Standard Scaling: The ReplicaSet Resource</h1>&#13;
&#13;
<p>Looking at a standard resource, the ReplicaSet, gives a sense of how resources comprise the application management database at the heart of Kubernetes.<a data-primary="ReplicaSet objects" data-type="indexterm" id="idm45261334811352"/><a data-primary="scaling" data-secondary="ReplicaSet resource" data-type="indexterm" id="idm45261334810648"/> Like any other resource in the Kubernetes API, the <a href="https://oreil.ly/nW3ui">ReplicaSet</a> is a collection of API objects. The ReplicaSet primarily collects pod objects forming a list of the running replicas of an application. The specification of another object type defines the number of those replicas that should be maintained on the cluster. A third object spec points to a template for creating new pods when there are fewer running than desired. There are more objects collected in a ReplicaSet, but these three types define the basic state of a scalable set of pods running on the cluster. Here, we can see these three key pieces <a data-primary="staticweb ReplicaSet (example)" data-type="indexterm" id="idm45261334808360"/><a data-primary="Selector field, staticweb ReplicaSet (example)" data-type="indexterm" id="idm45261334807640"/><a data-primary="Replicas field, staticweb ReplicaSet (example)" data-type="indexterm" id="idm45261334886520"/>for the <code>staticweb</code> ReplicaSet from <a data-type="xref" href="ch01.html#chapter_introduction">Chapter 1</a> (the <code>Selector</code>, <code>Replicas</code>, and <code>Pod Template</code> fields):</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl describe replicaset/staticweb-69ccd6d6c</strong>&#13;
Name:           staticweb-69ccd6d6c&#13;
Namespace:      default&#13;
Selector:       pod-template-hash=69ccd6d6c,run=staticweb&#13;
Labels:         pod-template-hash=69ccd6d6c&#13;
                run=staticweb&#13;
Controlled By:  Deployment/staticweb&#13;
Replicas:       <code>1</code> current / <code>1</code> desired&#13;
Pods Status:    <code>1</code> Running / <code>0</code> Waiting / <code>0</code> Succeeded / <code>0</code> Failed&#13;
Pod Template:&#13;
  Labels:  pod-template-hash=69ccd6d6c&#13;
           run=staticweb&#13;
  Containers:&#13;
   staticweb:&#13;
    Image:        nginx&#13;
</pre>&#13;
&#13;
<p>A standard Kubernetes control plane component, the ReplicaSet controller, manages ReplicaSets and the pods belonging to them.<a data-primary="controllers" data-secondary="ReplicaSet" data-type="indexterm" id="idm45261334878232"/> The ReplicaSet controller creates ReplicaSets and continually monitors them. When the count of running pods doesn’t match the desired number in the <code>Replicas</code> field, the ReplicaSet controller starts or stops pods to make the actual state match the desired state.</p>&#13;
&#13;
<p>The actions the ReplicaSet controller takes are intentionally general and application agnostic. It starts new replicas according to the pod template, or deletes excess pods. It does not, should not, and truly cannot know the particulars of startup and shutdown sequences for every application that might run on a Kubernetes cluster.</p>&#13;
&#13;
<p>An Operator is the application-specific combination of CRs and a custom controller that does know all the details about starting, scaling, recovering, and managing its application.<a data-primary="operands" data-type="indexterm" id="idm45261334875192"/> The Operator’s <em>operand</em> is what we call the application, service, or whatever resources an Operator manages.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Custom Resources" data-type="sect1"><div class="sect1" id="idm45261334873816">&#13;
<h1>Custom Resources</h1>&#13;
&#13;
<p>CRs, as extensions of the Kubernetes API, <a data-primary="custom resources (CRs)" data-secondary="about" data-type="indexterm" id="idm45261334872600"/><a data-primary="resources" data-secondary="custom" data-seealso="custom resource definitions; custom resources" data-type="indexterm" id="idm45261334871624"/>contain one or more fields, like a native resource, but are not part of a default Kubernetes deployment. CRs hold structured data, and the API server provides a mechanism for reading and setting their fields as you would those in a native resource, by using <code>kubectl</code> or another API client. Users define a CR on a running cluster by providing a CR definition. A CRD is akin to a schema for a CR, defining the CR’s fields and the types of values those fields contain.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CR or ConfigMap?" data-type="sect2"><div class="sect2" id="idm45261334869304">&#13;
<h2>CR or ConfigMap?</h2>&#13;
&#13;
<p>Kubernetes provides a standard resource, the <a href="https://oreil.ly/ba0uh"><em>ConfigMap</em></a>, for making configuration data available to applications. ConfigMaps seem to overlap with the possible uses for CRs, but the two abstractions target different cases.<a data-primary="custom resources (CRs)" data-secondary="ConfigMaps versus" data-type="indexterm" id="idm45261334866952"/><a data-primary="ConfigMap objects, custom resources versus" data-type="indexterm" id="idm45261334866008"/></p>&#13;
&#13;
<p>ConfigMaps are best at providing a configuration to a program running in a pod on the cluster—think of an application’s config file, like <em>httpd.conf</em> or MySQL’s <em>mysql.cnf</em>. Applications usually want to read such configuration from within their pod, as a file or the value of an environment variable, rather than from the Kubernetes API.</p>&#13;
&#13;
<p>Kubernetes provides CRs to represent new collections of objects in the API. CRs are created and accessed by standard Kubernetes clients, like <code>kubectl</code>, and they obey Kubernetes conventions, like the resources <code>.spec</code> and <code>.status</code>. At their most useful, CRs are watched by custom controller code that in turn creates, updates, or deletes other cluster objects or even arbitrary resources outside of the cluster.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Custom Controllers" data-type="sect1"><div class="sect1" id="idm45261334861352">&#13;
<h1>Custom Controllers</h1>&#13;
&#13;
<p>CRs are entries in the Kubernetes API database.<a data-primary="controllers" data-secondary="custom" data-type="indexterm" id="idm45261334860024"/> They can be created, accessed, updated, and deleted with common <code>kubectl</code> commands—but a CR alone is merely a collection of data. To provide a declarative API for a specific application running on a cluster, you also need active code that captures the processes of managing that <span class="keep-together">application.</span></p>&#13;
&#13;
<p>We’ve looked at a standard Kubernetes controller, the ReplicaSet controller. To make an Operator, providing an API for the active management of an application, you build an instance of the Controller pattern to control your application. This custom controller checks and maintains the application’s desired state, represented in the CR. Every Operator has one or more custom controllers implementing its application-specific management logic.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Operator Scopes" data-type="sect1"><div class="sect1" id="idm45261334856616">&#13;
<h1>Operator Scopes</h1>&#13;
&#13;
<p>A Kubernetes cluster is divided into <em>namespaces</em>. <a data-primary="Operators" data-secondary="scopes" data-type="indexterm" id="idm45261334854632"/><a data-primary="scope of an Operator" data-type="indexterm" id="idm45261334920680"/><a data-primary="namespaces" data-type="indexterm" id="idm45261334920008"/>A namespace is the boundary for cluster object and resource names. Names must be unique within a single namespace, but not between namespaces. This makes it easier for multiple users or teams to share a single cluster. Resource limits and access controls can be applied per namespace. An Operator, in turn, can be limited to a namespace, or it can maintain its operand across an entire cluster.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For details about Kubernetes namespaces, see the <a href="https://oreil.ly/k4Okf">Kubernetes namespace documentation</a>.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Namespace Scope" data-type="sect2"><div class="sect2" id="idm45261334916824">&#13;
<h2>Namespace Scope</h2>&#13;
&#13;
<p>Usually, restricting your Operator to a single namespace makes sense and is more flexible for clusters used by multiple teams.<a data-primary="namespaces" data-secondary="namespace scope for Operators" data-type="indexterm" id="idm45261334915352"/> An Operator scoped to a namespace can be upgraded independently of other instances, and this allows for some handy facilities. You can test upgrades in a testing namespace, for example, or serve older API or application versions from different namespaces for compatibility.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cluster-Scoped Operators" data-type="sect2"><div class="sect2" id="idm45261334913640">&#13;
<h2>Cluster-Scoped Operators</h2>&#13;
&#13;
<p>There are some situations where it is desirable for an Operator to watch and manage an application or services throughout a cluster. For example, an Operator that manages a service mesh, such as <a href="https://oreil.ly/jM5q2">Istio</a>, or one that <a data-primary="TLS certificates" data-type="indexterm" id="idm45261334911480"/>issues TLS certificates for application endpoints, like <a href="https://oreil.ly/QT8tE"><code>cert-manager</code></a>, might be most effective when watching and acting on cluster-wide state.</p>&#13;
&#13;
<p>By default, the Operator SDK used in this book creates deployment and authorization templates that limit the Operator to a single namespace. It is possible to change most Operators to run in the cluster scope instead. Doing so requires changes in the Operator’s manifests to specify that it should watch all namespaces in a cluster and that it should run under the auspices of a ClusterRole and ClusterRoleBinding, rather than the namespaced Role and RoleBinding authorization objects. In the next section we give an overview of these concepts.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authorization" data-type="sect1"><div class="sect1" id="idm45261334908600">&#13;
<h1>Authorization</h1>&#13;
&#13;
<p>Authorization—the power to do things on the cluster through the API—is defined in Kubernetes by one of a few available access control systems.<a data-primary="authorization" data-secondary="defining in Kubernetes" data-type="indexterm" id="idm45261334906808"/><a data-primary="role-based access control (RBAC)" data-type="indexterm" id="idm45261334905832"/> Role-Based Access Control (RBAC) is the preferred and most tightly integrated of these. RBAC regulates access to system resources according to the <em>role</em> a system user performs. <a data-primary="roles" data-secondary="defined" data-type="indexterm" id="idm45261334904472"/>A role is a set of capabilities to take certain actions on particular API resources, such as <em>create</em>, <em>read</em>, <em>update</em>, or <em>delete</em>. The capabilities described by a role are granted, or bound, to a user by a RoleBinding.<a data-primary="RoleBinding" data-type="indexterm" id="idm45261334901416"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Service Accounts" data-type="sect2"><div class="sect2" id="idm45261334900712">&#13;
<h2>Service Accounts</h2>&#13;
&#13;
<p>In Kubernetes, regular human user accounts aren’t managed by the cluster, and there are no API resources depicting them.<a data-primary="service accounts" data-secondary="about" data-type="indexterm" id="idm45261334899272"/> The user identifying you on the cluster comes from some outside provider, which can be anything from a list of users in a text file to an OpenID Connect (OIDC) provider proxying authentication through your Google account.<a data-primary="OpenID Connect (OIDC) providers" data-type="indexterm" id="idm45261334897928"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>See the <a href="https://oreil.ly/WmdTq">“Users in Kubernetes”</a> documentation for more about Kubernetes service accounts.</p>&#13;
</div>&#13;
&#13;
<p>Service accounts, on the other hand, are managed by Kubernetes and can be created and manipulated through the Kubernetes API. A service account is a special type of cluster user for authorizing programs instead of people. An Operator is a program that uses the Kubernetes API, and most Operators should derive their access rights from a service account. Creating a service account is a standard step in deploying an Operator. The service account identifies the Operator, and the account’s role denotes the powers granted to the Operator.<a data-primary="Users in Kubernetes documentation" data-type="indexterm" id="idm45261334894472"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Roles" data-type="sect2"><div class="sect2" id="idm45261334893448">&#13;
<h2>Roles</h2>&#13;
&#13;
<p>Kubernetes RBAC denies permissions by default, so a role defines granted rights. A common “Hello World” example of a Kubernetes role looks something like this YAML excerpt:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Role</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">namespace</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">default</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">pod-reader</code><code>&#13;
</code><code class="nt">rules</code><code class="p">:</code><code>&#13;
</code><code class="p-Indicator">-</code><code> </code><code class="nt">apiGroups</code><code class="p">:</code><code> </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">"</code><code class="p-Indicator">]</code><code>&#13;
</code><code>  </code><code class="nt">resources</code><code class="p">:</code><code> </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">pods</code><code class="s">"</code><code class="p-Indicator">]</code><code>  </code><a class="co" href="#callout_operators_at_the_kubernetes_interface_CO1-1" id="co_operators_at_the_kubernetes_interface_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>  </code><code class="nt">verbs</code><code class="p">:</code><code> </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">get</code><code class="s">"</code><code class="p-Indicator">,</code><code> </code><code class="s">"</code><code class="s">watch</code><code class="s">"</code><code class="p-Indicator">,</code><code> </code><code class="s">"</code><code class="s">list</code><code class="s">"</code><code class="p-Indicator">]</code><code>  </code><a class="co" href="#callout_operators_at_the_kubernetes_interface_CO1-2" id="co_operators_at_the_kubernetes_interface_CO1-2"><img alt="2" src="assets/2.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_operators_at_the_kubernetes_interface_CO1-1" id="callout_operators_at_the_kubernetes_interface_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The powers granted by this role are effective only on pods.</p></dd>&#13;
<dt><a class="co" href="#co_operators_at_the_kubernetes_interface_CO1-2" id="callout_operators_at_the_kubernetes_interface_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>This list permits specific operations on the allowed resources. The verbs comprising read-only access to pods are available to accounts bound with this role.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="RoleBindings" data-type="sect2"><div class="sect2" id="idm45261334955992">&#13;
<h2>RoleBindings</h2>&#13;
&#13;
<p>A RoleBinding ties a role to a list of one or more users.<a data-primary="RoleBinding" data-type="indexterm" id="idm45261334954696"/> Those users are granted the permissions defined in the role referenced in the binding. A RoleBinding can reference only those roles in its own namespace. When deploying an Operator restricted to a namespace, a RoleBinding binds an appropriate role to a service account identifying the Operator.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ClusterRoles and ClusterRoleBindings" data-type="sect2"><div class="sect2" id="idm45261334953304">&#13;
<h2>ClusterRoles and ClusterRoleBindings</h2>&#13;
&#13;
<p>As discussed earlier, most Operators are confined to a namespace. Roles and RoleBindings are also restricted to a namespace. ClusterRoles and ClusterRoleBindings are their cluster-wide equivalents.&#13;
<a data-primary="ClusterRoles" data-type="indexterm" id="idm45261334951832"/><a data-primary="ClusterRoleBindings" data-type="indexterm" id="idm45261334951128"/><a data-primary="roles" data-secondary="ClusterRole and ClusterRoleBinding" data-type="indexterm" id="idm45261334705704"/>&#13;
A standard, namespaced RoleBinding can reference only roles in its namespace, or ClusterRoles defined for the entire cluster. When a RoleBinding references a ClusterRole, the rules declared in the ClusterRole apply to only those specified resources in the binding’s own namespace. In this way, a set of common roles can be defined once as ClusterRoles, but reused and granted to users in just a given namespace.</p>&#13;
&#13;
<p>The ClusterRoleBinding grants capabilities to a user across the entire cluster, in all namespaces. Operators charged with cluster-wide responsibilities will often tie a ClusterRole to an Operator service account with a ClusterRoleBinding.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45261334703400">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Operators are Kubernetes extensions. We’ve outlined the Kubernetes components used to construct an Operator that knows how to manage the application in its charge. Because Operators build on core Kubernetes concepts, they can make applications meaningfully “Kubernetes native.” Aware of their environment, such applications are able to leverage not just the existing features but the design patterns of the platform in order to be more reliable and less needy. Because Operators politely extend Kubernetes, they can even manage parts and procedures of the platform itself, as seen throughout Red Hat’s OpenShift Kubernetes distribution.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>