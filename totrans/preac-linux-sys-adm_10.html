<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 10. Scripting and Automation" data-type="chapter" epub:type="chapter"><div class="chapter" id="scripting_and_automation">
<h1><span class="label">Chapter 10. </span>Scripting and Automation</h1>
<p>Sysadmins automate what they can. But you can’t automate everything. Automation is a good thing but has its limitations. <a contenteditable="false" data-primary="automation" data-type="indexterm" id="ix_auto"/>In this chapter, I discuss both the pros and cons of automation. Some tasks are difficult to automate because they involve too many variables. And automation does come with some security risks because automating tasks that require elevated privileges creates security holes that can lead to system compromise. Other obstacles to automation include timing and time drift, system failure, script error conditions, and human interactions.</p>
<p>Creating scripts and automating tasks is challenging and fun. <a contenteditable="false" data-primary="scripting" data-seealso="automation" data-type="indexterm" id="idm45657872793680"/>Watching a series of scripts and schedules work as planned to mimic human keystrokes, decisions, and activities is rewarding. Every sysadmin must know how to create basic shell scripts and should automate every possible nonprivileged, repetitive task. This chapter covers the concepts of scripting and automation but not the low-level mechanics of scripting (loops, file I/O, etc.), which are well-documented on the web.</p>
<section data-pdf-bookmark="Answering the Question: Why Automate?" data-type="sect1"><div class="sect1" id="answering_the_question_why_automateques">
<h1>Answering the Question: Why Automate?</h1>
<p>I’ve had a few sysadmins ask me why they should automate anything.<a contenteditable="false" data-primary="automation" data-secondary="benefits of" data-type="indexterm" id="idm45657873303568"/> The answer is simple: so you can focus on higher-level tasks while your computer systems handle the mundane, daily jobs that you must perform but that a CPU and some memory can address without making mistakes. <a contenteditable="false" data-primary="backups" data-secondary="manual" data-type="indexterm" id="idm45657873303968"/>Do you want your day filled with the drudgery of manually creating backups, copying backups to an archive location, checking capacity on every system, installing updates, checking log files for errors, and checking uptimes, or would you rather focus on system security, testing new software, and sharpening your scripting skills?</p>
<p class="pagebreak-before">You have only a limited number of hours to perform the work that must be done. And you probably have an almost inexhaustible supply of computing power at your fingertips. Use it. The tasks that require hours of your time can be handed off to systems that complete those repetitive tasks flawlessly, without getting tired or frustrated, and with almost no overhead. And those are the reasons to automate every task that you possibly can.</p>
</div></section>
<section data-pdf-bookmark="Automating Yourself Out of a Job" data-type="sect1"><div class="sect1" id="automating_yourself_out_of_a_job">
<h1>Automating Yourself Out of a Job</h1>
<p>Spoiler alert: you’re never going to automate yourself out of a job, but you should try. <a contenteditable="false" data-primary="automation" data-secondary="automating yourself out of a job" data-type="indexterm" id="idm45657872777664"/>Seriously, you can automate every repetitive, mundane task you face, but you’ll never succeed in losing your job because you’ve automated it. Too many variables and things can go wrong with the hardware, software, networks, and, most of all, users to end your employment because you’ve successfully automated too much.</p>
<p>Here are answers to five common questions about automation that I’m confident will clear things <a contenteditable="false" data-primary="automation" data-secondary="common questions about" data-type="indexterm" id="idm45657873246400"/>up for you:</p>
<dl>
<dt>Which tasks should I automate?</dt>
<dd>Anything that can be scripted reliably, even if it requires user input.</dd>
<dt>Are there tasks that cannot be automated?</dt>
<dd>Yes, plenty of them. Most things requiring a complex, multistep decision can’t be automated (although some can). You can use various techniques to automate them, including <code>expect</code>, shell scripts, Perl, PHP, and other scripting and compiled languages.</dd>
<dt>Are there tasks that should never be automated?</dt>
<dd>Yes. You should not automate tasks such as those that require you to store an unencrypted password in a text file. There are multiple methods of automating tasks where you can use encrypted passwords, key files, limited <code>sudo</code>, or nonprivileged accounts.</dd>
<dt>Which task should I automate first?</dt>
<dd>Backups. For example, create a backup of your <em>/etc</em> directory and use secure copy (SCP) to archive it onto another system.</dd>
<dt>Should I purchase a commercial automation solution?</dt>
<dd>You can, but you should begin by using your own scripts and exhausting your options before spending money on something you can do just as efficiently and free of charge. But certainly, purchase a commercial solution if the number of hosts makes it reasonable.</dd>
</dl>
<p>Basic automation is easy to do, it saves money and time, and it prevents mistakes made by human hands.</p>
<p>There is also a psychological aspect of automation—sysadmins who automate experience less burnout than those who perform every task manually.<a contenteditable="false" data-primary="psychological aspect of automation" data-type="indexterm" id="idm45657873246976"/> Think about the repetitive nature of making backups, transferring them to an archive location, checking backups, and removing old archives. If you manage more than a handful of systems, it will take a significant portion of your day (or evening) to type every command manually. This kind of labor wears on a person’s psyche and causes burnout and job dissatisfaction. Multiple studies show that automation does increase job satisfaction. Alex Edelstein’s blog post <a href="https://oreil.ly/5-iR9">“89% of Your Employees Could Benefit with This One Change”</a> explains this concept further.<a contenteditable="false" data-primary="automation" data-startref="ix_auto" data-type="indexterm" id="idm45657873289232"/></p>
</div></section>
<section data-pdf-bookmark="Creating Scripts" data-type="sect1"><div class="sect1" id="creating_scripts">
<h1>Creating Scripts</h1>
<p>If you need a script to perform a particular task, chances are excellent that you can find one with a simple online search. <a contenteditable="false" data-primary="scripting" data-secondary="creating scripts" data-type="indexterm" id="ix_scrptcr"/><a contenteditable="false" data-primary="automation" data-secondary="creating scripts" data-type="indexterm" id="ix_autoscrpt"/>You don’t have to write one from scratch. Adapt scripts to your needs and use them without guilt. Other system administrators place their scripts online for you to use. You should, however, learn the basics of scripting, such as reading from a file, writing to a file, grepping, piping, redirecting, looping, and calling other scripts from within a script. You don’t have to become a scripting expert but learning the basics helps you find what you need and allows you to adapt what you find to your circumstances.</p>
<p>Writing backup scripts is a good place to start. <a contenteditable="false" data-primary="backups" data-secondary="writing backup scripts" data-type="indexterm" id="idm45657875871888"/>Backups are required, and you’ll be a hero in case of a failure or human error, which could be your own. I’ve known sysadmins with more than ten years of experience who have removed entire <em>/etc</em> directories by accident, so a good backup is essential to a happy life as a sysadmin. The following sections teach you scriptwriting concepts. The most important of these is outlining your script.</p>
<section data-pdf-bookmark="Outlining Your Scripts" data-type="sect2"><div class="sect2" id="outlining_your_scripts">
<h2>Outlining Your Scripts</h2>
<p>Before you write a script, outline what you want the script to do.<a contenteditable="false" data-primary="scripting" data-secondary="creating scripts" data-tertiary="outlining your scripts" data-type="indexterm" id="idm45657872726368"/> No, you don’t have to create a flowchart, but you should list the steps that you want to occur during the script’s run. Here’s an example of a script that I’ll call <em>backup_server1.sh</em>:</p>
<ul>
<li>
<p>Create a <code>tar</code> file of the <em>/etc</em> directory.</p>
</li>
<li>
<p>Compress the <code>tar</code> file.</p>
</li>
<li>
<p>Transfer the file to server <em>archive1</em>.</p>
</li>
</ul>
<p>That’s simple enough. The script is a simple, top-down procedure with no decision tree or branching.</p>
</div></section>
<section data-pdf-bookmark="Writing a Script from an Outline" data-type="sect2"><div class="sect2" id="writing_a_script_from_an_outline">
<h2>Writing a Script from an Outline</h2>
<p>And now that you have your script outline, you also have the documentation for your script. <a contenteditable="false" data-primary="scripting" data-secondary="creating scripts" data-tertiary="writing a script from an outline" data-type="indexterm" id="idm45657872715088"/>You must document your scripts because, in six months or a year, you might not remember the script’s purpose or even that you wrote it.</p>
<p>The contents of <em>backup_server1.sh</em> are as follows:</p>
<pre data-type="programlisting">
#!/bin/bash

# Create a tar file of /etc.
sudo tar cvf server1_etc.tar /etc

# Compress the tar file
gzip -9 server1_etc.tar

# Transfer the file to archive1 into the /server1/backups directory
scp server1_etc.tar.gz archive1:/server1/backups</pre>
<p>Save the file, give it execute permission, and it’s ready to use. The <em>/server1/backups</em> directory on the <em>archive1</em> system should be executable and writeable by the user placing the backups into it. <a contenteditable="false" data-primary="backup and restore (bur) user, creating on all systems" data-type="indexterm" id="idm45657872710704"/><a contenteditable="false" data-primary="bur (backup and restore) user, creating on all systems" data-type="indexterm" id="idm45657872709808"/>For better security, you should designate a backup user and create backup directories with permissions restricted to that user.</p>
<p>Create a Backup and Restore (<code>bur</code>) user on all systems and set up passwordless SSH key files for the <code>bur</code> user.<a contenteditable="false" data-primary="cron jobs" data-secondary="setting up for bur user" data-type="indexterm" id="idm45657872711408"/><a contenteditable="false" data-primary="backups" data-secondary="setting up cron jobs for bur user" data-type="indexterm" id="idm45657872706080"/> Set up <code>cron</code> jobs for backups as the <code>bur</code> user on all systems:</p>
<pre data-type="programlisting">
drwx------    2 bur  bur         64 Oct  4 08:01 backups</pre>
<p>Here is the <code>crontab</code> for the <code>bur</code> user on <em>server1</em>:</p>
<pre data-type="programlisting">
0 2 * * * /home/bur/backup_server1.sh</pre>
<p>The <code>bur</code> user’s <code>crontab</code> will<a contenteditable="false" data-primary="crontab for bur user" data-type="indexterm" id="idm45657872699584"/> back up <em>server1</em>’s <em>/etc</em> directory every day at 2 a.m. The backups will transfer to <em>archive1</em> into the <em>/server1/backup</em> directory. You need to set up this scenario on every system. The backup for <em>archive1</em> should be sent to a different system.</p>
<p>The <em>/etc</em> directory isn’t the only directory you need to back up. <a contenteditable="false" data-primary="directories" data-secondary="needing backup" data-type="indexterm" id="idm45657872693552"/>This is just an example. You might need to back up <em>/home</em>, <em>/var/www/html</em>, <em>/opt</em>, and others to restore a system to its previous state before a security incident or failure. The <code>crontab</code> (scheduled task) will be explained in detail in the next section.<a contenteditable="false" data-primary="scripting" data-secondary="creating scripts" data-startref="ix_scrptcr" data-type="indexterm" id="idm45657872689088"/><a contenteditable="false" data-primary="automation" data-secondary="creating scripts" data-startref="ix_autoscrpt" data-type="indexterm" id="idm45657872688192"/></p>
</div></section>
</div></section>
<section class="pagebreak-before" data-pdf-bookmark="Scheduling Tasks" data-type="sect1"><div class="sect1" id="scheduling_tasks">
<h1 class="less_space">Scheduling Tasks</h1>
<p>The <code>cron</code> utility schedules commands to run at a specific time. <a contenteditable="false" data-primary="scheduling tasks" data-type="indexterm" id="ix_schd"/><a contenteditable="false" data-primary="cron utility" data-type="indexterm" id="idm45657872683328"/><a contenteditable="false" data-primary="automation" data-secondary="scheduling tasks" data-type="indexterm" id="ix_autoschd"/>It helps to automate repetitive tasks that must be performed at a specific time, multiple times, or at inconvenient times for humans.</p>
<p>Over the years, developers have attempted to replace the <code>cron</code> utility with little success. <code>cron</code> is difficult to replace because it works well and is versatile enough to handle most scheduled activities. <code>cron</code> is reliable because it uses the computer’s system clock to act on scheduled activities. The one flaw with <code>cron</code>, if you can call it that, is that you will encounter problems if your automated tasks involve multiple systems and their times drift out of sync. The solution is to reference a central time server. I will cover the network time protocol later in this section.</p>
<section data-pdf-bookmark="Using cron to Schedule Tasks" data-type="sect2"><div class="sect2" id="using_cron_to_schedule_tasks">
<h2>Using cron to Schedule Tasks</h2>
<p>The <code>cron</code> utility is available on all Linux systems, and it just works. <a contenteditable="false" data-primary="automation" data-secondary="scheduling tasks" data-tertiary="using cron" data-type="indexterm" id="idm45657872756224"/><a contenteditable="false" data-primary="cron utility" data-secondary="using to schedule tasks" data-type="indexterm" id="idm45657872672800"/>There’s no tweaking or configuration required. <a contenteditable="false" data-primary="scheduling tasks" data-secondary="using cron" data-type="indexterm" id="idm45657872756864"/>It’s a time-tested application built to do one job: run commands at a specific time—and it does that job very well. The best way to learn <code>cron</code> is by example because the syntax isn’t necessarily intuitive.</p>
<p><code>cron</code> has a simple “syntax” or format:</p>
<pre data-type="programlisting">
# ┌───────────── minute (0 - 59)
# │ ┌───────────── hour (0 - 23)
# │ │ ┌───────────── day of the month (1 - 31)
# │ │ │ ┌───────────── month (1 - 12)
# │ │ │ │ ┌───────────── day of the week (0 - 6) (Sunday to Saturday;
# │ │ │ │ │                         7 is also Sunday on some systems)
# │ │ │ │ │
# │ │ │ │ │
# * * * * * command to execute</pre>
<p>What isn’t shown here is that you can run scripts or commands multiple times using only one schedule or <code>cron</code> “job.” For example, you need to run a script that checks for the existence of a file every 5 minutes every day. The format for that entry is as follows:</p>
<pre data-type="programlisting">
0,5,10,15,20,25,30,35,40,45,50,55 * * * * /path/to/script.sh</pre>
<p class="pagebreak-before">If you want a script to run every Monday, Wednesday, and Friday at 2:00 p.m., the <code>cron</code> schedule takes the following form:</p>
<pre data-type="programlisting">
0 14 * * 1,3,5 /path/to/script.sh</pre>
<p>If you want your script to run at 6 a.m. on the 15th of every month:</p>
<pre data-type="programlisting">
0 6 15 * * /path/to/script.sh</pre>
<p>You have a full range of possibilities with <code>cron</code> schedules.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Do not set a schedule in <code>cron</code> for <em>* * * * * /path/to/script.sh</em> unless you want your script to run every minute of every day.<a contenteditable="false" data-primary="cron utility" data-secondary="time interval to schedule monitoring tasks" data-type="indexterm" id="idm45657872659424"/> For most monitoring scenarios, once every five minutes is sufficient to catch any process, error, or file you’re trying to capture or track.</p>
</div>
</div></section>
<section data-pdf-bookmark="Preventing Time Drift with the Network Time Protocol" data-type="sect2"><div class="sect2" id="preventing_time_drift_with_the_network">
<h2>Preventing Time Drift with the Network Time Protocol</h2>
<p>One of the problems with writing scripts that operate on multiple systems is synchronizing system time among them. <a contenteditable="false" data-primary="automation" data-secondary="scheduling tasks" data-tertiary="preventing time drift with Network Time Protocol" data-type="indexterm" id="idm45657872655152"/><a contenteditable="false" data-primary="NTP (Network Time Protocol)" data-type="indexterm" id="idm45657872656304"/><a contenteditable="false" data-primary="scheduling tasks" data-secondary="preventing time drift with Network Time Protocol" data-type="indexterm" id="idm45657872655920"/><a contenteditable="false" data-primary="time drift, preventing with Network Time Protocol" data-type="indexterm" id="idm45657872652480"/><a contenteditable="false" data-primary="Network Time Protocol (NTP)" data-type="indexterm" id="idm45657872651408"/>For example, imagine you have a script that gathers files from <em>Server A</em> and copies them to <em>Server B</em>, and once those files are copied, <em>Server B</em> checks for them and then creates a tarball and copies them onto NAS for archiving. If this needs to happen multiple times per day and in a timed sequence, you can see how synchronized time among server systems is essential.</p>
<p>The way to keep time synced among all your systems is to reference an internet time server plus a time server inside your network (in case you experience an internet connectivity outage).<a contenteditable="false" data-primary="chrony" data-secondary="installing and configuring as internet time server" data-type="indexterm" id="idm45657872836608"/></p>
<p>Install <code>ntp</code> or <code>chrony</code> to allow your systems to synchronize with an external (internet) time server. Installing <code>chrony</code> is easy and requires no configuration as a client. Here, I demonstrate how to install and configure <code>chrony</code>. It works similarly on Debian <a contenteditable="false" data-primary="Debian" data-secondary="configuring chrony on" data-type="indexterm" id="idm45657872644048"/>distributions except that your <code>chrony</code> configuration file is located in <em>/etc/chrony/</em> rather than simply in <em>/etc</em>:</p>
<pre class="pagebreak-after" data-type="programlisting">
$ sudo yum -y install chrony

$ sudo apt install chrony

$ sudo systemctl enable chronyd
Created symlink /etc/systemd/system/multi-user.target.wants/chronyd.service 
→ /usr/lib/systemd/system/chronyd.service.

$ sudo systemctl start chronyd</pre>
<p>The <code>chrony</code> package provides you with the <code>chrony</code> daemon, <code>chronyd</code>, and a command-line interface utility that has dozens of options, which you can find in its man page. <a contenteditable="false" data-primary="CLI (command-line interface)" data-secondary="chrony" data-type="indexterm" id="idm45657872636400"/><a contenteditable="false" data-primary="chrony" data-secondary="chronyd and CLI" data-type="indexterm" id="idm45657872635376"/>To perform a quick check, use the following command:</p>
<pre data-type="programlisting">
$ chronyc activity
200 OK
4 sources online
0 sources offline
0 sources doing burst (return to online)
0 sources doing burst (return to offline)
0 sources with unknown address</pre>
<p>You can also configure <code>chrony</code> as a time server for your local network. <a contenteditable="false" data-primary="chrony" data-secondary="configuring chrony as time server on local network" data-type="indexterm" id="idm45657872632528"/>To do so, uncomment the following two lines in the <em>/etc/chrony.conf</em> file on the system you wish to set up <a contenteditable="false" data-primary=" /etc/chrony.conf file" data-primary-sortas="etc" data-type="indexterm" id="idm45657872631840"/>as the time server:</p>
<pre data-type="programlisting">
# Allow NTP client access from local network.
#allow 192.168.0.0/16

# Serve time even if not synchronized to a time source.
#local stratum 10</pre>
<p>Change the <code>Allow</code> line to cover your subnet(s) and restart the <code>chronyd</code>:</p>
<pre data-type="programlisting">
$ sudo systemctl restart chronyd</pre>
<p>To set up other Linux systems to use your <code>chrony</code> server, enter the following line into your <em>/etc/chrony.conf</em> file:</p>
<pre data-type="programlisting">
server  192.168.1.80 prefer iburst</pre>
<p>The <code>prefer</code> designation tells <code>chrony</code> that this local system should be consulted first for the correct time. Restart the <code>chronyd</code> to accept the new setting and check your <code>chronyd</code> sources with the following command:</p>
<pre data-type="programlisting">
$ chronyc sources
MS Name/IP address         Stratum Poll Reach LastRx Last sample              
===============================================================================
^? server1                       0   6     0     -     +0ns[   +0ns] +/-    0ns
^- mon2.hostin.cc                2   6     7     1    +37ms[  +31ms] +/-  138ms
^+ ntp.netnod.se                 1   6     7     1  +9151us[+2267us] +/-   81ms
^? nobody.yourvserver.net        2   6     1     4  -2309us[-9194us] +/-   65ms
^* nettuno.ntp.irh.it            2   6     7     1  -4454us[  -11ms] +/-   67ms</pre>
<p>You could also configure all your client systems to use only the local server by commenting out the “pool” line(s) in <em>/etc/chrony.conf</em>. You may also edit the <em>chrony.conf</em> file to set up more specific settings. What I’ve shown here is a minimal but working configuration.</p>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Although <code>cron</code> and <code>chrony</code> sound similar, deal with timing, and work together, they are quite different. <a contenteditable="false" data-primary="chrony" data-secondary="cron versus" data-type="indexterm" id="idm45657872615840"/><a contenteditable="false" data-primary="cron utility" data-secondary="chrony versus" data-type="indexterm" id="idm45657872614848"/>The <code>cron</code> utility schedules jobs to be executed at a specific day and time, whereas <code>chrony</code> synchronizes the system clock with an external time server. <code>chrony</code> keeps system time stable so that <code>cron</code> jobs run at the correct time, which is especially important when timing jobs across multiple systems.</p>
</div>
</div></section>
</div></section>
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id00010">
<h1>Summary</h1>
<p><em>Timing is everything.</em> <a contenteditable="false" data-primary="automation" data-secondary="scheduling tasks" data-startref="ix_autoschd" data-type="indexterm" id="idm45657872610112"/>Scheduling <a contenteditable="false" data-primary="scheduling tasks" data-startref="ix_schd" data-type="indexterm" id="idm45657872608768"/>jobs, synchronizing time among local systems, timing automated scripts among systems, and synchronizing time with an external “source of truth” is essential. Automation is but one reason to keep your systems’ times synchronized. Security is another. Consider the scenario where you’re attempting to isolate a security incident, and your systems are not time synchronized. It would be difficult to pinpoint a timeframe for the incident to determine when it occurred and its length.</p>
<p>Automation is an important part of your work as a system administrator. There aren’t enough hours available to manually complete every required task. You must hand off your repetitive, mundane tasks to your systems. They won’t complain, tire, or mistype a command. Automation is a good thing, and you should embrace it. Try to automate yourself out of a job.</p>
</div></section>
</div></section></div></body></html>