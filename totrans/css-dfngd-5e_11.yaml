- en: Chapter 11\. Flexible Box Layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The [CSS Flexible Box Module Level 1](http://www.w3.org/TR/css-flexbox-1), or
    flexbox for short, makes the once difficult tasks of laying out certain kinds
    of pages, widgets, applications, and galleries almost simple. With flexbox, you
    often don’t need a CSS framework. In this chapter, you’ll learn how to use just
    a few lines of CSS to create almost any feature your site requires.
  prefs: []
  type: TYPE_NORMAL
- en: Flexbox Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Flexbox* is a simple and powerful way to lay out page components by dictating
    how space is distributed, content is aligned, and elements are visually ordered.
    Content can easily be arranged vertically or horizontally, and can be laid out
    along a single axis or wrapped across multiple lines. And much, much more.'
  prefs: []
  type: TYPE_NORMAL
- en: With flexbox, the appearance of content can be independent of source order.
    Though visually altered, flex properties should not impact the order of content
    read by screen readers.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Specifications say that screen readers should follow source order, but as of
    late 2022, Firefox follows the visual order. As of this writing, a proposal calls
    for adding a CSS property that specifies whether to follow source or visual order,
    so it may soon be possible to decide for yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps most importantly, with flexible box module layouts, elements can be
    made to behave predictably for different screen sizes and different display devices.
    Flexbox works very well with responsive sites, as content can increase and decrease
    in size when the space provided is increased or decreased.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flexbox works off of a parent-and-child relationship. Flexbox layout is activated
    by declaring `display: flex` or `display: inline-flex` on an element. This element
    becomes a *flex container*, arranging its children within the space provided and
    controlling their layout. The children of this flex container become *flex items*.
    Consider the following styles and markup, illustrated in [Figure 11-1](#display_flex):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding display: flex; or display: inline-flex creates a flex container](assets/css5_1101.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-1\. The two kinds of flex containers [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/two-kinds-of-flex-containers.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Look for the Play symbol ![](assets/play-icon-round.png) to know when an online
    example is available. All of the examples in this chapter can be found at [*https://meyerweb.github.io/csstdg5figs/11-flexbox*](https://meyerweb.github.io/csstdg5figs/11-flexbox).
  prefs: []
  type: TYPE_NORMAL
- en: Notice how each child element of the `<div>`s becomes a flex item, and furthermore,
    how they all lay out in the same way? It doesn’t matter that some are paragraphs
    and others are `<span>`s. They all become flex items. (There would likely have
    been some differences due to the paragraphs’ browser-default margins, except those
    were removed.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The only real difference between the first and second flex containers is that
    one is set to `display: flex`, and the other to `display: inline-flex`. In the
    first, the `<div>` becomes a block box with flex layout inside it. In the second,
    the `<div>` becomes an inline-block box with flex inside it.'
  prefs: []
  type: TYPE_NORMAL
- en: The key thing to keep in mind is that once you set an element to be a flex container,
    like the `<div>`s in [Figure 11-1](#display_flex), it will flex only its immediate
    children, and not further descendants. However, you can make those descendants
    flex containers as well, enabling some really complex layouts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within a flex container, items line up on the *main-axis*. The main-axis can
    be either horizontal or vertical, so you can arrange items into columns or rows.
    The main-axis takes on the directionality set via the writing mode: this main-axis
    concept is discussed in depth in [“Understanding Axes”](#understanding-axis).'
  prefs: []
  type: TYPE_NORMAL
- en: As the first `<div>` in [Figure 11-1](#display_flex) demonstrates, when the
    flex items don’t fill up the entire main-axis (in this case, the width) of the
    container, they will leave extra space. Certain properties dictate how to handle
    that extra space, which we’ll explore later in the chapter. You can group the
    children to the left, the right, or centered, or you can spread them out, defining
    how the space is spread out either between or around the children.
  prefs: []
  type: TYPE_NORMAL
- en: Besides distributing space, you can also allow the flex items to grow to take
    up all the available space by distributing that extra space among one, some, or
    all of the flex items. If there isn’t enough space to contain all the flex items,
    you can employ flexbox properties to dictate how they should shrink to fit within
    their container, or whether they’re allowed to wrap to multiple flex lines.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, the children can be aligned with respect to their container or
    to each other; to the bottom, top, or center of the container; or stretched out
    to fill the container. Regardless of the difference in content length among sibling
    containers, with flexbox you can make all the siblings the same size with a single
    declaration.
  prefs: []
  type: TYPE_NORMAL
- en: A Simple Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s say we want to create a navigation bar out of a group of links. This
    is exactly the sort of thing flexbox was designed to handle. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, with its `display` property set to `flex`, the `<nav>`
    element is turned into a flex container, and its child links are all flex items.
    These links are still hyperlinks, but they are now also flex items, which means
    they are no longer inline-level boxes: rather, they participate in their container’s
    flex formatting context. Therefore, the whitespace between the `<a>` elements
    in the HTML is completely ignored in layout terms. If you’ve ever used HTML comments
    to suppress the space between links, list items, or other elements, you know why
    this is a big deal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s add some CSS to the links:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We now have ourselves a simple tabbed navigation bar, as shown in [Figure 11-2](#simple_tabbed_navigation).
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple tabbed navigation (files/nav_displayflex.html)](assets/css5_1102.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-2\. A simple tabbed navigation [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/simple-tabbed-navigation.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'That might not seem like much right now, because there’s nothing here you couldn’t
    have done with old-school CSS. Just wait: it gets better.'
  prefs: []
  type: TYPE_NORMAL
- en: By design, flexbox is direction-agnostic. This is different from block or inline
    layouts, which are defined to be vertically and horizontally biased, respectively.
    The web was originally designed for the creation of pages on monitors, and assumed
    a horizontal constraint with infinite vertical scroll. This vertically biased
    layout is insufficient for modern applications that change orientation, grow,
    and shrink, depending on the user agent and the direction of the viewport, and
    change writing modes depending on the language.
  prefs: []
  type: TYPE_NORMAL
- en: For years we joked about the challenges of vertical centering and multiple column
    layout. Some layouts were no laughing matter, like ensuring equal heights in sets
    of multiple side-by-side boxes, with buttons or “more” links fixed to the bottom
    of each box ([Figure 11-3](#power_grid_layout_flexbox)); or, keeping the pieces
    of a single button all neatly lined up ([Figure 11-4](#fb_button-vert-centered)).
    Flexbox makes what used to be challenging layout effects fairly simple.
  prefs: []
  type: TYPE_NORMAL
- en: '![Power grid layout with flexbox, with buttons aligned on the bottom](assets/css5_1103.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-3\. Power grid layout with flexbox, with buttons aligned on the bottom
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/power-grid-layout.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![Button with many components neatly vertically centered](assets/css5_1104.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-4\. Widget with several components, all vertically centered [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/widget-with-components-vertically-centered.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The classic [“Holy Grail” layout](https://en.wikipedia.org/wiki/Holy_grail_(web_design)),
    with a header, three equal-height columns of varying flexibility, and a footer,
    can be created in a few lines of CSS with either flexbox or grid layout, which
    are covered in the next chapter. Here’s an example of HTML that might represent
    such a layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As the chapter progresses, remember that flexbox is designed for a specific
    type of layout, that of single-dimensional content distribution. It works best
    at arranging information along a single dimension, or axis. While you can create
    grid-like layouts (two-dimensional alignment) with flexbox, this is not its intended
    purpose, and it has significant flaws for this use case. If you find yourself
    pining for two-dimensional layout capabilities, see [Chapter 12](ch12.html#grid-layout).
  prefs: []
  type: TYPE_NORMAL
- en: Flex Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first important concept to fully understand is the *flex container*, also
    known as the *container box*. The element on which `display: flex` or `display:
    inline-flex` is applied becomes the flex container and generates a *flex formatting
    context* for its child nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: These children are *flex items*, whether they are DOM nodes, text nodes, or
    generated-content pseudo-elements. Absolutely positioned children of flex containers
    are also flex items, but each is sized and positioned as though it is the only
    flex item in its flex container.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll first look at all the CSS properties that apply to the flex container,
    including several properties impacting the layout of flex items. We’ll then explore
    the equally important concept of flex items in [“Flex Items”](#flex-items).
  prefs: []
  type: TYPE_NORMAL
- en: Using the flex-direction Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want your layout to go from top to bottom, left to right, right to left,
    or even bottom to top, you can use `flex-direction` to control the main-axis along
    which the flex items get laid out.
  prefs: []
  type: TYPE_NORMAL
- en: The `flex-direction` property specifies how flex items are placed in the flex
    container. It defines the main-axis of a flex container, which is the primary
    axis along which flex items are laid out (see [“Understanding Axes”](#understanding-axis)
    for more details).
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume the following basic markup structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-5](#four-values-flex-dir) shows how that simple list would be arranged
    by applying each of the four values of `flex-direction`, assuming a left-to-right
    language.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The four values of the flex-direction property](assets/css5_1105.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-5\. The four values of the flex-direction property [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-four-values.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default value, `row`, doesn’t look all that different from a bunch of inline
    or floated elements. This is misleading, for reasons you’ll soon see, but notice
    how the other `flex-direction` values affect the arrangement of the list items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can reverse this layout of the items with `flex-direction:
    row-reverse`. The flex items are laid out from top to bottom when `flex-direction:
    column` is set, and from bottom to top if `flex-direction: column-reverse` is
    set, as shown in [Figure 11-5](#four-values-flex-dir).'
  prefs: []
  type: TYPE_NORMAL
- en: We specified left-to-right languages, because the direction of the main-axis
    for `row`—the direction that the flex items are laid out—is the direction of the
    current writing mode. We’ll discuss how writing modes affect flex direction and
    layout in a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Do *not* use `flex-direction` to change the layout for right-to-left languages.
    Rather, use the `dir` attribute in HTML, or the `writing-mode` CSS property described
    in [“Setting Writing Modes”](ch15.html#setting_writing_modes), to indicate the
    language direction. To learn more about language direction and flexbox, see [“Working
    with Other Writing Directions”](#other-writing-directions).
  prefs: []
  type: TYPE_NORMAL
- en: The `column` value sets the flex container’s main-axis to be the same orientation
    as the block axis of the current writing mode. This is the vertical axis in horizontal
    writing modes like English, and the horizontal axis in vertical writing modes
    like traditional Japanese.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, when declaring a `column` direction in English (or a language with the
    same writing direction), the flex items are displayed in the same order as declared
    in the source document, but from top to bottom instead of left to right, so the
    flex items are laid out one on top of the next instead of side by side. Consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Thus, by simply writing a few CSS properties, we can create a nice sidebar-style
    navigation for the list of links we saw earlier as a horizontal row of tabs. For
    the new layout, we change the `flex-direction` from the default value of `row`
    to `column` and move the border from the bottom to the right; [Figure 11-6](#changing-flex-dir)
    shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing flex-direction can completely change the layout of your content](assets/css5_1106.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-6\. Changing the flex direction can completely change the layout [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/changing-flex-direction-change-layout.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `column-reverse` value is similar to `column`, except the main-axis is reversed;
    thus, `main-start` is placed at the *end* of the main-axis, and `main-end` is
    placed at the *start* of the main-axis. In top-to-bottom writing modes, that means
    the flex items are arranged going upward, as shown previously in [Figure 11-5](#four-values-flex-dir).
    The `-reverse` values only change the appearance. The keyboard-navigation tab
    order remains the same as the underlying markup.
  prefs: []
  type: TYPE_NORMAL
- en: What we’ve shown so far is super powerful and makes many layouts a breeze. If
    we include the navigation within a full document, we can see how simple layout
    can be with just a few flexbox property declarations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s expand a little on our preceding HTML example, and include the navigation
    as a component within a home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'By adding a few lines of CSS, we get a nicely laid-out home page ([Figure 11-7](#using_flex_direction_row_and_column)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![Home page layout using +flex-direction:+ +row+ and +column+](assets/css5_1107.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-7\. Home page layout using `flex-direction: row` and `column` [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/home-page-layout-row-and-column.html)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Yes, elements can be flex items while also being flex containers, as you can
    see with the navigation, main, and article elements in this case. The `<body>`
    and `<article>` elements have `column` set as their flex directions, and we let
    `<nav>` and `<main>` default to `row`. And all that with just two lines of CSS!
  prefs: []
  type: TYPE_NORMAL
- en: To be clear, there’s more styling at work in [Figure 11-7](#using_flex_direction_row_and_column).
    Borders, margins, and padding were applied to all the elements, so you can visually
    differentiate the flex items for the sake of learning (we wouldn’t put this less-than-attractive
    site into production!). Otherwise, all we’ve done is simply declare the body,
    navigation, main, and articles as flex containers, making the navigation links,
    main, article, images, paragraphs, and buttons flex items.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Other Writing Directions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re creating websites in English, or another left-to-right (LTR) language,
    you likely want the flex items to be laid out from left to right, and from top
    to bottom. The default value `row` will do that. If you’re writing in Arabic,
    or another right-to-left (RTL) language, you likely want the flex items to be
    laid out from right to left, and from top to bottom. The default value `row` will
    do that, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `flex-direction: row` arranges the flex items in the same direction as
    the text direction, also known as the *writing mode*, whether the language is
    RTL or LTR. While most websites are presented in left-to-right languages, some
    sites are in right-to-left languages, and yet others are top-to-bottom. With flexbox,
    when you change the writing mode, flexbox takes care of changing the flex direction
    for you.'
  prefs: []
  type: TYPE_NORMAL
- en: The writing mode is set by the `writing-mode`, `direction`, and `text-orientation`
    properties, or by the `dir` attribute in HTML. (These are covered in [Chapter 15](ch15.html#text_properties).)
    When the writing mode is right to left, the direction of the main-axis—and therefore
    the flex items within the flex container—will go from right to left when the `flex-direction`
    is `row`. This is illustrated in [Figure 11-8](#four-vals-flex-dir).
  prefs: []
  type: TYPE_NORMAL
- en: '![The four values of flex-direction when direction is right to left, demonstrated
    here with display: inline-flex;](assets/css5_1108.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-8\. The four values of `flex-direction` when writing direction is
    right to left [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-rtl-four-values.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the CSS `direction` value is different from the `dir` attribute value on
    an element, the CSS property value takes precedence over the HTML attribute. The
    specifications strongly recommend using the HTML attribute rather than the CSS
    property.
  prefs: []
  type: TYPE_NORMAL
- en: Vertically written languages include Bopomofo, Egyptian hieroglyphs, Hiragana,
    Katakana, Han, Hangul, Meroitic cursive and hieroglyphs, Mongolian, Ogham, Old
    Turkic, Phags Pa, Yi, and sometimes Japanese. These languages are displayed vertically
    only when a vertical writing mode is specified. If not, all of those languages
    are treated as horizontal.
  prefs: []
  type: TYPE_NORMAL
- en: 'For top-to-bottom languages, `writing-mode: horizontal-tb` is in effect, meaning
    the main-axis is rotated 90 degrees clockwise from the default left to right.
    Thus, `flex-direction: row` goes from top to bottom, and `flex-direction: column`
    proceeds from right to left. [Figure 11-9](#writing_mode_horizontal_tb) shows
    the effects of the various `flex-direction` values on the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![The four values of flex-direction when writing mode is horizontal-tb](assets/css5_1109.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-9\. The four values of `flex-direction` when writing mode is horizontal-tb
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-ttb-four-values.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'That’s right: the rows are vertical, and columns are horizontal. Not only that,
    but the basic `column` direction is right to left, whereas `column-reverse` runs
    left to right. That’s what comes of applying these values to a top-to-bottom,
    right-to-left language as we see here.'
  prefs: []
  type: TYPE_NORMAL
- en: All right, you’ve seen various ways flex direction and writing modes interact.
    But so far, all the examples have shown a single row or column of flex items.
    What happens when the flex items’ *main dimension* (their combined inline sizes
    for `row` or combined block sizes for `column`) don’t fit within the flex container?
    We can either have them overflow the container or can allow them to wrap onto
    additional flex lines. Also, we’ll later talk about how to allow flex items to
    shrink (or grow) to fit the container.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping Flex Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all the flex items don’t fit into the main-axis of the flex container, the
    flex items will not wrap by default, nor will they necessarily resize. Rather,
    the flex items may shrink if allowed to do so via the flex item’s `flex` property
    (see [“Growth Factors and the flex Property”](#growth-factors-and-the-flex-property));
    otherwise, the flex items will overflow the bounding container box.
  prefs: []
  type: TYPE_NORMAL
- en: You can affect this behavior. The `flex-wrap` property sets whether a flex container
    is limited to a single line or is allowed to become multiline when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `flex-wrap` property is set to allow for multiple flex lines via `wrap`
    or `wrap-reverse`, it determines where additional lines of flex items appear:
    either before or after the original line of flex items.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-10](#three_values_of_flex_wrap) demonstrates the three values of
    the `flex-wrap` property when the `flex-direction` value is `row` (and the language
    is LTR). Where these examples show two flex lines, the second line and subsequent
    flex lines are added along the direction of the cross-axis (in this case, the
    vertical axis).'
  prefs: []
  type: TYPE_NORMAL
- en: '![The three values of flex-wrap property](assets/css5_1110.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-10\. The three values of the `flex-wrap` property in a row-oriented
    flow [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-three-values.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When `wrap` is set, the cross-axis is the same as the block axis for `flex-direction:
    row` and `row-reverse`, and is the same as the inline axis of the language for
    `flex-direction: column` and `column-reverse`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is that when `flex-wrap` is set to `wrap-reverse`, the cross-axis
    direction is reversed: subsequent flex lines are drawn above the previous line
    in the case of `row` and `row-reverse`, and to the left of the previous column
    in the case of `column-reverse` (assuming an LTR language such as English).'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll talk more about axes in just a moment, but first, let’s talk about the
    shorthand property that brings flex direction and wrapping together.
  prefs: []
  type: TYPE_NORMAL
- en: Defining Flexible Flows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `flex-flow` property lets you define the wrapping directions of the main-
    and cross-axes, and whether the flex items can wrap to more than one line if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The `flex-flow` shorthand property sets the `flex-direction` and `flex-wrap`
    properties to define the flex container’s wrapping and main- and cross-axes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As long as `display` is set to `flex` or `inline-flex`, omitting `flex-flow`,
    `flex-direction`, and `flex-wrap` is the same as declaring any of the following
    three, all of which have the result shown in [Figure 11-11](#flex_flow_row):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '![flex-flow: row;](assets/css5_1111.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-11\. A row-oriented unwrapped flex flow [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-flow-unwrapped-row.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In LTR writing modes, declaring any of the property values just listed, or omitting
    the `flex-flow` property altogether, will create a flex container with a horizontal
    main-axis that doesn’t wrap. [Figure 11-11](#flex_flow_row) illustrates flex items
    distributed along the horizontal axis, on one line, overflowing a container that’s
    500 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: 'If instead we want a reverse-column-oriented flow with wrapping, either of
    these will suffice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In an LTR language like English, this causes the flex items to flow from bottom
    to top, starting at the left side, and wrap to new columns in the rightward direction.
    In a vertical writing mode like Japanese, which is right-to-left when written
    vertically, the columns would be horizontal, flowing from right to left, and wrap
    top to bottom.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve been using terms like *main-axis* and *cross-axis* without really delving
    into what they mean. It’s time to clarify all that.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Axes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First: flex items are laid out along the main-axis. Flex lines are added in
    the direction of the cross-axis.'
  prefs: []
  type: TYPE_NORMAL
- en: Up until we introduced `flex-wrap`, all the examples had a single line of flex
    items. In that single line, the flex items were laid out along the main-axis,
    in the *main direction*, from main-start to main-end. When we added flex wrapping,
    new flex lines were added along the cross-axis, in the *cross direction*, going
    from cross-start to cross-end.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, a lot of terms are used in that paragraph. Here are some quick
    definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: Main-axis
  prefs: []
  type: TYPE_NORMAL
- en: The axis along which content flows. In flexbox, this is the direction in which
    flex items are flowed.
  prefs: []
  type: TYPE_NORMAL
- en: Main-size
  prefs: []
  type: TYPE_NORMAL
- en: The total length of the content along the main-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Main-start
  prefs: []
  type: TYPE_NORMAL
- en: The end of the main-axis from which content begins to flow.
  prefs: []
  type: TYPE_NORMAL
- en: Main-end
  prefs: []
  type: TYPE_NORMAL
- en: The end of the main-axis toward which content flows, opposite the main-start.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-axis
  prefs: []
  type: TYPE_NORMAL
- en: The axis along which flex lines are “stacked.” In flexbox, this is the direction
    in which new lines of flex items are placed, if flex wrapping is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-size
  prefs: []
  type: TYPE_NORMAL
- en: The total length of the content along the cross-axis.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-start
  prefs: []
  type: TYPE_NORMAL
- en: The edge of the cross-axis where blocks begin to be stacked.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-end
  prefs: []
  type: TYPE_NORMAL
- en: The opposite edge of the cross-axis from the cross-start.
  prefs: []
  type: TYPE_NORMAL
- en: While these terms may sound like logical properties such as `margin-inline-start`,
    they are not the same thing. Here, the physical direction of each changes depending
    on the value of the `flex-direction` property. In fact, the meaning of each term
    in the context of layout depends on the combination of the flex direction, the
    flex wrapping, and the writing mode. Charting all the combinations for every writing
    mode would get difficult, so let’s examine what they mean for LTR languages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s important to understand that direction gets reversed when writing direction
    is reversed. To make explaining (and understanding) flex layout much simpler,
    the rest of the explanations and examples in this chapter are based on an LTR
    writing mode, but will include how writing mode impacts the flex properties and
    features discussed.
  prefs: []
  type: TYPE_NORMAL
- en: When thinking about `flex-direction`, we know that the flex items will start
    being laid out along the main-axis of the flex container, starting from the main-start
    edge and proceeding toward the main-end edge. If the `flex-wrap` property is used
    to allow the container to wrap when the flex items don’t fit onto one line, the
    flex lines are laid out starting from the cross-start edge and proceeding toward
    the cross-end edge.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 11-12](#flex_lines_on_row_and_row_reverse), when we have
    horizontal rows of flex items, the cross-axis is vertical. In these examples,
    with `flex-flow: row wrap` and `flex-flow: row-reverse wrap` set on horizontal
    languages, new flex lines are added below preceding flex lines. The cross-size
    is the opposite of main-size, being height for `row` and `row-reverse` flex directions,
    and width for `column` and `column-reverse` directions, in both RTL and LTR languages.'
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, the `wrap-reverse` value inverts the direction of the cross-axis.
    Normally for `flex-direction` of `row` and `row-reverse`, the cross-axis goes
    from top to bottom, with the cross-start on top and cross-end on the bottom. When
    `flex-wrap` is `wrap-reverse`, the cross-start and cross-end directions are swapped,
    with the cross-start on the bottom, cross-end on top, and the cross-axis going
    from bottom to top. Additional flex lines get added on top of, or above, the previous
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex lines on row and row-reverse when flex-wrap: wrap is set](assets/css5_1112.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-12\. Stacking of row-oriented flex lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the `flex-direction` is set to `column` or `column-reverse`, by default the
    cross-axis goes from left to right in LTR languages, with new flex lines being
    added to the right of previous lines. As shown in [Figure 11-13](#flex_wrap_wrap_reverse),
    when `flex-wrap` is set to `wrap-reverse`, the cross-axis is inverted, with cross-start
    being on the right, cross-end being on the left, the cross-axis going from right
    to left, and additional flex lines being added to the left of the previously drawn
    line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex lines on columns and column-reverse when flex-wrap: wrap-reverse is
    set](assets/css5_1113.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-13\. Stacking of column-oriented flex lines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Arrangement of Flex Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our examples thus far, we’ve skated past the precise arrangement of the flex
    items within each flex line, and how that’s determined. It might seem intuitive
    that a row fills in horizontally, but why should all the items huddle toward the
    main-start edge? Why not have them grow to fill all available space, or distribute
    themselves throughout the line?
  prefs: []
  type: TYPE_NORMAL
- en: For an example of what we’re talking about here, check out [Figure 11-14](#empty-space-dir-main-cross).
    Notice the extra space at the top left. In this bottom-to-top, right-to-left flow,
    new flex items get placed above the previous ones, with new wrap lines being placed
    to the left of each previously filled line.
  prefs: []
  type: TYPE_NORMAL
- en: '![No matter the value of flex flow, the empty space will be in the direction
    of main-end and cross-end](assets/css5_1114.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-14\. Empty space will be in the direction of main-end and cross-end
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: By default, no matter the values of `flex-flow`, empty space outside the flex
    items in a flex container will be in the direction of main-end and cross-end,
    but CSS has properties that allow us to alter that.
  prefs: []
  type: TYPE_NORMAL
- en: Flex Item Alignment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our examples thus far, whenever the flex items do not completely fill the
    flex container, the flex items are all grouped toward the main-start on the main-axis.
    Flex items can be flush against the main-end instead, centered, or even spaced
    out in various ways across the main-axis.
  prefs: []
  type: TYPE_NORMAL
- en: The flex layout specification provides us with flex container properties to
    control the distribution of space. The `justify-content` property controls how
    flex items within a flex line are distributed along the main-axis. The `align-items`
    property defines the default distribution of the flex items along the cross-axis
    of each flex line; this global default can be individually overridden with the
    flex item `align-self` property. When there is more than one flex line and wrapping
    is enabled, the `align-content` property defines how those flex lines are distributed
    along the cross-axis of the flex container.
  prefs: []
  type: TYPE_NORMAL
- en: Justifying Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `justify-content` property enables us to direct the way flex items are distributed
    along the main-axis of the flex container within each flex line, and how to handle
    situations where information might be lost. This property is applied to the flex
    container, *not* the individual flex items.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `safe` and `unsafe` values, introduced with several other values in CSS
    Box Alignment Module Level 3, are recognized but not supported in most browsers
    as of early 2023\. This means the value is ignored, but its presence does not
    render the rest of the declaration invalid.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-15](#justify-content-values) shows the effects of the various values
    in a writing mode like English.'
  prefs: []
  type: TYPE_NORMAL
- en: '![The values of the justify-content property](assets/css5_1115.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-15\. The values of the `justify-content` property [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-values.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With `start` and `flex-start`, flex items are placed flush against main-start.
    With `end` and `flex-end`, flex items are justified toward main-end. The `center`
    option groups the items flush against each other, centered in the middle of the
    main-axis. The `left` and `right` options place items flush against the named
    sides of the box, regardless of the actual axis direction.
  prefs: []
  type: TYPE_NORMAL
- en: The `space-between` value puts the first flex item on a flex line flush with
    main-start and the last flex item in each flex line flush with main-end, and then
    puts an equal amount of space between every pair of adjacent flex items. The `space-evenly`
    value takes the leftover space and splits it so that every gap is the same length.
    This means the spaces at the start and end edges of the main-axis will be the
    same size as the spaces placed between flex items.
  prefs: []
  type: TYPE_NORMAL
- en: By contrast, `space-around` splits up the leftover space and then applies half
    of each portion to each flex item, as if there were noncollapsing margins of equal
    size around each item. Note that this means the space between any two flex items
    is twice that of the spaces at the main-start and main-end of the flex line.
  prefs: []
  type: TYPE_NORMAL
- en: The `stretch` value has no effect as a value of `justify-content` in flexbox.
    As you’ll see in the next chapter, when placed on a grid container, it causes
    grid items to grow in size until they take up all available space in the main-axis
    direction.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We’ll cover `safe` and `unsafe`, which vary how the browser should handle items
    that overflow the container along the cross-axis, in [“Safe and unsafe alignment”](#safe-and-unsafe-alignment).
  prefs: []
  type: TYPE_NORMAL
- en: Justifying and overflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If flex items are not allowed to wrap to multiple lines and overflow their flex
    line, the value of `justify-content` influences the way the flex items will overflow
    the flex container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting `justify-content: start` or `flex-start` explicitly sets the default
    behavior of grouping the flex items toward main-start, placing the first flex
    item of each flex line flush against the main-start side. Each subsequent flex
    item then gets placed flush with the preceding flex item’s main-end side. (Remember,
    the location of the main-start side depends on the flex direction and writing
    mode.) If there isn’t enough room for all the items and wrapping is not allowed,
    the items will overflow the main-end edge. This is illustrated in [Figure 11-16](#justify_content_start).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1116.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-16\. The effects of `start` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-start.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The mirror of this is setting `justify-content: end` or `flex-end`, which puts
    the last flex on a line flush against the main-end with each preceding flex item
    being placed flush with the subsequent item. In this case, if the items aren’t
    allowed to wrap, and if there isn’t enough room for all the items, the items will
    overflow on the main-start edge, as illustrated in [Figure 11-17](#justify_content_end).'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1117.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-17\. The effects of `end` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-end.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Setting `justify-content: center` will pack all the items flush against each
    other, and center them on the center of the flex line instead of packing them
    against the main-start or main-end. If there isn’t enough room for all the items
    and they aren’t allowed to wrap, the items will overflow evenly on both the main-start
    and main-end edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-18](#justify_content_center) illustrates these effects.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1118.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-18\. The effects of `center` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-center.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As the `left` and `right` values, they always start packing from the left or
    right edge of a row, regardless of axis directions. Thus, `justify-content: left`
    will always justify row-based content to the left, whether the main-axis goes
    left to right or right to left. In column-based content, `left` is treated the
    same as `start`, and `right` the same as `end`. Any overflow will occur on the
    opposite side from where the packing started; that is, flex items will overflow
    on the right edge for `justify-content: left` and on the left edge for `right`.'
  prefs: []
  type: TYPE_NORMAL
- en: With those relatively simple cases covered, let’s look at values that alter
    space between and around flex items, and compare them to their wrapped cases.
    Note that if flex items are allowed to wrap onto multiple lines, the space around
    each flex item is based on the available space in their specific flex line only,
    and will not (in most cases) be consistent from one line to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting `justify-content: space-between` puts the first flex item flush with
    main-start and the last flex item on the line flush with main-end, and then puts
    an equal amount of space around each flex item, until the flex line is filled
    (see [Figure 11-19](#justify_content_space-between)). If we have three flex items,
    the same amount of space will be between the first and second items as between
    the second and third, but there will be no extra empty space between the main-start
    and main-end edges of the container and the first and last flex items in the line.
    This means if a line has only one flex item, it will be flush with the main-start
    edge, not centered. If there isn’t enough space to fit all the flex items and
    they aren’t allowed to wrap, the items will overflow on the main-end edge, yielding
    an effect visually indistinguishable from `justify-content: start`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1119.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-19\. The effects of `space-between` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-between.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Setting `justify-content: space-around` evenly distributes the extra space
    on the line around each of the flex items, as if noncollapsing margins of equal
    size were around each element on the main-dimension sides ([Figure 11-20](#justify_content_space-around)).
    Thus, there will be twice as much space between the first and second item as there
    is between main-start and the first item, and main-end and the last item. If there
    isn’t enough room for all the items and they aren’t allowed to wrap, the items
    will overflow evenly on both the main-start and main-end edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1120.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-20\. The effects of `space-around` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-around.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Setting `justify-content: space-evenly` means the user agent counts the items,
    adds one, and then splits any extra space on the line by that many (i.e., if we
    have five items, the amount of space is split into six equal-size portions); see
    [Figure 11-21](#justify_content_space-evenly). One portion of the space is placed
    before each item on the line, as if it were a noncollapsing margin, and the last
    portion is placed after the last item on the list. Thus, the same amount of space
    will appear between the first and second item as there is between main-start and
    the first item, and main-end and the last item. If there isn’t enough room for
    all the items and they aren’t allowed to wrap, the items will overflow evenly
    on both the main-start and main-end edges.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1121.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-21\. The effects of `space-evenly` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-evenly.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `stretch` value has no effect when set as the value of `justify-content`
    on a flex container, and is treated the same as `normal`. As you’ll see in the
    next chapter, when placed on a grid container, it causes the grid items to grow
    in size until they take up all available space in the main-axis direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'And finally, `justify-content: normal` is treated the same as `justify-content:
    start`. This is the case for historical reasons too boring and lengthy to get
    into here, but what it means is that the default value of `justify-content` is
    essentially `start`, even if it is technically `normal`.'
  prefs: []
  type: TYPE_NORMAL
- en: Note in the previous few examples that when flex items are allowed to wrap onto
    multiple lines, the space around each flex item is based on the available space
    in its specific flex line only, and will not (in many cases) be consistent from
    one line to the next.
  prefs: []
  type: TYPE_NORMAL
- en: justify-content example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We took advantage of the default value of `justify-content` in [Figure 11-2](#simple_tabbed_navigation),
    creating a left-aligned navigation bar. By changing the default value to `justify-content:
    flex-end`, we can right-align the navigation bar in English:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that `justify-content` is applied to the flex container. If we’d applied
    to the links themselves, using something like `nav a {justify-content: flex-start;}`,
    no alignment effect would have occurred.'
  prefs: []
  type: TYPE_NORMAL
- en: A major advantage of `justify-content` is that when the writing direction changes
    (say, for RTL writing modes), we don’t have to alter the CSS to get the tabs where
    they need to go. The flex items are always grouped toward main-start when `flex-start`
    is applied; in English, main-start is on the left. For Hebrew, main-start is on
    the right. If `flex-end` is applied and the `flex-direction` is `row`, then the
    tabs go to the right side in English, and the left side in Hebrew, as shown in
    [Figure 11-22](#right_and_left_aligned_navigation).
  prefs: []
  type: TYPE_NORMAL
- en: '![Right- and left-aligned navigation in LTR and RTL languages using justify-content](assets/css5_1122.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-22\. Internationally robust navigation alignment [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-i18n.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This may seem like the main-start and main-end are similar to inline-start and
    inline-end in logical properties. This will feel true when `flex-direction` is
    set to `row`. With `flex-direction:` `row-reverse`, however, the main-start and
    main-end get switched, but the inline-start and inline-end don’t, because the
    inline directions for the flex items remain the same even if their flex order
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could have centered that navigation, as shown in [Figure 11-23](#changing-layout-one-prop):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '![Changing the layout with one property value pair](assets/css5_1123.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-23\. Changing the layout with one property value pair [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-i18n-center.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All the flex items we’ve shown thus far are a single line tall, and therefore
    are the same size in the cross dimension as their sibling flex items. Before discussing
    wrapping flex lines, we need to discuss aligning items of differing dimensions
    along the cross-axis, which is, appropriately enough, called *aligning*.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning Items
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whereas `justify-content` defines how flex items are aligned along the flex
    container’s main-axis, the `align-items` property defines how flex items are aligned
    along its flex line’s cross-axis. As with `justify-content`, `align-items` is
    applied to flex containers, not individual flex items.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While `align-items` sets the alignment for all the flex items within a container,
    the [`align-self` property](#the-align-self-property) enables overriding the alignment
    for individual flex items, as you’ll see in [“The align-self property”](#the-align-self-property).
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 11-24](#vals-align-items), note how the flex items are arranged with
    respect to the cross-axis. (The cross-axis is the block axis for row-flowed flex
    containers, and the inline axis for column-flowed flex containers.)
  prefs: []
  type: TYPE_NORMAL
- en: '![The values of the align-items property when you have a single row or column
    of flex items](assets/css5_1124.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-24\. The values of the `align-items` property for both rows and columns
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/align-items-values-rows-cols.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The default value, `normal`, is treated as `stretch` in flexbox.
  prefs: []
  type: TYPE_NORMAL
- en: For `stretch`, the cross-start edge of each flex item is placed against the
    cross-start edge of the container, and the cross-end edges are also placed against
    the cross-end edge of the container. This happens regardless of the size of the
    content inside each flex item, so a flex item with short content (such as “One”)
    will still have its element box fill out the cross-axis size of the flex container.
  prefs: []
  type: TYPE_NORMAL
- en: With the `center` value, by contrast, the element box is just as large as it
    needs to be to contain the content along the cross-axis, and no bigger. The cross-start
    and -end edges of the flex items are placed the same distance away from the cross-start
    and -end edges of the container, thus centering the flex item’s box within the
    flex container along the cross-axis.
  prefs: []
  type: TYPE_NORMAL
- en: For the various `start` and `end` values, the cross-start or -end edges of the
    flex items are all snugged up against the respective edge of the flex container.
    There are so many ways to say `start` and `end`, mostly for historical reasons
    that are too lengthy and painful to get into here.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that when the items are aligned to the start or end of the cross-axis,
    their inline sizes are (by default) exactly as big as their content needs to be,
    and no wider. It’s as if their `max-width` was set to `max-size`, so that extra
    content can wrap to multiple lines within the flex item, but if no wrapping is
    needed, the element’s inline size won’t fill out the entire flex container’s inline
    size. This is a default behavior of flex items, so if you want flex elements to
    fill out the entire inline size of the flex container, the way block boxes fill
    out their containing block, use the `stretch` value instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `baseline`, the flex items’ first baselines are aligned with one another
    when they can do so, which is to say, when the `flex-direction` is `row` or `row-reverse`.
    Because the font size of each flex item differs, the baseline of each line in
    every flex item differs. The flex item that has the greatest distance between
    its first baseline and its cross-start side will be flush against the cross-start
    edge of the line. The other flex items will be placed so that their first baselines
    line up with the first baseline of the flex item that’s flush against the cross-start
    edge (and thus each other’s first baselines). When `align-items: last baseline;`
    is set, the inverse occurs. The flex item with the greatest distance between its
    last baseline and the cross-end side will be flush against the cross-end edge
    of the line. The other flex items will be placed with their last baseline lined
    up with the last baseline of the flex item that’s flush against the cross-end
    edge, unless overridden by `align-self` (see [“The align-self property”](#the-align-self-property)).
    Since there isn’t a way to align baselines in a columnar flow, `baseline` is treated
    like `start` in these contexts, or `end` in the case of `last baseline`.'
  prefs: []
  type: TYPE_NORMAL
- en: Flex item margins and alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now you have a general idea how each value behaves, but there’s a bit more
    to it than that. In the multiline `align-items` figures that follow, the following
    styles have been applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For each flex line, the cross-start and cross-end edges have been drawn in as
    a red dotted and blue dashed line, respectively. The C, H, D, and I boxes have
    added top or bottom margins. We’ve added a `gap` (which will be discussed a bit
    later in the chapter) between the flex items to make the figures more legible,
    which doesn’t affect the impact of the `align-items` property in this case. The
    J box has its font size increased, which also increases its line height. (This
    will come into play when we discuss the `baseline` value.)
  prefs: []
  type: TYPE_NORMAL
- en: The effects of these margins on both the `stretch` and `center` alignments can
    be seen in [Figure 11-25](#margins-and-align).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1125](assets/css5_1125.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-25\. The effect of margins on cross-axis alignment
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `stretch` value, as its name implies, stretches all “stretchable” flex items
    to be as tall or wide as the tallest or widest flex item on the line. A stretchable
    flex item is one that does not have a non-`auto` value set for any of the sizing
    properties along the cross-axis. In [Figure 11-25](#margins-and-align), that would
    be the `block-size`, `min-block-size`, `max-block-size`, `height`, `min-height`,
    and `max-height` properties. If all are set to `auto`, the flex item is stretchable.
    If not, it is not.
  prefs: []
  type: TYPE_NORMAL
- en: Assuming a flex item is stretchable, its cross-start edge will be flush with
    the flex line’s cross-start edge, and its cross-end edge will be flush with the
    flex line’s cross-end edge. The flex item with the largest cross-size will remain
    its default size, and the other flex items will grow to the size of that largest
    flex item.
  prefs: []
  type: TYPE_NORMAL
- en: What [Figure 11-25](#margins-and-align) shows us is that it’s the outer edge
    of the flex items’ *margins* that will be flush with cross-start and cross-end,
    not their border edges. This is demonstrated by items C, D, H, and I, which appear
    smaller than the other flex items on their flex lines. They’re not, though. It’s
    just that their margins, which are always fully transparent, take up some of the
    stretching space.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If a flex container’s cross-size is constrained, the contents may overflow the
    flex container’s cross-start and/or cross-end edge. The direction of the overflow
    is not determined by the `align-items` property, but rather by the `align-content`
    property, discussed in [“Aligning Flex Lines”](#the-align-content-property). The
    `align-items` property aligns the flex items within the flex line and does not
    directly impact the overflow direction of the flex items within the container.
  prefs: []
  type: TYPE_NORMAL
- en: Baseline alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `baseline` values are a little more complicated. CSS has two possible baseline
    alignments, represented by `first baseline` and `last baseline`. You can also
    use the value `baseline`, which is equivalent to `first baseline`.
  prefs: []
  type: TYPE_NORMAL
- en: With `baseline` (and `first baseline`), the flex items in each line are all
    aligned at the lowest first baseline. For each flex line, the flex item with the
    biggest distance between its baseline and its cross-start margin edge has that
    margin edge placed flush against the cross-start edge of the line, and all other
    flex items’ baselines are lined up with the baseline of that flex item.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this, take a look at the first set of flex items in [Figure 11-26](#align-items_baseline),
    the ones labeled `baseline` (and `first baseline`). For each flex line, the cross-start
    and -end edges are marked with solid red and blue lines, respectively. The baseline
    to which the items in each line are aligned is marked with a dotted line, and
    the element whose baseline is taken as the prime baseline has a lighter background
    and red text.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1126](assets/css5_1126.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-26\. Baseline alignments [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/baseline-alignments.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first line (A through E), it is the C box whose first baseline is used.
    This is because the C box has a top margin, so its first baseline is the farthest
    from the cross-start edge of the flex line. All the other boxes (A, B, D, and
    E) have their first baselines aligned with the first baseline of C.
  prefs: []
  type: TYPE_NORMAL
- en: In the second line (F through J), H’s first baseline is used—again, because
    of its top margin—and so the F, G, I, and J boxes have their first baselines aligned
    with H’s. Here, we can also see how the J box has its first baseline aligned with
    all the others, despite its much bigger font size.
  prefs: []
  type: TYPE_NORMAL
- en: Similar things happen for the flex items labeled with `last baseline`, only
    here, the dominating factors are bottom margins. The D box in the first line has
    a bottom margin, as does the I box in the second line. In both cases, their last
    baselines are the farthest away from the cross-end edge of the line, and so all
    the other flex items in their rows have their last baselines aligned with the
    last baselines of D and I. The dotted lines show the placements of the last baselines
    in each flex line.
  prefs: []
  type: TYPE_NORMAL
- en: In many cases, `first baseline` will look like `start` (and its equivalents,
    such as `flex-start`), and `last baseline` will look like `end`. For example,
    had C lacked a top margin in [Figure 11-26](#align-items_baseline), all the items
    in that first line would have been visibly flush against the top of the flex line,
    instead of pushed away from it. Anytime flex items have different margins, borders,
    padding, font sizes, or line heights on their cross-start side, the `start` and
    `first baseline` will differ. Similarly, any cross-end margins, borders, etc.
    will create a difference between the results of `last baseline` and `end`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any of the baseline values can become `start` when the baselines of the flex
    items are parallel to the cross-axis. For example, suppose we take the flex containers
    in [Figure 11-26](#align-items_baseline) and change them to `flex-direction: column`.
    Now the cross-axis, like the baselines of the English text within, is horizontal.
    Since there’s no way to create an offset from the cross-start edge of the columns
    that will align the text baselines, `baseline` is treated exactly as if it were
    `start` instead; or `end`, in the case of last baseline.'
  prefs: []
  type: TYPE_NORMAL
- en: Safe and unsafe alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In all the previous examples, we let the flex containers be whatever size they
    needed to be to contain the flex lines; that is, we left them at `block-size:
    auto` (or `height: auto`, in old-school CSS terminology). But what happens if
    the block size of a flex container is constrained in some way, perhaps by the
    size of a grid track or an explicit block size value being given? In these situations,
    the `safe` and `unsafe` keywords come into play.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If `safe` alignment is specified, then anytime a flex item would overflow the
    flex container, the flex item is treated as though its `align-self` were set to
    `start`. That would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: On the other hand, if `unsafe` is used, the alignment of flex items is honored
    no matter what that means in terms of overflowing the flex container.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering which is the default, the answer is neither. Instead, when
    neither safe nor unsafe alignment has been declared, browsers should default to
    `unsafe` behavior *unless* this would cause flex items to overflow the scrollable
    area of their nearest ancestor’s scroll container, in which case they should align
    to the cross-axis edge farthest away from the edge they would otherwise overflow.
    [Figure 11-27](#safe_unsafe_alignment) shows some examples.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, only Firefox browsers fully support the `safe` and `unsafe`
    keywords, and they have to be written first in the value (as shown in this section)
    even though the formal syntax for the property does not require this placement.
    All other evergreen browsers recognize these keywords as valid, but they have
    no impact on the layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1127.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-27\. `Safe` versus `unsafe` alignments
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The align-self property
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want to change the alignment of one or more flex items, but not all,
    you can include the `align-self` property on the flex items you would like to
    align differently. This property takes the same values as `align-items` and is
    used to override the `align-items` property value on a per-flex-item basis.
  prefs: []
  type: TYPE_NORMAL
- en: You can override the cross-axis alignment of any individual flex item with the
    `align-self` property, as long as it’s represented by an element or pseudo-element.
    You cannot override the alignment for anonymous flex items (non-empty text node
    children of flex containers). Their `align-self` always matches the value of `align-items`
    of their parent flex container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default value of `align-items` is `stretch`, but let’s make that explicit
    in the following code, which will let us set different `align-self` values for
    the second flex item, as illustrated in [Figure 11-28](#align_self_fig):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 1128](assets/css5_1128.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-28\. Changing individual flex-item alignments [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/gaps-between-items.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: All these flex items have `align-self`’s default value of `auto`, meaning they
    inherit the alignment (in this case, `stretch`) from the container’s `align-items`
    property. The exception in each example is the second flex item, which has been
    given the `align-self` value shown underneath.
  prefs: []
  type: TYPE_NORMAL
- en: As we said, all the values of `align-items` can be used for `align-self`, including
    the values for first and last baseline alignment, `safe` and `unsafe` alignment,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning Flex Lines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In nearly all the previous examples, the flex container’s cross-size was always
    as tall as it needed to be: no `block-size` or `height` was declared on the container,
    so it defaulted to `height: auto`. Because of this, the flex container grew to
    fit the content.'
  prefs: []
  type: TYPE_NORMAL
- en: Had the cross-size of the container been set to a specific size, there may have
    been extra space at the cross-end, or not enough space to fit the content. In
    such cases, CSS allows us to control the overall placement of flex lines with
    the `align-content` property.
  prefs: []
  type: TYPE_NORMAL
- en: The `align-content` property dictates how any extra cross-direction space in
    a flex container is distributed between and around flex lines. Although the values
    and concepts are largely the same, `align-content` is different from the previously
    discussed `align-items` property, which dictates flex item positioning within
    each flex line.
  prefs: []
  type: TYPE_NORMAL
- en: Think of `align-content` as similar to the way `justify-content` aligns individual
    items along the main-axis of the flex container, but it does so for flex lines
    with regard to the cross-axis of the container. This property applies to multiline
    flex containers, having no effect on nonwrapping and otherwise single-line flex
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following CSS as a base and assume the flex items have no margins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-29](#distribution_of_extra_space) demonstrates the possible values
    of the `align-content` property, as used in conjunction with that CSS. We’ve concentrated
    on the primary alignment values, and left out examples of things such as safe
    and unsafe alignment as well as the first and last baseline alignments.'
  prefs: []
  type: TYPE_NORMAL
- en: With a height of 14 ems, the flex container is taller than the default combined
    heights of the three flex lines. Given the larger text of some flex items and
    the various bits of padding and borders, each flex container in [Figure 11-29](#distribution_of_extra_space)
    has approximately 3 ems of leftover space.
  prefs: []
  type: TYPE_NORMAL
- en: '![The distribution of extra space for the different values of align-content](assets/css5_1129.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-29\. Distribution of extra space for primary values of `align-content`
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/align-content.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With the values `normal`, `stretch`, `center`, `start`, `flex-start`, `end`,
    and `flex-end`, the free space is distributed outside the flex lines, as illustrated
    in [Figure 11-29](#distribution_of_extra_space). These act in the same ways as
    they do for `align-items`. With the value `stretch`, the extra space is evenly
    distributed to all the flex lines, increasing their cross-size until their edges
    touch. For the others, the flex lines are kept together, with the leftover space
    placed to one side or another.
  prefs: []
  type: TYPE_NORMAL
- en: For the remaining values, the flex lines are pushed apart and the leftover space
    distributed in various ways. Let’s assume the approximately 3 ems of leftover
    space is equal to 120 pixels. (It’s big text, OK?)
  prefs: []
  type: TYPE_NORMAL
- en: 'Given `space-between`, about 60 pixels of space is between each adjacent pair
    of flex lines, each half of the leftover 120 pixels. With `space-around`, the
    space is evenly distributed around each line: the 120 pixels are split into three
    pieces, since there are three flex lines. This puts 20 pixels of noncollapsed
    space (half of 40 pixels) on the cross-start and cross-end sides of each flex
    line, so we have 20 pixels of extra space at the cross-start and cross-end sides
    of the flex container, and 40 pixels of space between adjacent flex lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `space-evenly`, there are four spaces to insert: one before each flex line,
    and an extra space after the last flex line. With three lines, that means four
    spaces, with 30 pixels for each space. That places 30 pixels of space at the cross-start
    and cross-end sides of the flex container, and 30 pixels between adjacent flex
    lines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Continuing this example for the stretch value, you’ll note that the `stretch`
    value is different: with `stretch`, the lines stretch with the extra space evenly
    distributed among the flex lines rather than between them. In this case, 40 pixels
    are added to each of the flex lines, causing all three lines to grow in height
    by an equal amount—that is, the extra space is divided equally, not proportionally,
    with the exact same amount added to each.'
  prefs: []
  type: TYPE_NORMAL
- en: If there isn’t enough room for all the lines, they will overflow at cross-start,
    cross-end, or both, depending on the value of the `align-content` property. This
    is shown in [Figure 11-30](#align_content_overflowing), where the dotted box with
    a light-gray background represents a short flex container. (A little bit of inline
    padding was added to each flex container to make it more obvious where it starts
    and ends.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Appearance of align-content property when lines are overflowing the container](assets/css5_1130.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-30\. Flex-line overflow directions for each value of `align-content`
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The only difference in the CSS between this and [Figure 11-29](#distribution_of_extra_space)
    is the height of the flex container. Here, the flex containers have been reduced
    to a height of 7 ems, so as to create flex containers not tall enough to encompass
    all their flex lines (which, as you may recall, total around 10 ems in height).
  prefs: []
  type: TYPE_NORMAL
- en: When the flex lines overflow the flex container, the `align-content` values
    `normal`, `stretch`, `start`, `flex-start`, `baseline`, `last baseline`, and `space-between`
    cause them to overflow on the cross-end side, whereas the values `center`, `space-around`,
    and `space-evenly` evenly overflow both the cross-end and cross-start sides. Only
    `align-content:` `end` and `flex-end` cause flex lines to overflow on just the
    cross-start side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep in mind that these values are not top- or bottom-centric. If the cross-axis
    goes upward, `align-content: flex-start` will start aligning flex lines from the
    bottom and work upward from there, potentially overflowing the top (cross-end)
    edge. For that matter, when the flow direction is columnar, the cross-axis will
    be horizontal, in which case the cross-start and -end edges will be the right
    or left edges of the flex container.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the place-content Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CSS offers a shorthand property that collapses `align-content`, which we just
    covered, and `justify-content`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can supply either one or two values. If you supply one, `place-content`
    acts as if you had set both `align-content` and `justify-content` to the same
    value. In other words, the following two rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The exception to this behavior occurs if the value is baseline-related, such
    as `first baseline`. In that case, the value for `justify-content` is set to `start`,
    making the following two rules equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If two values are given, the second is the value of `justify-content`. Thus,
    the following two rules are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: That’s pretty much all there is to `place-content`. If you’d rather align and
    justify content by using a single shorthand property, `place-content` does that.
    Otherwise, use the individual properties separately.
  prefs: []
  type: TYPE_NORMAL
- en: Two more `place-` shorthand properties are covered in [Chapter 12](ch12.html#grid-layout).
  prefs: []
  type: TYPE_NORMAL
- en: Opening Gaps Between Flex Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flex items are, by default, rendered with no space held open between them. Space
    can appear between items thanks to values of `justify-content` or by adding margins
    to flex items, but these approaches are not always ideal. For example, margins
    can lead to flex line wrapping when it isn’t actually needed, and even using `justify-content`
    values like `space-between` can result in having no space separating the items.
    It would be easier if there was a way to define what are essentially minimum gap
    sizes, and thanks to the gap properties, there is.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these properties inserts space of the declared size between adjacent
    flex items. This space is often referred to as a *gutter*. For historical reasons,
    the default value, `normal`, equates to 0 pixels (no space) in flexbox and grid
    containers, and `1` em in multicolumn layout. Otherwise, you can supply a single
    length or percentage value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we have a set of flex items that will wrap to multiple flex lines,
    and we want to open a 15-pixel gap between the flex lines. Here’s what that CSS
    would look like, illustrated in [Figure 11-31](#row-gaps):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/css5_1131.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-31\. Gaps between rows of flex items
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: No margins are set on the flex items, to be clear. Exactly 15 pixels of space
    is between each flex line (row), thanks to the value of `row-gap`. In essence,
    `row-gap` acts as if it were called `block-axis-gap`, so if the writing mode were
    changed to something like `vertical-rl`, thus making the block axis horizontal,
    the rows would flow top to bottom, and the gaps between them would be to their
    right and left sides (which are their block-start and block-end sides).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that there are gaps only between rows: there are no gaps placed between
    the flex items and the block-start and -end edges of the flex container. If you
    want to open gaps of the same size along those container edges, you would write
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In a like manner, we can open spaces between the flex items along the inline
    axis by using `column-gap`. We can modify the earlier example to push items apart
    as follows, with the result shown in [Figure 11-32](#column-gaps):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/css5_1132.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-32\. Gaps between adjacent flex items along the inline axis
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Here, leftover space remains at the inline-end side of the flex lines, with
    each line having its own amount of space. That’s because the flex items weren’t
    given a `justify-content` value, so they defaulted to `start`. This means the
    gaps between the flex items are all exactly 15 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to change the value of `justify-content` to `space-between`, then
    in any flex line with leftover space, the gaps between flex items will be increased
    by an equal amount, meaning they will be separated by more than 15 pixels. If
    there’s a line where the inline sizes of all the flex items and all the gaps exactly
    equals the inline length of the flex line, 15 pixels of space will be between
    each flex item.
  prefs: []
  type: TYPE_NORMAL
- en: This is why `row-gap` and `column-gap` are really more like minimum separation
    distances between flex items or flex lines. The gaps don’t count as “leftover
    space,” any more than the flex items do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gaps are inserted between the outer margin edges of adjacent flex items, so
    if you add margins to your flex items, the actual visible space between two flex
    items will be the width of the gap plus the widths of the margins. Consider the
    following, which is illustrated in [Figure 11-33](#column-gaps-plus-margins):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/css5_1133.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-33\. Gaps and margins combine to open more space
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Now the open spaces between flex items are all 35 pixels wide: 15 pixels from
    the `gap` property, plus 20 pixels (10 + 10) from the inline-side margins set
    on the flex items.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus far we’ve used length values, but what about percentages? Any percentage
    value used for a gap is taken to be a percentage of the container’s size along
    the relevant axis. Thus, given `column-gap: 10%`, the gaps will be 10% the inline
    size of the flex container. If the container is 640 pixels wide along the inline
    axis, the column gaps will be 64 pixels each.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with rows can be a little more complicated. If you define an explicit
    block size, percentages are just a percentage of that block size. A `block-size`
    (which could also be set with `height` or `width`) of `25em` and a `row-gap` of
    `10%` means row gaps will be 2.5 ems wide. This same sort of thing can also happen
    if the block size happens to be larger than the sum total of the rows’ block sizes.
  prefs: []
  type: TYPE_NORMAL
- en: 'But when the block size is solely determined by the block sizes of the rows
    added together, any percentage value could lead to a *cyclic calculation*: each
    calculation changes the value being calculated, ad infinitum. Suppose a flex container
    has three flex lines, each exactly 30 pixels tall. The flex container is set so
    its height is `auto`, so it will “shrink-wrap” the flex lines, making it 90 pixels
    tall (we’re assuming no padding here, but the principles are the same regardless).
    A `row-gap` of `10%` would mean 9-pixel row gaps, and inserting the 2 row gaps
    would add 18 pixels of height. That would increase the container’s height to 108
    pixels, which would mean the 10%-wide gaps are now 10.8 pixels, so the container
    height increases again, which increases the row gaps, which increases container
    height, which…'
  prefs: []
  type: TYPE_NORMAL
- en: To avoid this sort of infinite-loop scenario, the gaps are set to be zero-width
    whenever a cyclic calculation would happen, and everyone moves on with their lives.
    In practice, this means that percentage values for row gaps are useful only in
    a narrow range of cases, whereas they can be more broadly useful for column gaps.
    [Figure 11-34](#percentage-based-row-gaps) shows examples of percentage row gaps.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1134.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-34\. Percentage-based row gaps with and without explicit container
    heights
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can set up both column and gap rows on a flex container by supplying the
    two properties individually, or you can use the shorthand property `gap`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to supply only one value to `gap`, in which case it will be used for
    both the row and column gaps. If you supply two values, the first will always
    be used for row gaps, and the second for column gaps. Thus you get the results
    shown in [Figure 11-35](#using-the-gap-shorthand) from the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/css5_1135.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-35\. Row and column gaps set using the `gap` shorthand property
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The original `gap` property was defined in CSS Multiple Columns, with additional
    hyphenated gap properties defined in CSS Grid as `grid-row-gap`, `grid-column-gap`,
    and `grid-gap`, before being made more generic and available in grid, flexbox,
    and multicolumn contexts. Browsers are required to treat the older properties
    as aliases for the newer, more generic properties; e.g., `grid-gap` is an alias
    for `gap`. So if you find the older grid gap properties in legacy CSS, you can
    change them to the newer names, but if not, they’ll still work as if you had.
  prefs: []
  type: TYPE_NORMAL
- en: Flex Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, you saw how to globally lay out all the flex items
    within a flex container by styling that container. The flexible box layout specification
    provides several additional properties applicable directly to flex items. With
    these flex-item-specific properties, we can more precisely control the layout
    of individual flex containers’ children.
  prefs: []
  type: TYPE_NORMAL
- en: What Are Flex Items?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As you’ve seen throughout the chapter, we create flex containers by adding
    `display: flex` or `display: inline-flex` to an element that has child nodes.
    The children of those flex containers are called *flex items*—whether they’re
    child elements, non-empty text nodes between child elements, or generated content.
    In [Figure 11-36](#display_flex_containers_children), each letter is enclosed
    in its own element, including the space between words, so that each letter and
    space becomes a flex item.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Items with display: flex; become flex containers, and their non-absolutely
    positioned children become flex items](assets/css5_1136.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-36\. The child nodes are flex items, and the parent node is a flex
    container [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-within-container.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When it comes to text-node children of flex containers, if the text node is
    not empty (containing content other than whitespace), it will be wrapped in an
    *anonymous flex item*, behaving like its flex-item siblings. While these anonymous
    flex items do inherit all the flex properties set by the flex container, just
    like their DOM node siblings, they are not directly targetable with CSS. We can’t
    directly set any of the flex-item-specific properties on them. Thus, in the following
    markup, the two elements (`<strong>` and `<em>`) and the text “they’re what’s
    for” become flex items, for a total of three flex items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Generated content (via `::before` and `::after`) can be styled directly; therefore,
    all the properties discussed in this chapter apply equally to generated content
    and to element nodes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whitespace-only text nodes within a flex container are ignored, as if their
    `display` property were set to `none`, as the following code example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, with the `display` property set to `flex`, the unordered
    list is the flex container, and its child list items are all flex items. These
    list items, being flex items, are flex-level boxes—semantically still list items,
    but not list items in their presentation. They are not block-level boxes either.
    Rather, they participate in their container’s flex-formatting context. The whitespace
    between and around the `<li>` elements—the line feeds and indenting tabs and/or
    spaces—is completely ignored. The links are not flex items themselves, but are
    descendants of the flex items the list items have become.
  prefs: []
  type: TYPE_NORMAL
- en: Flex Item Features
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The margins of flex items do not collapse. The `float` and `clear` properties
    don’t have an effect on flex items and do not take a flex item out of flow. In
    effect, `float` and `clear` are ignored when applied to flex items. (However,
    the `float` property can still affect box generation by influencing the `display`
    property’s computed value.) Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `aside` is the flex container. The comment and whitespace-only
    text nodes are ignored. The text node containing “Some text” is wrapped in an
    anonymous flex item. The header, image, and text node containing “Some text” are
    all flex items. Because the image is a flex item, the `float` is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though images and text nodes are inline-level nodes, because they are
    flex items, they are blockified as long as they are not absolutely positioned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This markup is similar to the previous code example, except in this example
    we’ve added a link within the non-empty text node. In this case, we are creating
    five flex items illustrated in [Figure 11-37](#display_flex_five_items). The comment
    and whitespace-only text nodes are ignored. The header, the image, the text node
    before the link, the link, and the text node after the link are all flex items.
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1137.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-37\. Five flex items in an aside [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-in-aside.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The text nodes containing “Some text” and “and more text” are wrapped in anonymous
    flex items, represented in [Figure 11-37](#display_flex_five_items) by the dashed
    boxes (the dashes having been added for illustrative purposes) with no background.
    The header, image, and link, being actual DOM nodes, can be styled directly with
    CSS, as you can see with the border styling. The anonymous flex containers are
    not directly targetable, and so will have only whatever styles they pick up from
    the flex container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `vertical-align` has no effect on a flex item, except as it affects
    the alignment of text within the flex item. Setting `vertical-align: bottom` on
    a flex item will make all the text inside that flex item align to the bottom of
    their line boxes; it will not push the flex item to the bottom of its container.
    (That’s what `align-items` and `align-self` are for.)'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute Positioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `float` will not actually float a flex item, setting `position: absolute`
    is a different story. The absolutely positioned children of flex containers, just
    like any other absolutely positioned element, are taken out of the flow of the
    document.'
  prefs: []
  type: TYPE_NORMAL
- en: More to the point, they do not participate in flex layout and are not part of
    the document flow. However, they can be impacted by the styles set on the flex
    container, just as a child can be impacted by a parent element that isn’t a flex
    container. In addition to inheriting any inheritable properties, the flex container’s
    properties can affect the origin of the positioning.
  prefs: []
  type: TYPE_NORMAL
- en: 'The absolutely positioned child of a flex container is affected by both the
    `justify-content` value of the flex container and its own `align-self` value,
    if there is one. For example, if you set `align-self: center` on the absolutely
    positioned child, it will start out centered with respect to the flex container
    parent’s cross-axis. From there, the element or pseudo-element can be moved by
    properties like `top`, `bottom`, margins, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: The `order` property (explained in [“The order Property”](#the-order-property))
    may not impact where the absolutely positioned flex container child is drawn,
    but it does impact the order in which it is drawn in relation to its siblings.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum Widths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Figure 11-38](#three-vals-flex-wrap), you’ll note that the flex line inside
    the container with the `nowrap` default `flex-wrap` value overflows its flex container.
    This is because when it comes to flex items, the implied value of `min-width`
    is `auto`, rather than `0`. Originally in the specification, if the items didn’t
    fit onto that single main-axis, they would shrink. However, the specification
    of `min-width` was altered as applied to flex items. (Traditionally, the default
    value for `min-width` is `0`.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex items overflowing their container when min-width defaults to auto, unless
    wrapping is allowed](assets/css5_1138.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-38\. Flex container overflow with minimum-width flex items [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-container-overflow-with-min-width.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If you set `min-width` to a width narrower than the computed value of `auto`—for
    example, if you declare `min-width: 0`—the flex items in the `nowrap` example
    will shrink to be narrower than their actual content (in some cases). If the items
    are allowed to wrap, they will be as narrow as possible to fit their content,
    but no narrower. [Figure 11-39](#three-vals-min-width-0) illustrates both situations.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex items in nonwrapping containers will shrink if the min-width is explicitly
    set to 0, which is the default in Safari 9](assets/css5_1139.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-39\. Zero-minimum-width flex items in nonwrapped and wrapped flex
    containers [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-zero-min-width-flex-items.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Flex-Item-Specific Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While flex items’ alignment, order, and flexibility are to some extent controllable
    via properties set on their flex container, several properties can be applied
    to individual flex items for more granular control.
  prefs: []
  type: TYPE_NORMAL
- en: The `flex` shorthand property, along with its component properties of `flex-grow`,
    `flex-shrink`, and `flex-basis`, controls the flexibility of the flex items. *Flexibility*
    is the amount by which a flex item can grow or shrink along the main-axis.
  prefs: []
  type: TYPE_NORMAL
- en: The flex Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The defining aspect of flex layout is the ability to make the flex items *flex*:
    altering their width or height to fill the available space in the main dimension.
    A flex container distributes free space to its items proportionally to their flex
    grow factor, or shrinks them to prevent overflow proportionally to their flex
    shrink factor. (We’ll explore these concepts momentarily.)'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the `flex` shorthand property on a flex item, or defining the individual
    properties that make up the shorthand, enables you to define the grow and shrink
    factors. If there is excess space, you can tell the flex items to grow to fill
    that space. Or not. If there isn’t enough room to fit all the flex items within
    the flex container at their defined or default sizes, you can tell the flex items
    to shrink proportionally to fit into the space. Or not.
  prefs: []
  type: TYPE_NORMAL
- en: This is all done with the `flex` property, which is a shorthand property for
    `flex-grow`, `flex-shrink`, and `flex-basis`. While these three subproperties
    can be used separately, it is highly recommended to always use the `flex` shorthand,
    for reasons we’ll soon cover.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `flex` property specifies the components of a flexible length: the *length*
    of the flex item being the length of the flex item along the main-axis (see [“Understanding
    Axes”](#understanding-axis)). When a box is a flex item, `flex` is consulted to
    determine the size of the box, instead of the main-axis size dimension property
    (`height` or `width`). The *components* of the `flex` property include the flex
    growth factor, flex shrink factor, and the flex basis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The *flex basis* determines how the flex growth and shrink factors are implemented.
    As its name suggests, the `flex-basis` component of the flex shorthand is the
    basis on which the flex item determines how much it can grow to fill available
    space or how much it should shrink to fit all the flex items when there isn’t
    enough space. It’s the initial size of each flex item, and can be restricted to
    that specific size by specifying `0` for both the growth and shrink factors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding CSS, the flex item will have a main-axis size of exactly 200
    pixels, as the flex basis is `200px`, and it is allowed to neither grow nor shrink.
    Assuming that the main-axis is horizontal, the value of `width` (`50%`) is ignored.
    Similarly, a value for `height` would be ignored if the main-axis were vertical.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This override of `height` and `width` occurs outside the cascade, so you can’t
    even override the flex basis by adding `!important` to the `height` or `width`
    value of a flex item.
  prefs: []
  type: TYPE_NORMAL
- en: If the target of a selector is not a flex item, applying the `flex` property
    to it will have no effect.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand the three components that make up the `flex` shorthand
    property in order to be able to use it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: The flex-grow Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `flex-grow` property defines whether a flex item is allowed to grow when
    space is available, and, if so, how much it will grow proportionally relative
    to the growth of other flex-item siblings.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Declaring the growth factor via the `flex-grow` property is *strongly* discouraged
    by the authors of the specification itself. Instead, declare the growth factor
    as part of the `flex` shorthand. We’re discussing the property here only to explore
    how growth works.
  prefs: []
  type: TYPE_NORMAL
- en: The value of `flex-grow` is always a number. Negative numbers are not valid.
    You can use non-integers if you like, just as long as they’re 0 or greater. The
    value sets the *flex growth factor*, which determines how much the flex-item will
    grow relative to the rest of the flex item siblings as the flex container’s free
    space is distributed.
  prefs: []
  type: TYPE_NORMAL
- en: If any space is available within the flex container, the space will be distributed
    proportionally among the children with a nonzero positive growth factor based
    on the various values of those growth factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, assume a `750px`-wide horizontal flex container with three flex
    items, each set to `width: 100px`. A total of 300 pixels of space is taken up
    by the flex items, leaving 450 pixels of “leftover” or available space (since
    750 – 300 = 450). This is the first scenario shown in [Figure 11-40](#variety_of_growth_factor_scenarios):
    none of the flex items are permitted to grow.'
  prefs: []
  type: TYPE_NORMAL
- en: '![With a growth factor of 0, the flex item will not grow; any positive value
    will allow the item to grow proportionally to the value](assets/css5_1140.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-40\. A variety of flex-growth scenarios [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-variety.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In the second scenario in [Figure 11-40](#variety_of_growth_factor_scenarios),
    only one of the flex items (the third) has been given a growth factor. The declaration
    we gave it is `flex-grow: 1`, but it could be any positive number the browser
    can understand. In this case, with two items having no growth factor and the third
    having a growth factor, all of the available space is given to the flex item with
    a growth factor. Thus, the third flex item gets all 450 pixels of available space
    added to it, arriving at a final width of 550 pixels. The `width: 100px` applied
    to it elsewhere in the styles is overridden.'
  prefs: []
  type: TYPE_NORMAL
- en: In the third and fourth scenarios, the same flex item widths result despite
    the differing flex growth factors. Let’s consider the third scenario, where the
    growth factors are 1, 1, and 3\. The factors are all added together to get a total
    of 5\. Each factor is then divided by that total to get a proportion. So here,
    the three values are each divided by 5, yielding 0.2, 0.2, and 0.6.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each proportion is multiplied by the available space to get the amount of growth.
    Thus:'
  prefs: []
  type: TYPE_NORMAL
- en: 450 px × 0.2 = 90 px
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 450 px × 0.2 = 90 px
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 450 px × 0.6 = 270 px
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Those are the growth portions added to each flex item’s starting width of 100
    pixels. Thus, the final widths are 190 pixels, 190 pixels, and 370 pixels, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth scenario has the same result, because the proportions are the same.
    Imagine for a moment that we alter the growth factors to be 0.5, 1, and 1.5\.
    Now the math works out such that the first flex item gets one-sixth of the available
    space, the second gets a third, and the third gets half. This results in the flex
    items’ final widths being 175, 250, and 425 pixels, respectively. Had we declared
    growth factors of 0.1, 0.1, and 0.3, or 25, 25, and 75, or really any combination
    of numbers with a 1:1:3 correspondence, the result would have been identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'As noted in [“Minimum Widths”](#min-width), if no width or flex basis is set,
    the flex basis defaults to `auto`, meaning each flex item basis is the width of
    its nonwrapped content. The `auto` value is special: it defaults to `content`
    unless the item has a width set on it, at which point the flex basis becomes that
    width. The `auto` value is discussed in [“Automatic flex basis”](#auto). Had we
    not set the width in this example scenario, with our smallish font size, we would
    have had more than 450 pixels of distributable space along the main-axis.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The main-axis size of a flex item is impacted by the available space, the growth
    factor of all the flex items, and the flex basis of the item. We have yet to cover
    [flex basis](#flex-basis), but that time is coming soon!
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s consider flex items with different `width` values as well as different
    growth factors. In [Figure 11-41](#even-dist-avail-space), in the second example,
    we have flex items that are 100 pixels, 250 pixels, and 100 pixels wide, with
    growth factors of 1, 1, and 3, respectively, in a container that is 750 pixels
    wide. This means we have 300 pixels of extra space to distribute among a total
    of five growth factors (since 750 – 450 = 300). Each growth factor is therefore
    60 pixels (300 ÷ 5). Therefore, the first and second flex items, with a `flex-grow`
    value of `1`, will each grow by 60 pixels. The last flex item will grow by 180
    pixels, since its `flex-grow` value is `3`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The available space is evenly distributed to each growth factor; any positive
    value will allow the item to grow proportionally to the value.](assets/css5_1141.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-41\. Mixed widths and growth factors [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-mixed-width-and-factors.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'To recap, the available space in the flex container, the growth factors, and
    final width of each flex item are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Available space: 750 px – (100 px + 250 px + 100 px) = 300 px'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Growth factors: 1 + 1 + 3 = 5'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Width of each growth factor: 300 px ÷ 5 = 60 px'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When flexed, the width of the flex items, based on their original width and
    growth factors, become
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 100 px + (1 × 60 px) = 160 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 250 px + (1 × 60 px) = 310 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 100 px + (3 × 60 px) = 280 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: which adds up to 750 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Growth Factors and the flex Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `flex` property takes up to three values—the growth factor, shrink factor,
    and basis. The first positive non-null numeric value, if there is one, sets the
    growth factor (i.e., the `flex-grow` value). When the growth and shrink factors
    are omitted in the `flex` value, the growth factor defaults to `1`. However, if
    neither `flex` nor `flex-grow` is declared, the growth factor defaults to `0`.
    Yes, really.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall the second example in [Figure 11-40](#variety_of_growth_factor_scenarios),
    where the flex growth factors were 0, 0, and 1. Because we declared a value for
    `flex-grow` only, the flex basis was set to `auto`, as if we had declared the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'So that means the first two flex items had no growth factor, a shrink factor,
    and a flex basis of `auto`. Had we used `flex` in the examples in [Figure 11-40](#variety_of_growth_factor_scenarios)
    instead of ill-advisedly using `flex-grow`, the flex basis in each case would
    be set to `0%`, as if this had been done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'As the shrink factor defaults to `1` and the basis defaults to `0%`, the following
    CSS is identical to the preceding snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This would have the result shown in [Figure 11-42](#flex_basis_is_0). Compare
    this to [Figure 11-40](#variety_of_growth_factor_scenarios) to see how things
    have changed (or not).
  prefs: []
  type: TYPE_NORMAL
- en: 'You may notice something odd in the first two scenarios: the flex basis been
    set to 0, and only the last flex item in the second scenario has a positive value
    for flex growth. Logic would seem to dictate that the widths of the three flex
    items should be 0, 0, and 750 pixels, respectively. But logic would also dictate
    that it makes no sense to have content overflowing its flex item if the flex container
    has the room for all the content, even if the basis is set to `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: The specification authors thought of this quandary. When the `flex` property
    declaration explicitly sets or defaults the flex basis to `0%` and a flex item’s
    growth factor is `0`, the length of the main-axis of the nongrowing flex items
    will shrink to the smallest length the content allows, or smaller. In [Figure 11-42](#flex_basis_is_0),
    that minimum length is the width of the widest sequence of letters, “flex:” (including
    the colon).
  prefs: []
  type: TYPE_NORMAL
- en: As long as a flex item has a visible overflow and no explicitly set value for
    `min-width` (or `min-height` for vertical main-axes), the minimum width (or minimum
    height) will be the smallest width (or height) that the flex item needs to be
    to fit the content or the declared `width` (or `height`), whichever is smaller.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex grow looks different when the flex basis is 0, and some items are not
    allowed to grow](assets/css5_1142.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-42\. Flex sizing when using the flex shorthand [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-sizing-when-using-shorthand.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'If all items are allowed to grow, and the flex basis for each flex item is
    `0%`, *all* of the space, rather than just excess space, is distributed proportionally
    based on the growth factors. In the third example in [Figure 11-42](#flex_basis_is_0),
    two flex items have growth factors of 1, and one flex item has a growth factor
    of 3\. We thus have a total of five growth factors:'
  prefs: []
  type: TYPE_NORMAL
- en: (2 × 1) + (1 × 3) = 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With five growth factors, and a total of 750 pixels, each growth factor is
    worth 150 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: 750 px ÷ 5 = 150 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the default flex item size is 100 pixels, the flex basis of `0%` overrides
    that, leaving us with two flex items at 150 pixels each and the last flex item
    with a width of 450 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: 1 × 150 px = 150 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3 × 150 px = 450 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Similarly, in the last example of [Figure 11-42](#flex_basis_is_0), with two
    flex items having growth factors of 0.5, and one flex item having a growth factor
    of 1.5, we have a total of 2.5 growth factors:'
  prefs: []
  type: TYPE_NORMAL
- en: (2 × 0.5) + (1 × 1.5) = 2.5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With a 2.5 growth factor, and a total of 750 pixels, each growth factor is
    worth 300 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: 750 px ÷ 2.5 = 300 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'While the default flex item size is 100 pixels, the flex basis of 0% overrides
    that, leaving us with two flex items at 150 pixels each and the last flex item
    with a width of 450 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: 0.5 × 300 px = 150 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 1.5 × 300 px = 450 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, this is different from declaring only `flex-grow`, because that means
    the flex basis defaults to `auto`. In that case, only the extra space, not all
    the space, is distributed proportionally. When using `flex`, on the other hand,
    the flex basis is set to `0%`, so the flex items grow in proportion to the total
    space, not just the leftover space. [Figure 11-43](#flex-grow-basis-0) illustrates
    the difference.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex grow looks different when the flex basis is 0, and sometimes are not
    allowed to grow](assets/css5_1143.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-43\. Flex sizing differences between using `flex` and `flex-grow`
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-differences-between-flex-and-flex-grow.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now let’s talk about flex shrinking factors, which are in some ways the inverse
    of flex growth factors, but are in other ways different.
  prefs: []
  type: TYPE_NORMAL
- en: The flex-shrink Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The <*`flex-shrink`*> portion of the `flex` shorthand property specifies the
    *flex shrink* *factor*. It can also be set via the `flex-shrink` property.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Declaring the shrink factor via the `flex-shrink` property is *strongly* discouraged
    by the authors of the specification itself. Instead, declare the shrink factor
    as part of the `flex` shorthand. We’re discussing the property here only to explore
    how shrinking works.
  prefs: []
  type: TYPE_NORMAL
- en: The shrink factor determines how much a flex item will shrink relative to the
    rest of its flex-item siblings when there isn’t enough space for them all to fit,
    as defined by their content and other CSS properties. When omitted in the shorthand
    `flex` property value or when both `flex` and `flex-shrink` are omitted, the shrink
    factor defaults to `1`. Like the growth factor, the value of `flex-shrink` is
    always a number. Negative numbers are not valid. You can use non-integer values
    if you like, just as long as they’re greater than 0.
  prefs: []
  type: TYPE_NORMAL
- en: Basically, the shrink factor defines how “negative available space” is distributed
    when there isn’t enough room for the flex items, and the flex container isn’t
    allowed to otherwise grow or wrap. See [Figure 11-44](#flex-shrink-0).
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 11-44](#flex-shrink-0) is similar to [Figure 11-40](#variety_of_growth_factor_scenarios),
    except the flex items are set to `width: 300px` instead of 100 pixels. We still
    have a 750-pixel-wide flex container. The total width of the three items is 900
    pixels, meaning the content starts out 150 pixels wider than the parent flex container.
    If the items are not allowed to shrink or wrap (see [“Wrapping Flex Lines”](#the-flex-wrap-property)),
    they will burst out from the fixed-size flex container. This is demonstrated in
    the first example in [Figure 11-44](#flex-shrink-0): those items will not shrink
    because they have a zero shrink factor. Instead, they overflow the flex container.'
  prefs: []
  type: TYPE_NORMAL
- en: '![A flex shrink factor of 0 will not allow flex items to shrink; any positive
    value will enable the item to shrink proportionally relative to sibling flex items
    that are allowed to shrink on the same flex line](assets/css5_1144.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-44\. A variety of flex shrinking scenarios [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-variety.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the second example in [Figure 11-44](#flex-shrink-0), only the last flex
    item is set to be able to shrink. The last flex item is thus forced to do all
    the shrinking necessary to enable all the flex items to fit within the flex container.
    With 900 pixels of content needing to fit into our 750-pixel container, we have
    150 pixels of negative available space. The two flex items with no shrink factor
    stay at 300 pixels wide. The third flex item, with a positive value for the shrink
    factor, shrinks 150 pixels, to end up 150 pixels wide. This enables the three
    items to fit within the container. (In this example, the shrink factor is `1`,
    but had it been `0.001` or `100` or `314159.65` or any other positive number the
    browser could understand, the result would be the same.)
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third example, we have positive shrink factors for all three flex items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is the only one of the three `flex` shorthand properties we declared,
    this means the flex items will behave as if we had declared the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If all items are allowed to shrink, as is the case here, the shrinking is distributed
    proportionally based on the shrink factors. This means the larger a flex item’s
    shrink factor, as compared to the shrink factors of its sibling flex items, the
    more the item will shrink in comparison.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a parent 750 pixels wide, and three flex items with a width of 300 pixels,
    150 “negative space” pixels need to be shaved off the flex items that are allowed
    to shrink (which is all of them in this example). With two flex items having a
    shrink factor of 1, and one flex item having a shrink factor of 3, we have a total
    of five shrink factors:'
  prefs: []
  type: TYPE_NORMAL
- en: (2 × 1) + (1 × 3) = 5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With five shrink factors, and a total of 150 pixels needing to be shaved off
    all the flex items, each shrink factor is worth 30 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: 150 px ÷ 5 = 30 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The default flex item size is 300 pixels, leading us to have two flex items
    with a width of 270 pixels each and the last flex item having a width of 210 pixels,
    which totals 750 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: 300 px – (1 × 30 px) = 270 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 300 px – (3 × 30 px) = 210 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following CSS produces the same outcome: while the numeric representations
    of the shrink factors are different, they are proportionally the same, so the
    flex item widths will be the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Note that the flex items in these examples will shrink to 210, 210, and 270
    pixels, respectively, *as long as* the content (like media objects or nonwrappable
    text) within each flex item is not wider than 210, 210, or 270 pixels, respectively.
    If the flex item contains content that cannot wrap or otherwise shrink in the
    main dimension, the flex item will not shrink any further.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the first flex items contain an image 300 pixels wide. That first
    flex item cannot shrink, and other flex items can shrink; therefore, it will not
    shrink, as if it had a null shrink factor. In this case, the first item would
    be 300 pixels, with the 150 pixels of negative space distributed proportionally
    based on the shrink factors of the second and third flex items.
  prefs: []
  type: TYPE_NORMAL
- en: 'That being the case, we have four unimpeded shrink factors (one from the second
    flex item, and three from the third) for 150 pixels of negative space, with each
    shrink factor being worth 37.5 pixels. The flex items will end up 300, 262.5,
    and 187.5 pixels, respectively, for a total of 750 pixels, as shown here and illustrated
    in [Figure 11-45](#flex-shrink-with-image):'
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 300 px – (0 × 37.5 px) = 300.0 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 300 px – (1 × 37.5 px) = 262.5 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 300 px – (3 × 37.5 px) = 187.5 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](assets/css5_1145.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-45\. Shrinking being impeded by flex-item content [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-with-image.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Had the image been 296 pixels wide, that first flex item would have been able
    to shrink by 4 pixels. The remaining 146 pixels of negative space would then be
    distributed among the four remaining factors, yielding 36.5 pixels per factor.
    The flex items would then be 296, 263.5, and 190.5 pixels wide, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: If all three flex items contained nonwrappable text or media 300 pixels or wider,
    none of the three flex items would not shrink, appearing similar to the first
    example in [Figure 11-44](#flex-shrink-0).
  prefs: []
  type: TYPE_NORMAL
- en: Proportional shrinkage based on width and shrink factor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding code examples are fairly simple because all the flex items start
    with the same width. But what if the widths are different? What if the first and
    last flex items have a width of 250 pixels and the middle flex item has a width
    of 500 pixels, as shown in [Figure 11-46](#flex-items-shrink-factor)?
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex items shrink proportionally relative to their shrink factor](assets/css5_1146.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-46\. Flex items shrink proportionally relative to their shrink factor
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-proportionally-relative-to-factor.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Flex items shrink proportionally relative to both the shrink factor *and* the
    flex item’s width, with the width often being the width of the flex item’s content
    with no wrapping. In [Figure 11-46](#flex-items-shrink-factor), we are trying
    to fit 1,000 pixels into a flex container that’s 750 pixels wide. We have an excess
    of 250 pixels to be removed from five shrink factors.
  prefs: []
  type: TYPE_NORMAL
- en: If this were a `flex-grow` situation, we would simply divide 250 pixels by 5,
    allocating 50 pixels per growth factor. If we were to shrink that way, we would
    get flex items 200, 550, and 100 pixels wide, respectively. But that’s not how
    shrinking actually works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we have 250 pixels of negative space to proportionally distribute. To
    get the shrink factor proportions, we divide the negative space by the total of
    the flex items’ widths (more precisely, their lengths along the main-axis) times
    their shrink factors:'
  prefs: []
  type: TYPE_NORMAL
- en: <math alttext="upper S h r i n k upper P e r c e n t equals StartFraction upper
    N e g a t i v e upper S p a c e Over left-parenthesis left-parenthesis upper W
    i d t h Baseline 1 times upper S h r upper F Baseline 1 right-parenthesis plus
    period period period plus left-parenthesis upper W i d t h upper N times upper
    S h r upper F upper N right-parenthesis right-parenthesis EndFraction" display="block"><mrow><mi>S</mi>
    <mi>h</mi> <mi>r</mi> <mi>i</mi> <mi>n</mi> <mi>k</mi> <mi>P</mi> <mi>e</mi> <mi>r</mi>
    <mi>c</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>N</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi></mrow>
    <mrow><mo>(</mo><mo>(</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mn>1</mn><mo>×</mo><mi>S</mi><mi>h</mi><mi>r</mi><mi>F</mi><mn>1</mn><mo>)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo>(</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mi>N</mi><mo>×</mo><mi>S</mi><mi>h</mi><mi>r</mi><mi>F</mi><mi>N</mi><mo>)</mo><mo>)</mo></mrow></mfrac></mrow></math>
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this equation, we find the shrink percentage:'
  prefs: []
  type: TYPE_NORMAL
- en: = 250 px ÷ [(250 px × 1) + (500 px × 1) + (250 px × 3)]
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: = 250 px ÷ 1500 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: = 0.166666667 (16.67%)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we reduce each flex item by 16.67% times the value of `flex-shrink`, we
    end up with flex items that are reduced as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 250 px × (1 × 16.67%) = 41.67 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 500 px × (1 × 16.67%) = 83.33 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 250 px × (3 × 16.67%) = 125 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each reduction is then subtracted from the starting sizes of 250, 500, and 250
    pixels, respectively. Thus we have flex items that are 208.33, 416.67, and 125
    pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: Differing basis values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the shrink factor has been set to `0`, and both the width and flex basis
    of a flex item are set to `auto`, the item’s content will not wrap, even when
    you think it should. Conversely, any positive shrink value enables content to
    wrap. Because shrinking is proportional based on the shrink factor, if all the
    flex items have similar shrink factors, the content should wrap over a similar
    number of lines.
  prefs: []
  type: TYPE_NORMAL
- en: In the three examples shown in [Figure 11-47](#flex_items_shrink_proportionally),
    the flex items do not have a declared width. Therefore, the width is based on
    the content, because `width` defaults to `auto`. The flex container has been made
    520 pixels wide instead of our usual 750 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1147](assets/css5_1147.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-47\. Flex items shrink proportionally relative to their shrink factor
    and content [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-proportionally-relative-to-factor-and-content.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note that in the first example, where all the items have the same `flex-shrink`
    value, all content wraps over four lines. In the second example, the first flex
    item has a shrink factor that’s half the value of the other flex items, so it
    wraps the content over (roughly) half the number of lines. This is the power of
    the shrink factor.
  prefs: []
  type: TYPE_NORMAL
- en: In the third example, with no shrink factor, the text doesn’t wrap at all, and
    the flex items overflow the container by quite a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, this “line-balancing” and refusal-to-wrap behavior is not consistent
    across browsers. If you see different results when trying this out for yourself,
    that may be why.
  prefs: []
  type: TYPE_NORMAL
- en: Because the `flex` property’s shrink factor reduces the width of flex items
    proportionally, the number of lines of text in the flex items will grow or shrink
    as the width shrinks or grows, leading to similar height content within sibling
    flex items when the shrink factors are similar.
  prefs: []
  type: TYPE_NORMAL
- en: In the examples, take the contents of the flex items to be 280, 995, and 480
    pixels, respectively—which are the widths of the nonwrapping flex items in the
    third example (as measured by the developer tools, then rounded to make this example
    a little simpler). This means we have to fit 1,755 pixels of content into a 520-pixel-wide
    flex container by shrinking the flex items proportionally based on their shrink
    factor. We have 1,235 pixels of negative available space to proportionally distribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that you can’t rely on web inspector tools to figure out shrink factors
    for production. We’re going through this exercise to show how shrink factors work.
    If minutia isn’t your thing, feel free to jump to [“The flex-basis Property”](#flex-basis).
  prefs: []
  type: TYPE_NORMAL
- en: In our first example, the flex items will end up with the same, or approximately
    the same, number of text lines. This is because flex items shrink proportionally,
    based on the width of their content.
  prefs: []
  type: TYPE_NORMAL
- en: 'We didn’t declare any widths, and therefore can’t simply use an explicit element
    width as the basis for our calculations, as we did in the previous examples. Rather,
    we distribute the 1,235 pixels of negative space proportionally based on the widths
    of the content—280, 995, and 480 pixels, respectively. We determine 520 is 29.63%
    of 1,755\. To determine the width of each flex item with a shrink factor of 1,
    we multiply the content width of each flex item by 29.63%:'
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 280 px × 29.63% = 83 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 995 px × 29.63% = 295 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 480 px × 29.63% = 142 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With the default of `align-items: stretch` (see [“Aligning Items”](#the-align-items-property)),
    a three-column layout will have three columns of equal height. By using a consistent
    shrink factor for all flex items, you can indicate that the actual content of
    these three flex items should be of approximately equal height—though, by doing
    this, the widths of those columns will not necessarily be uniform.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the second example in [Figure 11-47](#flex_items_shrink_proportionally),
    the flex items don’t all have the same shrink factor. The first flex item will,
    proportionally, shrink half as much as the others. We start with the same widths:
    280, 995, and 480 pixels, respectively, but their shrink factors are 0.5, 1.0,
    and 1.0. Because we know the widths of the content, the shrink factor (*X*) can
    be found mathematically:'
  prefs: []
  type: TYPE_NORMAL
- en: 280 px + 995 px + 480 px = 1,615 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (0.5 × 280 px) + (1 × 995 px) + (1 × 480 px) = 1,235 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*X* = 1,235 px ÷ 1,615 px = 0.7647'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can find the final widths now that we know the shrink factor. If the shrink
    factor is 76.47%, `item2` and `item3` will shrink by that amount, whereas `item1`
    will shrink by 38.23% (because its `flex-shrink` value is half the others). The
    amount of shrinkage in each case is rounded off to the nearest whole number:'
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 280 px × 0.3823 = 107 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 995 px × 0.7647 = 761 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 480 px × 0.7647 = 367 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Thus, the final widths of the flex items are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 280 px – 107 px = 173 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 995 px – 761 px = 234 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 480 px – 367 px = 113 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The total combined widths of these three flex items is 520 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Adding in varying shrink and growth factors makes it all a little less intuitive.
    That’s why you likely want to always declare the `flex` shorthand, preferably
    with a width or basis set for each flex item. If this doesn’t make sense yet,
    don’t worry; we’ll cover a few more examples of shrinking as we discuss `flex-basis`.
  prefs: []
  type: TYPE_NORMAL
- en: Responsive flexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Allowing flex items to shrink proportionally allows for responsive objects
    and layouts that can shrink proportionally without breaking. For example, you
    can create a three-column layout that smartly grows and shrinks without media
    queries, as shown on a wide screen in [Figure 11-48](#set_diff_values) and narrow
    screen in [Figure 11-49](#set_diff_values-2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '![By setting different values for growth, shrink, basis, and min-width, you
    can create responsive layouts, with or without media queries](assets/css5_1148.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-48\. A wide flexbox layout
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![css5 1149](assets/css5_1149.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-49\. A narrow flexbox layout [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-homepage.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, if the viewport is greater than 1,000 pixels, only the middle
    column grows because only the middle column is provided with a positive growth
    factor. We also dictate that below the 1,000-pixel-wide mark, all the columns
    shrink.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take it bit by bit. The `<nav>` and `<aside>` elements have the following
    CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: They don’t grow from their basis but can shrink at equal rates. This means they’ll
    have the width of their flex basis by default. If they do need to shrink, they’ll
    shrink to a minimum width of `150px` and then stop shrinking. However, if either
    one has an element that’s more than 150 pixels wide, whether it’s an image or
    a run of text, it will stop shrinking as soon as it reaches the width of that
    bit of content. Suppose a 180-pixel image dropped into the `<aside>` element.
    It would stop shrinking as soon as it reaches 180 pixels wide. The `<nav>` would
    keep shrinking down to 150 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<main>` element, on the other hand, has these styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Thus, the `<main>` element can grow if there’s space for it to do so. Since
    it’s the only flex item that can grow, it gets all the growth. Given a browser
    window 1,300 pixels wide, the two side columns will be 200 pixels wide each, leaving
    900 pixels of width for the center column. In shrinking situations, the center
    column will shrink twice as fast as the other two elements. Thus, if the browser
    window is 900 pixels wide, each side column will be 175 pixels wide, and the center
    column 550 pixels wide.
  prefs: []
  type: TYPE_NORMAL
- en: Once the window reaches 800 pixels wide, the side columns will reach their `min-width`
    values of `150px`. From then on, any narrowing will be taken up by the center
    column.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to be clear, you are not required to use pixels in these situations. You
    don’t even have to use the same unit measures for various flex basis values. The
    previous example could be rewritten like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We won’t go through all the math here, but the general approach is to set flex
    basis values on character widths for improved readability, with some lower limits
    based on character widths and others on viewport width.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Flexbox can be useful for a one-dimensional page layout like the one shown in
    this section, with only three columns in a line. For anything more complex, or
    for a more powerful set of options, use grid layout. (See [Chapter 12](ch12.html#grid-layout).)
  prefs: []
  type: TYPE_NORMAL
- en: The flex-basis Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you’ve already seen, a flex item’s size is impacted by its content and box-model
    properties and can be reset via the three components of the `flex` property. The
    <*`flex-basis`*> component of the `flex` property defines the initial or default
    size of flex items, before extra or negative space is distributed—before the flex
    items are allowed to grow or shrink according to the growth and shrink factors.
    It can also be set via the `flex-basis` property.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Declaring the flex basis via the `flex-basis` property is *strongly* discouraged
    by the authors of the specification itself. Instead, declare the flex basis as
    part of the `flex` shorthand. We’re discussing the property here only to explore
    the flex basis.
  prefs: []
  type: TYPE_NORMAL
- en: The flex basis determines the size of a flex item’s element box, as set by `box-sizing`.
    By default, when a block-level element is not a flex item, the size is determined
    by the size of its parent, content, and box-model properties. When no size properties
    are explicitly declared or inherited, the size defaults to its individual content,
    border, and padding, which is 100% of the width of its parent for block-level
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: The flex basis can be defined using the same length value types as the `width`
    and `height` properties—for example, `5vw`, `12%`, and `300px`.
  prefs: []
  type: TYPE_NORMAL
- en: The universal keyword `initial` resets the flex basis to the initial value of
    `auto`, so you might as well declare `auto`. In turn, `auto` evaluates to the
    `width` (or `height`), if declared. If the value of `width` (or `height`) is set
    to `auto`, the value of `flex-basis` is evaluated to `content`. This causes the
    flex item to be sized based on the content of the flex item, though the exact
    method for doing so is not made explicit in the specification.
  prefs: []
  type: TYPE_NORMAL
- en: The content keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to lengths and percentages, `flex-basis` supports the `min-content`,
    `max-content`, `fit-content`, and `content` keywords. We covered the first three
    in [Chapter 6](ch06.html#basic-visual-formatting), but `fit-content` deserves
    a revisit here, and `content` needs to be explored.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using `fit-content` as the value for `flex-basis`, the browser will do
    its best to balance all the flex items in a line so that they are similar in block
    size. Consider this code, which is illustrated in [Figure 11-50](#flex-basis-fit-sizing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/css5_1150.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-50\. Fit-content flex-basis sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first flex line, the flex basis of the flex items is set to 25%, meaning
    each flex item starts out with 25% the width of the flex line as its sizing basis,
    and is flexed from there at the browser’s discretion. In the second flex line,
    the flex items are set to use `fit-content` for their flex basis. Notice that
    more content leads to wider flex items, and less to narrower items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also notice that the heights (more properly, the block sizes) of the flex items
    are all the same, though this is not guaranteed: in certain situations, some of
    the flex items could be a bit taller than the others—say, by having one flex item’s
    content wrap to one more line than the others’. They should all be very close
    to the same, though.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a good illustration of one of the strengths of flexbox: you can give
    a general direction to the layout engine and have it do the rest of the work.
    Here, rather than having to figure out which widths should be assigned to which
    flex items in order to balance out their heights, you tell it `fit-content` and
    let it figure out the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `content` keyword has results generally similar to `fit-content`,
    though some differences exist. A `content` basis is the size of the flex item’s
    content—that is, the length of the main-axis size of the longest line of content
    or widest (or tallest) media object. It’s the equivalent of declaring `flex-basis:
    auto; inline-size: auto;` on a flex item.'
  prefs: []
  type: TYPE_NORMAL
- en: The value `content` has the effects shown in [Figure 11-51](#content_basis_width).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1151](assets/css5_1151.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-51\. Sizing flex items on a `content` basis [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-content-basis.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first and third examples, the width of the flex item is the size of the
    content; and the flex basis is that same size. In the first example, the flex
    items’ width and basis are approximately 132 pixels. The total width of the three
    flex items side by side is 396 pixels, with a few pixels of space between the
    items, all fitting easily into the parent container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third example, we have set a null shrink factor (`0`): this means the
    flex items cannot shrink, so they won’t shrink or wrap to fit into the fixed-width
    flex container. Rather, they are the width of their nonwrapped text. That width
    is also the value of the flex basis. The three flex items’ widths, and thus their
    basis values, are approximately 309, 1,037 pixels, and 523 pixels, respectively.
    You can’t see the full width of the second flex item or the third flex item at
    all, but they’re in the [chapter files](https://meyerweb.github.io/csstdg5figs/11-flexbox).'
  prefs: []
  type: TYPE_NORMAL
- en: The second example contains the same content as the third example, but the flex
    items are defaulting to a shrink factor of 1, so the text in this example wraps
    because the flex items can shrink. Thus, while the width of the flex item is not
    the width of the content, the flex basis—the basis by which it will proportionally
    shrink—is the width of the items’ contents.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third example in [Figure 11-51](#content_basis_width) is also a good illustration
    of what would happen with the `max-content` keyword with `flex-shrink: 0`: the
    flex basis for each item will be the maximum size of its content. If flex shrinking
    is allowed, then the browser will start with the `max-content` for the basis of
    each item’s flexing, and shrink them down from there. The difference between the
    two is captured in the following code and illustrated in [Figure 11-52](#max_content_basis_width):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/css5_1152.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-52\. Sizing flex items on a `max-content` basis, with and without
    shrinking
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first example, where shrinking is not allowed, each flex item is as wide
    as its content can get without wrapping. This causes the flex items to overflow
    the container (because `flex-wrap` is not set to `wrap`). In the second example,
    where `flex-shrink` is set to `1`, the browser shrinks the flex items equally
    until they all fill out the flex container without overflowing it. Note that the
    second of the four items is a little taller than the others, because its shrinking
    happens to require wrapping the content to one more line than the other items.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a `min-content` flex basis, the reverse happens. Consider the following,
    illustrated in [Figure 11-53](#min_content_basis_width):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '![](assets/css5_1153.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-53\. Sizing flex items on a `min-content` basis, with and without
    growing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first example, flex items are as narrow as possible while still fitting
    their content. For elements containing text, this makes them very tall, given
    that the block axis is vertical. (Note that the full heights of the flex items
    in the first example have been clipped to keep the figure to a reasonable size.)
    In the second example, the items are allowed to grow, so they start from the `min-content`
    size and their widths are grown equally until they all fill out the flex container
    without overflowing it.
  prefs: []
  type: TYPE_NORMAL
- en: In the browser used to create [Figure 11-53](#min_content_basis_width), the
    widths of the flex items in the first example added up to 361.1 pixels (rounded
    to the nearest tenth of a pixel), with 20 pixels of space between each flex item.
    This means from the left edge of the first item to the right edge of the last
    item is about 420.1 pixels. To arrive at the result in the second example, given
    that the width of the flex container is 1,200 pixels, the difference between the
    container width and content width is 1,200 – 420.1 = 778.9 pixels. This difference
    is divided by 4, yielding approximately 194.7 pixels, and the width of each of
    the four flex items is increased by that amount.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic flex basis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When set to `auto`, whether explicitly or by default, `flex-basis` is the same
    as the main-axis size of the element, had the element not been turned into a flex
    item. For length values, `flex-basis` resolves to the `width` or `height` value,
    with the exception that when the value of `width` or `height` is `auto`, the flex-basis
    value falls back to `content`.
  prefs: []
  type: TYPE_NORMAL
- en: When the flex basis is `auto`, and all the flex items can fit within the parent
    flex container, the flex items will be their preflexed size. If the flex items
    don’t fit into their parent flex container, the flex items within that container
    will shrink proportionally based on their nonflexed main-axis sizes (unless the
    shrink factor is 0).
  prefs: []
  type: TYPE_NORMAL
- en: 'When there are no other properties setting the main-axis size of the flex items
    (that is, there’s no `inline-size`, `min-inline-size`, `width`, or `min-width`
    set on these flex items), and `flex-basis: auto` or `flex: 0 1 auto` is set, the
    flex items will be only as wide as they need to be for the content to fit, as
    seen in the first example in [Figure 11-54](#when_flex_basis_set). In this case,
    they are the width of the text “flex-basis: auto,” which is approximately 110
    pixels. The flex items are their preflexed size, as if set to `display: inline-block`.
    In this example, they’re grouped at main-start because the `justify-content` property,
    the flex container’s `justify-content` defaults to `flex-start`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the second example in [Figure 11-54](#when_flex_basis_set), each flex item
    has a flex basis of `auto` and an explicitly declared width. The main-axis size
    of the elements, had they not been turned into flex items, would be 100, 150,
    and 200 pixels, respectively. And so they are here, since they fit into the flex
    container without any overflow along the main-axis.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1154](assets/css5_1154.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-54\. Auto flex basis and flex item widths [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-auto-basis-and-widths.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the third example in [Figure 11-54](#when_flex_basis_set), each of the flex
    items has a flex basis of `auto` and a very large explicitly declared width. The
    main-axis size of the elements, had they not been turned into flex items, would
    be 2,000, 3,000, and 4,000 pixels, respectively. Since they could not possibly
    fit into the flex container without overflowing along the main-axis, and their
    flex shrink factors have all defaulted to `1`, they shrink until they fit into
    the flex container. You can do the math to find out how big they are using the
    process outlined in [“Differing basis values”](#differing-bases); as a hint, the
    width of the third flex item should be reduced from 4,000 pixels to 240 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Default values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When neither `flex-basis` nor `flex` is set, the flex item’s main-axis size
    is the preflex size of the item, as the default value is `auto`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 11-55](#when_no_flex_properties_are_set): the flex basis values
    are defaulting to `auto`, the growth factor is defaulting to `0`, and the shrink
    factor of each item is defaulting to `1`. For each flex item, the flex basis is
    its individual `width` value. That means the flex basis values are being set to
    the values of the `width` properties: 100, 200, and 300 pixels in the first example,
    and 200, 400, and 200 pixels in the second example. As the combined widths of
    the flex items are 600 pixels and 800 pixels, respectively, both of which are
    greater than the main-axis size of the 540-pixel-wide containers, they are all
    shrinking proportionally to fit.'
  prefs: []
  type: TYPE_NORMAL
- en: '![When no flex properties are set, the flex item''s main-axis size will be
    the pre-flex size of the item](assets/css5_1155.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-55\. Default sizing of flex items [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-default-sizing.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the first example, we are trying to fit 600 pixels in 540 pixels, so each
    flex item will shrink by 10% to yield flex items that are 90, 180, and 270 pixels
    wide. In the second example, we are trying to fit 800 pixels into 540 pixels,
    so they all shrink 32.5%, making the flex items’ widths 135, 270, and 135 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Length units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous examples, the `auto` flex basis values defaulted to the declared
    widths of the various flex items. CSS provides other options; for example, we
    can use the same length units for our flex-basis value as we do for `width` and
    `height`.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1156](assets/css5_1156.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-56\. Sizing flex items with length-unit flex basis values [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-width-vs-length.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'When we have both `flex-basis` and `width` (or `height`, for vertical main-axes)
    values, the basis trumps the width (or height). Let’s add basis values to the
    first example from [Figure 11-55](#when_no_flex_properties_are_set). The flex
    items include the following CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The widths are overridden by the basis values. The flex items shrink down to
    270 pixels, 180 pixels, and 90 pixels, respectively. Had the container *not* had
    a constrained width, the flex items would have been 300 pixels, 200 pixels, and
    100 pixels, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the declared flex basis can override the main-axis size of flex items,
    the size can be affected by other properties, such as `min-width`, `min-height`,
    `max-width`, and `max-height`. These are not ignored. Thus, for example, an element
    might have `flex-basis: 100px` and `min-width: 500px`. The minimum width of `500px`
    will be respected, even though the flex basis is smaller.'
  prefs: []
  type: TYPE_NORMAL
- en: Percentage units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Percentage values for `flex-basis` are calculated relative to the size of the
    main dimension of the flex container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve already seen the first example in [Figure 11-57](#percentage-val-flex-basis);
    it’s included here to recall that the width of the text “flex-basis: auto” in
    this case is approximately 110 pixels wide. In this case only, declaring `flex-basis:
    auto` looks the same as writing `flex-basis: 110px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: In the second example in [Figure 11-57](#percentage-val-flex-basis), the first
    two flex items have a flex basis of `auto` with a default `width` of `auto`, which
    is as if their flex basis were set to `content`. As we’ve noted previously, the
    `flex-basis` of the first two items ends up being the equivalent of 110 pixels,
    as the content in this case happens to be 110 pixels wide. The last item has its
    `flex-basis` set to `100%`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The percentage value for flex-basis is relative to the width of the flex
    container](assets/css5_1157.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-57\. Sizing flex items with percentage flex basis values [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-percentage.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The percentage value is relative to the parent, which is 540 pixels. The third
    flex item, with a basis of `100%`, is not the only flex item within the nonwrapping
    flex container. Thus, it will not grow to be 100% of the width of the parent flex
    container *unless* its shrink factor is set with a null shrink factor, meaning
    it can’t shrink, or if it contains nonwrappable content that is as wide or wider
    than the parent container.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Remember: when the flex basis is a percent value, the main-axis size is relative
    to the parent, which is the flex container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With our three flex basis values, if the content is indeed 110 pixels wide,
    and the container is 540 pixels wide (ignoring other box-model properties for
    simplicity’s sake), we have a total of 760 pixels to fit in a 540-pixel space.
    Thus we have 220 pixels of negative space to distribute proportionally. The shrink
    factor is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Shrink factor = 220 px ÷ 760 px = 28.95%
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each flex item will be shrunk by 28.95%, becoming 71.05% of the width it would
    have been, had it not been allowed to shrink. We can figure the final widths:'
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 110 px × 71.05% = 78.16 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 110 px × 71.05% = 78.16 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 540 px × 71.05% = 383.68 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These numbers hold true as long as the flex items can be that small—that is,
    as long as none of the flex items contain media or nonbreaking text wider than
    78.16 pixels or 383.68 pixels. This is the widest these flex items will be as
    long as the content can wrap to be that width or narrower. We say “widest” because
    if one of the other two flex items can’t shrink to be as narrow as this value,
    they’ll both have to absorb some of that negative space.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third example in [Figure 11-57](#percentage-val-flex-basis), the `flex-basis:
    auto` item wraps over three lines. The CSS for this example is the equivalent
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We declare the `flex-basis` of the three flex items to be `70%`, `auto`, and
    `80%`, respectively. Remembering that in our scenario `auto` is the width of the
    nonwrapping content, which in this case is approximately 110 pixels, and our flex
    container is 540 pixels, the basis values are equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 70% × 540 px = 378 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'item2 = widthOfText(“flex-basis: auto”) ≈ 110 px'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 80% × 540 px = 432 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we add the widths of these three flex items’ basis values, they have a
    total combined width of 920 pixels, which needs to fit into a flex container 540
    pixels wide. Thus we have 380 pixels of negative space to remove proportionally
    among the three flex items. To figure out the ratio, we divide the available width
    of our flex container by the sum of the widths of the flex items that they would
    have if they couldn’t shrink:'
  prefs: []
  type: TYPE_NORMAL
- en: Proportional width = 540 px ÷ 920 px = 0.587
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because the shrink factors are all the same, this is fairly simple. Each item
    will be 58.7% of the width it would be if it had no flex-item siblings:'
  prefs: []
  type: TYPE_NORMAL
- en: item1 = 378 px × 58.7% = 221.8 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 110 px × 58.7% = 64.6 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 432 px × 58.7% = 253.6 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What happens when the container is a different width? Say, 1,000 pixels? The
    flex basis would be 700 pixels (70% × 1,000 pixels), 110 pixels, and 800 pixels
    (80% × 1,000 pixels), respectively, for a total of 1,610 pixels:'
  prefs: []
  type: TYPE_NORMAL
- en: Proportional width = 1,000 px ÷ 1,610 px = 0.6211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item1 = 700 px × 62.11% = 434.8 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item2 = 110 px × 62.11% = 68.3 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: item3 = 800 px × 62.11% = 496.9 px
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because with a basis of 70% and 80%, the combined basis values of the flex items
    will always be wider than 100%, no matter how wide we make the parent, all three
    items will always shrink.
  prefs: []
  type: TYPE_NORMAL
- en: If the first flex item can’t shrink for some reason—whether because of unshrinkable
    content, or another bit of CSS setting its `flex-shrink` to `0`—it will be 70%
    of the width of the parent, 378 pixels in this case. The other two flex items
    must shrink proportionally to fit into the remaining 30%, or 162 pixels. In this
    case, we expect widths to be 378 pixels, 32.875 pixels, and 129.125 pixels. As
    the text “basis:” is wider than that—assume 42 pixels—we get 378 pixels, 42 pixels,
    and 120 pixels. [Figure 11-58](#flex-basis-rel-main-axis-size) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 1158](assets/css5_1158.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-58\. While the percentage value for `flex-basis` is relative to the
    width of the flex container, the main-axis size is impacted by its siblings [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-percentage-main-axis.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Testing this out on your device will likely have slightly different results,
    as the width of the text “flex-basis: auto” may not be the same for you, depending
    on the font that gets used to render the text. (We used Myriad Pro, with fallbacks
    to Helvetica and any generic sans-serif font.)'
  prefs: []
  type: TYPE_NORMAL
- en: Zero basis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If neither the `flex-basis` property nor the `flex` shorthand is included at
    all, the flex basis defaults to `auto`. When the `flex` property is included,
    but the flex basis component of the shorthand is omitted from the shorthand, the
    basis defaults to `0`. While on the surface you might think the two values of
    `auto` and `0` are similar, the `0` value is actually very different and may not
    be what you expect.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of `flex-basis: auto`, the basis is the main size of the flex items’
    contents. If the basis of each of the flex items is `0`, the available space is
    the main-axis size of the entire flex container. In either case, the available
    space is distributed proportionally, based on the growth factors of each flex
    item.'
  prefs: []
  type: TYPE_NORMAL
- en: With a basis of `0`, the size of the flex container is divided up and distributed
    proportionally to each flex item based on its growth factors—its default original
    main-axis size as defined by `height`, `width`, or `content` is not taken into
    account, though `min-width`, `max-width`, `min-height`, and `max-height` do impact
    the flexed size.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in [Figure 11-59](#flex-basis-auto-vs-0), when the basis is `auto`,
    only the extra space is divided up proportionally and added to each flex item
    set to grow. Again, assuming the width of the text “flex: *X X* auto” is 110 pixels,
    in the first example we have 210 pixels to distribute among six growth factors,
    or 35 pixels per growth factor. The flex items are 180, 145, and 215 pixels wide,
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: '![flex-basis auto versus 0](assets/css5_1159.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-59\. Flex growth in auto and zero flex basis values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In the second example, when the basis is 0, all 540 pixels of the width is distributable
    space. With 540 pixels of distributable space among six growth factors, each growth
    factor is worth 90 pixels. The flex items are 180, 90, and 270 pixels wide, respectively.
    While the middle flex item is 90 pixels wide, the content in this example is narrower
    than 110 pixels, so the flex item didn’t wrap.
  prefs: []
  type: TYPE_NORMAL
- en: The flex Shorthand
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a fuller understanding of the properties that make up the
    `flex` shorthand, remember: *always use the `flex` shorthand.* It accepts the
    usual global property values, including `initial`, `auto`, `none`; and the use
    of an integer, usually `1`, meaning the flex item can grow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Four of the flex values provide the most commonly desired effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`flex: initial`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equivalent to `flex: 0 1 auto`. This sizes flex items based on the value of
    `inline-size` (which is equivalent to either `width` or `height`, depending on
    the direction of the inline axis), and allows shrinking but not growing.'
  prefs: []
  type: TYPE_NORMAL
- en: '`flex: auto`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equivalent to `flex: 1 1 auto`. This sizes flex items based on the value of
    `inline-size`, but makes them fully flexible, allowing both shrinking and growing.'
  prefs: []
  type: TYPE_NORMAL
- en: '`flex: none`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equivalent to `flex: 0 0 auto`. This sizes flex items based on the value of
    `inline-size`, but makes them completely inflexible: they can’t shrink or grow.'
  prefs: []
  type: TYPE_NORMAL
- en: '`flex: <*number*>`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Equivalent to `flex: <*number*> 1 0`. This value sets the flex item’s growth
    factor to the <*`number`*> provided. It also sets both the shrink factor and flex
    basis to `0`. This means the value of `inline-size` acts as a minimum size, but
    the flex item will grow if there is room to do so.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s consider each of these in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Flexing with initial
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The global CSS keyword `initial` can be used on all properties to represent
    a property’s initial value (its specification default value). Thus, the following
    lines are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring `flex: initial` sets a null growth factor, a shrink factor of `1`,
    and the flex basis values to `auto`. In [Figure 11-60](#flex-shrink-flex-initial),
    we can see the effect of the `auto` flex basis values. In the first two examples,
    the basis of each flex item is `content`—with each flex item having the width
    of the single line of letters that makes up the content. However, in the last
    two examples, the flex basis values of all the items are equal at 50 pixels, since
    `width: 50px` has been applied to all the flex items. The `flex: initial` declaration
    sets the `flex-basis` to `auto`, which we previously saw is the value of the `width`
    (or `height`), if declared, or `content` if not declared.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first and third of these examples, we see that when the flex container
    is too small to fit all the flex items at their default main-axis size, the flex
    items shrink so that all fit within the parent flex container. In these examples,
    the combined flex basis values of all the flex items is greater than the main-axis
    size of the flex container. In the first example, the width of each flex item
    varies based on the width of each item’s content and its ability to shrink. They
    all shrink proportionally based on their shrink factor, but not narrower than
    their widest content. In the third example, with each flex item’s flex-basis being
    50 pixels (because of the value of `width`), all the items shrink equally.
  prefs: []
  type: TYPE_NORMAL
- en: '![With containers of different main sizes, the flex items shrink but won''t
    grow when flex: initial is set on the flex items](assets/css5_1160.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-60\. Flex items shrink but won’t grow when `flex: initial` is set
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-shrink-dont-grow.html)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Flex items, by default, are grouped at main-start, as `flex-start` is the default
    value for the `justify-content` property. This is noticeable only when the combined
    main-axis sizes of the flex items in a flex line are smaller than the main-axis
    size of the flex container, and none of the flex items are able to grow.
  prefs: []
  type: TYPE_NORMAL
- en: Flexing with auto
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `flex: auto` option is similar to `flex: initial`, but makes the flex items
    flexible in both directions: they’ll shrink if there isn’t enough room to fit
    all the items within the container, and they’ll grow to take up all the extra
    space within the container if there is distributable space. The flex items absorb
    any free space along the main-axis. The following two statements are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-61](#flex-auto-grow-shrink) shows a variety of scenarios using `auto`
    flexing.'
  prefs: []
  type: TYPE_NORMAL
- en: '![With flex: auto set on the flex items, the flex items can grow and shrink
    ](assets/css5_1161.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-61\. Flex items can grow and shrink when `flex: auto` is set [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-shrink-and-grow.html)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The first and third examples of [Figure 11-61](#flex-auto-grow-shrink) are
    identical to the examples in [Figure 11-60](#flex-shrink-flex-initial), as the
    shrinking and basis values are the same. However, the second and fourth examples
    are different. This is because when `flex: auto` is set, the growth factor is
    `1`, and the flex items therefore can grow to incorporate all the extra available
    space.'
  prefs: []
  type: TYPE_NORMAL
- en: Preventing flexing with none
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Any `flex: none` flex items are inflexible: they can neither shrink nor grow.
    The following two lines of CSS are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[Figure 11-62](#flex-none-no-grow-shrink) shows the effects of `none`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![With flex: none, flex items will neither grow nor shrink](assets/css5_1162.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-62\. With `flex: none`, flex items will neither grow nor shrink [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-dont-grow-nor-shrink.html)'
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As demonstrated in the first and third examples of [Figure 11-62](#flex-none-no-grow-shrink),
    if there isn’t enough space, the flex items overflow the flex container. This
    is different from `flex: initial` and `flex: auto`, which both set a positive
    shrink factor.'
  prefs: []
  type: TYPE_NORMAL
- en: The basis resolves to `auto`, meaning each flex item’s main-axis size is determined
    by the main-axis size of the element had it not been turned into a flex item.
    The flex-basis resolves to the `width` or `height` value of the element. If that
    value is `auto`, the basis becomes the main-axis size of the content. In the first
    two examples, the basis—and the width, since there is no growing or shrinking—is
    the width of the content. In the third and fourth examples, the width and basis
    are all 50 pixels, because that’s the value of the `width` property applied to
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric flexing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When the value of the `flex` property is a single, positive, numeric value,
    that value will be used for the growth factor, while the shrink factor will default
    to `1` and the basis will default to `0`. The following two CSS declarations are
    equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the flex item on which it is set flexible: it can grow. The shrink
    factor is actually moot: the flex basis is set to `0`, so the flex item can grow
    only from that basis.'
  prefs: []
  type: TYPE_NORMAL
- en: In the first two examples in [Figure 11-63](#flex-n-grow-shrink), all the flex
    items have a flex growth factor of `3`. The flex basis is `0`, so they don’t “shrink”;
    they just grow equally from 0 pixels wide until the sum of their main-axis sizes
    to fill the container along the main-axis. With all the flex items having a basis
    of `0`, 100% of the main dimension is distributable space. The main-axis size
    of the flex items is wider in this second example because the wider flex container
    has more distributable space.
  prefs: []
  type: TYPE_NORMAL
- en: '![With flex: n, you''re declaring the flex items growth factor while setting
    the flex basis to zero](assets/css5_1163.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-63\. Flexing using a single numeric value [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-using-single-numeric-value.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Any numeric value that is greater than 0, even 0.1, means the flex item can
    grow. If there is available space to grow and only one flex item has a positive
    growth factor, that item will take up all the available space. If multiple flex
    items can grow, the available extra space will be distributed proportionally to
    each flex item based on its growth factor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last three examples of [Figure 11-63](#flex-n-grow-shrink) declare six
    flex items with `flex: 0`, `flex: 1`, `flex: 2`, `flex: 3`, `flex: 4`, and `flex:
    5`, respectively. These are the growth factors for the flex items, with each having
    a shrink factor of `1` and a flex basis of `0`. The main-axis size of each is
    proportional to the specified flex growth factor. You might assume that the `flex:
    0` item with the text “flex: 0” in the third example will be 0 pixels wide, as
    in the fourth example—but, by default, flex items won’t shrink below the length
    of the longest word or fixed-size element.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'We added a bit of padding, margins, and borders to the figures to make the
    visuals more pleasing. For this reason, the leftmost flex item, with `flex: 0`
    declared, is visible: it has a 1-pixel border making it visible, even though it’s
    0 pixels wide.'
  prefs: []
  type: TYPE_NORMAL
- en: The order Property
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flex items are, by default, displayed and laid out in the same order as they
    appear in the source code. The order of flex items and flex lines can be reversed
    with `flex-direction`, but sometimes you want a rearrangment that’s a little more
    complicated. The `order` property can be used to change the ordering of individual
    flex items.
  prefs: []
  type: TYPE_NORMAL
- en: By default, all flex items are assigned the order of `0`, with the flex items
    all assigned to the same ordinal group and displayed in the same order as their
    source order, along the direction of the main-axis. (This has been the case for
    all the examples throughout this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: To change the visual order of a flex item, set the `order` property value to
    a nonzero integer. Setting the `order` property on elements that are not children
    of a flex container has no effect on such elements.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Changing the visual rendering order of flex items creates a disconnect between
    the source order of elements and their visual presentation. This can, in the words
    of the Mozilla Developer Network’s article on `order`, “adversely affect users
    experiencing low vision navigating with the aid of assistive technology such as
    a screen reader.” It could also create problems for users who navigate by keyboard
    and use a zoomed-in or otherwise magnified view of pages. In other words: be very
    careful with `order`, and use it *only* in production after much accessibility
    testing.'
  prefs: []
  type: TYPE_NORMAL
- en: The value of the `order` property specifies an *ordinal group* to which the
    flex item belongs. Any flex items with a negative value will appear to come before
    those defaulting to `0` when drawn to the page, and all the flex items with a
    positive value will appear to come after those defaulting to `0`. While visually
    altered, the source order remains the same. Screen readers and tabbing order remain
    as defined by the source order of the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a group of 12 items, and you want the seventh to come
    first and the sixth to be last, you would declare the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'In this scenario, we are explicitly setting the order for the sixth and seventh
    list items, while the other list items are defaulting to `order: 0`. [Figure 11-64](#setting-order-to-any)
    shows the result.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting order to any value other than 0 will reorder that flex item](assets/css5_1164.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-64\. Reordering flex items with the `order` property [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/order01.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The seventh flex item is the first to be laid out, because of the negative value
    of the `order` property, which is less than the default `0`, and is also the lowest
    value of any of its sibling flex items. The sixth flex item is the only item with
    a value greater than 0, and therefore has the highest-order value out of all of
    its siblings. This is why it’s laid out after all the other flex items. All the
    other items, all having the default `order` of `0`, are drawn between those first
    and last items, in the same order as their source order, since they are all members
    of the same ordinal group (`0`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The flex container lays out its content in order-modified document order, starting
    from the lowest-numbered ordinal group and going up. When multiple flex items
    have the same value for the `order` property, the items share an ordinal group.
    The items in each ordinal group will appear in source order, with the group appearing
    in numeric order, from lowest to highest. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: By setting the same `order` value to more than one flex item, the items will
    appear by ordinal group, and by source order within each individual ordinal group.
    [Figure 11-65](#flex-items-appear-ordinal) shows the result.
  prefs: []
  type: TYPE_NORMAL
- en: '![Flex items appear in order of ordinal groups, by source order within their
    group](assets/css5_1165.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-65\. Flex items appear in order of ordinal groups, by source order
    within their group [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/order02.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Here’s what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: Items 2, 5, 8, and 11 were selected to share ordinal group `3`, and get a 20%
    opaque background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items 1, 4, 7, and 10 were selected to share ordinal group `-1`, and get a 40%
    opaque background.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Items 3, 6, 9, and 12 were not selected at all. They default to the ordinal
    group `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three ordinal groups, then, are `-1`, `0`, and `3`. The groups are arranged
    in that order. Within each group, the items are arranged by source order.
  prefs: []
  type: TYPE_NORMAL
- en: 'This reordering is purely visual. Screen readers *should* read the document
    as it appears in the source code, though they may not. As a visual change, ordering
    flex items impacts the painting order of the page: the painting order of the flex
    items is the order in which they appear, as if they were reordered in the source
    document, even though they aren’t.'
  prefs: []
  type: TYPE_NORMAL
- en: Changing the layout with the `order` property has no effect on the tab order
    of the page. If the numbers in [Figure 11-65](#flex-items-appear-ordinal) were
    links, tabbing through the links would go through the links in the order of the
    source code, *not* in the order of the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Tabbed Navigation Revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding to our tabbed navigation bar example in [Figure 11-2](#simple_tabbed_navigation),
    we can make the currently active tab appear first, as [Figure 11-66](#changing-order-tab)
    shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![Changing the order will change the visual order, but not the tab order](assets/css5_1166.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11-66\. Changing the order will change the visual order, but not the
    tab order [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/changing-order-changes-visual-order.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The currently active tab has the `.active` class added, the `href` attribute
    removed, and the `order` set to `-1`, which is less than the default `0` of the
    other sibling flex items, meaning it appears first.
  prefs: []
  type: TYPE_NORMAL
- en: Why did we remove the `href` attribute? As the tab is the currently active document,
    there is no reason for the document to link to itself. But, more importantly,
    if it was an active link instead of a placeholder link, and the user was using
    the keyboard to tab through the navigation, the order of appearance is Blog, Home,
    About, Careers, and Contact Us, with the Blog appearing first; but the tab order
    would have been Home, About, Blog, Careers, and Contact Us, following the source
    order rather than the visual order, which can be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `order` property can be used to enable marking up the main content area
    before the side columns for mobile devices and those using screen readers and
    other assistive technology, while creating the appearance of the common three-column
    layout: a center main content area, with site navigation on the left and a sidebar
    on the right, as shown way back in [Figure 11-48](#set_diff_values).'
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can put your footer before your header in your markup, and use `order`
    to reorder the page, this is an inappropriate use of the property. The `order`
    property should be used only for visual reordering of content. Your underlying
    markup should always reflect the logical order of your content. Consider these
    two markup orders for the same content, shown here side by side to make comparing
    them easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: We’ve been marking up websites in the order we want them to appear, as shown
    on the right in the code example, which is the same code as in our three-column
    layout example ([Figure 11-48](#set_diff_values)).
  prefs: []
  type: TYPE_NORMAL
- en: 'It really would make more sense if we marked up the page as shown on the left,
    with the `<article>` content, which is the main content, first in the source order:
    this puts the article first for screen readers, search engines, and even mobile
    devices, but in the middle for our sighted users on larger screens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the `order: -1` declaration, we are able to make the `<nav>` appear
    first, as it is the lone flex item in the ordinal group of `-1`. The `<article>`
    and `<aside>`, with no `order` explicitly declared, default to `order: 0`.'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, when more than one flex item is in the same ordinal group, the members
    of that group are displayed in source order in the direction of main-start to
    main-end, so the `article` is displayed before the `aside`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some developers, when changing the order of at least one flex item, like to
    give all flex items an `order` value for better markup readability. We could have
    also written this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'In previous years, before browsers supported flex, all this could have been
    done with floats: we would have set `float: right` on the `<nav>`. While doable,
    flex layout makes this sort of layout much simpler, especially if we want all
    three columns—the `<aside>`, `<nav>`, and `<article>`—to be of equal heights.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With flexible box layout, you can lay out sibling elements in ways that are
    responsive to many layout contexts and writing modes, with a variety of options
    for arranging those elements and aligning them to one another. It makes the task
    of vertically centering elements within their parent elements almost trivially
    easy, something that was very difficult in the years before flexbox. It also serves
    as a powerfully useful bridge between normal-flow and grid layout, which is the
    subject of the next chapter.
  prefs: []
  type: TYPE_NORMAL
