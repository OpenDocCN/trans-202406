- en: Chapter 11\. Flexible Box Layout
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章\. 伸缩盒布局
- en: The [CSS Flexible Box Module Level 1](http://www.w3.org/TR/css-flexbox-1), or
    flexbox for short, makes the once difficult tasks of laying out certain kinds
    of pages, widgets, applications, and galleries almost simple. With flexbox, you
    often don’t need a CSS framework. In this chapter, you’ll learn how to use just
    a few lines of CSS to create almost any feature your site requires.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[CSS伸缩盒模块1级](http://www.w3.org/TR/css-flexbox-1)，或简称伸缩盒，使得一度困难的页面、小部件、应用程序和画廊布局几乎变得简单。通过伸缩盒，通常不需要CSS框架。在本章中，您将学习如何只用几行CSS创建站点所需的几乎任何功能。'
- en: Flexbox Fundamentals
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伸缩盒基础知识
- en: '*Flexbox* is a simple and powerful way to lay out page components by dictating
    how space is distributed, content is aligned, and elements are visually ordered.
    Content can easily be arranged vertically or horizontally, and can be laid out
    along a single axis or wrapped across multiple lines. And much, much more.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*伸缩盒* 是一种简单而强大的页面组件布局方式，通过定义空间分配方式、内容对齐和元素的视觉顺序来实现。内容可以轻松垂直或水平排列，并可以沿单一轴或跨多行进行布局。还有更多更多。'
- en: With flexbox, the appearance of content can be independent of source order.
    Though visually altered, flex properties should not impact the order of content
    read by screen readers.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 使用伸缩盒，内容的外观可以独立于源代码顺序。虽然视觉上会改变，但伸缩属性不应影响屏幕阅读器读取内容的顺序。
- en: Warning
  id: totrans-5
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Specifications say that screen readers should follow source order, but as of
    late 2022, Firefox follows the visual order. As of this writing, a proposal calls
    for adding a CSS property that specifies whether to follow source or visual order,
    so it may soon be possible to decide for yourself.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 规范说明屏幕阅读器应该遵循源代码顺序，但截至2022年底，Firefox遵循视觉顺序。目前，有一个提案建议添加一个CSS属性，指定是遵循源代码还是视觉顺序，因此很快可能可以自行决定。
- en: Perhaps most importantly, with flexible box module layouts, elements can be
    made to behave predictably for different screen sizes and different display devices.
    Flexbox works very well with responsive sites, as content can increase and decrease
    in size when the space provided is increased or decreased.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 或许更重要的是，采用灵活盒模块布局后，元素可以在不同屏幕大小和不同显示设备上表现出可预测的行为。伸缩盒在响应式站点中非常有效，因为在提供的空间增加或减少时，内容可以增加或减小尺寸。
- en: 'Flexbox works off of a parent-and-child relationship. Flexbox layout is activated
    by declaring `display: flex` or `display: inline-flex` on an element. This element
    becomes a *flex container*, arranging its children within the space provided and
    controlling their layout. The children of this flex container become *flex items*.
    Consider the following styles and markup, illustrated in [Figure 11-1](#display_flex):'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '伸缩盒通过声明 `display: flex` 或 `display: inline-flex` 来激活父子关系布局。这个元素成为*伸缩容器*，在提供的空间内排列其子元素并控制它们的布局。这个伸缩容器的子元素成为*伸缩项目*。考虑以下样式和标记，见
    [图 11-1](#display_flex)：'
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Adding display: flex; or display: inline-flex creates a flex container](assets/css5_1101.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![添加 `display: flex;` 或 `display: inline-flex` 创建伸缩容器](assets/css5_1101.png)'
- en: Figure 11-1\. The two kinds of flex containers [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/two-kinds-of-flex-containers.html)
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-1\. 两种伸缩容器类型 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/two-kinds-of-flex-containers.html)
- en: Tip
  id: totrans-13
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Look for the Play symbol ![](assets/play-icon-round.png) to know when an online
    example is available. All of the examples in this chapter can be found at [*https://meyerweb.github.io/csstdg5figs/11-flexbox*](https://meyerweb.github.io/csstdg5figs/11-flexbox).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 查找播放符号 ![](assets/play-icon-round.png) 以了解在线示例是否可用。本章中的所有示例都可以在 [*https://meyerweb.github.io/csstdg5figs/11-flexbox*](https://meyerweb.github.io/csstdg5figs/11-flexbox)
    找到。
- en: Notice how each child element of the `<div>`s becomes a flex item, and furthermore,
    how they all lay out in the same way? It doesn’t matter that some are paragraphs
    and others are `<span>`s. They all become flex items. (There would likely have
    been some differences due to the paragraphs’ browser-default margins, except those
    were removed.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `<div>` 的每个子元素如何成为伸缩项目，以及它们如何以相同方式布局？这些元素不同于某些段落和其他 `<span>`，它们都成为伸缩项目。（除了浏览器默认边距，可能会有一些差异，但已经移除。）
- en: 'The only real difference between the first and second flex containers is that
    one is set to `display: flex`, and the other to `display: inline-flex`. In the
    first, the `<div>` becomes a block box with flex layout inside it. In the second,
    the `<div>` becomes an inline-block box with flex inside it.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '第一个和第二个弹性容器之间唯一的真正区别在于，一个被设置为`display: flex`，另一个被设置为`display: inline-flex`。在第一个容器中，`<div>`成为一个内部具有弹性布局的块级盒子。而在第二个容器中，`<div>`成为一个内部具有弹性布局的行内块级盒子。'
- en: The key thing to keep in mind is that once you set an element to be a flex container,
    like the `<div>`s in [Figure 11-1](#display_flex), it will flex only its immediate
    children, and not further descendants. However, you can make those descendants
    flex containers as well, enabling some really complex layouts.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，一旦你将一个元素设置为弹性容器，比如在[图 11-1](#display_flex)中的`<div>`元素，它将仅对其直接子元素进行弹性布局，而不会影响更深层次的后代元素。不过，你也可以将这些后代元素设为弹性容器，从而实现一些非常复杂的布局。
- en: 'Within a flex container, items line up on the *main-axis*. The main-axis can
    be either horizontal or vertical, so you can arrange items into columns or rows.
    The main-axis takes on the directionality set via the writing mode: this main-axis
    concept is discussed in depth in [“Understanding Axes”](#understanding-axis).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在弹性容器内部，项目沿着*主轴*对齐。主轴可以是水平的也可以是垂直的，因此你可以将项目排列成列或行。主轴的方向性由书写模式设置：关于这个主轴概念将在[“理解轴”](#understanding-axis)中深入讨论。
- en: As the first `<div>` in [Figure 11-1](#display_flex) demonstrates, when the
    flex items don’t fill up the entire main-axis (in this case, the width) of the
    container, they will leave extra space. Certain properties dictate how to handle
    that extra space, which we’ll explore later in the chapter. You can group the
    children to the left, the right, or centered, or you can spread them out, defining
    how the space is spread out either between or around the children.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 11-1](#display_flex)中的第一个`<div>`所示，当弹性项目未填满容器的主轴（在本例中为宽度）时，它们会留下额外的空间。某些属性规定了如何处理这些额外的空间，我们将在本章后面进行探讨。你可以将子元素分组到左侧、右侧或居中，或者将它们分散开来，定义空间是在子元素之间还是围绕子元素周围扩展。
- en: Besides distributing space, you can also allow the flex items to grow to take
    up all the available space by distributing that extra space among one, some, or
    all of the flex items. If there isn’t enough space to contain all the flex items,
    you can employ flexbox properties to dictate how they should shrink to fit within
    their container, or whether they’re allowed to wrap to multiple flex lines.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 除了分配空间外，你还可以允许弹性项目扩展以占用所有可用空间，通过在弹性项目之间或在所有弹性项目之间分配额外空间来实现。如果没有足够的空间容纳所有弹性项目，你可以使用flexbox属性来指定它们在容器内如何收缩，或者它们是否可以换行到多个弹性行中。
- en: Furthermore, the children can be aligned with respect to their container or
    to each other; to the bottom, top, or center of the container; or stretched out
    to fill the container. Regardless of the difference in content length among sibling
    containers, with flexbox you can make all the siblings the same size with a single
    declaration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，子元素可以相对于其容器或彼此对齐；可以位于容器的底部、顶部或中心；或者拉伸以填充容器。无论同级容器之间内容长度的差异如何，使用flexbox可以通过单个声明使所有兄弟元素大小相同。
- en: A Simple Example
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个简单的示例
- en: 'Let’s say we want to create a navigation bar out of a group of links. This
    is exactly the sort of thing flexbox was designed to handle. Consider the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想要从一组链接创建一个导航栏。这正是flexbox设计用来处理的情况。考虑以下内容：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding code, with its `display` property set to `flex`, the `<nav>`
    element is turned into a flex container, and its child links are all flex items.
    These links are still hyperlinks, but they are now also flex items, which means
    they are no longer inline-level boxes: rather, they participate in their container’s
    flex formatting context. Therefore, the whitespace between the `<a>` elements
    in the HTML is completely ignored in layout terms. If you’ve ever used HTML comments
    to suppress the space between links, list items, or other elements, you know why
    this is a big deal.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，将其`display`属性设置为`flex`后，`<nav>`元素被转换为弹性容器，其子链接都成为了弹性项目。这些链接仍然是超链接，但现在它们也是弹性项目，这意味着它们不再是行内级别的框，而是参与其容器的弹性格式化上下文。因此，在HTML中`<a>`元素之间的空白在布局上完全被忽略了。如果你以前使用HTML注释来消除链接、列表项或其他元素之间的空格，那么你就明白这有多重要了。
- en: 'So let’s add some CSS to the links:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以让我们为这些链接添加一些CSS样式：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We now have ourselves a simple tabbed navigation bar, as shown in [Figure 11-2](#simple_tabbed_navigation).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个简单的选项卡导航栏，如[图 11-2](#simple_tabbed_navigation)所示。
- en: '![A simple tabbed navigation (files/nav_displayflex.html)](assets/css5_1102.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![一个简单的选项卡导航 (files/nav_displayflex.html)](assets/css5_1102.png)'
- en: Figure 11-2\. A simple tabbed navigation [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/simple-tabbed-navigation.html)
  id: totrans-31
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-2\. 一个简单的选项卡导航 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/simple-tabbed-navigation.html)
- en: 'That might not seem like much right now, because there’s nothing here you couldn’t
    have done with old-school CSS. Just wait: it gets better.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可能看起来并不起眼，因为在旧式 CSS 中你可以做到这一切。等等：它会变得更好。
- en: By design, flexbox is direction-agnostic. This is different from block or inline
    layouts, which are defined to be vertically and horizontally biased, respectively.
    The web was originally designed for the creation of pages on monitors, and assumed
    a horizontal constraint with infinite vertical scroll. This vertically biased
    layout is insufficient for modern applications that change orientation, grow,
    and shrink, depending on the user agent and the direction of the viewport, and
    change writing modes depending on the language.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从设计上看，flexbox 是方向不可知的。这与块级或行内布局不同，后者分别被定义为垂直和水平倾向。Web 最初是为在监视器上创建页面而设计的，并假定具有无限垂直滚动的水平约束。这种垂直倾向布局对于根据用户代理和视口方向变化、增长和收缩的现代应用程序以及根据语言改变书写模式的情况是不足够的。
- en: For years we joked about the challenges of vertical centering and multiple column
    layout. Some layouts were no laughing matter, like ensuring equal heights in sets
    of multiple side-by-side boxes, with buttons or “more” links fixed to the bottom
    of each box ([Figure 11-3](#power_grid_layout_flexbox)); or, keeping the pieces
    of a single button all neatly lined up ([Figure 11-4](#fb_button-vert-centered)).
    Flexbox makes what used to be challenging layout effects fairly simple.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们一直在开玩笑地谈论垂直居中和多列布局的挑战。有些布局并不好笑，比如确保多个并排框的高度相等，按钮或“更多”链接固定在每个框的底部（[图 11-3](#power_grid_layout_flexbox)）；或者，保持单个按钮的各部分整齐排列（[图
    11-4](#fb_button-vert-centered)）。Flexbox 让以前具有挑战性的布局效果变得相当简单。
- en: '![Power grid layout with flexbox, with buttons aligned on the bottom](assets/css5_1103.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![使用 flexbox 的电力网格布局，按钮底部对齐](assets/css5_1103.png)'
- en: Figure 11-3\. Power grid layout with flexbox, with buttons aligned on the bottom
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/power-grid-layout.html)
  id: totrans-36
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-3\. 使用 flexbox 的电力网格布局，按钮底部对齐 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/power-grid-layout.html)
- en: '![Button with many components neatly vertically centered](assets/css5_1104.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![垂直居中排列的多组件按钮](assets/css5_1104.png)'
- en: Figure 11-4\. Widget with several components, all vertically centered [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/widget-with-components-vertically-centered.html)
  id: totrans-38
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-4\. 具有多个组件的小部件，所有内容垂直居中 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/widget-with-components-vertically-centered.html)
- en: 'The classic [“Holy Grail” layout](https://en.wikipedia.org/wiki/Holy_grail_(web_design)),
    with a header, three equal-height columns of varying flexibility, and a footer,
    can be created in a few lines of CSS with either flexbox or grid layout, which
    are covered in the next chapter. Here’s an example of HTML that might represent
    such a layout:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的[“圣杯”布局](https://en.wikipedia.org/wiki/Holy_grail_(web_design))，带有标题、三个高度相等但灵活性不同的列和页脚，可以用几行
    CSS 代码使用 flexbox 或网格布局在下一章中介绍的方式创建。以下是可能代表这种布局的 HTML 示例：
- en: '[PRE5]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As the chapter progresses, remember that flexbox is designed for a specific
    type of layout, that of single-dimensional content distribution. It works best
    at arranging information along a single dimension, or axis. While you can create
    grid-like layouts (two-dimensional alignment) with flexbox, this is not its intended
    purpose, and it has significant flaws for this use case. If you find yourself
    pining for two-dimensional layout capabilities, see [Chapter 12](ch12.html#grid-layout).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本章的进行，请记住，flexbox 是为特定类型的布局设计的，即单维内容分布。它最擅长沿着单个维度或轴排列信息。虽然你可以使用 flexbox 创建类似网格的布局（二维对齐），但这不是其预期目的，对于这种用例它存在显著缺陷。如果你发现自己渴望二维布局功能，请参阅[第
    12 章](ch12.html#grid-layout)。
- en: Flex Containers
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性容器
- en: 'The first important concept to fully understand is the *flex container*, also
    known as the *container box*. The element on which `display: flex` or `display:
    inline-flex` is applied becomes the flex container and generates a *flex formatting
    context* for its child nodes.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '完全理解的第一个重要概念是 *flex 容器*，也称为 *容器盒子*。应用了 `display: flex` 或 `display: inline-flex`
    的元素成为 flex 容器，并为其子节点生成 *flex 格式化上下文*。'
- en: These children are *flex items*, whether they are DOM nodes, text nodes, or
    generated-content pseudo-elements. Absolutely positioned children of flex containers
    are also flex items, but each is sized and positioned as though it is the only
    flex item in its flex container.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子项是 *flex 项*，无论它们是 DOM 节点、文本节点还是生成的内容伪元素。flex 容器的绝对定位子项也是 flex 项，但每个子项的大小和位置都像是其所在
    flex 容器中唯一的 flex 项一样。
- en: We’ll first look at all the CSS properties that apply to the flex container,
    including several properties impacting the layout of flex items. We’ll then explore
    the equally important concept of flex items in [“Flex Items”](#flex-items).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先查看适用于 flex 容器的所有 CSS 属性，包括几个影响 flex 项布局的属性。然后我们将探讨同样重要的 flex 项概念在[“Flex
    项”](#flex-items)中。
- en: Using the flex-direction Property
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `flex-direction` 属性
- en: If you want your layout to go from top to bottom, left to right, right to left,
    or even bottom to top, you can use `flex-direction` to control the main-axis along
    which the flex items get laid out.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望布局从上到下、从左到右、从右到左，甚至从底部到顶部，可以使用 `flex-direction` 控制 flex 项排列的主轴方向。
- en: The `flex-direction` property specifies how flex items are placed in the flex
    container. It defines the main-axis of a flex container, which is the primary
    axis along which flex items are laid out (see [“Understanding Axes”](#understanding-axis)
    for more details).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-direction` 属性指定了如何在 flex 容器中放置 flex 项。它定义了 flex 容器的主轴，即沿着哪个主轴排列 flex
    项（有关更多细节，请参见[“理解轴”](#understanding-axis)）。'
- en: 'Assume the following basic markup structure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 假设以下基本标记结构：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[Figure 11-5](#four-values-flex-dir) shows how that simple list would be arranged
    by applying each of the four values of `flex-direction`, assuming a left-to-right
    language.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-5](#four-values-flex-dir) 显示了应用 `flex-direction` 四个值排列简单列表的方式，假设是从左到右的语言。'
- en: '![The four values of the flex-direction property](assets/css5_1105.png)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![flex-direction 属性的四个值](assets/css5_1105.png)'
- en: Figure 11-5\. The four values of the flex-direction property [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-four-values.html)
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-5\. flex-direction 属性的四个值 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-four-values.html)
- en: The default value, `row`, doesn’t look all that different from a bunch of inline
    or floated elements. This is misleading, for reasons you’ll soon see, but notice
    how the other `flex-direction` values affect the arrangement of the list items.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值 `row` 看起来与一堆内联元素或浮动元素没有太大区别。这是误导性的，原因很快你就会看到，但请注意其他 `flex-direction` 值如何影响列表项的排列。
- en: 'For example, you can reverse this layout of the items with `flex-direction:
    row-reverse`. The flex items are laid out from top to bottom when `flex-direction:
    column` is set, and from bottom to top if `flex-direction: column-reverse` is
    set, as shown in [Figure 11-5](#four-values-flex-dir).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，你可以通过 `flex-direction: row-reverse` 来反转项目的布局。当设置 `flex-direction: column`
    时，flex 项从上到下排列，如果设置 `flex-direction: column-reverse`，则从下到上排列，如[图 11-5](#four-values-flex-dir)所示。'
- en: We specified left-to-right languages, because the direction of the main-axis
    for `row`—the direction that the flex items are laid out—is the direction of the
    current writing mode. We’ll discuss how writing modes affect flex direction and
    layout in a bit.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了从左到右的语言，因为`row`的主轴方向——即 flex 项排列的方向——是当前书写模式的方向。稍后我们将讨论书写模式如何影响 flex 方向和布局。
- en: Warning
  id: totrans-57
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Do *not* use `flex-direction` to change the layout for right-to-left languages.
    Rather, use the `dir` attribute in HTML, or the `writing-mode` CSS property described
    in [“Setting Writing Modes”](ch15.html#setting_writing_modes), to indicate the
    language direction. To learn more about language direction and flexbox, see [“Working
    with Other Writing Directions”](#other-writing-directions).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 不要使用 `flex-direction` 来更改从右到左的语言的布局。而是在 HTML 中使用 `dir` 属性，或者在[“设置书写模式”](ch15.html#setting_writing_modes)中描述的
    `writing-mode` CSS 属性来指示语言方向。要了解更多有关语言方向和 flexbox 的信息，请参见[“处理其他书写方向”](#other-writing-directions)。
- en: The `column` value sets the flex container’s main-axis to be the same orientation
    as the block axis of the current writing mode. This is the vertical axis in horizontal
    writing modes like English, and the horizontal axis in vertical writing modes
    like traditional Japanese.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`column` 值将 flex 容器的主轴设置为与当前书写模式的块轴相同的方向。在水平书写模式（如英语）中，这是垂直轴，在传统日语等垂直书写模式中，这是水平轴。'
- en: 'Thus, when declaring a `column` direction in English (or a language with the
    same writing direction), the flex items are displayed in the same order as declared
    in the source document, but from top to bottom instead of left to right, so the
    flex items are laid out one on top of the next instead of side by side. Consider
    the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在英语（或具有相同书写方向的语言）中声明 `column` 方向时，flex 项目以与源文档中声明的相同顺序显示，但从上到下而不是从左到右排列，因此
    flex 项目是按顺序堆叠而不是并排放置。考虑以下情况：
- en: '[PRE7]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Thus, by simply writing a few CSS properties, we can create a nice sidebar-style
    navigation for the list of links we saw earlier as a horizontal row of tabs. For
    the new layout, we change the `flex-direction` from the default value of `row`
    to `column` and move the border from the bottom to the right; [Figure 11-6](#changing-flex-dir)
    shows the result.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过简单地编写几个 CSS 属性，我们可以为早期看到的横向选项卡列表创建一个漂亮的侧边栏样式导航。对于新布局，我们将 `flex-direction`
    从默认值 `row` 更改为 `column`，并将边框从底部移到右侧；[图 11-6](#changing-flex-dir) 显示了结果。
- en: '![Changing flex-direction can completely change the layout of your content](assets/css5_1106.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![更改 flex-direction 可完全改变内容的布局](assets/css5_1106.png)'
- en: Figure 11-6\. Changing the flex direction can completely change the layout [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/changing-flex-direction-change-layout.html)
  id: totrans-64
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-6\. 更改 flex-direction 可完全改变内容的布局 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/changing-flex-direction-change-layout.html)
- en: The `column-reverse` value is similar to `column`, except the main-axis is reversed;
    thus, `main-start` is placed at the *end* of the main-axis, and `main-end` is
    placed at the *start* of the main-axis. In top-to-bottom writing modes, that means
    the flex items are arranged going upward, as shown previously in [Figure 11-5](#four-values-flex-dir).
    The `-reverse` values only change the appearance. The keyboard-navigation tab
    order remains the same as the underlying markup.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`column-reverse` 值类似于 `column`，但主轴是反向的；因此，`main-start` 放在主轴的*末端*，而 `main-end`
    放在主轴的*起始*。在从上到下的书写模式中，这意味着 flex 项目是向上排列的，如之前在[图 11-5](#four-values-flex-dir)中所示。
    `-reverse` 值仅改变外观。键盘导航的标签顺序与底层标记相同。'
- en: What we’ve shown so far is super powerful and makes many layouts a breeze. If
    we include the navigation within a full document, we can see how simple layout
    can be with just a few flexbox property declarations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们展示的内容非常强大，使得许多布局变得轻而易举。如果我们在完整文档中包含导航，我们可以看到仅凭几个 flexbox 属性声明就可以实现多么简单的布局。
- en: 'Let’s expand a little on our preceding HTML example, and include the navigation
    as a component within a home page:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微扩展一下前面的 HTML 示例，并将导航作为主页中的一个组件包含进来：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'By adding a few lines of CSS, we get a nicely laid-out home page ([Figure 11-7](#using_flex_direction_row_and_column)):'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加几行 CSS，我们可以得到一个布局良好的主页（[图 11-7](#using_flex_direction_row_and_column)）：
- en: '[PRE9]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Home page layout using +flex-direction:+ +row+ and +column+](assets/css5_1107.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![使用 +flex-direction:+ +row+ 和 +column+ 的主页布局](assets/css5_1107.png)'
- en: 'Figure 11-7\. Home page layout using `flex-direction: row` and `column` [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/home-page-layout-row-and-column.html)'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图 11-7\. 使用 `flex-direction: row` 和 `column` 的主页布局 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/home-page-layout-row-and-column.html)'
- en: Yes, elements can be flex items while also being flex containers, as you can
    see with the navigation, main, and article elements in this case. The `<body>`
    and `<article>` elements have `column` set as their flex directions, and we let
    `<nav>` and `<main>` default to `row`. And all that with just two lines of CSS!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，元素既可以是 flex 项目，同时也可以是 flex 容器，就像您在此示例中看到的导航、主体和文章元素一样。 `<body>` 和 `<article>`
    元素将 `column` 设置为它们的 flex 方向，而我们让 `<nav>` 和 `<main>` 默认为 `row`。而且所有这些只需两行 CSS 就能完成！
- en: To be clear, there’s more styling at work in [Figure 11-7](#using_flex_direction_row_and_column).
    Borders, margins, and padding were applied to all the elements, so you can visually
    differentiate the flex items for the sake of learning (we wouldn’t put this less-than-attractive
    site into production!). Otherwise, all we’ve done is simply declare the body,
    navigation, main, and articles as flex containers, making the navigation links,
    main, article, images, paragraphs, and buttons flex items.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，在[图 11-7](#using_flex_direction_row_and_column)中还有更多样式的应用。我们给所有元素都添加了边框、外边距和内边距，这样你可以通过视觉区分弹性项目以便学习（我们不会将这种不太吸引人的网站投入生产！）。否则，我们只是简单地声明了
    body、导航、主体和文章作为弹性容器，使得导航链接、主体、文章、图像、段落和按钮成为弹性项目。
- en: Working with Other Writing Directions
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理其他写作方向
- en: If you’re creating websites in English, or another left-to-right (LTR) language,
    you likely want the flex items to be laid out from left to right, and from top
    to bottom. The default value `row` will do that. If you’re writing in Arabic,
    or another right-to-left (RTL) language, you likely want the flex items to be
    laid out from right to left, and from top to bottom. The default value `row` will
    do that, too.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在使用英语或其他从左到右（LTR）语言创建网站，你可能希望弹性项目从左到右、从上到下布局。默认值`row`可以实现这一点。如果你使用阿拉伯语或其他从右到左（RTL）语言，你可能希望弹性项目从右到左、从上到下布局。默认值`row`也能够实现这一点。
- en: 'Using `flex-direction: row` arranges the flex items in the same direction as
    the text direction, also known as the *writing mode*, whether the language is
    RTL or LTR. While most websites are presented in left-to-right languages, some
    sites are in right-to-left languages, and yet others are top-to-bottom. With flexbox,
    when you change the writing mode, flexbox takes care of changing the flex direction
    for you.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`flex-direction: row`将弹性项目按照文本方向（也称为*写作模式*）的相同方向排列，无论语言是RTL还是LTR。尽管大多数网站使用从左到右的语言呈现，有些网站使用从右到左的语言，还有一些是从上到下的。使用flexbox，当你改变写作模式时，flexbox会帮助你改变弹性方向。'
- en: The writing mode is set by the `writing-mode`, `direction`, and `text-orientation`
    properties, or by the `dir` attribute in HTML. (These are covered in [Chapter 15](ch15.html#text_properties).)
    When the writing mode is right to left, the direction of the main-axis—and therefore
    the flex items within the flex container—will go from right to left when the `flex-direction`
    is `row`. This is illustrated in [Figure 11-8](#four-vals-flex-dir).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 写作模式由`writing-mode`、`direction`和`text-orientation`属性设置，或者由HTML中的`dir`属性设置。（这些内容在[第15章](ch15.html#text_properties)中有详细介绍。）当写作模式为从右到左时，主轴的方向——因此弹性容器内的弹性项目——在`flex-direction`为`row`时将从右到左进行。这在[图
    11-8](#four-vals-flex-dir)中有示例。
- en: '![The four values of flex-direction when direction is right to left, demonstrated
    here with display: inline-flex;](assets/css5_1108.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![当方向为从右到左时，使用`inline-flex`显示的`flex-direction`的四个值。](assets/css5_1108.png)'
- en: Figure 11-8\. The four values of `flex-direction` when writing direction is
    right to left [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-rtl-four-values.html)
  id: totrans-80
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-8\. 当写作方向为从右到左时`flex-direction`的四个值 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-rtl-four-values.html)
- en: Note
  id: totrans-81
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If the CSS `direction` value is different from the `dir` attribute value on
    an element, the CSS property value takes precedence over the HTML attribute. The
    specifications strongly recommend using the HTML attribute rather than the CSS
    property.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果CSS中的`direction`值与元素上的`dir`属性值不同，则CSS属性值优先于HTML属性。规范强烈建议使用HTML属性而不是CSS属性。
- en: Vertically written languages include Bopomofo, Egyptian hieroglyphs, Hiragana,
    Katakana, Han, Hangul, Meroitic cursive and hieroglyphs, Mongolian, Ogham, Old
    Turkic, Phags Pa, Yi, and sometimes Japanese. These languages are displayed vertically
    only when a vertical writing mode is specified. If not, all of those languages
    are treated as horizontal.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 竖排文字包括注音符号、埃及象形文字、平假名、片假名、汉字、韩文、麦洛莱迪书写体和象形文字、蒙古文、欧甘文、古代突厥文、八思巴文、彝文，有时还包括日语。这些语言只有在指定了竖排写作模式时才会竖排显示，否则均视为水平排列。
- en: 'For top-to-bottom languages, `writing-mode: horizontal-tb` is in effect, meaning
    the main-axis is rotated 90 degrees clockwise from the default left to right.
    Thus, `flex-direction: row` goes from top to bottom, and `flex-direction: column`
    proceeds from right to left. [Figure 11-9](#writing_mode_horizontal_tb) shows
    the effects of the various `flex-direction` values on the following markup:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '对于自上而下的语言，`writing-mode: horizontal-tb` 生效，这意味着主轴顺时针旋转 90 度，从默认的左到右变为从上到下，而
    `flex-direction: column` 则从右到左进行。[图 11-9](#writing_mode_horizontal_tb) 展示了各种 `flex-direction`
    值对以下标记的影响：'
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '![The four values of flex-direction when writing mode is horizontal-tb](assets/css5_1109.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![水平-tb 写入模式时 flex-direction 的四个值](assets/css5_1109.png)'
- en: Figure 11-9\. The four values of `flex-direction` when writing mode is horizontal-tb
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-ttb-four-values.html)
  id: totrans-87
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-9\. 写入模式为 horizontal-tb 时 `flex-direction` 的四个值 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-direction-ttb-four-values.html)
- en: 'That’s right: the rows are vertical, and columns are horizontal. Not only that,
    but the basic `column` direction is right to left, whereas `column-reverse` runs
    left to right. That’s what comes of applying these values to a top-to-bottom,
    right-to-left language as we see here.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，行是垂直的，列是水平的。不仅如此，基本的 `column` 方向是从右到左，而 `column-reverse` 则是从左到右。这就是将这些值应用于自上而下、从右到左语言时所产生的结果。
- en: All right, you’ve seen various ways flex direction and writing modes interact.
    But so far, all the examples have shown a single row or column of flex items.
    What happens when the flex items’ *main dimension* (their combined inline sizes
    for `row` or combined block sizes for `column`) don’t fit within the flex container?
    We can either have them overflow the container or can allow them to wrap onto
    additional flex lines. Also, we’ll later talk about how to allow flex items to
    shrink (or grow) to fit the container.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，您已经看到了 flex 方向和书写模式相互作用的各种方式。但到目前为止，所有示例都显示了单行或单列的 flex 项。当 flex 项的 *主尺寸*（它们的组合内联尺寸用于
    `row` 或组合块尺寸用于 `column`）不能适合 flex 容器时会发生什么？我们可以让它们溢出容器，或者允许它们换行到额外的 flex 行上。此外，我们将稍后讨论如何允许
    flex 项收缩（或扩展）以适应容器。
- en: Wrapping Flex Lines
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包裹 Flex 行
- en: If all the flex items don’t fit into the main-axis of the flex container, the
    flex items will not wrap by default, nor will they necessarily resize. Rather,
    the flex items may shrink if allowed to do so via the flex item’s `flex` property
    (see [“Growth Factors and the flex Property”](#growth-factors-and-the-flex-property));
    otherwise, the flex items will overflow the bounding container box.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有 flex 项不适合 flex 容器的主轴，则默认情况下 flex 项不会自动换行，也不一定会调整大小。相反，如果通过 flex 项的 `flex`
    属性允许的话，flex 项可能会收缩；否则，flex 项将溢出边界容器框。
- en: You can affect this behavior. The `flex-wrap` property sets whether a flex container
    is limited to a single line or is allowed to become multiline when needed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以影响此行为。`flex-wrap` 属性设置一个 flex 容器是限制为单行还是在需要时允许多行。
- en: 'When the `flex-wrap` property is set to allow for multiple flex lines via `wrap`
    or `wrap-reverse`, it determines where additional lines of flex items appear:
    either before or after the original line of flex items.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `flex-wrap` 属性设置为通过 `wrap` 或 `wrap-reverse` 允许多个 flex 行时，它确定额外的 flex 项行在原始
    flex 项行之前或之后出现的位置。
- en: '[Figure 11-10](#three_values_of_flex_wrap) demonstrates the three values of
    the `flex-wrap` property when the `flex-direction` value is `row` (and the language
    is LTR). Where these examples show two flex lines, the second line and subsequent
    flex lines are added along the direction of the cross-axis (in this case, the
    vertical axis).'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-10](#three_values_of_flex_wrap) 展示了 `flex-direction` 值为 `row`（语言为 LTR
    时）时 `flex-wrap` 属性的三个值的示例。在这些示例中显示了两个 flex 行，第二行及后续 flex 行沿着交叉轴的方向添加（在这种情况下是垂直轴）。'
- en: '![The three values of flex-wrap property](assets/css5_1110.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![flex-wrap 属性的三个值](assets/css5_1110.png)'
- en: Figure 11-10\. The three values of the `flex-wrap` property in a row-oriented
    flow [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-three-values.html)
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-10\. 在行定向流中 `flex-wrap` 属性的三个值 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-three-values.html)
- en: 'When `wrap` is set, the cross-axis is the same as the block axis for `flex-direction:
    row` and `row-reverse`, and is the same as the inline axis of the language for
    `flex-direction: column` and `column-reverse`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '当设置 `wrap` 时，交叉轴与 `flex-direction: row` 和 `row-reverse` 的块轴相同，并且与语言的内联轴相同，例如
    `flex-direction: column` 和 `column-reverse`。'
- en: 'The difference is that when `flex-wrap` is set to `wrap-reverse`, the cross-axis
    direction is reversed: subsequent flex lines are drawn above the previous line
    in the case of `row` and `row-reverse`, and to the left of the previous column
    in the case of `column-reverse` (assuming an LTR language such as English).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，当 `flex-wrap` 设置为 `wrap-reverse` 时，交叉轴方向被反转：在 `row` 和 `row-reverse` 的情况下，后续的
    flex 行位于前一行的上方，在 `column-reverse` 的情况下位于前一列的左侧（假设是像英语这样的从左到右的语言）。
- en: We’ll talk more about axes in just a moment, but first, let’s talk about the
    shorthand property that brings flex direction and wrapping together.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后会详细讨论轴，但首先让我们谈谈将 flex 方向和包裹整合在一起的缩写属性。
- en: Defining Flexible Flows
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义灵活的流动
- en: The `flex-flow` property lets you define the wrapping directions of the main-
    and cross-axes, and whether the flex items can wrap to more than one line if needed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-flow` 属性允许您定义主轴和交叉轴的包裹方向，以及 flex 项目在需要时是否可以换行到多行。'
- en: The `flex-flow` shorthand property sets the `flex-direction` and `flex-wrap`
    properties to define the flex container’s wrapping and main- and cross-axes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-flow` 缩写属性设置 `flex-direction` 和 `flex-wrap` 属性，定义 flex 容器的包裹和主轴与交叉轴。'
- en: 'As long as `display` is set to `flex` or `inline-flex`, omitting `flex-flow`,
    `flex-direction`, and `flex-wrap` is the same as declaring any of the following
    three, all of which have the result shown in [Figure 11-11](#flex_flow_row):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 `display` 设置为 `flex` 或 `inline-flex`，省略 `flex-flow`、`flex-direction` 和 `flex-wrap`
    与声明以下三者之一是相同的，所有这些选项的结果如 [图 11-11](#flex_flow_row) 所示：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '![flex-flow: row;](assets/css5_1111.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![flex-flow: row;](assets/css5_1111.png)'
- en: Figure 11-11\. A row-oriented unwrapped flex flow [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-flow-unwrapped-row.html)
  id: totrans-106
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-11\. 一个面向行的未包裹的 flex 流 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-flow-unwrapped-row.html)
- en: In LTR writing modes, declaring any of the property values just listed, or omitting
    the `flex-flow` property altogether, will create a flex container with a horizontal
    main-axis that doesn’t wrap. [Figure 11-11](#flex_flow_row) illustrates flex items
    distributed along the horizontal axis, on one line, overflowing a container that’s
    500 pixels wide.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在从左到右的书写模式中，声明列出的任何属性值，或完全省略 `flex-flow` 属性，都将创建一个不换行的水平主轴的 flex 容器。[图 11-11](#flex_flow_row)
    展示了沿水平轴分布的 flex 项目，一行内溢出了宽度为 500 像素的容器。
- en: 'If instead we want a reverse-column-oriented flow with wrapping, either of
    these will suffice:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个反向列导向的流动并且带有包裹，以下任何一种都足够：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In an LTR language like English, this causes the flex items to flow from bottom
    to top, starting at the left side, and wrap to new columns in the rightward direction.
    In a vertical writing mode like Japanese, which is right-to-left when written
    vertically, the columns would be horizontal, flowing from right to left, and wrap
    top to bottom.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在像英语这样的从左到右的语言中，这导致 flex 项目从底部向顶部流动，从左侧开始，并在右向方向上换行到新列。在像日语这样的垂直书写模式中，列会是水平的，从右向左流动，并在顶部向底部换行。
- en: We’ve been using terms like *main-axis* and *cross-axis* without really delving
    into what they mean. It’s time to clarify all that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在使用像*主轴*和*交叉轴*这样的术语，但没有真正深入探讨它们的含义。现在是时候澄清一切了。
- en: Understanding Axes
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解轴
- en: 'First: flex items are laid out along the main-axis. Flex lines are added in
    the direction of the cross-axis.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 首先：flex 项目沿着主轴布局。flex 行根据交叉轴方向添加。
- en: Up until we introduced `flex-wrap`, all the examples had a single line of flex
    items. In that single line, the flex items were laid out along the main-axis,
    in the *main direction*, from main-start to main-end. When we added flex wrapping,
    new flex lines were added along the cross-axis, in the *cross direction*, going
    from cross-start to cross-end.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们介绍 `flex-wrap` 之前，所有示例都是单行的 flex 项目。在这一行中，flex 项目沿着主轴，在*主方向*上从主起点到主终点布局。当我们添加
    flex 包裹时，新的 flex 行被添加到交叉轴上，在*交叉方向*上从交叉起点到交叉终点。
- en: 'As you can see, a lot of terms are used in that paragraph. Here are some quick
    definitions:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，该段落中使用了许多术语。这里是一些快速定义：
- en: Main-axis
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 主轴
- en: The axis along which content flows. In flexbox, this is the direction in which
    flex items are flowed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '-   内容流动的轴。在伸缩盒中，这是伸缩项流动的方向。'
- en: Main-size
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '-   主尺寸'
- en: The total length of the content along the main-axis.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '-   沿主轴的内容总长度。'
- en: Main-start
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '-   主轴起点'
- en: The end of the main-axis from which content begins to flow.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '-   内容开始流动的主轴端点。'
- en: Main-end
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '-   主轴终点'
- en: The end of the main-axis toward which content flows, opposite the main-start.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '-   内容流向的主轴端点，与主轴起点相反。'
- en: Cross-axis
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '-   交叉轴'
- en: The axis along which flex lines are “stacked.” In flexbox, this is the direction
    in which new lines of flex items are placed, if flex wrapping is permitted.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '-   “堆叠”伸缩线的轴。在伸缩盒中，这是放置新伸缩项行的方向，如果允许伸缩换行。'
- en: Cross-size
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '-   交叉尺寸'
- en: The total length of the content along the cross-axis.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '-   沿交叉轴的内容总长度。'
- en: Cross-start
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '-   交叉起点'
- en: The edge of the cross-axis where blocks begin to be stacked.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '-   交叉轴的边缘，从此开始堆叠块。'
- en: Cross-end
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '-   交叉终点'
- en: The opposite edge of the cross-axis from the cross-start.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '-   与交叉起点相对的交叉轴的边缘。'
- en: While these terms may sound like logical properties such as `margin-inline-start`,
    they are not the same thing. Here, the physical direction of each changes depending
    on the value of the `flex-direction` property. In fact, the meaning of each term
    in the context of layout depends on the combination of the flex direction, the
    flex wrapping, and the writing mode. Charting all the combinations for every writing
    mode would get difficult, so let’s examine what they mean for LTR languages.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '-   尽管这些术语听起来像逻辑属性，比如 `margin-inline-start`，但它们并不是同一回事。在这里，每个术语在布局上下文中的意义取决于
    `flex-direction` 的组合、伸缩换行和书写模式的值。为每种书写模式的所有组合绘制图表会变得困难，因此让我们来看看它们在 LTR 语言中的含义。'
- en: Note
  id: totrans-133
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '-   注意'
- en: It’s important to understand that direction gets reversed when writing direction
    is reversed. To make explaining (and understanding) flex layout much simpler,
    the rest of the explanations and examples in this chapter are based on an LTR
    writing mode, but will include how writing mode impacts the flex properties and
    features discussed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '-   重要的是要理解，当书写方向被反转时，方向也会被反转。为了更简单地解释（和理解）伸缩布局，本章节中其余的解释和示例基于 LTR 书写模式，但会包括书写模式对讨论的伸缩属性和特性的影响。'
- en: When thinking about `flex-direction`, we know that the flex items will start
    being laid out along the main-axis of the flex container, starting from the main-start
    edge and proceeding toward the main-end edge. If the `flex-wrap` property is used
    to allow the container to wrap when the flex items don’t fit onto one line, the
    flex lines are laid out starting from the cross-start edge and proceeding toward
    the cross-end edge.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '-   当考虑 `flex-direction` 时，我们知道伸缩项将从伸缩容器的主轴开始布局，从主轴起点边缘向主轴终点边缘前进。如果使用 `flex-wrap`
    属性允许容器在伸缩项无法放入一行时换行，那么伸缩线将从交叉起点边缘开始布局，向交叉终点边缘前进。'
- en: 'As shown in [Figure 11-12](#flex_lines_on_row_and_row_reverse), when we have
    horizontal rows of flex items, the cross-axis is vertical. In these examples,
    with `flex-flow: row wrap` and `flex-flow: row-reverse wrap` set on horizontal
    languages, new flex lines are added below preceding flex lines. The cross-size
    is the opposite of main-size, being height for `row` and `row-reverse` flex directions,
    and width for `column` and `column-reverse` directions, in both RTL and LTR languages.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '如图 [11-12](#flex_lines_on_row_and_row_reverse) 所示，当我们有水平排列的伸缩项时，交叉轴是垂直的。在这些示例中，对于水平语言，使用
    `flex-flow: row wrap` 和 `flex-flow: row-reverse wrap` 设置时，新的伸缩线会添加到前面的伸缩线下方。交叉尺寸与主尺寸相反，对于
    `row` 和 `row-reverse` 伸缩方向，无论是 RTL 还是 LTR 语言，高度是主尺寸，而对于 `column` 和 `column-reverse`
    方向，则是宽度。'
- en: By contrast, the `wrap-reverse` value inverts the direction of the cross-axis.
    Normally for `flex-direction` of `row` and `row-reverse`, the cross-axis goes
    from top to bottom, with the cross-start on top and cross-end on the bottom. When
    `flex-wrap` is `wrap-reverse`, the cross-start and cross-end directions are swapped,
    with the cross-start on the bottom, cross-end on top, and the cross-axis going
    from bottom to top. Additional flex lines get added on top of, or above, the previous
    line.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '-   相比之下，`wrap-reverse` 值颠倒了交叉轴的方向。通常对于 `row` 和 `row-reverse` 的 `flex-direction`，交叉轴从上到下，交叉起点在顶部，交叉终点在底部。当
    `flex-wrap` 为 `wrap-reverse` 时，交叉起点和交叉终点的方向被交换，交叉起点在底部，交叉终点在顶部，交叉轴从底部到顶部。额外的伸缩线添加在前一行的顶部或上方。'
- en: '![Flex lines on row and row-reverse when flex-wrap: wrap is set](assets/css5_1112.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![当设置 flex-wrap: wrap 时，行和行反向上的弹性线](assets/css5_1112.png)'
- en: Figure 11-12\. Stacking of row-oriented flex lines
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-12\. 行向弹性行的堆叠
- en: If the `flex-direction` is set to `column` or `column-reverse`, by default the
    cross-axis goes from left to right in LTR languages, with new flex lines being
    added to the right of previous lines. As shown in [Figure 11-13](#flex_wrap_wrap_reverse),
    when `flex-wrap` is set to `wrap-reverse`, the cross-axis is inverted, with cross-start
    being on the right, cross-end being on the left, the cross-axis going from right
    to left, and additional flex lines being added to the left of the previously drawn
    line.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `flex-direction` 设置为 `column` 或 `column-reverse`，默认情况下，交叉轴从左到右在从左到右的语言环境中进行，新的弹性行被添加到之前的行右侧。如
    [图 11-13](#flex_wrap_wrap_reverse) 所示，当 `flex-wrap` 设置为 `wrap-reverse` 时，交叉轴被反转，交叉起始位于右侧，交叉末端位于左侧，交叉轴从右到左，额外的弹性行被添加到之前绘制行的左侧。
- en: '![Flex lines on columns and column-reverse when flex-wrap: wrap-reverse is
    set](assets/css5_1113.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![当设置 flex-wrap: wrap-reverse 时，列和列反向上的弹性线](assets/css5_1113.png)'
- en: Figure 11-13\. Stacking of column-oriented flex lines
  id: totrans-142
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-13\. 列向弹性行的堆叠
- en: Arrangement of Flex Items
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性项目的排列
- en: In our examples thus far, we’ve skated past the precise arrangement of the flex
    items within each flex line, and how that’s determined. It might seem intuitive
    that a row fills in horizontally, but why should all the items huddle toward the
    main-start edge? Why not have them grow to fill all available space, or distribute
    themselves throughout the line?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今的示例中，我们已经简单讨论了每个弹性行内弹性项目的具体排列方式，以及如何确定这一排列方式。在水平填充一行似乎是直观的，但为什么所有项目都聚集在主起始边缘？为什么不让它们增长以填满所有可用空间，或者在整行中分布？
- en: For an example of what we’re talking about here, check out [Figure 11-14](#empty-space-dir-main-cross).
    Notice the extra space at the top left. In this bottom-to-top, right-to-left flow,
    new flex items get placed above the previous ones, with new wrap lines being placed
    to the left of each previously filled line.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 作为我们这里讨论的一个例子，请查看 [图 11-14](#empty-space-dir-main-cross)。注意左上方的额外空间。在此自下而上、从右到左的流程中，新的弹性项目被放置在之前的项目之上，新的换行被放置在每条先前填充行的左侧。
- en: '![No matter the value of flex flow, the empty space will be in the direction
    of main-end and cross-end](assets/css5_1114.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![无论 flex 流的值如何，空白空间都将朝主轴末端和交叉轴末端](assets/css5_1114.png)'
- en: Figure 11-14\. Empty space will be in the direction of main-end and cross-end
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-14\. 空白区域将朝主轴末端和交叉轴末端
- en: By default, no matter the values of `flex-flow`, empty space outside the flex
    items in a flex container will be in the direction of main-end and cross-end,
    but CSS has properties that allow us to alter that.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，无论 `flex-flow` 的值如何，弹性容器中弹性项目外的空白区域将朝主轴末端和交叉轴末端，但 CSS 具有允许我们改变这一行为的属性。
- en: Flex Item Alignment
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性项目的对齐
- en: In our examples thus far, whenever the flex items do not completely fill the
    flex container, the flex items are all grouped toward the main-start on the main-axis.
    Flex items can be flush against the main-end instead, centered, or even spaced
    out in various ways across the main-axis.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们迄今的示例中，每当弹性项目未完全填满弹性容器时，所有弹性项目都会集中于主轴的主起始端。弹性项目也可以靠近主轴的主末端，居中，或者以各种方式在主轴上分布。
- en: The flex layout specification provides us with flex container properties to
    control the distribution of space. The `justify-content` property controls how
    flex items within a flex line are distributed along the main-axis. The `align-items`
    property defines the default distribution of the flex items along the cross-axis
    of each flex line; this global default can be individually overridden with the
    flex item `align-self` property. When there is more than one flex line and wrapping
    is enabled, the `align-content` property defines how those flex lines are distributed
    along the cross-axis of the flex container.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性布局规范为我们提供了弹性容器属性，用于控制空间的分布。`justify-content` 属性控制弹性行内的弹性项目沿主轴的分布方式。`align-items`
    属性定义了每个弹性行上弹性项目沿交叉轴的默认分布；这一全局默认值可以通过弹性项目的 `align-self` 属性单独覆盖。当存在多个弹性行并且启用了换行时，`align-content`
    属性定义了这些弹性行在弹性容器的交叉轴上的分布方式。
- en: Justifying Content
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容的对齐
- en: The `justify-content` property enables us to direct the way flex items are distributed
    along the main-axis of the flex container within each flex line, and how to handle
    situations where information might be lost. This property is applied to the flex
    container, *not* the individual flex items.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`justify-content`属性使我们能够指导 flex 容器中每个 flex 行沿主轴分布 flex 项目的方式，并处理可能丢失信息的情况。这个属性应用于
    flex 容器，*而不是*单个 flex 项目。'
- en: Note
  id: totrans-154
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The `safe` and `unsafe` values, introduced with several other values in CSS
    Box Alignment Module Level 3, are recognized but not supported in most browsers
    as of early 2023\. This means the value is ignored, but its presence does not
    render the rest of the declaration invalid.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`safe` 和 `unsafe` 值，与 CSS Box Alignment Module Level 3 中的其他值一起引入，截至 2023 年初在大多数浏览器中被识别但不被支持。这意味着该值被忽略，但其存在并不使其他声明无效。'
- en: '[Figure 11-15](#justify-content-values) shows the effects of the various values
    in a writing mode like English.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-15](#justify-content-values)展示了在类似英语的书写模式中各种值的效果。'
- en: '![The values of the justify-content property](assets/css5_1115.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![justify-content属性的值](assets/css5_1115.png)'
- en: Figure 11-15\. The values of the `justify-content` property [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-values.html)
  id: totrans-158
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-15. `justify-content` 属性的值 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-values.html)
- en: With `start` and `flex-start`, flex items are placed flush against main-start.
    With `end` and `flex-end`, flex items are justified toward main-end. The `center`
    option groups the items flush against each other, centered in the middle of the
    main-axis. The `left` and `right` options place items flush against the named
    sides of the box, regardless of the actual axis direction.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `start` 和 `flex-start`，flex 项目紧贴主开始。使用 `end` 和 `flex-end`，flex 项目朝向主结束对齐。`center`
    选项将项目紧贴在一起，居中于主轴的中间。`left` 和 `right` 选项将项目紧贴在盒子的指定侧，而不考虑实际轴方向。
- en: The `space-between` value puts the first flex item on a flex line flush with
    main-start and the last flex item in each flex line flush with main-end, and then
    puts an equal amount of space between every pair of adjacent flex items. The `space-evenly`
    value takes the leftover space and splits it so that every gap is the same length.
    This means the spaces at the start and end edges of the main-axis will be the
    same size as the spaces placed between flex items.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`space-between` 值将第一个 flex 项目放置在 flex 行主开始处，并将每个 flex 行中的最后一个 flex 项目放置在主结束处，然后在每对相邻
    flex 项目之间放置相等数量的空间。`space-evenly` 值获取剩余空间并将其分割，以使每个间隙长度相同。这意味着主轴起始和结束边缘的空间大小将与放置在
    flex 项目之间的空间相同。'
- en: By contrast, `space-around` splits up the leftover space and then applies half
    of each portion to each flex item, as if there were noncollapsing margins of equal
    size around each item. Note that this means the space between any two flex items
    is twice that of the spaces at the main-start and main-end of the flex line.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`space-around`将剩余空间分开，然后将每个部分的一半应用于每个 flex 项目，就好像每个项目周围有相等大小的不折叠边距一样。注意，这意味着任意两个
    flex 项目之间的间距是 flex 行主开始和主结束处空间的两倍。
- en: The `stretch` value has no effect as a value of `justify-content` in flexbox.
    As you’ll see in the next chapter, when placed on a grid container, it causes
    grid items to grow in size until they take up all available space in the main-axis
    direction.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretch` 值在 flexbox 中作为 `justify-content` 的值没有效果。在下一章节中，您将看到它放置在网格容器上时，会导致网格项目在主轴方向上增大，直到占据所有可用空间。'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We’ll cover `safe` and `unsafe`, which vary how the browser should handle items
    that overflow the container along the cross-axis, in [“Safe and unsafe alignment”](#safe-and-unsafe-alignment).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论 `safe` 和 `unsafe`，它们会影响浏览器如何处理沿交叉轴溢出的项目，在[“安全和不安全对齐”](#safe-and-unsafe-alignment)中。
- en: Justifying and overflow
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对齐和溢出
- en: If flex items are not allowed to wrap to multiple lines and overflow their flex
    line, the value of `justify-content` influences the way the flex items will overflow
    the flex container.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不允许 flex 项目换行到多行并溢出其 flex 行，`justify-content` 的值将影响 flex 项目溢出 flex 容器的方式。
- en: 'Setting `justify-content: start` or `flex-start` explicitly sets the default
    behavior of grouping the flex items toward main-start, placing the first flex
    item of each flex line flush against the main-start side. Each subsequent flex
    item then gets placed flush with the preceding flex item’s main-end side. (Remember,
    the location of the main-start side depends on the flex direction and writing
    mode.) If there isn’t enough room for all the items and wrapping is not allowed,
    the items will overflow the main-end edge. This is illustrated in [Figure 11-16](#justify_content_start).'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '明确设置`justify-content: start`或`flex-start`会将 flex 项目分组到主开始的默认行为，并将每个 flex 行的第一个
    flex 项目放置在主开始侧。然后，每个后续的 flex 项目都会与前一个 flex 项目的主结束侧对齐。（请记住，主开始侧的位置取决于 flex 方向和书写模式。）如果没有足够的空间放置所有项目并且不允许换行，则项目将溢出到主结束边缘。这在
    [图 11-16](#justify_content_start) 中有所说明。'
- en: '![](assets/css5_1116.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1116.png)'
- en: Figure 11-16\. The effects of `start` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-start.html)
  id: totrans-169
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-16\. `start` 内容对齐的效果 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-start.html)
- en: 'The mirror of this is setting `justify-content: end` or `flex-end`, which puts
    the last flex on a line flush against the main-end with each preceding flex item
    being placed flush with the subsequent item. In this case, if the items aren’t
    allowed to wrap, and if there isn’t enough room for all the items, the items will
    overflow on the main-start edge, as illustrated in [Figure 11-17](#justify_content_end).'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '其镜像是设置`justify-content: end`或`flex-end`，它将最后一个 flex 放置在与主结束对齐的行上，并使每个前置 flex
    项目与后续项目对齐。在这种情况下，如果不允许项目换行，并且没有足够的空间放置所有项目，则项目将溢出到主开始边缘，如 [图 11-17](#justify_content_end)
    所示。'
- en: '![](assets/css5_1117.png)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1117.png)'
- en: Figure 11-17\. The effects of `end` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-end.html)
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-17\. `end` 内容对齐的效果 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-end.html)
- en: 'Setting `justify-content: center` will pack all the items flush against each
    other, and center them on the center of the flex line instead of packing them
    against the main-start or main-end. If there isn’t enough room for all the items
    and they aren’t allowed to wrap, the items will overflow evenly on both the main-start
    and main-end edges.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '设置`justify-content: center`会将所有项目紧密对齐，并将它们居中放置在 flex 行的中心，而不是将它们放置在主开始或主结束。如果没有足够的空间放置所有项目并且不允许换行，则项目将均匀地溢出到主开始和主结束边缘。'
- en: '[Figure 11-18](#justify_content_center) illustrates these effects.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-18](#justify_content_center) 说明了这些效果。'
- en: '![](assets/css5_1118.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1118.png)'
- en: Figure 11-18\. The effects of `center` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-center.html)
  id: totrans-176
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-18\. `center` 内容对齐的效果 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-center.html)
- en: 'As the `left` and `right` values, they always start packing from the left or
    right edge of a row, regardless of axis directions. Thus, `justify-content: left`
    will always justify row-based content to the left, whether the main-axis goes
    left to right or right to left. In column-based content, `left` is treated the
    same as `start`, and `right` the same as `end`. Any overflow will occur on the
    opposite side from where the packing started; that is, flex items will overflow
    on the right edge for `justify-content: left` and on the left edge for `right`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '作为`left`和`right`值，它们始终从行的左侧或右侧开始打包，而不管轴的方向如何。因此，`justify-content: left`始终会将基于行的内容对齐到左侧，无论主轴是从左到右还是从右到左。在基于列的内容中，`left`和`start`是一样的，`right`和`end`是一样的。任何溢出都将发生在打包开始的相反侧；也就是说，对于`justify-content:
    left`，flex 项目将溢出到右侧边缘，对于`right`则溢出到左侧边缘。'
- en: With those relatively simple cases covered, let’s look at values that alter
    space between and around flex items, and compare them to their wrapped cases.
    Note that if flex items are allowed to wrap onto multiple lines, the space around
    each flex item is based on the available space in their specific flex line only,
    and will not (in most cases) be consistent from one line to the next.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 针对这些相对简单的情况，让我们看看会改变 flex 项目之间和周围空间的值，并将它们与它们的换行情况进行比较。请注意，如果允许 flex 项目换行到多行上，则每个
    flex 项目周围的空间都基于它们特定 flex 行中的可用空间，并且（在大多数情况下）不会从一行到另一行保持一致。
- en: 'Setting `justify-content: space-between` puts the first flex item flush with
    main-start and the last flex item on the line flush with main-end, and then puts
    an equal amount of space around each flex item, until the flex line is filled
    (see [Figure 11-19](#justify_content_space-between)). If we have three flex items,
    the same amount of space will be between the first and second items as between
    the second and third, but there will be no extra empty space between the main-start
    and main-end edges of the container and the first and last flex items in the line.
    This means if a line has only one flex item, it will be flush with the main-start
    edge, not centered. If there isn’t enough space to fit all the flex items and
    they aren’t allowed to wrap, the items will overflow on the main-end edge, yielding
    an effect visually indistinguishable from `justify-content: start`.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '设置`justify-content: space-between`会使第一个 flex 项目与主轴起始边缘对齐，最后一个 flex 项目与主轴结束边缘对齐，然后在每个
    flex 项目周围均匀分布相等量的空间，直到填满 flex 行（见[图 11-19](#justify_content_space-between)）。如果有三个
    flex 项目，则第一个和第二个项目之间的空间与第二个和第三个项目之间的空间相同，但容器的主轴起始边缘和主轴结束边缘与行中的第一个和最后一个 flex 项目之间不会有额外的空白空间。这意味着如果一行只有一个
    flex 项目，则它将与主轴起始边缘对齐，而不是居中。如果没有足够的空间来容纳所有的 flex 项目，并且它们不允许换行，则项目将在主轴结束边缘上溢出，产生与`justify-content:
    start`视觉上无法区分的效果。'
- en: '![](assets/css5_1119.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1119.png)'
- en: Figure 11-19\. The effects of `space-between` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-between.html)
  id: totrans-181
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-19\. `space-between`内容对齐的效果 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-between.html)
- en: 'Setting `justify-content: space-around` evenly distributes the extra space
    on the line around each of the flex items, as if noncollapsing margins of equal
    size were around each element on the main-dimension sides ([Figure 11-20](#justify_content_space-around)).
    Thus, there will be twice as much space between the first and second item as there
    is between main-start and the first item, and main-end and the last item. If there
    isn’t enough room for all the items and they aren’t allowed to wrap, the items
    will overflow evenly on both the main-start and main-end edges.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '设置`justify-content: space-around`会均匀分布在每个 flex 项目周围的额外空间，就像主维度两侧的非折叠边距大小相等的元素一样（见[图 11-20](#justify_content_space-around)）。因此，第一个项目与第二个项目之间的空间将是主轴起始边缘与第一个项目之间以及主轴结束边缘与最后一个项目之间的两倍。如果没有足够的空间容纳所有项目，并且它们不允许换行，则项目将在主轴起始边缘和主轴结束边缘上均匀溢出。'
- en: '![](assets/css5_1120.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1120.png)'
- en: Figure 11-20\. The effects of `space-around` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-around.html)
  id: totrans-184
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-20\. `space-around`内容对齐的效果 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-around.html)
- en: 'Setting `justify-content: space-evenly` means the user agent counts the items,
    adds one, and then splits any extra space on the line by that many (i.e., if we
    have five items, the amount of space is split into six equal-size portions); see
    [Figure 11-21](#justify_content_space-evenly). One portion of the space is placed
    before each item on the line, as if it were a noncollapsing margin, and the last
    portion is placed after the last item on the list. Thus, the same amount of space
    will appear between the first and second item as there is between main-start and
    the first item, and main-end and the last item. If there isn’t enough room for
    all the items and they aren’t allowed to wrap, the items will overflow evenly
    on both the main-start and main-end edges.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '设置`justify-content: space-evenly`意味着用户代理会计算项目数，然后增加一个，然后将行上的任何额外空间分成这么多等份（例如，如果有五个项目，则空间分成六个相等大小的部分）；参见[图 11-21](#justify_content_space-evenly)。空间的一部分被放置在每个列表项之前，就像它是一个非折叠边距一样，并且最后一部分被放置在列表的最后一个项之后。因此，第一个项目与第二个项目之间的空间将与主轴起始边缘与第一个项目之间以及主轴结束边缘与最后一个项目之间的空间相同。如果没有足够的空间容纳所有项目，并且它们不允许换行，则项目将在主轴起始边缘和主轴结束边缘上均匀溢出。'
- en: '![](assets/css5_1121.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1121.png)'
- en: Figure 11-21\. The effects of `space-evenly` content justification [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-evenly.html)
  id: totrans-187
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-21\. `space-evenly`内容对齐的效果 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-space-evenly.html)
- en: The `stretch` value has no effect when set as the value of `justify-content`
    on a flex container, and is treated the same as `normal`. As you’ll see in the
    next chapter, when placed on a grid container, it causes the grid items to grow
    in size until they take up all available space in the main-axis direction.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretch` 值在作为 `justify-content` 的值设置在 flex 容器上时没有效果，并且被视为 `normal` 一样。正如你将在下一章中看到的那样，在放置在网格容器上时，它会导致网格项在主轴方向上增长直至占据所有可用空间。'
- en: 'And finally, `justify-content: normal` is treated the same as `justify-content:
    start`. This is the case for historical reasons too boring and lengthy to get
    into here, but what it means is that the default value of `justify-content` is
    essentially `start`, even if it is technically `normal`.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，`justify-content: normal` 被视为与 `justify-content: start` 相同。出于历史原因，这也是情况太无聊和太长以至于不在这里讨论，但它意味着
    `justify-content` 的默认值实质上是 `start`，即使在技术上是 `normal`。'
- en: Note in the previous few examples that when flex items are allowed to wrap onto
    multiple lines, the space around each flex item is based on the available space
    in its specific flex line only, and will not (in many cases) be consistent from
    one line to the next.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的几个示例中，请注意，当允许 flex 项换行到多行时，每个 flex 行中的空间都基于其特定 flex 行中的可用空间，并且通常不会从一行到另一行保持一致。
- en: justify-content example
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: justify-content 示例
- en: 'We took advantage of the default value of `justify-content` in [Figure 11-2](#simple_tabbed_navigation),
    creating a left-aligned navigation bar. By changing the default value to `justify-content:
    flex-end`, we can right-align the navigation bar in English:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '我们利用了 `justify-content` 在 [图 11-2](#simple_tabbed_navigation) 中的默认值，创建了一个左对齐的导航栏。通过将默认值更改为
    `justify-content: flex-end`，我们可以在英文中右对齐导航栏：'
- en: '[PRE13]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Note that `justify-content` is applied to the flex container. If we’d applied
    to the links themselves, using something like `nav a {justify-content: flex-start;}`,
    no alignment effect would have occurred.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '注意 `justify-content` 应用于 flex 容器。如果我们应用于链接本身，使用类似 `nav a {justify-content:
    flex-start;}`，则不会发生对齐效果。'
- en: A major advantage of `justify-content` is that when the writing direction changes
    (say, for RTL writing modes), we don’t have to alter the CSS to get the tabs where
    they need to go. The flex items are always grouped toward main-start when `flex-start`
    is applied; in English, main-start is on the left. For Hebrew, main-start is on
    the right. If `flex-end` is applied and the `flex-direction` is `row`, then the
    tabs go to the right side in English, and the left side in Hebrew, as shown in
    [Figure 11-22](#right_and_left_aligned_navigation).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`justify-content` 的一个主要优势是，当书写方向改变（比如，对于 RTL 书写模式），我们不必修改 CSS 就可以使标签页到达它们应该去的地方。当应用
    `flex-start` 时，flex 项始终向主轴开始方向分组；在英文中，主轴开始在左侧。对于希伯来文，主轴开始在右侧。如果应用了 `flex-end`
    并且 `flex-direction` 是 `row`，那么在英文中标签页会移动到右侧，在希伯来文中移动到左侧，如[图 11-22](#right_and_left_aligned_navigation)所示。'
- en: '![Right- and left-aligned navigation in LTR and RTL languages using justify-content](assets/css5_1122.png)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![LTR 和 RTL 语言使用 justify-content 的右对齐和左对齐导航](assets/css5_1122.png)'
- en: Figure 11-22\. Internationally robust navigation alignment [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-i18n.html)
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-22\. 国际化强大的导航对齐 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-i18n.html)
- en: This may seem like the main-start and main-end are similar to inline-start and
    inline-end in logical properties. This will feel true when `flex-direction` is
    set to `row`. With `flex-direction:` `row-reverse`, however, the main-start and
    main-end get switched, but the inline-start and inline-end don’t, because the
    inline directions for the flex items remain the same even if their flex order
    changes.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '这可能看起来主轴开始和主轴结束类似于逻辑属性中的内联开始和内联结束。当 `flex-direction` 设置为 `row` 时，这种感觉是正确的。然而，当
    `flex-direction: row-reverse` 时，主轴开始和主轴结束会交换，但内联开始和内联结束不会，因为 flex 项的内联方向即使其 flex
    顺序改变也保持不变。'
- en: 'We could have centered that navigation, as shown in [Figure 11-23](#changing-layout-one-prop):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以像在 [图 11-23](#changing-layout-one-prop) 中显示的那样将导航居中。
- en: '[PRE14]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '![Changing the layout with one property value pair](assets/css5_1123.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![使用一个属性值对改变布局](assets/css5_1123.png)'
- en: Figure 11-23\. Changing the layout with one property value pair [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-i18n-center.html)
  id: totrans-202
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-23\. 使用一个属性值对改变布局 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/justify-content-i18n-center.html)
- en: All the flex items we’ve shown thus far are a single line tall, and therefore
    are the same size in the cross dimension as their sibling flex items. Before discussing
    wrapping flex lines, we need to discuss aligning items of differing dimensions
    along the cross-axis, which is, appropriately enough, called *aligning*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们展示的所有 flex 项目都是单行高度，因此在交叉维度上与其兄弟 flex 项目的大小相同。在讨论换行 flex 行之前，我们需要讨论如何沿交叉轴对齐具有不同尺寸的项目，这恰当地称为
    *对齐*。
- en: Aligning Items
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐项目
- en: Whereas `justify-content` defines how flex items are aligned along the flex
    container’s main-axis, the `align-items` property defines how flex items are aligned
    along its flex line’s cross-axis. As with `justify-content`, `align-items` is
    applied to flex containers, not individual flex items.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 而 `justify-content` 定义了 flex 项目沿 flex 容器的主轴如何对齐，`align-items` 属性定义了如何沿其 flex
    行的交叉轴对齐 flex 项目。与 `justify-content` 类似，`align-items` 应用于 flex 容器，而不是单个 flex 项目。
- en: Note
  id: totrans-206
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: While `align-items` sets the alignment for all the flex items within a container,
    the [`align-self` property](#the-align-self-property) enables overriding the alignment
    for individual flex items, as you’ll see in [“The align-self property”](#the-align-self-property).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `align-items` 设置了容器内所有 flex 项目的对齐方式，[`align-self` 属性](#the-align-self-property)
    允许覆盖单个 flex 项目的对齐方式，如您将在 [“align-self 属性”](#the-align-self-property) 中看到的那样。
- en: In [Figure 11-24](#vals-align-items), note how the flex items are arranged with
    respect to the cross-axis. (The cross-axis is the block axis for row-flowed flex
    containers, and the inline axis for column-flowed flex containers.)
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11-24](#vals-align-items) 中，请注意 flex 项目相对于交叉轴的排列方式。（对于 row-flowed flex
    容器，交叉轴是块轴，对于 column-flowed flex 容器，交叉轴是内联轴。）
- en: '![The values of the align-items property when you have a single row or column
    of flex items](assets/css5_1124.png)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![当您有一行或一列 flex 项目时，align-items 属性的值](assets/css5_1124.png)'
- en: Figure 11-24\. The values of the `align-items` property for both rows and columns
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/align-items-values-rows-cols.html)
  id: totrans-210
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-24\. 行和列的 `align-items` 属性值 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/align-items-values-rows-cols.html)
- en: The default value, `normal`, is treated as `stretch` in flexbox.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值 `normal` 在 flexbox 中被视为 `stretch`。
- en: For `stretch`, the cross-start edge of each flex item is placed against the
    cross-start edge of the container, and the cross-end edges are also placed against
    the cross-end edge of the container. This happens regardless of the size of the
    content inside each flex item, so a flex item with short content (such as “One”)
    will still have its element box fill out the cross-axis size of the flex container.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `stretch`，每个 flex 项目的交叉起始边缘都放置在容器的交叉起始边缘上，而交叉结束边缘也放置在容器的交叉结束边缘上。这不考虑每个 flex
    项目内内容的大小，因此一个具有短内容（如“One”）的 flex 项目仍将其元素框填充为 flex 容器的交叉轴尺寸。
- en: With the `center` value, by contrast, the element box is just as large as it
    needs to be to contain the content along the cross-axis, and no bigger. The cross-start
    and -end edges of the flex items are placed the same distance away from the cross-start
    and -end edges of the container, thus centering the flex item’s box within the
    flex container along the cross-axis.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 而对于 `center` 值，元素框大小正好足以容纳沿交叉轴的内容，且不会更大。因此，flex 项目的交叉起始和结束边缘与容器的交叉起始和结束边缘距离相同，从而在交叉轴上使
    flex 项目的框居中于 flex 容器内。
- en: For the various `start` and `end` values, the cross-start or -end edges of the
    flex items are all snugged up against the respective edge of the flex container.
    There are so many ways to say `start` and `end`, mostly for historical reasons
    that are too lengthy and painful to get into here.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于各种 `start` 和 `end` 值，flex 项目的交叉起始或结束边缘都紧贴在 flex 容器的相应边缘上。有许多方法来表达 `start`
    和 `end`，主要是出于历史原因，这些原因在这里讨论起来太冗长而痛苦了。
- en: Notice that when the items are aligned to the start or end of the cross-axis,
    their inline sizes are (by default) exactly as big as their content needs to be,
    and no wider. It’s as if their `max-width` was set to `max-size`, so that extra
    content can wrap to multiple lines within the flex item, but if no wrapping is
    needed, the element’s inline size won’t fill out the entire flex container’s inline
    size. This is a default behavior of flex items, so if you want flex elements to
    fill out the entire inline size of the flex container, the way block boxes fill
    out their containing block, use the `stretch` value instead.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当项目对齐到交叉轴的开始或结束时，默认情况下它们的内联尺寸正好与其内容所需的一样大，不会更宽。就像它们的`max-width`设置为`max-size`一样，因此多余的内容可以在伸缩项目内部的多行中换行，但如果不需要换行，则元素的内联尺寸不会填充整个伸缩容器的内联尺寸。这是伸缩项目的默认行为，所以如果你希望伸缩元素填充整个伸缩容器的内联尺寸，就像块级盒子填充其包含块一样，请使用`stretch`值。
- en: 'With `baseline`, the flex items’ first baselines are aligned with one another
    when they can do so, which is to say, when the `flex-direction` is `row` or `row-reverse`.
    Because the font size of each flex item differs, the baseline of each line in
    every flex item differs. The flex item that has the greatest distance between
    its first baseline and its cross-start side will be flush against the cross-start
    edge of the line. The other flex items will be placed so that their first baselines
    line up with the first baseline of the flex item that’s flush against the cross-start
    edge (and thus each other’s first baselines). When `align-items: last baseline;`
    is set, the inverse occurs. The flex item with the greatest distance between its
    last baseline and the cross-end side will be flush against the cross-end edge
    of the line. The other flex items will be placed with their last baseline lined
    up with the last baseline of the flex item that’s flush against the cross-end
    edge, unless overridden by `align-self` (see [“The align-self property”](#the-align-self-property)).
    Since there isn’t a way to align baselines in a columnar flow, `baseline` is treated
    like `start` in these contexts, or `end` in the case of `last baseline`.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`baseline`时，伸缩项目的第一基线在可能时会彼此对齐，也就是说，当`flex-direction`为`row`或`row-reverse`时。由于每个伸缩项目的字体大小不同，因此每个伸缩项中每行的第一基线也不同。第一个基线与其交叉起始边之间的距离最大的伸缩项目将与该行的交叉起始边紧密对齐。其他伸缩项目将被放置在其第一基线与与交叉起始边紧密对齐的伸缩项目的第一基线对齐的位置（因此彼此的第一基线对齐）。当设置`align-items:
    last baseline;`时，情况相反。与其交叉结束边之间距离最大的伸缩项目将与该行的交叉结束边紧密对齐。其他伸缩项目将与其最后基线与与交叉结束边紧密对齐的伸缩项目的最后基线对齐，除非被`align-self`覆盖（见[“align-self属性”](#the-align-self-property)）。由于在列流中没有一种方式可以对齐基线，因此在这些情况下，`baseline`被视为`start`，或者在`last
    baseline`的情况下视为`end`。'
- en: Flex item margins and alignment
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 伸缩项的边距和对齐
- en: 'Now you have a general idea how each value behaves, but there’s a bit more
    to it than that. In the multiline `align-items` figures that follow, the following
    styles have been applied:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对每个值的行为有了一个大概的了解，但实际情况比这复杂一些。在接下来的多行`align-items`示例中，应用了以下样式：
- en: '[PRE15]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For each flex line, the cross-start and cross-end edges have been drawn in as
    a red dotted and blue dashed line, respectively. The C, H, D, and I boxes have
    added top or bottom margins. We’ve added a `gap` (which will be discussed a bit
    later in the chapter) between the flex items to make the figures more legible,
    which doesn’t affect the impact of the `align-items` property in this case. The
    J box has its font size increased, which also increases its line height. (This
    will come into play when we discuss the `baseline` value.)
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个伸缩行，交叉轴的起始和结束边缘都用红色虚线和蓝色虚线绘制出来。C、H、D和I框添加了顶部或底部边距。我们在伸缩项之间添加了一个间隔（稍后在本章中讨论），以使图表更易读，这不会影响此情况下`align-items`属性的影响。J框的字体大小增加，这也增加了其行高。（当我们讨论`baseline`值时将会涉及到这一点。）
- en: The effects of these margins on both the `stretch` and `center` alignments can
    be seen in [Figure 11-25](#margins-and-align).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边距对`stretch`和`center`对齐方式的影响在[图 11-25](#margins-and-align)中可见。
- en: '![css5 1125](assets/css5_1125.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1125](assets/css5_1125.png)'
- en: Figure 11-25\. The effect of margins on cross-axis alignment
  id: totrans-223
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-25\. 边距对交叉轴对齐的影响
- en: The `stretch` value, as its name implies, stretches all “stretchable” flex items
    to be as tall or wide as the tallest or widest flex item on the line. A stretchable
    flex item is one that does not have a non-`auto` value set for any of the sizing
    properties along the cross-axis. In [Figure 11-25](#margins-and-align), that would
    be the `block-size`, `min-block-size`, `max-block-size`, `height`, `min-height`,
    and `max-height` properties. If all are set to `auto`, the flex item is stretchable.
    If not, it is not.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`stretch` 值如其名，将所有“可拉伸”的伸缩项拉伸至与行中最高或最宽的伸缩项一样高或宽。可拉伸的伸缩项是指沿交叉轴没有设置任何非`auto`值的尺寸属性的伸缩项。在[图 11-25](#margins-and-align)中，这将是`block-size`、`min-block-size`、`max-block-size`、`height`、`min-height`
    和 `max-height`属性。如果全部设置为`auto`，则伸缩项是可拉伸的；否则，就不是。'
- en: Assuming a flex item is stretchable, its cross-start edge will be flush with
    the flex line’s cross-start edge, and its cross-end edge will be flush with the
    flex line’s cross-end edge. The flex item with the largest cross-size will remain
    its default size, and the other flex items will grow to the size of that largest
    flex item.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个伸缩项是可拉伸的，其交叉起始边缘将与伸缩线的交叉起始边缘对齐，其交叉结束边缘将与伸缩线的交叉结束边缘对齐。具有最大交叉尺寸的伸缩项将保持其默认尺寸，而其他伸缩项将增长到该最大伸缩项的尺寸。
- en: What [Figure 11-25](#margins-and-align) shows us is that it’s the outer edge
    of the flex items’ *margins* that will be flush with cross-start and cross-end,
    not their border edges. This is demonstrated by items C, D, H, and I, which appear
    smaller than the other flex items on their flex lines. They’re not, though. It’s
    just that their margins, which are always fully transparent, take up some of the
    stretching space.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-25](#margins-and-align)展示的是伸缩项 *margins* 的外边缘与交叉起始和交叉结束对齐，而不是其边框边缘。这由项
    C、D、H 和 I 表示，它们看起来比其它伸缩项小。然而实际上并非如此，只是它们的边距始终是完全透明的，占据了一部分伸展空间。'
- en: Note
  id: totrans-227
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: If a flex container’s cross-size is constrained, the contents may overflow the
    flex container’s cross-start and/or cross-end edge. The direction of the overflow
    is not determined by the `align-items` property, but rather by the `align-content`
    property, discussed in [“Aligning Flex Lines”](#the-align-content-property). The
    `align-items` property aligns the flex items within the flex line and does not
    directly impact the overflow direction of the flex items within the container.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 如果伸缩容器的交叉尺寸受到限制，内容可能会溢出伸缩容器的交叉起始和/或交叉结束边缘。溢出的方向不由 `align-items` 属性决定，而是由讨论在[“对齐伸缩线”](#the-align-content-property)的
    `align-content` 属性决定。`align-items` 属性用于在伸缩线内对齐伸缩项，并不直接影响容器内伸缩项的溢出方向。
- en: Baseline alignment
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基线对齐
- en: The `baseline` values are a little more complicated. CSS has two possible baseline
    alignments, represented by `first baseline` and `last baseline`. You can also
    use the value `baseline`, which is equivalent to `first baseline`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`baseline` 值更加复杂。CSS 提供了两种基线对齐方式，分别用 `first baseline` 和 `last baseline` 表示。还可以使用值
    `baseline`，其等效于 `first baseline`。'
- en: With `baseline` (and `first baseline`), the flex items in each line are all
    aligned at the lowest first baseline. For each flex line, the flex item with the
    biggest distance between its baseline and its cross-start margin edge has that
    margin edge placed flush against the cross-start edge of the line, and all other
    flex items’ baselines are lined up with the baseline of that flex item.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `baseline`（和 `first baseline`），每行中的伸缩项都对齐到最低的第一基线。对于每条伸缩线，距离其基线和交叉起始边缘之间距离最大的伸缩项，将该边缘对齐到该行的交叉起始边缘，并且所有其他伸缩项的基线都与该伸缩项的基线对齐。
- en: To understand this, take a look at the first set of flex items in [Figure 11-26](#align-items_baseline),
    the ones labeled `baseline` (and `first baseline`). For each flex line, the cross-start
    and -end edges are marked with solid red and blue lines, respectively. The baseline
    to which the items in each line are aligned is marked with a dotted line, and
    the element whose baseline is taken as the prime baseline has a lighter background
    and red text.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解这一点，请看[图 11-26](#align-items_baseline)中第一组伸缩项，标记为 `baseline`（和 `first baseline`）。对于每条伸缩线，交叉起始和结束边缘分别用实线红色和蓝色标记。每行中伸缩项对齐的基线用点线标记，以及被视为主要基线的元素具有较浅的背景和红色文本。
- en: '![css5 1126](assets/css5_1126.png)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1126](assets/css5_1126.png)'
- en: Figure 11-26\. Baseline alignments [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/baseline-alignments.html)
  id: totrans-234
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-26\. 基线对齐 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/baseline-alignments.html)
- en: In the first line (A through E), it is the C box whose first baseline is used.
    This is because the C box has a top margin, so its first baseline is the farthest
    from the cross-start edge of the flex line. All the other boxes (A, B, D, and
    E) have their first baselines aligned with the first baseline of C.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行（A到E），C框的第一基线被使用了。这是因为C框有顶部边距，所以它的第一基线是距离伸缩行交叉起始边缘最远的。所有其他框（A、B、D和E）的第一基线都与C的第一基线对齐。
- en: In the second line (F through J), H’s first baseline is used—again, because
    of its top margin—and so the F, G, I, and J boxes have their first baselines aligned
    with H’s. Here, we can also see how the J box has its first baseline aligned with
    all the others, despite its much bigger font size.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行（F到J），H的第一基线被使用了 —— 再次是因为它的顶部边距 —— 因此F、G、I和J框的第一基线与H的对齐。在这里，我们也可以看到J框如何使所有其他框的第一基线对齐，尽管它的字体大小要大得多。
- en: Similar things happen for the flex items labeled with `last baseline`, only
    here, the dominating factors are bottom margins. The D box in the first line has
    a bottom margin, as does the I box in the second line. In both cases, their last
    baselines are the farthest away from the cross-end edge of the line, and so all
    the other flex items in their rows have their last baselines aligned with the
    last baselines of D and I. The dotted lines show the placements of the last baselines
    in each flex line.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 类似的情况发生在标记为`last baseline`的伸缩项上，只是这里，主导因素是底部边距。第一行的D框和第二行的I框都有底部边距。在这两种情况下，它们的最后基线距离行的交叉末端边缘最远，因此它们所在行的所有其他伸缩项的最后基线与D和I的最后基线对齐。虚线显示了每个伸缩行中最后基线的位置。
- en: In many cases, `first baseline` will look like `start` (and its equivalents,
    such as `flex-start`), and `last baseline` will look like `end`. For example,
    had C lacked a top margin in [Figure 11-26](#align-items_baseline), all the items
    in that first line would have been visibly flush against the top of the flex line,
    instead of pushed away from it. Anytime flex items have different margins, borders,
    padding, font sizes, or line heights on their cross-start side, the `start` and
    `first baseline` will differ. Similarly, any cross-end margins, borders, etc.
    will create a difference between the results of `last baseline` and `end`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，`first baseline`看起来会像`start`（及其等效项，如`flex-start`），而`last baseline`看起来会像`end`。例如，如果[图 11-26](https://meyerweb.github.io/csstdg5figs/11-flexbox/baseline-alignments.html)中的C框没有顶部边距，那么第一行中的所有项目将明显紧贴伸缩行的顶部，而不是推开它。每当伸缩项在其交叉起始侧具有不同的边距、边框、填充、字体大小或行高时，`start`和`first
    baseline`之间会有差异。同样地，任何交叉末端的边距、边框等都会在`last baseline`和`end`的结果之间创建差异。
- en: 'Any of the baseline values can become `start` when the baselines of the flex
    items are parallel to the cross-axis. For example, suppose we take the flex containers
    in [Figure 11-26](#align-items_baseline) and change them to `flex-direction: column`.
    Now the cross-axis, like the baselines of the English text within, is horizontal.
    Since there’s no way to create an offset from the cross-start edge of the columns
    that will align the text baselines, `baseline` is treated exactly as if it were
    `start` instead; or `end`, in the case of last baseline.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '当伸缩项的基线与交叉轴平行时，任何基线值都可以变为`start`。例如，假设我们将[图 11-26](https://meyerweb.github.io/csstdg5figs/11-flexbox/baseline-alignments.html)中的伸缩容器改为`flex-direction:
    column`。现在，交叉轴就像英文文本内部的基线一样是水平的。由于没有办法从列的交叉起始边缘创建偏移量来对齐文本基线，`baseline`就像`start`一样被处理；或者在最后基线的情况下，被视为`end`。'
- en: Safe and unsafe alignment
  id: totrans-240
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全对齐和不安全对齐
- en: 'In all the previous examples, we let the flex containers be whatever size they
    needed to be to contain the flex lines; that is, we left them at `block-size:
    auto` (or `height: auto`, in old-school CSS terminology). But what happens if
    the block size of a flex container is constrained in some way, perhaps by the
    size of a grid track or an explicit block size value being given? In these situations,
    the `safe` and `unsafe` keywords come into play.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的所有示例中，我们让伸缩容器成为它们需要包含伸缩行的大小；也就是说，我们将它们留在`block-size: auto`（或者在老式CSS术语中是`height:
    auto`）。但是，如果伸缩容器的块大小以某种方式受到限制，例如通过网格轨道的大小或给定的显式块大小值，那么`safe`和`unsafe`关键字就会发挥作用。'
- en: 'If `safe` alignment is specified, then anytime a flex item would overflow the
    flex container, the flex item is treated as though its `align-self` were set to
    `start`. That would look something like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了 `safe` 对齐，那么每当 flex 项溢出 flex 容器时，该 flex 项被视为其 `align-self` 被设置为 `start`。看起来可能是这样：
- en: '[PRE16]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: On the other hand, if `unsafe` is used, the alignment of flex items is honored
    no matter what that means in terms of overflowing the flex container.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果使用 `unsafe`，则无论会导致 flex 容器溢出什么意思，都会尊重 flex 项的对齐方式。
- en: If you’re wondering which is the default, the answer is neither. Instead, when
    neither safe nor unsafe alignment has been declared, browsers should default to
    `unsafe` behavior *unless* this would cause flex items to overflow the scrollable
    area of their nearest ancestor’s scroll container, in which case they should align
    to the cross-axis edge farthest away from the edge they would otherwise overflow.
    [Figure 11-27](#safe_unsafe_alignment) shows some examples.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道哪个是默认值，答案是都不是。相反，当未声明安全或不安全对齐时，浏览器应默认为 `unsafe` 行为，*除非*这会导致 flex 项溢出其最近祖先滚动容器的可滚动区域，在这种情况下，它们应对齐到距离它们溢出边缘最远的交叉轴边缘。[图 11-27](#safe_unsafe_alignment)
    展示了一些示例。
- en: Warning
  id: totrans-246
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, only Firefox browsers fully support the `safe` and `unsafe`
    keywords, and they have to be written first in the value (as shown in this section)
    even though the formal syntax for the property does not require this placement.
    All other evergreen browsers recognize these keywords as valid, but they have
    no impact on the layout.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2022 年底，只有 Firefox 浏览器完全支持 `safe` 和 `unsafe` 关键字，它们必须首先在值中书写（如本节所示），即使属性的正式语法不要求此位置。所有其他常青浏览器都将这些关键字识别为有效，但它们对布局没有影响。
- en: '![](assets/css5_1127.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1127.png)'
- en: Figure 11-27\. `Safe` versus `unsafe` alignments
  id: totrans-249
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-27\. `安全（safe）`与`不安全（unsafe）`对齐方式
- en: The align-self property
  id: totrans-250
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: align-self 属性
- en: If you want to change the alignment of one or more flex items, but not all,
    you can include the `align-self` property on the flex items you would like to
    align differently. This property takes the same values as `align-items` and is
    used to override the `align-items` property value on a per-flex-item basis.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想改变一个或多个 flex 项的对齐方式，但不是全部，你可以在希望以不同方式对齐的 flex 项上使用 `align-self` 属性。该属性接受与
    `align-items` 相同的值，并用于按每个 flex 项覆盖 `align-items` 属性的值。
- en: You can override the cross-axis alignment of any individual flex item with the
    `align-self` property, as long as it’s represented by an element or pseudo-element.
    You cannot override the alignment for anonymous flex items (non-empty text node
    children of flex containers). Their `align-self` always matches the value of `align-items`
    of their parent flex container.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `align-self` 属性覆盖任何单个 flex 项的交叉轴对齐方式，只要它由元素或伪元素表示。你不能覆盖匿名 flex 项（flex
    容器的非空文本节点子节点）的对齐方式。它们的 `align-self` 始终与其父 flex 容器的 `align-items` 值匹配。
- en: 'The default value of `align-items` is `stretch`, but let’s make that explicit
    in the following code, which will let us set different `align-self` values for
    the second flex item, as illustrated in [Figure 11-28](#align_self_fig):'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`align-items` 的默认值是 `stretch`，但让我们在以下代码中明确设置这一点，这将允许我们为第二个 flex 项设置不同的 `align-self`
    值，如 [图 11-28](#align_self_fig) 所示：'
- en: '[PRE17]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '![css5 1128](assets/css5_1128.png)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1128](assets/css5_1128.png)'
- en: Figure 11-28\. Changing individual flex-item alignments [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/gaps-between-items.html)
  id: totrans-256
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-28\. 改变单个 flex 项的对齐方式 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/gaps-between-items.html)
- en: All these flex items have `align-self`’s default value of `auto`, meaning they
    inherit the alignment (in this case, `stretch`) from the container’s `align-items`
    property. The exception in each example is the second flex item, which has been
    given the `align-self` value shown underneath.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些 flex 项都具有 `align-self` 的默认值 `auto`，意味着它们继承自容器的 `align-items` 属性的对齐方式（在本例中为
    `stretch`）。每个示例中的例外是第二个 flex 项，它被赋予了下面显示的 `align-self` 值。
- en: As we said, all the values of `align-items` can be used for `align-self`, including
    the values for first and last baseline alignment, `safe` and `unsafe` alignment,
    and so on.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，`align-items` 的所有值都可以用于 `align-self`，包括第一个和最后一个基线对齐的值，`safe` 和 `unsafe`
    对齐等。
- en: Aligning Flex Lines
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对齐 Flex 行
- en: 'In nearly all the previous examples, the flex container’s cross-size was always
    as tall as it needed to be: no `block-size` or `height` was declared on the container,
    so it defaulted to `height: auto`. Because of this, the flex container grew to
    fit the content.'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '在几乎所有之前的示例中，弹性容器的交叉尺寸总是尽可能高：容器上没有声明`block-size`或`height`，因此默认为`height: auto`。因此，弹性容器会随内容增长。'
- en: Had the cross-size of the container been set to a specific size, there may have
    been extra space at the cross-end, or not enough space to fit the content. In
    such cases, CSS allows us to control the overall placement of flex lines with
    the `align-content` property.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器的交叉尺寸被设置为特定尺寸，可能会在交叉端有额外的空间，或者没有足够的空间来容纳内容。在这种情况下，CSS允许我们通过`align-content`属性来控制弹性行的整体位置。
- en: The `align-content` property dictates how any extra cross-direction space in
    a flex container is distributed between and around flex lines. Although the values
    and concepts are largely the same, `align-content` is different from the previously
    discussed `align-items` property, which dictates flex item positioning within
    each flex line.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`align-content`属性决定了弹性容器中任何额外的交叉方向空间如何在弹性行之间和周围分布。尽管值和概念大致相同，`align-content`与之前讨论的`align-items`属性不同，后者决定了每个弹性行内的弹性项的位置。'
- en: Think of `align-content` as similar to the way `justify-content` aligns individual
    items along the main-axis of the flex container, but it does so for flex lines
    with regard to the cross-axis of the container. This property applies to multiline
    flex containers, having no effect on nonwrapping and otherwise single-line flex
    containers.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 将`align-content`视为类似于`justify-content`在弹性容器的主轴上对单个项进行对齐的方式，但它是针对弹性行与容器的交叉轴进行的。此属性适用于多行弹性容器，对不换行和其他单行弹性容器没有影响。
- en: 'Consider the following CSS as a base and assume the flex items have no margins:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下CSS视为基础，假设弹性项没有边距：
- en: '[PRE18]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[Figure 11-29](#distribution_of_extra_space) demonstrates the possible values
    of the `align-content` property, as used in conjunction with that CSS. We’ve concentrated
    on the primary alignment values, and left out examples of things such as safe
    and unsafe alignment as well as the first and last baseline alignments.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-29](#distribution_of_extra_space)展示了与CSS一起使用时`align-content`属性的可能值。我们专注于主要的对齐值，并省略了诸如安全对齐和不安全对齐以及第一个和最后一个基线对齐的示例。'
- en: With a height of 14 ems, the flex container is taller than the default combined
    heights of the three flex lines. Given the larger text of some flex items and
    the various bits of padding and borders, each flex container in [Figure 11-29](#distribution_of_extra_space)
    has approximately 3 ems of leftover space.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 使用高度为14 ems时，弹性容器比三个弹性行的默认组合高度更高。考虑到某些弹性项的较大文本和各种填充和边框的位，[图 11-29](#distribution_of_extra_space)中每个弹性容器大约有3
    ems的剩余空间。
- en: '![The distribution of extra space for the different values of align-content](assets/css5_1129.png)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![不同`align-content`值的额外空间分布](assets/css5_1129.png)'
- en: Figure 11-29\. Distribution of extra space for primary values of `align-content`
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/align-content.html)
  id: totrans-269
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-29\. 主要`align-content`值的额外空间分布 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/align-content.html)
- en: With the values `normal`, `stretch`, `center`, `start`, `flex-start`, `end`,
    and `flex-end`, the free space is distributed outside the flex lines, as illustrated
    in [Figure 11-29](#distribution_of_extra_space). These act in the same ways as
    they do for `align-items`. With the value `stretch`, the extra space is evenly
    distributed to all the flex lines, increasing their cross-size until their edges
    touch. For the others, the flex lines are kept together, with the leftover space
    placed to one side or another.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`normal`、`stretch`、`center`、`start`、`flex-start`、`end`和`flex-end`这些值时，多余的空间分布在弹性行的外部，如[图 11-29](#distribution_of_extra_space)所示。这些值的行为与`align-items`相同。对于值`stretch`，额外的空间均匀分布到所有弹性行，增加它们的交叉尺寸直到它们的边缘接触。对于其他值，弹性行保持在一起，多余的空间放置在一侧或另一侧。
- en: For the remaining values, the flex lines are pushed apart and the leftover space
    distributed in various ways. Let’s assume the approximately 3 ems of leftover
    space is equal to 120 pixels. (It’s big text, OK?)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于剩余的值，弹性行被分开，并以各种方式分布剩余的空间。假设大约3 ems的剩余空间相当于120像素。（这是大文本，好吗？）
- en: 'Given `space-between`, about 60 pixels of space is between each adjacent pair
    of flex lines, each half of the leftover 120 pixels. With `space-around`, the
    space is evenly distributed around each line: the 120 pixels are split into three
    pieces, since there are three flex lines. This puts 20 pixels of noncollapsed
    space (half of 40 pixels) on the cross-start and cross-end sides of each flex
    line, so we have 20 pixels of extra space at the cross-start and cross-end sides
    of the flex container, and 40 pixels of space between adjacent flex lines.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`space-between`来说，每对相邻的flex行之间大约有60像素的空间，即剩余的120像素的一半。对于`space-around`，空间均匀分布在每行周围：120像素被分成三份，因为有三个flex行。这会在每个flex行的交叉开始和交叉结束两侧各增加20像素的非折叠空间（40像素的一半），所以在相邻flex行之间有40像素的空间。
- en: 'For `space-evenly`, there are four spaces to insert: one before each flex line,
    and an extra space after the last flex line. With three lines, that means four
    spaces, with 30 pixels for each space. That places 30 pixels of space at the cross-start
    and cross-end sides of the flex container, and 30 pixels between adjacent flex
    lines.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`space-evenly`，需要插入四个空格：每个flex行之前各一个，最后一个flex行之后还有一个额外的空格。对于三行来说，这意味着四个空格，每个空格30像素。这将在flex容器的交叉开始和交叉结束两侧各放置30像素的空间，并在相邻flex行之间放置30像素的空间。
- en: 'Continuing this example for the stretch value, you’ll note that the `stretch`
    value is different: with `stretch`, the lines stretch with the extra space evenly
    distributed among the flex lines rather than between them. In this case, 40 pixels
    are added to each of the flex lines, causing all three lines to grow in height
    by an equal amount—that is, the extra space is divided equally, not proportionally,
    with the exact same amount added to each.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 继续对`stretch`值的示例，你会注意到`stretch`值不同：使用`stretch`，额外的空间均匀分布在flex行中，而不是在它们之间。在这种情况下，每个flex行增加了40像素，导致所有三行的高度均等增加—即额外的空间均等分配，而不是按比例分配，每行增加的量完全相同。
- en: If there isn’t enough room for all the lines, they will overflow at cross-start,
    cross-end, or both, depending on the value of the `align-content` property. This
    is shown in [Figure 11-30](#align_content_overflowing), where the dotted box with
    a light-gray background represents a short flex container. (A little bit of inline
    padding was added to each flex container to make it more obvious where it starts
    and ends.)
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有足够的空间容纳所有行，它们将在交叉开始、交叉结束或两者之间溢出，这取决于`align-content`属性的值。这在[图 11-30](#align_content_overflowing)中有所展示，其中带有浅灰色背景的虚线框表示一个短的flex容器。（为了更清楚地显示其开始和结束位置，每个flex容器都添加了少量内联填充。）
- en: '![Appearance of align-content property when lines are overflowing the container](assets/css5_1130.png)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![当行溢出容器时，align-content属性的外观](assets/css5_1130.png)'
- en: Figure 11-30\. Flex-line overflow directions for each value of `align-content`
  id: totrans-277
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-30\. 每个`align-content`值对应的flex行溢出方向
- en: The only difference in the CSS between this and [Figure 11-29](#distribution_of_extra_space)
    is the height of the flex container. Here, the flex containers have been reduced
    to a height of 7 ems, so as to create flex containers not tall enough to encompass
    all their flex lines (which, as you may recall, total around 10 ems in height).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 与[图 11-29](#distribution_of_extra_space)之间的CSS唯一差异是flex容器的高度。在这里，flex容器的高度已经减少到7
    ems，以便创建不足以容纳其所有flex行的flex容器（你可能还记得，总共约为10 ems的高度）。
- en: When the flex lines overflow the flex container, the `align-content` values
    `normal`, `stretch`, `start`, `flex-start`, `baseline`, `last baseline`, and `space-between`
    cause them to overflow on the cross-end side, whereas the values `center`, `space-around`,
    and `space-evenly` evenly overflow both the cross-end and cross-start sides. Only
    `align-content:` `end` and `flex-end` cause flex lines to overflow on just the
    cross-start side.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '当flex行溢出flex容器时，`align-content`值`normal`、`stretch`、`start`、`flex-start`、`baseline`、`last
    baseline`和`space-between`会使它们在交叉结束侧溢出，而值`center`、`space-around`和`space-evenly`则会均匀地在交叉开始和交叉结束两侧溢出。只有`align-content:
    end`和`flex-end`会使flex行仅在交叉开始侧溢出。'
- en: 'Keep in mind that these values are not top- or bottom-centric. If the cross-axis
    goes upward, `align-content: flex-start` will start aligning flex lines from the
    bottom and work upward from there, potentially overflowing the top (cross-end)
    edge. For that matter, when the flow direction is columnar, the cross-axis will
    be horizontal, in which case the cross-start and -end edges will be the right
    or left edges of the flex container.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '请记住，这些值不是顶部或底部为中心的。如果交叉轴向上移动，`align-content: flex-start`将从底部开始对齐 flex 行，然后向上工作，可能会溢出顶部（交叉末端）边缘。就此而言，当流向是列时，交叉轴将是水平的，此时交叉起始和结束边缘将是
    flex 容器的右边或左边边缘。'
- en: Using the place-content Property
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`place-content`属性
- en: CSS offers a shorthand property that collapses `align-content`, which we just
    covered, and `justify-content`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 提供了一个缩写属性，将`align-content`（我们刚刚讨论过的）和`justify-content`合并为一个属性。
- en: 'You can supply either one or two values. If you supply one, `place-content`
    acts as if you had set both `align-content` and `justify-content` to the same
    value. In other words, the following two rules are equivalent:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供一个或两个值。如果提供一个值，则`place-content`将像您设置了`align-content`和`justify-content`为相同值一样。换句话说，以下两个规则是等效的：
- en: '[PRE19]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The exception to this behavior occurs if the value is baseline-related, such
    as `first baseline`. In that case, the value for `justify-content` is set to `start`,
    making the following two rules equivalent:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 该行为的例外情况是值与基线相关，如`first baseline`。在这种情况下，`justify-content`的值被设置为`start`，使得以下两个规则等效：
- en: '[PRE20]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If two values are given, the second is the value of `justify-content`. Thus,
    the following two rules are equivalent:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果给出两个值，第二个值是`justify-content`的值。因此，以下两个规则是等效的：
- en: '[PRE21]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That’s pretty much all there is to `place-content`. If you’d rather align and
    justify content by using a single shorthand property, `place-content` does that.
    Otherwise, use the individual properties separately.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是`place-content`的全部内容。如果您宁愿通过单个缩写属性来对齐和调整内容，`place-content`可以做到。否则，请分别使用单独的属性。
- en: Two more `place-` shorthand properties are covered in [Chapter 12](ch12.html#grid-layout).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 第 12 章中还介绍了另外两个`place-`的缩写属性。
- en: Opening Gaps Between Flex Items
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 flex 项之间打开间隙
- en: Flex items are, by default, rendered with no space held open between them. Space
    can appear between items thanks to values of `justify-content` or by adding margins
    to flex items, but these approaches are not always ideal. For example, margins
    can lead to flex line wrapping when it isn’t actually needed, and even using `justify-content`
    values like `space-between` can result in having no space separating the items.
    It would be easier if there was a way to define what are essentially minimum gap
    sizes, and thanks to the gap properties, there is.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，flex 项呈现为它们之间没有空间。通过`justify-content`的值或向 flex 项添加边距，可以在项之间显示空间，但这些方法并不总是理想的。例如，边距可能会导致
    flex 行换行，当实际上并不需要时，即使使用`space-between`等`justify-content`值也可能导致没有分隔项的空间。如果有一种方法可以定义基本上是最小间隙大小，那将更容易，多亏了间隙属性。
- en: Each of these properties inserts space of the declared size between adjacent
    flex items. This space is often referred to as a *gutter*. For historical reasons,
    the default value, `normal`, equates to 0 pixels (no space) in flexbox and grid
    containers, and `1` em in multicolumn layout. Otherwise, you can supply a single
    length or percentage value.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性中的每一个都在相邻的 flex 项之间插入声明大小的空间。这个空间通常被称为*gutter*。由于历史原因，默认值`normal`在 flexbox
    和网格容器中等于 0 像素（无空间），在多列布局中等于`1` em。否则，您可以提供单个长度或百分比值。
- en: 'Suppose we have a set of flex items that will wrap to multiple flex lines,
    and we want to open a 15-pixel gap between the flex lines. Here’s what that CSS
    would look like, illustrated in [Figure 11-31](#row-gaps):'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一组 flex 项，这些项将包裹到多个 flex 行中，并且我们希望在 flex 行之间打开一个 15 像素的间隙。以下是该 CSS 的示例，详见[图
    11-31](#row-gaps)：
- en: '[PRE22]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![](assets/css5_1131.png)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1131.png)'
- en: Figure 11-31\. Gaps between rows of flex items
  id: totrans-297
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-31\. flex 项行之间的间隙
- en: No margins are set on the flex items, to be clear. Exactly 15 pixels of space
    is between each flex line (row), thanks to the value of `row-gap`. In essence,
    `row-gap` acts as if it were called `block-axis-gap`, so if the writing mode were
    changed to something like `vertical-rl`, thus making the block axis horizontal,
    the rows would flow top to bottom, and the gaps between them would be to their
    right and left sides (which are their block-start and block-end sides).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 并未对伸缩项设置任何边距。每个伸缩行（行）之间确实有15像素的空间，这要归功于`row-gap`的值。本质上，`row-gap`的作用就像被称为`block-axis-gap`，因此如果书写方式改为像`vertical-rl`这样，使块轴为水平方向，行将从顶部向底部流动，并且它们之间的间隙将位于它们的右侧和左侧（它们的块起始和块结束侧）。
- en: 'Note that there are gaps only between rows: there are no gaps placed between
    the flex items and the block-start and -end edges of the flex container. If you
    want to open gaps of the same size along those container edges, you would write
    something like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，只有在行之间存在间隙：不会在伸缩容器的伸缩项和块起始和结束边缘之间插入间隙。如果想要在这些容器边缘打开相同大小的间隙，可以写成这样：
- en: '[PRE23]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In a like manner, we can open spaces between the flex items along the inline
    axis by using `column-gap`. We can modify the earlier example to push items apart
    as follows, with the result shown in [Figure 11-32](#column-gaps):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以使用`column-gap`在行内轴上打开伸缩项之间的空间。我们可以修改之前的例子，使项目分开，结果如图[11-32](#column-gaps)所示：
- en: '[PRE24]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '![](assets/css5_1132.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1132.png)'
- en: Figure 11-32\. Gaps between adjacent flex items along the inline axis
  id: totrans-304
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-32。沿行内轴之间相邻伸缩项的间隙
- en: Here, leftover space remains at the inline-end side of the flex lines, with
    each line having its own amount of space. That’s because the flex items weren’t
    given a `justify-content` value, so they defaulted to `start`. This means the
    gaps between the flex items are all exactly 15 pixels wide.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在此，行内端边的伸缩行上仍然有剩余空间，每行具有其自己的空间量。这是因为伸缩项未被赋予`justify-content`值，因此它们默认为`start`。这意味着伸缩项之间的间隙都恰好是15像素宽。
- en: If we were to change the value of `justify-content` to `space-between`, then
    in any flex line with leftover space, the gaps between flex items will be increased
    by an equal amount, meaning they will be separated by more than 15 pixels. If
    there’s a line where the inline sizes of all the flex items and all the gaps exactly
    equals the inline length of the flex line, 15 pixels of space will be between
    each flex item.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将`justify-content`的值更改为`space-between`，那么在任何具有剩余空间的伸缩行中，伸缩项之间的间隙将增加相等的量，这意味着它们将被超过15像素分开。如果有一行，其中所有伸缩项和所有间隙的行内尺寸恰好等于伸缩行的行内长度，则每个伸缩项之间将有15像素的空间。
- en: This is why `row-gap` and `column-gap` are really more like minimum separation
    distances between flex items or flex lines. The gaps don’t count as “leftover
    space,” any more than the flex items do.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么`row-gap`和`column-gap`更像是伸缩项或伸缩行之间的最小分隔距离。这些间隙不算是“剩余空间”，就像伸缩项一样。
- en: 'Gaps are inserted between the outer margin edges of adjacent flex items, so
    if you add margins to your flex items, the actual visible space between two flex
    items will be the width of the gap plus the widths of the margins. Consider the
    following, which is illustrated in [Figure 11-33](#column-gaps-plus-margins):'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在相邻伸缩项的外边距边缘之间插入间隙，因此如果向伸缩项添加边距，两个伸缩项之间的实际可见空间将是间隙的宽度加上边距的宽度。考虑以下情况，该情况在图[11-33](#column-gaps-plus-margins)中有图示：
- en: '[PRE25]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '![](assets/css5_1133.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1133.png)'
- en: Figure 11-33\. Gaps and margins combine to open more space
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-33。间隙和边距结合以打开更多空间
- en: 'Now the open spaces between flex items are all 35 pixels wide: 15 pixels from
    the `gap` property, plus 20 pixels (10 + 10) from the inline-side margins set
    on the flex items.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，伸缩项之间的开放空间都是35像素宽：15像素来自`gap`属性，加上在伸缩项上设置的行内侧边距20像素（10 + 10）。
- en: 'Thus far we’ve used length values, but what about percentages? Any percentage
    value used for a gap is taken to be a percentage of the container’s size along
    the relevant axis. Thus, given `column-gap: 10%`, the gaps will be 10% the inline
    size of the flex container. If the container is 640 pixels wide along the inline
    axis, the column gaps will be 64 pixels each.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '到目前为止，我们使用了长度值，但百分比呢？任何百分比值用作间隙将被视为与相关轴上容器尺寸的百分比。因此，给定`column-gap: 10%`，间隙将是伸缩容器沿行内轴的尺寸的10%。如果容器沿行内轴宽度为640像素，那么列间隙将每个为64像素。'
- en: Working with rows can be a little more complicated. If you define an explicit
    block size, percentages are just a percentage of that block size. A `block-size`
    (which could also be set with `height` or `width`) of `25em` and a `row-gap` of
    `10%` means row gaps will be 2.5 ems wide. This same sort of thing can also happen
    if the block size happens to be larger than the sum total of the rows’ block sizes.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 处理行可能会有点复杂。如果您定义了一个显式的块大小，则百分比仅是该块大小的百分比。一个 `block-size`（也可以用 `height` 或 `width`
    设置）为 `25em`，而 `row-gap` 为 `10%` 意味着行间隙将为 2.5 em 宽。如果块大小恰好大于行的块大小总和，也会发生类似的情况。
- en: 'But when the block size is solely determined by the block sizes of the rows
    added together, any percentage value could lead to a *cyclic calculation*: each
    calculation changes the value being calculated, ad infinitum. Suppose a flex container
    has three flex lines, each exactly 30 pixels tall. The flex container is set so
    its height is `auto`, so it will “shrink-wrap” the flex lines, making it 90 pixels
    tall (we’re assuming no padding here, but the principles are the same regardless).
    A `row-gap` of `10%` would mean 9-pixel row gaps, and inserting the 2 row gaps
    would add 18 pixels of height. That would increase the container’s height to 108
    pixels, which would mean the 10%-wide gaps are now 10.8 pixels, so the container
    height increases again, which increases the row gaps, which increases container
    height, which…'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当块大小仅由添加在一起的行的块大小决定时，任何百分比值都可能导致循环计算：每次计算都会改变正在计算的值，无限循环。假设一个弹性容器有三个弹性行，每行高度恰好为
    30 像素。弹性容器设置其高度为 `auto`，因此将“包裹”弹性行，使其高度为 90 像素（这里我们假设没有填充，但原则上相同）。`row-gap` 为
    `10%` 将意味着 9 像素的行间隙，插入 2 个行间隙将增加 18 像素的高度。这将增加容器的高度至 108 像素，使得 10% 宽的间隙现在为 10.8
    像素，因此容器高度再次增加，间隙增加，容器高度增加，以此类推…
- en: To avoid this sort of infinite-loop scenario, the gaps are set to be zero-width
    whenever a cyclic calculation would happen, and everyone moves on with their lives.
    In practice, this means that percentage values for row gaps are useful only in
    a narrow range of cases, whereas they can be more broadly useful for column gaps.
    [Figure 11-34](#percentage-based-row-gaps) shows examples of percentage row gaps.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种无限循环的情况，当发生循环计算时，间隙被设置为零宽度，所有人都继续他们的生活。实际上，这意味着行间隙的百分比值仅在一小部分情况下有用，而在列间隙方面则可以更广泛地使用。[图 11-34](#percentage-based-row-gaps)
    显示了百分比行间隙的示例。
- en: '![](assets/css5_1134.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1134.png)'
- en: Figure 11-34\. Percentage-based row gaps with and without explicit container
    heights
  id: totrans-318
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-34. 具有百分比行间隙的示例，带有和不带有显式容器高度
- en: You can set up both column and gap rows on a flex container by supplying the
    two properties individually, or you can use the shorthand property `gap`.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过分别提供两个属性来设置弹性容器上的列和间隙行，或者您可以使用简写属性 `gap`。
- en: 'You need to supply only one value to `gap`, in which case it will be used for
    both the row and column gaps. If you supply two values, the first will always
    be used for row gaps, and the second for column gaps. Thus you get the results
    shown in [Figure 11-35](#using-the-gap-shorthand) from the following CSS:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需提供一个值给 `gap`，在这种情况下，它将用于行间隙和列间隙。如果提供两个值，则第一个值始终用于行间隙，第二个值用于列间隙。因此，通过以下 CSS
    您将获得 [图 11-35](#using-the-gap-shorthand) 中显示的结果：
- en: '[PRE26]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![](assets/css5_1135.png)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1135.png)'
- en: Figure 11-35\. Row and column gaps set using the `gap` shorthand property
  id: totrans-323
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-35. 使用 `gap` 简写属性设置的行和列间隙
- en: Note
  id: totrans-324
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The original `gap` property was defined in CSS Multiple Columns, with additional
    hyphenated gap properties defined in CSS Grid as `grid-row-gap`, `grid-column-gap`,
    and `grid-gap`, before being made more generic and available in grid, flexbox,
    and multicolumn contexts. Browsers are required to treat the older properties
    as aliases for the newer, more generic properties; e.g., `grid-gap` is an alias
    for `gap`. So if you find the older grid gap properties in legacy CSS, you can
    change them to the newer names, but if not, they’ll still work as if you had.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 最初的 `gap` 属性在 CSS 多列中定义，而在 CSS Grid 中定义了额外带连字符的间隙属性 `grid-row-gap`，`grid-column-gap`
    和 `grid-gap`，然后在网格、弹性盒和多列上下文中变得更加通用和可用。浏览器需要将旧属性视为新更通用属性的别名；例如，`grid-gap` 是 `gap`
    的别名。因此，如果您在遗留 CSS 中找到旧的网格间隙属性，可以将其更改为新名称，否则它们将像您有了一样正常工作。
- en: Flex Items
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹性项目
- en: In the previous sections, you saw how to globally lay out all the flex items
    within a flex container by styling that container. The flexible box layout specification
    provides several additional properties applicable directly to flex items. With
    these flex-item-specific properties, we can more precisely control the layout
    of individual flex containers’ children.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，您看到了如何通过为容器设置样式来全局布局弹性容器中的所有弹性项目。弹性盒布局规范提供了几个适用于弹性项目的附加属性。借助这些弹性项目特定的属性，我们可以更精确地控制单个弹性容器的子元素布局。
- en: What Are Flex Items?
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性项目是什么？
- en: 'As you’ve seen throughout the chapter, we create flex containers by adding
    `display: flex` or `display: inline-flex` to an element that has child nodes.
    The children of those flex containers are called *flex items*—whether they’re
    child elements, non-empty text nodes between child elements, or generated content.
    In [Figure 11-36](#display_flex_containers_children), each letter is enclosed
    in its own element, including the space between words, so that each letter and
    space becomes a flex item.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '正如本章中所见，我们通过将`display: flex`或`display: inline-flex`添加到具有子节点的元素来创建弹性容器。这些弹性容器的子元素称为*弹性项目*—无论它们是子元素、非空文本节点还是生成的内容。在[图
    11-36](#display_flex_containers_children)中，每个字母都被包裹在自己的元素中，包括单词之间的空格，使得每个字母和空格都成为一个弹性项目。'
- en: '![Items with display: flex; become flex containers, and their non-absolutely
    positioned children become flex items](assets/css5_1136.png)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![Items with display: flex; become flex containers, and their non-absolutely
    positioned children become flex items](assets/css5_1136.png)'
- en: Figure 11-36\. The child nodes are flex items, and the parent node is a flex
    container [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-within-container.html)
  id: totrans-331
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-36\. 子节点是弹性项目，父节点是弹性容器 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-within-container.html)
- en: 'When it comes to text-node children of flex containers, if the text node is
    not empty (containing content other than whitespace), it will be wrapped in an
    *anonymous flex item*, behaving like its flex-item siblings. While these anonymous
    flex items do inherit all the flex properties set by the flex container, just
    like their DOM node siblings, they are not directly targetable with CSS. We can’t
    directly set any of the flex-item-specific properties on them. Thus, in the following
    markup, the two elements (`<strong>` and `<em>`) and the text “they’re what’s
    for” become flex items, for a total of three flex items:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到弹性容器的文本节点子元素时，如果文本节点不为空（包含除空白字符以外的内容），它将被包装在一个*匿名弹性项目*中，表现得像它的弹性项目兄弟一样。尽管这些匿名弹性项目继承了弹性容器设置的所有弹性属性，就像它们的
    DOM 节点兄弟一样，但无法直接通过 CSS 进行定位。我们不能直接在它们上面设置任何弹性项目特定的属性。因此，在以下标记中，两个元素（`<strong>`
    和 `<em>`）以及文本“they’re what’s for”成为弹性项目，总共有三个弹性项目：
- en: '[PRE27]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Generated content (via `::before` and `::after`) can be styled directly; therefore,
    all the properties discussed in this chapter apply equally to generated content
    and to element nodes.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`::before`和`::after`生成的内容可以直接进行样式化；因此，本章讨论的所有属性同样适用于生成的内容和元素节点。
- en: 'Whitespace-only text nodes within a flex container are ignored, as if their
    `display` property were set to `none`, as the following code example shows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性容器中的仅包含空白字符的文本节点将被忽略，就像它们的`display`属性被设置为`none`一样，如下面的代码示例所示：
- en: '[PRE28]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In the preceding code, with the `display` property set to `flex`, the unordered
    list is the flex container, and its child list items are all flex items. These
    list items, being flex items, are flex-level boxes—semantically still list items,
    but not list items in their presentation. They are not block-level boxes either.
    Rather, they participate in their container’s flex-formatting context. The whitespace
    between and around the `<li>` elements—the line feeds and indenting tabs and/or
    spaces—is completely ignored. The links are not flex items themselves, but are
    descendants of the flex items the list items have become.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码中，通过设置`display`属性为`flex`，无序列表成为了弹性容器，其子列表项全部成为弹性项目。这些列表项作为弹性项目是弹性级盒子—在语义上仍然是列表项，但在呈现上不是列表项。它们也不是块级盒子。相反，它们参与它们容器的弹性格式化上下文。列表项之间和周围的空白—换行符和缩进制表符和/或空格—完全被忽略。链接本身不是弹性项目，但是它们是列表项已成为的弹性项目的后代。
- en: Flex Item Features
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性项目特性
- en: 'The margins of flex items do not collapse. The `float` and `clear` properties
    don’t have an effect on flex items and do not take a flex item out of flow. In
    effect, `float` and `clear` are ignored when applied to flex items. (However,
    the `float` property can still affect box generation by influencing the `display`
    property’s computed value.) Consider the following:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this example, the `aside` is the flex container. The comment and whitespace-only
    text nodes are ignored. The text node containing “Some text” is wrapped in an
    anonymous flex item. The header, image, and text node containing “Some text” are
    all flex items. Because the image is a flex item, the `float` is ignored.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'Even though images and text nodes are inline-level nodes, because they are
    flex items, they are blockified as long as they are not absolutely positioned:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This markup is similar to the previous code example, except in this example
    we’ve added a link within the non-empty text node. In this case, we are creating
    five flex items illustrated in [Figure 11-37](#display_flex_five_items). The comment
    and whitespace-only text nodes are ignored. The header, the image, the text node
    before the link, the link, and the text node after the link are all flex items.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![](assets/css5_1137.png)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: Figure 11-37\. Five flex items in an aside [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-in-aside.html)
  id: totrans-349
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The text nodes containing “Some text” and “and more text” are wrapped in anonymous
    flex items, represented in [Figure 11-37](#display_flex_five_items) by the dashed
    boxes (the dashes having been added for illustrative purposes) with no background.
    The header, image, and link, being actual DOM nodes, can be styled directly with
    CSS, as you can see with the border styling. The anonymous flex containers are
    not directly targetable, and so will have only whatever styles they pick up from
    the flex container.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, `vertical-align` has no effect on a flex item, except as it affects
    the alignment of text within the flex item. Setting `vertical-align: bottom` on
    a flex item will make all the text inside that flex item align to the bottom of
    their line boxes; it will not push the flex item to the bottom of its container.
    (That’s what `align-items` and `align-self` are for.)'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Absolute Positioning
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While `float` will not actually float a flex item, setting `position: absolute`
    is a different story. The absolutely positioned children of flex containers, just
    like any other absolutely positioned element, are taken out of the flow of the
    document.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: More to the point, they do not participate in flex layout and are not part of
    the document flow. However, they can be impacted by the styles set on the flex
    container, just as a child can be impacted by a parent element that isn’t a flex
    container. In addition to inheriting any inheritable properties, the flex container’s
    properties can affect the origin of the positioning.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'The absolutely positioned child of a flex container is affected by both the
    `justify-content` value of the flex container and its own `align-self` value,
    if there is one. For example, if you set `align-self: center` on the absolutely
    positioned child, it will start out centered with respect to the flex container
    parent’s cross-axis. From there, the element or pseudo-element can be moved by
    properties like `top`, `bottom`, margins, and so on.'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex` 容器的绝对定位子元素受 `flex` 容器的 `justify-content` 值和其自身的 `align-self` 值的影响（如果有的话）。例如，如果在绝对定位的子元素上设置了
    `align-self: center`，它将从 `flex` 容器父元素的交叉轴中心开始对齐。然后，该元素或伪元素可以通过 `top`、`bottom`、边距等属性移动。'
- en: The `order` property (explained in [“The order Property”](#the-order-property))
    may not impact where the absolutely positioned flex container child is drawn,
    but it does impact the order in which it is drawn in relation to its siblings.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`order` 属性（在 [“`order` 属性”](#the-order-property) 中解释）可能不会影响绝对定位的 `flex` 容器子元素的绘制位置，但会影响其相对于兄弟元素的绘制顺序。'
- en: Minimum Widths
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小宽度
- en: In [Figure 11-38](#three-vals-flex-wrap), you’ll note that the flex line inside
    the container with the `nowrap` default `flex-wrap` value overflows its flex container.
    This is because when it comes to flex items, the implied value of `min-width`
    is `auto`, rather than `0`. Originally in the specification, if the items didn’t
    fit onto that single main-axis, they would shrink. However, the specification
    of `min-width` was altered as applied to flex items. (Traditionally, the default
    value for `min-width` is `0`.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11-38](#three-vals-flex-wrap) 中，您会注意到在 `nowrap` 默认 `flex-wrap` 值的容器内，`flex`
    容器内的 `flex` 行溢出。这是因为当涉及到 `flex` 项目时，`min-width` 的隐含值是 `auto`，而不是 `0`。最初在规范中，如果项目不能适应单一主轴，它们将会收缩。然而，`min-width`
    属性的规范在应用到 `flex` 项目时已经改变。（传统上，`min-width` 的默认值是 `0`。）
- en: '![Flex items overflowing their container when min-width defaults to auto, unless
    wrapping is allowed](assets/css5_1138.png)'
  id: totrans-359
  prefs: []
  type: TYPE_IMG
  zh: '![当最小宽度默认为自动时，`flex` 项目溢出其容器，除非允许换行](assets/css5_1138.png)'
- en: Figure 11-38\. Flex container overflow with minimum-width flex items [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-container-overflow-with-min-width.html)
  id: totrans-360
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-38\. 使用最小宽度 `flex` 项目的 `flex` 容器溢出 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-container-overflow-with-min-width.html)
- en: 'If you set `min-width` to a width narrower than the computed value of `auto`—for
    example, if you declare `min-width: 0`—the flex items in the `nowrap` example
    will shrink to be narrower than their actual content (in some cases). If the items
    are allowed to wrap, they will be as narrow as possible to fit their content,
    but no narrower. [Figure 11-39](#three-vals-min-width-0) illustrates both situations.'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '如果将 `min-width` 设置为比计算值 `auto` 更窄的宽度——例如，如果声明 `min-width: 0`——则 `nowrap` 示例中的
    `flex` 项目将收缩到比其实际内容更窄（某些情况下）。如果允许项目换行，则它们将尽可能窄以适应其内容，但不会更窄。 [图 11-39](#three-vals-min-width-0)
    描述了这两种情况。'
- en: '![Flex items in nonwrapping containers will shrink if the min-width is explicitly
    set to 0, which is the default in Safari 9](assets/css5_1139.png)'
  id: totrans-362
  prefs: []
  type: TYPE_IMG
  zh: '![在非换行容器中，如果将最小宽度明确设置为 `0`，则 `flex` 项目将会收缩，这是 Safari 9 的默认设置](assets/css5_1139.png)'
- en: Figure 11-39\. Zero-minimum-width flex items in nonwrapped and wrapped flex
    containers [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-zero-min-width-flex-items.html)
  id: totrans-363
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-39\. 非换行和换行 `flex` 容器中零最小宽度 `flex` 项目 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-wrap-zero-min-width-flex-items.html)
- en: Flex-Item-Specific Properties
  id: totrans-364
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`flex` 项目特定属性'
- en: While flex items’ alignment, order, and flexibility are to some extent controllable
    via properties set on their flex container, several properties can be applied
    to individual flex items for more granular control.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `flex` 项目的对齐方式、顺序和灵活性在其 `flex` 容器上通过属性设置到一定程度上可控时，对于更细粒度的控制，可以应用于单个 `flex`
    项目的多个属性。
- en: The `flex` shorthand property, along with its component properties of `flex-grow`,
    `flex-shrink`, and `flex-basis`, controls the flexibility of the flex items. *Flexibility*
    is the amount by which a flex item can grow or shrink along the main-axis.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex` 缩写属性及其组成属性 `flex-grow`、`flex-shrink` 和 `flex-basis` 控制了 `flex` 项目的灵活性。*灵活性*
    是 `flex` 项目沿着主轴能够增长或收缩的量。'
- en: The flex Property
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`flex` 属性'
- en: 'The defining aspect of flex layout is the ability to make the flex items *flex*:
    altering their width or height to fill the available space in the main dimension.
    A flex container distributes free space to its items proportionally to their flex
    grow factor, or shrinks them to prevent overflow proportionally to their flex
    shrink factor. (We’ll explore these concepts momentarily.)'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: flex 布局的定义方面是能够使 flex 项目 *灵活*：调整它们的宽度或高度以填充主尺寸中的可用空间。 flex 容器按照其 flex 增长因子比例分配剩余空间给其项目，或按其
    flex 缩小因子的比例收缩它们以防止溢出（我们马上会探讨这些概念）。
- en: Declaring the `flex` shorthand property on a flex item, or defining the individual
    properties that make up the shorthand, enables you to define the grow and shrink
    factors. If there is excess space, you can tell the flex items to grow to fill
    that space. Or not. If there isn’t enough room to fit all the flex items within
    the flex container at their defined or default sizes, you can tell the flex items
    to shrink proportionally to fit into the space. Or not.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在 flex 项目上声明 `flex` 简写属性，或者定义构成简写的各个属性，使您能够定义增长和缩小因子。 如果有多余空间，您可以告诉 flex 项目增长以填充该空间。
    或者不要。 如果没有足够的空间来容纳所有 flex 项目在其定义或默认大小中，您可以告诉 flex 项目按比例缩小以适应空间。 或者不要。
- en: This is all done with the `flex` property, which is a shorthand property for
    `flex-grow`, `flex-shrink`, and `flex-basis`. While these three subproperties
    can be used separately, it is highly recommended to always use the `flex` shorthand,
    for reasons we’ll soon cover.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都是通过 `flex` 属性完成的，这是 `flex-grow`、`flex-shrink` 和 `flex-basis` 的简写属性。 虽然这三个子属性可以单独使用，但强烈建议始终使用
    `flex` 简写，我们将很快解释原因。
- en: 'The `flex` property specifies the components of a flexible length: the *length*
    of the flex item being the length of the flex item along the main-axis (see [“Understanding
    Axes”](#understanding-axis)). When a box is a flex item, `flex` is consulted to
    determine the size of the box, instead of the main-axis size dimension property
    (`height` or `width`). The *components* of the `flex` property include the flex
    growth factor, flex shrink factor, and the flex basis.'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex` 属性指定了灵活长度的组成部分：flex 项目的长度是沿主轴（参见 [“理解轴”](#understanding-axis)）的 flex
    项目的长度。 当盒子是 flex 项目时，将参考 `flex` 来确定盒子的尺寸，而不是主轴尺寸维度属性（`height` 或 `width`）。 `flex`
    属性的组件包括 flex 增长因子、flex 缩小因子和 flex 基础值。'
- en: 'The *flex basis* determines how the flex growth and shrink factors are implemented.
    As its name suggests, the `flex-basis` component of the flex shorthand is the
    basis on which the flex item determines how much it can grow to fill available
    space or how much it should shrink to fit all the flex items when there isn’t
    enough space. It’s the initial size of each flex item, and can be restricted to
    that specific size by specifying `0` for both the growth and shrink factors:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*Flex basis* 确定了如何实施 flex 增长和缩小因子。 如其名称所示，flex 简写的 `flex-basis` 组件是 flex 项目确定可以增长填充可用空间的基础，或者在没有足够空间容纳所有
    flex 项目时缩小以适应所有 flex 项目的初始大小。 可以通过指定增长和缩小因子均为 `0` 来限制到特定大小：'
- en: '[PRE34]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding CSS, the flex item will have a main-axis size of exactly 200
    pixels, as the flex basis is `200px`, and it is allowed to neither grow nor shrink.
    Assuming that the main-axis is horizontal, the value of `width` (`50%`) is ignored.
    Similarly, a value for `height` would be ignored if the main-axis were vertical.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述 CSS 中，flex 项目的主轴尺寸将恰好为 200 像素，因为 flex 基础值为 `200px`，既不允许增长也不允许缩小。 假设主轴是水平的，则会忽略
    `width` 的值 (`50%`)。 类似地，如果主轴是垂直的，则会忽略 `height` 的值。
- en: Note
  id: totrans-375
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: This override of `height` and `width` occurs outside the cascade, so you can’t
    even override the flex basis by adding `!important` to the `height` or `width`
    value of a flex item.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 此处对 `height` 和 `width` 的覆盖发生在层叠之外，因此甚至不能通过在 flex 项目的 `height` 或 `width` 值中添加
    `!important` 来覆盖 flex 基础值。
- en: If the target of a selector is not a flex item, applying the `flex` property
    to it will have no effect.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 如果选择器的目标不是 flex 项目，则将 `flex` 属性应用于其将不会产生任何效果。
- en: It is important to understand the three components that make up the `flex` shorthand
    property in order to be able to use it effectively.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 理解组成 `flex` 简写属性的三个组件非常重要，以便能够有效地使用它。
- en: The flex-grow Property
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`flex-grow` 属性'
- en: The `flex-grow` property defines whether a flex item is allowed to grow when
    space is available, and, if so, how much it will grow proportionally relative
    to the growth of other flex-item siblings.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-grow` 属性定义了当空间可用时，伸缩项是否允许增长，以及如何相对于其他伸缩项兄弟项的增长成比例地增长。'
- en: Warning
  id: totrans-381
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Declaring the growth factor via the `flex-grow` property is *strongly* discouraged
    by the authors of the specification itself. Instead, declare the growth factor
    as part of the `flex` shorthand. We’re discussing the property here only to explore
    how growth works.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 建议通过`flex`的快捷方式将增长因子声明为`flex-grow`属性的方式被规范的作者*强烈*不建议。相反，应将增长因子作为`flex`的一部分声明。我们仅在此讨论属性以探讨增长的工作方式。
- en: The value of `flex-grow` is always a number. Negative numbers are not valid.
    You can use non-integers if you like, just as long as they’re 0 or greater. The
    value sets the *flex growth factor*, which determines how much the flex-item will
    grow relative to the rest of the flex item siblings as the flex container’s free
    space is distributed.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex-grow` 的值始终是一个数字。负数是无效的。您可以使用非整数，只要它们大于或等于0即可。该值设置了*伸缩增长因子*，确定了伸缩项在伸缩容器的剩余空间分配时相对于其他伸缩项兄弟项的增长量。'
- en: If any space is available within the flex container, the space will be distributed
    proportionally among the children with a nonzero positive growth factor based
    on the various values of those growth factors.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 如果伸缩容器内有任何空间可用，则该空间将根据各个增长因子的值以非零正增长因子比例分配给子项。
- en: 'For example, assume a `750px`-wide horizontal flex container with three flex
    items, each set to `width: 100px`. A total of 300 pixels of space is taken up
    by the flex items, leaving 450 pixels of “leftover” or available space (since
    750 – 300 = 450). This is the first scenario shown in [Figure 11-40](#variety_of_growth_factor_scenarios):
    none of the flex items are permitted to grow.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '例如，假设一个宽度为`750px`的水平伸缩容器，有三个伸缩项，每个设置为`width: 100px`。伸缩项占据了300像素的空间，剩下450像素的“剩余”或可用空间（因为750
    - 300 = 450）。这是图[11-40](#variety_of_growth_factor_scenarios)中展示的第一个场景：没有任何伸缩项被允许增长。'
- en: '![With a growth factor of 0, the flex item will not grow; any positive value
    will allow the item to grow proportionally to the value](assets/css5_1140.png)'
  id: totrans-386
  prefs: []
  type: TYPE_IMG
  zh: '![增长因子为0时，伸缩项不会增长；任何正值都将使项目按比例增长](assets/css5_1140.png)'
- en: Figure 11-40\. A variety of flex-growth scenarios [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-variety.html)
  id: totrans-387
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-40\. 各种伸缩增长因子场景 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-variety.html)
- en: 'In the second scenario in [Figure 11-40](#variety_of_growth_factor_scenarios),
    only one of the flex items (the third) has been given a growth factor. The declaration
    we gave it is `flex-grow: 1`, but it could be any positive number the browser
    can understand. In this case, with two items having no growth factor and the third
    having a growth factor, all of the available space is given to the flex item with
    a growth factor. Thus, the third flex item gets all 450 pixels of available space
    added to it, arriving at a final width of 550 pixels. The `width: 100px` applied
    to it elsewhere in the styles is overridden.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '在图[11-40](#variety_of_growth_factor_scenarios)中的第二个场景中，只有一个伸缩项（第三个）被赋予了增长因子。我们给它的声明是`flex-grow:
    1`，但浏览器可以理解的任何正数也可以。在这种情况下，两个没有增长因子的项目和一个有增长因子的第三个项目将所有可用空间都分配给具有增长因子的伸缩项。因此，第三个伸缩项获得了所有450像素的可用空间，最终宽度为550像素。它在其他样式中应用的`width:
    100px`被覆盖。'
- en: In the third and fourth scenarios, the same flex item widths result despite
    the differing flex growth factors. Let’s consider the third scenario, where the
    growth factors are 1, 1, and 3\. The factors are all added together to get a total
    of 5\. Each factor is then divided by that total to get a proportion. So here,
    the three values are each divided by 5, yielding 0.2, 0.2, and 0.6.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三和第四个场景中，尽管伸缩增长因子不同，但同一伸缩项的宽度相同。让我们考虑第三个场景，其中增长因子为1、1和3。这些因子相加得到总数5。然后，每个因子除以总数以得到比例。因此，在这里，三个值分别除以5，得到0.2、0.2和0.6。
- en: 'Each proportion is multiplied by the available space to get the amount of growth.
    Thus:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 每个比例都乘以可用空间以获取增长量。因此：
- en: 450 px × 0.2 = 90 px
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 450 px × 0.2 = 90 px
- en: 450 px × 0.2 = 90 px
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 450 px × 0.2 = 90 px
- en: 450 px × 0.6 = 270 px
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 450 px × 0.6 = 270 px
- en: Those are the growth portions added to each flex item’s starting width of 100
    pixels. Thus, the final widths are 190 pixels, 190 pixels, and 370 pixels, respectively.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是添加到每个 flex 项起始宽度的增长部分。因此，最终宽度分别为 190 像素、190 像素和 370 像素。
- en: The fourth scenario has the same result, because the proportions are the same.
    Imagine for a moment that we alter the growth factors to be 0.5, 1, and 1.5\.
    Now the math works out such that the first flex item gets one-sixth of the available
    space, the second gets a third, and the third gets half. This results in the flex
    items’ final widths being 175, 250, and 425 pixels, respectively. Had we declared
    growth factors of 0.1, 0.1, and 0.3, or 25, 25, and 75, or really any combination
    of numbers with a 1:1:3 correspondence, the result would have been identical.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 第四种情况结果相同，因为比例相同。想象一下，我们将增长因子修改为 0.5、1 和 1.5。现在的计算表明，第一个 flex 项获得可用空间的六分之一，第二个获得三分之一，第三个获得一半。这导致最终的
    flex 项宽度分别为 175、250 和 425 像素。如果我们声明增长因子为 0.1、0.1 和 0.3，或者 25、25 和 75，或者实际上任何 1:1:3
    对应的组合，结果都将相同。
- en: 'As noted in [“Minimum Widths”](#min-width), if no width or flex basis is set,
    the flex basis defaults to `auto`, meaning each flex item basis is the width of
    its nonwrapped content. The `auto` value is special: it defaults to `content`
    unless the item has a width set on it, at which point the flex basis becomes that
    width. The `auto` value is discussed in [“Automatic flex basis”](#auto). Had we
    not set the width in this example scenario, with our smallish font size, we would
    have had more than 450 pixels of distributable space along the main-axis.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [“最小宽度”](#min-width) 所述，如果未设置宽度或 flex 基础，则 flex 基础默认为 `auto`，这意味着每个 flex 项的基础宽度为其非包装内容的宽度。`auto`
    值很特殊：它默认为 `content`，除非为项目设置了宽度，在这种情况下，flex 基础将成为该宽度。`auto` 值在 [“自动 flex 基础”](#auto)
    中讨论过。如果我们在这个例子中没有设置宽度，根据我们的小字体大小，主轴上的可分配空间将超过 450 像素。
- en: Note
  id: totrans-397
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The main-axis size of a flex item is impacted by the available space, the growth
    factor of all the flex items, and the flex basis of the item. We have yet to cover
    [flex basis](#flex-basis), but that time is coming soon!
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 flex 项的主轴大小受到可用空间、所有 flex 项的增长因子以及项的 flex 基础的影响。我们还没有涵盖 [flex 基础](#flex-basis)，但那时会很快的！
- en: Now let’s consider flex items with different `width` values as well as different
    growth factors. In [Figure 11-41](#even-dist-avail-space), in the second example,
    we have flex items that are 100 pixels, 250 pixels, and 100 pixels wide, with
    growth factors of 1, 1, and 3, respectively, in a container that is 750 pixels
    wide. This means we have 300 pixels of extra space to distribute among a total
    of five growth factors (since 750 – 450 = 300). Each growth factor is therefore
    60 pixels (300 ÷ 5). Therefore, the first and second flex items, with a `flex-grow`
    value of `1`, will each grow by 60 pixels. The last flex item will grow by 180
    pixels, since its `flex-grow` value is `3`.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们考虑具有不同 `width` 值以及不同增长因子的 flex 项。在 [图 11-41](#even-dist-avail-space) 中的第二个例子中，我们有宽度为
    100 像素、250 像素和 100 像素的 flex 项，其增长因子分别为 1、1 和 3，在一个宽度为 750 像素的容器中。这意味着我们有额外的 300
    像素空间要在总共五个增长因子（因为 750 - 450 = 300）之间分配。因此，每个增长因子为 60 像素（300 ÷ 5）。因此，第一个和第二个 flex
    项，具有 `flex-grow` 值为 `1`，每个将增长 60 像素。最后一个 flex 项将增长 180 像素，因为其 `flex-grow` 值为 `3`。
- en: '![The available space is evenly distributed to each growth factor; any positive
    value will allow the item to grow proportionally to the value.](assets/css5_1141.png)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![可用空间均匀分配给每个增长因子；任何正值都将允许项目按比例增长。](assets/css5_1141.png)'
- en: Figure 11-41\. Mixed widths and growth factors [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-mixed-width-and-factors.html)
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-41。混合宽度和增长因子 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-mixed-width-and-factors.html)
- en: 'To recap, the available space in the flex container, the growth factors, and
    final width of each flex item are as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，flex 容器中的可用空间、增长因子和每个 flex 项的最终宽度如下：
- en: 'Available space: 750 px – (100 px + 250 px + 100 px) = 300 px'
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用空间：750 px – (100 px + 250 px + 100 px) = 300 px
- en: 'Growth factors: 1 + 1 + 3 = 5'
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增长因子：1 + 1 + 3 = 5
- en: 'Width of each growth factor: 300 px ÷ 5 = 60 px'
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个增长因子的宽度：300 px ÷ 5 = 60 px
- en: When flexed, the width of the flex items, based on their original width and
    growth factors, become
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 当进行弯曲时，根据它们的原始宽度和增长因子，flex 项的宽度变为
- en: item1 = 100 px + (1 × 60 px) = 160 px
  id: totrans-407
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项1 = 100 px + (1 × 60 px) = 160 px
- en: item2 = 250 px + (1 × 60 px) = 310 px
  id: totrans-408
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项2 = 250 px + (1 × 60 px) = 310 px
- en: item3 = 100 px + (3 × 60 px) = 280 px
  id: totrans-409
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 100 px + (3 × 60 px) = 280 px
- en: which adds up to 750 pixels.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 总计为 750 像素。
- en: Growth Factors and the flex Property
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生长因子和 flex 属性
- en: The `flex` property takes up to three values—the growth factor, shrink factor,
    and basis. The first positive non-null numeric value, if there is one, sets the
    growth factor (i.e., the `flex-grow` value). When the growth and shrink factors
    are omitted in the `flex` value, the growth factor defaults to `1`. However, if
    neither `flex` nor `flex-grow` is declared, the growth factor defaults to `0`.
    Yes, really.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex` 属性可以接受最多三个值 — 生长因子、收缩因子和基础值。如果第一个非空的正数数值设置了生长因子（即`flex-grow` 值）。当在 `flex`
    值中省略生长和收缩因子时，生长因子默认为`1`。但是，如果既未声明 `flex` 也未声明 `flex-grow`，生长因子则默认为`0`。是的，真的。'
- en: 'Recall the second example in [Figure 11-40](#variety_of_growth_factor_scenarios),
    where the flex growth factors were 0, 0, and 1. Because we declared a value for
    `flex-grow` only, the flex basis was set to `auto`, as if we had declared the
    following:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下 [图 11-40](#variety_of_growth_factor_scenarios) 中的第二个示例，其中 flex 生长因子为 0、0
    和 1。因为我们仅声明了 `flex-grow` 的值，所以 flex 基础值被设置为`auto`，就像我们声明了以下内容一样：
- en: '[PRE35]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'So that means the first two flex items had no growth factor, a shrink factor,
    and a flex basis of `auto`. Had we used `flex` in the examples in [Figure 11-40](#variety_of_growth_factor_scenarios)
    instead of ill-advisedly using `flex-grow`, the flex basis in each case would
    be set to `0%`, as if this had been done:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着前两个 flex 项没有生长因子，有收缩因子，并且基础值为`auto`。如果在 [图 11-40](#variety_of_growth_factor_scenarios)
    的示例中使用 `flex` 而不是不合理地使用 `flex-grow`，则每种情况下的 flex 基础值都将被设置为`0%`，就像这样做了一样：
- en: '[PRE36]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As the shrink factor defaults to `1` and the basis defaults to `0%`, the following
    CSS is identical to the preceding snippet:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 由于收缩因子默认为`1`，基础默认为`0%`，以下的 CSS 与前面的代码段完全相同：
- en: '[PRE37]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This would have the result shown in [Figure 11-42](#flex_basis_is_0). Compare
    this to [Figure 11-40](#variety_of_growth_factor_scenarios) to see how things
    have changed (or not).
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 [图 11-42](#flex_basis_is_0) 中显示的结果。与 [图 11-40](#variety_of_growth_factor_scenarios)
    进行比较，看看事情如何变化（或未变化）。
- en: 'You may notice something odd in the first two scenarios: the flex basis been
    set to 0, and only the last flex item in the second scenario has a positive value
    for flex growth. Logic would seem to dictate that the widths of the three flex
    items should be 0, 0, and 750 pixels, respectively. But logic would also dictate
    that it makes no sense to have content overflowing its flex item if the flex container
    has the room for all the content, even if the basis is set to `0`.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到前两种情况中的一些奇怪之处：flex 基础值被设置为0，而第二种情况中仅最后一个 flex 项具有正值的 flex 生长。逻辑似乎应该表明三个
    flex 项的宽度分别为0、0 和 750 像素。但逻辑也表明，如果 flex 容器有足够的空间容纳所有内容，即使基础值设置为`0`，也不应该使内容溢出其
    flex 项。
- en: The specification authors thought of this quandary. When the `flex` property
    declaration explicitly sets or defaults the flex basis to `0%` and a flex item’s
    growth factor is `0`, the length of the main-axis of the nongrowing flex items
    will shrink to the smallest length the content allows, or smaller. In [Figure 11-42](#flex_basis_is_0),
    that minimum length is the width of the widest sequence of letters, “flex:” (including
    the colon).
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 规范的作者们考虑到了这个困境。当 `flex` 属性声明显式设置或默认设置 flex 基础值为`0%` 并且 flex 项的生长因子为`0` 时，非生长型
    flex 项的主轴长度将会收缩到内容允许的最小长度，甚至更小。在 [图 11-42](#flex_basis_is_0) 中，这个最小长度是最宽的字符序列
    “flex:” 的宽度（包括冒号）。
- en: As long as a flex item has a visible overflow and no explicitly set value for
    `min-width` (or `min-height` for vertical main-axes), the minimum width (or minimum
    height) will be the smallest width (or height) that the flex item needs to be
    to fit the content or the declared `width` (or `height`), whichever is smaller.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 flex 项具有可见的溢出并且没有显式设置的 `min-width`（或垂直主轴的 `min-height`），最小宽度（或最小高度）将是 flex
    项需要的最小宽度（或高度），以适应内容或声明的 `width`（或 `height`），以较小者为准。
- en: '![Flex grow looks different when the flex basis is 0, and some items are not
    allowed to grow](assets/css5_1142.png)'
  id: totrans-423
  prefs: []
  type: TYPE_IMG
  zh: '![当 flex 基础值为 0 且某些项不允许生长时，flex 生长看起来有所不同](assets/css5_1142.png)'
- en: Figure 11-42\. Flex sizing when using the flex shorthand [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-sizing-when-using-shorthand.html)
  id: totrans-424
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-42\. 使用 flex 快捷方式时的 flex 大小调整 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-sizing-when-using-shorthand.html)
- en: 'If all items are allowed to grow, and the flex basis for each flex item is
    `0%`, *all* of the space, rather than just excess space, is distributed proportionally
    based on the growth factors. In the third example in [Figure 11-42](#flex_basis_is_0),
    two flex items have growth factors of 1, and one flex item has a growth factor
    of 3\. We thus have a total of five growth factors:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 如果允许所有项目增长，并且每个 flex 项的 flex 基础是`0%`，则所有空间而不仅仅是多余的空间都按照增长因子的比例进行分配。在[图 11-42](#flex_basis_is_0)的第三个示例中，两个
    flex 项的增长因子为 1，而一个 flex 项的增长因子为 3。因此，总共有五个增长因子：
- en: (2 × 1) + (1 × 3) = 5
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (2 × 1) + (1 × 3) = 5
- en: 'With five growth factors, and a total of 750 pixels, each growth factor is
    worth 150 pixels:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个增长因子，并且总共有 750 像素，每个增长因子值 150 像素：
- en: 750 px ÷ 5 = 150 px
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 750 像素 ÷ 5 = 150 像素
- en: 'While the default flex item size is 100 pixels, the flex basis of `0%` overrides
    that, leaving us with two flex items at 150 pixels each and the last flex item
    with a width of 450 pixels:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然默认的 flex 项大小为 100 像素，但 0% 的 flex 基础覆盖了该值，使得我们有两个 flex 项每个为 150 像素，最后一个 flex
    项宽度为 450 像素：
- en: 1 × 150 px = 150 px
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1 × 150 像素 = 150 像素
- en: 3 × 150 px = 450 px
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3 × 150 像素 = 450 像素
- en: 'Similarly, in the last example of [Figure 11-42](#flex_basis_is_0), with two
    flex items having growth factors of 0.5, and one flex item having a growth factor
    of 1.5, we have a total of 2.5 growth factors:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在[图 11-42](#flex_basis_is_0)的最后一个示例中，两个具有 0.5 的 flex 项的增长因子，以及一个具有 1.5 的
    flex 项，总共有 2.5 的增长因子：
- en: (2 × 0.5) + (1 × 1.5) = 2.5
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (2 × 0.5) + (1 × 1.5) = 2.5
- en: 'With a 2.5 growth factor, and a total of 750 pixels, each growth factor is
    worth 300 pixels:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 有 2.5 的增长因子，并且总共有 750 像素，每个增长因子值 300 像素：
- en: 750 px ÷ 2.5 = 300 px
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 750 像素 ÷ 2.5 = 300 像素
- en: 'While the default flex item size is 100 pixels, the flex basis of 0% overrides
    that, leaving us with two flex items at 150 pixels each and the last flex item
    with a width of 450 pixels:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然默认的 flex 项大小为 100 像素，但 0% 的 flex 基础覆盖了该值，使得我们有两个 flex 项每个为 150 像素，最后一个 flex
    项宽度为 450 像素：
- en: 0.5 × 300 px = 150 px
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 0.5 × 300 像素 = 150 像素
- en: 1.5 × 300 px = 450 px
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 1.5 × 300 像素 = 450 像素
- en: Again, this is different from declaring only `flex-grow`, because that means
    the flex basis defaults to `auto`. In that case, only the extra space, not all
    the space, is distributed proportionally. When using `flex`, on the other hand,
    the flex basis is set to `0%`, so the flex items grow in proportion to the total
    space, not just the leftover space. [Figure 11-43](#flex-grow-basis-0) illustrates
    the difference.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这与仅声明`flex-grow`不同，因为那意味着 flex 基础默认为`auto`。在这种情况下，只有额外的空间而不是所有空间按比例分配。而使用`flex`时，flex
    基础设置为`0%`，因此 flex 项按照总空间的比例增长，而不仅仅是剩余空间。[图 11-43](#flex-grow-basis-0)说明了这种差异。
- en: '![Flex grow looks different when the flex basis is 0, and sometimes are not
    allowed to grow](assets/css5_1143.png)'
  id: totrans-440
  prefs: []
  type: TYPE_IMG
  zh: '![当 flex 基础为 0 时，flex grow 看起来不同，并且有时不允许增长](assets/css5_1143.png)'
- en: Figure 11-43\. Flex sizing differences between using `flex` and `flex-grow`
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-differences-between-flex-and-flex-grow.html)
  id: totrans-441
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-43。使用`flex`和`flex-grow`之间的 flex 大小差异 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-grow-differences-between-flex-and-flex-grow.html)
- en: Now let’s talk about flex shrinking factors, which are in some ways the inverse
    of flex growth factors, but are in other ways different.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们谈谈 flex 收缩因子，它在某些方面是 flex 增长因子的反向，但在其他方面又有所不同。
- en: The flex-shrink Property
  id: totrans-443
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: flex-shrink 属性
- en: The <*`flex-shrink`*> portion of the `flex` shorthand property specifies the
    *flex shrink* *factor*. It can also be set via the `flex-shrink` property.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '`<*flex-shrink*>` 部分的 `flex` 简写属性指定了 *flex shrink* *因子*。它也可以通过 `flex-shrink`
    属性进行设置。'
- en: Warning
  id: totrans-445
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Declaring the shrink factor via the `flex-shrink` property is *strongly* discouraged
    by the authors of the specification itself. Instead, declare the shrink factor
    as part of the `flex` shorthand. We’re discussing the property here only to explore
    how shrinking works.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈建议不要通过 `flex-shrink` 属性声明收缩因子，而是将收缩因子作为 `flex` 简写的一部分声明。我们在这里讨论该属性仅仅是为了探讨收缩如何工作。
- en: The shrink factor determines how much a flex item will shrink relative to the
    rest of its flex-item siblings when there isn’t enough space for them all to fit,
    as defined by their content and other CSS properties. When omitted in the shorthand
    `flex` property value or when both `flex` and `flex-shrink` are omitted, the shrink
    factor defaults to `1`. Like the growth factor, the value of `flex-shrink` is
    always a number. Negative numbers are not valid. You can use non-integer values
    if you like, just as long as they’re greater than 0.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 收缩因子确定了当弹性项目无法容纳时，相对于其余弹性项目兄弟会收缩多少，这由它们的内容和其他 CSS 属性定义。在简写的 `flex` 属性值中省略或者
    `flex` 和 `flex-shrink` 都被省略时，收缩因子默认为 `1`。与增长因子一样，`flex-shrink` 的值始终是一个数字。负数是无效的。如果你愿意，可以使用非整数值，只要它们大于
    `0`。
- en: Basically, the shrink factor defines how “negative available space” is distributed
    when there isn’t enough room for the flex items, and the flex container isn’t
    allowed to otherwise grow or wrap. See [Figure 11-44](#flex-shrink-0).
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，收缩因子定义了当弹性项目无法容纳时，“负可用空间”如何分配，而且弹性容器也无法增长或换行。参见 [图 11-44](#flex-shrink-0)。
- en: '[Figure 11-44](#flex-shrink-0) is similar to [Figure 11-40](#variety_of_growth_factor_scenarios),
    except the flex items are set to `width: 300px` instead of 100 pixels. We still
    have a 750-pixel-wide flex container. The total width of the three items is 900
    pixels, meaning the content starts out 150 pixels wider than the parent flex container.
    If the items are not allowed to shrink or wrap (see [“Wrapping Flex Lines”](#the-flex-wrap-property)),
    they will burst out from the fixed-size flex container. This is demonstrated in
    the first example in [Figure 11-44](#flex-shrink-0): those items will not shrink
    because they have a zero shrink factor. Instead, they overflow the flex container.'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-44](#flex-shrink-0) 与 [图 11-40](#variety_of_growth_factor_scenarios)
    类似，只是弹性项目的 `width` 被设置为 `300px` 而不是 100 像素。我们仍然有一个 750 像素宽的弹性容器。三个项目的总宽度为 900
    像素，这意味着内容的起始宽度比父弹性容器宽出 150 像素。如果项目不允许收缩或换行（参见 [“Wrapping Flex Lines”](#the-flex-wrap-property)），它们将从固定大小的弹性容器中溢出。这在
    [图 11-44](#flex-shrink-0) 的第一个示例中得到了展示：这些项目不会收缩，因为它们的收缩因子为零。相反，它们会溢出弹性容器。'
- en: '![A flex shrink factor of 0 will not allow flex items to shrink; any positive
    value will enable the item to shrink proportionally relative to sibling flex items
    that are allowed to shrink on the same flex line](assets/css5_1144.png)'
  id: totrans-450
  prefs: []
  type: TYPE_IMG
  zh: '![当 `flex shrink factor` 值为 0 时，该弹性项目不会收缩；任何正值都将使该项目相对于在同一弹性行上允许收缩的其他弹性项目成比例地收缩](assets/css5_1144.png)'
- en: Figure 11-44\. A variety of flex shrinking scenarios [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-variety.html)
  id: totrans-451
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-44\. 多种弹性收缩场景 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-variety.html)
- en: In the second example in [Figure 11-44](#flex-shrink-0), only the last flex
    item is set to be able to shrink. The last flex item is thus forced to do all
    the shrinking necessary to enable all the flex items to fit within the flex container.
    With 900 pixels of content needing to fit into our 750-pixel container, we have
    150 pixels of negative available space. The two flex items with no shrink factor
    stay at 300 pixels wide. The third flex item, with a positive value for the shrink
    factor, shrinks 150 pixels, to end up 150 pixels wide. This enables the three
    items to fit within the container. (In this example, the shrink factor is `1`,
    but had it been `0.001` or `100` or `314159.65` or any other positive number the
    browser could understand, the result would be the same.)
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11-44](#flex-shrink-0) 的第二个示例中，只有最后一个弹性项目可以收缩。因此，最后一个弹性项目被迫承担使所有弹性项目都能适应弹性容器的所有收缩工作。由于有
    900 像素的内容需要适应到我们的 750 像素容器中，我们有 150 像素的负可用空间。没有收缩因子的两个弹性项目保持在 300 像素宽度。第三个弹性项目，其收缩因子为正值，收缩了
    150 像素，最终宽度为 150 像素。这使得三个项目能够适应容器内。在这个例子中，收缩因子为 `1`，但如果是 `0.001` 或 `100` 或 `314159.65`
    或任何浏览器能理解的其他正数，结果都将是一样的。
- en: 'In the third example, we have positive shrink factors for all three flex items:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，我们对所有三个弹性项目都设置了正收缩因子：
- en: '[PRE38]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'As this is the only one of the three `flex` shorthand properties we declared,
    this means the flex items will behave as if we had declared the following:'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是我们声明的三个 `flex` 简写属性中的唯一一个，这意味着弹性项目的行为将如同我们声明了以下内容一样：
- en: '[PRE39]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: If all items are allowed to shrink, as is the case here, the shrinking is distributed
    proportionally based on the shrink factors. This means the larger a flex item’s
    shrink factor, as compared to the shrink factors of its sibling flex items, the
    more the item will shrink in comparison.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有的项都允许收缩，如此例所示，那么收缩将按照收缩因子的比例进行分配。这意味着，与其同级伸缩项的收缩因子相比，伸缩项的收缩因子越大，该项在收缩时收缩得越多。
- en: 'With a parent 750 pixels wide, and three flex items with a width of 300 pixels,
    150 “negative space” pixels need to be shaved off the flex items that are allowed
    to shrink (which is all of them in this example). With two flex items having a
    shrink factor of 1, and one flex item having a shrink factor of 3, we have a total
    of five shrink factors:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个宽度为750像素的父级容器，和三个宽度为300像素的伸缩项，需要从可以收缩的伸缩项中刮掉150个“负空间”像素（在本例中是全部）。其中，两个伸缩项具有收缩因子1，一个伸缩项具有收缩因子3，总共有五个收缩因子：
- en: (2 × 1) + (1 × 3) = 5
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (2 × 1) + (1 × 3) = 5
- en: 'With five shrink factors, and a total of 150 pixels needing to be shaved off
    all the flex items, each shrink factor is worth 30 pixels:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个收缩因子，总共需要从所有伸缩项中削减150像素，每个收缩因子相当于30像素：
- en: 150 px ÷ 5 = 30 px
  id: totrans-461
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 150 px ÷ 5 = 30 px
- en: 'The default flex item size is 300 pixels, leading us to have two flex items
    with a width of 270 pixels each and the last flex item having a width of 210 pixels,
    which totals 750 pixels:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的伸缩项大小为300像素，导致我们有两个伸缩项的宽度分别为270像素，最后一个伸缩项的宽度为210像素，总计750像素：
- en: 300 px – (1 × 30 px) = 270 px
  id: totrans-463
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 300 px – (1 × 30 px) = 270 px
- en: 300 px – (3 × 30 px) = 210 px
  id: totrans-464
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 300 px – (3 × 30 px) = 210 px
- en: 'The following CSS produces the same outcome: while the numeric representations
    of the shrink factors are different, they are proportionally the same, so the
    flex item widths will be the same:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 以下CSS产生了相同的结果：尽管收缩因子的数字表示不同，但它们在比例上是相同的，因此伸缩项的宽度将是相同的：
- en: '[PRE40]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Note that the flex items in these examples will shrink to 210, 210, and 270
    pixels, respectively, *as long as* the content (like media objects or nonwrappable
    text) within each flex item is not wider than 210, 210, or 270 pixels, respectively.
    If the flex item contains content that cannot wrap or otherwise shrink in the
    main dimension, the flex item will not shrink any further.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这些示例中，伸缩项将收缩到分别为210、210和270像素，*只要*每个伸缩项内的内容（如媒体对象或不可换行的文本）不超过210、210或270像素。如果伸缩项包含不能在主尺寸上换行或以其他方式收缩的内容，则该伸缩项将不会进一步收缩。
- en: Suppose that the first flex items contain an image 300 pixels wide. That first
    flex item cannot shrink, and other flex items can shrink; therefore, it will not
    shrink, as if it had a null shrink factor. In this case, the first item would
    be 300 pixels, with the 150 pixels of negative space distributed proportionally
    based on the shrink factors of the second and third flex items.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 假设第一个伸缩项包含一张宽300像素的图像。第一个伸缩项无法收缩，其他伸缩项可以收缩；因此，它不会收缩，就好像它有一个空的收缩因子。在这种情况下，第一个项将为300像素，剩余的150像素负空间将根据第二个和第三个伸缩项的收缩因子比例进行分配。
- en: 'That being the case, we have four unimpeded shrink factors (one from the second
    flex item, and three from the third) for 150 pixels of negative space, with each
    shrink factor being worth 37.5 pixels. The flex items will end up 300, 262.5,
    and 187.5 pixels, respectively, for a total of 750 pixels, as shown here and illustrated
    in [Figure 11-45](#flex-shrink-with-image):'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于这种情况，我们有四个未受阻的收缩因子（来自第二个伸缩项的一个，以及第三个伸缩项的三个），用于150个负空间像素，每个收缩因子相当于37.5像素。伸缩项的宽度最终将分别为300、262.5和187.5像素，总计750像素，如此处所示，并在[图11-45](#flex-shrink-with-image)中进行了说明：
- en: item1 = 300 px – (0 × 37.5 px) = 300.0 px
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 300 px – (0 × 37.5 px) = 300.0 px
- en: item2 = 300 px – (1 × 37.5 px) = 262.5 px
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item2 = 300 px – (1 × 37.5 px) = 262.5 px
- en: item3 = 300 px – (3 × 37.5 px) = 187.5 px
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 300 px – (3 × 37.5 px) = 187.5 px
- en: '![](assets/css5_1145.png)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1145.png)'
- en: Figure 11-45\. Shrinking being impeded by flex-item content [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-with-image.html)
  id: totrans-474
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-45\. 由于伸缩项内容而受到限制的收缩 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-with-image.html)
- en: Had the image been 296 pixels wide, that first flex item would have been able
    to shrink by 4 pixels. The remaining 146 pixels of negative space would then be
    distributed among the four remaining factors, yielding 36.5 pixels per factor.
    The flex items would then be 296, 263.5, and 190.5 pixels wide, respectively.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图像宽度为296像素，那么第一个弹性项将能够收缩4像素。剩余的146像素负空间将分配给剩余的四个因子，每个因子分配36.5像素。然后，弹性项宽度将变为296、263.5和190.5像素。
- en: If all three flex items contained nonwrappable text or media 300 pixels or wider,
    none of the three flex items would not shrink, appearing similar to the first
    example in [Figure 11-44](#flex-shrink-0).
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有三个弹性项包含非换行文本或宽度为300像素或更宽的媒体，则这三个弹性项都不会收缩，类似于第一个示例中的[图 11-44](#flex-shrink-0)。
- en: Proportional shrinkage based on width and shrink factor
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 基于宽度和收缩因子的比例缩小
- en: The preceding code examples are fairly simple because all the flex items start
    with the same width. But what if the widths are different? What if the first and
    last flex items have a width of 250 pixels and the middle flex item has a width
    of 500 pixels, as shown in [Figure 11-46](#flex-items-shrink-factor)?
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码示例相对简单，因为所有弹性项的宽度相同。但如果宽度不同呢？如果第一个和最后一个弹性项的宽度为250像素，而中间的弹性项的宽度为500像素，如[图 11-46](#flex-items-shrink-factor)所示？
- en: '![Flex items shrink proportionally relative to their shrink factor](assets/css5_1146.png)'
  id: totrans-479
  prefs: []
  type: TYPE_IMG
  zh: '![弹性项根据其收缩因子按比例收缩](assets/css5_1146.png)'
- en: Figure 11-46\. Flex items shrink proportionally relative to their shrink factor
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-proportionally-relative-to-factor.html)
  id: totrans-480
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-46\. 弹性项根据其收缩因子按比例收缩 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-proportionally-relative-to-factor.html)
- en: Flex items shrink proportionally relative to both the shrink factor *and* the
    flex item’s width, with the width often being the width of the flex item’s content
    with no wrapping. In [Figure 11-46](#flex-items-shrink-factor), we are trying
    to fit 1,000 pixels into a flex container that’s 750 pixels wide. We have an excess
    of 250 pixels to be removed from five shrink factors.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性项根据其收缩因子和弹性项的宽度按比例收缩，宽度通常是弹性项内容的宽度，没有换行。在[图 11-46](#flex-items-shrink-factor)中，我们试图将1000像素放入一个750像素宽的弹性容器中。我们有多出的250像素要从五个收缩因子中移除。
- en: If this were a `flex-grow` situation, we would simply divide 250 pixels by 5,
    allocating 50 pixels per growth factor. If we were to shrink that way, we would
    get flex items 200, 550, and 100 pixels wide, respectively. But that’s not how
    shrinking actually works.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个`flex-grow`的情况，我们只需将250像素除以5，分配每个增长因子50像素。如果我们按这种方式收缩，我们得到的弹性项宽度分别为200、550和100像素。但实际的收缩方式并非如此。
- en: 'Here, we have 250 pixels of negative space to proportionally distribute. To
    get the shrink factor proportions, we divide the negative space by the total of
    the flex items’ widths (more precisely, their lengths along the main-axis) times
    their shrink factors:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有250像素的负空间要按比例分配。为了获取收缩因子的比例，我们将负空间除以弹性项宽度（更精确地说，沿主轴的长度）乘以它们的收缩因子总和：
- en: <math alttext="upper S h r i n k upper P e r c e n t equals StartFraction upper
    N e g a t i v e upper S p a c e Over left-parenthesis left-parenthesis upper W
    i d t h Baseline 1 times upper S h r upper F Baseline 1 right-parenthesis plus
    period period period plus left-parenthesis upper W i d t h upper N times upper
    S h r upper F upper N right-parenthesis right-parenthesis EndFraction" display="block"><mrow><mi>S</mi>
    <mi>h</mi> <mi>r</mi> <mi>i</mi> <mi>n</mi> <mi>k</mi> <mi>P</mi> <mi>e</mi> <mi>r</mi>
    <mi>c</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>N</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi></mrow>
    <mrow><mo>(</mo><mo>(</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mn>1</mn><mo>×</mo><mi>S</mi><mi>h</mi><mi>r</mi><mi>F</mi><mn>1</mn><mo>)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo>(</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mi>N</mi><mo>×</mo><mi>S</mi><mi>h</mi><mi>r</mi><mi>F</mi><mi>N</mi><mo>)</mo><mo>)</mo></mrow></mfrac></mrow></math>
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: <math alttext="upper S h r i n k upper P e r c e n t equals StartFraction upper
    N e g a t i v e upper S p a c e Over left-parenthesis left-parenthesis upper W
    i d t h Baseline 1 times upper S h r upper F Baseline 1 right-parenthesis plus
    period period period plus left-parenthesis upper W i d t h upper N times upper
    S h r upper F upper N right-parenthesis right-parenthesis EndFraction" display="block"><mrow><mi>S</mi>
    <mi>h</mi> <mi>r</mi> <mi>i</mi> <mi>n</mi> <mi>k</mi> <mi>P</mi> <mi>e</mi> <mi>r</mi>
    <mi>c</mi> <mi>e</mi> <mi>n</mi> <mi>t</mi> <mo>=</mo> <mfrac><mrow><mi>N</mi><mi>e</mi><mi>g</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>v</mi><mi>e</mi><mi>S</mi><mi>p</mi><mi>a</mi><mi>c</mi><mi>e</mi></mrow>
    <mrow><mo>(</mo><mo>(</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mn>1</mn><mo>×</mo><mi>S</mi><mi>h</mi><mi>r</mi><mi>F</mi><mn>1</mn><mo>)</mo><mo>+</mo><mo>.</mo><mo>.</mo><mo>.</mo><mo>+</mo><mo>(</mo><mi>W</mi><mi>i</mi><mi>d</mi><mi>t</mi><mi>h</mi><mi>N</mi><mo>×</mo><mi>S</mi><mi>h</mi><mi>r</mi><mi>F</mi><mi>N</mi><mo>)</mo><mo>)</mo></mrow></mfrac></mrow></math>
- en: 'Using this equation, we find the shrink percentage:'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个方程式，我们找到了收缩百分比：
- en: = 250 px ÷ [(250 px × 1) + (500 px × 1) + (250 px × 3)]
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: = 250 px ÷ [(250 px × 1) + (500 px × 1) + (250 px × 3)]
- en: = 250 px ÷ 1500 px
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: = 250 px ÷ 1500 px
- en: = 0.166666667 (16.67%)
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: = 0.166666667 (16.67%)
- en: 'When we reduce each flex item by 16.67% times the value of `flex-shrink`, we
    end up with flex items that are reduced as follows:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们按`flex-shrink`值的16.67%减少每个弹性项时，我们得到如下减少的弹性项宽度：
- en: item1 = 250 px × (1 × 16.67%) = 41.67 px
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 250 px × (1 × 16.67%) = 41.67 px
- en: item2 = 500 px × (1 × 16.67%) = 83.33 px
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item2 = 500 px × (1 × 16.67%) = 83.33 px
- en: item3 = 250 px × (3 × 16.67%) = 125 px
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 250 px × (3 × 16.67%) = 125 px
- en: Each reduction is then subtracted from the starting sizes of 250, 500, and 250
    pixels, respectively. Thus we have flex items that are 208.33, 416.67, and 125
    pixels wide.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 然后从起始大小分别减去每个缩小值，得到的弹性项宽度分别为208.33、416.67和125像素。
- en: Differing basis values
  id: totrans-494
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不同的基础值
- en: When the shrink factor has been set to `0`, and both the width and flex basis
    of a flex item are set to `auto`, the item’s content will not wrap, even when
    you think it should. Conversely, any positive shrink value enables content to
    wrap. Because shrinking is proportional based on the shrink factor, if all the
    flex items have similar shrink factors, the content should wrap over a similar
    number of lines.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 当收缩因子被设置为`0`，且弹性项的宽度和基础宽度均设为`auto`时，即使你认为内容应该换行，该项的内容也不会换行。相反，任何正的收缩值都会使内容换行。因为收缩是根据收缩因子成比例的，如果所有弹性项的收缩因子相似，内容应该会以相似的行数换行。
- en: In the three examples shown in [Figure 11-47](#flex_items_shrink_proportionally),
    the flex items do not have a declared width. Therefore, the width is based on
    the content, because `width` defaults to `auto`. The flex container has been made
    520 pixels wide instead of our usual 750 pixels.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图11-47](#flex_items_shrink_proportionally)中显示的三个示例中，弹性项未声明宽度。因此，宽度基于内容，因为`width`默认为`auto`。弹性容器的宽度已调整为520像素，而不是通常的750像素。
- en: '![css5 1147](assets/css5_1147.png)'
  id: totrans-497
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1147](assets/css5_1147.png)'
- en: Figure 11-47\. Flex items shrink proportionally relative to their shrink factor
    and content [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-proportionally-relative-to-factor-and-content.html)
  id: totrans-498
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-47\. 弹性项根据其收缩因子和内容成比例收缩 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-proportionally-relative-to-factor-and-content.html)
- en: Note that in the first example, where all the items have the same `flex-shrink`
    value, all content wraps over four lines. In the second example, the first flex
    item has a shrink factor that’s half the value of the other flex items, so it
    wraps the content over (roughly) half the number of lines. This is the power of
    the shrink factor.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在第一个示例中，所有项的`flex-shrink`值相同，所有内容都会换行为四行。在第二个示例中，第一个弹性项的收缩因子是其他弹性项的一半，所以它将内容换行为（大致）一半的行数。这就是收缩因子的威力。
- en: In the third example, with no shrink factor, the text doesn’t wrap at all, and
    the flex items overflow the container by quite a bit.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，没有收缩因子，文本根本不换行，而且弹性项远超容器。
- en: Warning
  id: totrans-501
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, this “line-balancing” and refusal-to-wrap behavior is not consistent
    across browsers. If you see different results when trying this out for yourself,
    that may be why.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年末，这种“行平衡”和拒绝换行的行为在各浏览器间并不一致。如果您在自己尝试时看到不同的结果，可能就是原因。
- en: Because the `flex` property’s shrink factor reduces the width of flex items
    proportionally, the number of lines of text in the flex items will grow or shrink
    as the width shrinks or grows, leading to similar height content within sibling
    flex items when the shrink factors are similar.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 因为`flex`属性的收缩因子按比例减少弹性项的宽度，当宽度收缩或扩展时，弹性项中的文本行数也会增加或减少，从而在收缩因子相似时在兄弟弹性项内产生类似高度的内容。
- en: In the examples, take the contents of the flex items to be 280, 995, and 480
    pixels, respectively—which are the widths of the nonwrapping flex items in the
    third example (as measured by the developer tools, then rounded to make this example
    a little simpler). This means we have to fit 1,755 pixels of content into a 520-pixel-wide
    flex container by shrinking the flex items proportionally based on their shrink
    factor. We have 1,235 pixels of negative available space to proportionally distribute.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，假设弹性项的内容分别为280、995和480像素，这些是第三个示例中非换行弹性项的宽度（由开发工具测量，然后四舍五入，以使此示例更简单）。这意味着我们必须通过根据其收缩因子成比例收缩弹性项，将1,755像素的内容装入520像素宽的弹性容器中。我们有1,235像素的可用负空间进行成比例分配。
- en: Note
  id: totrans-505
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you can’t rely on web inspector tools to figure out shrink factors
    for production. We’re going through this exercise to show how shrink factors work.
    If minutia isn’t your thing, feel free to jump to [“The flex-basis Property”](#flex-basis).
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您不能依赖于Web检查工具来确定生产中的收缩因子。我们正在进行此练习，以展示收缩因子的工作原理。如果细节不是您的事情，请随时跳到[“flex-basis属性”](#flex-basis)。
- en: In our first example, the flex items will end up with the same, or approximately
    the same, number of text lines. This is because flex items shrink proportionally,
    based on the width of their content.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个示例中，弹性项最终将具有相同或近似相同的文本行数。这是因为弹性项根据其内容的宽度成比例收缩。
- en: 'We didn’t declare any widths, and therefore can’t simply use an explicit element
    width as the basis for our calculations, as we did in the previous examples. Rather,
    we distribute the 1,235 pixels of negative space proportionally based on the widths
    of the content—280, 995, and 480 pixels, respectively. We determine 520 is 29.63%
    of 1,755\. To determine the width of each flex item with a shrink factor of 1,
    we multiply the content width of each flex item by 29.63%:'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有声明任何宽度，因此不能像在前面的示例中那样简单地使用显式元素宽度作为计算基础。相反，我们根据内容的宽度（分别为 280、995 和 480 像素）在
    1,235 像素的负空间中按比例分配它们。我们确定 520 是 1,755 的 29.63%。要确定收缩因子为 1 的每个 flex 项目的宽度，我们将每个
    flex 项目的内容宽度乘以 29.63%：
- en: item1 = 280 px × 29.63% = 83 px
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 280 px × 29.63% = 83 px
- en: item2 = 995 px × 29.63% = 295 px
  id: totrans-510
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item2 = 995 px × 29.63% = 295 px
- en: item3 = 480 px × 29.63% = 142 px
  id: totrans-511
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 480 px × 29.63% = 142 px
- en: 'With the default of `align-items: stretch` (see [“Aligning Items”](#the-align-items-property)),
    a three-column layout will have three columns of equal height. By using a consistent
    shrink factor for all flex items, you can indicate that the actual content of
    these three flex items should be of approximately equal height—though, by doing
    this, the widths of those columns will not necessarily be uniform.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '使用默认的`align-items: stretch`（见[“对齐项目”](#the-align-items-property)），三列布局将具有相等高度的三列。通过对所有
    flex 项目使用一致的收缩因子，您可以指示这三个 flex 项目的实际内容应该具有大致相等的高度——尽管这样做，这些列的宽度不一定是均匀的。'
- en: 'In the second example in [Figure 11-47](#flex_items_shrink_proportionally),
    the flex items don’t all have the same shrink factor. The first flex item will,
    proportionally, shrink half as much as the others. We start with the same widths:
    280, 995, and 480 pixels, respectively, but their shrink factors are 0.5, 1.0,
    and 1.0. Because we know the widths of the content, the shrink factor (*X*) can
    be found mathematically:'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11-47](#flex_items_shrink_proportionally) 的第二个示例中，flex 项目的收缩因子并不完全相同。第一个
    flex 项目将按比例缩小一半，其他项目将按比例缩小。我们开始时拥有相同的宽度：分别为 280、995 和 480 像素，但它们的收缩因子分别为 0.5、1.0
    和 1.0。因为我们知道内容的宽度，可以通过数学方法找到收缩因子（*X*）：
- en: 280 px + 995 px + 480 px = 1,615 px
  id: totrans-514
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 280 px + 995 px + 480 px = 1,615 px
- en: (0.5 × 280 px) + (1 × 995 px) + (1 × 480 px) = 1,235 px
  id: totrans-515
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: (0.5 × 280 px) + (1 × 995 px) + (1 × 480 px) = 1,235 px
- en: '*X* = 1,235 px ÷ 1,615 px = 0.7647'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*X* = 1,235 px ÷ 1,615 px = 0.7647'
- en: 'We can find the final widths now that we know the shrink factor. If the shrink
    factor is 76.47%, `item2` and `item3` will shrink by that amount, whereas `item1`
    will shrink by 38.23% (because its `flex-shrink` value is half the others). The
    amount of shrinkage in each case is rounded off to the nearest whole number:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道收缩因子，我们可以找到最终的宽度。如果收缩因子为 76.47%，`item2` 和 `item3` 将以此比例收缩，而 `item1` 将以
    38.23% 收缩（因为其 `flex-shrink` 值是其他项目的一半）。在每种情况下，收缩量四舍五入至最接近的整数：
- en: item1 = 280 px × 0.3823 = 107 px
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 280 px × 0.3823 = 107 px
- en: item2 = 995 px × 0.7647 = 761 px
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item2 = 995 px × 0.7647 = 761 px
- en: item3 = 480 px × 0.7647 = 367 px
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 480 px × 0.7647 = 367 px
- en: 'Thus, the final widths of the flex items are as follows:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，flex 项目的最终宽度如下：
- en: item1 = 280 px – 107 px = 173 px
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 280 px – 107 px = 173 px
- en: item2 = 995 px – 761 px = 234 px
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item2 = 995 px – 761 px = 234 px
- en: item3 = 480 px – 367 px = 113 px
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 480 px – 367 px = 113 px
- en: The total combined widths of these three flex items is 520 pixels.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个 flex 项目的总宽度组合为 520 像素。
- en: Adding in varying shrink and growth factors makes it all a little less intuitive.
    That’s why you likely want to always declare the `flex` shorthand, preferably
    with a width or basis set for each flex item. If this doesn’t make sense yet,
    don’t worry; we’ll cover a few more examples of shrinking as we discuss `flex-basis`.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 添加不同的收缩和增长因子使一切变得不那么直观。这就是为什么您可能希望始终声明 `flex` 简写，最好为每个 flex 项目设置宽度或基础。如果现在还不理解，不用担心；我们将讨论更多关于
    `flex-basis` 收缩的示例。
- en: Responsive flexing
  id: totrans-527
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应式 flex
- en: 'Allowing flex items to shrink proportionally allows for responsive objects
    and layouts that can shrink proportionally without breaking. For example, you
    can create a three-column layout that smartly grows and shrinks without media
    queries, as shown on a wide screen in [Figure 11-48](#set_diff_values) and narrow
    screen in [Figure 11-49](#set_diff_values-2):'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 允许 flex 项目按比例收缩可创建响应式对象和布局，无需断点查询，例如，在宽屏上显示为 [图 11-48](#set_diff_values)，在窄屏上显示为
    [图 11-49](#set_diff_values-2)：
- en: '[PRE41]'
  id: totrans-529
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '![By setting different values for growth, shrink, basis, and min-width, you
    can create responsive layouts, with or without media queries](assets/css5_1148.png)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![通过设置不同的增长、收缩、基础和最小宽度值，您可以创建响应式布局，无论是否使用媒体查询](assets/css5_1148.png)'
- en: Figure 11-48\. A wide flexbox layout
  id: totrans-531
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-48。一个宽阔的 flexbox 布局
- en: '![css5 1149](assets/css5_1149.png)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1149](assets/css5_1149.png)'
- en: Figure 11-49\. A narrow flexbox layout [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-homepage.html)
  id: totrans-533
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-49。一个窄的 flexbox 布局 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-shrink-homepage.html)
- en: In this example, if the viewport is greater than 1,000 pixels, only the middle
    column grows because only the middle column is provided with a positive growth
    factor. We also dictate that below the 1,000-pixel-wide mark, all the columns
    shrink.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果视口宽度大于1000像素，只有中间列会增长，因为只有中间列被提供了正增长因子。我们还规定在1000像素宽标记以下，所有列都会收缩。
- en: 'Let’s take it bit by bit. The `<nav>` and `<aside>` elements have the following
    CSS:'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一点点来看。`<nav>`和`<aside>`元素有以下CSS：
- en: '[PRE42]'
  id: totrans-536
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: They don’t grow from their basis but can shrink at equal rates. This means they’ll
    have the width of their flex basis by default. If they do need to shrink, they’ll
    shrink to a minimum width of `150px` and then stop shrinking. However, if either
    one has an element that’s more than 150 pixels wide, whether it’s an image or
    a run of text, it will stop shrinking as soon as it reaches the width of that
    bit of content. Suppose a 180-pixel image dropped into the `<aside>` element.
    It would stop shrinking as soon as it reaches 180 pixels wide. The `<nav>` would
    keep shrinking down to 150 pixels.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不会根据基础增长，但可以以相等的速率收缩。这意味着它们默认将以它们的 flex 基础宽度为宽度。如果它们需要收缩，它们将会收缩到最小宽度`150px`然后停止收缩。然而，如果其中一个有一个超过150像素宽的元素，无论是图像还是文本运行，当它达到该内容位的宽度时，它将停止收缩。假设一个180像素的图像放入`<aside>`元素中。一旦它达到180像素宽，它将停止收缩。`<nav>`将继续缩小到150像素。
- en: 'The `<main>` element, on the other hand, has these styles:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`<main>`元素有以下样式：
- en: '[PRE43]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Thus, the `<main>` element can grow if there’s space for it to do so. Since
    it’s the only flex item that can grow, it gets all the growth. Given a browser
    window 1,300 pixels wide, the two side columns will be 200 pixels wide each, leaving
    900 pixels of width for the center column. In shrinking situations, the center
    column will shrink twice as fast as the other two elements. Thus, if the browser
    window is 900 pixels wide, each side column will be 175 pixels wide, and the center
    column 550 pixels wide.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果有空间，`<main>`元素可以增长。因为它是唯一可以增长的 flex 项目，它得到所有的增长。假设浏览器窗口宽度为1300像素，两侧列将各为200像素宽，剩下900像素宽度给中间列。在收缩情况下，中间列将比其他两个元素快两倍缩小。因此，如果浏览器窗口宽度为900像素，每个侧列将为175像素宽，中间列为550像素宽。
- en: Once the window reaches 800 pixels wide, the side columns will reach their `min-width`
    values of `150px`. From then on, any narrowing will be taken up by the center
    column.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦窗口宽度达到800像素，侧列将达到它们的最小宽度值`150px`。从那时起，任何缩窄将由中间列接管。
- en: 'Just to be clear, you are not required to use pixels in these situations. You
    don’t even have to use the same unit measures for various flex basis values. The
    previous example could be rewritten like this:'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，在这些情况下，您并不需要使用像素。甚至可以对各种 flex 基础值使用不同的单位度量。前面的例子可以重写如下：
- en: '[PRE44]'
  id: totrans-543
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We won’t go through all the math here, but the general approach is to set flex
    basis values on character widths for improved readability, with some lower limits
    based on character widths and others on viewport width.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会在这里详细讨论所有的数学，但一般的方法是在字符宽度上设置 flex 基础值以提高可读性，有些基于字符宽度的下限，有些基于视口宽度。
- en: Note
  id: totrans-545
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Flexbox can be useful for a one-dimensional page layout like the one shown in
    this section, with only three columns in a line. For anything more complex, or
    for a more powerful set of options, use grid layout. (See [Chapter 12](ch12.html#grid-layout).)
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: Flexbox对于像本节所示的一维页面布局非常有用，只有一行中的三列。对于更复杂的布局或更强大的选项集，请使用网格布局（见[第12章](ch12.html#grid-layout)）。
- en: The flex-basis Property
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: flex-basis 属性
- en: As you’ve already seen, a flex item’s size is impacted by its content and box-model
    properties and can be reset via the three components of the `flex` property. The
    <*`flex-basis`*> component of the `flex` property defines the initial or default
    size of flex items, before extra or negative space is distributed—before the flex
    items are allowed to grow or shrink according to the growth and shrink factors.
    It can also be set via the `flex-basis` property.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您已经看到的，弹性项的大小受其内容和框模型属性的影响，并可以通过`flex`属性的三个组件来重置。`flex`属性的<*`flex-basis`*>组件定义了弹性项在额外或负空间分配之前的初始或默认大小——在允许弹性项根据增长和收缩因子增长或缩小之前。它也可以通过`flex-basis`属性设置。
- en: Warning
  id: totrans-549
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Declaring the flex basis via the `flex-basis` property is *strongly* discouraged
    by the authors of the specification itself. Instead, declare the flex basis as
    part of the `flex` shorthand. We’re discussing the property here only to explore
    the flex basis.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 强烈不建议通过`flex-basis`属性声明弹性基础，这是规范作者本人的建议。相反，应将弹性基础作为`flex`简写的一部分声明。我们在这里讨论属性只是为了探索弹性基础。
- en: The flex basis determines the size of a flex item’s element box, as set by `box-sizing`.
    By default, when a block-level element is not a flex item, the size is determined
    by the size of its parent, content, and box-model properties. When no size properties
    are explicitly declared or inherited, the size defaults to its individual content,
    border, and padding, which is 100% of the width of its parent for block-level
    elements.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性基础通过`box-sizing`设置弹性项元素框的大小。默认情况下，当块级元素不是弹性项时，大小由其父级、内容和框模型属性确定。当没有显式声明或继承尺寸属性时，默认大小为其独立内容、边框和填充，这是块级元素父级宽度的100%。
- en: The flex basis can be defined using the same length value types as the `width`
    and `height` properties—for example, `5vw`, `12%`, and `300px`.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性基础可以使用与`width`和`height`属性相同的长度值类型进行定义，例如`5vw`、`12%`和`300px`。
- en: The universal keyword `initial` resets the flex basis to the initial value of
    `auto`, so you might as well declare `auto`. In turn, `auto` evaluates to the
    `width` (or `height`), if declared. If the value of `width` (or `height`) is set
    to `auto`, the value of `flex-basis` is evaluated to `content`. This causes the
    flex item to be sized based on the content of the flex item, though the exact
    method for doing so is not made explicit in the specification.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 通用关键字`initial`将弹性基础重置为`auto`的初始值，因此您可能想要声明`auto`。反过来，如果`width`（或`height`）的值设置为`auto`，则`flex-basis`的值被评估为`content`。这会导致弹性项根据其内容的大小进行调整，尽管规范中没有明确说明具体方法。
- en: The content keywords
  id: totrans-554
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 内容关键字
- en: In addition to lengths and percentages, `flex-basis` supports the `min-content`,
    `max-content`, `fit-content`, and `content` keywords. We covered the first three
    in [Chapter 6](ch06.html#basic-visual-formatting), but `fit-content` deserves
    a revisit here, and `content` needs to be explored.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 除了长度和百分比外，`flex-basis`还支持`min-content`、`max-content`、`fit-content`和`content`关键字。我们在[第六章](ch06.html#basic-visual-formatting)中涵盖了前三者，但是在这里我们需要重新审视`fit-content`，并且需要探索`content`。
- en: 'When using `fit-content` as the value for `flex-basis`, the browser will do
    its best to balance all the flex items in a line so that they are similar in block
    size. Consider this code, which is illustrated in [Figure 11-50](#flex-basis-fit-sizing):'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`fit-content`作为`flex-basis`的值时，浏览器会尽力平衡一行中所有弹性项，使它们在块大小上相似。考虑以下代码，在[图 11-50](#flex-basis-fit-sizing)中有所说明：
- en: '[PRE45]'
  id: totrans-557
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '![](assets/css5_1150.png)'
  id: totrans-558
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1150.png)'
- en: Figure 11-50\. Fit-content flex-basis sizing
  id: totrans-559
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-50\. `fit-content` 弹性基础大小
- en: In the first flex line, the flex basis of the flex items is set to 25%, meaning
    each flex item starts out with 25% the width of the flex line as its sizing basis,
    and is flexed from there at the browser’s discretion. In the second flex line,
    the flex items are set to use `fit-content` for their flex basis. Notice that
    more content leads to wider flex items, and less to narrower items.
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个弹性线上，弹性项的弹性基础被设置为25%，这意味着每个弹性项从弹性线宽度的25%作为其尺寸基础开始，并根据浏览器的自由裁量进行弹性调整。在第二个弹性线上，弹性项被设置为使用`fit-content`作为它们的弹性基础。注意到更多的内容导致弹性项更宽，而内容较少导致更窄的项。
- en: 'Also notice that the heights (more properly, the block sizes) of the flex items
    are all the same, though this is not guaranteed: in certain situations, some of
    the flex items could be a bit taller than the others—say, by having one flex item’s
    content wrap to one more line than the others’. They should all be very close
    to the same, though.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，尽管不能保证，在某些情况下，一些弹性项目的高度（更正确地说是块大小）可能会不同：比如，其中一个弹性项目的内容换行比其他的多一行。它们应该几乎相同。
- en: 'This is a good illustration of one of the strengths of flexbox: you can give
    a general direction to the layout engine and have it do the rest of the work.
    Here, rather than having to figure out which widths should be assigned to which
    flex items in order to balance out their heights, you tell it `fit-content` and
    let it figure out the rest.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Flexbox的一个优点的良好示例：您可以向布局引擎提供一个总体方向，并让它完成其余工作。在这里，您不需要计算哪些宽度应该分配给哪些弹性项目以平衡它们的高度，只需告诉它`fit-content`，让它自行处理。
- en: 'Using the `content` keyword has results generally similar to `fit-content`,
    though some differences exist. A `content` basis is the size of the flex item’s
    content—that is, the length of the main-axis size of the longest line of content
    or widest (or tallest) media object. It’s the equivalent of declaring `flex-basis:
    auto; inline-size: auto;` on a flex item.'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '使用`content`关键字通常会产生与`fit-content`类似的结果，尽管存在一些差异。一个`content`基础是弹性项目内容的大小——即内容最长行或最宽（或最高）媒体对象的主轴尺寸长度。这相当于在弹性项目上声明`flex-basis:
    auto; inline-size: auto;`。'
- en: The value `content` has the effects shown in [Figure 11-51](#content_basis_width).
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 值`content`具有如图11-51所示的效果。
- en: '![css5 1151](assets/css5_1151.png)'
  id: totrans-565
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1151](assets/css5_1151.png)'
- en: Figure 11-51\. Sizing flex items on a `content` basis [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-content-basis.html)
  id: totrans-566
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-51. 基于`content`基础的弹性项目尺寸 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-content-basis.html)
- en: In the first and third examples, the width of the flex item is the size of the
    content; and the flex basis is that same size. In the first example, the flex
    items’ width and basis are approximately 132 pixels. The total width of the three
    flex items side by side is 396 pixels, with a few pixels of space between the
    items, all fitting easily into the parent container.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个和第三个示例中，弹性项目的宽度与内容大小相同；而弹性基础也是相同的尺寸。例如，在第一个示例中，弹性项目的宽度和基础约为132像素。三个并排的弹性项目的总宽度为396像素，项目之间有一些像素的间距，都轻松适应父容器。
- en: 'In the third example, we have set a null shrink factor (`0`): this means the
    flex items cannot shrink, so they won’t shrink or wrap to fit into the fixed-width
    flex container. Rather, they are the width of their nonwrapped text. That width
    is also the value of the flex basis. The three flex items’ widths, and thus their
    basis values, are approximately 309, 1,037 pixels, and 523 pixels, respectively.
    You can’t see the full width of the second flex item or the third flex item at
    all, but they’re in the [chapter files](https://meyerweb.github.io/csstdg5figs/11-flexbox).'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中，我们设置了一个空的收缩因子（`0`）：这意味着弹性项目不能收缩，因此它们不会收缩或换行以适应固定宽度的弹性容器。相反，它们的宽度与非换行文本的宽度相同。这个宽度也是弹性基础的值。三个弹性项目的宽度，因此其基础值分别约为309像素、1037像素和523像素。您完全看不到第二个和第三个弹性项目的全部宽度，但它们在[章节文件](https://meyerweb.github.io/csstdg5figs/11-flexbox)中。
- en: The second example contains the same content as the third example, but the flex
    items are defaulting to a shrink factor of 1, so the text in this example wraps
    because the flex items can shrink. Thus, while the width of the flex item is not
    the width of the content, the flex basis—the basis by which it will proportionally
    shrink—is the width of the items’ contents.
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例与第三个示例包含相同的内容，但弹性项目默认为收缩因子1，因此此示例中的文本换行。因此，虽然弹性项目的宽度不是内容的宽度，但弹性基础——按比例收缩的基础——是项目内容的宽度。
- en: 'The third example in [Figure 11-51](#content_basis_width) is also a good illustration
    of what would happen with the `max-content` keyword with `flex-shrink: 0`: the
    flex basis for each item will be the maximum size of its content. If flex shrinking
    is allowed, then the browser will start with the `max-content` for the basis of
    each item’s flexing, and shrink them down from there. The difference between the
    two is captured in the following code and illustrated in [Figure 11-52](#max_content_basis_width):'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-51](#content_basis_width) 中的第三个示例也很好地说明了在使用 `flex-shrink: 0` 时 `max-content`
    关键字会发生什么：每个项目的伸缩基础将是其内容的最大尺寸。如果允许伸缩，浏览器将从每个项目的 `max-content` 作为基础开始进行伸缩，并从那里开始缩小它们。以下代码捕捉了两者之间的差异，并在
    [图 11-52](#max_content_basis_width) 中有所展示：'
- en: '[PRE46]'
  id: totrans-571
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '![](assets/css5_1152.png)'
  id: totrans-572
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1152.png)'
- en: Figure 11-52\. Sizing flex items on a `max-content` basis, with and without
    shrinking
  id: totrans-573
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-52\. 根据 `max-content` 基础调整伸缩项的大小，有和没有收缩
- en: In the first example, where shrinking is not allowed, each flex item is as wide
    as its content can get without wrapping. This causes the flex items to overflow
    the container (because `flex-wrap` is not set to `wrap`). In the second example,
    where `flex-shrink` is set to `1`, the browser shrinks the flex items equally
    until they all fill out the flex container without overflowing it. Note that the
    second of the four items is a little taller than the others, because its shrinking
    happens to require wrapping the content to one more line than the other items.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，不允许收缩时，每个伸缩项的宽度都等于其内容的最大宽度而不换行。这导致伸缩项溢出容器（因为 `flex-wrap` 未设置为 `wrap`）。在第二个例子中，当
    `flex-shrink` 设置为 `1` 时，浏览器会等比例缩小每个伸缩项，直到它们都填满了伸缩容器而不溢出。请注意，四个伸缩项中的第二个略微比其他项更高，因为其缩小需要将内容换行至更多行。
- en: 'For a `min-content` flex basis, the reverse happens. Consider the following,
    illustrated in [Figure 11-53](#min_content_basis_width):'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `min-content` 伸缩基础，情况正好相反。请考虑下面的情况，在 [图 11-53](#min_content_basis_width)
    中有所展示：
- en: '[PRE47]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '![](assets/css5_1153.png)'
  id: totrans-577
  prefs: []
  type: TYPE_IMG
  zh: '![](assets/css5_1153.png)'
- en: Figure 11-53\. Sizing flex items on a `min-content` basis, with and without
    growing
  id: totrans-578
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-53\. 根据 `min-content` 基础调整伸缩项的大小，有和没有增长
- en: In the first example, flex items are as narrow as possible while still fitting
    their content. For elements containing text, this makes them very tall, given
    that the block axis is vertical. (Note that the full heights of the flex items
    in the first example have been clipped to keep the figure to a reasonable size.)
    In the second example, the items are allowed to grow, so they start from the `min-content`
    size and their widths are grown equally until they all fill out the flex container
    without overflowing it.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中，伸缩项尽可能窄以适应其内容。对于包含文本的元素，这使得它们非常高，因为块轴是垂直的。（请注意，第一个例子中伸缩项的全高度已被剪辑，以保持图像尺寸合理。）在第二个例子中，允许伸展伸缩项，因此它们从
    `min-content` 大小开始，并且宽度均匀增加，直到它们全部填满了伸缩容器而不溢出。
- en: In the browser used to create [Figure 11-53](#min_content_basis_width), the
    widths of the flex items in the first example added up to 361.1 pixels (rounded
    to the nearest tenth of a pixel), with 20 pixels of space between each flex item.
    This means from the left edge of the first item to the right edge of the last
    item is about 420.1 pixels. To arrive at the result in the second example, given
    that the width of the flex container is 1,200 pixels, the difference between the
    container width and content width is 1,200 – 420.1 = 778.9 pixels. This difference
    is divided by 4, yielding approximately 194.7 pixels, and the width of each of
    the four flex items is increased by that amount.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 在用于创建 [图 11-53](#min_content_basis_width) 的浏览器中，第一个例子中伸缩项的宽度总和约为 361.1 像素（四舍五入到最接近的十分之一像素），每个伸缩项之间有
    20 像素的间距。这意味着从第一项的左边缘到最后一项的右边缘大约是 420.1 像素。要得出第二个例子中的结果，考虑到伸缩容器的宽度为 1,200 像素，则容器宽度与内容宽度之间的差值为
    1,200 - 420.1 = 778.9 像素。将这一差值除以 4，得到约为 194.7 像素，每个四个伸缩项的宽度增加了该数量。
- en: Automatic flex basis
  id: totrans-581
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动伸缩基础
- en: When set to `auto`, whether explicitly or by default, `flex-basis` is the same
    as the main-axis size of the element, had the element not been turned into a flex
    item. For length values, `flex-basis` resolves to the `width` or `height` value,
    with the exception that when the value of `width` or `height` is `auto`, the flex-basis
    value falls back to `content`.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置为 `auto` 时，无论是显式设置还是默认设置，`flex-basis` 与元素的主轴尺寸相同，如果元素没有被转换为 flex 项目的话。对于长度值，`flex-basis`
    解析为 `width` 或 `height` 的值，但当 `width` 或 `height` 的值为 `auto` 时，`flex-basis` 的值回退到
    `content`。
- en: When the flex basis is `auto`, and all the flex items can fit within the parent
    flex container, the flex items will be their preflexed size. If the flex items
    don’t fit into their parent flex container, the flex items within that container
    will shrink proportionally based on their nonflexed main-axis sizes (unless the
    shrink factor is 0).
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 当 flex 基础为 `auto` 且所有 flex 项目都可以适应父 flex 容器时，flex 项目将保持它们的预设尺寸。如果 flex 项目不能适应其父
    flex 容器，则这些 flex 项目将根据其非弹性主轴尺寸（除非收缩因子为 0）在父 flex 容器内按比例收缩。
- en: 'When there are no other properties setting the main-axis size of the flex items
    (that is, there’s no `inline-size`, `min-inline-size`, `width`, or `min-width`
    set on these flex items), and `flex-basis: auto` or `flex: 0 1 auto` is set, the
    flex items will be only as wide as they need to be for the content to fit, as
    seen in the first example in [Figure 11-54](#when_flex_basis_set). In this case,
    they are the width of the text “flex-basis: auto,” which is approximately 110
    pixels. The flex items are their preflexed size, as if set to `display: inline-block`.
    In this example, they’re grouped at main-start because the `justify-content` property,
    the flex container’s `justify-content` defaults to `flex-start`.'
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: '当没有其他属性设置 flex 项目的主轴尺寸（即这些 flex 项目上没有设置 `inline-size`、`min-inline-size`、`width`
    或 `min-width`），并且设置了 `flex-basis: auto` 或 `flex: 0 1 auto`，flex 项目的宽度将仅仅足够容纳内容，如
    [图 11-54](#when_flex_basis_set) 中的第一个示例所示。在这种情况下，它们是文本“flex-basis: auto”的宽度，大约为
    110 像素。flex 项目保持它们的预设尺寸，就像设置为 `display: inline-block` 一样。在此示例中，它们位于主轴起点，因为 flex
    容器的 `justify-content` 属性默认为 `flex-start`。'
- en: In the second example in [Figure 11-54](#when_flex_basis_set), each flex item
    has a flex basis of `auto` and an explicitly declared width. The main-axis size
    of the elements, had they not been turned into flex items, would be 100, 150,
    and 200 pixels, respectively. And so they are here, since they fit into the flex
    container without any overflow along the main-axis.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中的 [图 11-54](#when_flex_basis_set)，每个 flex 项目都具有 `auto` 的 flex 基础和明确声明的宽度。如果它们没有被转换为
    flex 项目，那么元素的主轴尺寸分别为 100、150 和 200 像素。由于它们在 flex 容器中没有沿主轴溢出，因此它们的尺寸就是这些。
- en: '![css5 1154](assets/css5_1154.png)'
  id: totrans-586
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1154](assets/css5_1154.png)'
- en: Figure 11-54\. Auto flex basis and flex item widths [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-auto-basis-and-widths.html)
  id: totrans-587
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-54\. 自动 flex 基础和 flex 项目宽度 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-auto-basis-and-widths.html)
- en: In the third example in [Figure 11-54](#when_flex_basis_set), each of the flex
    items has a flex basis of `auto` and a very large explicitly declared width. The
    main-axis size of the elements, had they not been turned into flex items, would
    be 2,000, 3,000, and 4,000 pixels, respectively. Since they could not possibly
    fit into the flex container without overflowing along the main-axis, and their
    flex shrink factors have all defaulted to `1`, they shrink until they fit into
    the flex container. You can do the math to find out how big they are using the
    process outlined in [“Differing basis values”](#differing-bases); as a hint, the
    width of the third flex item should be reduced from 4,000 pixels to 240 pixels.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三个示例中的 [图 11-54](#when_flex_basis_set)，每个 flex 项目都具有 `auto` 的 flex 基础和非常大的明确声明宽度。如果它们没有被转换为
    flex 项目，那么元素的主轴尺寸分别为 2,000、3,000 和 4,000 像素。由于它们不可能在不沿主轴溢出的情况下适应 flex 容器，并且它们的
    flex 收缩因子都默认为 `1`，它们会收缩以适应 flex 容器。您可以通过 [“不同的基础值”](#differing-bases) 中概述的过程计算出它们的实际大小；提示：第三个
    flex 项目的宽度应从 4,000 像素减少到 240 像素。
- en: Default values
  id: totrans-589
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认值
- en: When neither `flex-basis` nor `flex` is set, the flex item’s main-axis size
    is the preflex size of the item, as the default value is `auto`.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `flex-basis` 和 `flex` 都未设置时，flex 项目的主轴尺寸为该项目的预设尺寸，因为默认值是 `auto`。
- en: 'In [Figure 11-55](#when_no_flex_properties_are_set): the flex basis values
    are defaulting to `auto`, the growth factor is defaulting to `0`, and the shrink
    factor of each item is defaulting to `1`. For each flex item, the flex basis is
    its individual `width` value. That means the flex basis values are being set to
    the values of the `width` properties: 100, 200, and 300 pixels in the first example,
    and 200, 400, and 200 pixels in the second example. As the combined widths of
    the flex items are 600 pixels and 800 pixels, respectively, both of which are
    greater than the main-axis size of the 540-pixel-wide containers, they are all
    shrinking proportionally to fit.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11-55](#when_no_flex_properties_are_set) 中：弹性基准值默认为 `auto`，增长因子默认为 `0`，每个项目的收缩因子默认为
    `1`。对于每个弹性项目，弹性基准值是其单独的 `width` 值。这意味着弹性基准值被设置为 `width` 属性的值：在第一个示例中分别为 100、200
    和 300 像素，在第二个示例中分别为 200、400 和 200 像素。由于弹性项目的总宽度分别为 600 像素和 800 像素，两者均大于 540 像素宽的主轴容器，它们都在按比例收缩以适应。
- en: '![When no flex properties are set, the flex item''s main-axis size will be
    the pre-flex size of the item](assets/css5_1155.png)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![当没有设置弹性属性时，弹性项目的主轴尺寸将是项目的预弹性尺寸](assets/css5_1155.png)'
- en: Figure 11-55\. Default sizing of flex items [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-default-sizing.html)
  id: totrans-593
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-55\. 弹性项目的默认大小 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-default-sizing.html)
- en: In the first example, we are trying to fit 600 pixels in 540 pixels, so each
    flex item will shrink by 10% to yield flex items that are 90, 180, and 270 pixels
    wide. In the second example, we are trying to fit 800 pixels into 540 pixels,
    so they all shrink 32.5%, making the flex items’ widths 135, 270, and 135 pixels.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个示例中，我们试图将 600 像素放入 540 像素中，因此每个弹性项目将以 10% 的比例收缩，从而得到宽度分别为 90、180 和 270 像素的弹性项目。在第二个示例中，我们试图将
    800 像素放入 540 像素中，因此它们都会收缩 32.5%，使得弹性项目的宽度为 135、270 和 135 像素。
- en: Length units
  id: totrans-595
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 长度单位
- en: In the previous examples, the `auto` flex basis values defaulted to the declared
    widths of the various flex items. CSS provides other options; for example, we
    can use the same length units for our flex-basis value as we do for `width` and
    `height`.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`auto` 弹性基准值默认为各种弹性项目的声明宽度。CSS 提供其他选项；例如，我们可以使用与 `width` 和 `height`
    相同的长度单位作为我们的弹性基准值。
- en: '![css5 1156](assets/css5_1156.png)'
  id: totrans-597
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1156](assets/css5_1156.png)'
- en: Figure 11-56\. Sizing flex items with length-unit flex basis values [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-width-vs-length.html)
  id: totrans-598
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-56\. 使用长度单位弹性基准值调整弹性项目大小 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-width-vs-length.html)
- en: 'When we have both `flex-basis` and `width` (or `height`, for vertical main-axes)
    values, the basis trumps the width (or height). Let’s add basis values to the
    first example from [Figure 11-55](#when_no_flex_properties_are_set). The flex
    items include the following CSS:'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们同时具有 `flex-basis` 和 `width`（或 `height`，用于垂直主轴）值时，基准值优先于宽度（或高度）。让我们在 [图 11-55](#when_no_flex_properties_are_set)
    的第一个示例中添加基准值。弹性项目包括以下 CSS：
- en: '[PRE48]'
  id: totrans-600
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The widths are overridden by the basis values. The flex items shrink down to
    270 pixels, 180 pixels, and 90 pixels, respectively. Had the container *not* had
    a constrained width, the flex items would have been 300 pixels, 200 pixels, and
    100 pixels, respectively.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 宽度被基准值覆盖。弹性项目收缩至分别为 270 像素、180 像素和 90 像素。如果容器没有限制宽度，弹性项目将分别为 300 像素、200 像素和
    100 像素。
- en: 'While the declared flex basis can override the main-axis size of flex items,
    the size can be affected by other properties, such as `min-width`, `min-height`,
    `max-width`, and `max-height`. These are not ignored. Thus, for example, an element
    might have `flex-basis: 100px` and `min-width: 500px`. The minimum width of `500px`
    will be respected, even though the flex basis is smaller.'
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: '虽然声明的弹性基准可以覆盖弹性项目的主轴尺寸，但其尺寸可能会受到其他属性的影响，例如 `min-width`、`min-height`、`max-width`
    和 `max-height`。这些属性不会被忽略。因此，例如，一个元素可能有 `flex-basis: 100px` 和 `min-width: 500px`。尽管弹性基准较小，但将尊重最小宽度为
    `500px`。'
- en: Percentage units
  id: totrans-603
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 百分比单位
- en: Percentage values for `flex-basis` are calculated relative to the size of the
    main dimension of the flex container.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比值对于 `flex-basis` 是相对于弹性容器主轴尺寸计算的。
- en: 'We’ve already seen the first example in [Figure 11-57](#percentage-val-flex-basis);
    it’s included here to recall that the width of the text “flex-basis: auto” in
    this case is approximately 110 pixels wide. In this case only, declaring `flex-basis:
    auto` looks the same as writing `flex-basis: 110px`:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '我们已经看到 [图 11-57](#percentage-val-flex-basis) 的第一个示例；这里包含它是为了回顾“flex-basis:
    auto”文本的宽度在此情况下约为 110 像素。在这种情况下，仅声明 `flex-basis: auto` 看起来与写 `flex-basis: 110px`
    相同：'
- en: '[PRE49]'
  id: totrans-606
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the second example in [Figure 11-57](#percentage-val-flex-basis), the first
    two flex items have a flex basis of `auto` with a default `width` of `auto`, which
    is as if their flex basis were set to `content`. As we’ve noted previously, the
    `flex-basis` of the first two items ends up being the equivalent of 110 pixels,
    as the content in this case happens to be 110 pixels wide. The last item has its
    `flex-basis` set to `100%`.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [图 11-57](#percentage-val-flex-basis) 的第二个示例中，前两个 flex 项目的 `flex-basis` 设置为
    `auto`，其默认 `width` 为 `auto`，即相当于它们的 `flex-basis` 被设置为 `content`。正如我们之前提到的，这两个项目的
    `flex-basis` 最终等同于 110 像素，因为在这种情况下内容恰好为 110 像素宽。最后一个项目的 `flex-basis` 设置为 `100%`。
- en: '![The percentage value for flex-basis is relative to the width of the flex
    container](assets/css5_1157.png)'
  id: totrans-608
  prefs: []
  type: TYPE_IMG
  zh: '![flex-basis 的百分比值是相对于 flex 容器的宽度而言](assets/css5_1157.png)'
- en: Figure 11-57\. Sizing flex items with percentage flex basis values [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-percentage.html)
  id: totrans-609
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-57\. 使用百分比 `flex-basis` 值调整 `flex` 项目大小 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-percentage.html)
- en: The percentage value is relative to the parent, which is 540 pixels. The third
    flex item, with a basis of `100%`, is not the only flex item within the nonwrapping
    flex container. Thus, it will not grow to be 100% of the width of the parent flex
    container *unless* its shrink factor is set with a null shrink factor, meaning
    it can’t shrink, or if it contains nonwrappable content that is as wide or wider
    than the parent container.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比值相对于父级元素，即 540 像素。第三个 `flex` 项目的 `basis` 设置为 `100%`，并非唯一位于非换行 `flex` 容器中的
    `flex` 项目。因此，它不会扩展为父级 `flex` 容器宽度的 `100%` *除非* 它的收缩因子设置为空收缩因子，表示它无法收缩，或者包含的不换行内容宽度等于或大于父容器宽度。
- en: Tip
  id: totrans-611
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Remember: when the flex basis is a percent value, the main-axis size is relative
    to the parent, which is the flex container.'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 记住：当 `flex` 基础值为百分比时，主轴大小是相对于父级元素即 `flex` 容器的。
- en: 'With our three flex basis values, if the content is indeed 110 pixels wide,
    and the container is 540 pixels wide (ignoring other box-model properties for
    simplicity’s sake), we have a total of 760 pixels to fit in a 540-pixel space.
    Thus we have 220 pixels of negative space to distribute proportionally. The shrink
    factor is as follows:'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的三个 `flex` 基础值，如果内容确实为 110 像素宽，容器宽度为 540 像素（简化起见，忽略其他盒模型属性），我们有 760 像素要放入
    540 像素的空间中。因此，我们需要按比例分配 220 像素的负空间。收缩因子如下：
- en: Shrink factor = 220 px ÷ 760 px = 28.95%
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收缩因子 = 220 px ÷ 760 px = 28.95%
- en: 'Each flex item will be shrunk by 28.95%, becoming 71.05% of the width it would
    have been, had it not been allowed to shrink. We can figure the final widths:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `flex` 项目将按 28.95% 收缩，变为原本宽度的 71.05%。我们可以计算最终的宽度：
- en: item1 = 110 px × 71.05% = 78.16 px
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 110 px × 71.05% = 78.16 px
- en: item2 = 110 px × 71.05% = 78.16 px
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item2 = 110 px × 71.05% = 78.16 px
- en: item3 = 540 px × 71.05% = 383.68 px
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 540 px × 71.05% = 383.68 px
- en: These numbers hold true as long as the flex items can be that small—that is,
    as long as none of the flex items contain media or nonbreaking text wider than
    78.16 pixels or 383.68 pixels. This is the widest these flex items will be as
    long as the content can wrap to be that width or narrower. We say “widest” because
    if one of the other two flex items can’t shrink to be as narrow as this value,
    they’ll both have to absorb some of that negative space.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 只要 `flex` 项目不包含比 78.16 像素或 383.68 像素更宽的媒体或不换行文本，这些数字就是准确的。这是这些 `flex` 项目能够收缩到的最宽程度，只要内容可以折叠到该宽度或更窄。我们说“最宽”，因为如果其他两个
    `flex` 项目无法收缩到这个值那么窄，它们将必须吸收一些负空间。
- en: 'In the third example in [Figure 11-57](#percentage-val-flex-basis), the `flex-basis:
    auto` item wraps over three lines. The CSS for this example is the equivalent
    of the following:'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '在 [图 11-57](#percentage-val-flex-basis) 的第三个示例中，`flex-basis: auto` 项目跨三行。这个示例的
    CSS 等同于以下内容：'
- en: '[PRE50]'
  id: totrans-621
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We declare the `flex-basis` of the three flex items to be `70%`, `auto`, and
    `80%`, respectively. Remembering that in our scenario `auto` is the width of the
    nonwrapping content, which in this case is approximately 110 pixels, and our flex
    container is 540 pixels, the basis values are equivalent to the following:'
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明三个 flex 项目的 `flex-basis` 分别为 `70%`、`auto` 和 `80%`。记住，在我们的情况下，`auto` 是非换行内容的宽度，本例中约为110像素，而我们的
    flex 容器是540像素，基础值等同于以下内容：
- en: item1 = 70% × 540 px = 378 px
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 70% × 540 px = 378 px
- en: 'item2 = widthOfText(“flex-basis: auto”) ≈ 110 px'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'item2 = 文本宽度（“flex-basis: auto”）≈ 110 px'
- en: item3 = 80% × 540 px = 432 px
  id: totrans-625
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 80% × 540 px = 432 px
- en: 'When we add the widths of these three flex items’ basis values, they have a
    total combined width of 920 pixels, which needs to fit into a flex container 540
    pixels wide. Thus we have 380 pixels of negative space to remove proportionally
    among the three flex items. To figure out the ratio, we divide the available width
    of our flex container by the sum of the widths of the flex items that they would
    have if they couldn’t shrink:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将这三个 flex 项目的基础值的宽度相加时，它们总共的宽度为920像素，需要适应一个540像素宽的 flex 容器。因此，我们有380像素的负空间需要在这三个
    flex 项目中按比例减少。为了找出比例，我们将我们的 flex 容器的可用宽度除以它们如果不能收缩时的 flex 项目宽度总和：
- en: Proportional width = 540 px ÷ 920 px = 0.587
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比例宽度 = 540 px ÷ 920 px = 0.587
- en: 'Because the shrink factors are all the same, this is fairly simple. Each item
    will be 58.7% of the width it would be if it had no flex-item siblings:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 因为收缩因子都是相同的，所以这相当简单。每个项目将是其没有 flex 项目兄弟时宽度的58.7%：
- en: item1 = 378 px × 58.7% = 221.8 px
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 378 px × 58.7% = 221.8 px
- en: item2 = 110 px × 58.7% = 64.6 px
  id: totrans-630
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item2 = 110 px × 58.7% = 64.6 px
- en: item3 = 432 px × 58.7% = 253.6 px
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 432 px × 58.7% = 253.6 px
- en: 'What happens when the container is a different width? Say, 1,000 pixels? The
    flex basis would be 700 pixels (70% × 1,000 pixels), 110 pixels, and 800 pixels
    (80% × 1,000 pixels), respectively, for a total of 1,610 pixels:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器宽度不同时会发生什么？比如，1,000像素？flex 基础将分别为700像素（70% × 1,000像素）、110像素和800像素（80% × 1,000像素），总共为1,610像素：
- en: Proportional width = 1,000 px ÷ 1,610 px = 0.6211
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 比例宽度 = 1,000 px ÷ 1,610 px = 0.6211
- en: item1 = 700 px × 62.11% = 434.8 px
  id: totrans-634
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item1 = 700 px × 62.11% = 434.8 px
- en: item2 = 110 px × 62.11% = 68.3 px
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item2 = 110 px × 62.11% = 68.3 px
- en: item3 = 800 px × 62.11% = 496.9 px
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: item3 = 800 px × 62.11% = 496.9 px
- en: Because with a basis of 70% and 80%, the combined basis values of the flex items
    will always be wider than 100%, no matter how wide we make the parent, all three
    items will always shrink.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 因为70%和80%的基础值的组合总是大于100%，无论父级容器有多宽，所有三个项目都会收缩。
- en: If the first flex item can’t shrink for some reason—whether because of unshrinkable
    content, or another bit of CSS setting its `flex-shrink` to `0`—it will be 70%
    of the width of the parent, 378 pixels in this case. The other two flex items
    must shrink proportionally to fit into the remaining 30%, or 162 pixels. In this
    case, we expect widths to be 378 pixels, 32.875 pixels, and 129.125 pixels. As
    the text “basis:” is wider than that—assume 42 pixels—we get 378 pixels, 42 pixels,
    and 120 pixels. [Figure 11-58](#flex-basis-rel-main-axis-size) shows the result.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 如果第一个 flex 项目由于某种原因无法收缩——无论是因为无法收缩的内容，还是其他CSS设置其 `flex-shrink` 为 `0`——它将是父级宽度的70%，在这种情况下是378像素。其余两个
    flex 项目必须按比例收缩以适应剩余的30%，即162像素。在这种情况下，我们预计宽度将为378像素、32.875像素和129.125像素。由于文本“basis:”比这更宽——假设42像素——我们得到378像素、42像素和120像素。[图11-58](#flex-basis-rel-main-axis-size)展示了结果。
- en: '![css5 1158](assets/css5_1158.png)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![css5 1158](assets/css5_1158.png)'
- en: Figure 11-58\. While the percentage value for `flex-basis` is relative to the
    width of the flex container, the main-axis size is impacted by its siblings [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-percentage-main-axis.html)
  id: totrans-640
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-58。虽然 `flex-basis` 的百分比值是相对于 flex 容器宽度的，但主轴大小受其兄弟项目的影响[![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-basis-percentage-main-axis.html)
- en: 'Testing this out on your device will likely have slightly different results,
    as the width of the text “flex-basis: auto” may not be the same for you, depending
    on the font that gets used to render the text. (We used Myriad Pro, with fallbacks
    to Helvetica and any generic sans-serif font.)'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: '在您的设备上测试此功能可能会有略微不同的结果，因为渲染文本的字体宽度“flex-basis: auto”可能不同，这取决于所使用的字体（我们使用了Myriad
    Pro，并回退到Helvetica和任何通用无衬线字体）。'
- en: Zero basis
  id: totrans-642
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零基础
- en: If neither the `flex-basis` property nor the `flex` shorthand is included at
    all, the flex basis defaults to `auto`. When the `flex` property is included,
    but the flex basis component of the shorthand is omitted from the shorthand, the
    basis defaults to `0`. While on the surface you might think the two values of
    `auto` and `0` are similar, the `0` value is actually very different and may not
    be what you expect.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 如果既未包括`flex-basis`属性也未包括`flex`简写，则`flex`基础值默认为`auto`。当包含`flex`属性但省略了简写中的flex基础组件时，基础默认为`0`。表面上看，你可能会认为`auto`和`0`两个值相似，但实际上`0`值非常不同，可能不符合你的预期。
- en: 'In the case of `flex-basis: auto`, the basis is the main size of the flex items’
    contents. If the basis of each of the flex items is `0`, the available space is
    the main-axis size of the entire flex container. In either case, the available
    space is distributed proportionally, based on the growth factors of each flex
    item.'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '在`flex-basis: auto`的情况下，基础是弹性项目内容的主尺寸。如果每个弹性项目的基础为`0`，则可用空间是整个弹性容器的主轴尺寸。在任一情况下，可用空间按每个弹性项目的增长因子比例分配。'
- en: With a basis of `0`, the size of the flex container is divided up and distributed
    proportionally to each flex item based on its growth factors—its default original
    main-axis size as defined by `height`, `width`, or `content` is not taken into
    account, though `min-width`, `max-width`, `min-height`, and `max-height` do impact
    the flexed size.
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 使用基础值`0`，弹性容器的大小按比例分配给每个弹性项目，根据其增长因子——默认的原始主轴尺寸定义为`height`、`width`或`content`不计算，尽管`min-width`、`max-width`、`min-height`和`max-height`会影响弹性尺寸。
- en: 'As shown in [Figure 11-59](#flex-basis-auto-vs-0), when the basis is `auto`,
    only the extra space is divided up proportionally and added to each flex item
    set to grow. Again, assuming the width of the text “flex: *X X* auto” is 110 pixels,
    in the first example we have 210 pixels to distribute among six growth factors,
    or 35 pixels per growth factor. The flex items are 180, 145, and 215 pixels wide,
    respectively.'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: '如图[11-59](#flex-basis-auto-vs-0)所示，当基础为`auto`时，只有额外的空间按比例分配并添加到每个设置为增长的弹性项目中。同样地，假设文本宽度为“flex:
    *X X* auto”的第一个示例中为110像素，则有210像素可在六个增长因子中分配，每个增长因子为35像素。弹性项目分别为180、145和215像素宽。'
- en: '![flex-basis auto versus 0](assets/css5_1159.png)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![flex-basis auto versus 0](assets/css5_1159.png)'
- en: Figure 11-59\. Flex growth in auto and zero flex basis values
  id: totrans-648
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图11-59。自动和零弹性基础值中的弹性增长
- en: In the second example, when the basis is 0, all 540 pixels of the width is distributable
    space. With 540 pixels of distributable space among six growth factors, each growth
    factor is worth 90 pixels. The flex items are 180, 90, and 270 pixels wide, respectively.
    While the middle flex item is 90 pixels wide, the content in this example is narrower
    than 110 pixels, so the flex item didn’t wrap.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，当基础为0时，宽度的全部540像素为可分配空间。在540像素的可分配空间中，每个增长因子值为90像素。弹性项目分别为180、90和270像素宽。虽然中间的弹性项目宽度为90像素，但本示例中的内容比110像素窄，因此弹性项目未换行。
- en: The flex Shorthand
  id: totrans-650
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 弹性简写
- en: 'Now that you have a fuller understanding of the properties that make up the
    `flex` shorthand, remember: *always use the `flex` shorthand.* It accepts the
    usual global property values, including `initial`, `auto`, `none`; and the use
    of an integer, usually `1`, meaning the flex item can grow.'
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经更充分地理解了组成`flex`简写的属性，请记住：*始终使用`flex`简写*。它接受通常的全局属性值，包括`initial`、`auto`、`none`；以及一个整数，通常为`1`，表示弹性项目可以增长。
- en: 'Four of the flex values provide the most commonly desired effects:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 弹性值的四个提供最常见的期望效果：
- en: '`flex: initial`'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex: initial`'
- en: 'Equivalent to `flex: 0 1 auto`. This sizes flex items based on the value of
    `inline-size` (which is equivalent to either `width` or `height`, depending on
    the direction of the inline axis), and allows shrinking but not growing.'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: '等同于`flex: 0 1 auto`。这基于`inline-size`值调整弹性项目的大小（等效于`width`或`height`，取决于内联轴的方向），允许收缩但不允许增长。'
- en: '`flex: auto`'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex: auto`'
- en: 'Equivalent to `flex: 1 1 auto`. This sizes flex items based on the value of
    `inline-size`, but makes them fully flexible, allowing both shrinking and growing.'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: '等同于`flex: 1 1 auto`。这基于`inline-size`值调整弹性项目的大小，使其完全灵活，允许收缩和增长。'
- en: '`flex: none`'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex: none`'
- en: 'Equivalent to `flex: 0 0 auto`. This sizes flex items based on the value of
    `inline-size`, but makes them completely inflexible: they can’t shrink or grow.'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: '等同于`flex: 0 0 auto`。这基于`inline-size`值调整弹性项目的大小，但使其完全不可伸缩：不能收缩或增长。'
- en: '`flex: <*number*>`'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex: <*number*>`'
- en: 'Equivalent to `flex: <*number*> 1 0`. This value sets the flex item’s growth
    factor to the <*`number`*> provided. It also sets both the shrink factor and flex
    basis to `0`. This means the value of `inline-size` acts as a minimum size, but
    the flex item will grow if there is room to do so.'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: '等同于`flex: <*number*> 1 0`。此值将flex项目的增长因子设置为提供的<*`number`*>。它还将收缩因子和flex基础设置为`0`。这意味着`inline-size`的值充当最小尺寸，但如果有空间的话，flex项目将增长。'
- en: Let’s consider each of these in turn.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们依次考虑每个问题。
- en: Flexing with initial
  id: totrans-662
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flexing with initial
- en: 'The global CSS keyword `initial` can be used on all properties to represent
    a property’s initial value (its specification default value). Thus, the following
    lines are equivalent:'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 全局CSS关键字`initial`可用于所有属性，表示属性的初始值（即规范的默认值）。因此，以下行是等效的：
- en: '[PRE51]'
  id: totrans-664
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Declaring `flex: initial` sets a null growth factor, a shrink factor of `1`,
    and the flex basis values to `auto`. In [Figure 11-60](#flex-shrink-flex-initial),
    we can see the effect of the `auto` flex basis values. In the first two examples,
    the basis of each flex item is `content`—with each flex item having the width
    of the single line of letters that makes up the content. However, in the last
    two examples, the flex basis values of all the items are equal at 50 pixels, since
    `width: 50px` has been applied to all the flex items. The `flex: initial` declaration
    sets the `flex-basis` to `auto`, which we previously saw is the value of the `width`
    (or `height`), if declared, or `content` if not declared.'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: '声明`flex: initial`会将增长因子设置为空值，收缩因子设置为`1`，并将flex基础值设置为`auto`。在[图 11-60](#flex-shrink-flex-initial)中，我们可以看到`auto`
    flex基础值的效果。在前两个示例中，每个flex项目的基础是`content`——每个flex项目的宽度都是组成内容的单行字母的宽度。然而，在最后两个示例中，所有项目的flex基础值都相等，为50像素，因为所有flex项目都应用了`width:
    50px`。`flex: initial`声明将`flex-basis`设置为`auto`，正如我们之前看到的，这是`width`（或`height`）的值（如果声明），或者如果没有声明则是`content`的值。'
- en: In the first and third of these examples, we see that when the flex container
    is too small to fit all the flex items at their default main-axis size, the flex
    items shrink so that all fit within the parent flex container. In these examples,
    the combined flex basis values of all the flex items is greater than the main-axis
    size of the flex container. In the first example, the width of each flex item
    varies based on the width of each item’s content and its ability to shrink. They
    all shrink proportionally based on their shrink factor, but not narrower than
    their widest content. In the third example, with each flex item’s flex-basis being
    50 pixels (because of the value of `width`), all the items shrink equally.
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例的第一和第三个中，我们看到当flex容器太小而无法容纳所有flex项目以其默认的主轴尺寸时，flex项目会收缩，以便全部适应父flex容器。在这些示例中，所有flex项目的组合flex基础值大于flex容器的主轴尺寸。在第一个示例中，每个flex项目的宽度根据其内容的宽度和其收缩能力而异。它们根据其收缩因子成比例地收缩，但不会比其最宽的内容更窄。在第三个示例中，由于`width`的值，每个flex项目的flex基础为50像素，因此所有项目均等地收缩。
- en: '![With containers of different main sizes, the flex items shrink but won''t
    grow when flex: initial is set on the flex items](assets/css5_1160.png)'
  id: totrans-667
  prefs: []
  type: TYPE_IMG
  zh: '![对于具有不同主尺寸的容器，设置了`flex: initial`的flex项目会收缩但不会增长](assets/css5_1160.png)'
- en: 'Figure 11-60\. Flex items shrink but won’t grow when `flex: initial` is set
    [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-shrink-dont-grow.html)'
  id: totrans-668
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图11-60\. 当设置`flex: initial`时，flex项目会收缩但不会增长 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-shrink-dont-grow.html)'
- en: Flex items, by default, are grouped at main-start, as `flex-start` is the default
    value for the `justify-content` property. This is noticeable only when the combined
    main-axis sizes of the flex items in a flex line are smaller than the main-axis
    size of the flex container, and none of the flex items are able to grow.
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，flex项目被分组到主轴的起始端，因为`flex-start`是`justify-content`属性的默认值。只有当flex行中所有flex项目的组合主轴尺寸小于flex容器的主轴尺寸，并且没有flex项目能够增长时，这一点才会显现出来。
- en: Flexing with auto
  id: totrans-670
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Flexing with auto
- en: 'The `flex: auto` option is similar to `flex: initial`, but makes the flex items
    flexible in both directions: they’ll shrink if there isn’t enough room to fit
    all the items within the container, and they’ll grow to take up all the extra
    space within the container if there is distributable space. The flex items absorb
    any free space along the main-axis. The following two statements are equivalent:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: '`flex: auto`选项类似于`flex: initial`，但在两个方向上使 flex 项都灵活：如果没有足够的空间容纳所有项，则它们会收缩，并且如果有可分配的空间，则会增长以占据容器内的所有额外空间。flex
    项吸收沿主轴的任何自由空间。以下两个语句是等效的：'
- en: '[PRE52]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[Figure 11-61](#flex-auto-grow-shrink) shows a variety of scenarios using `auto`
    flexing.'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-61](#flex-auto-grow-shrink)展示了使用`auto`进行各种场景的灵活性。'
- en: '![With flex: auto set on the flex items, the flex items can grow and shrink
    ](assets/css5_1161.png)'
  id: totrans-674
  prefs: []
  type: TYPE_IMG
  zh: '![设置了`flex: auto`后，flex 项可以增长和收缩](assets/css5_1161.png)'
- en: 'Figure 11-61\. Flex items can grow and shrink when `flex: auto` is set [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-shrink-and-grow.html)'
  id: totrans-675
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图 11-61。当设置了`flex: auto`时，flex 项可以增长和收缩 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-shrink-and-grow.html)'
- en: 'The first and third examples of [Figure 11-61](#flex-auto-grow-shrink) are
    identical to the examples in [Figure 11-60](#flex-shrink-flex-initial), as the
    shrinking and basis values are the same. However, the second and fourth examples
    are different. This is because when `flex: auto` is set, the growth factor is
    `1`, and the flex items therefore can grow to incorporate all the extra available
    space.'
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-61](#flex-auto-grow-shrink)的第一个和第三个示例与[图 11-60](#flex-shrink-flex-initial)中的示例相同，因为它们的收缩和基础值是一样的。然而，第二个和第四个示例是不同的。这是因为当设置了`flex:
    auto`时，增长因子为`1`，因此 flex 项可以扩展以包含所有额外的可用空间。'
- en: Preventing flexing with none
  id: totrans-677
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`none`防止灵活性
- en: 'Any `flex: none` flex items are inflexible: they can neither shrink nor grow.
    The following two lines of CSS are equivalent:'
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: '任何`flex: none`的 flex 项都是不灵活的：它们既不能收缩也不能扩展。以下两行 CSS 是等价的：'
- en: '[PRE53]'
  id: totrans-679
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[Figure 11-62](#flex-none-no-grow-shrink) shows the effects of `none`.'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11-62展示了`none`的效果。
- en: '![With flex: none, flex items will neither grow nor shrink](assets/css5_1162.png)'
  id: totrans-681
  prefs: []
  type: TYPE_IMG
  zh: '![设置了`flex: none`后，flex 项既不会增长也不会收缩](assets/css5_1162.png)'
- en: 'Figure 11-62\. With `flex: none`, flex items will neither grow nor shrink [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-dont-grow-nor-shrink.html)'
  id: totrans-682
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图 11-62。使用`flex: none`，flex 项既不会增长也不会收缩 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-items-dont-grow-nor-shrink.html)'
- en: 'As demonstrated in the first and third examples of [Figure 11-62](#flex-none-no-grow-shrink),
    if there isn’t enough space, the flex items overflow the flex container. This
    is different from `flex: initial` and `flex: auto`, which both set a positive
    shrink factor.'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '如图 11-62的第一个和第三个示例所示，如果空间不足，flex 项将溢出 flex 容器。这与`flex: initial`和`flex: auto`不同，它们都设置了一个正的收缩因子。'
- en: The basis resolves to `auto`, meaning each flex item’s main-axis size is determined
    by the main-axis size of the element had it not been turned into a flex item.
    The flex-basis resolves to the `width` or `height` value of the element. If that
    value is `auto`, the basis becomes the main-axis size of the content. In the first
    two examples, the basis—and the width, since there is no growing or shrinking—is
    the width of the content. In the third and fourth examples, the width and basis
    are all 50 pixels, because that’s the value of the `width` property applied to
    them.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 基础解析为`auto`，这意味着每个 flex 项的主轴尺寸由原本的元素主轴尺寸决定，假如它没有被转换为 flex 项。flex 基础解析为元素的`width`或`height`值。如果该值为`auto`，则基础值变为内容的主轴尺寸。在前两个示例中，基础值——以及宽度，因为没有增长或收缩——是内容的宽度。在第三和第四个示例中，宽度和基础值都是
    50 像素，因为这是应用于它们的`width`属性的值。
- en: Numeric flexing
  id: totrans-685
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数值灵活性
- en: 'When the value of the `flex` property is a single, positive, numeric value,
    that value will be used for the growth factor, while the shrink factor will default
    to `1` and the basis will default to `0`. The following two CSS declarations are
    equivalent:'
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 当`flex`属性的值是单个的正数数值时，该值将用于增长因子，而收缩因子默认为`1`，基础值默认为`0`。以下两个 CSS 声明是等效的：
- en: '[PRE54]'
  id: totrans-687
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'This makes the flex item on which it is set flexible: it can grow. The shrink
    factor is actually moot: the flex basis is set to `0`, so the flex item can grow
    only from that basis.'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得设置了它的 flex 项变得灵活：它可以增长。收缩因子实际上无关紧要：flex 基础被设置为`0`，因此 flex 项只能从该基础开始增长。
- en: In the first two examples in [Figure 11-63](#flex-n-grow-shrink), all the flex
    items have a flex growth factor of `3`. The flex basis is `0`, so they don’t “shrink”;
    they just grow equally from 0 pixels wide until the sum of their main-axis sizes
    to fill the container along the main-axis. With all the flex items having a basis
    of `0`, 100% of the main dimension is distributable space. The main-axis size
    of the flex items is wider in this second example because the wider flex container
    has more distributable space.
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 11-63](#flex-n-grow-shrink)的前两个示例中，所有伸缩项的伸缩增长因子均为`3`。伸缩基础为`0`，因此它们不会“收缩”；它们只是从0像素宽度开始等比例增长，直到它们的主轴尺寸之和填充容器沿主轴。所有伸缩项的基础为`0`时，主尺寸的100%是可分配空间。第二个示例中伸缩项的主轴尺寸较宽，因为较宽的伸缩容器具有更多可分配空间。
- en: '![With flex: n, you''re declaring the flex items growth factor while setting
    the flex basis to zero](assets/css5_1163.png)'
  id: totrans-690
  prefs: []
  type: TYPE_IMG
  zh: '![使用flex: n时，您声明了伸缩项的增长因子，同时将伸缩基础设置为零](assets/css5_1163.png)'
- en: Figure 11-63\. Flexing using a single numeric value [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-using-single-numeric-value.html)
  id: totrans-691
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-63\. 使用单个数值进行伸缩 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/flex-using-single-numeric-value.html)
- en: Any numeric value that is greater than 0, even 0.1, means the flex item can
    grow. If there is available space to grow and only one flex item has a positive
    growth factor, that item will take up all the available space. If multiple flex
    items can grow, the available extra space will be distributed proportionally to
    each flex item based on its growth factor.
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大于0的数值，甚至是0.1，表示伸缩项可以增长。如果有可用空间进行增长，并且只有一个伸缩项具有正的增长因子，那么该项将占据所有可用空间。如果多个伸缩项可以增长，则可用的额外空间将根据其增长因子按比例分配给每个伸缩项。
- en: 'The last three examples of [Figure 11-63](#flex-n-grow-shrink) declare six
    flex items with `flex: 0`, `flex: 1`, `flex: 2`, `flex: 3`, `flex: 4`, and `flex:
    5`, respectively. These are the growth factors for the flex items, with each having
    a shrink factor of `1` and a flex basis of `0`. The main-axis size of each is
    proportional to the specified flex growth factor. You might assume that the `flex:
    0` item with the text “flex: 0” in the third example will be 0 pixels wide, as
    in the fourth example—but, by default, flex items won’t shrink below the length
    of the longest word or fixed-size element.'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 11-63](#flex-n-grow-shrink)的最后三个示例分别声明了六个伸缩项，其值分别为`flex: 0`、`flex: 1`、`flex:
    2`、`flex: 3`、`flex: 4`和`flex: 5`。这些是伸缩项的增长因子，每个都具有收缩因子为`1`和基础为`0`。每个的主轴尺寸与指定的伸缩增长因子成比例。你可能会假设在第三个示例中显示文本“flex:
    0”的`flex: 0`项将为0像素宽，就像第四个示例中一样——但默认情况下，伸缩项不会收缩到比最长单词或固定尺寸元素的长度更短。'
- en: Note
  id: totrans-694
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'We added a bit of padding, margins, and borders to the figures to make the
    visuals more pleasing. For this reason, the leftmost flex item, with `flex: 0`
    declared, is visible: it has a 1-pixel border making it visible, even though it’s
    0 pixels wide.'
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: '我们向这些图形添加了一些填充、边距和边框，以使视觉效果更加愉悦。因此，最左边的具有声明`flex: 0`的伸缩项是可见的：它有1像素的边框，使其可见，即使宽度为0像素。'
- en: The order Property
  id: totrans-696
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: order 属性
- en: Flex items are, by default, displayed and laid out in the same order as they
    appear in the source code. The order of flex items and flex lines can be reversed
    with `flex-direction`, but sometimes you want a rearrangment that’s a little more
    complicated. The `order` property can be used to change the ordering of individual
    flex items.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 伸缩项默认按照它们在源代码中出现的顺序显示和布局。伸缩项和伸缩行的顺序可以通过`flex-direction`进行反转，但有时你可能需要一个更复杂的重新排列。`order`属性可用于更改单个伸缩项的顺序。
- en: By default, all flex items are assigned the order of `0`, with the flex items
    all assigned to the same ordinal group and displayed in the same order as their
    source order, along the direction of the main-axis. (This has been the case for
    all the examples throughout this chapter.)
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有伸缩项的`order`属性均为`0`，所有伸缩项都分配到相同的序号组，并按照它们的源顺序沿主轴方向显示。（这是本章节中所有示例的情况。）
- en: To change the visual order of a flex item, set the `order` property value to
    a nonzero integer. Setting the `order` property on elements that are not children
    of a flex container has no effect on such elements.
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改伸缩项的视觉顺序，请将`order`属性值设置为非零整数。在不是伸缩容器子元素的元素上设置`order`属性将不会对这些元素产生影响。
- en: Warning
  id: totrans-700
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'Changing the visual rendering order of flex items creates a disconnect between
    the source order of elements and their visual presentation. This can, in the words
    of the Mozilla Developer Network’s article on `order`, “adversely affect users
    experiencing low vision navigating with the aid of assistive technology such as
    a screen reader.” It could also create problems for users who navigate by keyboard
    and use a zoomed-in or otherwise magnified view of pages. In other words: be very
    careful with `order`, and use it *only* in production after much accessibility
    testing.'
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 改变伸缩项目的视觉渲染顺序会导致元素的源顺序和视觉呈现之间存在差异。如 Mozilla 开发者网络关于 `order` 的文章所述，“对于低视力用户通过屏幕阅读器等辅助技术进行导航可能产生不利影响。”
    对于通过键盘导航并使用放大或其他方式放大页面的用户也可能会造成问题。换句话说：非常小心使用 `order`，并仅在经过充分的可访问性测试后才在生产环境中使用。
- en: The value of the `order` property specifies an *ordinal group* to which the
    flex item belongs. Any flex items with a negative value will appear to come before
    those defaulting to `0` when drawn to the page, and all the flex items with a
    positive value will appear to come after those defaulting to `0`. While visually
    altered, the source order remains the same. Screen readers and tabbing order remain
    as defined by the source order of the HTML.
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '`order` 属性的值指定了伸缩项目所属的*序数组*。任何具有负值的伸缩项目在绘制到页面时将会出现在默认为 `0` 的项目之前，并且所有具有正值的伸缩项目将会出现在默认为
    `0` 的项目之后。虽然视觉上有所改变，但源顺序保持不变。屏幕阅读器和制表顺序保持HTML源顺序定义的方式。'
- en: 'For example, if you have a group of 12 items, and you want the seventh to come
    first and the sixth to be last, you would declare the following:'
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您有一组 12 个项目，并且希望第七个项目排在第一位，第六个项目排在最后，您可以声明如下：
- en: '[PRE55]'
  id: totrans-704
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'In this scenario, we are explicitly setting the order for the sixth and seventh
    list items, while the other list items are defaulting to `order: 0`. [Figure 11-64](#setting-order-to-any)
    shows the result.'
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: '在这种情况下，我们明确为第六和第七个列表项设置了顺序，而其他列表项默认为 `order: 0`。[图 11-64](#setting-order-to-any)
    展示了结果。'
- en: '![Setting order to any value other than 0 will reorder that flex item](assets/css5_1164.png)'
  id: totrans-706
  prefs: []
  type: TYPE_IMG
  zh: '![将 `order` 设置为非 `0` 值将重新排序该伸缩项目](assets/css5_1164.png)'
- en: Figure 11-64\. Reordering flex items with the `order` property [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/order01.html)
  id: totrans-707
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-64\. 使用 `order` 属性重新排序伸缩项目 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/order01.html)
- en: The seventh flex item is the first to be laid out, because of the negative value
    of the `order` property, which is less than the default `0`, and is also the lowest
    value of any of its sibling flex items. The sixth flex item is the only item with
    a value greater than 0, and therefore has the highest-order value out of all of
    its siblings. This is why it’s laid out after all the other flex items. All the
    other items, all having the default `order` of `0`, are drawn between those first
    and last items, in the same order as their source order, since they are all members
    of the same ordinal group (`0`).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 第七个伸缩项目首先布局，因为 `order` 属性的负值小于默认的 `0`，也是其所有同级伸缩项目中最低的值。第六个伸缩项目是唯一具有大于 `0` 值的项目，因此是其所有同级项目中最高的顺序值。这就是为什么它在所有其他伸缩项目之后布局的原因。所有其他项目，由于默认为
    `0` 的 `order`，都在第一个和最后一个项目之间按其源顺序绘制。
- en: 'The flex container lays out its content in order-modified document order, starting
    from the lowest-numbered ordinal group and going up. When multiple flex items
    have the same value for the `order` property, the items share an ordinal group.
    The items in each ordinal group will appear in source order, with the group appearing
    in numeric order, from lowest to highest. Consider the following:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 伸缩容器按照修改后的文档顺序布局其内容，从序数组编号最低的开始向上。当多个伸缩项目具有相同的 `order` 值时，它们共享一个序数组。每个序数组中的项目将按源顺序显示，序数组按数字顺序从低到高显示。考虑以下情况：
- en: '[PRE56]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: By setting the same `order` value to more than one flex item, the items will
    appear by ordinal group, and by source order within each individual ordinal group.
    [Figure 11-65](#flex-items-appear-ordinal) shows the result.
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为多个伸缩项目设置相同的 `order` 值，这些项目将按序数组和每个单独序数组内的源顺序显示。[图 11-65](#flex-items-appear-ordinal)
    展示了结果。
- en: '![Flex items appear in order of ordinal groups, by source order within their
    group](assets/css5_1165.png)'
  id: totrans-712
  prefs: []
  type: TYPE_IMG
  zh: '![伸缩项目按序数组的顺序以源顺序显示](assets/css5_1165.png)'
- en: Figure 11-65\. Flex items appear in order of ordinal groups, by source order
    within their group [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/order02.html)
  id: totrans-713
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-65\. 弹性项按顺序组出现，按组内源顺序排列 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/order02.html)
- en: 'Here’s what happened:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生了什么：
- en: Items 2, 5, 8, and 11 were selected to share ordinal group `3`, and get a 20%
    opaque background.
  id: totrans-715
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项2，5，8和11被选中以共享顺序组`3`，并获得20%的不透明背景。
- en: Items 1, 4, 7, and 10 were selected to share ordinal group `-1`, and get a 40%
    opaque background.
  id: totrans-716
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项1，4，7和10被选中以共享顺序组`-1`，并获得40%的不透明背景。
- en: Items 3, 6, 9, and 12 were not selected at all. They default to the ordinal
    group `0`.
  id: totrans-717
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项3，6，9和12根本未被选择。它们默认属于顺序组`0`。
- en: The three ordinal groups, then, are `-1`, `0`, and `3`. The groups are arranged
    in that order. Within each group, the items are arranged by source order.
  id: totrans-718
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，三个顺序组分别是`-1`，`0`和`3`。这些组按照这个顺序排列。在每个组内部，项目按照源顺序排列。
- en: 'This reordering is purely visual. Screen readers *should* read the document
    as it appears in the source code, though they may not. As a visual change, ordering
    flex items impacts the painting order of the page: the painting order of the flex
    items is the order in which they appear, as if they were reordered in the source
    document, even though they aren’t.'
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 此重新排序纯粹是视觉效果。屏幕阅读器应该按照源代码中的顺序读取文档，尽管可能不会。作为视觉变化，弹性项的排序影响页面的绘制顺序：弹性项的绘制顺序是它们出现的顺序，就好像它们在源文档中重新排序了一样，尽管实际上并没有。
- en: Changing the layout with the `order` property has no effect on the tab order
    of the page. If the numbers in [Figure 11-65](#flex-items-appear-ordinal) were
    links, tabbing through the links would go through the links in the order of the
    source code, *not* in the order of the layout.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`order`属性更改布局对页面的选项卡顺序没有影响。如果[图 11-65](#flex-items-appear-ordinal)中的数字是链接，通过链接的选项卡顺序将按照源代码顺序，*而不是*按照布局顺序进行。
- en: Tabbed Navigation Revisited
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视选项卡导航
- en: 'Adding to our tabbed navigation bar example in [Figure 11-2](#simple_tabbed_navigation),
    we can make the currently active tab appear first, as [Figure 11-66](#changing-order-tab)
    shows:'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的选项卡导航栏示例中（见[图 11-2](#simple_tabbed_navigation)），我们可以使当前活动选项卡首先显示，如[图 11-66](#changing-order-tab)所示：
- en: '[PRE57]'
  id: totrans-723
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![Changing the order will change the visual order, but not the tab order](assets/css5_1166.png)'
  id: totrans-724
  prefs: []
  type: TYPE_IMG
  zh: '![改变顺序将改变视觉顺序，但不会改变选项卡顺序](assets/css5_1166.png)'
- en: Figure 11-66\. Changing the order will change the visual order, but not the
    tab order [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/changing-order-changes-visual-order.html)
  id: totrans-725
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 11-66\. 改变顺序将改变视觉顺序，但不会改变选项卡顺序 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/11-flexbox/changing-order-changes-visual-order.html)
- en: The currently active tab has the `.active` class added, the `href` attribute
    removed, and the `order` set to `-1`, which is less than the default `0` of the
    other sibling flex items, meaning it appears first.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 当前活动选项卡已添加`.active`类，并移除了`href`属性，并将`order`设置为`-1`，低于其他兄弟弹性项的默认`0`，因此它会首先显示。
- en: Why did we remove the `href` attribute? As the tab is the currently active document,
    there is no reason for the document to link to itself. But, more importantly,
    if it was an active link instead of a placeholder link, and the user was using
    the keyboard to tab through the navigation, the order of appearance is Blog, Home,
    About, Careers, and Contact Us, with the Blog appearing first; but the tab order
    would have been Home, About, Blog, Careers, and Contact Us, following the source
    order rather than the visual order, which can be confusing.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么要移除`href`属性？因为选项卡是当前活动文档，没有理由文档要链接到自身。但更重要的是，如果它是一个活动链接而不是占位符链接，并且用户正在使用键盘通过导航进行选项卡，出现顺序是博客，主页，关于我们，职业，联系我们，其中博客首先出现；但选项卡顺序将是主页，关于我们，博客，职业，联系我们，遵循源顺序而不是视觉顺序，这可能会令人困惑。
- en: 'The `order` property can be used to enable marking up the main content area
    before the side columns for mobile devices and those using screen readers and
    other assistive technology, while creating the appearance of the common three-column
    layout: a center main content area, with site navigation on the left and a sidebar
    on the right, as shown way back in [Figure 11-48](#set_diff_values).'
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: '`order`属性可用于在移动设备和使用屏幕阅读器及其他辅助技术的用户面前将主要内容区域标记为首列，同时创建常见的三列布局外观：中心主内容区域，左侧站点导航和右侧侧边栏，如[图 11-48](#set_diff_values)所示。'
- en: 'While you can put your footer before your header in your markup, and use `order`
    to reorder the page, this is an inappropriate use of the property. The `order`
    property should be used only for visual reordering of content. Your underlying
    markup should always reflect the logical order of your content. Consider these
    two markup orders for the same content, shown here side by side to make comparing
    them easier:'
  id: totrans-729
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以在标记中将页脚放在页眉之前，并使用 `order` 重新排列页面，但这是属性的不当使用。`order` 属性应仅用于内容的视觉重新排序。你的底层标记应始终反映内容的逻辑顺序。考虑这两种相同内容的标记顺序，这里并排显示以便比较：
- en: '[PRE58]'
  id: totrans-730
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: We’ve been marking up websites in the order we want them to appear, as shown
    on the right in the code example, which is the same code as in our three-column
    layout example ([Figure 11-48](#set_diff_values)).
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直按照想要它们出现的顺序标记网站，如代码示例中右侧所示，这与我们的三列布局示例中的代码相同（[图 11-48](#set_diff_values)）。
- en: 'It really would make more sense if we marked up the page as shown on the left,
    with the `<article>` content, which is the main content, first in the source order:
    this puts the article first for screen readers, search engines, and even mobile
    devices, but in the middle for our sighted users on larger screens:'
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照左侧显示的方式标记页面，将 `<article>` 内容（即主内容）放在源代码顺序的第一位，这对于屏幕阅读器、搜索引擎甚至大屏幕上的用户来说更合理，但对于我们的视力用户来说，在较大的屏幕上却在中间位置：
- en: '[PRE59]'
  id: totrans-733
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'By using the `order: -1` declaration, we are able to make the `<nav>` appear
    first, as it is the lone flex item in the ordinal group of `-1`. The `<article>`
    and `<aside>`, with no `order` explicitly declared, default to `order: 0`.'
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: '通过使用 `order: -1` 属性声明，我们能够使 `<nav>` 出现在首位，因为它是 `-1` 顺序组中的唯一 flex 项目。`<article>`
    和 `<aside>` 没有显式声明 `order`，默认为 `order: 0`。'
- en: Remember, when more than one flex item is in the same ordinal group, the members
    of that group are displayed in source order in the direction of main-start to
    main-end, so the `article` is displayed before the `aside`.
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，当一个顺序组中有多个 flex 项目时，这些项目按照主轴起点到主轴终点的顺序显示，所以 `article` 在 `aside` 前面显示。
- en: 'Some developers, when changing the order of at least one flex item, like to
    give all flex items an `order` value for better markup readability. We could have
    also written this:'
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 一些开发人员，在至少一个 flex 项目的顺序变更时，喜欢为所有 flex 项目赋予 `order` 值以提高标记的可读性。我们也可以这样写：
- en: '[PRE60]'
  id: totrans-737
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In previous years, before browsers supported flex, all this could have been
    done with floats: we would have set `float: right` on the `<nav>`. While doable,
    flex layout makes this sort of layout much simpler, especially if we want all
    three columns—the `<aside>`, `<nav>`, and `<article>`—to be of equal heights.'
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: '在之前的几年里，在浏览器支持 flex 布局之前，这一切都可以通过浮动（floats）来实现：我们会在 `<nav>` 上设置 `float: right`。虽然可行，但是使用
    flex 布局可以使这种布局变得更加简单，特别是如果我们希望三个列元素——`<aside>`、`<nav>` 和 `<article>`——的高度相等。'
- en: Summary
  id: totrans-739
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: With flexible box layout, you can lay out sibling elements in ways that are
    responsive to many layout contexts and writing modes, with a variety of options
    for arranging those elements and aligning them to one another. It makes the task
    of vertically centering elements within their parent elements almost trivially
    easy, something that was very difficult in the years before flexbox. It also serves
    as a powerfully useful bridge between normal-flow and grid layout, which is the
    subject of the next chapter.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 使用弹性盒布局，你可以根据多种布局上下文和书写模式响应地布局同级元素，提供了多种选项来安排这些元素并使它们彼此对齐。它使得在父元素内垂直居中元素的任务变得几乎轻而易举，这在
    flexbox 出现之前是非常困难的。它还作为普通流和网格布局之间强大而有用的桥梁，是下一章节的主题。
