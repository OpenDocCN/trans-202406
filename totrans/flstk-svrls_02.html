<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Getting Started with AWS Amplify"><div class="chapter" id="ch2">
<h1><span class="label">Chapter 2. </span>Getting Started with AWS Amplify</h1>


<p><a data-type="indexterm" data-primary="data/API layer" id="idm45364349332184"/>At the core of most applications is the data/API layer. This layer could look like many things. In the serverless world, this usually will be composed of a combination of API endpoints and serverless functions. These serverless functions could be doing some logic and returning data, interacting with a database of some kind, or even interacting with another API endpoint.</p>

<p><a data-type="indexterm" data-primary="creating" data-secondary="APIs" id="idm45364349330712"/><a data-type="indexterm" data-primary="APIs" data-secondary="creating" id="idm45364349360152"/>There are two main ways of creating APIs with Amplify:</p>

<ul>
<li>
<p>A combination of Amazon API Gateway and a Lambda function</p>
</li>
<li>
<p>A GraphQL API connected to some type of data source (database, Lambda function, or HTTP endpoint)</p>
</li>
</ul>

<p><a data-type="indexterm" data-primary="API Gateway" data-secondary="about" id="idm45364349356536"/><a data-type="indexterm" data-primary="Lambda" data-secondary="about" id="idm45364349355560"/>API Gateway is an AWS service that allows you to create API endpoints and route them to different services, often via a Lambda function. When you make an API call, it will route the request through API Gateway, invoke the function, and return the response. Using the Amplify CLI, you can create both the API Gateway endpoint as well as the Lambda function; the CLI will automatically configure the API to be able to invoke the Lambda function via an HTTP request.</p>

<p><a data-type="indexterm" data-primary="API class" id="idm45364349353752"/>Once your API is created, you then need a way to interact with it. Using the Amplify client you will be able to send requests to the endpoint using the Amplify <code>API</code> class. The <code>API</code> class allows you to interact with both GraphQL APIs as well as API Gateway endpoints, as shown in <a data-type="xref" href="#fig2a">Figure 2-1</a>.</p>

<p>In this chapter, you’ll create your first full stack serverless app that will interact with a serverless function via an API Gateway endpoint. You’ll use the CLI to create an API endpoint as well as a serverless function, and then use the Amplify client libraries to interact with the API.</p>

<figure><div id="fig2a" class="figure">
<img src="Images/fssl_0201.png" alt="API with Lambda" width="974" height="486"/>
<h6><span class="label">Figure 2-1. </span>API with Lambda</h6>
</div></figure>

<p>At first, the app will fetch a hardcoded array of items from the function. You’ll then learn how to update the function to make an asynchronous HTTP request to another API to retrieve data and return it to the client.</p>






<section data-type="sect1" data-pdf-bookmark="Creating and Deploying a Serverless Function"><div class="sect1" id="idm45364349347464">
<h1>Creating and Deploying a Serverless Function</h1>

<p><a data-type="indexterm" data-primary="stateless compute containers" id="idm45364348466424"/>At the core of many serverless applications are <em>serverless functions</em>. Serverless functions run your code in <em>stateless compute containers</em> that are event-driven, short-lived (may last for one invocation), and fully managed by the cloud provider of your choice. These functions scale seamlessly and do not require any server operations.</p>

<p>While most people think of serverless functions as being invoked or triggered by an API call, these functions can also be triggered by a variety of different events. In addition to HTTP requests, a few popular ways to invoke a serverless function are via an image upload to a storage service, a database operation (like create, update, or delete), or even from another serverless function.</p>

<p>Serverless functions scale automatically, so there’s no need to worry about your application if you get a large spike in traffic. The first time you invoke a function, the service provider will create an instance of the function and run its handler method to process the event. After the function finishes and returns a response, it will remain and process additional events if they come in. If another invocation happens while the first event is still processing, the service will then create another instance.</p>

<p><a data-type="indexterm" data-primary="AWS Lambda" id="idm45364348462568"/><a data-type="indexterm" data-primary="creating" data-secondary="serverless functions" id="cre_sf"/><a data-type="indexterm" data-primary="deploying" data-secondary="serverless functions" id="dep_sf"/><a data-type="indexterm" data-primary="serverless functions" data-secondary="creating" id="sf_cre"/><a data-type="indexterm" data-primary="serverless functions" data-secondary="deploying" id="sf_dep"/>Serverless functions also have a payment model that is different from traditional infrastructure. With services like AWS Lambda, you only pay for what you use and are charged based on the number of requests for your functions and the time it takes for your code to execute. This is in contrast to provisioning and paying for infrastructure like servers regardless of whether they are being utilized.</p>

<p>Now that you know about serverless functions, let’s take a look at how you can create a serverless function and hook it up to an API that will invoke it from an HTTP request.</p>








<section data-type="sect2" data-pdf-bookmark="Creating the React Application and Installing the Dependencies"><div class="sect2" id="idm45364348455752">
<h2>Creating the React Application and Installing the Dependencies</h2>

<p><a data-type="indexterm" data-primary="installing" data-secondary="dependencies" id="idm45364348454344"/><a data-type="indexterm" data-primary="dependencies, installing" id="idm45364348453368"/><a data-type="indexterm" data-primary="creating" data-secondary="React application" id="idm45364348452728"/><a data-type="indexterm" data-primary="React application" data-secondary="creating" id="idm45364348451784"/>To get started, you’ll first need to create the React application. To do so, you can use <code>npx</code>:</p>

<pre data-type="programlisting">~ npx create-react-app amplify-react-app
~ cd amplify-react-app</pre>

<p><a data-type="indexterm" data-primary="Amplify client library" id="idm45364348449208"/><a data-type="indexterm" data-primary="client library" id="idm45364348448504"/>Next, you will need to install the dependencies. For this app, you’ll only need the AWS Amplify library:</p>

<pre data-type="programlisting">~ npm install aws-amplify</pre>

<p>After installing the dependencies, you can now initialize a new Amplify project in the root of the React application:</p>

<pre data-type="programlisting">~ amplify init

? Enter a name for the project: cryptoapp
? Enter a name for the environment: local
? Choose your default editor: &lt;your-preferred-editor&gt;
? Choose the type of app that you're building: javascript
? What javascript framework are you using: react
? Source Directory Path: src
? Distribution Directory Path: build
? Build Command: npm run-script build
? Start Command: npm run-script start
? Do you want to use an AWS profile? Here, choose *Y* and pick the AWS
  profile you created when you ran `amplify configure`.</pre>

<p>Now, both the Amplify project and the React app have been successfully created and you can begin adding new features.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating a New Serverless Function with the Amplify CLI"><div class="sect2" id="idm45364348444472">
<h2>Creating a New Serverless Function with the Amplify CLI</h2>

<p><a data-type="indexterm" data-primary="hardcode" id="idm45364348443160"/><a data-type="indexterm" data-primary="Amplify CLI" data-secondary="creating serverless functions with" id="idm45364348442456"/>In the next step, we’ll create the serverless function that you will be using for this app. The app you are building in this chapter is a cryptocurrency app. At first, you will hardcode an array of cryptocurrency information in the function and return it to the client. Later in this chapter, you’ll update this function to call another API (CoinLore) and asynchronously fetch and return data.</p>

<p>To create the function, run the following command:</p>

<pre data-type="programlisting">~ amplify add function

? Select which capability you want to add: Lambda function
? Provide a friendly name for your resource to be used as a label for
  this category in the project: cryptofunction
? Provide the AWS Lambda function name: cryptofunction
? Choose the function runtime that you want to use: NodeJS
? Choose the function template that you want to use: Serverless express
  function (Integration with Amazon API Gateway)
? Do you want to access other resources created in this project from
  your Lambda function? No
? Do you want to invoke this function on a recurring schedule? No
? Do you want to configure Lambda layers for this function? No
? Do you want to edit the local Lambda function now? No</pre>
<div data-type="tip"><h6>Tip</h6>
<p>If the function has successfully been created, you should see a message saying “Successfully added resource cryptofunction locally.”</p>
</div>

<p>You should now see a new subfolder located within the <em>amplify</em> directory at <em>amplify/backend/function/cryptofunction</em>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Walking Through the Code"><div class="sect2" id="idm45364348436264">
<h2>Walking Through the Code</h2>

<p><a data-type="indexterm" data-primary="function folder" id="idm45364348434856"/><a data-type="indexterm" data-primary="cryptofunction folder/function" id="idm45364348433992"/>When you created this resource, a new folder in <em>amplify/backend</em> was created named <em>function</em>. All of the functions created by the CLI will be stored in this folder. For now, you only have a single function, <code>cryptofunction</code>. In the <em>cryptofunction</em> folder, you will see a couple of configuration files as well as an <em>src</em> directory where the main function code is located.</p>

<p>Serverless functions are essentially just encapsulated applications running on their own. Because the function you created is in JavaScript, you’ll see that there are all of the things you’d typically see in any JavaScript application, including <em>package.json</em> and <em>index.js</em> files.</p>

<p><a data-type="indexterm" data-primary="entry point" id="idm45364348429064"/>Next, have a look at the function entry point located at <em>src/index.js</em>, in the <em>cryptofunction</em> folder. In this file you’ll see that there is a function called <code>exports.handler</code>. This is the entry point for the function invocation. When the function is invoked, this is the code that is run.</p>

<p><a data-type="indexterm" data-primary="Serverless Framework" id="idm45364348426568"/><a data-type="indexterm" data-primary="Express framework" id="idm45364348425640"/>You can handle the event directly in this function if you would like, but since you will be working with an API, a more useful way to do this is to proxy the path into an express app with routing (i.e., <em>http://yourapi/&lt;somepath&gt;</em>). Doing this gives you multiple routes in a single function as well as multiple HTTP request methods like <code>get</code>, <code>put</code>, <code>post</code>, and <code>delete</code> for each route. The <em>serverless express</em> framework provides an easy way to do this and has been built into the function boilerplate for you.</p>

<p>In <em>index.js</em>, you will see a line of code that looks like this:</p>

<pre data-type="programlisting">awsServerlessExpress.proxy(server, event, context);</pre>

<p>This code is where the event, context, and path are proxied to the express server running in <em>app.js</em>.</p>

<p>In <em>app.js</em>, you will then be able to create HTTP requests against whatever routes you create for your API (this example being a <code>/coins</code> route to fetch cryptocurrency).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Creating the /coins Route"><div class="sect2" id="idm45364348417752">
<h2>Creating the /coins Route</h2>

<p><a data-type="indexterm" data-primary="creating" data-secondary="coins route" id="idm45364348416344"/><a data-type="indexterm" data-primary="coins route, creating" id="idm45364348415368"/>Now that you have seen how the application is structured, let’s create a new route in <em>app.js</em> and return some data from it. The route that you will be creating is a <code>/coins</code> route. This route will be returning an object containing a coins array.</p>

<p>Let’s add the new route. Before the first <code>app.get('/items')</code> route, add the following code:</p>

<pre data-type="programlisting">/* amplify/backend/function/cryptofunction/src/app.js /*

app.get('/coins', function(req, res) {
  const coins = [
    { name: 'Bitcoin', symbol: 'BTC', price_usd: "10000" },
    { name: 'Ethereum', symbol: 'ETH', price_usd: "400" },
    { name: 'Litecoin', symbol: 'LTC', price_usd: "150" }
  ]
  res.json({
    coins
  })
})</pre>

<p>This new route has a hardcoded array of cryptocurrency information. When the function is invoked with this route, it will respond with an object containing a single property named <code>coins</code> that will contain the coins array.<a data-type="indexterm" data-primary="" data-startref="cre_sf" id="idm45364348410776"/><a data-type="indexterm" data-primary="" data-startref="dep_sf" id="idm45364348409800"/><a data-type="indexterm" data-primary="" data-startref="sf_cre" id="idm45364348408856"/><a data-type="indexterm" data-primary="" data-startref="sf_dep" id="idm45364348407912"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Adding the API"><div class="sect1" id="idm45364349346840">
<h1>Adding the API</h1>

<p><a data-type="indexterm" data-primary="adding" data-secondary="API" id="idm45364348405560"/><a data-type="indexterm" data-primary="APIs" data-secondary="adding" data-seealso="AWS AppSync" id="idm45364348404584"/>Now that the function is created and configured, let’s put an API in front of it so you can trigger it with an HTTP request.</p>

<p><a data-type="indexterm" data-primary="Amazon API Gateway" id="idm45364348402840"/>To do this, you will be using Amazon API Gateway. API Gateway is a fully managed service that enables developers to create, publish, maintain, monitor, and secure REST and WebSocket APIs. API Gateway is one of the services supported by both the Amplify CLI as well as the Amplify client library.</p>

<p>In this section, you’ll create a new API Gateway endpoint and configure it to invoke the Lambda function you created in the previous section.</p>








<section data-type="sect2" data-pdf-bookmark="Creating a New API"><div class="sect2" id="idm45364348401032">
<h2>Creating a New API</h2>

<p><a data-type="indexterm" data-primary="APIs" data-secondary="creating" id="idm45364348399832"/><a data-type="indexterm" data-primary="creating" data-secondary="APIs" id="idm45364348398856"/><a data-type="indexterm" data-primary="add command" id="idm45364348397912"/>To create the API, you can use the Amplify <code>add</code> command. From the root of the project, run the following command in your terminal:</p>

<pre data-type="programlisting">~ amplify add api

? Please select from one of the below mentioned services: REST
? Provide a friendly name for your resource to be used as a label for
  this category in the project: cryptoapi
? Provide a path: /coins
? Choose a Lambda source: Use a Lambda function already added in the
  current Amplify project
? Choose the Lambda function to invoke by this path: cryptofunction
? Restrict API access: N
? Do you want to add another path? N</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Deploying the API and the Lambda Function"><div class="sect2" id="idm45364348395320">
<h2>Deploying the API and the Lambda Function</h2>

<p><a data-type="indexterm" data-primary="push command" id="idm45364348393912"/><a data-type="indexterm" data-primary="deploying" data-secondary="Lambda function" id="idm45364348393208"/><a data-type="indexterm" data-primary="Lambda" data-secondary="deploying functions" id="idm45364348392264"/><a data-type="indexterm" data-primary="APIs" data-secondary="deploying" id="idm45364348391320"/><a data-type="indexterm" data-primary="deploying" data-secondary="API" id="idm45364348390376"/>Now that the function and API have both been created, you need to deploy them to your account to make them live. To do so, you can run the Amplify <code>push</code> command:</p>

<pre data-type="programlisting">~ amplify push

? Are you sure you want to continue? Y</pre>

<p>Once the deployment has successfully completed, the services are live and ready to use.</p>

<p><a data-type="indexterm" data-primary="status command" id="idm45364348387272"/>You can use the Amplify CLI <code>status</code> command at any time to see the current status of your project. The <code>status</code> command will list out all of the currently configured services in your project and give you the status for each of them:</p>

<pre data-type="programlisting"> ~ amplify status

Current Environment: local

| Category | Resource name  | Operation | Provider plugin   |
| -------- | -------------- | --------- | ----------------- |
| Function | cryptofunction | No Change | awscloudformation |
| Api      | cryptoapi      | No Change | awscloudformation |</pre>

<p>The main thing to notice in this status output is the <code>Operation</code>. The <code>Operation</code> tells you what will happen the next time <code>push</code> is run in the project. The <code>Operation</code> property will be set to <code>Create</code>, <code>Update</code>, <code>Delete</code>, or <code>No Change</code>.</p>
</div></section>





</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Interacting with the New API"><div class="sect1" id="idm45364348380296">
<h1>Interacting with the New API</h1>

<p><a data-type="indexterm" data-primary="APIs" data-secondary="interacting with" id="api_int"/>Now that the resources have been deployed, you can begin interacting with the API from the React application.</p>








<section data-type="sect2" data-pdf-bookmark="Configuring the Client App to Work with Amplify"><div class="sect2" id="idm45364348376984">
<h2>Configuring the Client App to Work with Amplify</h2>

<p><a data-type="indexterm" data-primary="aws-exports.js file" id="idm45364348375848"/><a data-type="indexterm" data-primary="client app" data-secondary="configuring" id="idm45364348375144"/><a data-type="indexterm" data-primary="configuring" data-secondary="client app" id="idm45364348374200"/>To use the Amplify client library in any application, there is a base configuration that needs to be set up, usually at the root level. When you create the resources, the CLI populates the <em>aws-exports.js</em> file with information about your resources. You will use this file to configure the client application to work with Amplify.</p>

<p>To configure the app, open <em>src/index.js</em> and add the following below the last import:</p>

<pre data-type="programlisting">import Amplify from 'aws-amplify'
import config from './aws-exports'
Amplify.configure(config)</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The Amplify Client API Category"><div class="sect2" id="idm45364348370440">
<h2>The Amplify Client API Category</h2>

<p><a data-type="indexterm" data-primary="Amplify client" id="idm45364348368824"/>After the client application has been configured, you can begin interacting with your resources.</p>

<p>The Amplify client library has various API categories that can be imported and used for various types of functionality, including <code>Auth</code> for authentication, <code>Storage</code> for storing items in S3, and <code>API</code> for interacting with REST and GraphQL APIs.</p>

<p>In this section, you will be working with the <code>API</code> category. <code>API</code> has various methods available—including <code>API.get</code>, <code>API.post</code>, <code>API.put</code>, and <code>API.del</code>—for interacting with REST APIs, and <code>API.graphql</code> for interacting with GraphQL APIs.</p>

<p>When working with a REST API, <code>API</code> takes in three arguments:</p>

<pre data-type="programlisting">API.get(apiName: String, path: String, data?: Object)</pre>
<dl>
<dt><code>apiName</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="apiName argument" id="idm45364348359000"/>The name given when you create the API from the command line. In our example, this value would be <code>cryptoapi</code>.</p>
</dd>
<dt><code>path</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="path argument" id="idm45364348356328"/>The path that you would like to interact with. In our example, we created <code>/coins</code>, so the path would be <code>/coins</code>.</p>
</dd>
<dt><code>data</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="data argument" id="idm45364348353320"/>This is an optional object containing any properties you’d like to pass to the API, including headers, query string parameters, or a body.</p>
</dd>
</dl>

<p class="less_space pagebreak-before">In our example, the API call is going to look like this:</p>

<pre data-type="programlisting">API.get('cryptoapi', '/coins')</pre>

<p><a data-type="indexterm" data-primary="promise" id="idm45364348350504"/>The API returns a promise, meaning you can handle the call using either a promise or an <code>async</code> function:</p>

<pre data-type="programlisting">// promise
API.get('cryptoapi', '/coins')
  .then(data =&gt; console.log(data))
  .catch(error =&gt; console.log(error))

// async await
const data = await API.get('cryptoapi', '/coins')</pre>

<p>In the examples in this book, we’ll be handling promises using <code>async</code> functions.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Calling the API and Rendering the Data in React"><div class="sect2" id="idm45364348369816">
<h2>Calling the API and Rendering the Data in React</h2>

<p><a data-type="indexterm" data-primary="APIs" data-secondary="calling" id="idm45364348346056"/><a data-type="indexterm" data-primary="calling APIs" id="idm45364348345080"/><a data-type="indexterm" data-primary="rendering data in React" id="idm45364348344408"/><a data-type="indexterm" data-primary="React application" data-secondary="rendering data in" id="idm45364348343736"/>Next, let’s call the API and render the data. Update <em>src/App.js</em> with the following:</p>

<pre data-type="programlisting">// Import useState and useEffect hooks from React
import React, { useState, useEffect } from 'react'

// Import the API category from AWS Amplify
import { API } from 'aws-amplify'

import './App.css';

function App() {
  // Create coins variable and set to empty array
  const [coins, updateCoins] = useState([])

  // Define function to all API
  async function fetchCoins() {
    const data = await API.get('cryptoapi', '/coins')
    updateCoins(data.coins)
  }

  // Call fetchCoins function when component loads
  useEffect(() =&gt; {
    fetchCoins()
  }, [])

  return (
    &lt;div className="App"&gt;
      {
        coins.map((coin, index) =&gt; (
          &lt;div key={index}&gt;
            &lt;h2&gt;{coin.name} - {coin.symbol}&lt;/h2&gt;
            &lt;h5&gt;${coin.price_usd}&lt;/h5&gt;
          &lt;/div&gt;
        ))
      }
    &lt;/div&gt;
  );
}

export default App</pre>

<p>Then, run the app:</p>

<pre data-type="programlisting">~ npm start</pre>

<p>When the app loads, you should see a list of coins with their name, symbol, and price, as shown in<a data-type="indexterm" data-primary="" data-startref="api_int" id="idm45364348338952"/> <a data-type="xref" href="#fig2b">Figure 2-2</a>.</p>

<figure><div id="fig2b" class="figure">
<img src="Images/fssl_0202.png" alt="Fetching data from API" width="1118" height="458"/>
<h6><span class="label">Figure 2-2. </span>Fetching data from the API</h6>
</div></figure>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Updating the Function to Call Another API"><div class="sect1" id="idm45364348334920">
<h1>Updating the Function to Call Another API</h1>

<p><a data-type="indexterm" data-primary="updating" data-secondary="function to call API" id="idm45364348333512"/><a data-type="indexterm" data-primary="APIs" data-secondary="updating function to call" id="idm45364348332536"/><a data-type="indexterm" data-primary="CoinLore API" id="idm45364348331624"/>Next, you’ll update the function to call another API, the CoinLore API, that will return dynamic data from the CoinLore service. The user will be able to add set filters like <code>limit</code> and <code>start</code> to limit the number of items coming back from the API.</p>

<p><a data-type="indexterm" data-primary="promise" id="idm45364348329448"/>To get started, you will first need a way to interact with an HTTP endpoint in the Lambda function. The library you will be using for this lesson is the Axios library. Axios is a promise-based HTTP client for the browser and Node.js.</p>








<section data-type="sect2" data-pdf-bookmark="Installing Axios"><div class="sect2" id="idm45364348328232">
<h2>Installing Axios</h2>

<p><a data-type="indexterm" data-primary="Axios library, installing" id="idm45364348327064"/><a data-type="indexterm" data-primary="installing" data-secondary="Axios" id="idm45364348326392"/>The first thing you need to do is install the Axios package in your function folder in order to send HTTP requests from the function. Navigate to <em>amplify/backend/function/cryptofunction/src</em>, install Axios, and then navigate back to the root of the app:</p>

<pre data-type="programlisting">~ cd amplify/backend/function/cryptofunction/src
~ npm install axios
~ cd ../../../../../</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Updating the Function"><div class="sect2" id="idm45364348323608">
<h2>Updating the Function</h2>

<p><a data-type="indexterm" data-primary="functions, updating" id="idm45364348322168"/><a data-type="indexterm" data-primary="updating" data-secondary="function" id="idm45364348321464"/>Next, update the <code>/coins</code> route in <em>amplify/backend/function/cryptofunction/src/app.js</em> with the following:</p>

<pre data-type="programlisting">// Import axios
const axios = require('axios')

app.get('/coins', function(req, res) {
  // Define base url
  let apiUrl = `https://api.coinlore.com/api/tickers?start=0&amp;limit=10`

  // Check if there are any query string parameters
  // If so, reset the base url to include them
  if (req.apiGateway &amp;&amp; req.apiGateway.event.queryStringParameters) {
   const { start = 0, limit = 10 } = req.apiGateway.event.queryStringParameters
   apiUrl = `https://api.coinlore.com/api/tickers/?start=${start}&amp;limit=${limit}`
  }

  // Call API and return response
  axios.get(apiUrl)
    .then(response =&gt; {
      res.json({  coins: response.data.data })
    })
    .catch(err =&gt; res.json({ error: err }))
})</pre>

<p><a data-type="indexterm" data-primary="pass in" id="idm45364348317848"/>In the preceding function, we’ve imported the Axios library and then used it to make an API call to the CoinLore API. In the API call, you can pass in a <code>start</code> and <code>limit</code> parameter to the request to define the number of coins to return, as well as to define the starting point.</p>

<p><a data-type="indexterm" data-primary="apiGateway property" id="idm45364348315592"/><a data-type="indexterm" data-primary="queryStringParameters property" id="idm45364348314488"/>In the <code>req</code> parameter, there is an <code>apiGateway</code> property that holds the <code>event</code> and the <code>context</code> variables. In the function just defined, there is a check to see if this <code>event</code> exists as well as the <code>queryStringParameters</code> property on the <code>event</code>. If the <code>queryStringParameters</code> property exists, we use those values to update the base URL with the parameters. Using <code>queryStringParameters</code>, the user can specify the <code>start</code> and <code>limit</code> values when querying the CoinLore API.</p>

<p><a data-type="indexterm" data-primary="push command" id="idm45364348308680"/>Once the function is updated, you can deploy the updates by running the <code>push</code> command in your terminal:</p>

<pre data-type="programlisting">~ amplify push

Current Environment: local

| Category | Resource name  | Operation | Provider plugin   |
| -------- | -------------- | --------- | ----------------- |
| Function | cryptofunction | Update    | awscloudformation |
| Api      | cryptoapi      | No Change | awscloudformation |

? Are you sure you want to continue? Y</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Updating the Client App"><div class="sect2" id="idm45364348306360">
<h2>Updating the Client App</h2>

<p><a data-type="indexterm" data-primary="client app" data-secondary="updating" id="idm45364348304920"/><a data-type="indexterm" data-primary="updating" data-secondary="client app" id="idm45364348303944"/>Now that you have updated the function, let’s update the React app to give the user the option to specify the <code>limit</code> and <code>start</code> parameters.</p>

<p>To do so, you’ll need to add fields for user input and give the user a button to trigger a new API request.</p>

<p>Update <em>src/App.js</em> with the following changes:</p>

<pre data-type="programlisting">// Create additional state to hold user input for limit and start properties
const [input, updateInput] = useState({ limit: 5, start: 0 })

// Create a new function to allow users to update the input values
function updateInputValues(type, value) {
  updateInput({ ...input, [type]: value })
}

// Update fetchCoins function to use limit and start properties
async function fetchCoins() {
  const { limit, start } = input
  const data = await API.get('cryptoapi', `/coins?limit=${limit}&amp;start=${start}`)
  updateCoins(data.coins)
}

// Add input fields to the UI for user input
&lt;input
  onChange={e =&gt; updateInputValues('limit', e.target.value)}
  placeholder="limit"
/&gt;
&lt;input
  placeholder="start"
  onChange={e =&gt; updateInputValues('start', e.target.value)}
/&gt;

// Add button to the UI to give user the option to call the API
&lt;button onClick={fetchCoins}&gt;Fetch Coins&lt;/button&gt;</pre>

<p>Next, run the app:</p>

<pre data-type="programlisting">~ npm start</pre>
</div></section>





</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Summary"><div class="sect1" id="idm45364348297624">
<h1>Summary</h1>

<p>Congratulations, you’ve deployed your first serverless API!</p>

<p>Here are a few things to keep in mind from this chapter<a data-type="indexterm" data-primary="APIs" data-secondary="creating" id="idm45364348295192"/><a data-type="indexterm" data-primary="creating" data-secondary="APIs" id="idm45364348294248"/><a data-type="indexterm" data-primary="API Gateway" data-secondary="configuring endpoint" id="idm45364348293304"/><a data-type="indexterm" data-primary="configuring" data-secondary="API Gateway endpoint" id="idm45364348292360"/><a data-type="indexterm" data-primary="amplify add api command" id="idm45364348291416"/><a data-type="indexterm" data-primary="amplify add function command" id="idm45364348290744"/><a data-type="indexterm" data-primary="Lambda" data-secondary="creating functions" id="idm45364348290104"/><a data-type="indexterm" data-primary="creating" data-secondary="Lambda functions" id="idm45364348289160"/><a data-type="indexterm" data-primary="Lambda" data-secondary="triggering" id="idm45364348288216"/>:</p>

<ul>
<li>
<p>Lambda functions can be triggered from a variety of events. In this chapter, we triggered the function using an API call from API Gateway.</p>
</li>
<li>
<p>Lambda functions can be created from the Amplify CLI by using the command <code>amplify add function</code>, and APIs can be created using the command <code>amplify add api</code>.</p>
</li>
<li>
<p>A single API Gateway endpoint can be configured to work with multiple Lambda functions. In the example in this chapter, we have only connected it to a single function.</p>
</li>
<li>
<p>Lambda functions are essentially self-contained Node.js applications. In the example for this chapter, we chose to run an express application in order to handle REST methods like <code>get</code>, <code>post</code>, and <code>delete</code>, though we have only worked with a <code>get</code> call at this point.</p>
</li>
<li>
<p>The <code>API</code> category from the Amplify client library can be used with both GraphQL as well as REST APIs.</p>
</li>
</ul>
</div></section>







</div></section></div>



  </body></html>