- en: Chapter 7\. Coroutines Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned of the pitfalls of the threading model.
    As an alternative to the threading model, the Kotlin language has a library called
    *kotlinx.coroutines* which aims at fixing the previously mentioned limitations.
    Coroutine-enabled primitives allow developers to write sequential, asynchronous
    code at a low cost. The design of coroutines comprises *suspending functions*,
    *structured concurrency*, and other specific considerations like *coroutine context*
    and *coroutine scope*. The subjects are closely related to one another. We’ll
    cover each one of these considerations in a way that is incremental and digestible.
  prefs: []
  type: TYPE_NORMAL
- en: What Exactly Is a Coroutine?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The official Kotlin documentation qualifies coroutines as “lightweight threads”
    in an effort to leverage an existing and well-known paradigm. You may conceptualize
    coroutines as *blocks of code that can be dispatched to threads that are nonblocking*.
  prefs: []
  type: TYPE_NORMAL
- en: Coroutines are indeed *lightweight*, but it is important to note that *coroutines
    aren’t threads* themselves. In fact, many coroutines can run on a single thread,
    although each has a lifecycle of its own. Rather, you’ll see in this section that
    they really are just state machines, with each state corresponding to a block
    of code that some thread will eventually execute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You might be surprised to find that the concept of coroutines goes all the way
    back to the early 1960s with the creation of Cobol’s compiler, which used the
    idea of suspending and launching functions in assembly language. Coroutines can
    also be spotted in the languages Go, Perl, and Python.
  prefs: []
  type: TYPE_NORMAL
- en: The coroutine library offers some facilities to manage those threads out of
    the box. However, you can configure the coroutine builder to manage your threads
    yourself if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: Your First Coroutine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this section, we’ll introduce a lot of new vocabulary and concepts
    from the `kotlinx.coroutines` package. To make this learning smooth, we chose
    to start with a simple coroutine usage, and explain how this works along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example, as well as the others in this chapter, uses semantics
    declared in the `kotlinx.coroutines` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The method `runBlocking` runs a new coroutine and blocks the current thread
    until the coroutine work has completed. This coroutine builder is typically used
    in main functions and testing as it serves as a bridge to regular blocking code.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the code block, we create a coroutine with the `launch` function. Since
    it creates a coroutine, it’s a *coroutine builder*—you’ll see later that other
    coroutine builders exist. The method `launch` returns a reference to a `Job`,
    which represents the lifecycle of the coroutine launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the coroutine, there’s a `while`-loop that executes indefinitely. Below
    the `job` coroutine, you may notice that the `job` is cancelled later on. To demonstrate
    what this means, we can run our program and the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It appears that the coroutine ran like clockwork. In tandem, the code continues
    to execute in the main thread, giving us a total of three printed lines within
    a 30 ms window given to us by the `delay` call, as shown in [Figure 7-1](#cancel_illustration).
  prefs: []
  type: TYPE_NORMAL
- en: '![First coroutine](assets/pawk_0701.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-1\. First coroutine.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The `delay` function looks suspiciously like `Thread.sleep` in its usage. The
    major difference is that `delay` is *nonblocking* while `Thread.sleep(...)` is
    *blocking*. To demonstrate what we mean, let’s examine our code again, but replace
    the `delay` call in our coroutine with `Thread.sleep`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe what happens when we run the code again. We get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The output seems to run infinitely now. When the coroutine executes, the `Thread.sleep(10L)`
    call blocks the main thread until the coroutine started by `launch` completes.
    As the coroutine started with `launch` makes the main thread either sleep or print,
    the coroutine never completes, so execution never leaves the coroutine,^([1](ch07.html#idm46669751105520))
    as shown in [Figure 7-2](#cancel_impossible).
  prefs: []
  type: TYPE_NORMAL
- en: '![Never ending program](assets/pawk_0702.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-2\. Never-ending program.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'It’s important to remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `launch` coroutine builder is “fire-and-forget” work—in other words, there
    is no result to return.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once called, it immediately returns a `Job` instance, and starts a new coroutine.
    A `Job` represents the coroutine itself, like a handle on its lifecycle. The coroutine
    can be cancelled by calling the `cancel` method on its `Job` instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A coroutine that is started with `launch` will not return a result, but rather,
    a reference to the background job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If, on the other hand, you need to get a result from an asynchronous computation,
    then you should use the `async` coroutine builder.
  prefs: []
  type: TYPE_NORMAL
- en: The async Coroutine Builder
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `async` coroutine builder can be compared to Java’s `Future`/`Promise`
    model to support asynchronous programming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Instead of making a blocking call to get the data, an asynchronous function
    immediately returns a wrapper around the result. Depending on the library you
    use, this wrapper is called `Future`, `CompletableFuture`, `Promise`, etc. This
    wrapper is like a handle from which you can check if the result is available or
    not. If you wish, you can block a thread until the result is available with the
    `Future.get()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like a `Future`, the `async` coroutine builder *returns a wrapper around
    a result*; and the type of this wrapper is `Deferred<T>` (the generic type is
    the type of the result), as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The data types `quick` and `slow` are a future result as an implementation of
    `Deferred<Int>`, otherwise known as a `Job` with a result. By calling the method
    `await` on each `Deferred<Int>` instance, the program waits for the result of
    each coroutine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we’ve launched two coroutines using the `async` coroutine builder.
    The code itself can give us a good guess at what might happen, but let’s run it
    anyway to see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The preceding program delays the slow `async` job delays it by 1,000 ms while
    the quick `async` job by 100 ms—the `result` waits for both to complete before
    printing out the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s important to remember the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `async` coroutine builder is intended for *parallel decomposition of work*—that
    is, you *explicitly* specify that some tasks will run concurrently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once called, an `async` immediately returns a `Deferred` instance. `Deferred`
    is a specialized `Job`, with a few extra methods like `await`. It’s a `Job` with
    a return value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very similarly to `Future`s and `Promise`s, you invoke the `await` method on
    the `Deferred` instance to get the returned value.^([2](ch07.html#idm46669750880912))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed by now that the examples provided with the coroutine builders
    `launch` and `async` are wrapped with a `runBlocking` call. We mentioned earlier
    that `runBlocking` runs a new coroutine and blocks the current thread until the
    coroutine work has completed. To better understand the role of `runBlocking`,
    we must first give a sneak preview on structured concurrency, a concept which
    will be explored in detail in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: A Quick Detour About Structured Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines aren’t just yet another fancy way to launch background tasks. The
    coroutines library is built around the structured concurrency paradigm. Before
    going further in your discovery of coroutines, you should understand what it is,
    and the problems the coroutine library aims to solve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making development easier is a worthwhile goal. In the case of structured concurrency,
    it’s almost a happy side effect of a response to a more general problem. Consider
    the simplest construct every developer is familiar with: a function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are predictable in the sense that they are executed from top to bottom.
    If we put aside the possibility that exceptions can be thrown from inside the
    function,^([3](ch07.html#idm46669750870416)) we know that prior to a function
    returning a value, execution order is serial: each statement executes prior to
    the next. What if inside the function, your program creates and starts another
    thread? It’s perfectly legal, but now you have two flows of execution, as shown
    in [Figure 7-3](#fig_two_flows).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Two Flows](assets/pawk_0703.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-3\. Two flows.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Calling this function doesn’t only produce one result; it has the side effect
    of creating a parallel flow of execution. This can be problematic for the following
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Exceptions aren’t propagated
  prefs: []
  type: TYPE_NORMAL
- en: 'If an exception is thrown inside the thread, and it isn’t handled, then the
    JVM calls the thread’s `UncaughtExceptionHandler`, which is a simple interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can provide a handler using the `Thread.setUncaughtExceptionHandler` method
    on your thread instance. By default, when you create a thread, it doesn’t have
    a specific `UncaughtExceptionHandler`. When an exception isn’t caught, *and* you
    haven’t set a specific one, the default handler is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: In the Android framework, it’s important to note that the default `UncaughtExceptionHandler`
    will cause your app to crash by killing the app’s native process. Android designers
    made this choice because it’s generally better for an Android application to *fail-fast*,
    as the system shouldn’t make decisions on behalf of the developer when it comes
    to unhandled exceptions. The stacktrace is then relevant to the real problem—while
    recovering from it might produce inconsistent behaviors and problems that are
    less transparent, because the root cause can be much earlier in the call stack.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, there’s nothing in place to inform our function if something
    bad happens in the background thread. Sometimes this is just fine because errors
    can be directly handled from the background thread, but you may have logic that
    is more complex and requires the calling code to monitor issues to react differently
    and specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There is a mechanism involved before the default handler is invoked. Every
    thread can belong to a `ThreadGroup` which can handle exceptions. Each thread
    group can also have a parent thread group. Within the Android framework, two groups
    are statically created: “system,” and a child of the system group known as “main.”
    The “main” group always delegates exception handling to the “system” group parent,
    which then delegates to `Thread.getDefaultUncaughtExceptionHandler()` if it isn’t
    null. Otherwise, the “system” group prints the exception name and stacktrace to
    `System.err`.'
  prefs: []
  type: TYPE_NORMAL
- en: Execution flow is hard to control
  prefs: []
  type: TYPE_NORMAL
- en: Since a thread can be created and started from anywhere, imagine that your background
    thread instantiates and starts three new threads to delegate some of its work,
    or performs tasks in reaction to computation performed in the parent thread’s
    context, as shown in [Figure 7-4](#multiple_flows_id).
  prefs: []
  type: TYPE_NORMAL
- en: '![Multiple Flows](assets/pawk_0704.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-4\. Multiple flows.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'How do you make sure the function returns only when all background processing
    is done? This can be error-prone: you need to make sure that you wait for all
    child threads to finish their work.^([4](ch07.html#idm46669750810416)) When using
    a `Future`-based implementation (for example, `CompletableFuture`s), even omitting
    a `Future.get` invocation might cause the flow of execution to terminate prematurely.'
  prefs: []
  type: TYPE_NORMAL
- en: Later, and while the background thread and all of its children are still running,
    all this work might have to be cancelled (the user exited the UI, an error was
    thrown, etc.). In this case, there’s no automatic mechanism to cancel the entire
    task hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: When working with threads, it’s really easy to forget about a background task.
    *Structured concurrency is nothing but a concept meant to address this issue*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll detail this concept and explain how it relates to
    coroutines.
  prefs: []
  type: TYPE_NORMAL
- en: The Parent-Child Relationship in Structured Concurrency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we’ve spoken about threads, which were represented by arrows in the
    previous illustrations. Let’s imagine a higher level of abstraction where some
    parent entity could create multiple children, as shown in [Figure 7-5](#fig_parent_child).
  prefs: []
  type: TYPE_NORMAL
- en: '![Parent-Child](assets/pawk_0705.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-5\. Parent-child.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Those children can run concurrently with each other as well as the parent.
    If the parent fails or is cancelled, then all its children are also cancelled.^([5](ch07.html#idm46669750799248))
    Here is the first rule of structured concurrency:'
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation always propagates downward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: How the failure of one child affects other children of the same level is a parameterization
    of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: Just as a parent entity could fail or be cancelled, this can happen to any of
    the children. In the case of cancellation of one of the children, referencing
    the first rule, we know that the parent will not be cancelled (cancellation propagates
    downward, not upward). In case of failure, what happens next depends on the problem
    you’re trying to solve. The failure of one child should or should not lead to
    the cancellation of the other children, as shown in [Figure 7-6](#fig_cancellation_policy).
    Those two possibilities characterize the parent-child failure relationship, and
    is a parameterization of the parent.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cancellation policy](assets/pawk_0706.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-6\. Cancellation policy.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The parent always waits for all its children to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Other rules could be added around exception propagation, but they would be implementation
    specific, and it’s time to introduce some concrete examples.
  prefs: []
  type: TYPE_NORMAL
- en: Structured  concurrency  is  available  in  Kotlin  coroutines  with  `CoroutineScope`s 
    and  `CoroutineContext`s.  Both  `CoroutineScope`s  and  `CoroutineContext`s 
    play  the  role  of  the parent in previous illustrations, while Coroutines, on
    play the role of the children.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we’ll cover `CoroutineScope` and `CoroutineContext`
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: CoroutineScope and CoroutineContext
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re about to dive into the details of the *kotlinx.coroutine* library. There
    will be *a lot* of new concepts in the upcoming section. While those concepts
    are important if you want to master coroutines, you don’t have to understand everything
    right now to get started and be productive with coroutines. There will be a lot
    of examples following this section and in the next chapter, which will give you
    a good sense of how coroutines work. Therefore, you might find it easier to come
    back to this section after you’ve practiced a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have an idea of what structured concurrency is, let’s revisit the
    whole `runBlocking` thing again. Why not just call `launch` or `async` outside
    a `runBlocking` call?
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler reports: “Unresolved reference: launch.” This is because coroutine
    builders are extension functions of `CoroutineScope`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A `CoroutineScope` controls the lifecycle of a coroutine within a well-defined
    scope or lifecycle. It’s an object that plays the role of the parent in structured
    concurrency—its purpose is to manage and monitor the coroutines you create inside
    it. You might be surprised to find that in the previous example with the `async`
    coroutine builder, a `CoroutineScope` had already been provided to launch a new
    coroutine. That `CoroutineScope` was provided by the `runBlocking` block. How?
    This is the simplified signature of `runBlocking`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The last argument is a function with a receiver of type `CoroutineScope`. Consequently,
    when you supply a function for the block argument, there is a `CoroutineScope`
    at your disposal which can invoke extension functions of `CoroutineScope`. As
    you can see in [Figure 7-7](#type_hint_figure_id), Android Studio is able to pick
    up the implicit type-referencing in Kotlin so that if you enable “type hints,”
    you are able to see the type parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '![Type hint in Android Studio](assets/pawk_0707.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-7\. Type hint in Android Studio.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Besides providing a `CoroutineScope`, what is the purpose of `runBlocking`?
    `runBlocking` blocks the current thread until its completion. It can be invoked
    from regular blocking code as a bridge to code containing suspending functions
    (we’ll cover suspending functions later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'To be able to create coroutines, we have to bridge our code to the “regular”
    function `main` in our code. However, the following sample won’t compile, as we’re
    trying to start a coroutine from regular code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This is because the `launch` coroutine builder is actually an *extension function*
    of `CoroutineScope`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Since regular code doesn’t provide a `CoroutineScope` instance, you cannot directly
    invoke coroutine builders from there.
  prefs: []
  type: TYPE_NORMAL
- en: So what’s this `CoroutineContext`? To answer this question, you need to understand
    the details of `CoroutineScope`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the source code, a `CoroutineScope` is an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In other words, a `CoroutineScope` is a container for a `CoroutineContext`.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of a `CoroutineScope` is to encapsulate concurrent tasks (coroutines
    and other scopes) by applying structured concurrency. Scopes and coroutines form
    a tree-like architecture with a scope at its root, as shown in [Figure 7-8](#fig_tree_like_arch).
  prefs: []
  type: TYPE_NORMAL
- en: '![Tree-like structure](assets/pawk_0708.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-8\. Tree-like relationship (coroutines are represented as rectangles).
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A `CoroutineContext`, which we’ll refer to as a *context* for future reference,
    is a broader concept. It’s an immutable union set of context elements. For future
    reference, we’ll use the term “element” to designate *context element*.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s the theory. In practice, you’ll most often use a special context element
    to control which thread, or which thread pool, will execute your coroutine(s).
    For example, imagine that you have to run CPU-heavy computations inside a `launch`,
    while not blocking the main thread. This is where the coroutine library is really
    handy because thread pools for most common usages are available out of the box.
    In the case of CPU-bound tasks, you don’t have to define your own thread pool.
    All you have to do is use the special `Dispatchers.Default` context element like
    so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '`Dispatchers.Main` is a context element. As you’ll see later, different context
    elements can be combined using operators to tweak the behavior of coroutines even
    more.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As its name suggests, the purpose of a `Dispatcher` is to dispatch coroutines
    on a specific thread or thread pool. By default, there are four `Dispatcher`s
    available out of the box—`Main`, `Default`, `IO`, and `Unconfined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatchers.Main`'
  prefs: []
  type: TYPE_NORMAL
- en: This uses the main thread, or the UI thread, of the platform you’re using.
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatchers.Default`'
  prefs: []
  type: TYPE_NORMAL
- en: This is meant for CPU-bound tasks, and is backed by a thread pool of four threads
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatchers.IO`'
  prefs: []
  type: TYPE_NORMAL
- en: This is meant for IO-bound tasks, and is backed by a thread pool of 64 threads
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: '`Dispatchers.Unconfined`'
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t something you should use or even need as you’re learning coroutines.
    It’s primarily used in the internals of the coroutines library.
  prefs: []
  type: TYPE_NORMAL
- en: By just changing the dispatcher, you can control which thread or thread pool
    your coroutine will be executed on. The context element `Dispatcher.Default` is
    a subclass of `CoroutineDispatcher`, but other context elements also exist.
  prefs: []
  type: TYPE_NORMAL
- en: By providing a dispatcher context, you can easily designate where logic flow
    executes. Thus, it is the developer’s responsibility to supply the context to
    the coroutine builder.
  prefs: []
  type: TYPE_NORMAL
- en: In coroutine framework parlance, a coroutine always runs inside a context. *This*
    context is provided by a coroutine scope and is different from the context you
    supply. To avoid confusion, we’ll call the context of the coroutine the *coroutine
    context*, and we’ll call the context you supply to the coroutine builder the *supplied
    context*.
  prefs: []
  type: TYPE_NORMAL
- en: The difference is subtle—remember the `Job` object? A `Job` instance is a handle
    on the lifecycle of the coroutine—it’s part of the coroutine context too. Every
    coroutine has a `Job` instance that represents it, and this job is part of the
    coroutine context.
  prefs: []
  type: TYPE_NORMAL
- en: It’s time to unveil how those contexts are created. Look at [Example 7-1](#listing_runblocking_1),
    which differs slightly from the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-1\. Dispatchers example
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This block of code creates two coroutines with their own respective `Job` instance:
    `runBlocking` starts the first coroutine, and the other one is started by `launch`.'
  prefs: []
  type: TYPE_NORMAL
- en: The coroutine created by `runBlocking` has its own context. Since this is the
    root coroutine started inside the scope, we call this context the *scope context*.
    The scope context encompasses the coroutine context, as shown in [Figure 7-9](#contexts_encapsulation_id).
  prefs: []
  type: TYPE_NORMAL
- en: '![Contexts](assets/pawk_0709.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-9\. Contexts.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You’ve seen that `launch` is an extension function of `CoroutineScope` (which
    holds a context), and that it can receive a context as its first parameter. So
    there are two contexts at our disposal in this function, as shown in [Example 7-1](#listing_runblocking_1):
    one from the receiver type (the scope context), and the other one from the context
    parameter (the supplied context).'
  prefs: []
  type: TYPE_NORMAL
- en: What does `launch` do in its implementation before calling our provided function?
    It merges the two contexts so that the elements from the context parameter take
    precedence over the other elements from the scope. From this merge operation we
    obtain the parent context. At this point, the `Job` of the coroutine isn’t created
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: At last, a new `Job` instance is created as a child of the `Job` from the parent
    context. This new `Job` is then added to the parent context, replacing the `Job`
    instance of the parent context to obtain the coroutine context.
  prefs: []
  type: TYPE_NORMAL
- en: These relationships and interactions are represented in [Figure 7-10](#context_diagram_id),
    in which a context is represented by a rectangle containing other context elements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Contexts](assets/pawk_0710.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-10\. Representation of a *Context*.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[Figure 7-10](#context_diagram_id) represents a context that contains a `Job`
    instance, and a dispatcher which is `Dispatchers.Main`. With that representation
    in mind, [Figure 7-11](#fig_context_detail) shows how we would represent the context
    of [Example 7-1](#listing_runblocking_1).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Context detail](assets/pawk_0711.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-11\. Context detail.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Everything you provide in the supplied context to the `launch` method takes
    precedence over the scope context. This results in a *parent context*, which inherits
    elements from the scope context which were not provided in the supplied context
    (a `Job`, in this case). Then a new `Job` instance is created (with a dot in the
    upper-right corner), as a child of the parent `Job` which is also, in this case,
    the `Job` of the scope context. The resulting coroutine context is made of elements
    from the parent context except for `Job` (which is a child `Job` of the `Job`
    in the parent context).
  prefs: []
  type: TYPE_NORMAL
- en: This *coroutine context* is the context in which the lambda we provide to `launch`
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Structured concurrency is possible because the `Job` in the coroutine context
    is a child of the `Job` from the parent context. If the scope is cancelled for
    any reason, every child coroutine started is then automatically cancelled.^([6](ch07.html#idm46669750393056))
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, the coroutine context inherits context elements from the scope
    context, which are not overridden by the context supplied as a parameter to launch;
    the `async` method behaves identically in this regard.
  prefs: []
  type: TYPE_NORMAL
- en: Suspending Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve examined how to launch a coroutine with the coroutine builders `launch`
    and `async`, and touched on what it means for something to be blocking or nonblocking.
    At its core, Kotlin coroutines offer something different that will really reveal
    how powerful coroutines can be: *suspending functions*.'
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that you invoke two tasks serially. The first task completes before
    the second can proceed with its execution.
  prefs: []
  type: TYPE_NORMAL
- en: '![Contexts](assets/pawk_07in01.png)'
  prefs: []
  type: TYPE_IMG
- en: When task A executes, the underlying thread cannot proceed with executing other
    tasks—task A is then said to be a *blocking call*.
  prefs: []
  type: TYPE_NORMAL
- en: However, task A spending a reasonable amount of time waiting for a longer-running
    job (e.g., an HTTP request) ends up blocking the underlying thread, rendering
    the waiting task B useless.
  prefs: []
  type: TYPE_NORMAL
- en: So task B waits for task A to complete. The frugal developer may see this scenario
    as a waste of thread resources, since the thread could (and should) proceed with
    executing another task while task A is waiting for the result of its network call.
  prefs: []
  type: TYPE_NORMAL
- en: Using suspending functions, we can split tasks into chunks which can *suspend*.
    In the case of our example, task A can be suspended when it performs its remote
    call, leaving the underlying thread free to proceed with another task (or just
    a part of it). When task A gets the result of its remote call, it can be resumed
    at a later point in time, as shown in [Figure 7-12](#figure7_12).
  prefs: []
  type: TYPE_NORMAL
- en: '![Contexts](assets/pawk_0712.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-12\. The time saved is represented at the end.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As you can see, the two tasks complete sooner than in the previous scenario.
    This interleaving of bits of tasks leaves the underlying thread always busy executing
    a task. Therefore, a suspending mechanism requires fewer threads to produce the
    same overall throughput, and this is quite important, when each thread has its
    own stack which costs a minimum of 64 Kb of memory. Typically, a thread occupies
    1 MB of RAM.
  prefs: []
  type: TYPE_NORMAL
- en: Using a suspending mechanism, we can be more frugal by using more of the same
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: Suspending Functions Under the Hood
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we’ve introduced a new concept: the fact that a task can *suspend*.
    A task can “pause” its execution without blocking the underlying thread. While
    this might sound like magic to you, it’s important to understand that it all comes
    down to lower-level constructs, which we’ll explain in this section.'
  prefs: []
  type: TYPE_NORMAL
- en: A task, or more precisely, a coroutine, can suspend if it makes use of at least
    one *suspending function*. A suspending function is easily recognizable as it’s
    declared with the `suspend` modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the Kotlin compiler encounters a suspending function, it compiles to a
    regular function with an additional parameter of type `Continuation<T>`, which
    is just an interface, as shown in [Example 7-2](#contd):'
  prefs: []
  type: TYPE_NORMAL
- en: Example 7-2\. Interface `Continuation<T>`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Assuming that you define this suspending function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At compile time, this function is transformed into a regular function (without
    the `suspend` modifier), with an additional `Continuation` argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Suspending functions are compiled to regular functions taking an additional
    `Continuation` object argument. This is an implementation of *Continuation Passing
    Style* (CPS), a style of programming where control flow is passed on in the form
    of a `Continuation` object.
  prefs: []
  type: TYPE_NORMAL
- en: This `Continuation` object holds all the code that should be executed in the
    body of the `backgroundWork` function.
  prefs: []
  type: TYPE_NORMAL
- en: What does the Kotlin compiler actually generate for this `Continuation` object?
  prefs: []
  type: TYPE_NORMAL
- en: For efficiency reasons, the Kotlin compiler generates a state machine.^([7](ch07.html#idm46669750312528))
    A state-machine implementation is all about allocating as few objects as possible,
    because coroutines being lightweight, thousands of them might be running.
  prefs: []
  type: TYPE_NORMAL
- en: Inside this state machine, each state corresponds to a *suspension point* inside
    the body of the suspending function. Let’s look at an example. Imagine that in
    an Android project, we use the presenter layer to execute some long-running processes
    surrounding IO and graphics processing, where the following code block has two
    suspension points with the self-managed coroutine launched from the `viewModelScope`:^([8](ch07.html#idm46669750309136))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The compiler generates an anonymous class which implements the `Continuation`
    interface. To give you a sense of what is actually generated, we’ll provide pseudocode
    of what is generated for the `renderImage` suspending function. The class has
    a `state` field holding the current state of the state machine. It also has fields
    for each variable that are shared between states:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This state machine is initialized with `state = 0`. Consequently, when the coroutine
    started with `launch` invokes the `renderImage` suspending function, the execution
    “jumps” to the first case `(0)`. We retrieve a path, set the next state to `1`,
    then invoke `fetchImage`—which is the first suspending function in the body of
    `renderImage`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, there are two possible scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetchImage` requires some time to return an `Image` instance, and immediately
    returns the `COROUTINE_SUSPENDED` value. By returning this specific value, `fetchImage`
    basically says: “I need more time to return an actual value, so give me your state-machine
    object, and I’ll use it when I have a result.” When `fetchImage` finally has an
    `Image` instance, it invokes `stateMachine.resumeWith(image)`. Since at this point
    `state` equals `1`, the execution “jumps” to the second case of the `when` statement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`fetchImage` immediately returns an `Image` instance. In this case, execution
    proceeds with the next state (via `resumeWith(image)`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The rest of the execution follows the same pattern, until the code of the last
    state invokes the `postProcess` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This explanation is not the exact state of the state machine generated in the
    bytecode, but rather, pseudocode of its representative logic to convey the main
    idea. For everyday use, it’s less important to know the implementation details
    of the actual finite state machine generated in the Kotlin bytecode than it is
    to understand what happens under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Conceptually, when you invoke a suspending function, a callback (`Continuation`)
    is created along with generated structures so that the rest of the code after
    the suspending function will be called only when the suspending function returns.
    With less time spent on boilerplate code, you can focus on business logic and
    high-level concepts.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve analyzed how the Kotlin compiler restructures our code under the
    hood, in such a way that we don’t have to write callbacks on our own. Of course,
    you don’t have to be fully aware of finite state-machine code generation to use
    suspending functions. However, the concept is important to grasp! For this purpose,
    nothing is better than practicing!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using Coroutines and Suspending Functions: A Practical Example'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that in an Android application you wish to load a user’s profile with
    an `id`. When navigating to the profile, it might make sense to fetch the user’s
    data based on the `id` in a method named `fetchAndLoadProfile`.
  prefs: []
  type: TYPE_NORMAL
- en: You can use coroutines for that, using what you learned in the previous section.
    For  now,  assume  that  somewhere  in  your  app  (typically  a  controller 
    in  MVC  architecture, or a `ViewModel` in MVVM) you have a `CoroutineScope` which
    has the `Dispatchers.Main` dispatcher in its `CoroutineContext`. In this case,
    we say that this scope dispatches coroutines on the main thread, which is identical
    to default behavior. In the next chapters we will give you detailed explanations
    and examples of coroutine scopes, and how you can access and create them yourself
    if you need to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fact that scope defaults to the main thread isn’t limiting in any way,
    since you can create coroutines with any `CoroutineDispatcher` you want inside
    this scope. This implementation of `fetchAndLoadProfile` illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is done in four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[![1](assets/1.png)](#co_coroutines_concepts_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Start with a `launch`. You want the `fetchAndLoadProfile` to return immediately
    so that you can proceed serially on the main thread. Since the scope defaults
    to the main thread, a launch without additional context inherits the scope’s context,
    so it runs on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_coroutines_concepts_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `async` and `Dispatchers.Default`, you call `fetchProfile`, which is
    a blocking call. As a reminder, using `Dispatchers.Default` results in having
    `fetchProfile` executed on a thread pool. You immediately get a `Deferred<Profile>`,
    which you name `profileDeferred`. At this point, ongoing background work is being
    done on one of the threads of the thread pool. This is the signature of `fetchProfile`:
    `fun fetchProfile(id: String): Profile { // impl }`. It’s a blocking call which
    might perform a database query on a remote server.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_coroutines_concepts_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot use `profileDeferred` right away to load the profile—you need to
    wait for the result of the background query. You do this by using `profileDeferred.await()`,
    which will generate and return a `Profile` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_coroutines_concepts_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can invoke `loadProfile` using the obtained profile. As the outer
    launch inherits its context from the parent scope, `loadProfile` is invoked on
    the main thread. We’re assuming that this is expected, as most UI-related operations
    have to be done on the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you invoke `fetchAndLoadProfile`, background processing is done off
    the UI thread to retrieve a profile. As soon as the profile is available, the
    UI is updated. You can invoke `fetchAndLoadProfile` from whatever thread you want—it
    won’t change the fact that `loadProfile` is eventually called on the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: Not bad, but we can do better.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how this code reads from top to bottom, without indirection or callbacks.
    You could argue that the “profileDeferred” naming and the `await` calls feel clunky.
    This could be even more apparent when you fetch a profile, wait for it, then load
    it. This is where suspending functions come into play.
  prefs: []
  type: TYPE_NORMAL
- en: Suspending functions are at the heart of the coroutine framework.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Conceptually, a suspending function is a function which may not return immediately.
    If it doesn’t return right away, it suspends the coroutine that called this suspending
    function while computation occurs. This inner computation *should not block* the
    calling thread. Later, the coroutine is resumed when the inner computation completes.
  prefs: []
  type: TYPE_NORMAL
- en: A suspending function can only be called from inside a coroutine or from another
    suspending function.
  prefs: []
  type: TYPE_NORMAL
- en: 'By “suspend the coroutine,” we mean that the coroutine execution is stopped.
    Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: First off, a suspending function isn’t a regular function; it has its own `suspend`
    keyword. It can have a return type, but notice that in this case it doesn’t return
    a `Deferred<Int>`—only bare `Int`.
  prefs: []
  type: TYPE_NORMAL
- en: Second, it can only be invoked from a coroutine, or another suspending function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our previous example: fetching and waiting for a profile was done with
    an `async` block. Conceptually, this is exactly the purpose of a suspending function.
    We’ll borrow the same name as the blocking `fetchProfile` function and rewrite
    it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The two major differences with the original `async` block are the `suspend`
    modifier and the return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows you to simplify `fetchAndLoadProfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now that `fetchProfile` is a suspending function, the coroutine started by `launch`
    is suspended when invoking `fetchProfile`. Suspended means that the execution
    of the coroutine is stopped, and that the next line does not execute. It will
    remain suspended until the profile is retrieved, at which point the coroutine
    started by `launch` resumes. The next line (`loadProfile`) is then executed.
  prefs: []
  type: TYPE_NORMAL
- en: Notice how this reads like procedural code. Imagine how you would implement
    complex, asynchronous logic where each step requires a result from the previous
    one. You would call suspending functions like this, one after another, in a classic
    procedural style. Code that is easy to understand is more maintainable. This is
    one of the most immediately helpful aspects of suspending functions.
  prefs: []
  type: TYPE_NORMAL
- en: As a bonus, IntelliJ IDEA and Android Studio help you in spotting suspending
    calls in one glimpse. In [Figure 7-13](#figure7_13), you can see a symbol in the
    margin indicating a suspending call.
  prefs: []
  type: TYPE_NORMAL
- en: '![suspend call](assets/pawk_0713.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7-13\. Suspending call.
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you see this symbol in the margin, you know that a coroutine can temporarily
    suspend at this line.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t Be Mistaken About the suspend Modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However impressive it looks, adding the `suspend` modifier to a regular function
    doesn’t magically turn it into a nonblocking function. There’s more to it. Here
    is an example with the suspending `fetchProfile` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`fetchProfile(...)` uses the `withContext` function from the coroutines framework,
    which accepts a `CoroutineContext` as parameter. In this case, we provide `Dispatchers.Default`
    as the context. Almost every single time you use `withContext`, you’ll only provide
    a `Dispatcher`.'
  prefs: []
  type: TYPE_NORMAL
- en: The thread that will execute the body of `withContext` is determined by the
    provided `Dispatcher`. For example, using `Dispatchers.Default`, it would be one
    of the threads of the thread pool dedicated for CPU-bound tasks. In the case of
    `Dispatchers.Main`, it would be the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Why and how does `fetchProfile` suspend? This is an implementation detail of
    `withContext` and of the coroutine framework in general.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important concept to remember is simple: a coroutine calling a suspending
    function *might* suspend its execution. In coroutine parlance, we say that it
    reaches a suspension point.'
  prefs: []
  type: TYPE_NORMAL
- en: Why did we say that it *might* suspend? Imagine that inside your implementation
    of `fetchProfile`, you check whether you have the associated profile in the cache.
    If you have the data in the cache, you may immediately return it. Then there’s
    no need to suspend the execution of the outer coroutine.^([9](ch07.html#idm46669749681488))
  prefs: []
  type: TYPE_NORMAL
- en: There are several ways to create a suspending function. Using `withContext`
    is only one of them, although probably the most common.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coroutines are always launched from a `CoroutineScope`. In structured concurrency
    parlance, the `CoroutineScope` is the parent, and coroutines themselves are children
    of that scope. A `CoroutineScope` can be a child of an existing `CoroutineScope`.
    See the next chapter on how to get a `CoroutineScope` or make one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `CoroutineScope` can be seen as a root coroutine. In fact, anything that has
    a `Job` can technically be considered a coroutine. The only difference is the
    intended usage. A scope is meant to encompass its child coroutines. As you’ve
    seen in the beginning of this chapter, a cancellation of a scope results in the
    cancellation of all of its child coroutines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`launch` is a coroutine builder which returns a `Job` instance. It is meant
    for “fire-and-forget.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`async` is a coroutine builder which can return values, very much like `Promise`
    and `Future`. It returns an instance of `Deferred<T>`, which is a specialized
    `Job`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `Job` is a handle on the lifecycle of a coroutine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The context of a newly created coroutine started with `launch` or `async`,
    the coroutine context, inherits from the scope context and from the context passed
    in as a parameter (the supplied context)—the latter taking precedence over the
    former. One context element is always freshly created: the `Job` of the coroutine.
    For example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A suspending function denotes a function which might not return immediately.
    Using `withContext` and the appropriate `Dispatcher`, any blocking function can
    be turned into a nonblocking suspending function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A coroutine is typically made of several calls to suspending functions. Every
    time a suspending function is invoked, a suspension point is reached. The execution
    of the coroutine is stopped at each of those suspension points, until it is resumed.^([10](ch07.html#idm46669749624320))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A final word on this chapter: *scope* and *context* are new notions and are
    just parts of the coroutine machinery. Other topics like *exception handling*
    and *cooperative cancellation* will be covered in the next chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch07.html#idm46669751105520-marker)) In this scenario, `job.cancel()`
    has no effect on the coroutine started by `launch`. We’ll touch on that in the
    next chapter (a coroutine must be cooperative with cancellation to be cancellable).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch07.html#idm46669750880912-marker)) This suspends the calling coroutine
    until the value is retrieved, or an exception is thrown if the coroutine started
    with `async` is cancelled or failed with an exception. More on that later in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([3](ch07.html#idm46669750870416-marker)) We assume that exceptions are handled
    and don’t interfere with the execution flow.
  prefs: []
  type: TYPE_NORMAL
- en: ^([4](ch07.html#idm46669750810416-marker)) The `join()` method of a thread causes
    the calling thread to go into a waiting state. It remains in a waiting state until
    the original thread terminates.
  prefs: []
  type: TYPE_NORMAL
- en: ^([5](ch07.html#idm46669750799248-marker)) A failure of an entity corresponds
    to any abnormal event the entity cannot recover from. This is typically implemented
    using unhandled or thrown exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: ^([6](ch07.html#idm46669750393056-marker)) You may have noticed that nothing
    prevents you from passing a `Job` instance inside the “provided context.” What
    happens then? Following the logic explained, this `Job` instance becomes the parent
    of the `Job` of the coroutine context (e.g., the newly created coroutine). So
    the scope is no longer the parent of the coroutine; the parent-child relationship
    is broken. This is the reason why doing this is strongly discouraged, except in
    specific scenarios which will be explained in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([7](ch07.html#idm46669750312528-marker)) Actually, when a suspending function
    only invokes a single suspending function as a tail call, a state machine isn’t
    required.
  prefs: []
  type: TYPE_NORMAL
- en: ^([8](ch07.html#idm46669750309136-marker)) `viewModelScope` is coming from the
    AndroidX implementation of `ViewModel`. A `viewModelScope` is scoped to the `ViewModel`
    lifetime. More on that in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: ^([9](ch07.html#idm46669749681488-marker)) We’ll show you how to do this in
    [Chapter 8](ch08.html#coroutines_in_practice_id).
  prefs: []
  type: TYPE_NORMAL
- en: ^([10](ch07.html#idm46669749624320-marker)) The coroutine mechanism resumes
    a coroutine when the suspending function which caused it to suspend exits.
  prefs: []
  type: TYPE_NORMAL
