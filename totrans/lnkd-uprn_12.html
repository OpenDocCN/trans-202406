<html><head></head><body><section data-pdf-bookmark="Chapter 12. Multicluster Communication with Linkerd" data-type="chapter" epub:type="chapter" class="preface"><div class="preface" id="LUAR_multicluster">
<h1 class="calibre7"><span class="calibre">Chapter 12. </span>Multicluster Communication with Linkerd</h1>


<p class="author1">Every Kubernetes cluster represents<a data-primary="multicluster setups" data-secondary="about" data-type="indexterm" id="id1569" class="calibre4"/> a single security and operational failure domain. As you look at scaling out your platform to accommodate more teams, more customers, and more use cases, you will inevitably run into the question of how you want to distribute your apps. Do you want to use large regional clusters with all your production apps in one place? Do you want to use purpose-built clusters for each app or each team? Most teams end up somewhere in the middle, with some shared clusters and some purpose-built for certain apps or categories of apps.</p>

<p class="author1">Linkerd aims to make the technical implementation problems around running multiple clusters easier to solve.</p>






<section data-pdf-bookmark="Types of Multicluster Setups" data-type="sect1" class="preface"><div class="preface" id="id176">
<h1 class="calibre8">Types of Multicluster Setups</h1>

<p class="author1">Linkerd supports two styles of<a data-primary="multicluster setups" data-secondary="types of" data-type="indexterm" id="id1570" class="calibre4"/> multicluster configurations: <em class="hyperlink">gateway-based
multicluster</em> and <em class="hyperlink">Pod-to-Pod multicluster</em>. Gateway-based multicluster setups are
easier to deploy; Pod-to-Pod setups offer more advanced functionality.
You can choose which is best for a given situation, and you can even use both
in the same cluster at the same time, if desired.</p>








<section data-pdf-bookmark="Gateway-Based Multicluster" data-type="sect2" class="preface"><div class="preface" id="id92">
<h2 class="calibre27">Gateway-Based Multicluster</h2>

<p class="author1">Linkerd’s gateway-based multicluster setup <a data-primary="multicluster setups" data-secondary="types of" data-tertiary="gateway-based multicluster" data-type="indexterm" id="id1571" class="calibre4"/><a data-primary="gateway-based multicluster" data-type="indexterm" id="id1572" class="calibre4"/><a data-primary="LoadBalancer Service" data-secondary="gateway-based multicluster" data-type="indexterm" id="id1573" class="calibre4"/>routes communications between clusters
through a special workload that Linkerd calls a gateway, which is reachable
via a LoadBalancer Service. This means that gateway-based multicluster
connections don’t require any particularly demanding network configuration:
all that’s required for gateway-based multicluster communications is that Pods
in a given cluster can connect to the LoadBalancer of the other cluster’s
gateway, no matter how that happens. <a data-primary="communication" data-secondary="secure communications" data-tertiary="gateway-based multicluster" data-type="indexterm" id="id1574" class="calibre4"/><a data-primary="security" data-secondary="secure communications" data-tertiary="gateway-based multicluster" data-type="indexterm" id="id1575" class="calibre4"/><a data-primary="mTLS (mutual TLS)" data-secondary="secure communications" data-tertiary="gateway-based multicluster" data-type="indexterm" id="id1576" class="calibre4"/>The network also doesn’t need to be
secure: Linkerd will take care of that with its usual mTLS.</p>

<p class="author1">The gateway-based multicluster architecture is shown in
<a data-type="xref" href="#gateway-based-multicluster" class="calibre4">Figure 12-1</a>.</p>

<figure class="calibre23"><div class="figure" id="gateway-based-multicluster">
<img alt="luar 1201" src="assets/luar_1201.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 12-1. </span>Gateway multicluster architecture</h6>
</div></figure>

<p class="author1">The numbers in the diagram show the number of network hops made when the <code class="calibre9">vote-bot</code> in cluster 1 talks to <code class="calibre9">web</code> in cluster 2, which then talks to <code class="calibre9">vote</code> back in cluster 1. (This actually happens in emojivoto.) Following the path, you’ll see a total of six hops. This can complicate things sometimes, which led to the development of Pod-to-Pod multicluster.</p>
</div></section>








<section data-pdf-bookmark="Pod-to-Pod Multicluster" data-type="sect2" class="preface"><div class="preface" id="id93">
<h2 class="calibre27">Pod-to-Pod Multicluster</h2>

<p class="author1">A Pod-to-Pod multicluster configuration, by contrast,<a data-primary="multicluster setups" data-secondary="types of" data-tertiary="Pod-to-Pod multicluster" data-type="indexterm" id="id1577" class="calibre4"/><a data-primary="Pod-to-Pod multicluster" data-type="indexterm" id="id1578" class="calibre4"/> relies on your Pods being able to talk
<em class="hyperlink">directly</em> to each other, even across cluster boundaries. This can be quite a
bit more challenging to set up, because your cluster provider needs to be able
to support it. If you’re creating your own bare-metal clusters, this is
probably quite possible. If you’re using a cloud provider, it will depend on
the provider.</p>

<p class="author1">The Pod-to-Pod multicluster architecture is shown in <a data-type="xref" href="#gatewayless-multicluster" class="calibre4">Figure 12-2</a>.</p>

<figure class="calibre23"><div class="figure" id="gatewayless-multicluster">
<img alt="luar 1202" src="assets/luar_1202.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 12-2. </span>Pod-to-Pod multicluster architecture</h6>
</div></figure>

<p class="author1">Following the path from <code class="calibre9">vote-bot</code> to <code class="calibre9">web</code> and back to <code class="calibre9">vote</code> here, we see only two hops, the same as we would see in a single cluster.</p>
</div></section>








<section data-pdf-bookmark="Gateways Versus Pod-to-Pod" data-type="sect2" class="preface"><div class="preface" id="id177">
<h2 class="calibre27">Gateways Versus Pod-to-Pod</h2>

<p class="author1">As with many things in computing, <a data-primary="multicluster setups" data-secondary="types of" data-tertiary="gateways versus Pod-to-Pod" data-type="indexterm" id="id1579" class="calibre4"/><a data-primary="gateway-based multicluster" data-secondary="Pod-to-Pod versus gateways" data-type="indexterm" id="id1580" class="calibre4"/><a data-primary="Pod-to-Pod multicluster" data-secondary="gateways versus Pod-to-Pod" data-type="indexterm" id="id1581" class="calibre4"/>the mode to choose depends on your situation:<a data-primary="identity" data-secondary="gateway in gateway-based multicluster" data-type="indexterm" id="id1582" class="calibre4"/></p>

<ul class="printings">
<li class="calibre6">
<p class="author1">The gateway-based multicluster mode is unquestionably simpler to set up; Pod-to-Pod
requires more advanced networking support.</p>
</li>
<li class="calibre6">
<p class="author1">Pod-to-Pod is marginally faster than gateway-based, since
there’s no hop through a gateway. With Linkerd this tends to be negligible,
though.</p>
</li>
<li class="calibre6">
<p class="author1">A potentially more important concern is that in a gateway-based multicluster setup,
any call from another cluster will appear as having the identity <em class="hyperlink">of the
gateway</em>, not the actual originating workload.</p>
</li>
<li class="calibre6">
<p class="author1">Another important concern is that in Pod-to-Pod mode, the Linkerd

<span class="calibre"><code class="calibre9">destination</code></span> service also needs to be able to connect to the remote
Kubernetes API server.</p>
</li>
</ul>

<p class="author1">Remember that the two modes can coexist in the same cluster as long as you
have the correct IP connectivity. You have an enormous amount of flexibility
in how you work with multicluster communications.</p>
</div></section>
</div></section>






<section data-pdf-bookmark="Multicluster Certificates" data-type="sect1" class="preface"><div class="preface" id="id178">
<h1 class="calibre8">Multicluster Certificates</h1>

<p class="author1">Whichever kind of multicluster setup you<a data-primary="multicluster setups" data-secondary="certificates" data-type="indexterm" id="id1583" class="calibre4"/><a data-primary="certificates" data-secondary="multicluster setups" data-type="indexterm" id="id1584" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="multicluster setups" data-type="indexterm" id="id1585" class="calibre4"/><a data-primary="trust hierarchy of certificates" data-secondary="multicluster setups" data-type="indexterm" id="id1586" class="calibre4"/> decide to use, your clusters’ trust
hierarchies need a common root for Linkerd to establish a
multicluster connection between clusters. <a data-primary="trust anchor certificate" data-secondary="same trust anchor to multiple clusters" data-type="indexterm" id="id1587" class="calibre4"/><a data-primary="multicluster setups" data-secondary="same trust anchor to multiple clusters" data-type="indexterm" id="id1588" class="calibre4"/>By far the easiest way to do this is
to have them share a common trust anchor, as shown in
<a data-type="xref" href="#multicluster-trust-hierarchy-2" class="calibre4">Figure 12-3</a>. This also implies that if you want clusters
to be isolated from each other, they <em class="hyperlink">must not</em> share the same trust anchor!</p>

<figure class="calibre23"><div class="figure" id="multicluster-trust-hierarchy-2">
<img alt="luar 1203" src="assets/luar_1203.png" class="calibre24"/>
<h6 class="calibre25"><span class="calibre">Figure 12-3. </span>A multicluster trust hierarchy</h6>
</div></figure>

<p class="author1">The simplest way to manage this is usually to have a single trust anchor for
each environment level (Dev, UAT, Production, Test, etc.), so that, for example,
development clusters can peer with each other but not with production
clusters. <a data-primary="certifying authorities (CAs)" data-secondary="multicluster setups" data-type="indexterm" id="id1589" class="calibre4"/><a data-primary="private keys" data-secondary="certifying authorities" data-tertiary="multicluster setups" data-type="indexterm" id="id1590" class="calibre4"/>Likewise, it’s often simplest to set up a CA for each of these
levels, too, so that each CA needs to worry about only one kind of
certificate.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Don’t Share Identity Issuers</h1>
<p class="author1">Even in multicluster setups, your<a data-primary="identity issuer certificate" data-secondary="same certificate in two clusters" data-type="indexterm" id="id1591" class="calibre4"/> clusters should not share identity issuer
certificates. Keeping the identity issuers separate is important both for
being certain of where a given workload identity originated and for
simplifying the operational aspects of rotating the identity issuers.</p>
</div>

<p class="author1">Ultimately, the needs of your environment will dictate how you set up
certificates and CAs.</p>
</div></section>






<section data-pdf-bookmark="Cross-Cluster Service Discovery" data-type="sect1" class="preface"><div class="preface" id="id94">
<h1 class="calibre8">Cross-Cluster Service Discovery</h1>

<p class="author1">The last piece of the multicluster puzzle<a data-primary="multicluster setups" data-secondary="service discovery" data-type="indexterm" id="id1592" class="calibre4"/><a data-primary="services" data-secondary="multicluster service discovery" data-type="indexterm" id="id1593" class="calibre4"/><a data-primary="services" data-secondary="service mirror" data-type="indexterm" id="id1594" class="calibre4"/><a data-primary="service mirror" data-type="indexterm" id="id1595" class="calibre4"/><a data-primary="control plane of Linkerd" data-secondary="extensions" data-tertiary="multicluster extension service mirror" data-type="indexterm" id="id1596" class="calibre4"/><a data-primary="Services" data-secondary="service mirror" data-type="indexterm" id="id1597" class="calibre4"/><a data-primary="traffic shifting" data-secondary="service mirror" data-type="indexterm" id="id1598" class="calibre4"/> is service discovery: how do
workloads in one cluster know where to find workloads in other clusters?
Linkerd tackles this problem with the <em class="hyperlink">service mirror</em>, which is a part of the
control plane supplied by the Multicluster extension.</p>

<p class="author1">As its name implies, the service mirror arranges for Services in one cluster
to appear in other clusters. <a data-primary="multicluster setups" data-secondary="types of" data-tertiary="mirrored Services and" data-type="indexterm" id="id1599" class="calibre4"/>Exactly how it sets up the mirrored Services
depends on the type of multicluster configuration you’re using:</p>
<dl class="calibre10">
<dt class="calibre11">Gateway-based multicluster</dt>
<dd class="calibre12">
<p class="calibre13">Connections to a <a data-primary="gateway-based multicluster" data-secondary="mirrored Services" data-type="indexterm" id="id1600" class="calibre4"/>mirrored Service will be
redirected to the gateway in front of the original Service. The gateway then
knows how to carry the requests on to a real Pod, including endpoint selection,
policy enforcement, etc.</p>
</dd>
<dt class="calibre11">Pod-to-Pod multicluster</dt>
<dd class="calibre12">
<p class="calibre13">Connections to a <a data-primary="Pod-to-Pod multicluster" data-secondary="mirrored Services" data-type="indexterm" id="id1601" class="calibre4"/>mirrored Service will simply transit the network directly to the other Pod. The Linkerd proxy next to the workload making the connection knows which endpoints are available directly, so it handles load balancing, policy enforcement, etc.</p>
</dd>
</dl>

<p class="author1">The service mirror doesn’t blindly mirror every Service; it only
mirrors those with a <code class="calibre9">mirror.linkerd.io/exported</code> label. The value of the
label, again, depends on the multicluster mode:</p>
<dl class="calibre10">
<dt class="calibre11"><code class="calibre14">mirror.linkerd.io/exported: true</code></dt>
<dd class="calibre12">
<p class="calibre13">For gateway-based multicluster configurations. The
service mirror will expect there to be a gateway for the remote cluster, and
it will set up the mirrored Service to use it.</p>
</dd>
<dt class="calibre11"><code class="calibre14">mirror.linkerd.io/exported: remote-discovery</code></dt>
<dd class="calibre12">
<p class="calibre13">For Pod-to-Pod
multicluster configurations. The service mirror will set up the mirrored Service to go directly
to the original Pods.</p>
</dd>
</dl>

<p class="author1">It’s also worth noting that <a data-primary="permissions" data-secondary="service mirror talking to remote server" data-type="indexterm" id="id1602" class="calibre4"/><a data-primary="Linkerd Link resource for service mirror credentials" data-type="indexterm" id="id1603" class="calibre4"/><a data-primary="service mirror" data-secondary="credentials via Linkerd Link" data-type="indexterm" id="id1604" class="calibre4"/><a data-primary="services" data-secondary="service mirror" data-tertiary="credentials via Linkerd Link" data-type="indexterm" id="id1605" class="calibre4"/><a data-primary="Services" data-secondary="service mirror" data-tertiary="credentials via Linkerd Link" data-type="indexterm" id="id1606" class="calibre4"/>the service mirror needs permission to talk to
the remote cluster’s Kubernetes API server. Credentials for this are handled
by the Linkerd Link resource, created with the <code class="calibre9">linkerd multicluster link</code> CLI
command.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Links and GitOps</h1>
<p class="author1">Link resources are actually a little bit more imperative than they should be:
running the <code class="calibre9">linkerd multicluster link</code> command<a data-primary="Secrets" data-secondary="credentials for service mirror" data-type="indexterm" id="id1607" class="calibre4"/> creates a credentials Secret,
a Link resource, and the service mirror controller. Unfortunately, it’s
extremely hard to replicate everything without actually running the command
right now.</p>
</div>

<p class="author1">With all of that background, we can start setting up an example multicluster

<span class="calibre">architecture.</span></p>
</div></section>






<section data-pdf-bookmark="Setting Up for Multicluster" data-type="sect1" class="preface"><div class="preface" id="id95">
<h1 class="calibre8">Setting Up for Multicluster</h1>

<p class="author1">Multicluster Linkerd <em class="hyperlink">always</em> requires<a data-primary="multicluster setups" data-secondary="setting up" data-type="indexterm" id="ch12-muse" class="calibre4"/><a data-primary="k3d clusters in multicluster setup" data-type="indexterm" id="ch12-muse2" class="calibre4"/><a data-primary="gateway-based multicluster" data-secondary="setting up" data-type="indexterm" id="ch12-muse3" class="calibre4"/><a data-primary="Pod-to-Pod multicluster" data-secondary="setting up" data-type="indexterm" id="ch12-muse4" class="calibre4"/><a data-primary="Kubernetes" data-secondary="k3d clusters in multicluster setup" data-type="indexterm" id="ch12-muse5" class="calibre4"/><a data-primary="IP routing between clusters" data-type="indexterm" id="id1608" class="calibre4"/><a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="IP routing between clusters" data-type="indexterm" id="id1609" class="calibre4"/><a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="CIDR ranges distinct" data-type="indexterm" id="id1610" class="calibre4"/><a data-primary="CIDR (Classless Inter-Domain Routing)" data-secondary="multicluster setups" data-tertiary="CIDR ranges distinct" data-type="indexterm" id="id1611" class="calibre4"/> that you be able to route IP traffic between
your clusters. In some cases, it also requires that all clusters have
distinct, nonoverlapping cluster and service CIDR ranges.</p>

<p class="author1">Obviously, ensuring that these requirements are met is a bit outside the scope
of the service mesh! However, to demonstrate a multicluster setup in this
chapter, we’ll be creating two k3d clusters, and we’ll need to make sure the
requirements are met when we do so. We’ll call out where we’re doing k3d-specific infrastructure things as we go.</p>

<p class="author1">First, as shown in <a data-type="xref" href="#EX-mc-creating-clusters" class="calibre4">Example 12-1</a>, we’ll create two k3d clusters
attached to the same Docker network,<a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="CIDR ranges set up" data-type="indexterm" id="id1612" class="calibre4"/><a data-primary="CIDR (Classless Inter-Domain Routing)" data-secondary="multicluster setups" data-tertiary="setting up" data-type="indexterm" id="id1613" class="calibre4"/> and we’ll give them independent cluster and
service CIDRs so that we can use this setup either for gateway-based
multicluster or for Pod-to-Pod multicluster mode.</p>

<p class="author1">This entire block is k3d-specific, unsurprisingly!</p>
<div data-type="example" id="EX-mc-creating-clusters" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-1. </span>Creating clusters</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Create cluster1</code>
$<code class="w"> </code>k3d<code class="w"> </code>cluster<code class="w"> </code>create<code class="w"> </code>cluster1<code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--servers<code class="o">=</code><code class="m">1</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--network<code class="o">=</code>mc-network<code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--k3s-arg<code class="w"> </code><code class="s">'--disable=traefik@server:*'</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--k3s-arg<code class="w"> </code><code class="s">'--cluster-cidr=10.23.0.0/16@server:*'</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--k3s-arg<code class="w"> </code><code class="s">'--service-cidr=10.247.0.0/16@server:*'</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--wait<code class="w"/>

<code class="c"># Create cluster2</code>
$<code class="w"> </code>k3d<code class="w"> </code>cluster<code class="w"> </code>create<code class="w"> </code>cluster2<code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--servers<code class="o">=</code><code class="m">1</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--network<code class="o">=</code>mc-network<code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--k3s-arg<code class="w"> </code><code class="s">'--disable=traefik@server:*'</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--k3s-arg<code class="w"> </code><code class="s">'--cluster-cidr=10.22.0.0/16@server:*'</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--k3s-arg<code class="w"> </code><code class="s">'--service-cidr=10.246.0.0/16@server:*'</code><code class="w"> </code><code class="se">\</code>
<code class="w">    </code>--wait<code class="w"/></pre></div>

<p class="author1">Note that both clusters are told to use the same Docker network
(<code class="calibre9">--network=mc-network</code>), but they have independent, nonoverlapping CIDR
ranges.</p>

<p class="author1">We’ll continue by setting up<a data-primary="IP routing between clusters" data-secondary="setting up" data-type="indexterm" id="id1614" class="calibre4"/><a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="IP routing between clusters set up" data-type="indexterm" id="id1615" class="calibre4"/> IP routing between clusters, as shown in
<a data-type="xref" href="#EX-mc-ip-routing" class="calibre4">Example 12-2</a>. The <code class="calibre9">docker exec</code> commands here are k3d-specific, but the
idea of running the <code class="calibre9">ip route add</code> command on the Nodes themselves is actually not
k3d-specific.</p>
<div data-type="example" id="EX-mc-ip-routing" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-2. </span>Setting up IP routing</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># For each cluster, we need its Node IP and Pod CIDR range.</code>
$<code class="w"> </code><code class="nv">cluster1_node_ip</code><code class="o">=</code><code class="k">$(</code>kubectl<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>get<code class="w"> </code>node<code class="w"> </code>k3d-cluster1-server-0<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s">'{.status.addresses[?(.type=="InternalIP")].address}'</code><code class="k">)</code><code class="w"/>
$<code class="w"> </code><code class="nv">cluster1_pod_cidr</code><code class="o">=</code><code class="k">$(</code>kubectl<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>get<code class="w"> </code>node<code class="w"> </code>k3d-cluster1-server-0<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s">'{.spec.podCIDR}'</code><code class="k">)</code><code class="w"/>

$<code class="w"> </code><code class="nv">cluster2_node_ip</code><code class="o">=</code><code class="k">$(</code>kubectl<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>get<code class="w"> </code>node<code class="w"> </code>k3d-cluster2-server-0<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s">'{.status.addresses[?(.type=="InternalIP")].address}'</code><code class="k">)</code><code class="w"/>
$<code class="w"> </code><code class="nv">cluster2_pod_cidr</code><code class="o">=</code><code class="k">$(</code>kubectl<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>get<code class="w"> </code>node<code class="w"> </code>k3d-cluster2-server-0<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-o<code class="w"> </code><code class="nv">jsonpath</code><code class="o">=</code><code class="s">'{.spec.podCIDR}'</code><code class="k">)</code><code class="w"/>

<code class="c"># Once that's done, we'll run `ip route add` on each Node to set up IP</code>
<code class="c"># routing. We only need to do this once per cluster because these are</code>
<code class="c"># single-Node clusters.</code>
$<code class="w"> </code>docker<code class="w"> </code><code class="nb">exec</code><code class="w"> </code>-it<code class="w"> </code>k3d-cluster1-server-0<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>ip<code class="w"> </code>route<code class="w"> </code>add<code class="w"> </code><code class="si">${</code><code class="nv">cluster2_pod_cidr</code><code class="si">}</code><code class="w"> </code>via<code class="w"> </code><code class="si">${</code><code class="nv">cluster2_node_ip</code><code class="si">}</code><code class="w"/>
$<code class="w"> </code>docker<code class="w"> </code><code class="nb">exec</code><code class="w"> </code>-it<code class="w"> </code>k3d-cluster2-server-0<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>ip<code class="w"> </code>route<code class="w"> </code>add<code class="w"> </code><code class="si">${</code><code class="nv">cluster1_pod_cidr</code><code class="si">}</code><code class="w"> </code>via<code class="w"> </code><code class="si">${</code><code class="nv">cluster1_node_ip</code><code class="si">}</code><code class="w"/></pre></div>

<p class="author1">Once we have routing set up,<a data-primary="multicluster setups" data-secondary="certificates" data-tertiary="creating" data-type="indexterm" id="id1616" class="calibre4"/><a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="certificates" data-type="indexterm" id="id1617" class="calibre4"/><a data-primary="certificates" data-secondary="multicluster setups" data-tertiary="creating certificates" data-type="indexterm" id="id1618" class="calibre4"/><a data-primary="X.509 certificates" data-secondary="multicluster setups" data-tertiary="creating certificates" data-type="indexterm" id="id1619" class="calibre4"/><a data-primary="trust anchor certificate" data-secondary="same trust anchor to multiple clusters" data-tertiary="setting up" data-type="indexterm" id="id1620" class="calibre4"/> it’s time to create new certificates using <code class="calibre9">step</code>,
as shown in <a data-type="xref" href="#EX-mc-create-certs" class="calibre4">Example 12-3</a>. As noted previously, you’ll need to use the
same trust anchor for every cluster, no matter what kind of cluster you’re
using.</p>
<div data-type="example" id="EX-mc-create-certs" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-3. </span>Creating certificates for multicluster</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># First, create a trust anchor. This will be shared across all clusters.</code>
$<code class="w"> </code>step<code class="w"> </code>certificate<code class="w"> </code>create<code class="w"> </code>root.linkerd.cluster.local<code class="w"> </code>ca.crt<code class="w"> </code>ca.key<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--profile<code class="w"> </code>root-ca<code class="w"> </code>--no-password<code class="w"> </code>--insecure<code class="w"/>

<code class="c"># Next, use the trust anchor to create identity issuer certificates</code>
<code class="c"># (one for each cluster).</code>
$<code class="w"> </code>step<code class="w"> </code>certificate<code class="w"> </code>create<code class="w"> </code>identity.linkerd.cluster.local<code class="w"> </code>issuer1.crt<code class="w"> </code>issuer1.key<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--profile<code class="w"> </code>intermediate-ca<code class="w"> </code>--not-after<code class="w"> </code>8760h<code class="w"> </code>--no-password<code class="w"> </code>--insecure<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--ca<code class="w"> </code>ca.crt<code class="w"> </code>--ca-key<code class="w"> </code>ca.key<code class="w"/>

$<code class="w"> </code>step<code class="w"> </code>certificate<code class="w"> </code>create<code class="w"> </code>identity.linkerd.cluster.local<code class="w"> </code>issuer2.crt<code class="w"> </code>issuer2.key<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--profile<code class="w"> </code>intermediate-ca<code class="w"> </code>--not-after<code class="w"> </code>8760h<code class="w"> </code>--no-password<code class="w"> </code>--insecure<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--ca<code class="w"> </code>ca.crt<code class="w"> </code>--ca-key<code class="w"> </code>ca.key<code class="w"/></pre></div>

<p class="author1">Finally, given our certificates,<a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="Linkerd installation" data-type="indexterm" id="id1621" class="calibre4"/><a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="Linkerd Viz extension installation" data-type="indexterm" id="id1622" class="calibre4"/> we can install Linkerd and the Viz extension!
This is shown in <a data-type="xref" href="#EX-mc-install-linkerd" class="calibre4">Example 12-4</a>.</p>
<div data-type="warning" epub:type="warning" class="calibre18"><h1 class="calibre35">Be Careful of Contexts!</h1>
<p class="author1">We have personally made far more mistakes than we’d care to admit to when
working with multicluster setups. <a data-primary="multicluster setups" data-secondary="command run against wrong cluster" data-type="indexterm" id="id1623" class="calibre4"/><a data-primary="--context arguments in multicluster setups" data-primary-sortas="context arguments" data-type="indexterm" id="id1624" class="calibre4"/>A truly embarrassing amount of the time, the
problem was because we ran a <code class="calibre9">kubectl</code> command against the wrong cluster—so
pay attention to those <code class="calibre9">--context</code> arguments!</p>

<p class="author1">Alternatively, just set up a window<a data-primary="KUBECONFIG in multicluster setups" data-type="indexterm" id="id1625" class="calibre4"/><a data-primary="environment variables" data-secondary="KUBECONFIG in multicluster setups" data-type="indexterm" id="id1626" class="calibre4"/> for each cluster and work that way. This
works well if you have separate Kubernetes configuration files and can set
the <code class="calibre9">KUBECONFIG</code> variable differently depending on which cluster you want.</p>
</div>
<div data-type="example" id="EX-mc-install-linkerd" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-4. </span>Installing Linkerd</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Install Linkerd in cluster1...</code>
$<code class="w"> </code>linkerd<code class="w"> </code>install<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>--crds<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>install<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--identity-trust-anchors-file<code class="w"> </code>ca.crt<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--identity-issuer-certificate-file<code class="w"> </code>issuer1.crt<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--identity-issuer-key-file<code class="w"> </code>issuer1.key<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>install<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>check<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"/>

<code class="c"># ...then repeat for cluster2.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>install<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>--crds<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>install<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--identity-trust-anchors-file<code class="w"> </code>ca.crt<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--identity-issuer-certificate-file<code class="w"> </code>issuer2.crt<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--identity-issuer-key-file<code class="w"> </code>issuer2.key<code class="w"> </code><code class="se">\</code>
<code class="w">  </code><code class="p">|</code><code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>install<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>check<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"/></pre></div>

<p class="author1">At this point, we have to decide whether we’re using a gateway-based or
Pod-to-Pod multicluster architecture, because what we do from this point forward changes.<a data-startref="ch12-muse" data-type="indexterm" id="id1627" class="calibre4"/><a data-startref="ch12-muse2" data-type="indexterm" id="id1628" class="calibre4"/><a data-startref="ch12-muse4" data-type="indexterm" id="id1629" class="calibre4"/><a data-startref="ch12-muse5" data-type="indexterm" id="id1630" class="calibre4"/></p>








<section data-pdf-bookmark="Continuing with a Gateway-Based Setup" data-type="sect2" class="preface"><div class="preface" id="continuing_with_a_gateway-based_setup_ch12_LUAR_multicluster_1708965417142">
<h2 class="calibre27">Continuing with a Gateway-Based Setup</h2>

<p class="author1">If you want a Pod-to-Pod setup,<a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="continuing with gateway-based setup" data-type="indexterm" id="id1631" class="calibre4"/> skip ahead to <a data-type="xref" href="#continuing_with_a_pod-to-pod_setup_ch12_LUAR_multicluster_1708965399165" class="calibre4">“Continuing with a Pod-to-Pod Setup”</a>.</p>

<p class="author1">To continue with gateway-based multicluster mode,<a data-primary="Linkerd Multicluster extension" data-secondary="for gateway-based setup" data-type="indexterm" id="id1632" class="calibre4"/> we install the Linkerd
Multicluster extension as shown in <a data-type="xref" href="#EX-mc-install-with-gateways" class="calibre4">Example 12-5</a>. This
extension also ships with the core Linkerd CLI, so you needn’t install an
extra command to use it. This is the default way to install Linkerd Multicluster, since gateway-based
multicluster mode predates Pod-to-Pod.</p>
<div data-type="example" id="EX-mc-install-with-gateways" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-5. </span>Installing Linkerd Multicluster with gateways</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>install<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>check<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>install<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>check<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"/></pre></div>

<p class="author1">After that, we’ll need to link our clusters together using the gateways, as
shown in <a data-type="xref" href="#EX-mc-link-with-gateways" class="calibre4">Example 12-6</a>.</p>
<div data-type="note" epub:type="note" class="calibre16"><h1 class="calibre26">k3d and --api-server-address</h1>
<p class="author1">k3d clusters are weird: <a data-primary="k3d clusters in multicluster setup" data-secondary="localhost context override" data-type="indexterm" id="id1633" class="calibre4"/><a data-primary="Kubernetes" data-secondary="k3d clusters in multicluster setup" data-tertiary="localhost context override" data-type="indexterm" id="id1634" class="calibre4"/>they always create Kubernetes contexts that say that
the Kubernetes API server is on localhost. With our multicluster setup on the same
Docker network, our <code class="calibre9">cluster1</code> cannot use localhost to talk to <code class="calibre9">cluster2</code>,
or vice versa.</p>

<p class="author1">Therefore, for k3d, we have to use <code class="calibre9">--api-server-address</code> to override the
address with a routable IP address for the other cluster. This is specific to
k3d.<a data-startref="ch12-muse3" data-type="indexterm" id="id1635" class="calibre4"/></p>
</div>
<div data-type="example" id="EX-mc-link-with-gateways" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-6. </span>Linking the clusters with gateways</h5>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Link cluster1 to cluster2. Again, --api-server-address is k3d-specific.</code>
<code class="c"># PAY ATTENTION TO CONTEXTS! We run `linkerd multicluster link` in the</code>
<code class="c"># cluster1 context, then apply it in the cluster2 context.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>link<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--api-server-address<code class="w"> </code>https://<code class="si">${</code><code class="nv">cluster1_node_ip</code><code class="si">}</code>:6443<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--cluster-name<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>
<code class="w"> </code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Link cluster2 to cluster1. Again, --api-server-address is k3d-specific.</code>
<code class="c"># PAY ATTENTION TO CONTEXTS! We run `linkerd multicluster link` in the</code>
<code class="c"># cluster2 context, then apply it in the cluster1 context.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>link<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--api-server-address<code class="w"> </code>https://<code class="si">${</code><code class="nv">cluster2_node_ip</code><code class="si">}</code>:6443<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--cluster-name<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

<code class="c"># Ensure everything is healthy (note that this will fail for k3d, even</code>
<code class="c"># though things are working).</code>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>check<code class="w"/>

<code class="c"># Check on the gateways.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>gateways<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>gateways<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"/></pre></div>

<p class="author1">At this point, skip ahead to <a data-type="xref" href="#directions_and_contexts_ch12" class="calibre4">“Multicluster Gotchas”</a>.</p>
</div></section>








<section data-pdf-bookmark="Continuing with a Pod-to-Pod Setup" data-type="sect2" class="preface"><div class="preface" id="continuing_with_a_pod-to-pod_setup_ch12_LUAR_multicluster_1708965399165">
<h2 class="calibre27">Continuing with a Pod-to-Pod Setup</h2>

<p class="author1">If you want a gateway-based setup,<a data-primary="Pod-to-Pod multicluster" data-secondary="setting up" data-type="indexterm" id="id1636" class="calibre4"/><a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="continuing with Pod-to-Pod-based setup" data-type="indexterm" id="id1637" class="calibre4"/> go back to <a data-type="xref" href="#continuing_with_a_gateway-based_setup_ch12_LUAR_multicluster_1708965417142" class="calibre4">“Continuing with a Gateway-Based Setup”</a>.</p>

<p class="author1">To continue with Pod-to-Pod multicluster mode,<a data-primary="Linkerd Multicluster extension" data-secondary="for Pod-to-Pod setup" data-type="indexterm" id="id1638" class="calibre4"/> we install the Linkerd Multicluster
extension as shown in <a data-type="xref" href="#EX-mc-install-pod-to-pod" class="calibre4">Example 12-7</a>, using the <code class="calibre9">--gateway
false</code> flag.</p>
<div data-type="example" id="EX-mc-install-pod-to-pod" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-7. </span>Installing Linkerd Multicluster Pod-to-Pod</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>install<code class="w"> </code>--gateway<code class="w"> </code><code class="nb">false</code><code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>check<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"/>

$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>install<code class="w">  </code>--gateway<code class="w"> </code><code class="nb">false</code><code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>check<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"/></pre></div>

<p class="author1">Now we need to link our clusters, as
shown in <a data-type="xref" href="#EX-mc-link-pod-to-pod" class="calibre4">Example 12-8</a>. Again, we need the <code class="calibre9">--gateway false</code> flag (and we only need <code class="calibre9">--api-server-address</code> for k3d).</p>
<div data-type="example" id="EX-mc-link-pod-to-pod" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-8. </span>Linking the clusters Pod-to-Pod</h5>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Link cluster1 to cluster2. Again, --api-server-address is k3d-specific.</code>
<code class="c"># PAY ATTENTION TO CONTEXTS! We run `linkerd multicluster link` in the</code>
<code class="c"># cluster1 context, then apply it in the cluster2 context.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>link<code class="w"> </code>--gateway<code class="w"> </code><code class="nb">false</code><code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--api-server-address<code class="w"> </code>https://<code class="si">${</code><code class="nv">cluster1_node_ip</code><code class="si">}</code>:6443<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--cluster-name<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>
<code class="w"> </code></pre>

<pre class="calibre42" data-code-language="bash" data-type="programlisting"><code class="c"># Link cluster2 to cluster1. Again, --api-server-address is k3d-specific.</code>
<code class="c"># PAY ATTENTION TO CONTEXTS! We run `linkerd multicluster link` in the</code>
<code class="c"># cluster2 context, then apply it in the cluster1 context.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>link<code class="w"> </code>--gateway<code class="w"> </code><code class="nb">false</code><code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--api-server-address<code class="w"> </code>https://<code class="si">${</code><code class="nv">cluster2_node_ip</code><code class="si">}</code>:6443<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>--cluster-name<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="p">|</code><code class="w"/>
<code class="w">  </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>-<code class="w"/>

<code class="c"># Ensure everything is healthy (note that this will fail for k3d, even</code>
<code class="c"># though things are working).</code>
$<code class="w"> </code>linkerd<code class="w"> </code>multicluster<code class="w"> </code>check<code class="w"/></pre></div>
</div></section>








<section data-pdf-bookmark="Multicluster Gotchas" data-type="sect2" class="preface"><div class="preface" id="directions_and_contexts_ch12">
<h2 class="calibre27">Multicluster Gotchas</h2>

<p class="author1">Irrespective of whether you’re setting up for gateway-based multicluster or Pod-to-Pod multicluster, there are two things that are always very important to bear in mind:</p>
<dl class="calibre10">
<dt class="calibre11">Directions, contexts, and links</dt>
<dd class="calibre12">
<p class="calibre13">Every <code class="calibre9">linkerd multicluster link</code> command<a data-primary="linkerd" data-secondary="multicluster link command" data-type="indexterm" id="id1639" class="calibre4"/><a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="linkerd multicluster link command" data-type="indexterm" id="id1640" class="calibre4"/> creates a unidirectional link.
Running a <code class="calibre9">link</code> command in the <code class="calibre9">cluster1</code> context and applying it to the
<code class="calibre9">cluster2</code> context is giving <code class="calibre9">cluster2</code> the permissions and DNS information
needed to communicate with <code class="calibre9">cluster1</code>. Basically, running the <code class="calibre9">link</code> command
in the <code class="calibre9">cluster1</code> context gathers information and credentials <em class="hyperlink">about</em>
<code class="calibre9">cluster1</code>; applying it in the <code class="calibre9">cluster2</code> context gives everything <em class="hyperlink">to</em>
<code class="calibre9">cluster2</code>.</p>

<p class="calibre13">In our example setup (whether gateway or Pod-to-Pod), we run two
links, one in each direction. In most two-cluster setups, this makes sense,
but it’s definitely not required.</p>
</dd>
<dt class="calibre11">Checking Your connections</dt>
<dd class="calibre12">
<p class="calibre13">We’ve helped a lot of folks troubleshoot<a data-primary="multicluster setups" data-secondary="setting up" data-tertiary="connectivity check" data-type="indexterm" id="id1641" class="calibre4"/><a data-primary="debugging" data-secondary="multicluster setup connectivity check" data-type="indexterm" id="id1642" class="calibre4"/><a data-primary="connectivity check for multicluster setups" data-type="indexterm" id="id1643" class="calibre4"/> their multicluster setups, and the
most common problem we’ve seen is a lack of connectivity between the clusters.
When you’re debugging multicluster setups, the first thing to check is
<em class="hyperlink">always</em> to make sure that you have the appropriate connectivity between your
clusters.</p>

<p class="calibre13">You can usually do this very effectively simply by running a Pod in one
cluster with tools like <code class="calibre9">curl</code>, <code class="calibre9">dig</code>, etc., and then trying to make simple
HTTP calls to the other cluster.</p>
</dd>
</dl>
</div></section>
</div></section>






<section data-pdf-bookmark="Deploying and Connecting an Application" data-type="sect1" class="preface"><div class="preface" id="id98">
<h1 class="calibre8">Deploying and Connecting an Application</h1>

<p class="author1">At this point, we have our clusters connected,<a data-primary="multicluster setups" data-secondary="application deployment" data-type="indexterm" id="ch12-appdep" class="calibre4"/><a data-primary="applications" data-secondary="deploying in multicluster setups" data-type="indexterm" id="ch12-appdep2" class="calibre4"/><a data-primary="emojivoto application" data-secondary="deploying in multicluster setups" data-type="indexterm" id="ch12-appdep3" class="calibre4"/><a data-primary="applications" data-secondary="used in examples" data-see="booksapp application; emojivoto application" data-type="indexterm" id="id1644" class="calibre4"/> and we need to begin taking
advantage of our links. In <a data-type="xref" href="#EX-mc-install-emojivoto" class="calibre4">Example 12-9</a> we will deploy the
<a href="https://oreil.ly/qfGlx" class="calibre4">emojivoto sample application</a> across
two clusters.</p>
<div class="calibre40" data-type="example" id="EX-mc-install-emojivoto">
<h5 class="calibre41"><span class="calibre">Example 12-9. </span>Deploying a multicluster application</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Pull down the luar repo if you don't already have it.</code>
$<code class="w"> </code>git<code class="w"> </code>clone<code class="w"> </code>https://github.com/linkerd-book/luar.git<code class="w"/>

<code class="c"># Create the emojivoto ns in each cluster.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>luar/multicluster/ns.yaml<code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>luar/multicluster/ns.yaml<code class="w"/>

<code class="c"># This will ensure that all new Pods come up with</code>
<code class="c"># the Linkerd proxy.</code>

<code class="c"># Start the backing services in cluster2.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>luar/multicluster/emoji.yaml<code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>-f<code class="w"> </code>luar/multicluster/voting.yaml<code class="w"/>

<code class="c"># Start the web frontend and traffic generator in</code>
<code class="c"># cluster1.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>apply<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>-f<code class="w"> </code>luar/multicluster/web.yaml<code class="w"/>

<code class="c"># Check on the Pods in each cluster.</code>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>pods<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"/></pre></div>

<p class="author1">At this point, the Pods will be running in each cluster, but they have no
information about how to talk to each other. You can verify this simply by
looking at the Services in each cluster, as shown in <a data-type="xref" href="#EX-mc-check-services" class="calibre4">Example 12-10</a>.</p>
<div data-type="example" id="EX-mc-check-services" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-10. </span>Checking the Services in each cluster</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>svc<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>svc<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"/></pre></div>

<p class="author1">To make emojivoto work in our scenario,<a data-primary="service mirror" data-secondary="multicluster application deployment" data-type="indexterm" id="id1645" class="calibre4"/><a data-primary="services" data-secondary="service mirror" data-tertiary="multicluster application deployment" data-type="indexterm" id="id1646" class="calibre4"/><a data-primary="Services" data-secondary="service mirror" data-tertiary="multicluster application deployment" data-type="indexterm" id="id1647" class="calibre4"/><a data-primary="mirroring services" data-see="service mirror" data-type="indexterm" id="id1648" class="calibre4"/><a data-primary="traffic shifting" data-secondary="service mirror" data-type="indexterm" id="id1649" class="calibre4"/> we’ll need to mirror
services across the clusters. For each Service we want exported, we’ll add the
<code class="calibre9">mirror.link⁠erd.io/exported</code> label to it:</p>

<ul class="printings">
<li class="calibre6">
<p class="author1">If you’re using gateway-based multicluster mode, use <code class="calibre9">mirror.link⁠erd.io/exported:
true</code>, as shown in <a data-type="xref" href="#EX-mc-export-with-gateways" class="calibre4">Example 12-11</a>.</p>
</li>
<li class="calibre6">
<p class="author1">If you’re using Pod-to-Pod multicluster mode, use <code class="calibre9">mirror.link⁠erd.io/exported: remote-discovery</code>, as shown in <a data-type="xref" href="#EX-mc-export-pod-to-pod" class="calibre4">Example 12-12</a>.</p>
</li>
</ul>
<div class="calibre40" data-type="example" id="EX-mc-export-with-gateways">
<h5 class="calibre41"><span class="calibre">Example 12-11. </span>Exporting Services with gateways</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>kubectl<code class="w"> </code>--context<code class="o">=</code>k3d-cluster1<code class="w"> </code>label<code class="w"> </code>svc<code class="w"> </code>web-svc<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>mirror.linkerd.io/exported<code class="o">=</code><code class="nb">true</code><code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>--context<code class="o">=</code>k3d-cluster2<code class="w"> </code>label<code class="w"> </code>svc<code class="w"> </code>emoji-svc<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>mirror.linkerd.io/exported<code class="o">=</code><code class="nb">true</code><code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>--context<code class="o">=</code>k3d-cluster2<code class="w"> </code>label<code class="w"> </code>svc<code class="w"> </code>voting-svc<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>mirror.linkerd.io/exported<code class="o">=</code><code class="nb">true</code><code class="w"/></pre></div>
<div data-type="example" id="EX-mc-export-pod-to-pod" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-12. </span>Exporting Services Pod-to-Pod</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>kubectl<code class="w"> </code>--context<code class="o">=</code>k3d-cluster1<code class="w"> </code>label<code class="w"> </code>svc<code class="w"> </code>web-svc<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>mirror.linkerd.io/exported<code class="o">=</code>remote-discovery<code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>--context<code class="o">=</code>k3d-cluster2<code class="w"> </code>label<code class="w"> </code>svc<code class="w"> </code>emoji-svc<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>mirror.linkerd.io/exported<code class="o">=</code>remote-discovery<code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>--context<code class="o">=</code>k3d-cluster2<code class="w"> </code>label<code class="w"> </code>svc<code class="w"> </code>voting-svc<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>mirror.linkerd.io/exported<code class="o">=</code>remote-discovery<code class="w"/></pre></div>

<p class="author1">In either case, if you check the Services in the <code class="calibre9">emojivoto</code> namespace, as
shown in <a data-type="xref" href="#EX-mc-check-mirrored-services" class="calibre4">Example 12-13</a>, you’ll see the mirrored Services.</p>
<div data-type="example" id="EX-mc-check-mirrored-services" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-13. </span>Checking on mirrored Services</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>svc<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"/>
$<code class="w"> </code>kubectl<code class="w"> </code>get<code class="w"> </code>svc<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"/></pre></div>

<p class="author1">If using Pod-to-Pod multicluster mode, you can also use <code class="calibre9">linkerd diagnostics
endpoints</code> to check that everything is working correctly, as shown in

<span class="calibre"><a data-type="xref" href="#EX-mc-diag-endpoints" class="calibre4">Example 12-14</a>.</span></p>
<div data-type="example" id="EX-mc-diag-endpoints" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-14. </span>Checking on Service endpoints</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42"><code class="c"># Any valid Service DNS name should work here.</code>
$<code class="w"> </code>linkerd<code class="w"> </code>diagnostics<code class="w"> </code>endpoints<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>emoji-svc-cluster2.linkerd-multicluster.svc.cluster.local<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>diagnostics<code class="w"> </code>endpoints<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code><code class="se">\</code>
<code class="w">  </code>web-svc-cluster1.linkerd-multicluster.svc.cluster.local<code class="w"/></pre></div>

<p class="author1">As implied by <a data-type="xref" href="#EX-mc-diag-endpoints" class="calibre4">Example 12-14</a>, mirrored Services appear as
<code class="calibre9"><em class="calibre37">serviceName-clusterName</em></code>; for example, the <code class="calibre9">emoji-svc</code> mirrored from <code class="calibre9">cluster2</code>
into <code class="calibre9">cluster1</code> will appear as <code class="calibre9">emoji-svc-cluster2</code>.</p>

<p class="author1">This is a rare case where, by default, the application may have to change to
work with Linkerd. The manifests that we applied in
<a data-type="xref" href="#EX-mc-install-emojivoto" class="calibre4">Example 12-9</a> have already been tweaked so that the emojivoto
app uses the mirrored Service names, <a data-primary="traffic shifting" data-secondary="Gateway API HTTPRoute resource" data-type="indexterm" id="id1650" class="calibre4"/><a data-primary="HTTPRoute resource" data-secondary="traffic shifting" data-tertiary="placeholder Service" data-type="indexterm" id="id1651" class="calibre4"/><a data-primary="traffic shifting" data-secondary="HTTPRoute with placeholder Service" data-type="indexterm" id="id1652" class="calibre4"/>but you can also use an HTTPRoute and a
placeholder Service to redirect traffic.</p>

<p class="author1">For example, suppose we want all traffic for <code class="calibre9">emoji-svc</code> to be redirected to <code class="calibre9">emoji-svc-cluster2</code>. We could start by creating a Service named <code class="calibre9">emoji-svc</code> with no 
<span class="calibre"><code class="calibre9">selector</code>,</span> so that it’s simply not possible for that Service to match any Pods. This is shown in <a data-type="xref" href="#EX-mc-placeholder-service" class="calibre4">Example 12-15</a>.</p>
<div data-type="example" id="EX-mc-placeholder-service" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-15. </span>A placeholder <code class="calibre9">emoji-svc</code> Service</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nn">---</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">v1</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">Service</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">emoji-svc</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">emojivoto</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">type</code><code class="p">:</code><code class="w"> </code><code class="calibre9">ClusterIP</code><code class="w"/>
<code class="w">  </code><code class="nt">ports</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">80</code><code class="w"/>
<code class="w">    </code><code class="nt">targetPort</code><code class="p">:</code><code class="w"> </code><code class="calibre9">http</code><code class="w"/></pre></div>

<p class="author1">We can then associate an HTTPRoute with the placeholder Service to redirect all the traffic, as shown in <a data-type="xref" href="#EX-mc-redirect-placeholder" class="calibre4">Example 12-16</a>.<a data-startref="ch12-appdep" data-type="indexterm" id="id1653" class="calibre4"/><a data-startref="ch12-appdep2" data-type="indexterm" id="id1654" class="calibre4"/><a data-startref="ch12-appdep3" data-type="indexterm" id="id1655" class="calibre4"/></p>
<div data-type="example" id="EX-mc-redirect-placeholder" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-16. </span>Redirecting all traffic to the placeholder <code class="calibre9">emoji-svc</code> Service</h5>

<pre data-code-language="yaml" data-type="programlisting" class="calibre42"><code class="nn">---</code><code class="w"/>
<code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre9">policy.linkerd.io/v1beta3</code><code class="w"/>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">HTTPRoute</code><code class="w"/>
<code class="nt">metadata</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">emoji-svc-route</code><code class="w"/>
<code class="w">  </code><code class="nt">namespace</code><code class="p">:</code><code class="w"> </code><code class="calibre9">emojivoto</code><code class="w"/>
<code class="nt">spec</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">parentRefs</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">emoji-svc</code><code class="w"/>
<code class="w">      </code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre9">Service</code><code class="w"/>
<code class="w">      </code><code class="nt">group</code><code class="p">:</code><code class="w"> </code><code class="s">""</code><code class="w"/>
<code class="w">      </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">80</code><code class="w"/>
<code class="w">  </code><code class="nt">rules</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">backendRefs</code><code class="p">:</code><code class="w"/>
<code class="w">    </code><code class="calibre9">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre9">emoji-svc-cluster2</code><code class="w"/>
<code class="w">      </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre9">80</code><code class="w"/>
<code class="w">      </code><code class="nt">weight</code><code class="p">:</code><code class="w"> </code><code class="calibre9">100</code><code class="w"/>
<code class="w">    </code><code class="nt">timeouts</code><code class="p">:</code><code class="w"/>
<code class="w">      </code><code class="nt">request</code><code class="p">:</code><code class="w"> </code><code class="calibre9">5s</code><code class="w"/></pre></div>
</div></section>






<section data-pdf-bookmark="Checking Traffic" data-type="sect1" class="preface"><div class="preface" id="id180">
<h1 class="calibre8">Checking Traffic</h1>

<p class="author1">At this point, traffic should be<a data-primary="multicluster setups" data-secondary="application deployment" data-tertiary="traffic" data-type="indexterm" id="id1656" class="calibre4"/><a data-primary="multicluster setups" data-secondary="traffic" data-type="indexterm" id="id1657" class="calibre4"/><a data-primary="traffic" data-secondary="multicluster setups" data-type="indexterm" id="id1658" class="calibre4"/> flowing across clusters and the emojivoto
application should be working, as you should be able to see by pointing a web
browser to the <code class="calibre9">web-svc</code> service in <code class="calibre9">cluster1</code>, as shown in
<a data-type="xref" href="#EX-mc-browser-time" class="calibre4">Example 12-17</a>.</p>
<div data-type="example" id="EX-mc-browser-time" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-17. </span>Checking out emojivoto with a browser</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>kubectl<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>port-forward<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>web-svc<code class="w"> </code><code class="m">8080</code>:80<code class="w"> </code><code class="p">&amp;</code><code class="w"/>

<code class="c"># Open a browser to http://localhost:8000/ here</code></pre></div>

<p class="author1">You can also watch traffic flowing<a data-primary="Linkerd Viz extension" data-secondary="traffic flow" data-type="indexterm" id="id1659" class="calibre4"/> in the Linkerd Viz dashboard, accessible by
running either command shown in <a data-type="xref" href="#EX-mc-viz" class="calibre4">Example 12-18</a>, or by using the CLI commands in <a data-type="xref" href="#EX-mc-viz-cli" class="calibre4">Example 12-19</a>.</p>
<div data-type="example" id="EX-mc-viz" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-18. </span>Multicluster Linkerd Viz dashboard</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>linkerd<code class="w">  </code>--context<code class="w"> </code>k3d-cluster1<code class="w"> </code>viz<code class="w"> </code>dashboard<code class="w"/>
$<code class="w"> </code>linkerd<code class="w">  </code>--context<code class="w"> </code>k3d-cluster2<code class="w"> </code>viz<code class="w"> </code>dashboard<code class="w"/></pre></div>
<div data-type="example" id="EX-mc-viz-cli" class="calibre40">
<h5 class="calibre41"><span class="calibre">Example 12-19. </span>Multicluster Linkerd Viz CLI</h5>

<pre data-code-language="bash" data-type="programlisting" class="calibre42">$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>service<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>--context<code class="w"> </code>k3d-cluster1<code class="w"/>
$<code class="w"> </code>linkerd<code class="w"> </code>viz<code class="w"> </code>stat<code class="w"> </code>service<code class="w"> </code>-n<code class="w"> </code>emojivoto<code class="w"> </code>--context<code class="w"> </code>k3d-cluster2<code class="w"/></pre></div>

<p class="author1">However you look at it, you should be able to see traffic flowing across
clusters.</p>
</div></section>






<section data-pdf-bookmark="Policy in Multicluster Environments" data-type="sect1" class="preface"><div class="preface" id="id181">
<h1 class="calibre8">Policy in Multicluster Environments</h1>

<p class="author1">There’s one more thing to cover before we close out the chapter. <a data-primary="multicluster setups" data-secondary="policy" data-type="indexterm" id="id1660" class="calibre4"/><a data-primary="policy" data-secondary="multicluster setups" data-type="indexterm" id="id1661" class="calibre4"/><a data-primary="multicluster setups" data-secondary="types of" data-tertiary="policy" data-type="indexterm" id="id1662" class="calibre4"/><a data-primary="gateway-based multicluster" data-secondary="policy" data-type="indexterm" id="id1663" class="calibre4"/><a data-primary="Pod-to-Pod multicluster" data-secondary="policy" data-type="indexterm" id="id1664" class="calibre4"/>Linkerd policy is
applicable not just within but also between clusters. However, as you saw in
Figures <a data-type="xref" data-xrefstyle="select:labelnumber" href="#gateway-based-multicluster" class="calibre4">12-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#gatewayless-multicluster" class="calibre4">12-2</a>, the two modes
work differently. When using gateway-based multicluster mode, the gateway itself is
where you need to apply any cross-cluster policy. It will accept policy configurations like
any other workload in the mesh.</p>

<p class="author1">Pod-to-Pod multicluster mode has the advantage of preserving the identity of the
originating workload when you make multicluster requests. That means you can
set a policy directly on your target workload to only accept requests from the
services that need to access it.</p>
</div></section>






<section class="preface" data-pdf-bookmark="Summary" data-type="sect1"><div class="preface" id="id328">
<h1 class="calibre8">Summary</h1>

<p class="author1">This chapter covered how multicluster architecture works in Linkerd and showed you how to set it up in a local environment. Linkerd’s multicluster features are robust, powerful, and used at scale by some of the largest organizations in the world. Consider how a multicluster setup could impact your environment and if it’s a good addition to your platform.</p>
</div></section>
</div></section></body></html>