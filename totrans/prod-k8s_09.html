<html><head></head><body><section data-pdf-bookmark="Chapter 8. Admission Control" data-type="chapter" epub:type="chapter"><div class="chapter" id="chapter8">&#13;
<h1><span class="label">Chapter 8. </span>Admission Control</h1>&#13;
&#13;
&#13;
<p>We have written many times in this book about the flexible, modular design of Kubernetes being one of its great strengths.<a data-primary="admission control" data-type="indexterm" id="ix_adctrl"/> Sensible defaults can be replaced, augmented, or built upon to provide alternative or more fully featured experiences for platform consumers. Admission control is one area that particularly benefits from this flexible design goal. Admission control is concerned with validating and mutating requests to the Kubernetes API server <em>before</em> they are persisted in etcd.<a data-primary="API server" data-secondary="admission control and" data-type="indexterm" id="idm45611985092136"/> This ability to intercept objects with fine granularity and control opens up a number of interesting use cases.&#13;
For example:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Ensuring that new objects cannot be created in a Namespace that is currently being deleted (in terminating state)</p>&#13;
</li>&#13;
<li>&#13;
<p>Enforcing that new Pods are not going to run as the root user</p>&#13;
</li>&#13;
<li>&#13;
<p>Making sure that the total sum of memory used by all the Pods in a Namespace does not exceed a user-defined limit</p>&#13;
</li>&#13;
<li>&#13;
<p>Ensuring that Ingress rules cannot be overwritten accidentally</p>&#13;
</li>&#13;
<li>&#13;
<p>Adding a sidecar container to every Pod (e.g., Istio)</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>First we’ll take a high-level look at the admission chain, which is the process all requests to the API server go through. Then we’ll move on to cover the in-tree controllers. These are built-in admission controllers that can be enabled and disabled via flags to the API server and enable some of the preceding use cases. Other use cases require more custom implementation and are integrated via a flexible webhook model. We’ll dedicate a lot of time to diving into the webhook model as it provides the most powerful and flexible options for integrating admission control into a cluster. Lastly, we’ll finish by covering Gatekeeper, which is an opinionated open source project that implements the webhook model and provides additional user-friendly functionality.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Further into this chapter we’ll dive into some code written in the Go programming language.<a data-primary="Go language" data-type="indexterm" id="idm45611985083480"/> Kubernetes and many other cloud native tools are implemented in Go due to its rapid speed of development, strong concurrency primitives, and clean design. It’s not necessary to know Go to understand most of this chapter (but we’d advise you to look into it if you’re interested in Kubernetes tooling), and we will discuss the trade-off of needing development skills when weighing custom versus off-the-shelf tooling choices.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Kubernetes Admission Chain" data-type="sect1"><div class="sect1" id="idm45611985081944">&#13;
<h1>The Kubernetes Admission Chain</h1>&#13;
&#13;
<p>Before we look closer at the functionality and mechanics <a data-primary="admission control" data-secondary="Kubernetes admission chain" data-type="indexterm" id="ix_adctrlKAC"/><a data-primary="API server" data-secondary="admission control and" data-tertiary="Kubernetes admission chain" data-type="indexterm" id="idm45611985079080"/>of individual controllers, let’s first understand the flow of requests to and from the Kubernetes API server as shown in <a data-type="xref" href="#admission_chain">Figure 8-1</a>.</p>&#13;
&#13;
<figure><div class="figure" id="admission_chain">&#13;
<img alt="prku 0801" src="assets/prku_0801.png"/>&#13;
<h6><span class="label">Figure 8-1. </span>Admission chain.</h6>&#13;
</div></figure>&#13;
&#13;
<p>Initially when requests arrive at the API server they are authenticated and authorized to ensure that the client is valid and able to perform the requested action (e.g., create a Pod in a specific Namespace) according to any configured RBAC rules.</p>&#13;
&#13;
<p>In the next stage, requests pass through mutating admission controllers represented by the leftmost blue box in <a data-type="xref" href="#admission_chain">Figure 8-1</a>. These can be built-in controllers or calls to external (out-of-tree) mutating webhooks (we’ll discuss these later in the chapter). These controllers are able to modify the resource attributes before they pass onto future phases. As an example of why this might be useful, let’s consider the Service Account controller (which is built in and enabled by default).<a data-primary="Service Account controller" data-type="indexterm" id="idm45611985072120"/> When a Pod is submitted, the Service Account controller inspects the Pod’s spec to ensure that it has the <code>serviceAccount</code> (SA) field set. If not, then it adds the field and sets it to the <code>default</code> SA for the Namespace. It also<a data-primary="ImagePullSecrets" data-type="indexterm" id="idm45611985070344"/> adds <code>ImagePullSecrets</code> and a Volume to allow the Pod to <a href="https://oreil.ly/K6e5E">access its Service Account token</a>.</p>&#13;
&#13;
<p class="pagebreak-before">Requests then undergo <a data-primary="schemas" data-secondary="validation on submission of objects" data-type="indexterm" id="idm45611985067752"/>schema validation to ensure that the object being submmitted is valid according to the defined schema. Here it ensures things like mandatory fields are set. This ordering is important as it means we can set fields in mutating admission controllers before the object is validated.</p>&#13;
&#13;
<p>The final stage before the object<a data-primary="validating admission controllers" data-type="indexterm" id="idm45611985065928"/> is persisted to etcd is for it to pass through validating admission controllers, represented by the rightmost blue box in <a data-type="xref" href="#admission_chain">Figure 8-1</a>. These can be built-in controllers or calls to external (out-of-tree) validating webhooks (we’ll briefly cover these later in the chapter). These validating controllers differ from mutating controllers in the sense that they are only able to admit or reject the request, <em>not</em> modify the payload. They differ from the prior <em>schema validation</em> step in that they are concerned with validating against operational logic, not a standardized schema.</p>&#13;
&#13;
<p>An example validating admission controller is the <code>NamespaceLifecycle</code> controller.<a data-primary="NamespaceLifecycle controller" data-type="indexterm" id="idm45611985061928"/> It has several jobs related to Namespaces, but the one we’ll take a look at is its responsibility to reject requests for new objects to be created in a Namespace that is currently being deleted. We can see the behavior in this code snippet:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// ensure that we're not trying to create objects in terminating Namespaces&#13;
</code><code class="k">if</code><code> </code><code class="nx">a</code><code class="p">.</code><code class="nx">GetOperation</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">==</code><code> </code><code class="nx">admission</code><code class="p">.</code><code class="nx">Create</code><code> </code><code class="p">{</code><code>&#13;
</code><code>  </code><code class="k">if</code><code> </code><code class="nx">namespace</code><code class="p">.</code><code class="nx">Status</code><code class="p">.</code><code class="nx">Phase</code><code> </code><code class="o">!=</code><code> </code><code class="nx">v1</code><code class="p">.</code><code class="nx">NamespaceTerminating</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="k">return</code><code> </code><code class="kc">nil</code><code> </code><a class="co" href="#callout_admission_control_CO1-1" id="co_admission_control_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code>  </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">admission</code><code class="p">.</code><code class="nx">NewForbidden</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Errorf</code><code class="p">(</code><code class="s">"unable to create new content in&#13;
  namespace %s because it is being terminated"</code><code class="p">,</code><code> </code><code class="nx">a</code><code class="p">.</code><code class="nx">GetNamespace</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">)</code><code>&#13;
</code><code>  </code><code class="k">if</code><code> </code><code class="nx">apierr</code><code class="p">,</code><code> </code><code class="nx">ok</code><code> </code><code class="o">:=</code><code> </code><code class="nx">err</code><code class="p">.</code><code class="p">(</code><code class="o">*</code><code class="nx">errors</code><code class="p">.</code><code class="nx">StatusError</code><code class="p">)</code><code class="p">;</code><code> </code><code class="nx">ok</code><code> </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="nx">apierr</code><code class="p">.</code><code class="nx">ErrStatus</code><code class="p">.</code><code class="nx">Details</code><code class="p">.</code><code class="nx">Causes</code><code> </code><code class="p">=</code><code> </code><code class="nb">append</code><code class="p">(</code><code class="nx">apierr</code><code class="p">.</code><code class="nx">ErrStatus</code><code class="p">.</code><code class="nx">Details</code><code class="p">.</code><code class="nx">Causes</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="nx">metav1</code><code class="p">.</code><code class="nx">StatusCause</code><code class="p">{</code><code>&#13;
</code><code>      </code><code class="nx">Type</code><code class="p">:</code><code>    </code><code class="nx">v1</code><code class="p">.</code><code class="nx">NamespaceTerminatingCause</code><code class="p">,</code><code>&#13;
</code><code>      </code><code class="nx">Message</code><code class="p">:</code><code> </code><code class="nx">fmt</code><code class="p">.</code><code class="nx">Sprintf</code><code class="p">(</code><code class="s">"namespace %s is being terminated"</code><code class="p">,</code><code> </code><code class="nx">a</code><code class="p">.</code><code class="nx">GetNamespace</code><code class="p">(</code><code class="p">)</code><code class="p">)</code><code class="p">,</code><code>&#13;
</code><code>      </code><code class="nx">Field</code><code class="p">:</code><code>   </code><code class="s">"metadata.namespace"</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="p">}</code><code class="p">)</code><code>&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
</code><code>  </code><code class="k">return</code><code> </code><code class="nx">err</code><code> </code><a class="co" href="#callout_admission_control_CO1-2" id="co_admission_control_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_admission_control_CO1-1" id="callout_admission_control_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>If the operation is a Create but the Namespace is currently <em>not</em> terminating, return no error. The request would pass this controller.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO1-2" id="callout_admission_control_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Else, return an API error stating that the Namespace is being terminated. If an error is returned, the request is denied.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>For a request to pass and the object to be persisted into etcd it must be admitted by <em>all</em> validating admission controllers. For it to be denied, only <em>one</em> controller needs to reject it.<a data-primary="admission control" data-secondary="Kubernetes admission chain" data-startref="ix_adctrlKAC" data-type="indexterm" id="idm45611984994088"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="In-Tree Admission Controllers" data-type="sect1"><div class="sect1" id="idm45611985081352">&#13;
<h1>In-Tree Admission Controllers</h1>&#13;
&#13;
<p>When Kubernetes was first released there was only a minimal number of interfaces <a data-primary="admission control" data-secondary="in-tree admission controllers" data-type="indexterm" id="idm45611984991144"/>for users to <em>plug in</em> or extend external functionality, such as the Container Network Interface (CNI). Other integrations with cloud providers, storage providers, and the implementation of admission controllers were all baked into the core Kubernetes code base and often described as being <em>in-tree</em>. Over time the project has sought to increase the number of pluggable interfaces, and we have seen the creation of the Container Storage Interface (CSI) and the movement toward external cloud &#13;
<span class="keep-together">providers</span>.</p>&#13;
&#13;
<p>Admission controllers are one area where many core features are still in-tree. Kubernetes ships with many different admission controllers that can be enabled or disabled by configuring API server flags.<a data-primary="API server" data-secondary="admission control and" data-tertiary="in-tree admission controllers" data-type="indexterm" id="idm45611984987288"/> This model has proved problematic for those users of cloud-managed Kubernetes platforms who historically did not have access to configure those flags.<a data-primary="Pod Security Policies (PSPs)" data-secondary="PSP controller" data-type="indexterm" id="idm45611984985736"/> PodSecurityPolicy (PSP) is an example of a controller that enables advanced and robust security capabilities across the cluster but is <em>not</em> enabled by default, therefore excluding users from benefitting from it.</p>&#13;
&#13;
<p>However, admission control is slowly following the trend of shifting code out of the API server and moving toward increased pluggability. The start of this process came with the addition of mutating and validating webhooks.<a data-primary="mutating webhooks" data-type="indexterm" id="idm45611984983448"/><a data-primary="validating webhooks" data-type="indexterm" id="idm45611984982744"/><a data-primary="webhooks" data-type="indexterm" id="idm45611984820776"/> These are two flexible admission controllers that allow us to specify that the API server should forward requests (that match specific criteria) and delegate admission decisions to external webhooks. We will discuss these in greater detail in the next section.</p>&#13;
&#13;
<p>Another step in this process is the <a href="https://github.com/kubernetes/enhancements/issues/5">announced deprecation</a> of the current PodSecurityPolicy built-in controller. Although there are multiple approaches to replace it, we think the implementation of PSPs will be delegated to an external admission controller, as the community continues to move code out of tree. In fact, we believe that more of the built-in admission controllers will be eventually moved out of tree. These would be replaced either by recommendations to utilize third-party tooling or standardized components that live in the Kubernetes upstream organization but not the core code base, thereby allowing users a sane default choice with the ability to replace if necessary.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>A subset of the built-in admission controllers is enabled by default. These are intended as a set of <em>sane defaults</em> that should work well for most clusters. We won’t replicate the list here, but you should take care to ensure the controllers you need are enabled. Also note that the UX for this feature can be a little confusing. To enable additional (nondefault) controllers you must use the <code>--enable-admission-plugins</code> flag to the API server, and to <em>disable</em> default controllers you must specify the <code>--disable-admission-plugins</code> list parameter.</p>&#13;
</div>&#13;
&#13;
<p>There is a lot of good information on the in-tree controllers available in the official Kubernetes documentation, so we’re not going to cover much more on them here. The real power of admission controllers is enabled by the two special validating and mutating webhooks, which is where we’re headed next!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Webhooks" data-type="sect1"><div class="sect1" id="idm45611984813864">&#13;
<h1>Webhooks</h1>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>All admission controllers sit in the <em>critical path</em> for requests going to the Kubernetes API server.<a data-primary="admission control" data-secondary="webhooks" data-type="indexterm" id="ix_adctrlwhk"/><a data-primary="webhooks" data-type="indexterm" id="ix_webhk"/><a data-primary="API server" data-secondary="admission control and" data-tertiary="webhooks" data-type="indexterm" id="idm45611984809064"/> They have varying scopes, so not all requests may be intercepted, but you should definitely be aware of this when enabling and/or injecting them. This is especially relevant when discussing webhook admission controllers for two reasons. First, they have added latency as they reside out of tree and must be called via HTTPS. Second, they have a broad potential scope of functionality, maybe even calling out to third-party systems. Great care should be taken to make admission controllers perform as efficiently as possible, returning at the earliest &#13;
<span class="keep-together">opportunity</span>.</p>&#13;
</div>&#13;
&#13;
<p>Webhooks are a special type of admission controller. We can configure the Kubernetes API server to send an API request to external webhook endpoints and receive a decision (whether the original request should be allowed, denied, or altered/mutated) response. This is incredibly powerful for a number of reasons:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The receiving web server can be written in any language that can expose an HTTPS listener. We can take advantage of web frameworks, libraries, and expertise that may be available to us to implement any logic we need to make admission decisions.</p>&#13;
</li>&#13;
<li>&#13;
<p>They can be run in or out of cluster. We can take advantage of the discovery and operator primitives that are available to us if we want to run them in-cluster, or we can implement reusable functionality in a serverless function, for example.</p>&#13;
</li>&#13;
<li>&#13;
<p>We are able to make callouts to systems and datastores external to Kubernetes to make policy decisions. For instance, we could query a centralized security system to check if specific images were approved for use in Kubernetes manifests.</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The API server will call webhooks over TLS, so webhooks must present certificates trusted by the Kubernetes API.<a data-primary="TLS" data-secondary="API server calling webhooks over" data-type="indexterm" id="idm45611984800648"/><a data-primary="certificates" data-secondary="required submission by webhooks" data-type="indexterm" id="idm45611984799608"/> This is often achieved by deploying Cert Manager into the cluster and automatically generating certificates. If running out of cluster, you will need to provision certificates that are trusted by the Kubernetes API server, either from a public root CA or some internal CA that Kubernetes is aware of.</p>&#13;
</div>&#13;
&#13;
<p>For the webhook model to work, there must be a defined schema for the request and response<a data-primary="schemas" data-secondary="for requests/responses between API server and webhook server" data-type="indexterm" id="idm45611984797576"/> messages exchanged between the API server and the webhook server.<a data-primary="AdmissionReview objects" data-type="indexterm" id="idm45611984957944"/><a data-primary="JSON" data-secondary="AdmissionReview objects" data-type="indexterm" id="idm45611984957272"/> In Kubernetes this is defined as an AdmissionReview object and is a JSON payload that contains information about the request, including:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>API version, group, and kind</p>&#13;
</li>&#13;
<li>&#13;
<p>Metadata such as the name and Namespace, and a unique ID to correlate it with the response decision</p>&#13;
</li>&#13;
<li>&#13;
<p>The operation attempted (e.g., CREATE)</p>&#13;
</li>&#13;
<li>&#13;
<p>Information about the user initiating the request including their group &#13;
<span class="keep-together">membership</span></p>&#13;
</li>&#13;
<li>&#13;
<p>Whether<a data-primary="dry runs" data-type="indexterm" id="idm45611984950664"/> this is a <em>dry run</em> request (this is important as we’ll see later when we discuss design considerations)</p>&#13;
</li>&#13;
<li>&#13;
<p>The actual resource</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>All of this information can be used by the receiving webhook to calculate an admission decision. Once decided, the server needs to respond with an AdmissionReview message of its own (this time with a <code>response</code> field). It will contain:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The unique ID from the request (for correlation)</p>&#13;
</li>&#13;
<li>&#13;
<p>Whether the request should be allowed to proceed</p>&#13;
</li>&#13;
<li>&#13;
<p>An optional customized error status and message</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Validating webhooks are <a data-primary="validating webhooks" data-type="indexterm" id="idm45611984943800"/>not able to modify the requests sent to them and can admit or reject only the original object. This restriction makes them fairly limited; however, they are a good fit when ensuring that objects applied to the cluster conform to security standards (specific user IDs, no host mounts, etc.) or contain all required metadata (internal team labels, annotations, etc.).</p>&#13;
&#13;
<p>In the case of a <em>mutating</em> webhook the response structure can also include a patch set (if desired).<a data-primary="mutating webhooks" data-type="indexterm" id="idm45611984941752"/><a data-primary="JSONPatch structure" data-type="indexterm" id="idm45611984941048"/> This is a base64-encoded string containing a valid JSONPatch structure encapsulating the changes that should be made to the request before it is admitted to the API server. If you want a more detailed explanation of all the fields and structure for AdmissionReview objects, then the <a href="https://oreil.ly/NWagy">official documentation</a> does a great job here.</p>&#13;
&#13;
<p>A simple example of a mutating controller might be one that adds a set of labels containing team- or workload-specific metadata to Pods or Deployments. Another more complex but common use of mutating controllers you may come across is the injection of a sidecar proxy in many service mesh implementations. The way this works is that the service mesh (Istio in this case) runs an admission controller that mutates Pod specs to add a sidecar container that will participate in the data plane of the mesh. This injection occurs by default but can be overridden by annotations at the Namespace or Pod level to provide additional control.</p>&#13;
&#13;
<p>This model is an effective way of enriching Deployments with additional functionality but hiding that complexity to improve the end-user experience. However, as with many decisions this can be a double-edged sword. One downside of mutating controllers is that visibility is removed from the end user, with objects being applied to the cluster that are not consistent with those that they originally created, potentially causing confusion if the user is unaware that mutating controllers are in operation on the cluster.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Configuring Webhook Admission Controllers" data-type="sect2"><div class="sect2" id="idm45611984937112">&#13;
<h2>Configuring Webhook Admission Controllers</h2>&#13;
&#13;
<p>Cluster administrators<a data-primary="webhooks" data-secondary="configuring webhook admission controllers" data-type="indexterm" id="ix_webhkcfg"/><a data-primary="admission control" data-secondary="webhooks" data-tertiary="configuring webhook admission controllers" data-type="indexterm" id="ix_adctrlwhkcfg"/> can use the MutatingWebhookConfiguration and ValidatingWebhookConfiguration kinds to specify the configuration of dynamic webhooks.<a data-primary="ValidatingWebhookConfiguration" data-type="indexterm" id="idm45611984932600"/><a data-primary="MutatingWebhookConfiguration" data-type="indexterm" id="idm45611984931864"/> Following is an annotated example briefly describing the relevant sections. We’ll dig into some of the more advanced considerations for some of these fields in the following section:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">admissionregistration.k8s.io/v1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">MutatingWebhookConfiguration</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">test-mutating-hook</code><code class="s">"</code><code>&#13;
</code><code class="nt">webhooks</code><code class="p">:</code><code>&#13;
</code><code class="p-Indicator">-</code><code> </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">test-mutating-hook</code><code class="s">"</code><code>&#13;
</code><code>  </code><code class="nt">rules</code><code class="p">:</code><code> </code><a class="co" href="#callout_admission_control_CO2-1" id="co_admission_control_CO2-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>  </code><code class="p-Indicator">-</code><code> </code><code class="nt">apiGroups</code><code class="p">:</code><code>   </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">"</code><code class="p-Indicator">]</code><code>&#13;
</code><code>    </code><code class="nt">apiVersions</code><code class="p">:</code><code> </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">v1</code><code class="s">"</code><code class="p-Indicator">]</code><code>&#13;
</code><code>    </code><code class="nt">operations</code><code class="p">:</code><code>  </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">CREATE</code><code class="s">"</code><code class="p-Indicator">]</code><code> </code><a class="co" href="#callout_admission_control_CO2-2" id="co_admission_control_CO2-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>    </code><code class="nt">resources</code><code class="p">:</code><code>   </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">pods</code><code class="s">"</code><code class="p-Indicator">]</code><code> </code><a class="co" href="#callout_admission_control_CO2-3" id="co_admission_control_CO2-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>    </code><code class="nt">scope</code><code class="p">:</code><code>       </code><code class="s">"</code><code class="s">Namespaced</code><code class="s">"</code><code> </code><a class="co" href="#callout_admission_control_CO2-4" id="co_admission_control_CO2-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code>  </code><code class="nt">clientConfig</code><code class="p">:</code><code> </code><a class="co" href="#callout_admission_control_CO2-5" id="co_admission_control_CO2-5"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code>    </code><code class="nt">service</code><code class="p">:</code><code>&#13;
</code><code>      </code><code class="nt">namespace</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">test-ns</code><code>&#13;
</code><code>      </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">test-service</code><code>&#13;
</code><code>      </code><code class="nt">path</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">/test-path</code><code>&#13;
</code><code>      </code><code class="nt">port</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">8443</code><code>&#13;
</code><code>    </code><code class="nt">caBundle</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">Ci0tLS0tQk...tLS0K</code><code class="s">"</code><code> </code><a class="co" href="#callout_admission_control_CO2-6" id="co_admission_control_CO2-6"><img alt="6" src="assets/6.png"/></a><code>&#13;
</code><code>  </code><code class="nt">admissionReviewVersions</code><code class="p">:</code><code> </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">v1</code><code class="s">"</code><code class="p-Indicator">,</code><code> </code><code class="s">"</code><code class="s">v1beta1</code><code class="s">"</code><code class="p-Indicator">]</code><code> </code><a class="co" href="#callout_admission_control_CO2-7" id="co_admission_control_CO2-7"><img alt="7" src="assets/7.png"/></a><code>&#13;
</code><code>  </code><code class="nt">sideEffects</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">None</code><code class="s">"</code><code> </code><a class="co" href="#callout_admission_control_CO2-8" id="co_admission_control_CO2-8"><img alt="8" src="assets/8.png"/></a><code>&#13;
</code><code>  </code><code class="nt">timeoutSeconds</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">5</code><code class="s">"</code><code> </code><a class="co" href="#callout_admission_control_CO2-9" id="co_admission_control_CO2-9"><img alt="9" src="assets/9.png"/></a><code>&#13;
</code><code>  </code><code class="nt">reinvocationPolicy</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">IfNeeded</code><code class="s">"</code><code> </code><a class="co" href="#callout_admission_control_CO2-10" id="co_admission_control_CO2-10"><img alt="10" src="assets/10.png"/></a><code>&#13;
</code><code>  </code><code class="nt">failurePolicy</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">Fail</code><code class="s">"</code><code> </code><a class="co" href="#callout_admission_control_CO2-11" id="co_admission_control_CO2-11"><img alt="11" src="assets/11.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_admission_control_CO2-1" id="callout_admission_control_CO2-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Matching rules. What API/kind/version/operations this webhook should be sent.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-2" id="callout_admission_control_CO2-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The operations that should trigger a call to the webhook.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-3" id="callout_admission_control_CO2-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Which kind to target.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-4" id="callout_admission_control_CO2-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Whether Namespace-scoped or cluster-scoped resources should be targeted.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-5" id="callout_admission_control_CO2-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Describes how the API server should connect to the webhook. In this case it’s in cluster at <em>test-service.test-ns.svc</em>.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-6" id="callout_admission_control_CO2-6"><img alt="6" src="assets/6.png"/></a></dt>&#13;
<dd><p>A PEM encoded CA bundle that will be used to validate the webhook’s server &#13;
<span class="keep-together">certificate</span>.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-7" id="callout_admission_control_CO2-7"><img alt="7" src="assets/7.png"/></a></dt>&#13;
<dd><p>Declare the <code>admissionReviewVersions</code> that the webhook supports.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-8" id="callout_admission_control_CO2-8"><img alt="8" src="assets/8.png"/></a></dt>&#13;
<dd><p>Describes whether the webhook has external side effects (calls/dependencies to external systems).</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-9" id="callout_admission_control_CO2-9"><img alt="9" src="assets/9.png"/></a></dt>&#13;
<dd><p>How long to wait until triggering the <code>failurePolicy</code>.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-10" id="callout_admission_control_CO2-10"><img alt="10" src="assets/10.png"/></a></dt>&#13;
<dd><p>Whether this webhook can be re-invoked (this may happen after other webhooks have been called).</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO2-11" id="callout_admission_control_CO2-11"><img alt="11" src="assets/11.png"/></a></dt>&#13;
<dd><p>Whether the webhook should fail <em>open</em> or <em>closed</em>. This has security implications.</p></dd>&#13;
</dl>&#13;
&#13;
<p>As you can see in the preceding configuration, we can be very granular about selecting which requests we want to intercept with our admission webhooks. For example, if we wanted to target only requests that are creating Secrets, we could use the following rule:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="c1"># &lt;...snip...&gt;</code><code>&#13;
</code><code class="nt">rules</code><code class="p">:</code><code> </code><a class="co" href="#callout_admission_control_CO3-1" id="co_admission_control_CO3-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="p-Indicator">-</code><code> </code><code class="nt">apiGroups</code><code class="p">:</code><code>   </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">"</code><code class="p-Indicator">]</code><code>&#13;
</code><code>  </code><code class="nt">apiVersions</code><code class="p">:</code><code> </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">v1</code><code class="s">"</code><code class="p-Indicator">]</code><code>&#13;
</code><code>  </code><code class="nt">operations</code><code class="p">:</code><code>  </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">CREATE</code><code class="s">"</code><code class="p-Indicator">]</code><code> </code><a class="co" href="#callout_admission_control_CO3-2" id="co_admission_control_CO3-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>  </code><code class="nt">resources</code><code class="p">:</code><code>   </code><code class="p-Indicator">[</code><code class="s">"</code><code class="s">secrets</code><code class="s">"</code><code class="p-Indicator">]</code><code> </code><a class="co" href="#callout_admission_control_CO3-3" id="co_admission_control_CO3-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code>  </code><code class="nt">scope</code><code class="p">:</code><code>       </code><code class="s">"</code><code class="s">Namespaced</code><code class="s">"</code><code> </code><a class="co" href="#callout_admission_control_CO3-4" id="co_admission_control_CO3-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
</code><code class="c1"># &lt;...snip...&gt;</code></pre>&#13;
&#13;
<p>We can additionally combine this with Namespace or object selectors, which enable further granularity.<a data-primary="Namespaces" data-secondary="targeting, admission controller webhooks" data-type="indexterm" id="idm45611984481768"/> These allow us to specify any number of Namespaces to target and/or objects with specific labels; for instance, in the following snippet we are choosing <a data-primary="secrets" data-secondary="targeting in webhook-enabled Namespace" data-type="indexterm" id="idm45611984480616"/>only Secrets that are in Namespaces that have label of <code>webhook: enabled</code>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="c1"># &lt;...snip...&gt;</code>&#13;
<code class="nt">namespaceSelector</code><code class="p">:</code>&#13;
  <code class="nt">matchExpressions</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">key</code><code class="p">:</code> <code class="l-Scalar-Plain">webhook</code>&#13;
    <code class="nt">operator</code><code class="p">:</code> <code class="l-Scalar-Plain">In</code>&#13;
    <code class="nt">values</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"enabled"</code><code class="p-Indicator">]</code>&#13;
<code class="c1"># &lt;...snip...&gt;</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Webhook Design Considerations" data-type="sect2"><div class="sect2" id="webhook_design">&#13;
<h2>Webhook Design Considerations</h2>&#13;
&#13;
<p>There are several factors to be mindful of when writing and implementing admission webhooks.<a data-primary="admission control" data-secondary="webhooks" data-startref="ix_adctrlwhkcfg" data-tertiary="configuring webhook admission controllers" data-type="indexterm" id="idm45611984432936"/><a data-primary="webhooks" data-secondary="configuring webhook admission controllers" data-startref="ix_webhkcfg" data-type="indexterm" id="idm45611984431448"/><a data-primary="webhooks" data-secondary="design considerations for admission controllers" data-type="indexterm" id="idm45611984430264"/><a data-primary="access control" data-secondary="webhooks" data-tertiary="design considerations" data-type="indexterm" id="idm45611984429352"/> We’ll talk more in detail about how these impact some real-world scenarios in the next section, but at a high level you should be aware of the following &#13;
<span class="keep-together">concerns</span>:</p>&#13;
<dl>&#13;
<dt>Failure modes</dt>&#13;
<dd>&#13;
<p>If a webhook is unreachable or sends an unknown response back to the API server, it is treated as failing.<a data-primary="failures" data-secondary="failure modes for admission webhooks" data-type="indexterm" id="idm45611984425288"/> Administrators must choose whether to fail <em>open</em> or <em>closed</em> in this situation by setting the <code>failurePolicy</code> field to <code>Ignore</code> (allow the request) or <code>Fail</code> (reject the request).</p>&#13;
</dd>&#13;
</dl>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>For security-related (or critical functionality) webhooks, <code>Fail</code> is the safest option. For noncritical hooks <code>Ignore</code> may be safe (potentially in conjunction with a reconciling controller as a backup). Combine these recommendations with those discussed under the performance item in this list.</p>&#13;
</div>&#13;
<dl>&#13;
<dt>Ordering</dt>&#13;
<dd>&#13;
<p>The first thing to note with regards to API server request flow is that mutating webhooks will all be called (potentially more than once) <em>before</em> validating webhooks are called.<a data-primary="mutating webhooks" data-secondary="called before validating webhooks" data-type="indexterm" id="idm45611984417480"/><a data-primary="validating webhooks" data-secondary="ordering of calls to" data-type="indexterm" id="idm45611984416536"/> This is important because it enables validating webhooks (which may reject a request based on security requirements) always to see the <em>final</em> version of a resource before it is applied.</p>&#13;
&#13;
<p>Mutating webhooks are not guaranteed to be called in a specific order and may be called multiple times if subsequent hooks modify a request. This can be modified by specifying the <code>reinvocationPolicy</code>, but ideally webhooks should be designed for idempotency to ensure ordering does not affect their functionality.</p>&#13;
</dd>&#13;
<dt>Performance</dt>&#13;
<dd>&#13;
<p>Webhooks are called as part of the critical path of requests flowing to the API server.<a data-primary="performance" data-secondary="webhook admission controllers" data-type="indexterm" id="idm45611984412392"/> If a webhook is critical (security-related) and fails closed (if a timeout occurs, the request is denied), then it should be designed with high availability in mind. As one of our <a href="https://twitter.com/mauilion">esteemed former colleagues</a> often comments, admission control can become <em>bottleneck-as-a-service</em> if users are not careful in its &#13;
<span class="keep-together">application</span>.</p>&#13;
&#13;
<p>If a <a data-primary="resource-intensive webhooks" data-type="indexterm" id="idm45611984408824"/><a data-primary="dependencies" data-secondary="external dependencies on webhooks" data-type="indexterm" id="idm45611984408024"/>webhook is resource-intensive and/or has external dependencies, consideration should be taken for how often the hook will be called, and the performance impact of adding the functionality into the critical path. In these situations a controller that reconciles objects once in-cluster may be preferable. When writing webhook configurations you should try to scope them down as tightly as possible to ensure they are not called unnecessarily or on irrelevant resources.</p>&#13;
</dd>&#13;
<dt>Side effects</dt>&#13;
<dd>&#13;
<p>Some webhooks may be responsible for modifying external resources (e.g., some resource in a cloud provider) based on a request to the Kubernetes API.<a data-primary="side effects, webhooks with" data-type="indexterm" id="idm45611984386456"/> These webhooks should be aware of and respect the <code>dryRun</code> option and skip external state modification when it is enabled. Webhooks are responsible for declaring that they either have no side effects or respect this option by setting the <code>sideEffects</code> field. More information on the valid options for this field and the behavior of each option is detailed in the <a href="https://oreil.ly/8FGic">official documentation</a>.<a data-primary="admission control" data-secondary="webhooks" data-startref="ix_adctrlwhk" data-type="indexterm" id="idm45611984384008"/><a data-primary="webhooks" data-startref="ix_webhk" data-type="indexterm" id="idm45611984382920"/></p>&#13;
</dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Writing a Mutating Webhook" data-type="sect1"><div class="sect1" id="idm45611984813240">&#13;
<h1>Writing a Mutating Webhook</h1>&#13;
&#13;
<p>In this section we’ll take a look at two approaches for writing a mutating admission webhook.<a data-primary="admission control" data-secondary="writing a mutating webhook" data-type="indexterm" id="ix_adctrlwrmwhk"/><a data-primary="mutating webhooks" data-secondary="writing" data-type="indexterm" id="ix_muwhk"/><a data-primary="webhooks" data-secondary="writing a mutating webhook" data-type="indexterm" id="ix_webhkmu"/> First we’ll talk briefly about implementing one with a plain HTTPS handler that is language agnostic. Then we’ll take a deeper dive into a real use case while covering the controller-runtime upstream project, which is designed to help teams develop Kubernetes controller components.</p>&#13;
&#13;
<p>Both of the solutions in this section require expertise in either Go (for controller-runtime) or another programming language.<a data-primary="Go language" data-type="indexterm" id="idm45611984376360"/> There are cases where this requirement is an impediment to creating and implementing admission controllers. If your teams don’t have the experience or need to write bespoke webhooks, the final section in this chapter offers a solution for configurable admission policies that don’t require programming knowledge.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="pagebreak-before less_space" data-pdf-bookmark="Plain HTTPS Handler" data-type="sect2"><div class="sect2" id="idm45611984375160">&#13;
<h2>Plain HTTPS Handler</h2>&#13;
&#13;
<p>One of the advantages of the webhook model for admission controllers is that we’re able to implement them from scratch in any language.<a data-primary="HTTPS handler for mutating webhook" data-type="indexterm" id="ix_HTTPS"/><a data-primary="mutating webhooks" data-secondary="writing" data-tertiary="plain HTTPS handler" data-type="indexterm" id="ix_muwhkHTTPS"/><a data-primary="admission control" data-secondary="writing a mutating webhook" data-tertiary="plain HTTPS handler" data-type="indexterm" id="ix_ACmuwhHTTPS"/> The examples we’re using here are written in Go, but any language capable of TLS-enabled HTTP handling and JSON parsing is acceptable.</p>&#13;
&#13;
<p>This way of writing a webhook provides the most flexibility to integrate with the current stacks in use but comes at the cost of many high-level abstractions (although languages with mature Kubernetes client libraries can alleviate this).</p>&#13;
&#13;
<p>As described in the introduction to this section, admission control webhooks receive and return requests from and to the API server. The schema of these messages is well known, so it’s possible to receive the request and modify the object (via patches) &#13;
<span class="keep-together">manually</span>.</p>&#13;
&#13;
<p>For a concrete example of this approach let’s take an in-depth look at the <a href="https://oreil.ly/rW3ym">AWS IAM Roles for Service Accounts mutating webhook</a>. <a data-primary="AWS platform authentication methods/tooling" data-secondary="IAM Roles for Service Accounts" data-type="indexterm" id="idm45611984366472"/>This webhook is used to inject a Projected Volume into Pods with a Service Account token that can be used for authentication to AWS services. (See <a data-type="xref" href="ch10.html#chapter10">Chapter 10</a> for more detail on the security aspect of this use case.)</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="c1">// &lt;...snip...&gt;&#13;
</code><code class="kd">type</code><code> </code><code class="nx">patchOperation</code><code> </code><code class="kd">struct</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_admission_control_CO3-1" id="co_admission_control_CO3-5"><img alt="1" src="assets/1.png"/></a><code>&#13;
  </code><code class="nx">Op</code><code>    </code><code class="kt">string</code><code>      </code><code class="s">`json:"op"`</code><code>&#13;
</code><code>  </code><code class="nx">Path</code><code>  </code><code class="kt">string</code><code>      </code><code class="s">`json:"path"`</code><code>&#13;
</code><code>  </code><code class="nx">Value</code><code> </code><code class="kd">interface</code><code class="p">{</code><code class="p">}</code><code> </code><code class="s">`json:"value,omitempty"`</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="nx">volume</code><code> </code><code class="o">:=</code><code> </code><code class="nx">corev1</code><code class="p">.</code><code class="nx">Volume</code><code class="p">{</code><code> </code><a class="co" href="#callout_admission_control_CO3-2" id="co_admission_control_CO3-6"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="nx">Name</code><code class="p">:</code><code> </code><code class="nx">m</code><code class="p">.</code><code class="nx">volName</code><code class="p">,</code><code>&#13;
</code><code>  </code><code class="nx">VolumeSource</code><code class="p">:</code><code> </code><code class="nx">corev1</code><code class="p">.</code><code class="nx">VolumeSource</code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="nx">Projected</code><code class="p">:</code><code> </code><code class="o">&amp;</code><code class="nx">corev1</code><code class="p">.</code><code class="nx">ProjectedVolumeSource</code><code class="p">{</code><code>&#13;
</code><code>      </code><code class="nx">Sources</code><code class="p">:</code><code> </code><code class="p">[</code><code class="p">]</code><code class="nx">corev1</code><code class="p">.</code><code class="nx">VolumeProjection</code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="p">{</code><code>&#13;
</code><code>          </code><code class="nx">ServiceAccountToken</code><code class="p">:</code><code> </code><code class="o">&amp;</code><code class="nx">corev1</code><code class="p">.</code><code class="nx">ServiceAccountTokenProjection</code><code class="p">{</code><code>&#13;
</code><code>            </code><code class="nx">Audience</code><code class="p">:</code><code>          </code><code class="nx">audience</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="nx">ExpirationSeconds</code><code class="p">:</code><code> </code><code class="o">&amp;</code><code class="nx">m</code><code class="p">.</code><code class="nx">Expiration</code><code class="p">,</code><code>&#13;
</code><code>            </code><code class="nx">Path</code><code class="p">:</code><code>              </code><code class="nx">m</code><code class="p">.</code><code class="nx">tokenName</code><code class="p">,</code><code>&#13;
</code><code>          </code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code>        </code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code>      </code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code>  </code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="nx">patch</code><code> </code><code class="o">:=</code><code> </code><code class="p">[</code><code class="p">]</code><code class="nx">patchOperation</code><code class="p">{</code><code> </code><a class="co" href="#callout_admission_control_CO3-3" id="co_admission_control_CO3-7"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="nx">Op</code><code class="p">:</code><code>    </code><code class="s">"add"</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="nx">Path</code><code class="p">:</code><code>  </code><code class="s">"/spec/volumes/0"</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="nx">Value</code><code class="p">:</code><code> </code><code class="nx">volume</code><code class="p">,</code><code>&#13;
</code><code>  </code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="k">if</code><code> </code><code class="nx">pod</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">Volumes</code><code> </code><code class="o">==</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_admission_control_CO3-4" id="co_admission_control_CO3-8"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="nx">patch</code><code> </code><code class="p">=</code><code> </code><code class="p">[</code><code class="p">]</code><code class="nx">patchOperation</code><code class="p">{</code><code>&#13;
</code><code>    </code><code class="p">{</code><code>&#13;
</code><code>      </code><code class="nx">Op</code><code class="p">:</code><code>   </code><code class="s">"add"</code><code class="p">,</code><code>&#13;
</code><code>      </code><code class="nx">Path</code><code class="p">:</code><code> </code><code class="s">"/spec/volumes"</code><code class="p">,</code><code>&#13;
</code><code>      </code><code class="nx">Value</code><code class="p">:</code><code> </code><code class="p">[</code><code class="p">]</code><code class="nx">corev1</code><code class="p">.</code><code class="nx">Volume</code><code class="p">{</code><code>&#13;
</code><code>        </code><code class="nx">volume</code><code class="p">,</code><code>&#13;
</code><code>      </code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code>    </code><code class="p">}</code><code class="p">,</code><code>&#13;
</code><code>  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code>&#13;
</code><code class="nx">patchBytes</code><code class="p">,</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">json</code><code class="p">.</code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">patch</code><code class="p">)</code><code> </code><a class="co" href="#callout_admission_control_CO3-5" id="co_admission_control_CO3-9"><img alt="5" src="assets/5.png"/></a><code>&#13;
</code><code class="c1">// &lt;...snip...&gt;</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_admission_control_CO3-1" id="callout_admission_control_CO3-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Define a <code>patchOperation</code> struct that will be marshaled to JSON for the response back to the Kubernetes API server.<a data-primary="patchOperation" data-type="indexterm" id="idm45611983998600"/></p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO3-2" id="callout_admission_control_CO3-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Construct the <code>Volume</code> struct with the relevant ServiceAccountToken content.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO3-3" id="callout_admission_control_CO3-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Create an instance of the <code>patchOperation</code> with the Volume content previously constructed.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO3-4" id="callout_admission_control_CO3-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>If there are currently no Volumes, create that key and add the Volume content previously constructed.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO3-9" id="callout_admission_control_CO3-5"><img alt="5" src="assets/5.png"/></a></dt>&#13;
<dd><p>Create the JSON object containing the patch contents.</p></dd>&#13;
</dl>&#13;
&#13;
<p>Note that the actual implementation for this admission webhook includes some additional functionality that also adds to the patch set (e.g., adding environment variables), but we’re going to ignore that for the purposes of this example.<a data-primary="patch sets, generating" data-type="indexterm" id="idm45611984014520"/> After the patch set is complete we need to return an AdmissionResponse object that contains our patch set (the <code>Patch</code> field in the following snippet):</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="k">return</code> <code class="o">&amp;</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">AdmissionResponse</code><code class="p">{</code>&#13;
  <code class="nx">Allowed</code><code class="p">:</code> <code class="kc">true</code><code class="p">,</code>&#13;
  <code class="nx">Patch</code><code class="p">:</code>   <code class="nx">patchBytes</code><code class="p">,</code>&#13;
  <code class="nx">PatchType</code><code class="p">:</code> <code class="kd">func</code><code class="p">()</code> <code class="o">*</code><code class="nx">v1beta1</code><code class="p">.</code><code class="nx">PatchType</code> <code class="p">{</code>&#13;
    <code class="nx">pt</code> <code class="o">:=</code> <code class="nx">v1beta1</code><code class="p">.</code><code class="nx">PatchTypeJSONPatch</code>&#13;
    <code class="k">return</code> <code class="o">&amp;</code><code class="nx">pt</code>&#13;
  <code class="p">}(),</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p class="pagebreak-before">We can see in this example that there is a lot of manual work to be done generating patch sets and constructing the appropriate response for the API server. This is even present when utilizing some of the Kubernetes libraries available in the Go language. However, there is a large amount of supporting code  we’ve omitted that’s required to handle errors, graceful shutdown, HTTP header handling, and so on.</p>&#13;
&#13;
<p>While this approach affords us maximum flexibility, it requires more domain knowledge and is more complex to implement and maintain. This trade-off will be all-too-familiar for most readers. and care needs to be taken when evaluating your specific use cases and internal expertise.</p>&#13;
&#13;
<p>In the next section we’ll see an approach that removes a lot of the boilerplate and bespoke work in favor of implementing an upstream helper framework, controller-runtime.<a data-primary="HTTPS handler for mutating webhook" data-startref="ix_HTTPS" data-type="indexterm" id="idm45611984153224"/><a data-primary="admission control" data-secondary="writing a mutating webhook" data-startref="ix_ACmuwhHTTPS" data-tertiary="plain HTTPS handler" data-type="indexterm" id="idm45611984152344"/><a data-primary="mutating webhooks" data-secondary="writing" data-startref="ix_muwhkHTTPS" data-tertiary="plain HTTPS handler" data-type="indexterm" id="idm45611984150888"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Controller Runtime" data-type="sect2"><div class="sect2" id="idm45611984374568">&#13;
<h2>Controller Runtime</h2>&#13;
&#13;
<p>In this section <a data-primary="controller runtime for mutating webhook" data-type="indexterm" id="ix_ctrlrun"/><a data-primary="mutating webhooks" data-secondary="writing" data-tertiary="controller runtime" data-type="indexterm" id="ix_muwhkCR"/><a data-primary="admission control" data-secondary="writing a mutating webhook" data-tertiary="controller runtime" data-type="indexterm" id="ix_ACmuwhCR"/>we’re going to dive into the upstream project <a href="https://github.com/kubernetes-sigs/controller-runtime">controller-runtime</a> and see what abstractions it provides on top of the native Kubernetes client libraries to make writing admission controllers more streamlined. To provide more color we’ll use an open source controller we built to satisfy a community requirement as a way of illustrating some of the advantages of controller-runtime and cover some of the techniques and pitfalls previously discussed. While we have simplified the functionality and code of the controller somewhat for brevity, the core underlying ideas remain.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45611984207624">&#13;
<h5>Kubebuilder</h5>&#13;
<p>The <a href="https://oreil.ly/sBfth">upstream repository</a> contains<a data-primary="upstream repository" data-type="indexterm" id="idm45611984205352"/> examples that can help you get started implementing webhooks for built-in types (e.g., Pod, Deployment, etc.). If you want to implement webhooks for custom resources (CRDs), then the <a href="https://github.com/kubernetes-sigs/kubebuilder">Kubebuilder</a> project is probably more suitable for a holistic solution.<a data-primary="Kubebuilder project" data-type="indexterm" id="idm45611984203592"/> Kubebuilder utilizes <code>controller-runtime</code> and provides additional generation utilities and helpers. We’ll dive more into CRDs and Kubebuilder later in this book.</p>&#13;
&#13;
<p>If you <em>are</em> using Kubebuilder, the project provides a convenient marker system that allows you to generate the relevant manifests to deploy your webhook to the Kubernetes cluster. For example:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="cm">/* +kubebuilder:webhook:path=/infoblox-ipam,mutating=true,failurePolicy=fail,</code>&#13;
<code class="cm">groups="infrastructure.cluster.x-k8s.io",resources=vspheremachines,</code>&#13;
<code class="cm">verbs=create,versions=v1alpha3,</code>&#13;
<code class="cm">name=mutating.infoblox.ipam.vspheremachines.infrastructure.cluster.x-k8s.io */</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>The controller we’ll be walking through is a webhook designed to perform the following actions:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Watch for Cluster API VSphereMachine objects.<a data-primary="VSphereMachine objects" data-type="indexterm" id="idm45611984235080"/></p>&#13;
</li>&#13;
<li>&#13;
<p>Based on a configurable field, allocate an IP address in an external IPAM system (in this case, Infoblox).</p>&#13;
</li>&#13;
<li>&#13;
<p>Insert the allocated IP into the static IP field in the VSphereMachine.</p>&#13;
</li>&#13;
<li>&#13;
<p>Allow the mutated requested through to the Kubernetes API server to be actioned (by the Cluster API controller) and persisted into etcd.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>This use case is a good candidate for a custom-built (using controller-runtime) mutating webhook for a couple of reasons:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>We need to mutate the request to add an IP address <em>before</em> the request hits the API server (otherwise it would error).</p>&#13;
</li>&#13;
<li>&#13;
<p>We’re calling out to an external system (Infoblox) and can therefore leverage its Go library for interactions.</p>&#13;
</li>&#13;
<li>&#13;
<p>Small amount of boilerplate allows newer community and/or client developers to understand and extend the functionality.</p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Although out-of-scope for <em>this</em> chapter, we did accompany this webhook with a controller that runs in the cluster. This is important when your webhooks interact with and modify or depend on <em>external</em> state (Infoblox in this case) because you should be constantly reconciling that state, rather than relying on the state just seen at admission time. This is something to consider when building a mutating admission webhook and may increase the complexity of your solutions if the extra component is required.</p>&#13;
</div>&#13;
&#13;
<p>Controller-runtime webhooks must implement a <code>Handle</code> method whose signature is:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="kd">func</code> <code class="p">(</code><code class="nx">w</code> <code class="o">*</code><code class="nx">Webhook</code><code class="p">)</code> <code class="nx">Handle</code><code class="p">(</code>&#13;
  <code class="nx">ctx</code> <code class="nx">context</code><code class="p">.</code><code class="nx">Context</code><code class="p">,</code>&#13;
  <code class="nx">req</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">Request</code><code class="p">)</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">Response</code></pre>&#13;
&#13;
<p>The <code>admission.Request</code> object is an abstraction over the raw JSON that webhooks receive and provides easy access to the raw applied object, the operation being executed (e.g., <code>CREATE</code>), and many other useful pieces of metadata:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">vm</code><code> </code><code class="o">:=</code><code> </code><code class="o">&amp;</code><code class="nx">v1alpha3</code><code class="p">.</code><code class="nx">VSphereMachine</code><code class="p">{</code><code class="p">}</code><code> </code><a class="co" href="#callout_admission_control_CO4-1" id="co_admission_control_CO4-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">w</code><code class="p">.</code><code class="nx">decoder</code><code class="p">.</code><code class="nx">DecodeRaw</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">Object</code><code class="p">,</code><code> </code><code class="nx">vm</code><code class="p">)</code><code> </code><a class="co" href="#callout_admission_control_CO4-2" id="co_admission_control_CO4-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code>&#13;
</code><code>  </code><code class="k">return</code><code> </code><code class="nx">admission</code><code class="p">.</code><code class="nx">Errored</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusBadRequest</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code> </code><a class="co" href="#callout_admission_control_CO4-3" id="co_admission_control_CO4-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_admission_control_CO4-1" id="callout_admission_control_CO4-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Create a new VSphereMachine object.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO4-2" id="callout_admission_control_CO4-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Use the built-in decoder to decode the raw object from the request into the Go VSphereMachine object.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO4-3" id="callout_admission_control_CO4-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>Use the convenience method <code>Errored</code> to construct and return an error response if the decoding step returns an error.</p></dd>&#13;
</dl>&#13;
&#13;
<p>The <code>vm</code> object from the request can be modified or validated in any way before the response is returned. In the following example we are checking to see if the <code>infoblox</code> annotation (denoting that our webhook should take action) is present on the VSphereMachine object. This is an important step to perform early on in the webhook because we can short-circuit out of any further logic if no action should be taken. If the annotation is not present, we utilize the convenience <code>Allowed</code> method to return the unmodified object through to the API server as quickly as possible. As we discussed earlier in <a data-type="xref" href="#webhook_design">“Webhook Design Considerations”</a>, webhooks are on the critical path for API requests, and any actions we perform inside them should be as fast as possible:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="k">if</code> <code class="nx">_</code><code class="p">,</code> <code class="nx">ok</code> <code class="o">:=</code> <code class="nx">vm</code><code class="p">.</code><code class="nx">Annotations</code><code class="p">[</code><code class="s">"infoblox"</code><code class="p">];</code> <code class="p">!</code><code class="nx">ok</code> <code class="p">{</code>&#13;
  <code class="k">return</code> <code class="nx">admission</code><code class="p">.</code><code class="nx">Allowed</code><code class="p">(</code><code class="s">"Nothing to do"</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Assuming we <em>should</em> handle this request and the preceding logic does not trigger, we retrieve an IP address from Infoblox (not shown) and write it directly into the <code>vm</code> object:</p>&#13;
&#13;
<pre data-code-language="go" data-type="programlisting"><code class="nx">vm</code><code class="p">.</code><code class="nx">Spec</code><code class="p">.</code><code class="nx">VirtualMachineCloneSpec</code><code class="p">.</code><code class="nx">Network</code><code class="p">.</code><code class="nx">Devices</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="p">.</code><code class="nx">IPAddrs</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code> </code><code class="p">=</code><code> </code><code class="nx">ipFromInfoblox</code><code> </code><a class="co" href="#callout_admission_control_CO5-1" id="co_admission_control_CO5-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code class="nx">marshaledVM</code><code class="p">,</code><code> </code><code class="nx">err</code><code> </code><code class="o">:=</code><code> </code><code class="nx">json</code><code class="p">.</code><code class="nx">Marshal</code><code class="p">(</code><code class="nx">vm</code><code class="p">)</code><code> </code><a class="co" href="#callout_admission_control_CO5-2" id="co_admission_control_CO5-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code class="k">if</code><code> </code><code class="nx">err</code><code> </code><code class="o">!=</code><code> </code><code class="kc">nil</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_admission_control_CO5-3" id="co_admission_control_CO5-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
  </code><code class="k">return</code><code> </code><code class="nx">admission</code><code class="p">.</code><code class="nx">Errored</code><code class="p">(</code><code class="nx">http</code><code class="p">.</code><code class="nx">StatusInternalServerError</code><code class="p">,</code><code> </code><code class="nx">err</code><code class="p">)</code><code>&#13;
</code><code class="p">}</code><code>&#13;
</code><code class="k">return</code><code> </code><code class="nx">admission</code><code class="p">.</code><code class="nx">PatchResponseFromRaw</code><code class="p">(</code><code class="nx">req</code><code class="p">.</code><code class="nx">Object</code><code class="p">.</code><code class="nx">Raw</code><code class="p">,</code><code> </code><code class="nx">marshaledVM</code><code class="p">)</code><code> </code><a class="co" href="#callout_admission_control_CO5-4" id="co_admission_control_CO5-4"><img alt="4" src="assets/4.png"/></a></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_admission_control_CO5-1" id="callout_admission_control_CO5-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>Set the IP field on the <code>vm</code> object, thereby <em>mutating</em> it.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO5-2" id="callout_admission_control_CO5-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>Marshal the <code>vm</code> object to JSON ready to send back to the API server.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO5-3" id="callout_admission_control_CO5-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>If the marshaling fails we’ll use the convenience error method we saw earlier.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO5-4" id="callout_admission_control_CO5-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Another convenience method, <code>PatchReponseFromRaw</code>, sends back the response. We’ll discuss this in more detail later.</p></dd>&#13;
</dl>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>There are use cases where you may want and/or need to intercept <code>DELETE</code> requests to the API server. An example of this might be to clean up some external state that might be tied to resources in the cluster. While this <em>can</em> be done in a webhook, you should consider whether you’re failing open or closed and the risks of having misaligned state in the former case. Ideally, deletion logic should be implemented with a <a href="https://oreil.ly/Y1iGD">finalizer</a> and a custom controller running in the cluster to guarantee cleanup.</p>&#13;
</div>&#13;
&#13;
<p>In the preceding snippet we see another of controller-runtime’s convenience methods, <code>PatchResponseFromRaw</code>.<a data-primary="PatchResponseFromRaw" data-type="indexterm" id="idm45611983644712"/><a data-primary="JSONPatch structure" data-secondary="calculating diffs" data-type="indexterm" id="idm45611983644104"/> This method will automatically calculate the JSONPatch diffs required between the original raw object and the one we have been modifying before sending the correctly serialized response. Compared to the more manual approach covered in the previous section, this is a great way to remove some boilerplate and make our controller code leaner.</p>&#13;
&#13;
<p>In the case of a simple validating hook, we can also leverage convenience functions like <code>admission.Allowed()</code> and <code>admission.Denied()</code> that can be used after processing the required logic.</p>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>If we’re manipulating external state as part of an admission controller we <a data-primary="dry runs" data-type="indexterm" id="idm45611983640632"/>need to be aware of and check for the <code>req.DryRun</code> condition. If this is set, the user is only executing a dry run, no-op request and we should ensure that our controller <em>does not</em> mutate external state in this case.</p>&#13;
</div>&#13;
&#13;
<p>Controller-runtime provides a very strong foundation with which to build admission controllers, allowing us to focus on the logic we want to implement with minimal boilerplate. However, it does require programming expertise, and the admission logic is obfuscated inside the controller code, potentially leading to more confusing or unexpected results for end users.</p>&#13;
&#13;
<p>In the next section of this chapter, we’ll take a look at an emerging model that centralizes policy logic and introduces a standard language to author decision rules. The tools appearing in this area strive to combine the flexibility of a custom controller with greater usability features for less technical operators and/or end users.<a data-primary="controller runtime for mutating webhook" data-startref="ix_ctrlrun" data-type="indexterm" id="idm45611983637352"/><a data-primary="admission control" data-secondary="writing a mutating webhook" data-startref="ix_ACmuwhCR" data-tertiary="controller runtime" data-type="indexterm" id="idm45611983636504"/><a data-primary="mutating webhooks" data-secondary="writing" data-startref="ix_muwhkCR" data-tertiary="controller runtime" data-type="indexterm" id="idm45611983635176"/><a data-primary="access control" data-secondary="writing a mutating webhook" data-startref="ix_adctrlwrmwhk" data-type="indexterm" id="idm45611983633848"/><a data-primary="mutating webhooks" data-secondary="writing" data-startref="ix_muwhk" data-type="indexterm" id="idm45611983632760"/><a data-primary="webhooks" data-secondary="writing a mutating webhook" data-startref="ix_webhkmu" data-type="indexterm" id="idm45611983631672"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Centralized Policy Systems" data-type="sect1"><div class="sect1" id="idm45611984214120">&#13;
<h1>Centralized Policy Systems</h1>&#13;
&#13;
<p>So far we’ve looked at a number of different methods for implementing and configuring admission controllers.<a data-primary="policy systems, centralized, for admission control" data-type="indexterm" id="ix_polsys"/><a data-primary="admission control" data-secondary="centralized policy systems" data-type="indexterm" id="ix_ACcntr"/><a data-primary="centralized policy systems for admission control" data-type="indexterm" id="ix_CPSAC"/> Each has its own specific trade-offs that have to be considered when choosing to adopt them. In this final section, we’re going to cover an emerging model of centralizing policy logic into one place and using standardized languages to express the allow/deny rules. This model has two main advantages:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Programming knowledge is not required to create admission controllers, as we can express rules in a specific policy language (as opposed to a general-purpose programming language). This also means that changes to logic do not require rebuilding and redeploying the controller each time.</p>&#13;
</li>&#13;
<li>&#13;
<p>Policies and rules are stored in a single location (in most cases, the cluster itself) for viewing, editing, and auditing.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>This model is being built out and implemented by several open source tools and usually comprises two components:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>A policy/query language that can express conditions on whether an object should be admitted or rejected.</p>&#13;
</li>&#13;
<li>&#13;
<p>A controller that sits in the cluster serving as an admission controller. The controller’s job is to evaluate the policies/rules against objects coming into the API server and make admit or reject decisions.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For the<a data-primary="Gatekeeper" data-type="indexterm" id="ix_GtKp"/> rest of this chapter we’re going to focus on the most popular implementation of this centralized policy model called <a href="https://github.com/open-policy-agent/gatekeeper">Gatekeeper</a>, although other tools such as <a href="https://kyverno.io">Kyverno</a> are also gaining traction. Gatekeeper is built on a lower-level tool called Open Policy Agent (OPA).<a data-primary="Open Policy Agent (OPA)" data-type="indexterm" id="idm45611983616680"/> OPA is an open source policy engine that applies policies written in the Rego language to ingested JSON documents and returns a result.</p>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45611983615560">&#13;
<h5>Rego Language</h5>&#13;
<p>Rego is the declarative query language used by Open Policy Agent.<a data-primary="Rego language" data-type="indexterm" id="idm45611983614264"/><a data-primary="Open Policy Agent (OPA)" data-secondary="Rego language" data-type="indexterm" id="idm45611983613560"/> It was created by the creators of OPA and is used as the policy language in the OPA engine. It is not designed to be a general-purpose programming language and is specialized for querying and performing logic operations over data structures. This approach results in a fairly lean syntax, but it can be difficult to read and write initially. We won’t cover Rego syntax in detail in this book, but there is an <a href="https://academy.styra.com/courses/opa-rego">online training portal</a> where users can learn Rego and test their knowledge for free.</p>&#13;
</div></aside>&#13;
&#13;
<p>A calling application can utilize OPA by receiving the result and deciding how to proceed (making a policy decision). We know from this chapter that Kubernetes has a standard schema for sending requests and receiving admission decision responses, so it immediately seems like this is a promising fit. However, OPA itself is platform/context agnostic and is simply a policy engine that operates on JSON.<a data-primary="JSON" data-secondary="use by Open Policy Agent" data-type="indexterm" id="idm45611983610328"/> We need a controller that will act as an interface between the OPA engine and Kubernetes. Gatekeeper is the tool that fulfills that interface role and provides some additional Kubernetes-native functionality around templates and extensibility to make it easier for platform operators to author and apply policies. Gatekeeper is deployed to the cluster as an admission controller that allows users to write rules in Rego to make admission policy decisions about Kubernetes resources being applied to the cluster.</p>&#13;
&#13;
<p>Gatekeeper enables a model whereby cluster operators can create and expose preset policy templates as <code>ConstraintTemplate</code> CRDs.<a data-primary="ConstraintTemplate CRDs" data-type="indexterm" id="idm45611983607720"/> These templates create new CRDs for the specific constraints that can accept custom input parameters (much like a function). This approach is powerful because end users can then create an instance of the constraint with their own values, which will be used by Gatekeeper as part of admission control to the cluster.</p>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>For some of the reasons detailed in the latter part of this section, you should be aware that Gatekeeper currently fails <em>open</em> by default. This can have serious security implications, and you should carefully understand the trade-offs (detailed in this chapter and in much of the official documentation) involved in each approach before implementing these solutions in production.</p>&#13;
</div>&#13;
&#13;
<p>One common rule we’ve implemented in the field is ensuring that teams cannot overwrite existing Ingress resources.<a data-primary="Ingress" data-secondary="not overwriting existing Ingress resources" data-type="indexterm" id="idm45611983604040"/> This is a requirement in most Kubernetes clusters, and some Ingress controllers (e.g., Contour) provide mechanisms to protect against this out of the box. However, if this is not the case with your tooling, you can use Gatekeeper to enforce this rule. <a data-primary="Gatekeeper" data-secondary="official documentation" data-type="indexterm" id="idm45611983602632"/>This scenario is one of several maintained as a library of common policies in the <a href="https://oreil.ly/LINGy">official Gatekeeper documentation</a>.</p>&#13;
&#13;
<p>In this situation it’s necessary to make a policy decision based on data that <em>exists externally to the object</em> that’s being applied to the cluster. We need to query Kubernetes directly to know what Ingress resources already exist and to be able to inspect metadata around them to compare against the one being applied.</p>&#13;
&#13;
<p>Let’s take an even more complex example that builds on these ideas, and we’ll walk through the implementation of each resource. In this case, we’re going to annotate a Namespace with a regex pattern and ensure any Ingress applied in that Namespace conforms to the regex. We mentioned earlier that we need information about the cluster to be available to Gatekeeper to make policy decisions. This is achieved by defining a sync config to specify which resources in Kubernetes should be synchronized to Gatekeeper’s cache (in order to provide that queryable data source):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">config.gatekeeper.sh/v1alpha1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Config</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">config</code><code>&#13;
</code><code>  </code><code class="nt">namespace</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">gatekeeper-system</code><code class="s">"</code><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">sync</code><code class="p">:</code><code> </code><a class="co" href="#callout_admission_control_CO6-1" id="co_admission_control_CO6-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>    </code><code class="nt">syncOnly</code><code class="p">:</code><code>&#13;
</code><code>      </code><code class="p-Indicator">-</code><code> </code><code class="nt">group</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">extensions</code><code class="s">"</code><code>&#13;
</code><code>        </code><code class="nt">version</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">v1beta1</code><code class="s">"</code><code>&#13;
</code><code>        </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">Ingress</code><code class="s">"</code><code>&#13;
</code><code>      </code><code class="p-Indicator">-</code><code> </code><code class="nt">group</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">networking.k8s.io</code><code class="s">"</code><code>&#13;
</code><code>        </code><code class="nt">version</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">v1beta1</code><code class="s">"</code><code>&#13;
</code><code>        </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">Ingress</code><code class="s">"</code><code>&#13;
</code><code>      </code><code class="p-Indicator">-</code><code> </code><code class="nt">group</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">"</code><code>&#13;
</code><code>        </code><code class="nt">version</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">v1</code><code class="s">"</code><code>&#13;
</code><code>        </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">Namespace</code><code class="s">"</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_admission_control_CO6-1" id="callout_admission_control_CO6-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>sync</code> section specifies all the Kubernetes resources that Gatekeeper should cache to assist with policy decisions.</p></dd>&#13;
</dl>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>The cache exists to remove the need for Gatekeeper to keep querying the Kubernetes API server for the required resources. However, there is potential for Gatekeeper to make decisions based on <em>stale</em> data. To mitigate this, there is an audit capability that intermittently runs policies against existing resources and records violations in the <code>status</code> field of each constraint. These should be monitored to ensure that violations that pass through (maybe as a result of a stale cache read) are not left unchecked.</p>&#13;
</div>&#13;
&#13;
<p>Once the config is applied, then an administrator can create the <code>ConstraintTemplate</code>.<a data-primary="Gatekeeper" data-secondary="ConstraintTemplate" data-type="indexterm" id="idm45611983447624"/><a data-primary="ConstraintTemplate CRDs" data-type="indexterm" id="idm45611983446616"/> This resource defines the main content of the policy and any input parameters that are available for administrators or other operators to provide/override:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">templates.gatekeeper.sh/v1beta1</code><code>&#13;
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">ConstraintTemplate</code><code>&#13;
</code><code class="nt">metadata</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">limitnamespaceingress</code><code>&#13;
</code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>  </code><code class="nt">crd</code><code class="p">:</code><code>&#13;
</code><code>    </code><code class="nt">spec</code><code class="p">:</code><code>&#13;
</code><code>      </code><code class="nt">names</code><code class="p">:</code><code>&#13;
</code><code>        </code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">LimitNamespaceIngress</code><code>&#13;
</code><code>        </code><code class="nt">listKind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">LimitNamespaceIngressList</code><code>&#13;
</code><code>        </code><code class="nt">plural</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">limitnamespaceingresss</code><code>&#13;
</code><code>        </code><code class="nt">singular</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">limitnamespaceingress</code><code>&#13;
</code><code>      </code><code class="nt">validation</code><code class="p">:</code><code>&#13;
</code><code>        </code><code class="c1"># Schema for the `parameters` field in the constraint</code><code>&#13;
</code><code>        </code><code class="nt">openAPIV3Schema</code><code class="p">:</code><code>&#13;
</code><code>          </code><code class="nt">properties</code><code class="p">:</code><code> </code><a class="co" href="#callout_admission_control_CO7-1" id="co_admission_control_CO7-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>            </code><code class="nt">annotation</code><code class="p">:</code><code>&#13;
</code><code>              </code><code class="nt">type</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">string</code><code>&#13;
</code><code>  </code><code class="nt">targets</code><code class="p">:</code><code> </code><a class="co" href="#callout_admission_control_CO7-2" id="co_admission_control_CO7-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
</code><code>    </code><code class="p-Indicator">-</code><code> </code><code class="nt">target</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">admission.k8s.gatekeeper.sh</code><code>&#13;
</code><code>      </code><code class="nt">rego</code><code class="p">:</code><code> </code><code class="p-Indicator">|</code><code>&#13;
</code><code>        </code><code class="no">package limitnamespaceingress</code><code>&#13;
</code><code>&#13;
</code><code>        </code><code class="no">violation[{"msg": msg}] {</code><code>&#13;
</code><code>          </code><code class="no">cluster := data.inventory.cluster.v1</code><code>&#13;
</code><code>          </code><code class="no">namespace := cluster.Namespace[input.review.object.metadata.namespace]</code><code>&#13;
</code><code>          </code><code class="no">regex := namespace.metadata.annotations[input.parameters.annotation]</code><code>&#13;
</code><code>          </code><code class="no">hosts := input.review.object.spec.rules[_].host</code><code>&#13;
</code><code>          </code><code class="no">not re_match(regex, hosts)</code><code>&#13;
</code><code>          </code><code class="no">msg := sprintf("Only ingresses matching %v in namespace %v allowed",</code><code>&#13;
</code><code>             </code><code class="no">[regex ,input.review.object.metadata.namespace])</code><code>&#13;
</code><code>        </code><code class="no">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_admission_control_CO7-1" id="callout_admission_control_CO7-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>The <code>properties</code> section defines the input parameters that will be available to inject into the Rego policy for each instantiation of the rule.</p></dd>&#13;
<dt><a class="co" href="#co_admission_control_CO7-2" id="callout_admission_control_CO7-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>The <code>targets</code> section contains the Rego code for our policy rules. We won’t dig into Rego syntax here, but notice that the input parameter is being referenced via <code>input.parameters.&lt;parameter_name&gt;</code> (in this case, <code>annotation</code>).</p></dd>&#13;
</dl>&#13;
&#13;
<p>The <code>annotation</code> in the custom input parameters allows the user to specify the specific annotation name that Gatekeeper should pull the regex pattern from. Rego won’t trigger a violation if any statement returns <code>False</code>. In this case, we’re checking that the hosts <em>do</em> match the regex, so to ensure that doesn’t trigger a violation we need to invert the <code>re_match()</code> with <code>not</code> to ensure that a positive match doesn’t trigger a violation and instead <em>allows</em> the request through admission control.</p>&#13;
&#13;
<p>Lastly, we create an instance of the preceding policy to configure Gatekeeper to apply it against specific resources as part of admission control.<a data-primary="LimitNamespaceIngress object" data-type="indexterm" id="idm45611983363720"/><a data-primary="Ingress" data-secondary="LimitNamespaceIngress" data-type="indexterm" id="idm45611983363160"/> The <code>LimitNamespaceIngress</code> object specifies that the rule should apply to Ingress objects for both <code>apiGroups</code> and designates <code>allowed-ingress-pattern</code> as<a data-primary="allowed-ingress-pattern annotation" data-type="indexterm" id="idm45611983357832"/> the annotation that should be inspected for the regex pattern (this was the customizable input parameter):</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">constraints.gatekeeper.sh/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">LimitNamespaceIngress</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">limit-namespace-ingress</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">match</code><code class="p">:</code>&#13;
    <code class="nt">kinds</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"extensions"</code><code class="p-Indicator">,</code> <code class="s">"networking.k8s.io"</code><code class="p-Indicator">]</code>&#13;
        <code class="nt">kinds</code><code class="p">:</code> <code class="p-Indicator">[</code><code class="s">"Ingress"</code><code class="p-Indicator">]</code>&#13;
  <code class="nt">parameters</code><code class="p">:</code>&#13;
    <code class="nt">annotation</code><code class="p">:</code> <code class="l-Scalar-Plain">allowed-ingress-pattern</code></pre>&#13;
&#13;
<p>Finally, the Namespace object itself is applied with the custom annotation and pattern. Here we are specifying the regex <code>\w\.my-namespace\.com</code> in the <code>allowed-ingress-pattern</code> field:</p>&#13;
&#13;
<pre class="pagebreak-before" data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Namespace</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">annotations</code><code class="p">:</code>&#13;
    <code class="c1"># Note regex special character escaping</code>&#13;
    <code class="nt">allowed-ingress-pattern</code><code class="p">:</code> <code class="l-Scalar-Plain">\w\.my-namespace\.com</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">ingress-test</code></pre>&#13;
&#13;
<p>The setup steps are all now complete. We can begin adding Ingress objects, and the rules we have configured will evaluate against them and either allow or deny the persistence/creation of the Ingress:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="c1"># FAILS because the host doesn't match the pattern above</code>&#13;
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">networking.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Ingress</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">test-1</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">ingress-test</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">rules</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">host</code><code class="p">:</code> <code class="l-Scalar-Plain">foo.other-namespace.com</code>&#13;
    <code class="nt">http</code><code class="p">:</code>&#13;
      <code class="nt">paths</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">backend</code><code class="p">:</code>&#13;
          <code class="nt">serviceName</code><code class="p">:</code> <code class="l-Scalar-Plain">service1</code>&#13;
          <code class="nt">servicePort</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code>&#13;
<code class="nn">---</code>&#13;
<code class="c1"># SUCCEEDS as the pattern matches</code>&#13;
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">networking.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Ingress</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">test-2</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">ingress-test</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">rules</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">host</code><code class="p">:</code> <code class="l-Scalar-Plain">foo.my-namespace.com</code>&#13;
    <code class="nt">http</code><code class="p">:</code>&#13;
      <code class="nt">paths</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">backend</code><code class="p">:</code>&#13;
          <code class="nt">serviceName</code><code class="p">:</code> <code class="l-Scalar-Plain">service2</code>&#13;
          <code class="nt">servicePort</code><code class="p">:</code> <code class="l-Scalar-Plain">80</code></pre>&#13;
&#13;
<p>The second <a data-primary="Ingress" data-secondary="allowed-ingress-pattern annotation" data-type="indexterm" id="idm45611983235656"/>Ingress will succeed as the <code>spec.rules.host</code> matches the regex pattern specified in the <code>allowed-ingress-pattern</code> annotation on the <code>ingress-test</code> Namespace. However, the first Ingress does not match and results in an error:</p>&#13;
&#13;
<pre data-code-language="text" data-type="programlisting">Error from server ([denied by limit-namespace-ingress] Only ingresses with&#13;
host matching \w\.my-namespace\.com are allowed in namespace ingress-test):&#13;
error when creating "ingress.yaml": admission webhook "validation.gatekeeper.sh"&#13;
denied the request: [denied by limit-namespace-ingress] Only ingresses with host&#13;
matching \w\.my-namespace\.com are allowed in namespace ingress-test</pre>&#13;
&#13;
<p class="pagebreak-before">Gatekeeper has a number of strengths:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>The extensible <code>ConstraintTemplate</code> model allows<a data-primary="Gatekeeper" data-secondary="strengths and limitations" data-type="indexterm" id="idm45611983109832"/> admins to define common policies and share/reuse them as libraries across the organization.<a data-primary="ConstraintTemplate CRDs" data-type="indexterm" id="idm45611983108616"/></p>&#13;
</li>&#13;
<li>&#13;
<p>While it does require Rego knowledge, there is no additional programming language experience required, lowering the barrier to entry for policy design and creation.</p>&#13;
</li>&#13;
<li>&#13;
<p>The underlying technology (OPA) is fairly mature and well-supported in the community. Gatekeeper is a newer layer but has experienced strong early &#13;
<span class="keep-together">support</span>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Consolidating all policy enforcement into one admission controller allows us to access a centralized audit log, which is often important in regulated &#13;
<span class="keep-together">environments</span>.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>The main weakness of Gatekeeper is that it is currently unable to <em>mutate</em> requests. And while it does support external data sources (through a variety of methods), they can be cumbersome to implement. These issues will inevitably be addressed in the future, but should you have strong requirements in those areas, it’s likely you will need to implement one of the custom admission control solutions described in previous sections.</p>&#13;
&#13;
<p>One last consideration when utilizing Gatekeeper (and any general-purpose admission controller) is that the scope of requests captured by these tools is likely to be very broad. This is required for them to be useful because rules covering many different objects can be written and the controller itself needs to contain a superset of permissions to be able to capture them. However, this has several ramifications:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>As mentioned previously, these tools are in the critical path. If there is a bug or other issue with the controller and/or your configuration, there is the potential for widespread outage.</p>&#13;
</li>&#13;
<li>&#13;
<p>As a continuation of the previous point, because the controllers intercept requests <em>to the control plane</em>, it’s possible that you as administrators may also be temporarily <em>locked out</em> from performing remediation steps. This is pertinent especially in the case of resources that are important and/or integral to the <em>operation</em> of the cluster (e.g., networking resources and so on).</p>&#13;
</li>&#13;
<li>&#13;
<p>The broad scope necessarily requires that a broad RBAC policy is attached to the admission controller/policy server. If there is a vulnerability in this software, then the potential for destructive actions is significant.<a data-primary="Gatekeeper" data-startref="ix_GtKp" data-type="indexterm" id="idm45611983094584"/></p>&#13;
</li>&#13;
</ul>&#13;
<div data-type="caution"><h6>Caution</h6>&#13;
<p>You should avoid configuring admission webhooks to intercept resources targeting the <code>kube-system</code> Namespace.<a data-primary="kube-system Namespace" data-type="indexterm" id="idm45611983092072"/> Objects in this Namespace are often integral to the operation of the cluster and accidental mutations or rejections of these objects could cause serious issues in the cluster.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45611983629672">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>In this <a data-primary="policy systems, centralized, for admission control" data-startref="ix_polsys" data-type="indexterm" id="idm45611983089992"/><a data-primary="centralized policy systems for admission control" data-startref="ix_CPSAC" data-type="indexterm" id="idm45611983088888"/><a data-primary="admission control" data-secondary="centralized policy systems" data-startref="ix_ACcntr" data-type="indexterm" id="idm45611983087912"/>chapter we covered the many ways that we can control which objects are admitted to a Kubernetes cluster. Much like many of the concerns that we cover in this book, each way has its own specific trade-offs and decisions to make with regards to your individual requirements. Admission control is an area where even more careful examination and deeper knowledge is essential, given its heavy application in the area of cluster and workload security.</p>&#13;
&#13;
<p>Built-in controllers expose a solid set of functionality but are unlikely to be all that you need. We expect more and more of these actions to move to external (out-of-tree) controllers that leverage the mutating and validating webhook capabilities. In the near term you may find that building your own webhooks is required (either from scratch or using a framework) for more complex functionality. However, as we see broad admission policy tools like Gatekeeper become more mature, we think this is where a lot of value can be added.<a data-primary="admission control" data-startref="ix_adctrl" data-type="indexterm" id="idm45611983085208"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>