<html><head></head><body>
<div id="sbo-rt-content"><section data-pdf-bookmark="Chapter 17. Extending Kubernetes" data-type="chapter" epub:type="chapter"><div class="chapter" id="extending_kubernetes">
<h1><span class="label">Chapter 17. </span>Extending Kubernetes</h1>
<p>From the beginning, it was clear <a data-primary="extending Kubernetes" data-type="indexterm" id="ix_extnd"/>that Kubernetes was going to be more than its core
set of APIs; once an application is orchestrated within the cluster, there are
countless other useful tools and utilities that can be represented and deployed
as API objects in the Kubernetes cluster. The challenge was how
to embrace this explosion of objects and use cases without having an API that
sprawled without bound.</p>
<p>To resolve this tension between extended use cases and API sprawl, significant effort
was put into making the Kubernetes API extensible. This extensibility meant that cluster operators could customize their clusters with the additional components that suited
their needs. This extensibility enables people to augment their clusters themselves, consume
community-developed cluster add-ons, and even develop extensions that are bundled and
sold in an ecosystem of cluster plug-ins. Extensibility has also given rise to whole
new patterns of managing systems, such as the operator pattern.</p>
<p>Regardless of whether you are building your
own extensions or consuming operators from the ecosystem, understanding how the
Kubernetes API server is extended and how extensions can be built and delivered is
a key component to unlocking the complete power of Kubernetes and its ecosystem.<a data-primary="operators" data-type="indexterm" id="idm45664072220816"/>
As more and more advanced tools and platforms are built on top of Kubernetes using
these extensibility mechanisms, a working knowledge of how they operate is critical
to understanding how to build applications in a modern Kubernetes cluster.</p>
<section data-pdf-bookmark="What It Means to Extend Kubernetes" data-type="sect1"><div class="sect1" id="idm45664072219600">
<h1>What It Means to Extend Kubernetes</h1>
<p>In general, extensions to the Kubernetes API server either add new functionality
to a cluster or limit and tweak the ways that users can interact with their clusters.<a data-primary="extending Kubernetes" data-secondary="meaning of" data-type="indexterm" id="idm45664072218288"/>
There is a rich ecosystem of plug-ins that cluster administrators
can use to add services and capabilities to their clusters. It’s worth
noting that extending the cluster is a very high-privilege thing to do. It is
not a capability that should be extended to arbitrary users or arbitrary code
because cluster administrator privileges are required to extend a cluster. Even
cluster administrators should be careful and use diligence when installing
third-party tools. Some extensions, like admission controllers, can be used to
view all objects being created in the cluster, and could easily be used as a
vector to steal Secrets or run malicious code. Additionally, extending a cluster
makes it different than stock Kubernetes. When running on multiple clusters, it
is very valuable to build tooling to maintain consistency of experience across
the clusters, and this includes the extensions that are installed.</p>
</div></section>
<section data-pdf-bookmark="Points of Extensibility" data-type="sect1"><div class="sect1" id="idm45664072216928">
<h1>Points of Extensibility</h1>
<p>There are many ways to extend Kubernetes, from CustomResourceDefinitions
to Container Network Interface plug-ins. <a data-primary="extending Kubernetes" data-secondary="points of extensibility" data-type="indexterm" id="ix_extndpoints"/><a data-primary="custom resource definitions (CRDs)" data-type="indexterm" id="idm45664072212592"/><a data-primary="CNI (Container Network Interface)" data-type="indexterm" id="idm45664072211856"/><a data-primary="CRI (Container Runtime Interface)" data-type="indexterm" id="idm45664072211168"/><a data-primary="CSI (Container Storage Interface)" data-type="indexterm" id="idm45664072210480"/><a data-primary="Container Storage Interface (CSI)" data-type="indexterm" id="idm45664072209792"/>This chapter is going to focus on extending the API server by adding new resource types or admission controllers to API requests.<a data-primary="APIs" data-secondary="extensions to Kubernetes API" data-type="indexterm" id="idm45664072208976"/><a data-primary="admission controllers" data-type="indexterm" id="idm45664072208016"/>
We will not cover CNI/CSI/CRI (Container Network Interface/Container Storage Interface/Container Runtime Interface) extensions, as they are more commonly used by Kubernetes cluster providers rather than by the Kubernetes end users, for whom this book was written.</p>
<p>In addition to admission controllers and API extensions, there are actually a number of
ways to “extend” your cluster without ever modifying the API server at all. These include
DaemonSets that install automatic logging and monitoring, tools that scan your services for
cross-site scripting (XSS) vulnerabilities, and more. Before embarking on extending your cluster yourself, however, it’s worth
considering the landscape of things that are possible within the confines of the existing
Kubernetes APIs.</p>
<p>To understand the role of admission controllers and CustomResourceDefinitions, it helps to review the flow of requests through the Kubernetes API server, shown in <a data-type="xref" href="#api_server_request_flow">Figure 17-1</a>.</p>
<figure><div class="figure" id="api_server_request_flow">
<img alt="" height="179" src="assets/kur3_1701.png" width="1279"/>
<h6><span class="label">Figure 17-1. </span>API server request flow</h6>
</div></figure>
<p><em>Admission controllers</em> are called prior to the API object being written into the backing
storage.<a data-primary="APIs" data-secondary="Kubernetes API server request flow" data-type="indexterm" id="idm45664072202752"/> Admission controllers can reject or modify API requests. Several
admission controllers are built into the Kubernetes API server; for example,
the limit range admission controller that sets default limits for Pods without them.<a data-primary="admission controllers" data-secondary="built into Kubernetes API server" data-type="indexterm" id="idm45664072201632"/>
Many other systems use custom admission controllers to auto-inject sidecar containers
into all Pods created on the system to enable “auto-magic” experiences.</p>
<p>The other form of extension, which can also be used in conjunction with admission controllers,
is <em>custom resources</em>.<a data-primary="custom resources" data-type="indexterm" id="ix_cusres"/> With custom resources, whole new API objects are added to the Kubernetes
API surface area. <a data-primary="Kubernetes objects" data-secondary="new API objects" data-type="indexterm" id="idm45664072198384"/>These new API objects can be added to namespaces, are subject to RBAC,
and can be accessed with existing tools like <code>kubectl</code> as well as via the Kubernetes API.</p>
<p>The following sections describe these Kubernetes extension points in greater detail and
give both use cases and hands-on examples of how to extend your cluster.</p>
<p>The first thing to do to create a custom resource is to
create a CustomResourceDefinition.<a data-primary="CustomResourceDefinition" data-secondary="defining" data-type="indexterm" id="idm45664072195856"/> This object is actually
a meta-resource; that is, a resource that is the definition
of another resource.</p>
<p>As a concrete example, consider defining a new resource
to represent load tests in your cluster. When a new LoadTest
resource is created, a load test is spun up in your Kubernetes
cluster and drives traffic to a service.</p>
<p>The first step in creating this new resource is defining it
through a CustomResourceDefinition. An example definition looks
as follows:</p>
<pre data-type="programlisting">apiVersion: apiextensions.k8s.io/v1beta1
kind: CustomResourceDefinition
metadata:
  name: loadtests.beta.kuar.com
spec:
  group: beta.kuar.com
  versions:
    - name: v1
      served: true
      storage: true
  scope: Namespaced
  names:
    plural: loadtests
    singular: loadtest
    kind: LoadTest
    shortNames:
    - lt</pre>
<p>You can see that this is a Kubernetes object like any other.
It has a <code>metadata</code> <span class="keep-together">sub-object</span>, and within that sub-object,
the resource is named.<a data-primary="metadata" data-secondary="CustomResourceDefinition" data-type="indexterm" id="idm45664072191520"/> However, in the case of custom
resources, the name is special. It has to be the
format <code><em>&lt;resource-plural&gt;</em>.<em>&lt;api-group&gt;</em></code> to ensure that each resource definition is unique in
the cluster, because the name of each CustomResourceDefinition
has to match this pattern, and no two objects in the cluster
can have the same name. We are thus guaranteed that no two
CustomResourceDefinitions define the same resource.</p>
<p>In addition to metadata, the CustomResourceDefinition has a <code>spec</code>
sub-object. <a data-primary="specifications" data-secondary="spec object for CustomResourceDefinition" data-type="indexterm" id="idm45664072187520"/>This is where the resource itself is defined.
In that <code>spec</code> object, there is an <code>apigroup</code> field that supplies
the API group for the resource.<a data-primary="groups" data-secondary="API group for custom resource" data-type="indexterm" id="idm45664072185392"/> As mentioned previously, it must match
the suffix of the CustomResourceDefinition’s name. Additionally,
there is a list of versions for the resource, which includes the name of the version (e.g., <code>v1</code>, <code>v2</code>, etc.), as well as fields that indicate if that version is served by
the API server and which version is used for storing data
in the backing storage for the API server. <a data-primary="storage" data-secondary="storage field for CustomResourceDefinition" data-type="indexterm" id="idm45664072183248"/>The <code>storage</code> field
must be true for only a single version for the resource.<a data-primary="scope field (CustomResourceDefinition)" data-type="indexterm" id="idm45664072181632"/>
There is also a <code>scope</code> field to indicate whether
the resource is namespaced (the default is namespaced), and a <code>names</code> field that allows for the definition
of the singular, plural, and <code>kind</code> values for the resource. It
also allows the definition of convenience “short names” for
the resource for use in <code>kubectl</code> and elsewhere.</p>
<p>Given this definition, you can create the resource in the
Kubernetes API server. <a data-primary="kubectl tool" data-secondary="commands" data-tertiary="get loadtests" data-type="indexterm" id="idm45664072178752"/>But first, to show the true nature
of dynamic resource types, try to list our <code>loadtests</code> resource
using <code>kubectl</code>:</p>
<pre data-type="programlisting">$ <strong>kubectl get loadtests</strong></pre>
<p>You’ll see that there is no such resource currently defined. Now use <em>loadtest-resource.yaml</em> to create this<a data-primary="kubectl tool" data-secondary="commands" data-tertiary="create -f" data-type="indexterm" id="idm45664072174560"/> resource:</p>
<pre data-type="programlisting">$ <strong>kubectl create -f loadtest-resource.yaml</strong></pre>
<p>Then get the <code>loadtests</code> resource again:</p>
<pre data-type="programlisting">$ <strong>kubectl get loadtests</strong></pre>
<p>This time you’ll see that there is a LoadTest resource type
defined, though there are still no instances of this
resource type.<a data-primary="LoadTest custom resource" data-type="indexterm" id="idm45664072169856"/> Let’s change that by creating a new LoadTest resource.</p>
<p>As with all built-in Kubernetes API objects, you can use
YAML or JSON to define a custom resource (in this case
our LoadTest). See the following definition:</p>
<pre data-type="programlisting">apiVersion: beta.kuar.com/v1
kind: LoadTest
metadata:
  name: my-loadtest
spec:
  service: my-service
  scheme: https
  requestsPerSecond: 1000
  paths:
  - /index.xhtml
  - /login.xhtml
  - /shares/my-shares/</pre>
<p>One thing you’ll note is that we never defined the
schema for the custom resource in the CustomResourceDefinition.
It actually is possible to provide an OpenAPI specification (known previously as Swagger)
for a custom resource, but this complexity is generally
not worth it for simple resource types. If you do want
to perform validation, you can register a validating
admission controller, as described in the following sections.</p>
<p>You can now use this <em>loadtest.yaml</em> file to create a
resource just like you would with any built-in type:</p>
<pre data-type="programlisting">$ <strong>kubectl create -f loadtest.yaml</strong></pre>
<p>Now when you list the <code>loadtests</code> resource, you’ll see your newly
created resource:</p>
<pre data-type="programlisting">$ <strong>kubectl get loadtests</strong></pre>
<p>This may be exciting, but it doesn’t really do anything yet.<a data-primary="CRUD (Create/Read/Update/Delete) API" data-type="indexterm" id="idm45664072163216"/>
Sure, you can use this simple CRUD (Create/Read/Update/Delete) API
to manipulate the data for LoadTest objects, but no actual load
tests are created in response to this new API we defined because there is no controller present in the cluster
to react and take action when a LoadTest object is defined.
The LoadTest custom resource is only half of the infrastructure
needed to add LoadTests to our cluster. The other half is a piece
of code that will continuously monitor the custom resources
and create, modify, or delete LoadTests as necessary to
implement the API.</p>
<p>Just like the user of the API, the controller interacts with
the API server to list <span class="keep-together">LoadTests</span> and watches for any changes
that might occur.<a data-primary="CustomResourceDefinition" data-secondary="interaction between controller and API server" data-type="indexterm" id="idm45664072161008"/> This interaction between controller and
API server is shown in <a data-type="xref" href="#custom_resource_definition_interactions">Figure 17-2</a>.</p>
<figure><div class="figure" id="custom_resource_definition_interactions">
<img alt="" height="256" src="assets/kur3_1702.png" width="968"/>
<h6><span class="label">Figure 17-2. </span>CustomResourceDefinition interactions</h6>
</div></figure>
<p>The code for such a controller can range from simple to complex.
The simplest controllers run a <code>for</code> loop and repeatedly poll for
new custom objects, and then take actions to create or delete
the resources that implement those custom objects (e.g., the LoadTest
worker Pods).</p>
<p>However, this polling-based approach is inefficient: the period of the polling loop adds unnecessary latency, and the overhead of polling may add unnecessary load on the API server.
A more efficient approach is to use the watch API on the API server,
which provides a stream of updates when they occur, eliminating both
the latency and overhead of polling.<a data-primary="watch API on the API server" data-type="indexterm" id="idm45664072155344"/> However, using this API correctly
in a bug-free way is complicated.<a data-primary="Informer pattern" data-type="indexterm" id="idm45664072154448"/> As a result, if you want
to use watches, it is highly recommended that you use a well-supported mechanism such as the <code>Informer</code> pattern exposed in the
<a href="https://oreil.ly/L0QK2"><em>client-go</em> library</a>.</p>
<p>Now that we have created a custom resource and implemented it via
a controller, we have the basic functionality of a new resource in
our cluster.<a data-primary="custom resources" data-secondary="validation and defaulting" data-type="indexterm" id="idm45664072151536"/> However, many parts of what it means to be
a well-functioning resource are missing. The two most important
are validation and defaulting. <em>Validation</em> is the process of ensuring
that LoadTest objects sent to the API server are well formed and
can be used to create load tests, while <em>defaulting</em> makes it easier
for people to use our resources by providing automatic, commonly
used values by default.<a data-primary="validation" data-type="indexterm" id="idm45664072149296"/><a data-primary="defaulting" data-type="indexterm" id="idm45664072148592"/> We’ll now cover adding these capabilities
to our custom resource.</p>
<p>As mentioned earlier, one option for adding validation is via an OpenAPI
specification for our objects. This can be useful for basic
validation of the presence of required fields or the absence of
unknown fields. A complete OpenAPI tutorial is beyond the scope of
this book, but there are lots of resources online, including the <a href="https://oreil.ly/u3rRl">complete Kubernetes API specification</a>.</p>
<p>Generally speaking, an API schema is actually insufficient for
validation of API objects. For example, in our <code>loadtests</code> example, we
may want to validate that the LoadTest object has a valid scheme
(e.g., <em>http</em> or <em>https</em>) or that <code>requestsPerSecond</code> is a nonzero positive number.</p>
<p>To accomplish this, we will use a validating admission controller.<a data-primary="admission controllers" data-secondary="validating admission controller" data-type="indexterm" id="ix_admctrlval"/><a data-primary="validating admission controller" data-type="indexterm" id="ix_valadmctrl"/>
As discussed previously, admission controllers intercept requests to
the API server before they are processed and can reject or modify
the requests in flight. Admission controllers can be added to a
cluster via the dynamic admission control system. A dynamic
admission controller is a simple HTTP application. The API server
connects to the admission controller via either a Kubernetes
Service object or an arbitrary URL. This means that admission
controllers can optionally run outside of the cluster—for example,
in a cloud provider’s Function-as-a-Service offering, like Azure
Functions or AWS Lambda.</p>
<p>To install our validating admission controller, we need to specify
it as a Kubernetes ValidatingWebhookConfiguration.<a data-primary="webhooks" data-secondary="ValidatingWebhookConfiguration" data-type="indexterm" id="idm45664072139936"/><a data-primary="ValidatingWebhookConfiguration" data-type="indexterm" id="idm45664072138944"/> This object
specifies the endpoint where the admission controller runs,
as well as the resource (in this case LoadTest) and the action
(in this case <code>CREATE</code>) where the admission controller should be run.
You can see the full definition for the <a data-primary="validating admission controller" data-secondary="full definition" data-type="indexterm" id="idm45664072137472"/>validating admission controller
in the following code:</p>
<pre data-type="programlisting">apiVersion: admissionregistration.k8s.io/v1beta1
kind: ValidatingWebhookConfiguration
metadata:
  name: kuar-validator
webhooks:
- name: validator.kuar.com
  rules:
  - apiGroups:
    - "beta.kuar.com"
    apiVersions:
    - v1
    operations:
    - CREATE
    resources:
    - loadtests
  clientConfig:
    # Substitute the appropriate IP address for your webhook
    url: https://192.168.1.233:8080
    # This should be the base64-encoded CA certificate for your cluster,
    # you can find it in your ${KUBECONFIG} file
    caBundle: REPLACEME</pre>
<p>Fortunately for security, but unfortunately for complexity, webhooks
that are accessed by the Kubernetes API server can only be
accessed via HTTPS.<a data-primary="webhooks" data-secondary="access via HTTPS" data-type="indexterm" id="idm45664072135120"/><a data-primary="certificates" data-secondary="generating certificate to serve webhook" data-type="indexterm" id="ix_cert"/> So we need to generate a certificate
to serve the webhook. The easiest way to do this is to use the
cluster’s ability to generate new certificates using its
own certificate authority (CA).</p>
<p>First, we need a private key and a<a data-primary="certificate signing request (CSR)" data-type="indexterm" id="idm45664072132400"/> certificate signing request (CSR).
Here’s a simple Go program that generates these:</p>
<pre data-type="programlisting">package main

import (
	"crypto/rand"
	"crypto/rsa"
	"crypto/x509"
	"crypto/x509/pkix"
	"encoding/asn1"
	"encoding/pem"
	"net/url"
	"os"
)

func main() {
	host := os.Args[1]
	name := "server"

	key, err := rsa.GenerateKey(rand.Reader, 1024)
	if err != nil {
		panic(err)
	}
	keyDer := x509.MarshalPKCS1PrivateKey(key)
	keyBlock := pem.Block{
		Type:  "RSA PRIVATE KEY",
		Bytes: keyDer,
	}
	keyFile, err := os.Create(name + ".key")
	if err != nil {
		panic(err)
	}
	pem.Encode(keyFile, &amp;keyBlock)
	keyFile.Close()

	commonName := "myuser"
	emailAddress := "someone@myco.com"

	org := "My Co, Inc."
	orgUnit := "Widget Farmers"
	city := "Seattle"
	state := "WA"
	country := "US"

	subject := pkix.Name{
		CommonName:         commonName,
		Country:            []string{country},
		Locality:           []string{city},
		Organization:       []string{org},
		OrganizationalUnit: []string{orgUnit},
		Province:           []string{state},
	}

	uri, err := url.ParseRequestURI(host)
	if err != nil {
		panic(err)
	}

	asn1, err := asn1.Marshal(subject.ToRDNSequence())
	if err != nil {
		panic(err)
	}
	csr := x509.CertificateRequest{
		RawSubject:         asn1,
		EmailAddresses:     []string{emailAddress},
		SignatureAlgorithm: x509.SHA256WithRSA,
		URIs:               []*url.URL{uri},
	}

	bytes, err := x509.CreateCertificateRequest(rand.Reader, &amp;csr, key)
	if err != nil {
		panic(err)
	}
	csrFile, err := os.Create(name + ".csr")
	if err != nil {
		panic(err)
	}

	pem.Encode(csrFile, &amp;pem.Block{Type: "CERTIFICATE REQUEST", Bytes: bytes})
	csrFile.Close()
}</pre>
<p>You can run this program with:</p>
<pre data-type="programlisting">$ <strong>go run csr-gen.go <em>&lt;URL-for-webhook&gt;</em></strong></pre>
<p>and it will generate two files, <em>server.csr</em> and <em>server-key.pem</em>.</p>
<p>You can then create a certificate signing request for the Kubernetes
API server using the following YAML:</p>
<pre data-type="programlisting">apiVersion: certificates.k8s.io/v1beta1
kind: CertificateSigningRequest
metadata:
  name: validating-controller.default
spec:
  groups:
  - system:authenticated
  request: REPLACEME
  usages:
  usages:
  - digital signature
  - key encipherment
  - key agreement
  - server auth</pre>
<p>You will notice for the <code>request</code> field the value is <code>REPLACEME</code>; this
needs to be replaced with the base64-encoded certificate signing
request we produced in the preceding code:</p>
<pre data-type="programlisting">$ <strong>perl -pi -e s/REPLACEME/$(base64 server.csr | tr -d '\n')/</strong> \
<strong>admission-controller-csr.yaml</strong></pre>
<p>Now that your certificate signing request is ready, you can send it to the API server to get the
certificate:</p>
<pre data-type="programlisting">$ <strong>kubectl create -f admission-controller-csr.yaml</strong></pre>
<p>Next, you need to approve that request:</p>
<pre data-type="programlisting">$ <strong>kubectl certificate approve validating-controller.default</strong></pre>
<p>Once approved, you can download the new certificate:</p>
<pre data-type="programlisting">$ <strong>kubectl get csr validating-controller.default -o json |</strong> \
  <strong>jq -r .status.certificate | base64 -d &gt; server.crt</strong></pre>
<p>With the certificate, you are finally ready to create an SSL-based admission controller (phew!).<a data-primary="certificates" data-secondary="generating certificate to serve webhook" data-startref="ix_cert" data-type="indexterm" id="idm45664072115536"/><a data-primary="SSL-based admission controller" data-type="indexterm" id="idm45664072114224"/>
When the admission controller code receives a request, it contains an object of type <code>AdmissionReview</code>, which contains metadata about the request as
well as the body of the request itself.<a data-primary="AdmissionReview type" data-type="indexterm" id="idm45664072113024"/> In our validating admission controller,
we have only registered for a single resource type and a single action (<code>CREATE</code>),
so we don’t need to examine the request metadata. Instead, we dive directly
into the resource itself and validate that <code>requestsPerSecond</code> is positive
and the URL scheme is valid. If they aren’t, we return a JSON body disallowing the
request.</p>
<p>Implementing an admission controller to provide defaulting<a data-primary="validating admission controller" data-secondary="implementing to provide defaulting" data-type="indexterm" id="idm45664072110576"/> is similar to the steps
just described, but instead of using a ValidatingWebhookConfiguration, you use a
MutatingWebhookConfiguration, and you need to provide a JSON Patch object
to mutate the request object before it is stored.<a data-primary="JSONPath object" data-type="indexterm" id="idm45664072109360"/><a data-primary="MutatingWebhookConfiguration" data-type="indexterm" id="idm45664072108688"/></p>
<p>Here’s a TypeScript snippet that you can add to your validating admission controller
to add defaulting.<a data-primary="defaulting" data-type="indexterm" id="idm45664072107488"/> If the <code>paths</code> field in the <code>loadtest</code> is of length zero, add a single
path for <code>/index.xhtml</code>:</p>
<pre data-type="programlisting">        if (needsPatch(loadtest)) {
            const patch = [
                { 'op': 'add', 'path': '/spec/paths', 'value': ['/index.xhtml'] },
            ]
            response['patch'] = Buffer.from(JSON.stringify(patch))
                .toString('base64');
            response['patchType'] = 'JSONPatch';
        }</pre>
<p>You can then<a data-primary="webhooks" data-secondary="MutatingWebhookConfiguration" data-type="indexterm" id="idm45664072104080"/> register this webhook as a MutatingWebhookConfiguration by simply changing
the <code>kind</code> field in the YAML object and saving the file as <em>mutating-controller.yaml</em>.
Then create the controller by running:</p>
<pre data-type="programlisting">$ <strong>kubectl create -f mutating-controller.yaml</strong></pre>
<p>At this point, you’ve seen a complete example of how to extend the Kubernetes API server using
custom resources and admission controllers. The following section describes some general
patterns for various extensions.<a data-primary="admission controllers" data-secondary="validating admission controller" data-startref="ix_admctrlval" data-type="indexterm" id="idm45664072100480"/><a data-primary="validating admission controller" data-startref="ix_valadmctrl" data-type="indexterm" id="idm45664072099168"/><a data-primary="extending Kubernetes" data-secondary="points of extensibility" data-startref="ix_extndpoints" data-type="indexterm" id="idm45664072098208"/></p>
</div></section>
<section data-pdf-bookmark="Patterns for Custom Resources" data-type="sect1"><div class="sect1" id="idm45664072215376">
<h1>Patterns for Custom Resources</h1>
<p>Not all custom resources are identical.<a data-primary="extending Kubernetes" data-secondary="patterns for custom resources" data-type="indexterm" id="ix_extndpattCR"/><a data-primary="custom resources" data-secondary="patterns for" data-type="indexterm" id="ix_cusrespatt"/> There are a variety of reasons for
extending the Kubernetes API surface area, and the following sections discuss some general patterns you may want to
consider.</p>
<section data-pdf-bookmark="Just Data" data-type="sect2"><div class="sect2" id="idm45664072093568">
<h2>Just Data</h2>
<p>The easiest pattern for API extension is the notion of “just data.” In this pattern, you are<a data-primary="just data pattern" data-type="indexterm" id="idm45664072092160"/><a data-primary="custom resources" data-secondary="patterns for" data-tertiary="just data" data-type="indexterm" id="idm45664072091456"/>
simply using the API server for storage and retrieval of information for your application.
It is important to note that you should <em>not</em> use the Kubernetes API server for application
data storage. The Kubernetes API server is not designed to be a key/value store for your app;
instead, API extensions should be control or configuration objects that help you manage the
deployment or runtime of your application. An example use case for the “just data” pattern
might be configuration for canary deployments of your application—for example, directing
10% of all traffic to an experimental backend. While in theory such configuration information
could also be stored in a ConfigMap, ConfigMaps are essentially untyped, and sometimes
using a more strongly typed API extension object provides clarity and ease of use.</p>
<p>Extensions that are just data don’t need a corresponding controller to activate them, but
they may have validating or mutating admission controllers to ensure that they are well formed.
For example, in the canary use case, a validating controller might ensure that
all percentages in the canary object sum to 100%.</p>
</div></section>
<section data-pdf-bookmark="Compilers" data-type="sect2"><div class="sect2" id="idm45664072088816">
<h2>Compilers</h2>
<p>A slightly more complicated <a data-primary="custom resources" data-secondary="patterns for" data-tertiary="compilers" data-type="indexterm" id="idm45664072087488"/>pattern is the “compiler” or “abstraction” pattern.<a data-primary="compiler (or abstraction) pattern" data-type="indexterm" id="idm45664072086112"/> In this pattern, the API extension object represents a higher-level abstraction that is “compiled” into a combination of lower-level Kubernetes objects. The LoadTest extension in the previous example is an example of this compiler abstraction pattern. A user consumes the extension as a high-level concept, in this case a <code>loadtest</code>, but it comes into being by being deployed as a collection of Kubernetes Pods and services. To achieve this, a compiled abstraction requires an API controller to be running somewhere in the cluster to watch the current LoadTests and create the “compiled” representation (and likewise delete representations that no longer exist). In contrast to the operator pattern described next, however, there is no online health maintenance for compiled abstractions; it is delegated down to the lower-level objects (e.g., Pods).</p>
</div></section>
<section data-pdf-bookmark="Operators" data-type="sect2"><div class="sect2" id="idm45664072083984">
<h2>Operators</h2>
<p>While compiler extensions provide easy-to-use abstractions, extensions that use the “operator”
pattern provide online, proactive management of the resources created by the extensions.<a data-primary="custom resources" data-secondary="patterns for" data-tertiary="operators" data-type="indexterm" id="idm45664072082656"/><a data-primary="operators" data-secondary="extensions using" data-type="indexterm" id="idm45664072081408"/> These
extensions likely provide a higher-level abstraction (for example, a database) that is compiled
down to a lower-level representation, but they also provide online functionality, such as
snapshot backups of the database or upgrade notifications when a new version of the software
is available. To achieve this, the controller not only monitors the extension API to add or remove
things as necessary, but also monitors the running state of the application
supplied by the extension (e.g., a database) and takes actions to remediate unhealthy databases,
take snapshots, or restore from a snapshot if a failure occurs.</p>
<p>Operators are the most complicated
pattern for API extension of Kubernetes, but they are also the most powerful, enabling users to
get easy access to “self-driving” abstractions that are responsible not just for deployment, but
also health checking and repair.<a data-primary="extending Kubernetes" data-secondary="patterns for custom resources" data-startref="ix_extndpattCR" data-type="indexterm" id="idm45664072079664"/><a data-primary="custom resources" data-secondary="patterns for" data-startref="ix_cusrespatt" data-type="indexterm" id="idm45664072078400"/><a data-primary="custom resources" data-startref="ix_cusres" data-type="indexterm" id="idm45664072077184"/></p>
</div></section>
<section data-pdf-bookmark="Getting Started" data-type="sect2"><div class="sect2" id="idm45664072075984">
<h2>Getting Started</h2>
<p>Getting started extending the Kubernetes API can be a daunting and exhausting
experience.<a data-primary="extending Kubernetes" data-secondary="getting started, using Kubebuilder project library" data-type="indexterm" id="idm45664072074576"/><a data-primary="Kubebuilder project, library for Kubernetes API extensions" data-type="indexterm" id="idm45664072073504"/> Fortunately, there is a great deal of code to help you out.
The <a href="https://kubebuilder.io">Kubebuilder project</a> contains a library of code
intended to help you easily build reliable Kubernetes API extensions. It’s a
great resource to help you bootstrap your extension.</p>
</div></section>
</div></section>
<section class="pagebreak-before less_space" data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45664072071536">
<h1>Summary</h1>
<p>One of the great “superpowers” of Kubernetes is its ecosystem, and one of the most significant
things powering this ecosystem is the extensibility of the Kubernetes API. Whether you’re designing
your own extensions to customize your cluster or consuming off-the-shelf extensions as utilities,
cluster services, or operators, API extensions are the key to making your cluster your own and
building the right environment for the rapid development of reliable applications.<a data-primary="extending Kubernetes" data-startref="ix_extnd" data-type="indexterm" id="idm45664072069920"/></p>
</div></section>
</div></section></div></body></html>