- en: Chapter 9\. State Management with Pinia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapter guided us through building our application’s routings using
    Vue Router, including nested routes, route guards, and dynamic route navigation.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn state management and how to manage the data flow
    within our Vue application using Pinia, the officially recommended state management
    library for Vue. We will also explore how to build our application’s reusable
    and efficient data state management system.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding State Management in Vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data makes an application come to life and connects components. And components
    interact with users and with others using data states. State management is crucial
    for building an application that works with actual data, regardless of size and
    complexity. For example, we can display only a gallery of product cards with a
    list of pizzas and their details. Once a user adds a product to the cart within
    this gallery component, we need to update the cart’s data and display the updated
    cart’s data in the cart component at the same time as updating the chosen product’s
    remaining stock.
  prefs: []
  type: TYPE_NORMAL
- en: Take our Pizza House application, for example. In the main view (`App.vue`),
    we have a header component (`HeaderView`) and a gallery of pizza cards (`PizzasView`).
    The header contains a cart icon that displays the number of items in the cart,
    while the gallery includes a list of pizza cards, each with a button allowing
    the user to add the selected item to the cart. [Figure 9-1](#figure_ch08_diagram)
    illustrates the hierarchical structure of the components from the main view.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot showing the tree structure of the App component, where the header
    component and the gallery component are the children of the App and sibling to
    each other](assets/lvue_0901.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-1\. Hierarchy structure of the components from the main view of Pizza
    House
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When a user adds a pizza to the cart, the cart icon will display the updated
    number of items. To enable data communication between the header component and
    the gallery component, we can have the `App` manage the `cart` data and pass its
    data to the header as props while communicating with the gallery using an event
    `updateCart`, as seen in [Figure 9-2](#figure_ch08_dataflow).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot showing the data flow between the components, where the App component
    manages the cart data and passes it to the header component as props, and communicates
    with the gallery component using an event updateCart](assets/lvue_0902.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-2\. Data flow between the gallery and header with the App as the middleman
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This approach works well for small applications. However, suppose we want to
    split `PizzasView` into subcomponents, such as `PizzasGallery`, and have `PizzasGallery`
    render the `PizzaCard` component for each pizza. For each new parent-child layer,
    we will need to propagate the `updateCart` event to ensure the propagation of
    the data flow between the gallery and the header, as in [Figure 9-3](#figure_ch08_dataflow2).
  prefs: []
  type: TYPE_NORMAL
- en: It will become more complicated when we have more components and layers, leaving
    a lot of unnecessary props and events. As a result, this approach could be less
    scalable and maintainable when our application grows.
  prefs: []
  type: TYPE_NORMAL
- en: To reduce this overhead and manage the state flows within the application, we
    need a global state management system, a centralized place to store and manage
    the data states of the application. This system is responsible for managing the
    data states and distributing the data to the necessary components.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most popular approaches to provide developers with a smooth experience
    is using a state management library, such as Pinia.
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot showing the data flow between the components, where the App component
    manages the cart data and passes it to the header component as props, and communicates
    with the gallery component using an event updateCart](assets/lvue_0903.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-3\. Data flow between the gallery with children and header, with the
    App as the middleman
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Understanding Pinia
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Inspired by Vuex^([1](ch09.html#id1395)) and Vue Composition API, Pinia is Vue’s
    current official state management library. Nevertheless, you can always use other
    state management JavaScript libraries that support Vue, such as Vuex, MobX and
    XState.
  prefs: []
  type: TYPE_NORMAL
- en: Pinia follows the store pattern of Vuex but with a more flexible and scalable
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The official Pinia documentation is available at the [Pinia website](https://oreil.ly/JoOwm),
    with information on installation, APIs, and primary use cases for reference.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having a single system for all data sets used across the application,
    with Pinia, we can split each data set into its state module (or store). We then
    can access relevant data in a store from any component using a custom composable,
    following the Composition API pattern.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a Vue project from scratch using Vite, we can choose to install
    Pinia as the state management during the scaffolding process (see [“Create a New
    Vue Application”](ch01.html#chapter_01_newVueApp)). Vite will create our project
    with Pinia installed and configured with an example `counter` store, exposed as
    `useCounterStore`, located in `src/stores/counter.ts`.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, to fully understand how Pinia works, we will skip the scaffolding
    option and add Pinia manually using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this book, we use Pinia 2.1.3, the latest version at the time of writing.
    You can replace the version number after `@` with the newest version from the
    [Pinia NPM page](https://oreil.ly/zCUCg).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Pinia is installed, navigate to `src/main.ts` and import `createPinia`
    from the `pinia` package, use it to create a new Pinia instance, and plug it into
    the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Import `createPinia` from the `pinia` package
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_state_management_with_pinia_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Pinia instance
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_state_management_with_pinia_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Plug the Pinia instance into the application for use
  prefs: []
  type: TYPE_NORMAL
- en: 'With Pinia installed and plugged in, we will create the first store for our
    application: a `pizzas` store to manage the available pizzas for the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Pizzas Store for Pizza House
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As Pinia follows the store pattern of Vuex, a store in Pinia contains the following
    fundamental properties:'
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs: []
  type: TYPE_NORMAL
- en: The reactive data (state) of the store, created by using `ref()` or `reactive()`
    methods from Composition API.
  prefs: []
  type: TYPE_NORMAL
- en: Getters
  prefs: []
  type: TYPE_NORMAL
- en: The computed and read-only properties of the store, created by using the `computed()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs: []
  type: TYPE_NORMAL
- en: The methods to update the store’s state or perform custom logic on the store’s
    data (state).
  prefs: []
  type: TYPE_NORMAL
- en: 'Pinia provides a `defineStore` function to create a new store, which accepts
    two arguments: the store’s name and properties, and the methods available for
    use in other components. The store’s properties and methods can be an object with
    the key fields `state`, `getters`, `actions` following Options API ([Example 9-1](#example_ch8_01)),
    or a function that uses Composable API and return an object with the fields to
    expose ([Example 9-2](#example_ch8_02)).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-1\. Defining a store using an object configuration
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Example 9-2\. Defining a store using a function
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This chapter will focus on using Pinia stores with Vue 3.x Composition API,
    usually known as *setup stores*.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go back to our `pizzas` store. We add a new file, `src/stores/pizzas.ts`,
    with the code shown in [Example 9-3](#pizzas_store).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-3\. Pizzas store
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Then in `PizzasView` (based on the previous chapter’s [Example 8-2](ch08.html#pizza_view_component)
    component), we will use the `pizzas` and `fetchPizzas` properties from the `pizzas`
    store to fetch and display the list of pizzas from our API as in [Example 9-4](#pizza_view_component_store).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-4\. `PizzasView` component using the pizzas store
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Render the list of pizzas using `pizzasStore.pizzas`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_state_management_with_pinia_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `usePizzasStore` function from the `pizzas` store and use it to get
    the `pizzasStore` instance.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_state_management_with_pinia_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Fetch the pizzas from the API when the component is mounted asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: With the previous code, our `PizzasView` component is now using the `pizzas`
    store to fetch and display the list of pizzas from our API ([Figure 9-4](#figure_ch8_pizzasview)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Screenshot showing a list of pizzas](assets/lvue_0904.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-4\. `PizzasView` component using the pizzas store
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Great. Nevertheless, notice that we no longer have the search functionality,
    which uses the `useSearch()` composable from the previous chapter’s [Example 8-3](ch08.html#useSearch_hook).
    If we pass `pizzasStore.pizzas` directly to the `useSearch()` composable as `items`,
    it will lose the reactivity, and `searchResults` won’t get recalculated after
    `pizzasStore.fetchPizzas()` resolves. To fix this issue, we use `storeToRefs()`
    from `pinia` to extract `pizzas` from the `pizzasStore` and keep its reactivity
    when passing to `useSearch()` ([Example 9-5](#useSearch_working)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-5\. `useSearch()` composable working with pizzas store
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now our template uses the `searchResults` instead of `pizzasStore.pizzas` and
    we can bring the search `input` field back ([Example 9-6](#pizzasview_search)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-6\. `PizzasView` component with a search using the pizzas store
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will create a cart store to manage the current user’s cart data, including
    the list of items added.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Cart Store for Pizza House
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our `cart` store, we define our `cart` store with the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of `items` added to the cart; each item contains the `id` and `quantity`
    of the pizza
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `total` items of the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `add` method to add an item from the cart
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create our `cart` store, we add a new file, `src/stores/cart.ts`, with the
    code shown in [Example 9-7](#cart_store).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-7\. Cart store
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Define the type of the cart item
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_state_management_with_pinia_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the `items` state with an empty array
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_state_management_with_pinia_CO3-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `total` getter to calculate the total items in the cart
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_state_management_with_pinia_CO3-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Create an `add` action to add an item to the cart. If the item is already in
    the cart, the quantity will update instead of adding a new item.
  prefs: []
  type: TYPE_NORMAL
- en: With the `cart` store created, we can now use it in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Cart Store in a Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a new component, `src/components/Cart.vue`, to display the cart’s
    total items. Within the `<script setup()>` section, we import the `useCartStore()`
    method and call it to get the `cart` instance. Then in the template, we display
    the total items in the cart by using the `cart.total` getter, as seen in [Example 9-8](#cart_component).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-8\. Cart component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We then see the cart displayed with the initial value of `0` ([Figure 9-5](#figure_08_app_cart))
    when we use the `<Cart />` component in our `App.vue` as in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Cart component displayed in the application](assets/lvue_0905.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-5\. Cart component displayed in the header of the application
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Next, let’s enable adding items to the cart from our pizzas gallery for each
    pizza rendered by `PizzaCard`.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Items to the Cart from the Pizzas Gallery
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `PizzaCard`, we will add a button with the `click` event handler calling
    the `cart.add()` action to add the pizza to the cart. The `PizzaCard` component
    will look like [Example 9-9](#ch8_pizza_card_component).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-9\. `PizzaCard` component
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Add a button to add the pizza to the cart
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_state_management_with_pinia_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the `cart` instance from the `useCartStore()` method
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_state_management_with_pinia_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Call the `cart.add()` action to add the pizza to the cart within the `addToCart()`
    method
  prefs: []
  type: TYPE_NORMAL
- en: With the previous code, in the browser, we can add a pizza to the cart by clicking
    on the “Add to cart” button and see the cart’s total items updated ([Figure 9-6](#figure_08_cart_total)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Pizza card with adding option and updated cart total](assets/lvue_0906.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-6\. Pizza card with adding option and updated cart total
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We can also use the `cart.items` to detect whether the current pizza is already
    in the cart, and display its status on the pizza card, as in [Example 9-10](#ch8_pizza_card_component_2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-10\. `PizzaCard` component with status
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The “In cart” status is displayed on the pizza card if the pizza is already
    in the cart ([Figure 9-7](#figure_08_cart_status)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Pizza card with status](assets/lvue_0907.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-7\. Pizza card with status
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have successfully created a cart store and used it in our Pizza House. The
    `Cart` and the `PizzaCard` component now synchronize and communicate through the
    `cart` store.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the `Cart` component currently displays only the total items
    in the cart, which, most of the time, is not enough for users to understand what
    they have added. In the next section, we will improve this experience by displaying
    the cart items when users click on the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying Cart Items with Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `Cart.vue`, we will add a section displaying the list of cart items and a
    `showCart` `Details` variable to control the list’s visibility. We will toggle
    the visibility of the list when users click on the cart text, as shown in [Example 9-11](#ch8_cart_component_2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-11\. Cart component with cart items
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Toggle the visibility of the cart items list when users click on the cart text
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_state_management_with_pinia_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Display the cart items list when `showCartDetails` is `true`
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_state_management_with_pinia_CO5-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Loop through the cart items and display the item id and quantity
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_state_management_with_pinia_CO5-6)'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize a `showCartDetails` variable using the `ref()` method
  prefs: []
  type: TYPE_NORMAL
- en: 'We also add some CSS styles to the `Cart` component to position the list to
    look like a dropdown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the position of the `.cart` container to `relative` to make the `absolute`
    list container float within the container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_state_management_with_pinia_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the position of the list container to `absolute` to make it float concerning
    the `relative` positioned `.cart` container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_state_management_with_pinia_CO6-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Set the `inset-inline-end` property to `0` to make the list container float
    to the right of the `.cart` container.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_state_management_with_pinia_CO6-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Add box shadow and border to the list container to make it look like a dropdown.
  prefs: []
  type: TYPE_NORMAL
- en: When we click on the cart text, the cart items list will be displayed ([Figure 9-8](#figure_08_cart_items)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Cart items list displayed when clicking on the cart text](assets/lvue_0908.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-8\. Cart items list displayed when clicking on the cart text
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But wait, there is a problem. The list displays only the items `id` and `quantity`,
    which needs to be more descriptive for users to understand what item they have
    added as well as the total cost. We also need to display the item’s name and price.
    To do so, we can modify the `cart.items` to keep the item’s title and price, but
    this would make the `cart` store’s structure complex and would require additional
    logic fixes.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we can create a computed `detailedItems` list with the help of the
    pizzas store.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `cart.ts` store, we will add a `detailedItems` computed property,
    which will be the joined array from `items` and from the `pizzasStore.pizzas`
    of the pizzas store, as in [Example 9-12](#ch8_cart_store_2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-12\. Cart store with `detailedItems` computed property
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Get the initial list of pizzas from the store using `usePizzaStore`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_state_management_with_pinia_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Filter the relevant pizzas presented in the cart
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_state_management_with_pinia_CO7-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Format the cart items’ information to return
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_state_management_with_pinia_CO7-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Return the filtered and formatted array `detailedItems`
  prefs: []
  type: TYPE_NORMAL
- en: In `Cart.vue`, we will replace the `cart.items` with `cart.detailedItems` in
    the `v-for` loop, as shown in [Example 9-13](#ch8_cart_component_3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-13\. Using `detailedItems` to display more information
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Iterate the `cart.detailedItems` array to display cart’s items
  prefs: []
  type: TYPE_NORMAL
- en: Now, when we click on the cart text, the cart items list will display the item’s
    name, price, quantity, and total cost per item ([Figure 9-9](#figure_08_cart_items_2)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Cart items list displayed with more information](assets/lvue_0909.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-9\. Cart items list displayed with more information
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have successfully displayed the cart items’ details. Next we can add the
    ability to be able to remove items from the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Removing Items from the Cart Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For each item in the cart’s list, we will add a *Remove* button to be able to
    remove it from the cart. We will also add a *Remove all* button to remove all
    items from the cart. The `template` section of `Cart.vue` will look like [Example 9-14](#ch8_cart_component_4).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-14\. Cart component with Remove and Remove all buttons
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The Remove button binds to the `cart.remove` method, which takes the item’s
    `id` as an argument
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_state_management_with_pinia_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The Remove all button binds to the `cart.clear` method
  prefs: []
  type: TYPE_NORMAL
- en: In `cart.ts`, we will add the `remove` and `clear` methods, as shown in [Example 9-15](#ch8_cart_store_3).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-15\. Cart store with `remove` and `clear` methods
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: And that’s it! Vue removes the item from the cart when we click the *Remove*
    button. And it will empty the cart when we click the *Remove all* button; see
    [Figure 9-10](#figure_08_cart_remove).
  prefs: []
  type: TYPE_NORMAL
- en: '![Cart items with remove and remove all buttons](assets/lvue_0910.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-10\. Cart items with Remove and Remove all buttons
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you are building the `cart` store using Options API, you can use `cart.$reset()`
    to reset the store’s state to its initial state. Otherwise, you must manually
    reset the store’s state, as we did in the `clear` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can also use the Vue Devtool tab ([“Vue Developer Tools”](ch01.html#vue_devtools_ch1))
    in the browser’s Developer Tools to inspect the `cart` store’s state and getters.
    The `cart` and `pizzas` store will be listed under the `Pinia` tab ([Figure 9-11](#figure_08_cart_devtools)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Cart and pizzas stores in Vue Devtools](assets/lvue_0911.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-11\. Cart and pizzas stores in Vue Devtools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We have explored how to build stores using Pinia and Composition API. We have
    also explored different approaches, such as combining stores and using the store’s
    state in external composables. What about testing Pinia stores? Let’s explore
    that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Unit Testing Pinia Stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit testing a store is similar to regular unit testing a function. For Pinia,
    before running the actual tests, we need to create a Pinia instance using `createPinia`
    and activate it with the `setActivePinia()` method from the `pinia` package. [Example 9-16](#ch8_cart_store_test_1)
    shows how we write the test of adding an item to a cart for our `cart` store.
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-16\. Cart store test suite for adding items
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_state_management_with_pinia_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: We create and activate a new Pinia instance before each test run.
  prefs: []
  type: TYPE_NORMAL
- en: This code follows the common testing syntax supported by Jest and `Vitest` testing
    frameworks. We will explore more details on writing and running unit tests in
    [“Vitest as a Unit Testing Tool”](ch11.html#vitest_chap10). For now, we will explore
    how to subscribe to store changes and add side effects to store actions.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing Side Effects on Store Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One significant advantage of Pinia is the ability to extend the store’s functionalities
    and implement side effects using plugins. With this ability, we can easily subscribe
    to changes in all the stores or in a specific store to perform additional actions
    like synchronizing data with the server when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the following `cartPlugin`, for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `cartPlugin` is a function that receives an object containing a reference
    to the `app` instance, the `pinia` instance, the `store` instance, and an options
    object. Vue will trigger this function once for every store in our application.
    To make sure we are subscribing only to the `cart` store, we can check the store’s
    id (see [Example 9-17](#ch8_cart_plugin_1)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-17\. Cart plugin
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then we can subscribe to the cart store changes using the `store.$subscribe`
    method, as in [Example 9-18](#ch8_cart_plugin_2).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-18\. Cart plugin subscribing to store changes
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When we add an item to the cart, the `cartPlugin` will log the message to the
    console ([Figure 9-12](#figure_08_cart_plugin)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Cart plugin logging store changes](assets/lvue_0912.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-12\. Log the store changes using plugin
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `options` object received by the `$subscribe` method contains the `events`
    object, which contains the current event’s type (`add`), the previous value (`oldValue`),
    the current values passed to the event (`newValue`), the `storeId`, and the type
    of the event (`direct`).
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can add a side effect to the `cart` store’s `add` action using
    `store.$on` `Action` ([Example 9-19](#ch8_cart_plugin_3)).
  prefs: []
  type: TYPE_NORMAL
- en: Example 9-19\. Cart plugin subscribing to store’s adding action
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When we add an item to the cart, the `cartPlugin` will log the new item added
    to the cart ([Figure 9-13](#figure_08_cart_plugin_action)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Cart plugin logging store''s adding action](assets/lvue_0913.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9-13\. Cart plugin logging store’s adding action
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: With `$subscribe` and `$onAction`, we can add side effects such as logging and
    communicating with external API services such as updating the user’s cart in the
    server, etc. Additionally, if we have an `$onAction` and `$subscribe` in the same
    plugin, Vue will trigger the `$onAction` first, followed by the relevant `$subscribe`.
  prefs: []
  type: TYPE_NORMAL
- en: Using Side Effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s crucial to note that Vue triggers every side effect we add to the store.
    For example, for [Example 9-19](#ch8_cart_plugin_3), Vue will activate the side
    effect function for every action executed in the store. Hence, we must be very
    cautious when adding side effects to the store to avoid performance issues.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Pinia to build stores and use them in
    our application with the help of Composition API. We also learned how to destructure
    and pass the store’s state to external composables with reactivity and how to
    subscribe to store changes and add side effects to store actions. You are now
    ready to create a complete data flow from building a centralized data store, using
    it in different components, and connecting between components through the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter will explore a different aspect of Vue’s capabilities in enhancing
    the user experience: adding animations and transitions to our application and
    components.'
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch09.html#id1395-marker)) Vuex was previously the official state management
    for Vue applications.
  prefs: []
  type: TYPE_NORMAL
