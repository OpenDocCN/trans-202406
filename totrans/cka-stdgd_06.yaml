- en: Chapter 6\. Storage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When container images are instantiated as containers, the container needs context—context
    to CPU, memory, and I/O resources. Pods provide the network and the filesystem
    context for the containers within. The network is provided as the Pod’s virtual
    IP address, and the filesystem is mounted to the hosting node’s filesystem. Applications
    running in the container can interact with the filesystem as part of the Pod context.
    A container’s temporary filesystem is isolated from any other container or Pod
    and is not persisted beyond a Pod restart. The “Storage” section of the CKA curriculum
    addresses the technical abstraction in Kubernetes responsible for persisting data
    beyond a container or Pod restart.
  prefs: []
  type: TYPE_NORMAL
- en: A volume is a Kubernetes capability that persists data beyond a Pod restart.
    Essentially, a volume is a directory that’s shareable between multiple containers
    of a Pod. You will learn about the different volume types and the process for
    defining and mounting a volume in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent volumes are a specific category of the wider concept of volumes.
    The mechanics for persistent volumes are slightly more complex. The persistent
    volume is the resource that actually persists the data to an underlying physical
    storage. The persistent volume claim represents the connecting resource between
    a Pod and a persistent volume responsible for requesting the storage. Finally,
    the Pod needs to *claim* the persistent volume and mount it to a directory path
    available to the containers running inside of the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a high level, this chapter covers the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Persistent volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static versus dynamic provision of persistent volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storage Class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration options for a persistent volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Persistent volume claim
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting a persistent volume in a Pod
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications running in a container can use the temporary filesystem to read
    and write files. In the case of a container crash or a cluster/node restart, the
    kubelet will restart the container. Any data that had been written to the temporary
    filesystem is lost and cannot be retrieved anymore. The container effectively
    starts with a clean slate again.
  prefs: []
  type: TYPE_NORMAL
- en: There are many uses cases for wanting to mount a volume in a container. One
    of the most prominent use cases are [multi-container Pods](https://oreil.ly/EtTx4)
    that use a volume to exchange data between a main application container and a
    sidecar. [Figure 6-1](#tmp_file_system_volume) illustrates the differences between
    the temporary filesystem of a container and the use of a volume.
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0601](Images/ckas_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. A container using the temporary filesystem versus a volume
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Volume Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every volume needs to define a type. The type determines the medium that backs
    the volume and its runtime behavior. The Kubernetes documentation offers a long
    list of volume types. Some of the types—for example, `azureDisk`, `awsElasticBlockStore`,
    or `gcePersistentDisk`—are available only when running the Kubernetes cluster
    in a specific cloud provider. [Table 6-1](#table_volume_types) shows a reduced
    list of volume types that I deem to be most relevant to the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-1\. Volume types relevant to exam
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `emptyDir` | Empty directory in Pod with read/write access. Persisted for
    only the lifespan of a Pod. A good choice for cache implementations or data exchange
    between containers of a Pod. |'
  prefs: []
  type: TYPE_TB
- en: '| `hostPath` | File or directory from the host node’s filesystem. |'
  prefs: []
  type: TYPE_TB
- en: '| `configMap`, `secret` | Provides a way to inject configuration data. For
    practical examples, see [“Defining and Consuming Configuration Data”](ch03.xhtml#defining_consuming_configuration_data).
    |'
  prefs: []
  type: TYPE_TB
- en: '| `nfs` | An existing Network File System (NFS) share. Preserves data after
    Pod restart. |'
  prefs: []
  type: TYPE_TB
- en: '| `persistentVolumeClaim` | Claims a persistent volume. Fore more information,
    see [“Creating PersistentVolumeClaims”](#creating_pvc). |'
  prefs: []
  type: TYPE_TB
- en: Creating and Accessing Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Defining a volume for a Pod requires two steps. First, you need to declare the
    volume itself using the attribute `spec.volumes[]`. As part of the definition,
    you provide the name and the type. Just declaring the volume won’t be sufficient,
    though. Second, the volume needs to be mounted to a path of the consuming container
    via `spec.containers.volumeMounts[]`. The mapping between the volume and the volume
    mount occurs by the matching name.
  prefs: []
  type: TYPE_NORMAL
- en: From the YAML manifest stored in the file `pod-with-volume.yaml` and shown in
    [Example 6-1](#pod_defining_mounting_volume), you can see the definition of a
    volume with type `emptyDir`. The volume has been mounted to the path */var/logs*
    inside of the container named `nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-1\. A Pod defining and mounting a volume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create the Pod and see if we can interact with the mounted volume. The
    following commands open an interactive shell after the Pod’s creation and then
    navigate to the mount path. You can see that the volume type `emptyDir` initializes
    the mount path as an empty directory. New files and directories can be created
    as needed without limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Persistent Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Data stored on Volumes outlive a container restart. In many applications, the
    data lives far beyond the lifecycles of the applications, container, Pod, nodes,
    and even the clusters themselves. Data persistence ensures the lifecycles of the
    data are decoupled from the lifecycles of the cluster resources. A typical example
    would be data persisted by a database. That’s the responsibility of a persistent
    volume. Kubernetes models persist data with the help of two primitives: the PersistentVolume
    and the PersistentVolumeClaim.'
  prefs: []
  type: TYPE_NORMAL
- en: The PersistentVolume is the storage device in a Kubernetes cluster. It is completely
    decoupled from the Pod and therefore has its own lifecycle. The object captures
    the source of the storage (e.g., storage made available by a cloud provider).
    A PersistentVolume is either provided by a Kubernetes administrator or assigned
    dynamically by mapping to a storage class.
  prefs: []
  type: TYPE_NORMAL
- en: The PersistentVolumeClaim requests the resources of a PersistentVolume—for example,
    the size of the storage and the access type. In the Pod, you will use the type
    `persistentVolumeClaim` to mount the abstracted PersistentVolume by using the
    PersistentVolumeClaim.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 6-2](#pvc_relationship) shows the relationship between the Pod, the
    PersistentVolumeClaim, and the PersistentVolume.'
  prefs: []
  type: TYPE_NORMAL
- en: '![ckas 0602](Images/ckas_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Claiming a PersistentVolume from a Pod
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Static vs. Dynamic Provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A PersistentVolume can be created statically or dynamically. If you go with
    the static approach, then you need to create a storage device first and reference
    it by explicitly creating an object of kind PersistentVolume. The dynamic approach
    doesn’t require you to create a PersistentVolume object. It will be automatically
    created from the PersistentVolumeClaim by setting a storage class name using the
    attribute `spec.storageClassName`.
  prefs: []
  type: TYPE_NORMAL
- en: A storage class is an abstraction concept that defines a class of storage device
    (e.g., storage with slow or fast performance) used for different application types.
    It’s the job of a Kubernetes administrator to set up storage classes. For a deeper
    discussion on storage classes, see [“Understanding Storage Classes”](#understanding_storage_class).
    For now, we’ll focus on the static provisioning of PersistentVolumes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating PersistentVolumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you create a PersistentVolume object yourself, we refer to the approach
    as static provisioning. A PersistentVolume can be created only by using the manifest-first
    approach. At this time, `kubectl` doesn’t allow the creation of a PersistentVolume
    using the `create` command. Every PersistentVolume needs to define the storage
    capacity using `spec.capacity` and an access mode set via `spec.accessModes`.
    See [“Configuration Options for a PersistentVolume”](#configuring_pv) for more
    information on the configuration options available to a PersistentVolume.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 6-2](#yaml_manifest_persistent_volume) creates a PersistentVolume
    named `db-pv` with a storage capacity of 1Gi and read/write access by a single
    node. The attribute `hostPath` mounts the directory `/data/db` from the host node’s
    filesystem. We’ll store the YAML manifest in the file `db-pv.yaml`.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-2\. YAML manifest defining a PersistentVolume
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon inspection of the created PersistentVolume, you’ll find most of the information
    you provided in the manifest. The status `Available` indicates that the object
    is ready to be claimed. The reclaim policy determines what should happen with
    the PersistentVolume after it has been released from its claim. By default, the
    object will be retained. The following example uses the short-form command `pv`
    to avoid having to type `persistentvolume`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Configuration Options for a PersistentVolume
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A PersistentVolume offers a variety of configuration options that determine
    their innate runtime behavior. For the exam, it’s important to understand the
    volume mode, access mode, and reclaim policy configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Volume Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The volume mode handles the type of device. That’s a device either meant to
    be consumed from the filesystem or backed by a block device. The most common case
    is a filesystem device. You can set the volume mode using the attribute `spec.volumeMode`.
    [Table 6-2](#persistentvolume_volume_modes) shows all available volume modes.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-2\. PersistentVolume volume modes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Filesystem` | Default. Mounts the volume into a directory of the consuming
    Pod. Creates a filesystem first if the volume is backed by a block device and
    the device is empty. |'
  prefs: []
  type: TYPE_TB
- en: '| `Block` | Used for a volume as a raw block device without a filesystem on
    it. |'
  prefs: []
  type: TYPE_TB
- en: 'The volume mode is not rendered by default in the console output of the `get
    pv` command. You will need to provide the `-o wide` command-line option to see
    the VOLUMEMODE column, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Access Mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each PersistentVolume can express how it can be accessed using the attribute
    `spec.accessModes`. For example, you can define that the volume can be mounted
    only by a single Pod in a read or write mode or that a volume is read-only but
    accessible from different nodes simultaneously. [Table 6-3](#persistentvolume_access_modes)
    provides a high-level overview of the available access modes. The short-form notation
    of the access mode is usually rendered in outputs of specific commands, e.g.,
    `get pv` or `describe pv`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-3\. PersistentVolume access modes
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Short Form | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteOnce` | RWO | Read/write access by a single node |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadOnlyMany` | ROX | Read-only access by many nodes |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteMany` | RWX | Read/write access by many nodes |'
  prefs: []
  type: TYPE_TB
- en: '| `ReadWriteOncePod` | RWOP | Read/write access mounted by a single Pod |'
  prefs: []
  type: TYPE_TB
- en: 'The following command parses the access modes from the PersistentVolume named
    `db-pv`. As you can see, the returned value is an array underlining the fact that
    you can assign multiple access modes at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Reclaim Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Optionally, you can also define a reclaim policy for a PersistentVolume. The
    reclaim policy specifies what should happen to a PersistentVolume object when
    the bound PersistentVolumeClaim is deleted (see [Table 6-4](#persistentvolume_reclaim_policy)).
    For dynamically created PersistentVolumes, the reclaim policy can be set via the
    attribute `.reclaimPolicy` in the storage class. for statically created PersistentVolumes,
    use the attribute `spec.persistentVolumeReclaimPolicy` in the PersistentVolume
    definition .
  prefs: []
  type: TYPE_NORMAL
- en: Table 6-4\. PersistentVolume reclaim policies
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Retain` | Default. When PersistentVolumeClaim is deleted, the PersistentVolume
    is “released” and can be reclaimed. |'
  prefs: []
  type: TYPE_TB
- en: '| `Delete` | Deletion removes PersistentVolume and its associated storage.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Recycle` | This value is deprecated. You should use one of the values above.
    |'
  prefs: []
  type: TYPE_TB
- en: 'The following command retrieves the assigned reclaim policy of the PersistentVolume
    named `db-pv`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating PersistentVolumeClaims
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next object we’ll need to create is the PersistentVolumeClaim. Its purpose
    is to bind the PersistentVolume to the Pod. Let’s take a look at the YAML manifest
    stored in the file `db-pvc.yaml`, as shown in [Example 6-3](#yaml_manifest_persistent_volume_claim).
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-3\. Definition of a PersistentVolumeClaim
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What we’re saying here is, “Give me a PersistentVolume that can fulfill the
    resource request of 256Mi and provides the access mode `ReadWriteOnce`.” Static
    provisioning should use an empty string for the attribute `spec.storageClassName`
    if you do not want it to automatically assign the default storage class. The binding
    to an appropriate PersistentVolume happens automatically based on those criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating the PersistentVolumeClaim, the status is set as `Bound`, which
    means that the binding to the PersistentVolume was successful. Once the associated
    binding occurs, nothing else can bind to it. The binding relationship is 1-to-1\.
    Nothing else can bind to the PersistentVolume once claimed. The following `get`
    command uses the short-form `pvc` instead of `persistentvolumeclaim`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The PersistentVolume has not been mounted by a Pod yet. Therefore, inspecting
    the details of the object shows `<none>`. Using the `describe` command is a good
    way to verify if the PersistentVolumeClaim was mounted properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Mounting PersistentVolumeClaims in a Pod
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All that’s left is to mount the PersistentVolumeClaim in the Pod that wants
    to consume it. You already learned how to mount a volume in a Pod. The big difference
    here shown in [Example 6-4](#pod_referencing_persistent_volume_claim) is using
    `spec.volumes[].persistentVolumeClaim` and providing the name of the PersistentVolumeClaim.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-4\. A Pod referencing a PersistentVolumeClaim
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s assume we stored the configuration in the file `app-consuming-pvc.yaml`.
    After creating the Pod from the manifest, you should see the Pod transitioning
    into the `Ready` state. The `describe` command will provide additional information
    on the volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The PersistentVolumeClaim now also shows the Pod that mounted it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now go ahead and open an interactive shell to the Pod. Navigating to
    the mount path at */mnt/data* gives you access to the underlying PersistentVolume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Understanding Storage Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A storage class is a Kubernetes primitive that defines a specific type or “class”
    of storage. Typical characteristics of a storage can be the type (e.g., fast SSD
    storage versus a remote cloud storage or the backup policy for a storage). The
    storage class is used to provision a PersistentVolume dynamically based on its
    criteria. In practice, this means that you do not have to create the PersistentVolume
    object yourself. The provisioner assigned to the storage class takes care of it.
    Most Kubernetes cloud providers come with a list of existing provisioners. Minikube
    already creates a default storage class named `standard`, which you can query
    for with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating Storage Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Storage classes can be created declaratively only with the help of a YAML manifest.
    At a minimum, you need to declare the provisioner. All other attributes are optional
    and use default values if not provided upon creation. Most provisioners let you
    set parameters specific to the storage type. [Example 6-5](#storage_class_gce)
    defines a storage class on Google Compute Engine denoted by the provisioner `kubernetes.io/gce-pd`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-5\. Definition of a storage class
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Say you saved the YAML contents in the file `fast-sc.yaml`; then the following
    command will create the object. The storage class can be listed using the `get
    storageclass` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using Storage Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provisioning a PersistentVolume dynamically requires the assignment of the storage
    class when you create the PeristentVolumeClaim. [Example 6-6](#yaml_manifest_persistent_volume_claim_storage_class)
    shows the usage of the attribute `spec.storageClassName` for assigning the storage
    class named `standard`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 6-6\. Using a storage class in a PersistentVolumeClaim
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The corresponding PersistentVolume object will be created only if the storage
    class can provision a fitting PersistentVolume using its provisioner. It’s important
    to understand that Kubernetes does not render an error or warning message if it
    isn’t the case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command renders the created PersistentVolumeClaim and PersistentVolume.
    As you can see, the name of the dynamically provisioned PersistentVolume is using
    a hash to ensure a unique naming:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The steps for mounting the PersistentVolumeClaim from a Pod are the same as
    for static and dynamic provisioning. Refer to [“Mounting PersistentVolumeClaims
    in a Pod”](#mounting_persistent_volume) for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers store data in a temporary filesystem, which is empty each time a
    new Pod is started. Application developers need to persist data beyond the lifecycles
    of the containers, Pods, node, and cluster. Typical examples include persistent
    log files or data in a database.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes offers the concept of a volume to implement the use case. A Pod mounts
    a volume to a path in the container. Any data written to the mounted storage will
    be persisted beyond a container restart. Kubernetes offers a wide range of volume
    types to fulfill different requirements.
  prefs: []
  type: TYPE_NORMAL
- en: PersistentVolumes even store data beyond a Pod or cluster/node restart. Those
    objects are decoupled from the Pod’s lifecycle and are therefore represented by
    a Kubernetes primitive. The PersistentVolumeClaim abstracts the underlying implementation
    details of a PersistentVolume and acts as an intermediary between the Pod and
    PersistentVolume. A PersistentVolume can be provisioned statically by creating
    the object or dynamically with the help of a provisioner assigned to a storage
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Exam Essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understand the need and use cases for a volume
  prefs: []
  type: TYPE_NORMAL
- en: Many production-ready application stacks running in a cloud-native environment
    need to persist data. Read up on common use cases and explore recipes that describe
    typical scenarios. You can find some examples in the O’Reilly books [*Kubernetes
    Patterns*](https://oreil.ly/mQKRj), [*Kubernetes Best Practices*](https://oreil.ly/hcFNA),
    and [*Cloud Native DevOps with Kubernetes*](https://oreil.ly/G7V3W).
  prefs: []
  type: TYPE_NORMAL
- en: Practice defining and consuming volumes
  prefs: []
  type: TYPE_NORMAL
- en: Volumes are a cross-cutting concept applied in different areas of the exam.
    Know where to find the relevant documentation for defining a volume and the multitude
    of ways to consume a volume from a container. Definitely revisit [“Defining and
    Consuming Configuration Data”](ch03.xhtml#defining_consuming_configuration_data)
    for a deep dive on how to mount ConfigMaps and Secrets as a volume.
  prefs: []
  type: TYPE_NORMAL
- en: Internalize the mechanics of defining and consuming a PersistentVolume
  prefs: []
  type: TYPE_NORMAL
- en: Creating a PersistentVolume involves a couple of moving parts. Understand the
    configuration options for PersistentVolumes and PersistentVolumeClaims and how
    they play together. Try to emulate situations that prevent a successful binding
    of a PersistentVolumeClaim. Then fix the situation by taking counteractions. Internalize
    the short-form commands `pv` and `pvc` to save precious time during the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Know the differences between static and dynamic provisioning of a PersistentVolume
  prefs: []
  type: TYPE_NORMAL
- en: A PersistentVolume can be created statically by creating the object from a YAML
    manifest using the `create` command. Alternatively, you can let Kubernetes provision
    a PersistentVolume dynamically without your direct involvement. For this to happen,
    assign a storage class to the PersistentVolumeClaim. The provisioner of the storage
    class takes care of creating PersistentVolume object for you.
  prefs: []
  type: TYPE_NORMAL
- en: Sample Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Solutions to these exercises are available in the [Appendix](app01.xhtml#appendix-a).
  prefs: []
  type: TYPE_NORMAL
- en: Create a PersistentVolume named `logs-pv` that maps to the `hostPath` */tmp/logs*.
    The access mode should be `ReadWriteOnce` and `ReadOnlyMany`. Provision a storage
    capacity of 2Gi. Assign the reclaim policy `Delete` and an empty string as the
    storage class. Ensure that the status of the PersistentVolume shows `Available`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a PersistentVolumeClaim named `logs-pvc`. The access it uses is `ReadWriteOnce`.
    Request a capacity of 1Gi. Ensure that the status of the PersistentVolume shows
    `Bound`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Mount the PersistentVolumeClaim in a Pod running the image `nginx` at the mount
    path */var/log/nginx*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open an interactive shell to the container and create a new file named *my-nginx.log*
    in */var/log/nginx*. Exit out of the Pod.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Pod and PersistentVolumeClaim. What happens to the PersistentVolume?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List the available storage classes and identify the default storage class. Note
    the provisioner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new storage class named `custom` using the provisioner of the default
    storage class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a PersistentVolumeClaim named `custom-pvc`. Request a capacity of 500Mi
    and declare the access mode `ReadWriteOnce`. Assign the storage class name `custom`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The PersistentVolume should have been provisioned dynamically. Find out the
    name and write it to the file named `pv-name.txt`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the PersistentVolumeClaim. What happens to the PersistentVolume?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
