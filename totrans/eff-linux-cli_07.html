<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Expanding Your Toolbox"><div class="chapter" id="ch_toolbox">
<h1><span class="label">Chapter 5. </span>Expanding Your Toolbox</h1>


<p>Linux systems come with thousands of command-line programs. Experienced users
typically rely on a smaller subset—a toolbox of sorts—that they
return to again and again. <a data-type="xref" href="ch01.xhtml#ch_combining_commands">Chapter 1</a> added six highly
useful commands to your toolbox, and now I’ll hand you about a dozen
more. I’ll describe each command briefly and show you some example
uses. (To see all available options, view a command’s manpage.)
I’ll also introduce two powerful commands that are harder to learn but
well worth the effort, called <code>awk</code> and <code>sed</code>. Overall, the commands
in this chapter serve four common, practical needs for pipelines and
other complex commands:</p>
<dl>
<dt>Producing text</dt>
<dd>
<p>  Printing dates, times, sequences of numbers and letters, file paths,
repeated strings, and other text to jumpstart your pipelines.</p>
</dd>
<dt>Isolating text</dt>
<dd>
<p>  Extracting any part of a text file with a combination of <code>grep</code>, <code>cut</code>,
<code>head</code>, <code>tail</code>, and one handy feature of <code>awk</code>.</p>
</dd>
<dt>Combining text</dt>
<dd>
<p>  Combining files from top to bottom with <code>cat</code> and <code>tac</code>, or side by side
with <code>echo</code> and <code>paste</code>. You can also interleave files with <code>paste</code>
and <code>diff</code>.</p>
</dd>
<dt>Transforming text</dt>
<dd>
<p>  Converting text into other text using simple commands such as <code>tr</code> and
<code>rev</code>, or more powerful commands such as <code>awk</code> and <code>sed</code>.</p>
</dd>
</dl>

<p>This chapter is a quick overview. Later chapters show the
commands in action.</p>






<section data-type="sect1" data-pdf-bookmark="Producing Text"><div class="sect1" id="idm46586641251296">
<h1>Producing Text</h1>

<p><a data-type="indexterm" data-primary="producing text" id="idm46586641249392"/><a data-type="indexterm" data-primary="text" data-secondary="producing" id="idm46586641248464"/><a data-type="indexterm" data-primary="stdout" data-secondary="text production" id="idm46586641247520"/>
Every pipeline begins with a simple command that prints to stdout.
Sometimes it’s a command like <code>grep</code> or <code>cut</code> that pulls selected
data from a file:<a data-type="indexterm" data-primary="/etc/passwd file" id="idm46586641245504"/><a data-type="indexterm" data-primary="/etc/passwd file" data-primary-sortas="etc password" id="idm46586641244800"/><a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586641243856"/></p>

<pre data-type="programlisting">$ <strong>cut -d: -f1 /etc/passwd | sort</strong>      <em>Print all usernames and sort them</em></pre>

<p>or even <code>cat</code>,<a data-type="indexterm" data-primary="cat command" id="idm46586641240848"/> which is convenient for piping the full contents of
multiple files to other commands:<a data-type="indexterm" data-primary="wc command" data-secondary="examples" id="idm46586641239984"/></p>

<pre data-type="programlisting">$ <strong>cat *.txt | wc -l</strong>                   <em>Total the number of lines</em></pre>

<p>Other times, the initial text in a pipeline comes from other
sources. You already know one such command, <code>ls</code>, which prints file
and directory names and associated information. Let’s take a look at
some other text-producing commands and techniques:</p>
<dl>
<dt><code>date</code></dt>
<dd>
<p>Prints dates and times in various formats</p>
</dd>
<dt><code>seq</code></dt>
<dd>
<p>Prints a sequence of numbers</p>
</dd>
<dt>Brace expansion</dt>
<dd>
<p>A shell feature that prints a sequence of numbers or characters</p>
</dd>
<dt><code>find</code></dt>
<dd>
<p>Prints file paths</p>
</dd>
<dt><code>yes</code></dt>
<dd>
<p>Prints the same line repeatedly</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="The date Command"><div class="sect2" id="idm46586641235776">
<h2>The date Command</h2>

<p><a data-type="indexterm" data-primary="date command" id="idm46586641227264"/><a data-type="indexterm" data-primary="time of day" id="idm46586641226560"/><a data-type="indexterm" data-primary="today’s date" id="idm46586641225888"/><a data-type="indexterm" data-primary="current date and time" id="idm46586641225216"/>
The <code>date</code> command prints the current date and/or time in various
formats:<a data-type="indexterm" data-primary="formatting dates and times" id="idm46586641224000"/></p>

<pre data-type="programlisting">$ <strong>date</strong>                                <em>Default formatting</em>
Mon Jun 28 16:57:33 EDT 2021
$ <strong>date +%Y-%m-%d</strong>                      <em>Year-Month-Day format</em>
2021-06-28
$ <strong>date +%H:%M:%S</strong>                      <em>Hour:Minute:Seconds format</em>
16:57:33</pre>

<p>To control the output format, provide an argument that begins with a
plus sign (<code>+</code>)<a data-type="indexterm" data-primary="+ (plus)" data-secondary="date and time formatting" id="idm46586641218816"/><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="date and time formatting" id="idm46586641217840"/>
followed by any text. The text may contain special
expressions that begin with a percent sign (<code>%</code>),<a data-type="indexterm" data-primary="% (percent)" data-secondary="date and time formatting" id="idm46586641216256"/><a data-type="indexterm" data-primary="percent sign (%)" data-secondary="date and time formatting" id="idm46586641215232"/>
such as <code>%Y</code> for the
current four-digit year and <code>%H</code> for the current hour on a 24-hour
clock. A full list of expressions is on the manpage for <code>date</code>.</p>

<pre data-type="programlisting">$ <strong>date +"I cannot believe it's already %A!"</strong>        <em>Day of week</em>
I cannot believe it's already Tuesday!</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The seq Command"><div class="sect2" id="idm46586641211136">
<h2>The seq Command</h2>

<p><a data-type="indexterm" data-primary="seq command" id="idm46586641209600"/><a data-type="indexterm" data-primary="range of" data-secondary="numbers" data-tertiary="seq command" id="idm46586641208896"/><a data-type="indexterm" data-primary="sequence of" data-secondary="numbers" data-tertiary="seq command" id="idm46586641207680"/>
The <code>seq</code> command prints a sequence of numbers in a range. Provide
two arguments, the low and high values of the range, and <code>seq</code>
prints the whole range:</p>

<pre data-type="programlisting">$ <strong>seq 1 5</strong>                     <em>Print all integers from 1 to 5, inclusive</em>
1
2
3
4
5</pre>

<p>If you provide three arguments, the first and third define the range,
and the middle number is the increment:</p>

<pre data-type="programlisting">$ <strong>seq 1 2 10</strong>                  <em>Increment by 2 instead of 1</em>
1
3
5
7
9</pre>

<p>Use a negative increment such as <code>-1</code> to produce a descending sequence:</p>

<pre data-type="programlisting">$ <strong>seq 3 -1 0</strong>
3
2
1
0</pre>

<p>or a decimal increment to produce floating-point numbers:</p>

<pre data-type="programlisting">$ <strong>seq 1.1 0.1 2</strong>                       <em>Increment by 0.1</em>
1.1
1.2
1.3
⋮
2.0</pre>

<p>By default, values are separated by a newline character, but you can
change the separator with the <code>-s</code> option followed by any string:</p>

<pre data-type="programlisting">$ <strong>seq -s/ 1 5</strong>                 <em>Separate values with forward slashes</em>
1/2/3/4/5</pre>

<p>The option <code>-w</code><a data-type="indexterm" data-primary="seq command" data-secondary="equal widths (-w option)" id="idm46586641193984"/> makes all values the same width (in characters) by adding
leading zeros<a data-type="indexterm" data-primary="leading zeros" data-secondary="seq command" id="idm46586641192816"/><a data-type="indexterm" data-primary="zero" data-secondary="leading" id="idm46586641191872"/> as needed:</p>

<pre data-type="programlisting">$ <strong>seq -w 8 10</strong>
08
09
10</pre>

<p><code>seq</code> can produce numbers in many other formats (see the manpage), but
my examples represent the most common uses.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Brace Expansion (A Shell Feature)"><div class="sect2" id="idm46586641210544">
<h2>Brace Expansion (A Shell Feature)</h2>

<p><a data-type="indexterm" data-primary="brace expansion" id="braceexpansion"/><a data-type="indexterm" data-primary="curly braces ({})" data-secondary="brace expansion" id="idm46586641186032"/><a data-type="indexterm" data-primary="{} (curly braces)" data-secondary="brace expansion" id="idm46586641185088"/>
The shell provides its own way to print a sequence of numbers,<a data-type="indexterm" data-primary="range of" data-secondary="numbers" data-tertiary="brace expansion" id="idm46586641184016"/><a data-type="indexterm" data-primary="sequence of" data-secondary="numbers" data-tertiary="brace expansion" id="idm46586641182720"/> known as
<em>brace expansion</em>. Start with a left curly brace, add two integers
separated by two dots,<a data-type="indexterm" data-primary=".. (dot dot)" data-secondary="brace expansion" id="idm46586641180960"/><a data-type="indexterm" data-primary="dot (.)" data-secondary="dot dot (..)" data-tertiary="brace expansion" id="idm46586641179984"/> and end with a right curly brace:</p>

<pre data-type="programlisting">$ <strong>echo {1..10}</strong>                        <em>Forward from 1</em>
1 2 3 4 5 6 7 8 9 10
$ <strong>echo {10..1}</strong>                        <em>Backward from 10</em>
10 9 8 7 6 5 4 3 2 1
$ <strong>echo {01..10}</strong>                       <em>With leading zeros (equal width)</em>
01 02 03 04 05 06 07 08 09 10</pre>

<p>More generally, the shell expression
<code>{</code><em>x</em><code>..</code><em>y</em><code>..</code><em>z</em><code>}</code> generates the values <em>x</em> through
<em>y</em>, incrementing by <em>z</em>:<a data-type="indexterm" data-primary="leading zeros" data-secondary="brace expansion" id="idm46586641171200"/><a data-type="indexterm" data-primary="zero" data-secondary="leading" id="idm46586641170192"/></p>

<pre data-type="programlisting">$ <strong>echo {1..1000..100}</strong>                               <em>Count by hundreds from 1</em>
1 101 201 301 401 501 601 701 801 901
$ <strong>echo {1000..1..100}</strong>                               <em>Backward from 1000</em>
1000 900 800 700 600 500 400 300 200 100
$ <strong>echo {01..1000..100}</strong>                              <em>With leading zeros</em>
0001 0101 0201 0301 0401 0501 0601 0701 0801 0901</pre>
<div data-type="note" epub:type="note"><h1>Curly Braces Versus Square Brackets</h1>
<p>Square brackets are a pattern-matching operator<a data-type="indexterm" data-primary="curly braces ({})" data-secondary="square brackets versus" id="idm46586641164448"/><a data-type="indexterm" data-primary="square brackets ([])" data-secondary="curly braces versus" id="idm46586641163472"/><a data-type="indexterm" data-primary="[] (square brackets)" data-secondary="curly braces versus" id="idm46586641162528"/><a data-type="indexterm" data-primary="{} (curly braces)" data-secondary="square brackets versus" id="idm46586641161584"/> for filenames
(<a data-type="xref" href="ch02.xhtml#ch_shell">Chapter 2</a>). Curly brace expansion, on the other hand, does not
depend on filenames in any way. It just evaluates to a list of
strings. You can use brace expansion to <em>print</em> filenames, but no
pattern matching occurs:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
file1 file2 file4
$ <strong>ls file[2-4]</strong>           <em>Matches existing filenames</em>
file2 file4
$ <strong>ls file{2..4}</strong>          <em>Evaluates to: file2 file3 file4</em>
ls: cannot access 'file3': No such file or directory
file2  file4</pre>
</div>

<p>Brace expansion also can produce sequences of letters, which <code>seq</code> cannot:<a data-type="indexterm" data-primary="sequence of" data-secondary="letters" id="idm46586641154832"/><a data-type="indexterm" data-primary="range of" data-secondary="characters" data-tertiary="brace expansion" id="idm46586641153824"/></p>
<pre data-type="programlisting" class="pagebreak-after">$ <strong>echo {A..Z}</strong>
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z</pre>

<p>Brace expansion always produces output on a single line separated
by space characters. Change this by piping the output to other commands,
such as <code>tr</code> (see <a data-type="xref" href="#section_tr">“The tr Command”</a>):<a data-type="indexterm" data-primary="tr command" data-secondary="converting spaces to newlines" id="idm46586641149088"/><a data-type="indexterm" data-primary="whitespace" data-secondary="deleting" id="idm46586641148144"/><a data-type="indexterm" data-primary="tr command" data-secondary="whitespace deleted" id="idm46586641147200"/><a data-type="indexterm" data-primary="newline character" data-secondary="translating with tr" id="idm46586641146256"/><a data-type="indexterm" data-primary="newline character" data-secondary="syntax (\n)" id="idm46586641145312"/><a data-type="indexterm" data-primary="alphabet" data-secondary="printing" id="idm46586641144368"/></p>
<pre data-type="programlisting">$ <strong>echo {A..Z} | tr -d ' '</strong>      <em>Delete spaces</em>
ABCDEFGHIJKLMNOPQRSTUVWXYZ
$ <strong>echo {A..Z} | tr ' ' '\n'</strong>    <em>Change spaces into newlines</em>
A
B
C
⋮
Z</pre>

<p>Create an alias that prints the <em>n</em>th letter of the English alphabet:<a data-type="indexterm" data-primary="nth letter of English alphabet" id="idm46586641140176"/><a data-type="indexterm" data-startref="braceexpansion" id="idm46586641139408"/></p>

<pre data-type="programlisting">$ <strong>alias nth="echo {A..Z} | tr -d ' ' | cut -c"</strong>
$ <strong>nth 10</strong>
J</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The find Command"><div class="sect2" id="section_find">
<h2>The find Command</h2>

<p><a data-type="indexterm" data-primary="find command" id="find"/><a data-type="indexterm" data-primary="locating" data-secondary="files" id="idm46586641134144"/><a data-type="indexterm" data-primary="file" data-secondary="finding" id="idm46586641133200"/><a data-type="indexterm" data-primary="finding files" id="idm46586641132256"/>
The <code>find</code> command lists files in a directory recursively, descending
into subdirectories and printing full paths.<sup><a data-type="noteref" id="idm46586641130912-marker" href="ch05.xhtml#idm46586641130912">1</a></sup> Results are not
alphabetical (pipe the output to <code>sort</code> if needed):</p>

<pre data-type="programlisting">$ <strong>find /etc -print</strong>            <em>List all of /etc recursively</em>
/etc
/etc/issue.net
/etc/nanorc
/etc/apache2
/etc/apache2/sites-available
/etc/apache2/sites-available/default.conf
⋮</pre>

<p><code>find</code> has numerous options that you can combine. Here are a few
highly useful ones. Limit the output only to files or directories with
the option <code>-type</code>:<a data-type="indexterm" data-primary="find command" data-secondary="limiting to files or directories (-type option)" id="idm46586641125568"/></p>

<pre data-type="programlisting">$ <strong>find . -type f -print</strong>               <em>Files only</em>
$ <strong>find . -type d -print</strong>               <em>Directories only</em></pre>

<p>Limit the output to names that match a filename pattern with the option
<code>-name</code>.<a data-type="indexterm" data-primary="find command" data-secondary="filename pattern matching (-name option)" id="idm46586641121312"/><a data-type="indexterm" data-primary="filenames" data-secondary="pattern matching" data-tertiary="find command" id="idm46586641120272"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="filenames" data-tertiary="find command" id="idm46586641119056"/> Quote or escape the pattern so the shell doesn’t evaluate it
first:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>find /etc -type f -name "*.conf" -print</strong>           <em>Files ending with .conf</em>
/etc/logrotate.conf
/etc/systemd/logind.conf
/etc/systemd/timesyncd.conf
⋮</pre>

<p>Make the name-matching case insensitive with the option <code>-iname</code>:<a data-type="indexterm" data-primary="find command" data-secondary="case sensitivity (-iname option)" id="idm46586641114832"/></p>

<pre data-type="programlisting">$ <strong>find . -iname "*.txt" -print</strong></pre>

<p><code>find</code> can also execute a Linux command for <em>each file path</em> in the output,
using <code>-exec</code>.<a data-type="indexterm" data-primary="find command" data-secondary="executing other commands (-exec option)" id="idm46586641111296"/> The syntax is a bit wonky:</p>
<ol>
<li>
<p>Construct a <code>find</code> command and omit <code>-print</code>.</p>
</li>
<li>
<p>Append <code>-exec</code> followed by the command to execute. Use the expression <code>{}</code><a data-type="indexterm" data-primary="{} (curly braces)" data-secondary="find command" id="idm46586641106272"/><a data-type="indexterm" data-primary="curly braces ({})" data-secondary="find command" id="idm46586641105296"/>
to indicate where the file path should appear in the command.</p>
</li>
<li>
<p>End with a quoted or escaped semicolon, such as <code>";"</code> or <code>\;</code>.</p>
</li>

</ol>

<p>Here’s a toy example to print an <code>@</code> symbol on either side of the file
path:</p>

<pre data-type="programlisting">$ <strong>find /etc -exec echo @ {} @ ";"</strong>
@ /etc @
@ /etc/issue.net @
@ /etc/nanorc @
⋮</pre>

<p>A more practical example performs a long listing (<code>ls -l</code>) for all
<em>.conf</em> files in <em>/etc</em> and its subdirectories:</p>

<pre data-type="programlisting">$ <strong>find /etc -type f -name "*.conf" -exec ls -l {} ";"</strong>
-rw-r--r-- 1 root root 703  Aug 21  2017 /etc/logrotate.conf
-rw-r--r-- 1 root root 1022 Apr 20  2018 /etc/systemd/logind.conf
-rw-r--r-- 1 root root 604  Apr 20  2018 /etc/systemd/timesyncd.conf
⋮</pre>

<p><code>find -exec</code> works well for mass deletions<a data-type="indexterm" data-primary="deleting files" data-secondary="mass deletion" data-tertiary="find command" id="idm46586641096064"/><a data-type="indexterm" data-primary="removing files" data-secondary="mass deletion" data-tertiary="find command" id="idm46586641094816"/><a data-type="indexterm" data-primary="file" data-secondary="deleting" data-see="deleting files" id="idm46586641093600"/> of files throughout a directory
hierarchy (but be careful!). Let’s delete files with names ending in a
tilde (<code>~</code>) within the directory <em>$HOME/tmp</em> and its
subdirectories. For safety, first run the command <code>echo rm</code> to see
which files would be deleted,<a data-type="indexterm" data-primary="echo command" data-secondary="adding for safety" id="idm46586641090752"/> then remove <code>echo</code> to delete for
real:<a data-type="indexterm" data-startref="find" id="idm46586641089232"/></p>
<pre data-type="programlisting">$ <strong>find $HOME/tmp -type f -name "*~" -exec <mark class="box">echo rm</mark> {} ";"</strong>       <em>echo for safety</em>
rm /home/smith/tmp/file1~
rm /home/smith/tmp/junk/file2~
rm /home/smith/tmp/vm/vm-8.2.0b/lisp/vm-cus-load.el~
$ <strong>find $HOME/tmp -type f -name "*~" -exec <mark class="box">rm</mark> {} ";"</strong>            <em>Delete for real</em></pre>
</div></section>













<section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="The yes Command"><div class="sect2" id="idm46586641136560">
<h2>The yes Command</h2>

<p><a data-type="indexterm" data-primary="yes command" id="idm46586641083072"/><a data-type="indexterm" data-primary="repeating a string" id="idm46586641082368"/><a data-type="indexterm" data-primary="strings" data-secondary="repeating with yes command" id="idm46586641081696"/>
The <code>yes</code> command prints the same string over and over until terminated:</p>
<pre data-type="programlisting">$ <strong>yes</strong>          <em>Repeats "y" by default</em>
y
y
y <strong>^C</strong>           <em>Kill the command with Ctrl-C</em>
$ <strong>yes woof!</strong>    <em>Repeat any other string</em>
woof!
woof!
woof! <strong>^C</strong></pre>

<p>What’s the use of this curious behavior? <code>yes</code> can supply input to
interactive programs so they can run unattended. For example, the
program <code>fsck</code>,<a data-type="indexterm" data-primary="fsck command" id="idm46586641074608"/> which checks a Linux filesystem for errors,<a data-type="indexterm" data-primary="Linux" data-secondary="filesystem" data-tertiary="error checking" id="idm46586641073680"/><a data-type="indexterm" data-primary="filesystem" data-secondary="error checking" id="idm46586641072464"/> may prompt
the user to continue and wait for a response of <code>y</code> or <code>n</code>. The output
of the <code>yes</code> command, when piped to <code>fsck</code>, responds to every prompt on your
behalf, so you can walk away and let <code>fsck</code> run to
completion.<sup><a data-type="noteref" id="idm46586641069200-marker" href="ch05.xhtml#idm46586641069200">2</a></sup></p>

<p>The main use of <code>yes</code> for our purposes is printing a string a specific
number of times by piping <code>yes</code> to <code>head</code> (you’ll see a practical
example in <a data-type="xref" href="ch08.xhtml#section_generate_test">“Generating Test Files”</a>):</p>

<pre data-type="programlisting">$ <strong>yes "Efficient Linux" | head -n3</strong>            <em>Print a string 3 times</em>
Efficient Linux
Efficient Linux
Efficient Linux</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Isolating Text"><div class="sect1" id="idm46586641250640">
<h1>Isolating Text</h1>

<p><a data-type="indexterm" data-primary="isolating text" id="idm46586641061536"/><a data-type="indexterm" data-primary="text" data-secondary="isolating" id="idm46586641060496"/>
When you need just part of a file, the simplest commands to combine
and run are <code>grep</code>, <code>cut</code>, <code>head</code>, and <code>tail</code>. You’ve already seen the
first three in <a data-type="xref" href="ch01.xhtml#ch_combining_commands">Chapter 1</a>: <code>grep</code> prints lines that
match a string, <code>cut</code> prints columns from a file, and <code>head</code> prints
the first lines of a file. A new command, <code>tail</code>, is the opposite
of <code>head</code> and prints the last lines of a file. <a data-type="xref" href="#fig_slicers">Figure 5-1</a> depicts
these four commands working together.</p>

<figure><div id="fig_slicers" class="figure">
<img src="Images/elcl_0501.png" alt="head, grep, tail, and cut operating on a file" width="600" height="668"/>
<h6><span class="label">Figure 5-1. </span><code>head</code>, <code>grep</code>, and <code>tail</code> extract lines, and <code>cut</code> extracts columns. In this example, <code>grep</code> matches lines containing the string “blandit.”</h6>
</div></figure>

<p>In this section, I dive more deeply into <code>grep</code>, which does a lot more
than match plain strings, and explain <code>tail</code> more formally. I also
preview one feature of the command <code>awk</code> for extracting columns in a
way that <code>cut</code> cannot. These five commands in combination can isolate
pretty much any text using a single pipeline.</p>








<section data-type="sect2" data-pdf-bookmark="grep: A Deeper Look"><div class="sect2" id="idm46586641047056">
<h2>grep: A Deeper Look</h2>

<p><a data-type="indexterm" data-primary="grep command" id="grep2"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="grep command" data-see="grep command" id="idm46586641044224"/>
You’ve already seen <code>grep</code> print lines from a file that match a given
string:</p>

<pre data-type="programlisting">$ <strong>cat frost</strong>
Whose woods these are I think I know.
His house is in the village though;
He will not see me stopping here
To watch his woods fill up with snow.
This is not the end of the poem.
$ <strong>grep his frost</strong>                              <em>Print lines containing "his"</em>
To watch <strong>his</strong> woods fill up with snow.
T<strong>his</strong> is not the end of the poem.              <em>"This" matches "his"</em></pre>

<p><code>grep</code> also has some highly useful options. Use the <code>-w</code><a data-type="indexterm" data-primary="grep command" data-secondary="full word matching (-w option)" id="idm46586641037808"/> option to
match whole words only:</p>

<pre data-type="programlisting">$ <strong>grep -w his frost</strong>                         <em>Match the word "his" exactly</em>
To watch <strong>his</strong> woods fill up with snow.</pre>

<p>Use the <code>-i</code><a data-type="indexterm" data-primary="grep command" data-secondary="case sensitivity (-i option)" id="idm46586641033872"/> option to ignore the case of letters:</p>

<pre data-type="programlisting">$ <strong>grep -i his frost</strong>
<strong>His</strong> house is in the village though;             <em>Matches "His"</em>
To watch <strong>his</strong> woods fill up with snow.           <em>Matches "his"</em>
T<strong>his</strong> is not the end of the poem.                <em>"This" matches "his"</em></pre>

<p>Use the <code>-l</code> <a data-type="indexterm" data-primary="grep command" data-secondary="printing filenames (-l option)" id="idm46586641028048"/> option to print only the names of the files that contain
matching lines, but not the matching lines themselves:</p>

<pre data-type="programlisting">$ <strong>grep -l his * </strong>            <em>Which files contain the string "his"?</em>
frost</pre>

<p>The real power of <code>grep</code>, however, appears when you move beyond
matching simple strings to matching patterns, called <em>regular
expressions</em>.<a data-type="indexterm" data-primary="grep command" data-secondary="regular expressions" id="idm46586641023600"/><a data-type="indexterm" data-primary="regular expressions" data-secondary="grep" id="idm46586641022592"/><a data-type="indexterm" data-primary="regexp" data-see="regular expressions" id="idm46586641021648"/><a data-type="indexterm" data-primary="pattern matching" data-secondary="regular expressions" data-see="regular expressions" id="idm46586641020704"/><sup><a data-type="noteref" id="idm46586641019488-marker" href="ch05.xhtml#idm46586641019488">3</a></sup> The syntax is different from filename patterns;
a partial description is in <a data-type="xref" href="#table_regex">Table 5-1</a>.</p>
<table id="table_regex">
<caption><span class="label">Table 5-1. </span>Some regular expression syntax shared by <code>grep</code>, <code>awk</code>, and <code>sed</code>​<sup><a data-type="noteref" id="idm46586641014224-marker" href="ch05.xhtml#idm46586641014224">a</a></sup></caption>
<thead>
<tr>
<th>To match this:</th>
<th>Use this syntax:</th>
<th>Example</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>Beginning of a line<a data-type="indexterm" data-primary="^ (caret)" data-secondary="regular expression" id="idm46586641006000"/><a data-type="indexterm" data-primary="caret (^)" data-secondary="regular expression" id="idm46586641004992"/></p></td>
<td><p><code>^</code></p></td>
<td><p><code>^a</code> = Line beginning with <code>a</code></p></td>
</tr>
<tr>
<td><p>End of a line<a data-type="indexterm" data-primary="$ (dollar sign)" data-secondary="regular expression" id="idm46586641001136"/><a data-type="indexterm" data-primary="dollar sign ($)" data-secondary="regular expression" id="idm46586641000128"/></p></td>
<td><p><code>$</code></p></td>
<td><p><code>!$</code> = Line ending with an exclamation point</p></td>
</tr>
<tr>
<td><p>Any single character (except newline)<a data-type="indexterm" data-primary=". (dot)" data-secondary="regular expression" id="idm46586640996624"/><a data-type="indexterm" data-primary="dot (.)" data-secondary="regular expression" id="idm46586640995648"/></p></td>
<td><p><code>.</code></p></td>
<td><p><code>…</code> = Any three consecutive characters</p></td>
</tr>
<tr>
<td><p>A literal caret, dollar sign, or any other special character <em><code>c</code></em><a data-type="indexterm" data-primary="\ (backslash)" data-secondary="regular expression" id="idm46586640991584"/><a data-type="indexterm" data-primary="backslash (\)" data-secondary="regular expression" id="idm46586640990640"/></p></td>
<td><p><code>\</code><em>c</em></p></td>
<td><p><code>\$</code> = A literal dollar sign</p></td>
</tr>
<tr>
<td><p>Zero or more occurrences of expression <em>E</em> <a data-type="indexterm" data-primary="* (asterisk)" data-secondary="regular expression" id="idm46586640986400"/><a data-type="indexterm" data-primary="asterisk (*)" data-secondary="regular expression" id="idm46586640985392"/></p></td>
<td><p><em><code>E</code></em><code>*</code></p></td>
<td><p><code>_*</code> = Zero or more underscores</p></td>
</tr>
<tr>
<td><p>Any single character in a set</p></td>
<td><p><code>[</code><em><code>characters</code></em><code>]</code> <a data-type="indexterm" data-primary="[] (square brackets)" data-secondary="regular expression" id="idm46586640979904"/><a data-type="indexterm" data-primary="square brackets ([])" data-secondary="regular expression" id="idm46586640978896"/></p></td>
<td><p><code>[aeiouAEIOU]</code> = Any vowel</p></td>
</tr>
<tr>
<td><p>Any single character <em>not</em> in a set</p></td>
<td><p><code>[^</code><em><code>characters</code></em><code>]</code></p></td>
<td><p><code>[^aeiouAEIOU]</code> = Any nonvowel</p></td>
</tr>
<tr>
<td><p>Any character in a given range between <em><code>c</code><sub>1</sub></em> and <em><code>c</code><sub>2</sub></em> <a data-type="indexterm" data-primary="- (dash)" data-secondary="regular expression" id="idm46586640970608"/><a data-type="indexterm" data-primary="dash (-)" data-secondary="regular expression" id="idm46586640969632"/></p></td>
<td><p><code>[</code><em><code>c</code><sub>1</sub></em><code>-</code><em><code>c</code><sub>2</sub></em><code>]</code></p></td>
<td><p><code>[0-9]</code> = Any digit</p></td>
</tr>
<tr>
<td><p>Any character <em>not</em> in a given range between <em><code>c</code><sub>1</sub></em> and <em><code>c</code><sub>2</sub></em></p></td>
<td><p><code>[^</code><em><code>c</code><sub>1</sub></em><code>-</code><em><code>c</code><sub>2</sub></em><code>]</code></p></td>
<td><p><code>[^0-9]</code> = Any nondigit</p></td>
</tr>
<tr>
<td rowspan="2"><p>Either of two expressions <em><code>E</code><sub>1</sub></em> or <em><code>E</code><sub>2</sub></em></p></td>
<td><p><em><code>E</code><sub>1</sub></em><code>\|</code><em><code>E</code><sub>2</sub></em>    for grep and sed</p></td>
<td><p><code>one\|two</code> = Either <code>one</code> or <code>two</code></p></td>
</tr>
<tr>
<td><p><em><code>E</code><sub>1</sub></em><code>|</code><em><code>E</code><sub>2</sub></em>    for awk</p></td>
<td><p><code>one|two</code> = Either <code>one</code> or <code>two</code></p></td>
</tr>
<tr>
<td rowspan="2"><p>Grouping expression <em><code>E</code></em> for precedence <a data-type="indexterm" data-primary="() (parentheses)" data-secondary="regular expression" id="idm46586640945616"/><a data-type="indexterm" data-primary="parentheses ()" data-secondary="regular expression" id="idm46586640944640"/><a data-type="indexterm" data-primary="\(" data-secondary="regular expression" id="idm46586640943696"/><a data-type="indexterm" data-primary="backslash (\)" data-secondary="\(" data-tertiary="regular expression" id="idm46586640942752"/></p></td>
<td><p><code>\(</code><em><code>E</code></em><code>\)</code>    for grep and sed <sup><a data-type="noteref" id="idm46586640940032-marker" href="ch05.xhtml#idm46586640940032">b</a></sup></p></td>
<td><p><code>\(one\|two\)*</code> = Zero or more occurrences of <code>one</code> or <code>two</code></p></td>
</tr>
<tr>
<td><p><code>(</code><em><code>E</code></em><code>)</code>    for awk</p></td>
<td><p><code>(one|two)*</code> = Zero or more occurrences of <code>one</code> or <code>two</code></p></td>
</tr>
</tbody>
<tbody><tr class="footnotes"><td colspan="3"><p data-type="footnote" id="idm46586641014224"><sup><a href="ch05.xhtml#idm46586641014224-marker">a</a></sup> The three commands also differ in their treatment of regular expressions; <a data-type="xref" href="#table_regex">Table 5-1</a> presents a partial list.<a data-type="indexterm" data-primary="| (vertical bar)" data-secondary="regular expressions" id="idm46586641012704"/><a data-type="indexterm" data-primary="vertical bar (|)" data-secondary="regular expressions" id="idm46586641011760"/><a data-type="indexterm" data-primary="regular expressions" data-secondary="table of" id="idm46586641010816"/></p><p data-type="footnote" id="idm46586640940032"><sup><a href="ch05.xhtml#idm46586640940032-marker">b</a></sup> For <code>sed</code>, this syntax does more than grouping; see <a data-type="xref" href="#section_sed_subexpressions">“Matching subexpressions with sed”</a>.</p></td></tr></tbody></table>

<p>Here are some example <code>grep</code> commands with regular expressions. Match
all lines that begin with a capital letter:</p>
<pre data-type="programlisting">$ <strong>grep '^[A-Z]' myfile</strong></pre>

<p>Match all nonblank lines (i.e., match blank lines and use <code>-v</code> to omit them):</p>
<pre data-type="programlisting">$ <strong>grep -v '^$' myfile</strong></pre>

<p>Match all lines that contain either <em>cookie</em> or <em>cake</em>:</p>
<pre data-type="programlisting">$ <strong>grep 'cookie\|cake' myfile</strong></pre>

<p>Match all lines at least five characters long:</p>
<pre data-type="programlisting">$ <strong>grep '.....' myfile</strong></pre>

<p>Match all lines in which a less-than symbol appears somewhere before a
greater-than symbol, such as lines of HTML code:</p>
<pre data-type="programlisting">$ <strong>grep '&lt;.*&gt;' page.html</strong></pre>

<p>Regular expressions are great, but sometimes they get in the way.
Suppose you want to search for the two lines in the <em>frost</em> file that
contain a <code>w</code> followed by a period. The following command produces the
wrong results, because a period is a regular expression meaning “any
character”:</p>

<pre data-type="programlisting">$ <strong>grep w. frost</strong>
Whose <strong>wo</strong>ods these are I think I kno<strong>w.</strong>
He <strong>wi</strong>ll not see me stopping here
To <strong>wa</strong>tch his <strong>wo</strong>ods fill up <strong>wi</strong>th sno<strong>w.</strong></pre>

<p>To work around this problem, you can escape the special character:</p>

<pre data-type="programlisting">$ <strong>grep 'w\.' frost</strong>
Whose woods these are I think I kno<strong>w.</strong>
To watch his woods fill up with sno<strong>w.</strong></pre>

<p>but this solution becomes cumbersome if you have many special
characters to escape.  Fortunately, you can force <code>grep</code> to forget
about regular expressions and search for every character literally in
the input by using the <code>-F</code><a data-type="indexterm" data-primary="grep command" data-secondary="literal match (-F option)" id="idm46586640913824"/> (“fixed”) option; or, for an alternative with equivalent results,
run <code>fgrep</code><a data-type="indexterm" data-primary="fgrep command" id="idm46586640912448"/> instead of <code>grep</code>:</p>

<pre data-type="programlisting">$ <strong>grep -F w. frost</strong>
Whose woods these are I think I kno<strong>w.</strong>
To watch his woods fill up with sno<strong>w.</strong>
$ <strong>fgrep w. frost</strong>
Whose woods these are I think I kno<strong>w.</strong>
To watch his woods fill up with sno<strong>w.</strong></pre>

<p><code>grep</code> has many other options; I’ll present just one more that solves
a common problem.  Use the <code>-f</code><a data-type="indexterm" data-primary="grep command" data-secondary="set of strings to match (-f option)" id="idm46586640906704"/><a data-type="indexterm" data-primary="strings" data-secondary="pattern matching" data-see="pattern matching" id="idm46586640905760"/> option (lowercase; don’t confuse it
with <code>-F</code>) to match against a set of strings rather than a single
string. As a practical example, let’s list all shells found in the
file <em>/etc/passwd</em>,<a data-type="indexterm" data-primary="/etc/passwd file" id="idm46586640903408"/><a data-type="indexterm" data-primary="/etc/passwd file" data-primary-sortas="etc password" id="idm46586640902672"/> which I introduced in <a data-type="xref" href="ch01.xhtml#section_sort">“Command #5: sort”</a>. As you may
recall, each line in <em>/etc/passwd</em> contains information about a user,
organized as colon-separated fields. The final field on each line is
the program launched when the user logs in. This program is often but
not always a shell:</p>
<pre data-type="programlisting">$ <strong>cat /etc/passwd</strong>
root:x:0:0:root:/root:<mark class="box">/bin/bash</mark>                         <em>7th field is a shell</em>
daemon:x:1:1:daemon:/usr/sbin:<mark class="box">/usr/sbin/nologin</mark>         <em>7th field is not a shell</em>
⋮</pre>

<p>How can you tell if a program is a shell? Well, the file
<em>/etc/shells</em><a data-type="indexterm" data-primary="/etc/shells file" id="idm46586640896176"/><a data-type="indexterm" data-primary="/etc/shells file" data-primary-sortas="etc shells" id="idm46586640895472"/><a data-type="indexterm" data-primary="list of shells" data-secondary="installed" id="idm46586640894528"/><a data-type="indexterm" data-primary="shell" data-secondary="list of installed shells" id="idm46586640893584"/> lists all valid login shells on a Linux system:</p>

<pre data-type="programlisting">$ <strong>cat /etc/shells</strong>
/bin/sh
/bin/bash
/bin/csh</pre>

<p>So, you can list all valid shells in <em>/etc/passwd</em> by extracting the
seventh field with <code>cut</code>, eliminating duplicates with <code>sort -u</code>, and
checking the results against <em>/etc/shells</em> with <code>grep -f</code>. I also add
the <code>-F</code> option to be cautious, so all lines in <em>/etc/shells</em> are
taken literally, even if they contain special characters:<a data-type="indexterm" data-startref="grep2" id="idm46586640887504"/><a data-type="indexterm" data-primary="cut command" data-secondary="examples" id="idm46586640886720"/><a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586640885776"/></p>

<pre data-type="programlisting">$ <strong>cut -d: -f7 /etc/passwd | sort -u | grep -f /etc/shells -F</strong>
/bin/bash
/bin/sh</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The tail Command"><div class="sect2" id="idm46586641046112">
<h2>The tail Command</h2>

<p><a data-type="indexterm" data-primary="tail command" id="idm46586640882672"/><a data-type="indexterm" data-primary="last lines of a file" id="idm46586640881968"/><a data-type="indexterm" data-primary="file" data-secondary="last lines of a file" id="idm46586640881296"/>
The <code>tail</code> command prints the last lines of a file—10 lines by
default.  It’s a partner to the <code>head</code> command. Suppose you have a file
named <em>alphabet</em> containing 26 lines, one per letter:</p>

<pre data-type="programlisting">$ <strong>cat alphabet</strong>
A is for aardvark
B is for bunny
C is for chipmunk
⋮
X is for xenorhabdus
Y is for yak
Z is for zebu</pre>

<p>Print the last three lines with <code>tail</code>. The option <code>-n</code><a data-type="indexterm" data-primary="tail command" data-secondary="number of lines (-n option)" id="idm46586640876304"/> sets the
number of lines to be printed, just as it does for <code>head</code>:</p>

<pre data-type="programlisting">$ <strong>tail -n3 alphabet</strong>
X is for xenorhabdus
Y is for yak
Z is for zebu</pre>

<p>If you precede the number with a plus sign
(<code>+</code>),<a data-type="indexterm" data-primary="tail command" data-secondary="number of lines (-n option)" data-tertiary="plus sign for start number" id="idm46586640872544"/><a data-type="indexterm" data-primary="+ (plus)" data-secondary="tail command" id="idm46586640871232"/><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="tail command" id="idm46586640870288"/>
printing begins
at that line number and proceeds to the end of the file. The following
command begins at the 25th line of the file:</p>

<pre data-type="programlisting">$ <strong>tail -n+25 alphabet</strong>
Y is for yak
Z is for zebu</pre>

<p>Combine <code>tail</code> and <code>head</code> to print any range of lines<a data-type="indexterm" data-primary="range of" data-secondary="lines from a file" id="idm46586640866608"/><a data-type="indexterm" data-primary="file" data-secondary="range of lines from" id="idm46586640865632"/><a data-type="indexterm" data-primary="tail command" data-secondary="combining with head" id="idm46586640864688"/><a data-type="indexterm" data-primary="head command" data-secondary="combining with tail" id="idm46586640863744"/> from a file. To
print the fourth line alone, for example, extract the first four lines
and isolate the last one:</p>

<pre data-type="programlisting">$ <strong>head -n4 alphabet | tail -n1</strong>
D is for dingo</pre>

<p>In general, to print lines <em>M</em> through <em>N</em>, extract the first <em>N</em>
lines with <code>head</code>, then isolate the last <em>N-M+1</em> lines with
<code>tail</code>. Print lines six through eight of the <em>alphabet</em> file:</p>

<pre data-type="programlisting">$ <strong>head -n8 alphabet | tail -n3</strong>
F is for falcon
G is for gorilla
H is for hawk</pre>
<div data-type="tip"><h6>Tip</h6>
<p><code>head</code><a data-type="indexterm" data-primary="head command" data-secondary="simpler syntax" id="idm46586640855376"/> and <code>tail</code><a data-type="indexterm" data-primary="tail command" data-secondary="simpler syntax" id="idm46586640853984"/> both support a simpler syntax to specify a number of
lines without <code>-n</code>. This syntax is ancient, undocumented, and
deprecated but will probably remain supported forever:</p>
<pre data-type="programlisting">$ head -4 alphabet       <em>Same as head -n4 alphabet</em>
$ tail -3 alphabet       <em>Same as tail -n3 alphabet</em>
$ tail +25 alphabet      <em>Same as tail -n+25 alphabet</em></pre>
</div>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The awk {print} Command"><div class="sect2" id="section_awk_preview">
<h2>The awk {print} Command</h2>

<p><a data-type="indexterm" data-primary="awk command" id="idm46586640848432"/><a data-type="indexterm" data-primary="awk programs" data-secondary="printing fields" id="awkprint"/><a data-type="indexterm" data-primary="awk command" data-secondary="cutting columns" id="idm46586640846288"/><a data-type="indexterm" data-primary="print statement, awk" id="idm46586640845344"/>
The command <code>awk</code> is a general-purpose text processor with hundreds of
uses. Let’s preview one small feature, <code>print</code>, that extracts columns
from a file in ways that <code>cut</code> cannot. Consider the system file
<em>/etc/hosts</em>,<a data-type="indexterm" data-primary="/etc/hosts file" id="idm46586640842704"/><a data-type="indexterm" data-primary="/etc/hosts file" data-primary-sortas="etc hosts" id="idm46586640841968"/><a data-type="indexterm" data-primary="hosts file" data-see="/etc/hosts file" id="idm46586640841024"/> which includes IP addresses<a data-type="indexterm" data-primary="IP address" id="idm46586640839904"/> and hostnames separated by
any amount of whitespace:</p>

<pre data-type="programlisting" class="nobreakinside">$ <strong>less /etc/hosts</strong>
127.0.0.1       localhost
127.0.1.1           myhost      myhost.example.com
192.168.1.2       frodo
192.168.1.3     gollum
192.168.1.28        gandalf</pre>

<p>Suppose you want to isolate hostnames by printing the second word on
each line. The challenge is that each hostname is preceded by an
arbitrary amount of whitespace. <code>cut</code> needs its columns either lined
up neatly by column number (<code>-c</code>) or separated by a single consistent
character (<code>-f</code>). You need a command to print the second word on each
line, which <code>awk</code> provides with ease:<a data-type="indexterm" data-primary="{} (curly braces)" data-secondary="awk action" data-tertiary="print statement" id="idm46586640835104"/><a data-type="indexterm" data-primary="curly braces ({})" data-secondary="awk action" data-tertiary="print statement" id="idm46586640833824"/></p>

<pre data-type="programlisting">$ <strong>awk '{print $2}' /etc/hosts</strong>
localhost
myhost
frodo
gollum
gandalf</pre>

<p><code>awk</code> refers to any column by a dollar sign<a data-type="indexterm" data-primary="$ (dollar sign)" data-secondary="awk field" id="idm46586640830608"/><a data-type="indexterm" data-primary="dollar sign ($)" data-secondary="awk field" id="idm46586640829632"/>
followed by the column
number: for example, <code>$7</code> for the seventh column. If the column number
has more than one digit, surround the number with parentheses: for
example, <code>$(25)</code>.<a data-type="indexterm" data-primary="() (parentheses)" data-secondary="awk field numbers" id="idm46586640827552"/><a data-type="indexterm" data-primary="parentheses ()" data-secondary="awk field numbers" id="idm46586640826544"/>
To refer to the final field, use <code>$NF</code><a data-type="indexterm" data-primary="awk programs" data-secondary="number of fields ($NF)" id="idm46586640825168"/>  (“number of
fields”). To refer to the entire line, use <code>$0</code>.<a data-type="indexterm" data-primary="awk programs" data-secondary="entire line ($0)" id="idm46586640823600"/><a data-type="indexterm" data-primary="$0" data-secondary="awk input line" id="idm46586640822592"/><a data-type="indexterm" data-primary="dollar sign ($)" data-secondary="$0" data-tertiary="awk input line" id="idm46586640821648"/></p>

<p><code>awk</code> does not print whitespace<a data-type="indexterm" data-primary="awk programs" data-secondary="whitespace handling" id="idm46586640819888"/><a data-type="indexterm" data-primary="whitespace" data-secondary="awk handling of" id="idm46586640818912"/> between values by default. If you want
whitespace, separate the values with commas:<a data-type="indexterm" data-primary="awk programs" data-secondary="commas" id="idm46586640817840"/><a data-type="indexterm" data-primary=", (comma) in awk programs" id="idm46586640816896"/><a data-type="indexterm" data-primary="comma (,) in awk programs" id="idm46586640816160"/></p>

<pre data-type="programlisting">$ <strong>echo Efficient fun Linux | awk '{print $1 $3}'</strong>           <em>No whitespace</em>
EfficientLinux
$ <strong>echo Efficient fun Linux | awk '{print $1, $3}'</strong>          <em>Whitespace</em>
Efficient Linux</pre>

<p><code>awk</code>’s <code>print</code> statement is great for processing the output of
commands that strays outside tidy columns. An example is <code>df</code>,<a data-type="indexterm" data-primary="df command" id="idm46586640811008"/> which
prints the amount of free and used disk space<a data-type="indexterm" data-primary="disk space report" id="idm46586640810080"/><a data-type="indexterm" data-primary="free disk space" id="idm46586640809408"/> on a Linux system:</p>

<pre data-type="programlisting">$ <strong>df / /data</strong>
Filesystem      1K-blocks       Used  Available Use% Mounted on
/dev/sda1      1888543276  902295944  890244772  51% /
/dev/sda2      7441141620 1599844268 5466214400  23% /data</pre>

<p>The column locations may vary depending on the length of the
<code>Filesystem</code> paths, the disk sizes, and the options you pass to <code>df</code>,
so you can’t reliably extract values with <code>cut</code>. With <code>awk</code>, however,
you can easily isolate (say) the fourth value on each line,
representing available disk space:</p>

<pre data-type="programlisting">$ <strong>df / /data | awk '{print $4}'</strong>
Available
890244772
5466214400</pre>

<p>and even remove the first line (the header) at the same time with a little
<code>awk</code> magic, printing only line numbers greater than 1:<a data-type="indexterm" data-primary="awk programs" data-secondary="line number (FNR)" id="idm46586640802960"/></p>
<pre data-type="programlisting">$ <strong>df / /data | awk '<mark class="box">FNR&gt;1</mark> {print $4}'</strong>
890244772
5466214400</pre>

<p>If you encounter input separated by something other than space
characters, <code>awk</code> can change its field separator to any regular
expression with the <code>-F</code> option:<a data-type="indexterm" data-primary="awk command" data-secondary="changing field separator (-F option)" id="idm46586640798704"/></p>
<pre data-type="programlisting">$ <strong>echo efficient:::::linux | awk <mark class="box">-F':*'</mark> '{print $2}'</strong>       <em>Any number of colons</em>
linux</pre>

<p>You’ll learn more details about <code>awk</code> in <a data-type="xref" href="#section_awk">“awk essentials”</a>.<a data-type="indexterm" data-startref="awkprint" id="idm46586640793568"/></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Combining Text"><div class="sect1" id="idm46586640849552">
<h1>Combining Text</h1>

<p><a data-type="indexterm" data-primary="text" data-secondary="combining" id="idm46586640791424"/><a data-type="indexterm" data-primary="file" data-secondary="concatenating files" id="idm46586640790416"/><a data-type="indexterm" data-primary="combining text" id="idm46586640789472"/>
You already know several commands that combine text from different
files. The first is <code>cat</code>, which prints the contents of multiple
files to stdout. It’s a joiner of files top-to-bottom. That’s where
its name comes from—it con<em>cat</em>enates files:<a data-type="indexterm" data-primary="cat command" id="idm46586640787600"/><a data-type="indexterm" data-primary="concatenating files" id="idm46586640786864"/></p>

<pre data-type="programlisting">$ <strong>cat poem1</strong>
It is an ancient Mariner,
And he stoppeth one of three.
$ <strong>cat poem2</strong>
'By thy long grey beard and glittering eye,
$ <strong>cat poem3</strong>
Now wherefore stopp'st thou me?
$ <strong>cat poem1 poem2 poem3</strong>
It is an ancient Mariner,
And he stoppeth one of three.
'By thy long grey beard and glittering eye,
Now wherefore stopp'st thou me?</pre>

<p>The second command you’ve seen for combining text is <code>echo</code>,<a data-type="indexterm" data-primary="echo command" id="idm46586640782656"/> the shell
builtin that prints whatever arguments you give it, separated by a
single space character. It combines strings side by side:</p>

<pre data-type="programlisting">$ <strong>echo efficient             linux     in     $HOME</strong>
efficient linux in /home/smith</pre>

<p>Let’s examine some more commands that combine text:</p>
<dl>
<dt><code>tac</code></dt>
<dd>
<p>A bottom-to-top combiner of text files</p>
</dd>
<dt><code>paste</code></dt>
<dd>
<p>A side-by-side combiner of text files</p>
</dd>
<dt><code>diff</code></dt>
<dd>
<p>A command that interleaves text from two files by printing their differences</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="The tac Command"><div class="sect2" id="idm46586640774992">
<h2>The tac Command</h2>

<p><a data-type="indexterm" data-primary="tac command" id="idm46586640773616"/><a data-type="indexterm" data-primary="reversing text" data-secondary="lines of a file" id="idm46586640772912"/>
The <code>tac</code> command reverses a file line by line. Its name is <em>cat</em>
spelled backward.</p>

<pre data-type="programlisting">$ <strong>cat poem1 poem2 poem3 | tac</strong>
Now wherefore stopp'st thou me?
'By thy long grey beard and glittering eye,
And he stoppeth one of three.
It is an ancient Mariner,</pre>

<p>Notice I concatenated three files before reversing the text. If I instead
provide multiple files to <code>tac</code> as arguments, it reverses the lines of
each file in turn, producing different output:</p>

<pre data-type="programlisting">$ <strong>tac poem1 poem2 poem3</strong>
And he stoppeth one of three.                    <em>First file reversed</em>
It is an ancient Mariner,
'By thy long grey beard and glittering eye,      <em>Second file</em>
Now wherefore stopp'st thou me?                  <em>Third file</em></pre>

<p><code>tac</code> is great for processing data that is already in
chronological<a data-type="indexterm" data-primary="chronological data, reversing" id="idm46586640765440"/> order but not reversible with the
<code>sort -r</code><a data-type="indexterm" data-primary="sort command" data-secondary="reverse direction (-r option)" id="idm46586640764208"/> command.
A typical case is reversing a web-server log file to process its lines
from newest to oldest:</p>

<pre data-type="programlisting">192.168.1.34 - - [30/Nov/2021:23:37:39 -0500] "GET / HTTP/1.1" ...
192.168.1.10 - - [01/Dec/2021:00:02:11 -0500] "GET /notes.html HTTP/1.1" ...
192.168.1.8 - - [01/Dec/2021:00:04:30 -0500] "GET /stuff.html HTTP/1.1" ...
⋮</pre>

<p>The lines are in chronological order with timestamps, but they aren’t
in alphabetical or numeric order, so the <code>sort -r</code> command isn’t
helpful. The <code>tac</code> command can reverse these lines without needing to
consider the timestamps.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The paste Command"><div class="sect2" id="idm46586640760768">
<h2>The paste Command</h2>

<p><a data-type="indexterm" data-primary="paste command" data-seealso="cut command" id="idm46586640759392"/>
The <code>paste</code> command combines files side by side in columns separated
by a single tab character. It’s a partner to the <code>cut</code> command, which extracts
columns from a tab-separated file:</p>

<pre data-type="programlisting">$ <strong>cat title-words1</strong>
EFFICIENT
AT
COMMAND
$ <strong>cat title-words2</strong>
linux
the
line
$ <strong>paste title-words1 title-words2</strong>
EFFICIENT	linux
AT	the
COMMAND line
$ <strong>paste title-words1 title-words2 | cut -f2</strong>        <em>cut &amp; paste are complementary</em>
linux
the
line</pre>

<p>Change the separator to another character, such as a comma, with the
option <code>-d</code><a data-type="indexterm" data-primary="paste command" data-secondary="separator (-d option)" id="idm46586640753296"/> (meaning “delimiter<a data-type="indexterm" data-primary="delimiter" id="idm46586640752192"/>”):</p>

<pre data-type="programlisting">$ <strong>paste -d, title-words1 title-words2</strong>
EFFICIENT,linux
AT,the
COMMAND,line</pre>

<p>Transpose the output, producing pasted rows instead of pasted columns,
with <a data-type="indexterm" data-primary="paste command" data-secondary="transposed output (-s option)" id="idm46586640749792"/>the 
<span class="keep-together"><code>-s</code> option:</span></p>

<pre data-type="programlisting">$ <strong>paste -d, -s title-words1 title-words2</strong>
EFFICIENT,AT,COMMAND
linux,the,line</pre>

<p><code>paste</code> also interleaves data<a data-type="indexterm" data-primary="interleaving files" data-secondary="paste" id="idm46586640745504"/> from two or more files if you change
the separator to a newline character (<code>\n</code>):<a data-type="indexterm" data-primary="paste command" data-secondary="separator (-d option)" data-tertiary="newline character" id="idm46586640743984"/><a data-type="indexterm" data-primary="newline character" data-secondary="paste command" id="idm46586640742704"/><a data-type="indexterm" data-primary="newline character" data-secondary="syntax (\n)" id="idm46586640741760"/><a data-type="indexterm" data-primary="\n for newline" data-seealso="newline character" id="idm46586640740816"/><a data-type="indexterm" data-primary="backslash (\)" data-secondary="\n for newline" data-seealso="newline character" id="idm46586640739872"/><a data-type="indexterm" data-primary="separator" data-secondary="paste command" id="idm46586640738656"/></p>

<pre data-type="programlisting">$ <strong>paste -d "\n" title-words1 title-words2</strong>
EFFICIENT
linux
AT
the
COMMAND
line</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The diff Command"><div class="sect2" id="idm46586640736592">
<h2>The diff Command</h2>

<p><a data-type="indexterm" data-primary="diff command" id="idm46586640735280"/><a data-type="indexterm" data-primary="interleaving files" data-secondary="diff" id="idm46586640734576"/>
<code>diff</code> compares two files line by line and prints a terse report about their
differences:</p>

<pre data-type="programlisting">$ <strong>cat file1</strong>
Linux is all about efficiency.
I hope you will enjoy this book.
$ <strong>cat file2</strong>
MacOS is all about efficiency.
I hope you will enjoy this book.
Have a nice day.
$ <strong>diff file1 file2</strong>
1c1
&lt; Linux is all about efficiency.
---
&gt; MacOS is all about efficiency.
2a3
&gt; Have a nice day.</pre>

<p>The notation <code>1c1</code> represents a change or difference between the
files. It means that line 1 in the first file differs from line 1 in
the second file. This notation is followed by the relevant line from
<em>file1</em>, a three-dash separator (<code>---</code>),<a data-type="indexterm" data-primary="--- separator in diff output" id="idm46586640728656"/><a data-type="indexterm" data-primary="dash (-)" data-secondary="--- separator in diff output" id="idm46586640727856"/><a data-type="indexterm" data-primary="separator" data-secondary="diff output" id="idm46586640726896"/>
and the relevant line from <em>file2</em>.  The leading symbol
<code>&lt;</code><a data-type="indexterm" data-primary="&lt; (less than)" data-secondary="diff output" id="idm46586640725120"/><a data-type="indexterm" data-primary="less than (&lt;)" data-secondary="diff output" id="idm46586640724144"/>
always indicates a line from the first file, and
<code>&gt;</code><a data-type="indexterm" data-primary="&gt; (greater than)" data-secondary="diff output" id="idm46586640722752"/><a data-type="indexterm" data-primary="greater than (&gt;)" data-secondary="diff output" id="idm46586640721776"/>
indicates a line from the second file.</p>

<p>The notation <code>2a3</code> represents an addition. It means that <em>file2</em> has a
third line not present after the second line of <em>file1</em>. This notation
is followed by the extra line from <em>file2</em>, “Have a nice day.”</p>

<p><code>diff</code> output may contain other notation and can take other
forms. This short explanation is enough for our main purpose, however,
which is to use <code>diff</code> as a text processor that interleaves lines from
two files. Many users don’t think of <code>diff</code> this way, but it’s great
for forming pipelines to solve certain kinds of problems. For example,
you can isolate the differing lines with <code>grep</code> and <code>cut</code>:<a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586640715632"/><a data-type="indexterm" data-primary="cut command" data-secondary="examples" id="idm46586640714624"/></p>
<pre data-type="programlisting">$ <strong>diff file1 file2 | grep '^[&lt;&gt;]'</strong>
&lt; Linux is all about efficiency.
&gt; MacOS is all about efficiency.
&gt; Have a nice day.
$ <strong>diff file1 file2 | grep '^[&lt;&gt;]' | cut -c3-</strong>
Linux is all about efficiency.
MacOS is all about efficiency.
Have a nice day.</pre>

<p>You’ll see practical examples in <a data-type="xref" href="ch07.xhtml#section_process_substitution">“Technique #4: Process Substitution”</a> and
<a data-type="xref" href="ch08.xhtml#section_matched_pairs">“Checking Matched Pairs of Files”</a>.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Transforming Text"><div class="sect1" id="idm46586640792272">
<h1>Transforming Text</h1>

<p><a data-type="indexterm" data-primary="transforming text" id="idm46586640708704"/><a data-type="indexterm" data-primary="text" data-secondary="transforming" id="idm46586640707776"/>
<a data-type="xref" href="ch01.xhtml#ch_combining_commands">Chapter 1</a> introduced several commands that read text
from stdin and transform
it into something else on stdout. <code>wc</code> prints a count of lines, words,
and characters; <code>sort</code> arranges lines into alphabetical or numeric
order; and <code>uniq</code> consolidates duplicate lines. Let’s discuss several
more commands that transform their input:</p>
<dl>
<dt><code>tr</code></dt>
<dd>
<p>Translates characters into other characters</p>
</dd>
<dt><code>rev</code></dt>
<dd>
<p>Reverses characters on a line</p>
</dd>
<dt><code>awk</code> and <code>sed</code></dt>
<dd>
<p>General-purpose transformers</p>
</dd>
</dl>








<section data-type="sect2" data-pdf-bookmark="The tr Command"><div class="sect2" id="section_tr">
<h2>The tr Command</h2>

<p><a data-type="indexterm" data-primary="tr command" id="idm46586640697040"/><a data-type="indexterm" data-primary="translating characters" id="idm46586640696112"/>
<code>tr</code> translates one set of characters into another.
I showed you one example in <a data-type="xref" href="ch02.xhtml#ch_shell">Chapter 2</a> of translating colons into
newline characters to print the shell’s <code>PATH</code>:<a data-type="indexterm" data-primary="PATH variable" id="idm46586640693600"/><a data-type="indexterm" data-primary="variables" data-secondary="PATH" id="idm46586640692864"/><a data-type="indexterm" data-primary="newline character" data-secondary="translating with tr" id="idm46586640691920"/><a data-type="indexterm" data-primary="newline character" data-secondary="syntax (\n)" id="idm46586640690976"/><a data-type="indexterm" data-primary=": (colon)" data-secondary="PATH separator" id="idm46586640690032"/><a data-type="indexterm" data-primary="colon (:)" data-secondary="PATH separator" id="idm46586640689088"/><a data-type="indexterm" data-primary="separator" data-secondary="colon" data-tertiary="PATH" id="idm46586640688144"/></p>

<pre data-type="programlisting">$ <strong>echo $PATH | tr : "\n"</strong>              <em>Translate colons into newlines</em>
/home/smith/bin
/usr/local/bin
/usr/bin
/bin
/usr/games
/usr/lib/java/bin</pre>

<p><code>tr</code> takes two sets of characters as arguments, and it translates
members of the first set into the corresponding members of the
second. Common uses are converting text to uppercase or lowercase:<a data-type="indexterm" data-primary="- (dash)" data-secondary="tr character sets" id="idm46586640684672"/><a data-type="indexterm" data-primary="dash (-)" data-secondary="tr character sets" id="idm46586640683696"/><a data-type="indexterm" data-primary="changing" data-secondary="case of text" id="idm46586640682752"/><a data-type="indexterm" data-primary="converting text to uppercase or lowercase" id="idm46586640681808"/><a data-type="indexterm" data-primary="uppercase conversion" id="idm46586640681040"/><a data-type="indexterm" data-primary="lowercase conversion" id="idm46586640680368"/><a data-type="indexterm" data-primary="case of text changed" id="idm46586640679696"/></p>

<pre data-type="programlisting">$ <strong>echo efficient | tr a-z A-Z</strong>         <em>Translate a into A, b into B, etc.</em>
EFFICIENT
$ <strong>echo Efficient | tr A-Z a-z</strong>
efficient</pre>

<p>converting spaces into newlines:<a data-type="indexterm" data-primary="newline character" data-secondary="translating with tr" id="idm46586640676624"/><a data-type="indexterm" data-primary="newline character" data-secondary="syntax (\n)" id="idm46586640675648"/></p>

<pre data-type="programlisting">$ <strong>echo Efficient Linux | tr " " "\n"</strong>
Efficient
Linux</pre>

<p>and deleting whitespace<a data-type="indexterm" data-primary="whitespace" data-secondary="deleting" id="idm46586640673136"/> with the <code>-d</code><a data-type="indexterm" data-primary="tr command" data-secondary="deleting characters (-d option)" id="idm46586640671712"/><a data-type="indexterm" data-primary="tr command" data-secondary="whitespace deleted" id="idm46586640670672"/> (delete) option:</p>
<pre data-type="programlisting">$ <strong>echo efficient linux | tr -d ' \t'</strong>      <em>Remove spaces and tabs</em>
efficientlinux</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The rev Command"><div class="sect2" id="section_rev">
<h2>The rev Command</h2>

<p><a data-type="indexterm" data-primary="rev command" id="idm46586640666400"/><a data-type="indexterm" data-primary="reversing text" data-secondary="characters on a line" id="idm46586640665696"/>
The <code>rev</code> command reverses the characters of each line of
input:<sup><a data-type="noteref" id="idm46586640664208-marker" href="ch05.xhtml#idm46586640664208">4</a></sup></p>

<pre data-type="programlisting">$ <strong>echo Efficient Linux! | rev</strong>
!xuniL tneiciffE</pre>

<p>Beyond the obvious entertainment value, <code>rev</code> is handy for extracting
tricky information from files. Suppose you have a file of celebrity
names:</p>

<pre data-type="programlisting">$ <strong>cat celebrities</strong>
Jamie Lee Curtis
Zooey Deschanel
Zendaya Maree Stoermer Coleman
Rihanna</pre>

<p>and you want to extract the final word on each line<a data-type="indexterm" data-primary="final word on a line" data-secondary="extracting" data-tertiary="double rev trick" id="idm46586640659088"/><a data-type="indexterm" data-primary="double rev trick" id="idm46586640657840"/> (Curtis, Deschanel,
Coleman, Rihanna). This would be easy with <code>cut -f</code> if each line had
the same number of fields, but the number varies. With <code>rev</code>, you can
reverse all the lines, cut the <em>first</em> field, and reverse again to
achieve your goal:<sup><a data-type="noteref" id="idm46586640655616-marker" href="ch05.xhtml#idm46586640655616">5</a></sup></p>

<pre data-type="programlisting">$ <strong>rev celebrities</strong>
sitruC eeL eimaJ
lenahcseD yeooZ
nameloC remreotS eeraM ayadneZ
annahiR
$ <strong>rev celebrities | cut -d' ' -f1</strong>
sitruC
lenahcseD
nameloC
annahiR
$ <strong>rev celebrities | cut -d' ' -f1 | rev</strong>
Curtis
Deschanel
Coleman
Rihanna</pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The awk and sed Commands"><div class="sect2" id="idm46586640651424">
<h2>The awk and sed Commands</h2>

<p><a data-type="indexterm" data-primary="awk command" data-seealso="awk programs" id="awk"/><a data-type="indexterm" data-primary="sed command" id="idm46586640648656"/>
<code>awk</code> and <code>sed</code> are general-purpose “supercommands” for processing
text. They can do most everything that the other commands in this
chapter do, but with more cryptic-looking syntax.
As a simple example, they can print the first 10
lines of a file like <code>head</code> does:<a data-type="indexterm" data-primary="awk programs" data-secondary="line number (FNR)" id="idm46586640646320"/></p>

<pre data-type="programlisting">$ <strong>sed 10q myfile</strong>                  <em>Print 10 lines and quit (q)</em>
$ <strong>awk 'FNR&lt;=10' myfile</strong>            <em>Print while line number is ≤ 10</em></pre>

<p>They can also do things that our other commands cannot, like replace
or swap strings:<a data-type="indexterm" data-primary="swapping strings" id="idm46586640642592"/><a data-type="indexterm" data-primary="replacing a string" id="idm46586640641888"/><a data-type="indexterm" data-primary="strings" data-secondary="replacing" id="idm46586640641216"/><a data-type="indexterm" data-primary="strings" data-secondary="swapping" id="idm46586640640272"/></p>
<pre data-type="programlisting">$ <strong>echo image.jpg | sed 's/\.jpg/.png/'</strong>                 <em>Replace .jpg by .png</em>
image.png
$ <strong>echo "linux efficient" | awk '{print $2, $1}'</strong>        <em>Swap two words</em>
efficient linux
</pre>

<p><code>awk</code> and <code>sed</code> are harder to learn than the other commands I’ve
covered, because each of them has a miniature programming language
built in. They have so many capabilities that whole books have been
written on them.<sup><a data-type="noteref" id="idm46586640635552-marker" href="ch05.xhtml#idm46586640635552">6</a></sup> I highly recommend spending quality time learning both
commands (or at least one of them). To begin your journey, I cover
basic principles of each command and demonstrate some common
uses. I also recommend several online tutorials to learn more about
these powerful, crucial commands.</p>

<p>Don’t worry about memorizing every feature of <code>awk</code> or <code>sed</code>. Success
with these commands really means:</p>

<ul>
<li>
<p>Understanding the <em>kinds</em> of transformations they make possible, so
you can think, “Ah! This is a job for <code>awk</code> (or <code>sed</code>)!” and apply them
in your time of need</p>
</li>
<li>
<p>Learning to read their manpages and to find complete solutions on
<a href="https://oreil.ly/0948M">Stack Exchange</a><a data-type="indexterm" data-primary="Stack Exchange" id="idm46586640628112"/> and other online
resources</p>
</li>
</ul>










<section data-type="sect3" data-pdf-bookmark="awk essentials"><div class="sect3" id="section_awk">
<h3>awk essentials</h3>

<p><code>awk</code> transforms lines of text from files (or stdin) into any other
text, using a sequence of instructions called an <em>awk
program</em>.<a data-type="indexterm" data-primary="awk programs" data-seealso="awk command" id="idm46586640623776"/><sup><a data-type="noteref" id="idm46586640622768-marker" href="ch05.xhtml#idm46586640622768">7</a></sup> The more skilled you become
in writing awk programs, the more flexibly you can manipulate
text. You can supply the awk program on the command line:<a data-type="indexterm" data-primary="awk command" data-secondary="syntax" id="idm46586640620368"/></p>

<pre data-type="programlisting">$ <strong>awk <em>program</em> <em>input-files</em></strong></pre>

<p>You can also store one or more awk programs in files and refer to
them with <a data-type="indexterm" data-primary="awk command" data-secondary="reading program from file (-f option)" id="idm46586640617216"/>the 
<span class="keep-together"><code>-f</code> option,</span> and the programs run in sequence:</p>

<pre data-type="programlisting">$ <strong>awk -f <em>program-file1</em> -f <em>program-file2</em> -f <em>program-file3</em> <em>input-files</em></strong></pre>

<p>An awk program includes one or more <em>actions</em>,<a data-type="indexterm" data-primary="awk programs" data-secondary="actions" id="idm46586640611424"/><a data-type="indexterm" data-primary="actions in awk programs" id="idm46586640610416"/> such as calculating
values or printing text, that run when an input line matches a
<em>pattern</em>.<a data-type="indexterm" data-primary="awk programs" data-secondary="patterns" id="idm46586640609232"/><a data-type="indexterm" data-primary="patterns in awk programs" id="idm46586640608224"/> Each instruction in the program has the form:<a data-type="indexterm" data-primary="{} (curly braces)" data-secondary="awk action" id="idm46586640607296"/><a data-type="indexterm" data-primary="curly braces ({})" data-secondary="awk action" id="idm46586640606352"/></p>

<pre data-type="programlisting"><em>pattern</em> {<em>action</em>}</pre>

<p>Typical patterns include:</p>
<dl>
<dt>The word <code>BEGIN</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="awk programs" data-secondary="BEGIN pattern" id="idm46586640601840"/><a data-type="indexterm" data-primary="BEGIN pattern, awk" id="idm46586640600864"/>Its action runs just once, before <code>awk</code> processes
any input.</p>
</dd>
<dt>The word <code>END</code></dt>
<dd>
<p><a data-type="indexterm" data-primary="awk programs" data-secondary="END pattern" id="idm46586640598080"/><a data-type="indexterm" data-primary="END pattern, awk" id="idm46586640597104"/>Its action runs just once, after <code>awk</code> has processed
all the input.</p>
</dd>
<dt>A regular expression (see <a data-type="xref" href="#table_regex">Table 5-1</a>) surrounded by forward slashes</dt>
<dd>
<p><a data-type="indexterm" data-primary="awk programs" data-secondary="regular expressions" id="idm46586640593776"/><a data-type="indexterm" data-primary="regular expressions" data-secondary="awk" id="idm46586640592800"/><a data-type="indexterm" data-primary="/ (forward slash)" data-secondary="awk operator for regular expressions" id="idm46586640591856"/><a data-type="indexterm" data-primary="forward slash (/)" data-secondary="awk operator for regular expressions" id="idm46586640590848"/>An example is <code>/^[A-Z]/</code> to match lines that begin with a
capital letter.</p>
</dd>
<dt>Other expressions specific to <code>awk</code></dt>
<dd>
<p>For example, to check whether
the third field on an input line (<code>$3</code>) begins with a capital letter,
a pattern would be <code>$3~/^[A-Z]/</code>. Another example is <code>FNR&gt;5</code>,<a data-type="indexterm" data-primary="awk programs" data-secondary="line number (FNR)" id="idm46586640586064"/> which
tells <code>awk</code> to skip the first five lines of input.<a data-type="indexterm" data-primary="awk programs" data-secondary="skipping lines" id="idm46586640584512"/></p>
</dd>
</dl>

<p>An action with no pattern<a data-type="indexterm" data-primary="awk programs" data-secondary="default pattern" id="idm46586640583152"/> runs for every line of input.  (Several
awk programs in <a data-type="xref" href="#section_awk_preview">“The awk {print} Command”</a> were of this type.) As an
example, <code>awk</code> elegantly solves the “print the celebrity’s last name”
problem from <a data-type="xref" href="#section_rev">“The rev Command”</a> by directly printing the final word from
each line:<a data-type="indexterm" data-primary="final word on a line" data-secondary="extracting" data-tertiary="awk" id="idm46586640579888"/></p>

<pre data-type="programlisting">$ <strong>awk '{print $NF}' celebrities</strong>
Curtis
Deschanel
Coleman
Rihanna</pre>
<div data-type="tip"><h6>Tip</h6>
<p>When supplying an awk program on the command line, enclose it in
quotes<a data-type="indexterm" data-primary="awk programs" data-secondary="quoting on command line" id="idm46586640576496"/> to prevent the shell from evaluating <code>awk</code>’s special
characters. Use single or double quotes as needed.</p>
</div>

<p>A pattern with no action runs the default action <code>{print}</code>,<a data-type="indexterm" data-primary="awk programs" data-secondary="default action" id="idm46586640573680"/> which just
prints any matching input lines unchanged:</p>

<pre data-type="programlisting">$ <strong>echo efficient linux | awk '/efficient/'</strong>
efficient linux</pre>

<p>For a fuller demonstration, process the tab-separated file
<em>animals.txt</em> from <a data-type="xref" href="ch01.xhtml#example_animals.txt">Example 1-1</a> to produce a tidy
bibliography, converting lines from this format:</p>

<pre data-type="programlisting">python	Programming Python	2010	Lutz, Mark</pre>

<p>to this format:</p>

<pre data-type="programlisting">Lutz, Mark (2010). "Programming Python"</pre>

<p>This feat requires rearranging three fields and adding some characters
like parentheses and double quotes. The following awk program does the
trick, employing the option <code>-F</code><a data-type="indexterm" data-primary="awk command" data-secondary="changing field separator (-F option)" id="idm46586640566656"/><a data-type="indexterm" data-primary="separator" data-secondary="awk programs" id="idm46586640565616"/> to change the input separator from
spaces to tabs (<code>\t</code>):</p>
<pre data-type="programlisting">$ <strong>awk -F'\t' <mark class="box">'{print $4, "(" $3 ").", "\"" $2 "\""}'</mark> animals.txt</strong>
Lutz, Mark (2010). "Programming Python"
Barrett, Daniel (2005). "SSH, The Secure Shell"
Schwartz, Randal (2012). "Intermediate Perl"
Bell, Charles (2014). "MySQL High Availability"
Siever, Ellen (2009). "Linux in a Nutshell"
Boney, James (2005). "Cisco IOS in a Nutshell"
Roman, Steven (1999). "Writing Word Macros"</pre>

<p>Add a regular expression to process only the “horse” book:</p>
<pre data-type="programlisting">$ <strong>awk -F'\t' '<mark class="box">/^horse/</mark>{print $4, "(" $3 ").", "\"" $2 "\""}' animals.txt</strong>
Siever, Ellen (2009). "Linux in a Nutshell"</pre>

<p>Or process only books from 2010 or later, by testing whether field
<code>$3</code> matches <code>^201</code>:</p>
<pre data-type="programlisting">$ <strong>awk -F'\t' '<mark class="box">$3~/^201/</mark>{print $4, "(" $3 ").", "\"" $2 "\""}' animals.txt</strong>
Lutz, Mark (2010). "Programming Python"
Schwartz, Randal (2012). "Intermediate Perl"
Bell, Charles (2014). "MySQL High Availability"</pre>

<p>Finally, add a <code>BEGIN</code> instruction to print a friendly heading, some dashes
for indenting, and an <code>END</code> instruction to direct the reader to further
information:</p>
<pre data-type="programlisting">$ <strong>awk -F'\t' \
  '<mark class="box">BEGIN {print "Recent books:"}</mark> \
  $3~/^201/{print "-", $4, "(" $3 ").", "\"" $2 "\""} \
  <mark class="box">END {print "For more books, search the web"}</mark>' \
  animals.txt</strong>
Recent books:
- Lutz, Mark (2010). "Programming Python"
- Schwartz, Randal (2012). "Intermediate Perl"
- Bell, Charles (2014). "MySQL High Availability"
For more books, search the web</pre>

<p><code>awk</code> does much more than print—it can also perform calculations,<a data-type="indexterm" data-primary="awk programs" data-secondary="math" id="idm46586640551536"/>
like summing the numbers 1 to 100:</p>
<pre data-type="programlisting">$ <strong>seq 1 100 | awk '{s+=$1} END {print s}'</strong>
5050</pre>

<p>To learn <code>awk</code> beyond what can be covered in a few book pages, take an
<code>awk</code> tutorial at <a href="https://www.tutorialspoint.com/awk/" class="orm:hideurl">tutorialspoint.com/awk</a> or
<a href="https://riptutorial.com/awk" class="orm:hideurl">riptutorial.com/awk</a> or search the web for
“awk tutorial.”<a data-type="indexterm" data-primary="awk command" data-secondary="tutorials" id="idm46586640545488"/><a data-type="indexterm" data-primary="tutorials" data-secondary="awk" id="idm46586640544512"/> You’ll be glad you did.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Improving the duplicate file detector"><div class="sect3" id="sec_awk_arrays">
<h3>Improving the duplicate file detector</h3>

<p><a data-type="indexterm" data-primary="duplicate detection" data-secondary="files" data-tertiary="improved with awk" id="idm46586640541456"/>
In <a data-type="xref" href="ch01.xhtml#sec_duplicate_files">“Detecting Duplicate Files”</a>, you constructed a pipeline that detects
and counts duplicate JPEG files by checksum, but it was not powerful
enough to print the filenames:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg | cut -c1-32 | sort | uniq -c | sort -nr | grep -v "      1 "</strong>
      3 f6464ed766daca87ba407aede21c8fcc
      2 c7978522c58425f6af3f095ef1de1cd5
      2 146b163929b6533f02e91bdf21cb9563</pre>

<p>Now that you know <code>awk</code>, you have the tools to print the filenames as
well. Let’s construct a new command that reads each line of <code>md5sum</code><a data-type="indexterm" data-primary="md5sum command" id="idm46586640536592"/>
output:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg</strong>
146b163929b6533f02e91bdf21cb9563  image001.jpg
63da88b3ddde0843c94269638dfa6958  image002.jpg
146b163929b6533f02e91bdf21cb9563  image003.jpg
⋮</pre>

<p class="pagebreak-after">and not only counts occurrences of each checksum but also stores the
filenames for printing. You’ll need two additional <code>awk</code>
features called <em>arrays</em> and <em>loops</em>.</p>

<p>An <em>array</em><a data-type="indexterm" data-primary="awk programs" data-secondary="arrays" id="awkarrays"/><a data-type="indexterm" data-primary="arrays, awk" id="awkarrays2"/> is a variable that holds a collection of values. If the array
is named <code>A</code> and holds seven values, then the values could be accessed
as <code>A[1]</code>,<a data-type="indexterm" data-primary="[] (square brackets)" data-secondary="awk arrays" id="idm46586640527968"/><a data-type="indexterm" data-primary="square brackets ([])" data-secondary="awk arrays" id="idm46586640526960"/> <code>A[2]</code>, <code>A[3]</code>, up to <code>A[7]</code>. The values 1 through 7 are
called the <em>keys</em> of the array, and <code>A[1]</code> through <code>A[7]</code> are called
the array’s <em>elements</em>.<a data-type="indexterm" data-primary="elements of awk arrays" id="idm46586640522848"/> You can create any keys you want, however.  If
you’d rather access the seven elements of your array using the names
of Disney characters,<a data-type="indexterm" data-primary="dwarves, seven" id="idm46586640521824"/> go ahead and name them <code>A["Doc"]</code>,
<code>A["Grumpy"]</code>, <code>A["Bashful"]</code>, all the way to <code>A["Dopey"]</code>.</p>

<p>To count duplicate images, create an array called <code>counts</code> with one
element for each checksum. Each array key is a checksum, and the
associated element holds the number of times that
checksum occurs in the input. For example, the array element
<code>counts["f6464ed766daca87ba407aede21c8fcc"]</code> could have value 3. The
following awk script examines each line of <code>md5sum</code> output, isolates
the checksum (<code>$1</code>), and uses it as a key for the <code>counts</code> array. The
operator <code>++</code> increments an element by 1 each time <code>awk</code>
encounters its associated checksum:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg | awk '{counts[$1]++}'</strong></pre>

<p>So far, the awk script produces no output—it just counts each
checksum and exits. To print the counts, you need a second <code>awk</code>
feature called a <code>for</code> loop.<a data-type="indexterm" data-primary="awk programs" data-secondary="loops" id="idm46586640513104"/><a data-type="indexterm" data-primary="for loop" data-secondary="awk" id="idm46586640512096"/><a data-type="indexterm" data-primary="loops" data-secondary="awk for loop" id="idm46586640511152"/>  A <code>for</code> loop steps through an array, key
by key, and processes each element in sequence, using this 
<span class="keep-together">syntax:</span></p>

<pre data-type="programlisting">for (<em>variable</em> in <em>array</em>) <em>do something with array[variable]</em></pre>

<p>For example, print each array element by its key:<a data-type="indexterm" data-primary="awk programs" data-secondary="arrays" data-tertiary="printing" id="idm46586640506768"/><a data-type="indexterm" data-primary="arrays, awk" data-secondary="printing" id="idm46586640505520"/></p>

<pre data-type="programlisting">for (key in counts) print array[key]</pre>

<p>Place this loop in the <code>END</code> instruction so it runs after all the
counts are calculated.</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg \
  | awk '{counts[$1]++} \
         END {<mark class="box">for (key in counts) print counts[key]</mark>}'</strong>
1
2
2
⋮</pre>

<p>Next, add the checksums to the output. Each array key is a checksum,
so just print the key after the count:</p>
<pre data-type="programlisting" class="pagebreak-after">$ <strong>md5sum *.jpg \
  | awk '{counts[$1]++} \
         END {for (key in counts) print counts[key] <mark class="box">" " key</mark>}'</strong>
1 714eceeb06b43c03fe20eb96474f69b8
2 146b163929b6533f02e91bdf21cb9563
2 c7978522c58425f6af3f095ef1de1cd5
⋮</pre>

<p>To collect and print filenames, use a second array, <code>names</code>, also with
checksums as its keys. As <code>awk</code> processes each line of output, append
the filename (<code>$2</code>) to the corresponding element of the <code>names</code> array,
along with a space as a separator. In the <code>END</code> loop, after printing
the checksum (<code>key</code>), print a colon and the collected filenames for
that checksum:</p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg \
  | awk '{counts[$1]++; <mark class="box">names[$1]=names[$1] " " $2</mark>} \
         END {for (key in counts) print counts[key] " " key <mark class="box">":" names[key]</mark>}'</strong>
1 714eceeb06b43c03fe20eb96474f69b8: image011.jpg
2 146b163929b6533f02e91bdf21cb9563: image001.jpg image003.jpg
2 c7978522c58425f6af3f095ef1de1cd5: image019.jpg image020.jpg
⋮</pre>

<p>Lines that begin with 1 represent checksums that occur only once, so
they are not duplicates. Pipe the output to <code>grep -v</code> to remove these
lines, then sort the results numerically, high to low, with <code>sort -nr</code>
and you have your desired output:<a data-type="indexterm" data-startref="awk" id="idm46586640490464"/><a data-type="indexterm" data-startref="awkarrays" id="idm46586640489760"/><a data-type="indexterm" data-startref="awkarrays2" id="idm46586640489088"/><a data-type="indexterm" data-primary="grep command" data-secondary="examples" id="idm46586640488416"/><a data-type="indexterm" data-primary="sort command" data-secondary="examples" id="idm46586640487472"/></p>
<pre data-type="programlisting">$ <strong>md5sum *.jpg \
  | awk '{counts[$1]++; names[$1]=names[$1] " " $2} \
         END {for (key in counts) print counts[key] " " key ":" names[key]}' \
  | grep -v '^1 ' \
  | sort -nr</strong>
3 f6464ed766daca87ba407aede21c8fcc: image007.jpg image012.jpg image014.jpg
2 c7978522c58425f6af3f095ef1de1cd5: image019.jpg image020.jpg
2 146b163929b6533f02e91bdf21cb9563: image001.jpg image003.jpg</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="sed essentials"><div class="sect3" id="idm46586640542656">
<h3>sed essentials</h3>

<p><a data-type="indexterm" data-primary="sed command" data-seealso="sed scripts" id="sed"/>
<code>sed</code>, like <code>awk</code>, transforms text from files (or stdin) into any
other text, using a sequence of instructions called a <em>sed
script</em><a data-type="indexterm" data-primary="sed scripts" data-seealso="sed command" id="idm46586640480752"/>.<sup><a data-type="noteref" id="idm46586640479648-marker" href="ch05.xhtml#idm46586640479648">8</a></sup> sed scripts are pretty cryptic on first
glance. An example is <code>s/Windows/Linux/g</code>, which means to replace
every occurrence of the string <code>Windows</code> with <code>Linux</code>. The word
<em>script</em> here does not mean a file (like a shell script) but a
string.<sup><a data-type="noteref" id="idm46586640476576-marker" href="ch05.xhtml#idm46586640476576">9</a></sup> Invoke <code>sed</code> with a single script on the
command line:</p>

<pre data-type="programlisting">$ <strong>sed <em><em>script</em></em> <em>input-files</em></strong></pre>

<p>or use the <code>-e</code><a data-type="indexterm" data-primary="sed command" data-secondary="running multiple scripts (-e option)" id="idm46586640469904"/> option to supply multiple scripts that process the
input in sequence:</p>

<pre data-type="programlisting">$ <strong>sed -e <em><em>script1</em></em> -e <em><em>script2</em></em> -e <em><em>script3</em></em> <em>input-files</em></strong></pre>

<p>You can also store sed scripts in files and refer to them with the
<code>-f</code><a data-type="indexterm" data-primary="sed command" data-secondary="reading script from file (-f option)" id="idm46586640464928"/> option, and they run in sequence:</p>

<pre data-type="programlisting" class="pagebreak-after">$ <strong>sed -f <em>script-file1</em> -f <em>script-file2</em> -f <em>script-file3</em> <em>input-files</em></strong></pre>

<p>As with <code>awk</code>, the utility of <code>sed</code> depends on your skill in creating
sed scripts. The most common type of script is a substitution script<a data-type="indexterm" data-primary="sed scripts" data-secondary="substitution script" id="idm46586640459280"/><a data-type="indexterm" data-primary="substitution" data-secondary="sed script" id="idm46586640458304"/>
that replaces strings with other strings. The syntax is:<a data-type="indexterm" data-primary="/ (forward slash)" data-secondary="sed operator" id="idm46586640457232"/><a data-type="indexterm" data-primary="forward slash (/)" data-secondary="sed operator" id="idm46586640456208"/><a data-type="indexterm" data-primary="slash, forward" data-see="forward slash (/)" id="idm46586640455264"/></p>

<pre data-type="programlisting">s/<em>regexp</em>/<em>replacement</em>/</pre>

<p>where <em><code>regexp</code></em> is a regular expression<a data-type="indexterm" data-primary="sed scripts" data-secondary="regular expressions" id="idm46586640451680"/><a data-type="indexterm" data-primary="regular expressions" data-secondary="sed" id="idm46586640450704"/> to match against each input
line (see <a data-type="xref" href="#table_regex">Table 5-1</a>), and <em><code>replacement</code></em><a data-type="indexterm" data-primary="sed scripts" data-secondary="replacement string" id="idm46586640448384"/><a data-type="indexterm" data-primary="strings" data-secondary="sed replacement string" id="idm46586640447440"/> is a string to replace
the matched text. As a simple example, change one word into another:</p>

<pre data-type="programlisting">$ <strong>echo Efficient Windows | sed "s/Windows/Linux/"</strong>
Efficient Linux</pre>
<div data-type="tip"><h6>Tip</h6>
<p>When supplying a sed script on the command line, enclose it in quotes<a data-type="indexterm" data-primary="sed scripts" data-secondary="quoting on command line" id="idm46586640444240"/>
to prevent the shell from evaluating <code>sed</code>’s special
characters. Use single or double quotes as needed.</p>
</div>

<p><code>sed</code> easily solves the “print the celebrity’s last name” problem from
<a data-type="xref" href="#section_rev">“The rev Command”</a> with a regular expression. Just match all characters
(<code>.*</code>) up to the last space and replace them with nothing:</p>

<pre data-type="programlisting">$ <strong>sed 's/.* //' celebrities</strong>
Curtis
Deschanel
Coleman
Rihanna</pre>
<div data-type="tip" id="tip_sed_slash"><h1>Substitution and Slashes</h1>
<p>The forward slashes<a data-type="indexterm" data-primary="sed scripts" data-secondary="substitution script" data-tertiary="alternate separator character" id="idm46586640437584"/><a data-type="indexterm" data-primary="separator" data-secondary="sed scripts" id="idm46586640436240"/><a data-type="indexterm" data-primary="/ (forward slash)" data-secondary="sed operator" id="idm46586640435296"/><a data-type="indexterm" data-primary="forward slash (/)" data-secondary="sed operator" id="idm46586640434352"/>
in a substitution may be replaced by any other
convenient character. This is helpful when a regular expression itself
includes forward slashes (which would otherwise need escaping). These
three sed scripts are equivalent:</p>

<pre data-type="programlisting">s/one/two/	s_one_two_	s@one@two@</pre>
</div>

<p>You may follow a substitution with several options to affect its
behavior. The option <code>i</code><a data-type="indexterm" data-primary="sed scripts" data-secondary="case sensitivity (i option)" id="idm46586640431792"/> makes matches case insensitive:</p>

<pre data-type="programlisting">$ <strong>echo Efficient Stuff | sed "s/stuff/linux/"</strong>         <em>Case sensitive; no match</em>
Efficient Stuff
$ <strong>echo Efficient Stuff | sed "s/stuff/linux/i"</strong>        <em>Case-insensitive match</em>
Efficient linux</pre>

<p>The option <code>g</code><a data-type="indexterm" data-primary="sed scripts" data-secondary="global replacement (g option)" id="idm46586640427328"/> (“global”) replaces all occurrences of the regular
expression instead of just the first one:</p>

<pre data-type="programlisting">$ <strong>echo efficient stuff | sed "s/f/F/"</strong>         <em>Replaces just the first "f"</em>
eFficient stuff
$ <strong>echo efficient stuff | sed "s/f/F/g"</strong>        <em>Replaces all occurrences of "f"</em>
eFFicient stuFF</pre>

<p>Another common type of sed script is a deletion script.<a data-type="indexterm" data-primary="sed scripts" data-secondary="deletion script" id="idm46586640423072"/> It removes lines
by their line number:</p>

<pre data-type="programlisting">$ <strong>seq 10 14 | sed 4d</strong>                 <em>Remove the 4th line</em>
10
11
12
14</pre>

<p>or lines that match a regular expression:</p>

<pre data-type="programlisting">$ <strong>seq 101 200 | sed '/[13579]$/d'</strong>    <em>Delete lines ending in an odd digit</em>
102
104
106
⋮
200</pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Matching subexpressions with sed"><div class="sect3" id="section_sed_subexpressions">
<h3>Matching subexpressions with sed</h3>

<p>Suppose<a data-type="indexterm" data-primary="sed scripts" data-secondary="subexpressions" id="idm46586640416320"/> you have some filenames:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
image.jpg.1  image.jpg.2  image.jpg.3</pre>

<p>and want to produce new names, <em>image1.jpg</em>, <em>image2.jpg</em>, and
<em>image3.jpg</em>.  <code>sed</code> can split the filenames into parts and rearrange
them via a feature called <em>subexpressions</em>. First, create a regular
expression that matches the filenames:</p>

<pre data-type="programlisting">image\.jpg\.[1-3]</pre>

<p>You want to move the final digit earlier in the filename, so isolate
that digit by surrounding it with the symbols <code>\(</code><a data-type="indexterm" data-primary="\(" data-secondary="sed subexpression, defining" id="idm46586640409568"/><a data-type="indexterm" data-primary="backslash (\)" data-secondary="\(" data-tertiary="defining sed subexpression" id="idm46586640408576"/> and <code>\)</code>. This
defines a subexpression—a designated part of a regular
expression:<a data-type="indexterm" data-primary="subexpression" id="idm46586640406800"/><a data-type="indexterm" data-primary="regular expressions" data-secondary="subexpressions (sed)" id="idm46586640406096"/></p>
<pre data-type="programlisting">image\.jpg\.<mark class="box">\(</mark>[1-3]<mark class="box">\)</mark></pre>

<p><code>sed</code> can refer to subexpressions by number and manipulate them. You
created only one subexpression, so its name is <code>\1</code>.<a data-type="indexterm" data-primary="\ (backslash)" data-secondary="sed subexpression, referencing (\1)" id="idm46586640401616"/><a data-type="indexterm" data-primary="backslash (\)" data-secondary="sed subexpression, referencing (\1)" id="idm46586640400640"/>
A second subexpression would be <code>\2</code>, and so on, up to a maximum of
<code>\9</code>. Your new filenames would have the form <code>image\1.jpg</code>.
Therefore, your sed script would be:</p>
<pre data-type="programlisting">$ <strong>ls | sed "s/image\.jpg\.\([1-3]\)/image\1.jpg/"</strong>
image1.jpg
image2.jpg
image3.jpg</pre>

<p>To make things more complicated, suppose the filenames had more
variation, consisting of lowercase words:</p>

<pre data-type="programlisting">$ <strong>ls</strong>
apple.jpg.1  banana.png.2  carrot.jpg.3</pre>

<p>Create three subexpressions to capture the base filename, extension,
and final digit:</p>
<pre data-type="programlisting">\([a-z][a-z]*\)                 <em>\1 = Base filename of one letter or more</em>
\([a-z][a-z][a-z]\)             <em>\2 = File extension of three letters</em>
\([0-9]\)                       <em>\3 = A digit</em></pre>

<p>Connect them with escaped dots (<code>\.</code>) to form this regular expression:</p>
<pre data-type="programlisting"><mark class="box">\([a-z][a-z]*\)</mark>\.<mark class="box">\([a-z][a-z][a-z]\)</mark>\.<mark class="box">\([0-9]\)</mark></pre>

<p>Represent the newly transformed filenames to <code>sed</code> as <code>\1\3.\2</code>,
and the final substitution with <code>sed</code> becomes:</p>
<pre data-type="programlisting">$ <strong>ls | sed "s/\([a-z][a-z]*\)\.\([a-z][a-z][a-z]\)\.\([0-9]\)/\1\3.\2/"</strong>
apple1.jpg
banana2.png
carrot3.jpg</pre>

<p>This command does not rename files—it just prints the new names.
The section <a data-type="xref" href="ch08.xhtml#section_insert_filename_sequence">“Inserting a Filename into a Sequence”</a> shows a similar example that
performs the renaming as well.</p>

<p>To learn <code>sed</code> beyond what can be covered in a few book pages, take a
<code>sed</code> tutorial<a data-type="indexterm" data-primary="sed command" data-secondary="tutorials" id="idm46586640383376"/><a data-type="indexterm" data-primary="tutorials" data-secondary="sed" id="idm46586640382368"/> at
<a href="https://www.tutorialspoint.com/sed" class="orm:hideurl">tutorialspoint.com/sed</a> or
<a href="https://www.grymoire.com/Unix/Sed.html" class="orm:hideurl">grymoire.com/Unix/Sed.html</a> or
search the web for “sed tutorial.”<a data-type="indexterm" data-startref="sed" id="idm46586640379296"/></p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Toward an Even Larger Toolbox"><div class="sect1" id="idm46586640650832">
<h1>Toward an Even Larger Toolbox</h1>

<p><a data-type="indexterm" data-primary="new commands, discovering" id="idm46586640377648"/><a data-type="indexterm" data-primary="discovering new commands" id="idm46586640376976"/><a data-type="indexterm" data-primary="learning new commands" id="idm46586640376288"/><a data-type="indexterm" data-primary="command" data-secondary="discovery of new commands" id="idm46586640375616"/>
Most Linux systems come with thousands of command-line programs, and
most of them have numerous options that change their behavior. You’re
not likely to learn and remember them all. So, in a moment of need,
how do you locate a new program—or tailor a program that you
already know—to accomplish your goals?</p>

<p>Your first (obvious) step is a web search engine. For example, if you
need a command that limits the width of lines in a text file, wrapping
any lines that are too long, search the web for (say) “Linux command
wrap lines” and you’ll be pointed to the <code>fold</code><a data-type="indexterm" data-primary="fold command" id="idm46586640373760"/><a data-type="indexterm" data-primary="limiting line length" id="idm46586640373056"/><a data-type="indexterm" data-primary="wrapping text" id="idm46586640372384"/><a data-type="indexterm" data-primary="text" data-secondary="wrapping" id="idm46586640371712"/> command:</p>

<pre data-type="programlisting">$ <strong>cat title.txt</strong>
This book is titled "Efficient Linux at the Command Line"
$ <strong>fold -w40 title.txt</strong>
This book is titled "Efficient Linux at
the Command Line"</pre>

<p>To discover commands that are already installed on your Linux system,
run the command <code>man -k</code><a data-type="indexterm" data-primary="man command" data-secondary="keyword search (-k option)" id="idm46586640368128"/> (or equivalently, <code>apropos</code>).<a data-type="indexterm" data-primary="apropos command" id="idm46586640366592"/> Given a word,
<code>man -k</code> searches for that word in the brief descriptions at the top
of manpages:</p>

<pre data-type="programlisting">$ <strong>man -k width</strong>
DisplayWidth (3)     - image format functions and macros
DisplayWidthMM (3)   - image format functions and macros
fold (1)             - wrap each input line to fit in specified width
⋮</pre>

<p><code>man -k</code> accepts <code>awk</code>-style regular expressions<a data-type="indexterm" data-primary="regular expressions" data-secondary="man" id="idm46586640362928"/> in search strings (see
<a data-type="xref" href="#table_regex">Table 5-1</a>):</p>

<pre data-type="programlisting">$ <strong>man -k "wide|width"</strong></pre>

<p>A command that’s not installed on your system might still be
installable through your system’s package manager.<a data-type="indexterm" data-primary="package manager" id="idm46586640358752"/><a data-type="indexterm" data-primary="installing new programs" id="idm46586640358048"/><a data-type="indexterm" data-primary="program" data-secondary="installing new" id="idm46586640357376"/> A package manager
is software for installing Linux programs that are supported for your
system. Some popular package managers include <code>apt</code>,<a data-type="indexterm" data-primary="apt package manager" id="idm46586640355776"/> <code>dnf</code>,<a data-type="indexterm" data-primary="dnf package manager" id="idm46586640354496"/> <code>emerge</code>,<a data-type="indexterm" data-primary="emerge package manager" id="idm46586640353216"/>
<code>pacman</code>,<a data-type="indexterm" data-primary="pacman package manager" id="idm46586640351936"/> <code>rpm</code>,<a data-type="indexterm" data-primary="rpm package manager" id="idm46586640350656"/> <code>yum</code>,<a data-type="indexterm" data-primary="yum package manager" id="idm46586640349376"/> and <code>zypper</code>.<a data-type="indexterm" data-primary="zypper package manager" id="idm46586640348096"/> Use the <code>man</code> command to figure
out which package manager is installed on your system and learn how to
search for 
<span class="keep-together">uninstalled</span> packages. Often it’s a two-command sequence:
one command to copy the latest data about available packages
(“metadata”) from the internet onto your system, and another to search the metadata.
For example, for Ubuntu or Debian Linux-based systems, the commands are:</p>

<pre data-type="programlisting">$ <strong>sudo apt update</strong>                   <em>Download the latest metadata</em>
$ <strong>apt-file search <em>string</em></strong>            <em>Search for a string</em></pre>

<p>If, after much searching, you cannot locate or construct an
appropriate command to meet your needs, consider asking for help<a data-type="indexterm" data-primary="help, asking for" id="idm46586640343024"/><a data-type="indexterm" data-primary="Stack Overflow for help" id="idm46586640342320"/> in an
online forum. A great starting point for asking effective questions is Stack Overflow’s <a href="https://oreil.ly/J0jho">“How Do I Ask a Good Question?” help page</a>. In general, present your
questions in a way that is respectful of other people’s time, and
experts will be more inclined to answer. That means making your question
short and to the point, including any error messages or other output
word for word, and explaining what you have tried so far on
your own. Spend quality time to ask a quality question: you’ll not
only increase your chances of a helpful answer, but also, if the forum
is public and searchable, a clear question and answer may aid others
who have a similar problem.</p>
</div></section>













<section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm46586640378496">
<h1>Summary</h1>

<p>You’ve now grown beyond the pint-sized toolbox from
<a data-type="xref" href="ch01.xhtml#ch_combining_commands">Chapter 1</a> and are ready to tackle more challenging
business problems at the command line. The coming chapters are filled
with practical examples of using your new commands in all kinds of
situations.</p>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46586641130912"><sup><a href="ch05.xhtml#idm46586641130912-marker">1</a></sup> The related command <code>ls -R</code><a data-type="indexterm" data-primary="ls command" data-secondary="recursive (-R option)" id="idm46586641130032"/> produces output in a format that’s less convenient for pipelines.</p><p data-type="footnote" id="idm46586641069200"><sup><a href="ch05.xhtml#idm46586641069200-marker">2</a></sup> Nowadays, some implementations of <code>fsck</code> have options <code>-y</code> and <code>-n</code> to respond yes or no, respectively, to every prompt, so the <code>yes</code> command is unnecessary here.</p><p data-type="footnote" id="idm46586641019488"><sup><a href="ch05.xhtml#idm46586641019488-marker">3</a></sup> The name <em>grep</em> is short for “get regular expression and print.”<a data-type="indexterm" data-primary="grep command" data-secondary="meaning of name" id="idm46586641018448"/></p><p data-type="footnote" id="idm46586640664208"><sup><a href="ch05.xhtml#idm46586640664208-marker">4</a></sup> Quiz: what does the pipeline <code>rev myfile | tac | rev | tac</code> do?</p><p data-type="footnote" id="idm46586640655616"><sup><a href="ch05.xhtml#idm46586640655616-marker">5</a></sup> You’ll see simpler solutions with <code>awk</code> and <code>sed</code> shortly, but this double-<code>rev</code> trick is handy to know.</p><p data-type="footnote" id="idm46586640635552"><sup><a href="ch05.xhtml#idm46586640635552-marker">6</a></sup> Including the book <a href="https://oreil.ly/FjtTm" class="orm:hideurl"><em>sed &amp; awk</em></a> from O’Reilly.</p><p data-type="footnote" id="idm46586640622768"><sup><a href="ch05.xhtml#idm46586640622768-marker">7</a></sup> The name <em>awk</em> is an acronym<a data-type="indexterm" data-primary="awk command" data-secondary="meaning of name" id="idm46586640621792"/> for Aho, Weinberger, and Kernighan, the program’s creators.</p><p data-type="footnote" id="idm46586640479648"><sup><a href="ch05.xhtml#idm46586640479648-marker">8</a></sup> The name <em>sed</em> is short for “stream editor,” because it edits a stream of text.</p><p data-type="footnote" id="idm46586640476576"><sup><a href="ch05.xhtml#idm46586640476576-marker">9</a></sup> If you’re familiar with the editors <code>vi</code>, <code>vim</code>,<a data-type="indexterm" data-primary="sed command" data-secondary="vim relationship" id="idm46586640474848"/> <code>ex</code>, or <code>ed</code>, sed script syntax may look familiar.</p></div></div></section></div></body></html>