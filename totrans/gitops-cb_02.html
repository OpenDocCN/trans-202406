<html><head></head><body>
<div id="sbo-rt-content"><section class="pagenumrestart" data-pdf-bookmark="Chapter 1. Introduction" data-type="chapter" epub:type="chapter"><div class="chapter" id="ch_intro">
<h1><span class="label">Chapter 1. </span>Introduction</h1>
<p>With the advent of practices such as infrastructure as code (IaC), software development has pushed the boundaries of platforms where you can run applications. This becomes more frequent with programmable, API-driven platforms such as public clouds and open source infrastructure solutions. While some years ago developers were only focusing on application source code, today they also have the opportunity to code the infrastructure where their application will run. This gives control and enables automation, which significantly reduces lead time.</p>
<p>A good example is with <a data-primary="Kubernetes" data-type="indexterm" id="idm45120859810608"/>Kubernetes, a popular open source container workload orchestration platform and the de facto standard for running production applications, either on public or private clouds. The openness and extensibility of the platform enables automation, which reduces risks of delivery and increases service quality. Furthermore, this powerful paradigm is extended by another increasingly popular approach called GitOps.</p>
<section data-pdf-bookmark="1.1 What Is GitOps?" data-type="sect1"><div class="sect1" id="recipe_1_1">
<h1>1.1 What Is GitOps?</h1>
<p>GitOps is a methodology and practice that uses Git repositories as a single source of truth to deliver infrastructure as code. It takes the pillars and approaches from DevOps culture and provides a framework to start realizing the results. The relationship between DevOps and GitOps is close, as GitOps has become the popular choice to implement and enhance DevOps, platform engineering, and SRE.</p>
<p>GitOps is an agnostic approach, and a GitOps framework can be built with tools such as Git, Kubernetes, and CI/CD solutions. The three main pillars of GitOps are:</p>
<ul>
<li>
<p>Git is the single source of truth</p>
</li>
<li>
<p>Treat everything as code</p>
</li>
<li>
<p>Operations are performed through Git workflows</p>
</li>
</ul>
<p>There is an active community around <a data-primary="GitOps" data-secondary="principles" data-type="indexterm" id="idm45120859721424"/>GitOps, and the <a href="https://oreil.ly/FUbBy">GitOps Working Group</a> defines <a data-primary="GitOps" data-secondary="Working Group" data-type="indexterm" id="idm45120860160912"/><a data-primary="Working Group" data-type="indexterm" id="idm45120860159904"/>a set of GitOps Principles (currently in version 1.0.0) available at <a href="https://opengitops.dev">
<span class="keep-together">OpenGitOps</span></a>:</p>
<dl>
<dt>Declarative</dt>
<dd>
<p>A system managed by GitOps must have its desired state expressed declaratively.</p>
</dd>
<dt>Versioned and immutable</dt>
<dd>
<p>The desired state is stored in a way that enforces immutability and versioning and retains a complete version history.</p>
</dd>
<dt>Pulled automatically</dt>
<dd>
<p>Software agents automatically pull the desired state declarations from the source.</p>
</dd>
<dt>Continuously reconciled</dt>
<dd>
<p>Software agents continuously observe the actual system state and attempt to apply the desired state.</p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="1.2 Why GitOps?" data-type="sect1"><div class="sect1" id="recipe_1_2">
<h1>1.2 Why GitOps?</h1>
<p>Using the common Git-based workflows that developers are familiar with, GitOps expands upon existing processes from application development to deployment, app lifecycle management, and infrastructure configuration.</p>
<p>Every change throughout the application lifecycle is traced in the Git repository and is auditable. This approach is beneficial for both developers and operations teams as it enhances the ability to trace and reproduce issues quickly, improving overall security. One key point is to reduce the risk of unwanted changes (drift) and correct them before they go into production.</p>
<p>Here is a summary of the benefits <a data-primary="GitOps" data-secondary="benefits" data-type="indexterm" id="idm45120858183920"/>of the GitOps adoption in four key aspects:</p>
<dl>
<dt>Standard workflow</dt>
<dd>
<p>Use familiar tools and Git workflows from application development teams</p>
</dd>
<dt>Enhanced security</dt>
<dd>
<p>Review changes beforehand, detect configuration drifts, and take action</p>
</dd>
<dt>Visibility and audit</dt>
<dd>
<p>Capture and trace any change to clusters through Git history</p>
</dd>
<dt>Multicluster consistency</dt>
<dd>
<p>Reliably and consistently configure multiple environments and multiple Kubernetes clusters and deployment</p>
</dd>
</dl>
</div></section>
<section data-pdf-bookmark="1.3 Kubernetes CI/CD" data-type="sect1"><div class="sect1" id="recipe_1_3">
<h1>1.3 Kubernetes CI/CD</h1>
<p>Continuous <a data-primary="Kubernetes" data-secondary="CI/CD (continuous integration/continuous delivery)" data-type="indexterm" id="idm45120859865920"/><a data-primary="CI/CD (continuous integration/continuous delivery)" data-secondary="Kubernetes" data-type="indexterm" id="idm45120859864944"/><a data-primary="continuous integration/continuous delivery (CI/CD)" data-see="CI/CD (continuous integration/continuous delivery)" data-type="indexterm" id="idm45120859864032"/>integration (CI) and continuous delivery (CD) are methods used  to frequently deliver apps by introducing automation into the stages of app development. CI/CD pipelines are one of the most common use cases for GitOps.</p>
<p>In a typical CI/CD pipeline, submitted code checks the CI process while the CD process checks and applies requirements for things like security, infrastructure as code, or any other boundaries set for the application framework. All code changes are tracked, making updates easy while also providing version control should a rollback be needed. CD is the GitOps domain and it works together with the CI part to deploy apps in multiple environments, as you can see in <a data-type="xref" href="#fig1-1">Figure 1-1</a>.</p>
<figure><div class="figure" id="fig1-1">
<img alt="Continuous Integration and Continuous Delivery" height="348" src="assets/gocb_0101.png" width="1411"/>
<h6><span class="label">Figure 1-1. </span>Continuous integration and continuous delivery</h6>
</div></figure>
<p>With Kubernetes, it’s easy to implement an in-cluster CI/CD pipeline. You can have CI software create the container image representing your application and store it in a container image registry. Afterward, a Git workflow such as a pull request can change the Kubernetes manifests illustrating the deployment of your apps and start a CD sync loop, as shown in <a data-type="xref" href="#fig1-2">Figure 1-2</a>.</p>
<figure><div class="figure" id="fig1-2">
<img alt="Application deployment model" height="323" src="assets/gocb_0102.png" width="1096"/>
<h6><span class="label">Figure 1-2. </span>Application deployment model</h6>
</div></figure>
<p>This cookbook will show practical recipes for implementing this model on Kubernetes acting as a CI/CD and GitOps platform.</p>
</div></section>
<section data-pdf-bookmark="1.4 App Deployment with GitOps on Kubernetes" data-type="sect1"><div class="sect1" id="recipe_1_4">
<h1>1.4 App Deployment with GitOps on Kubernetes</h1>
<p>As GitOps is an agnostic, platform-independent approach, the application deployment model<a data-primary="application deployment model" data-type="indexterm" id="app_dep_K"/><a data-primary="Kubernetes" data-secondary="application deployment model" data-type="indexterm" id="K_app_dep"/> on Kubernetes can be either in-cluster or multicluster. An external GitOps tool can use Kubernetes just as a target platform for <a data-primary="applications" data-secondary="deployment" data-type="indexterm" id="apps_dep"/>deploying apps. At the same time, in-cluster approaches run a GitOps engine inside Kubernetes to deploy apps and <a data-primary="manifests" data-secondary="synchronizing" data-type="indexterm" id="idm45120859741376"/>sync manifests in one or more Kubernetes clusters.</p>
<p>The GitOps engine takes care of the CD part of the CI/CD pipeline and accomplishes a GitOps <a data-primary="GitOps" data-secondary="loops" data-type="indexterm" id="idm45120859739808"/><a data-primary="loops, GitOps" data-type="indexterm" id="idm45120859738832"/><a data-primary="Kubernetes" data-secondary="GitOps loops" data-type="indexterm" id="idm45120859738160"/>loop, which is composed of four main actions as shown in <a data-type="xref" href="#fig1-3">Figure 1-3</a>:</p>
<dl>
<dt>Deploy</dt>
<dd>
<p>Deploy the manifests from Git.</p>
</dd>
<dt>Monitor</dt>
<dd>
<p>Monitor either the Git repo or the cluster state.</p>
</dd>
<dt>Detect drift</dt>
<dd>
<p>Detect any change from what is described in Git and what is present in the cluster.</p>
</dd>
<dt>Take action</dt>
<dd>
<p>Perform an action that reflects what is on Git (rollback or three-way diff). Git is the source of truth, and any change is performed via a Git workflow.</p>
</dd>
</dl>
<figure><div class="figure" id="fig1-3">
<img alt="GitOps Loop" height="512" src="assets/gocb_0103.png" width="508"/>
<h6><span class="label">Figure 1-3. </span>GitOps loop</h6>
</div></figure>
<p>In Kubernetes, application deployment using the GitOps approach makes use of at least two Git repositories: one for the app source code, and one for the Kubernetes manifests describing the app’s deployment (Deployment, Service, etc.).</p>
<p><a data-type="xref" href="#fig1-4">Figure 1-4</a> illustrates the structure of a GitOps <a data-primary="projects" data-secondary="structure" data-type="indexterm" id="idm45120859857744"/><a data-primary="Kubernetes" data-secondary="GitOps project structure" data-type="indexterm" id="idm45120859856800"/><a data-primary="GitOps" data-secondary="project structure" data-type="indexterm" id="idm45120859855792"/>project on Kubernetes.</p>
<figure><div class="figure" id="fig1-4">
<img alt="Kubernetes GitOps Loop" height="455" src="assets/gocb_0104.png" width="1257"/>
<h6><span class="label">Figure 1-4. </span>Kubernetes GitOps loop</h6>
</div></figure>
<p>The following list <a data-primary="workflow" data-type="indexterm" id="idm45120859852304"/><a data-primary="GitOps" data-secondary="workflow" data-type="indexterm" id="idm45120859851568"/>outlines the items in the workflow:</p>
<ol>
<li>
<p>App source code repository</p>
</li>
<li>
<p>CI pipeline creating a container image</p>
</li>
<li>
<p>Container image registry</p>
</li>
<li>
<p>Kubernetes manifests repository</p>
</li>
<li>
<p>GitOps engine syncing manifests to one or more clusters and <a data-primary="application deployment model" data-startref="app_dep_K" data-type="indexterm" id="idm45120859845648"/><a data-primary="Kubernetes" data-secondary="application deployment model" data-startref="K_app_dep" data-type="indexterm" id="idm45120859844608"/><a data-primary="applications" data-secondary="deployment" data-startref="apps_dep" data-type="indexterm" id="idm45120859843376"/>detecting drifts</p>
</li>
</ol>
</div></section>
<section data-pdf-bookmark="1.5 DevOps and Agility" data-type="sect1"><div class="sect1" id="recipe_1_5">
<h1>1.5 DevOps and Agility</h1>
<p>GitOps is a developer-centric approach to continuous delivery and infrastructure operations, and a developer workflow through Git for automating processes. As DevOps<a data-primary="DevOps" data-type="indexterm" id="idm45120859839584"/> is complementary to <a data-primary="Agile" data-type="indexterm" id="idm45120859837824"/>Agile software development, GitOps is complementary to DevOps for infrastructure automation and application lifecycle management. As you can see in <a data-type="xref" href="#fig1-5">Figure 1-5</a>, it’s<a data-primary="development cycle" data-type="indexterm" id="dev_cyc"/><a data-primary="GitOps" data-secondary="development cycle" data-type="indexterm" id="Git_DevCyc"/> a developer workflow<a data-primary="workflow" data-secondary="development cycle" data-type="indexterm" id="idm45120859833872"/> for automating operations.</p>
<p>One of the most critical aspects of the Agile methodology is to reduce the <a href="https://oreil.ly/r52pg">lead time</a>, which is described more abstractly as the time elapsed between identifying a requirement and its fulfillment.</p>
<figure><div class="figure" id="fig1-5">
<img alt="GitOps Development Cycle" height="698" src="assets/gocb_0105.png" width="1254"/>
<h6><span class="label">Figure 1-5. </span>GitOps development cycle</h6>
</div></figure>
<p>Reducing this time is fundamental and requires a cultural change in IT organizations. Seeing applications live provides developers with a feedback loop to redesign and improve their code and make their projects thrive. Similarly to DevOps, GitOps also requires a cultural adoption in business processes. Every operation, such as application deployment or infrastructure change, is only possible through Git workflows. And sometimes, this means a cultural shift.</p>
<p>The <a href="https://oreil.ly/gPja9">“Teaching Elephants to Dance (and Fly!)”</a> <a data-primary="&quot;Teaching Elephants to Dance (and Fly!)&quot;" data-primary-sortas="Teaching Elephants to Dance (and Fly!)" data-type="indexterm" id="idm45120859828032"/><a data-primary="Sutter, Burr, &quot;Teaching Elephants to Dance (and Fly!)&quot;" data-type="indexterm" id="idm45120859826960"/>speech from Burr Sutter gives a clear idea of the context. The elephant is where your organization is today. There are phases of change between traditional and modern environments powered by GitOps tools. Some organizations have the luxury of starting from scratch, but for many businesses, the challenge is teaching their lumbering elephant to dance like a graceful ballerina<a data-primary="development cycle" data-startref="dev_cyc" data-type="indexterm" id="idm45120859826128"/><a data-primary="GitOps" data-secondary="development cycle" data-startref="Git_DevCyc" data-type="indexterm" id="idm45120859825184"/>.</p>
</div></section>
</div></section></div></body></html>