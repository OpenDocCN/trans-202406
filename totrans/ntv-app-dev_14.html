<html><head></head><body><section data-pdf-bookmark="Chapter 13. Extensions" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_extnensions">&#13;
<h1><span class="label">Chapter 13. </span>Extensions</h1>&#13;
&#13;
&#13;
<p>Sometimes the functionality provided by Android and iOS just isn’t enough, and sometimes the functionality provided by third-party libraries or internal objects just doesn’t make the cut. Sure, you can subclass, but it’s not always feasible for that to work properly.</p>&#13;
&#13;
<p>Fortunately, both platforms have a means to augment existing objects.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177216917208">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="extensions" data-secondary="task overview" data-type="indexterm" id="idm46177216915880"/> this chapter, you’ll learn to add functionality to existing APIs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177216914488">&#13;
<h1>Android</h1>&#13;
&#13;
<p>While<a data-primary="extensions" data-secondary="Android" data-type="indexterm" id="EXand13"/><a data-primary="Android" data-secondary="extensions" data-type="indexterm" id="Aext13"/><a data-primary="Kotlin" data-secondary="extensions" data-type="indexterm" id="Kext12"/> we have spent the majority of this book defaulting to Java as the language for Android development, and indeed the great majority of Android development does happen in Java, we must now mention that in the Android Framework, <em>only Kotlin is capable of supporting extensions</em>. What does that mean? Let’s define the word “extension” to mean “alter or add functionality to any class.” However, Java classes in a project with Kotlin extensions <em>can</em> take advantage of the extended <span class="keep-together">functionality</span>!</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Add Functionality to Existing APIs" data-type="sect2"><div class="sect2" id="idm46177216907240">&#13;
<h2>Add Functionality to Existing APIs</h2>&#13;
&#13;
<p>In Java, if you import a third-party library for <code>CalendarPicker</code>, you’re pretty much stuck with whatever public API that library provides. Of course, you can alter the source, but at that point you’ve created your own <code>CalendarPicker</code>, which will not be an instance of the same class as the original. You could also subclass <code>CalendarPicker</code>, but the same caveat applies. It is not possible to add or change the existing functionality of the existing <code>CalendarPicker</code> API.</p>&#13;
&#13;
<p>In Kotlin, this is no longer true. Not only could you add a method to <code>CalendarPicker</code> that <em>all</em> instances of <code>CalendarPicker</code> would have access to, you could in fact add methods to standard library classes like <code>LinkedList</code>, or even classes with generic typing like <code>HashSet&lt;String&gt;</code>. In fact, there’s even an <code>Any</code> class in Kotlin that can be extended to add functionality to all class instances. The classic example of Kotlin extensions does this very thing:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">Any</code><code class="o">?.</code><code class="n">toString</code><code class="p">():</code> <code class="n">String</code> <code class="p">{</code>&#13;
    <code class="k">if</code> <code class="p">(</code><code class="k">this</code> <code class="p">==</code> <code class="k">null</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">return</code> <code class="s">"null"</code>&#13;
    <code class="p">}</code>&#13;
    <code class="k">return</code> <code class="n">toString</code><code class="p">()</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This<a data-primary="? (null-safety) operator" data-type="indexterm" id="idm46177216891736"/> adds Kotlin’s <code>?</code> null-safety operator to the <em>body</em> of the common <code>Object.toString</code> method. By adding the preceding code, you can safely call <code>toString</code> on any object; if the object is <code>null</code>, instead of a <code>NullPointerException</code>, you’ll just get back the string <code>"null"</code>. Pretty intense!</p>&#13;
&#13;
<p>You can add your extensions anywhere, in any package or directory structure you like (as long as it’s a Kotlin file, in a <em>src</em> directory). For example, right-click any package in your project, select New &gt; Kotlin File/Class, and give any name—let’s say “extensions” for now<a data-primary="Android Studio" data-secondary="extensions and" data-type="indexterm" id="idm46177216839112"/> (Android Studio will append the “.kt” extension and show a different icon indicating it’s a Kotlin file).</p>&#13;
&#13;
<p>You could add a number of extension functions to this file, or any number of files, and all would be accessible from any Kotlin class in your project. Let’s say you added the following <code>String</code> helper:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">fun</code> <code class="nf">String</code><code class="p">.</code><code class="n">from</code><code class="p">(</code><code class="n">start</code><code class="p">:</code><code class="n">String</code><code class="p">):</code> <code class="n">String</code> <code class="p">{</code>&#13;
  <code class="k">val</code> <code class="py">index</code> <code class="p">=</code> <code class="n">indexOf</code><code class="p">(</code><code class="n">start</code><code class="p">)</code> <code class="p">+</code> <code class="n">start</code><code class="p">.</code><code class="n">length</code>&#13;
  <code class="k">return</code> <code class="n">substring</code><code class="p">(</code><code class="n">index</code><code class="p">)</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Then in some Kotlin class, you could call something like this and get the expected results:</p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">original</code> <code class="p">=</code> <code class="s">"Hello world!"</code>&#13;
<code class="k">val</code> <code class="py">modified</code> <code class="p">=</code> <code class="n">original</code><code class="p">.</code><code class="n">from</code><code class="p">(</code><code class="s">"Hello"</code><code class="p">)</code>&#13;
<code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="n">modified</code><code class="p">)</code></pre>&#13;
&#13;
<p>See <a href="https://oreil.ly/oGVHb">the developer docs</a> for more information on Kotlin extensions.</p>&#13;
<aside class="less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177216768504">&#13;
<h5>Kotlin Extensions Under the Covers</h5>&#13;
<p>Note that while Kotlin extensions are pretty cool and do keep everything object-oriented, the truth is they’re just syntactic sugar. You can do anything you can do with extensions using helper classes or traditional methods—just pass in the instance as a parameter.</p>&#13;
&#13;
<p>For example:</p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">Strings</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">toString</code><code class="o">(</code><code class="n">Object</code> <code class="n">object</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">if</code> <code class="o">(</code><code class="n">object</code> <code class="o">==</code> <code class="kc">null</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="k">return</code> <code class="s">"null"</code><code class="o">;</code>&#13;
    <code class="o">}</code>&#13;
    <code class="k">return</code> <code class="n">object</code><code class="o">.</code><code class="na">toString</code><code class="o">();</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="kd">static</code> <code class="n">String</code> <code class="nf">from</code><code class="o">(</code><code class="n">String</code> <code class="n">source</code><code class="o">,</code> <code class="n">String</code> <code class="n">start</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kt">int</code> <code class="n">index</code> <code class="o">=</code> <code class="n">source</code><code class="o">.</code><code class="na">indexOf</code><code class="o">(</code><code class="n">start</code><code class="o">)</code> <code class="o">+</code> <code class="n">start</code><code class="o">.</code><code class="na">length</code><code class="o">();</code>&#13;
    <code class="k">return</code> <code class="n">source</code><code class="o">.</code><code class="na">substring</code><code class="o">(</code><code class="n">index</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Line count is pretty much the same, and functionality is identical. You’re just choosing between having an object call a method, <code>myString.from("bob")</code>, or the more procedural <code>Strings.from(myString, "bob");</code>. In fact, many people would consider the latter to be superior; it’s not affected by state, so it is easy to test and package. That said, object-oriented programming versus functional programming is a conversation for another day.<a data-primary="" data-startref="Kext12" data-type="indexterm" id="idm46177216726664"/><a data-primary="" data-startref="EXand13" data-type="indexterm" id="idm46177216621944"/><a data-primary="" data-startref="Aext13" data-type="indexterm" id="idm46177216621000"/></p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177216619928">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>One<a data-primary="extensions" data-secondary="iOS" data-type="indexterm" id="EXios13"/><a data-primary="iOS" data-secondary="extensions" data-type="indexterm" id="IOSext13"/> of the core language features of Swift is the ability to add new functionality to types with extensions. In fact, this is a major part of the<a data-primary="Objective-C" data-type="indexterm" id="idm46177216615848"/> Objective-C language runtime as well, albeit by the name of “category” instead of “extension.” This capability is well baked into Swift and, in fact, very common in practice.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Add Functionality to Existing APIs" data-type="sect2"><div class="sect2" id="idm46177216614728">&#13;
<h2>Add Functionality to Existing APIs</h2>&#13;
&#13;
<p>Here’s a simple example:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ExtendableObect</code> <code class="p">{</code>&#13;
    <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">extension</code> <code class="nc">ExtendableObect</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">helloTacos</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="s">"Hello, tacos!"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>First, we define a class called <code>ExtendableObject</code>. In our example, the class doesn’t have a body because it’s not important to the example. The real heart of the example is in the next section where we define the extension.</p>&#13;
&#13;
<p>Our extension is declared on the <code>ExtendableObject</code> using <code>extension ExtendableObject { ... }</code>. Within that definition, we declare and define a new method called <code>helloTacos()</code> that, conveniently, prints the string <code>Hello, tacos!</code> to the console. We use our newly defined method by instantiating the object and calling <code>helloTacos()</code> as you would any other method on the object, like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">object</code> <code class="p">=</code> <code class="n">ExtendableObject</code><code class="p">()</code>&#13;
<code class="n">object</code><code class="p">.</code><code class="n">helloTacos</code><code class="p">()</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>One huge, important thing to note. You can add new methods and functions to existing object types, but it’s not possible to add new stored properties without importing the Objective-C runtime and using associated values. It’s generally not recommended except for very rare circumstances.</p>&#13;
</div>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extensions for code organization" data-type="sect3"><div class="sect3" id="idm46177216588200">&#13;
<h3>Extensions for code organization</h3>&#13;
&#13;
<p>Because extensions are such an integral part of the Swift language, it’s become common practice in Swift projects to use extensions to organize code throughout a project. Often, you’ll see implementation of protocols stuffed inside an extension at the bottom of a class.</p>&#13;
&#13;
<p>Here’s an example:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">protocol</code> <code class="nc">AwesomeProtocol</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">beAwesome</code><code class="p">()</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">ExtendableObect</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="kd">extension</code> <code class="nc">ExtendableObect</code><code class="p">:</code> <code class="n">AwesomeProtocol</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">beAwesome</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="s">"You are awesome!"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>First, we declare a new protocol called <code>AwesomeProtocol</code> with the required method <code>beAwesome()</code>. Next, we declare <code>ExtendableObject</code>. It’s possible to directly implement the protocol by declaring it as part of the definition of <code>ExtendableObject</code> like so:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">ExtendableObject</code><code class="p">:</code> <code class="n">AwesomeProtocol</code> <code class="p">{</code> <code class="cm">/*  ... */</code><code class="p">}</code></pre>&#13;
&#13;
<p>However, because of the protocol-oriented nature of Swift, this can become unwieldy and not easy to maintain as the number of protocols an object must implement grows as the complexity of the application grows. Our previous example, with the extension split off separately, allows us to lump the protocol conformance together and make it easier to find and maintain in the future.</p>&#13;
&#13;
<p>This is entirely a subjective way to organize code, but it’s something of a de facto standard in the Swift community. Feel free to use or not use!</p>&#13;
&#13;
<p>Speaking of protocols in Swift—it’s possible to extend those too! Let’s take a look.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extending protocols" data-type="sect3"><div class="sect3" id="idm46177216470136">&#13;
<h3>Extending protocols</h3>&#13;
&#13;
<p>Extending classes and structures in Swift is slightly different than extending protocols. The syntax is similar, but the mechanism behind it is different. Here’s how to extend a protocol in Swift:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">protocol</code> <code class="nc">ExtandableProtocol</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">doSomething</code><code class="p">()</code>&#13;
<code class="p">}</code>&#13;
<code class="kd">extension</code> <code class="nc">ExtendableProtocol</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">printSomething</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="s">"Something :)"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">SomeObject</code><code class="p">:</code> <code class="n">ExtendableProtocol</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">doSomething</code><code class="p">()</code> <code class="p">{</code>&#13;
		<code class="c1">// ...</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The protocol we’re extending is not an Objective-C protocol written in Swift—it’s a pure Swift object. That’s important because only pure Swift protocols can be extended. It’s also not possible to extend methods prefixed with <code>@objc</code>.</p>&#13;
</div>&#13;
&#13;
<p>This example creates a protocol, named <code>ExtendableProtocol</code>, with a <code>doSomething()</code> method declared as part of the protocol. Next, the extension added to the protocol adds a new <code>printSomething</code> method that is declared and defined as part of the extension. Finally, the class <code>SomeObject</code> is defined to implement the <code>ExtendableProtocol</code> protocol.</p>&#13;
&#13;
<p>Calling an instance of <code>SomeObject</code> might look like this:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">object</code> <code class="p">=</code> <code class="n">SomeObject</code><code class="p">()</code>&#13;
<code class="n">object</code><code class="p">.</code><code class="n">doSomething</code><code class="p">()</code>&#13;
<code class="n">object</code><code class="p">.</code><code class="n">printSomething</code><code class="p">()</code></pre>&#13;
&#13;
<p>Pretty simple and not too far removed from class and structure extensions, right?</p>&#13;
&#13;
<p>Where the power of protocol extensions becomes apparent is when you need common functionality across objects that do not inherit from the same base class. Take a look at this example:</p>&#13;
&#13;
<pre data-code-language="swift" data-type="programlisting"><code class="kd">protocol</code> <code class="nc">Typeable</code> <code class="p">{</code> <code class="cm">/* ... */</code> <code class="p">}</code>&#13;
<code class="kd">extension</code> <code class="nc">Typeable</code> <code class="p">{</code>&#13;
    <code class="kd">func</code> <code class="nf">printType</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kd">let</code> <code class="nv">objectType</code> <code class="p">=</code> <code class="nb">String</code><code class="p">(</code><code class="n">describing</code><code class="p">:</code> <code class="n">type</code><code class="p">(</code><code class="n">of</code><code class="p">:</code> <code class="kc">self</code><code class="p">))</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="s">"This object is a type of </code><code class="si">\(</code><code class="n">objectType</code><code class="si">)</code><code class="s">"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">BaseClassA</code> <code class="p">{</code> <code class="p">}</code>&#13;
<code class="kd">class</code> <code class="nc">BaseClassB</code> <code class="p">{</code> <code class="p">}</code>&#13;
<code class="kd">class</code> <code class="nc">BaseClassC</code> <code class="p">{</code> <code class="p">}</code>&#13;
&#13;
<code class="kd">class</code> <code class="nc">TacoTruck</code><code class="p">:</code> <code class="n">BaseClassA</code><code class="p">,</code> <code class="n">Typeable</code> <code class="p">{</code> <code class="p">}</code>&#13;
<code class="kd">class</code> <code class="nc">Dog</code><code class="p">:</code> <code class="n">BaseClassB</code><code class="p">,</code> <code class="n">Typeable</code> <code class="p">{</code> <code class="p">}</code>&#13;
<code class="kd">class</code> <code class="nc">Cat</code><code class="p">:</code> <code class="n">BaseClassC</code><code class="p">,</code> <code class="n">Typeable</code> <code class="p">{</code> <code class="p">}</code>&#13;
&#13;
<code class="kd">let</code> <code class="nv">tacoTruck</code> <code class="p">=</code> <code class="n">TacoTruck</code><code class="p">()</code>&#13;
<code class="kd">let</code> <code class="nv">dog</code> <code class="p">=</code> <code class="n">Dog</code><code class="p">()</code>&#13;
<code class="kd">let</code> <code class="nv">cat</code> <code class="p">=</code> <code class="n">Cat</code><code class="p">()</code>&#13;
&#13;
<code class="n">tacoTruck</code><code class="p">.</code><code class="n">printType</code><code class="p">()</code>&#13;
<code class="n">dog</code><code class="p">.</code><code class="n">printType</code><code class="p">()</code>&#13;
<code class="n">cat</code><code class="p">.</code><code class="n">printType</code><code class="p">()</code></pre>&#13;
&#13;
<p>First, we declare a protocol, <code>Typeable</code>, and an extension on that protocol, which outputs an object’s type. Next, declare three base classes that are totally different objects and not related in any way. Then, we declare three more child objects that each inherit from a different parent class, but that all implement our protocol from before: <code>Typeable</code>. After that, we instantiate each class. Finally, we call the same method, <code>printType</code>, that was declared in one place, but that functions exactly the same for each discrete and separate object.</p>&#13;
&#13;
<p>Protocol extensions are a powerful addition to Swift that has enabled cleaner code, with a better, more maintainable, architecture.<a data-primary="" data-startref="IOSext13" data-type="indexterm" id="idm46177216349128"/><a data-primary="" data-startref="EXios13" data-type="indexterm" id="idm46177216192936"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177216191864">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>Adding functionality isn’t easily possible with Java, but Kotlin and Swift both provide built-in mechanisms for extending existing objects. There are limitations in both approaches, but there is a definite use case for the capability enabled by both languages and platforms.</p>&#13;
&#13;
<p>In our final chapter on tasks, we turn our attention not toward building, but toward maintaining what we’ve already built through testing. Both platforms have excellent tooling around testing. Let’s dive in to see what’s available!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>