- en: Chapter 16\. Writing Web Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While JavaScript was once used to add simple interactivity to web pages, today
    it can be used to build complicated and fully featured software applications that
    run in a web browser. The possibilities include mapping, email clients, streaming
    video sites, real-time chat applications, and much more. The line between “website”
    and “application” can be fuzzy, but one way to think about it is that an application
    is any site that takes user input and returns something as a result.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you can develop these applications and deploy them instantly
    across the world, but this ability comes with unique challenges. As an application
    code base grows, you will need to split your codebase into smaller modules and
    ensure that users are receiving optimized code bundles. You will need to create
    features and experiences that compete with those of native mobile applications,
    such as offline functionality, notifications, and application icons. Thankfully,
    modern JavaScript and browser APIs enable these feature-rich experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to make use of JavaScript modules in a browser environment.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make use of native JavaScript modules or a bundling tool, such as [Webpack](https://webpack.js.org).
  prefs: []
  type: TYPE_NORMAL
- en: 'Native JavaScript is supported in [all modern browsers](https://oreil.ly/FhPq9).
    If we have a simple module that exports a value, named `mod.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'we can use the module natively in an HTML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'For more advanced applications and sites, you may benefit from using a bundling
    tool that can optimize your modules. To use Webpack as a bundling tool, first
    install its dependencies with npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Before you are able to install packages from npm, your project will need a *package.json*
    file. To generate this file, make sure you are in the root of your project’s directory
    and type `npm init`. The command-line interface will then guide you through a
    series of prompts. Additional information about installing and using npm is in
    [Chapter 1](ch01.html#ch01).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then create a file named *webpack.config.js* in the root of the project
    directory, where we specify the entry file and output directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add a script to the *package.json* to run the Webpack build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript modules are now widely available and supported by browsers. This
    allows us to break our code into smaller, more maintainble pieces.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack is a popular tool for compiling JavaScript modules. The power of Webpack
    lies in the configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous configuration file, we are instructing Webpack to look at the
    *src* directory for a file named *index.js*. This file will be the entry file
    for our project’s JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The *index.js* file is importing two additional files, *foo.js* and *bar.js*.
  prefs: []
  type: TYPE_NORMAL
- en: When the `build` script is run, Webpack will output a new minified file named
    *bundle.js* in the *dist* directory.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling simple import statements is only the tip of the iceberg. Webpack can
    be used for hot module reloading, code splitting, browser support shims, and even
    as a development server. In [“JavaScript and the Mobile Web”](#mobile-web), we’ll
    explore how Webpack can be used to reduce the size of a JavaScript bundle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Using npm Modules'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to using your own modules, Webpack enables you to download and
    utilize modules directly from [npm](https://www.npmjs.com). To do so, first install
    the module and save it as a dependency to the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then require the module directly in your code, without needing to specify
    the path to the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript and the Mobile Web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your website or application makes use of JavaScript, which can noticeably increase
    the time to load on mobile and slow connections.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For sites using a small amount of JavaScript in a single file, use a tool such
    as [UglifyJS](https://github.com/mishoo/UglifyJS) to minify your JavaScript. Minification
    will reduce the size of a JavaScript file by removing unnecessary characters (such
    as whitespace).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use UglifyJS, first install it with npm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add a script to your *package.json* file, specifying the input JavaScript
    file and a name for the minified file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For larger sites and applications with multiple JavaScript files, use a bundling
    tool, such as [Webpack](https://webpack.js.org), to perform a combination of minification,
    code splitting, tree shaking, and lazy loading.
  prefs: []
  type: TYPE_NORMAL
- en: Webpack automatically minifies its output in production mode, meaning that no
    specific configuration or minification tool is needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Code splitting is the process of generating multiple bundles, so that HTML
    pages or templates only load the code they need. The following *webpack.config.js*
    file will output two JavaScript files (*index.bundle.js* and *secondary.bundle.js*)
    to the *dist* directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Bundles can balloon in size, particularly when importing third-party libraries
    with functionality that may not be needed. *Tree shaking* is the concept of eliminating
    dead or unused code. Webpack can be configured to eliminate dead code with the
    `optimization` setting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The final step for code splitting is to add a `sideEffects` field to the project’s
    *package.json* file. According to the Webpack documentation, “a *side effect*
    is defined as code that performs a special behavior when imported, other than
    exposing one or more exports.” An example of a side effect would be a global polyfill,
    which does not expose any `export` statements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If no such file is present, we can set the following in *package.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If your project does have JavaScript files that would fall under the “side
    effect” category, we can provide them as an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can utilize Webpack to enable the lazy loading of JavaScript modules,
    only loading them when they are needed by a browser interaction. Webpack makes
    this straightforward with a dynamic `import` statements. With a file named *button.js*
    in the *src* directory, the contents of the file can be loaded when a user clicks
    a button. In *index.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fastest JavaScript is no JavaScript; however, the interactive demands of
    modern web applications often rely on client-side JavaScript. With that in mind,
    our goal is to limit the amount and file size of the JavaScript being downloaded
    by a user’s browser. Utilizing strategies such as minification, code splitting,
    tree shaking, and lazy loading allows you finer control over size and amount of
    JavaScript being loaded in a user’s browser.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Webpack’s [Getting Started guide](https://oreil.ly/TAnYG) is a useful introduction
    to code bundling and Webpack configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a Progressive Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’d like your web application to take advantage of native application features
    such as fast load times, offline functionality, and app launching icons.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Turn your web application into a Progressive Web Application (PWA). The phrase
    “Progressive Web Applications” was coined to describe a set of technologies that,
    when combined, enable web applications to use native-like features, such as offline
    functionality and user-installed app icons, while being built with standard web
    technologies and deployed to the web.
  prefs: []
  type: TYPE_NORMAL
- en: 'All PWAs are required to include two features that extend beyond that of a
    typical web page:'
  prefs: []
  type: TYPE_NORMAL
- en: Application manifest
  prefs: []
  type: TYPE_NORMAL
- en: Defines application specific features for the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Service worker
  prefs: []
  type: TYPE_NORMAL
- en: Enables the application’s offline functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in creating a progressive web application is to add the web
    app manifest file. This file enables developers to control things like application
    icons, splash screens, browser display style, and view orientation. In a file
    named *manifest.json*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, in your HTML files or templates, add a reference to the manifest file and
    appropriate application icons in the document’s `<head>`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-1\. PWA Metatags
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The PWA install prompt is automatically triggered in Chrome when a website meets
    the PWA criteria (see [Figure 16-1](#manifest_chrome)). Once installed, the PWA’s
    icon appears on the user’s device, much like a native application ([Figure 16-2](#ios_app)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of the install prompt in Chrome](assets/jsc3_1601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-1\. PWA install prompt
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![A screenshot of the app icon on a mobile device](assets/jsc3_1602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-2\. The application can be saved to a mobile device
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The second step is to create a service worker. A service worker is a script
    that runs separately from the page, providing us with a way to make our sites
    work offline, run faster, and add capabilities for background features. With the
    limits of mobile connectivity, service workers provide us with a means to build
    offline-first capable applications, which will load content for our users after
    an initial site visit, regardless of network conditions. Best of all, service
    workers are truly a progressive enhancement, layering on an additional feature
    to supporting browsers without changing the functionality of our site for users
    of nonsupporting browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'When introducing a service worker, the initial step is to register the script
    that will contain our service worker code with the user’s browser. To accomplish
    this, add the script registration to the bottom of the page just before the closing
    `</body>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This script checks for service worker support, and if the support is available,
    points the browser to a service worker script (in this case *service-worker.js*).
    For debugging purposes, the script also catches errors and logs them to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *service-worker.js*, begin by specifying a cache version and listing the
    files that the browser should cache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For changes to the site, the `cacheVersion` needs to be updated, or users risk
    being served content from the cache.
  prefs: []
  type: TYPE_NORMAL
- en: Now, in the *service-worker.js* file, set up the `install`, `fetch`, and `activate`
    event listeners. The `install` event provides the browser with instructions for
    installing our cached files. The `fetch` event provides the browser with guidelines
    for handling fetch events by instructing the browser to either load the cached
    files or those received over the network. Finally, the `activate` event, which
    fires when the service worker is activated, can be used to check for existing
    items in the cache and remove them if an updated `cacheVersion` is present and
    the file is no longer in the `filestoCache` list (see [Figure 16-3](#offline)).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '![A screenshot of the application running in offline mode](assets/jsc3_1603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-3\. With the service worker installed, the application can load files
    when offline
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A Progressive Web Application is a user-installable web application with some
    form of offline functionality. These features allow web applications to closely
    mimic the best features of native applications while providing the benefits of
    the open web.
  prefs: []
  type: TYPE_NORMAL
- en: 'The web app manifest is a JSON file that provides information about the application.
    The full list of key values that it can contain are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`background_color`'
  prefs: []
  type: TYPE_NORMAL
- en: A color code for a placeholder launch screen background.
  prefs: []
  type: TYPE_NORMAL
- en: '`categories`'
  prefs: []
  type: TYPE_NORMAL
- en: An array of strings of categories that the application belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: '`description`'
  prefs: []
  type: TYPE_NORMAL
- en: A string description of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`dir`'
  prefs: []
  type: TYPE_NORMAL
- en: The direction in which to display characters. This can be `auto`, `ltr` (left
    to right), or `rtl` (right to left).
  prefs: []
  type: TYPE_NORMAL
- en: '`display`'
  prefs: []
  type: TYPE_NORMAL
- en: The preferred display mode. This can be either `browser`, for default browser
    behavior, or `fullscreen`, which will reduce the browser chrome on some devices.
  prefs: []
  type: TYPE_NORMAL
- en: '`iarc_rating_id`'
  prefs: []
  type: TYPE_NORMAL
- en: An International Age Rating value.
  prefs: []
  type: TYPE_NORMAL
- en: '`icons`'
  prefs: []
  type: TYPE_NORMAL
- en: An array of objects linking to icon images and descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: '`lang`'
  prefs: []
  type: TYPE_NORMAL
- en: Identifies the primary language of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs: []
  type: TYPE_NORMAL
- en: The application name.
  prefs: []
  type: TYPE_NORMAL
- en: '`orientation`'
  prefs: []
  type: TYPE_NORMAL
- en: Allows the developer to set the default orientation of the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`prefer_related_applications`'
  prefs: []
  type: TYPE_NORMAL
- en: If set to `true`, allows the developer to specify related applications that
    should be installed instead of the web application.
  prefs: []
  type: TYPE_NORMAL
- en: '`related_applications`'
  prefs: []
  type: TYPE_NORMAL
- en: An array of objects containing a list of related native applications.
  prefs: []
  type: TYPE_NORMAL
- en: '`scope`'
  prefs: []
  type: TYPE_NORMAL
- en: A string that contains the navigation scope of the app. Specifying a scope restricts
    navigation in application mode to that directory.
  prefs: []
  type: TYPE_NORMAL
- en: '`screenshots`'
  prefs: []
  type: TYPE_NORMAL
- en: An array of application screenshots.
  prefs: []
  type: TYPE_NORMAL
- en: '`short_name`'
  prefs: []
  type: TYPE_NORMAL
- en: A shortened version of the application name to be used in contexts where the
    full name is too long to display.
  prefs: []
  type: TYPE_NORMAL
- en: '`start_url`'
  prefs: []
  type: TYPE_NORMAL
- en: The URL that should open when a user launches the application.
  prefs: []
  type: TYPE_NORMAL
- en: '`theme_color`'
  prefs: []
  type: TYPE_NORMAL
- en: A string that defines the default theme color for the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [W3C provides an example](https://oreil.ly/zlk9P) of a robust manifest
    file for a web-based game:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the web app manifest file, some platforms, such as iOS and Windows,
    require additional information which can be provided in the form of HTML metatags.
    In [Example 16-1](#pws_meta_tags), metatags are used to define a theme color,
    the iOS icon, and Windows tile settings.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Generating icons for all of the different device types and resolutions can be
    a tedious affair, so I recommend using [RealFaviconGenerator](https://oreil.ly/ALsQe).
  prefs: []
  type: TYPE_NORMAL
- en: A service worker is a script that the browser runs in the background, parallel
    to the rendering and execution of the page. Because it is a “worker,” the service
    worker cannot access the DOM directly, however this parallel script enables all
    sorts of new use cases. One of the most exciting of these use cases is the ability
    to cache bits of our application for offline use. In the above example, I’m caching
    an HTML, JavaScript, and CSS file to provide a full-featured (if minimal) site
    experience when offline. Other use cases may include creating a separate offline
    experience or caching the shared template markup and styles, often referred to
    as the “application shell.”
  prefs: []
  type: TYPE_NORMAL
- en: 'When utilizing service workers, there are a few limitations to be aware of:'
  prefs: []
  type: TYPE_NORMAL
- en: Sites using a service worker must be served over HTTPS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service workers do not work when a user is in private browsing mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since service workers run as a separate thread in the browser, they do not have
    access to the DOM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service workers are scoped, meaning that they should be placed in the root of
    your application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cache storage sizes can vary by browser and available space on a user’s hard
    drive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Though I’ve created a service worker by hand in the above example, that can
    quickly become unmanageable for larger applications. The [Workbox](https://oreil.ly/Gu3Z6)
    library, created by Google, is a package for managing service workers and offline
    functionality in web applications. Workbox takes much of the pain out of versioning
    and managing the cache, as well as advanced capabilities such as background sync
    and precaching.
  prefs: []
  type: TYPE_NORMAL
- en: Progressive web applications are an exciting step for the web and are framework
    agnostic, meaning they can be built with simple HTML, CSS, and JavaScript, or
    using the latest JavaScript frameworks. In this section we have only scratched
    the surface of the power of these technologies. Tal Alter’s book [*Building Progressive
    Web Apps*](http://shop.oreilly.com/product/0636920052067.do) (O’Reilly) offers
    a detailed look at the features and functionality of Progressive Web Applications.
  prefs: []
  type: TYPE_NORMAL
- en: Testing and Profiling a Progressive Web Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’d like to test that you’ve successfully fulfilled the requirements of a
    Progressive Web Application.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use [Lighthouse](https://oreil.ly/hEdHB) to audit performance, accessibility,
    best practices, SEO, and Progressive Web Application criteria. The easiest way
    to access Lighthouse is within the “Lighthouse” tab of Google Chrome Developer
    Tools. Visit the site (either in production or on a local web server) and click
    “Generate Report” (see [Figure 16-4](#lighthouse-pwa)).
  prefs: []
  type: TYPE_NORMAL
- en: Lighthouse will then generate a report, making recommended improvements for
    any score reductions (see Figures [16-5](#lighthouse_high) and [16-6](#lighthouse_low)).
  prefs: []
  type: TYPE_NORMAL
- en: '![A sreenshot of Google Lighthouse](assets/jsc3_1604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-4\. Lighthouse within Chrome Developer Tools
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![A screenshot of a site with a high Lighthouse score](assets/jsc3_1605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-5\. A high score demonstrates a performant application and successful
    progressive web app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '![A screenshot of a site with a low Lighthouse score](assets/jsc3_1606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-6\. A site receiving a low Lighthouse score will also receive recommendations
    for improvement
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The general use of profiling non-Progressive Web Application sites with Lighthouse
    in the Chrome Developer Tools is covered in more detail in [“Using Lighthouse
    to Measure Best Practices”](ch11.html#lighthouse).
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Lighthouse is a tool for measuring web best practices, including performance
    and progressive web application compatibility. It comes built into the Chrome
    Developer Tools, but can also be installed as a Firefox extension.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to being a browser tool, Lighthouse can be installed through npm
    and used on the command line or as a Node module. You would install Lighthouse
    the same as any other Node module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'which can then be run by passing a URL as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Passing a `--view` argument will open the results in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify an output filetype and location to store the report results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'And a *budget.json* file can be used to set and test against performance budget
    limitations. In a *budget.json* file, define the limitations to test against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Google Chrome team mantains a [repository](https://github.com/GoogleChrome/budget.json)
    containing the documentation of *budget.json* options.
  prefs: []
  type: TYPE_NORMAL
- en: Testing locally from the command line can be helpful for local development,
    but the real power of Lighthouse as a code module is realized when used with continuous
    integration tools such as GitHub Actions, Circle CI, Jenkins, and Travis CI. The
    [Lighthouse CI](https://github.com/GoogleChrome/lighthouse-ci) module enables
    you to perform Lighthouse testing in a continuous integration pipeline, such as
    on every GitHub pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample configuration for CircleCI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Full details on how to use Lighthouse in multiple CI environments are available
    in Google’s [Getting Started guide](https://oreil.ly/7jnwx).
  prefs: []
  type: TYPE_NORMAL
- en: Getting the Value of the Current URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your application needs to read the value of the current URL.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `href` property of `window.location` to read the current value of the
    full URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`window.location` provides read-only information about the current URL or *location*
    of the document. The `href` property provides the full URL, which includes the
    protocol (such as HTTPS), hostname, the path to the current document, and any
    query strings. All together, this will match what is displayed in the user’s URL
    bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The global variable `location` is the same as `window.location`; however, I
    prefer the explicitness of using the `window` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `href` property is not the only useful one. If you already know that the
    user is on your site, it may be more useful to access the `pathname` and `search`
    properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The full list of read-only properties of `window.location` are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`hash`'
  prefs: []
  type: TYPE_NORMAL
- en: A hash value in the URL, such as `#id`
  prefs: []
  type: TYPE_NORMAL
- en: '`host`'
  prefs: []
  type: TYPE_NORMAL
- en: The domain plus port
  prefs: []
  type: TYPE_NORMAL
- en: '`hostname`'
  prefs: []
  type: TYPE_NORMAL
- en: The domain
  prefs: []
  type: TYPE_NORMAL
- en: '`href`'
  prefs: []
  type: TYPE_NORMAL
- en: The full URL
  prefs: []
  type: TYPE_NORMAL
- en: '`origin`'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol, hostname, and port
  prefs: []
  type: TYPE_NORMAL
- en: '`pathname`'
  prefs: []
  type: TYPE_NORMAL
- en: The path of the current document
  prefs: []
  type: TYPE_NORMAL
- en: '`port`'
  prefs: []
  type: TYPE_NORMAL
- en: The server’s port number value
  prefs: []
  type: TYPE_NORMAL
- en: '`protocol`'
  prefs: []
  type: TYPE_NORMAL
- en: The protocol (HTTP or HTTPS)
  prefs: []
  type: TYPE_NORMAL
- en: '`search`'
  prefs: []
  type: TYPE_NORMAL
- en: Query string values
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting a URL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need to use JavaScript to route a user to a different page.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use either the `assign` or `replace` `window.location` method, depending on
    the goal of the redirect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `window.location.assign` method will route a user to a new URL, but will
    preserve the routing page in the browser history. This means that a user will
    be able to use the browser’s back button to navigate back to the page. Conversely,
    `window.location.replace` will replace the current URL in the history, disabling
    the ability to return to the current page.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By using `window.location` methods, you are able to route a user to a new URL
    using JavaScript. This allows you to reroute a user or redirect a user based on
    a page interaction. `assign` and `replace` are not the only `window.location`
    methods at your disposal. The full list of methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.assign()`'
  prefs: []
  type: TYPE_NORMAL
- en: Navigates the user’s browser to a given URL
  prefs: []
  type: TYPE_NORMAL
- en: '`.reload()`'
  prefs: []
  type: TYPE_NORMAL
- en: Reloads the page
  prefs: []
  type: TYPE_NORMAL
- en: '`.replace()`'
  prefs: []
  type: TYPE_NORMAL
- en: Navigates the user’s browser to a given URL and removes the current document
    from the browser history
  prefs: []
  type: TYPE_NORMAL
- en: '`toString()`'
  prefs: []
  type: TYPE_NORMAL
- en: Returns the current URL as a string
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging these methods, you will be able to use JavaScript to manipulate
    the route of the page, which can provide useful functionality for application
    UIs and interactive routing. Although these features can be very useful when developing
    applications, full page redirects should always be done with an HTTP redirect
    with the appropriate status code of 301 for permanent redirects or 302 for temporary
    redirects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Popular JavaScript frameworks come with a routing library or can be extended
    with a third-party routing library, which can be used for robust client-side routing.
  prefs: []
  type: TYPE_NORMAL
- en: Copying Text to a User’s Clipboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your application needs to copy text, such as a share link, to the user’s clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To copy text to a user’s clipboard, place the text within a text `input` or
    `textarea` element and use the `navigator.clipboard.writeText` method to copy
    the text.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your HTML, include the form element as well as a button. In the example,
    I’m setting an explicit `value` for the input element. This value could also be
    set by the user or dynamically in code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: And in the corresponding JavaScript, add an event handler to the `button` element.
    When the button is clicked, use the `select` method to select the text within
    the `input` element followed by `navigator.clipboard.writeText()` to copy the
    text to the user’s clipboard, as shown in [Example 16-2](#copy-text-js).
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-2\. Copying text to the clipboard
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding text to a user’s clipboard from a text input box is a common UI pattern
    seen in web applications such as GitHub and Google Docs. This can be a useful
    feature to simplify the sharing of information or a URL for users. The input and
    button pattern demonstrated in the primary recipe is the most common use, but
    there may be times where you want to instead copy a user selection from the page’s
    content. In this scenario, it may be useful to hide the form control. To do this,
    include the markup of the page content as well as a `textarea` or `input` element.
    In this example, I’ve used a `textarea` element and set the `tabindex` to remove
    it from the user’s tab flow, then set `aria-hidden` to `true` so that screen readers
    know to ignore the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In my CSS, I’ve hidden the element by placing it offscreen and giving it a
    height and width value of `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, in my JavaScript I follow a similar pattern as [Example 16-2](#copy-text-js),
    with the addition of using the `document.getSelection()` to get the value of any
    text that the user has selected on the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Enabling easy sharing of web application content is a common pattern in the
    social web era. Using these techniques provides a pattern to simplify that interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling a Mobile-Like Notification in the Desktop Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a way to notify a user that an event has occurred or a long-running
    process is finished, even if your site isn’t open in an active tab.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use the Web Notifications API.
  prefs: []
  type: TYPE_NORMAL
- en: This API provides a relatively simple technique to pop up a notification window
    outside of the browser, so that if a person is currently looking at a web page
    in another tab, they’ll still see the notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a Web Notification, you do need to get permission. In the following
    code, Notification permission is requested when a user clicks a button. If permission
    is granted, a notification is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Mobile environments have notifications that let you know when you’ve received
    a new “Like” on a Facebook post or a new email in your email client. Traditionally,
    we didn’t have this capability in a desktop environment, though some might say
    this is a good thing.
  prefs: []
  type: TYPE_NORMAL
- en: Still, as we create more sophisticated web applications, it may help to have
    this functionality, particularly when our applications may take a significant
    amount of time. Instead of forcing people to hang around looking at a “working”
    icon on our pages, the web page visitor can view other web pages in other tabs,
    and know they’ll get notified when the long-running process is finished.
  prefs: []
  type: TYPE_NORMAL
- en: In the solution, the first time the code creates a new notification, it gets
    permission from the web page visitor. If your application is created as a standalone
    web application, you can specify permissions in the manifest file, but for web
    pages, you have to ask permission.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prior to the Notification permission request, you can also test to see if Notification
    exists, so an error is not thrown if it’s not supported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The Notification takes two arguments—a title string and an object with options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`body`'
  prefs: []
  type: TYPE_NORMAL
- en: The text message in the body of the notification
  prefs: []
  type: TYPE_NORMAL
- en: '`tag`'
  prefs: []
  type: TYPE_NORMAL
- en: A tag to help identify notifications for global changes
  prefs: []
  type: TYPE_NORMAL
- en: '`icon`'
  prefs: []
  type: TYPE_NORMAL
- en: A custom icon
  prefs: []
  type: TYPE_NORMAL
- en: '`lang`'
  prefs: []
  type: TYPE_NORMAL
- en: Language of notification
  prefs: []
  type: TYPE_NORMAL
- en: '`dir`'
  prefs: []
  type: TYPE_NORMAL
- en: Direction of the language
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also code four event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onerror`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onclose`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onshow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`onclose`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And you can programatically close the notification with `Notification.close()`,
    though Safari and Firefox automatically close the notification in a few seconds.
    All browsers provide a window close (*x*) option in the notification.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Web Notifications and the Page Visibility API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can combine Web Notifications with the Page Visibility API to display the
    Notification only when the web page visitor isn’t actively looking at the web
    page.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Page Visibility API has broad support in modern browsers. It adds support
    for one event, `visibilitychange`, which is fired when the visibility of the tab
    page changes. It also supports a couple of new properties—`document.hidden` returns
    true if the tab page isn’t visible, and `document.visibilityState`, which has
    one of the following four values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`visible`: When the tab page is visible'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hidden`: When the tag page is hidden'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`prerender`: The page is being rendered but not yet visible (browser support
    is optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unloaded`: The page is being unloaded from memory (browser support is optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To modify the solution so that the notification only fires when the tabbed
    page is hidden, modify the code to check for `visbilityState`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Before creating the Notification, the code tests to see if the page is hidden.
    If it is, then the Notification is created. If it isn’t, then a message is written
    out to the page instead.
  prefs: []
  type: TYPE_NORMAL
- en: Loading a File Locally in the Browser
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to open an image file and output the metadata in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the File API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The File API bolts onto the existing input element `file` type, used for file
    uploading. In addition to the capability of uploading the file to the server via
    a form upload, you can now access the file directly in JavaScript, and either
    work with it locally or upload the file to a server.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For more on `FileReader`, check out MDN’s [page on the API](http://mzl.la/1ya0o1k),
    and a [related tutorial](http://mzl.la/1ya0qGs).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three objects in the File API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FileList`'
  prefs: []
  type: TYPE_NORMAL
- en: A list of files to upload via `input type="file"`
  prefs: []
  type: TYPE_NORMAL
- en: '`File`'
  prefs: []
  type: TYPE_NORMAL
- en: Information about a specific file
  prefs: []
  type: TYPE_NORMAL
- en: '`FileReader`'
  prefs: []
  type: TYPE_NORMAL
- en: Object to asynchronously upload the file for client-side access
  prefs: []
  type: TYPE_NORMAL
- en: Each object has associated properties and events, including being able to track
    the progress of a file upload (and provide a custom progress bar), as well as
    signaling when the upload is finished. The `File` object can provide information
    about the file, including the filename, size, and MIME type. The `FileList` object
    provides a list of `File` objects, because more than one file can be specified
    if the input element has the `multiple` attribute set. The `FileReader` is the
    object that does the actual file upload.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 16-3](#loading_an_image) shows an application that uploads an image,
    embeds it in the web page, and displays some information about the image. The
    result is shown in [Figure 16-7](#using_the_files_api_to_read_a_chapter_of).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 16-3\. Loading an image and metadata
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![jsc3 1607](assets/jsc3_1607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 16-7\. Using the File API to read an image
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The File API is a W3C effort. For more information, you can read the [latest
    draft](http://.w3.org/TR/FileAPI) or [Mozilla’s coverage](http://mzl.la/1ya0qGs).
  prefs: []
  type: TYPE_NORMAL
- en: Extending the Possible with Web Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You need a component that encapsulates a specific look, feel, and behavior,
    and that you can include as easily as you’d include an HTML element, but don’t
    want to use a web framework.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider Web Components, which allow you to create custom and reusable HTML
    elements. Web Components consist of a Template, custom elements, and shadow DOM.
    Each will be covered in the discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Think of a web page widget that’s completely self-contained and you have some
    resemblance to Web Components, but only in the most shallow sense. Web Components,
    as a term, encompasses several different constructs. In the following sections,
    I’ll cover each, provide examples, discuss polyfills, and what to expect in the
    future.
  prefs: []
  type: TYPE_NORMAL
- en: HTML templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `template` element is now part of the HTML5 specification. Currently it’s
    [supported in most modern browsers](https://oreil.ly/SJZDC). Within the `template`
    element, we include HTML that we want to group as a whole that isn’t instantiated
    until it is *cloned*. It is parsed when loaded, to ensure it’s valid, but it doesn’t
    exist. Yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with templates is very intuitive. Consider a common practice with today’s
    single-page JavaScript applications: taking returned data from a web service and
    formatting it as an unordered list (`ul`) (or new paragraph, or table, or whatever).
    Typically, we’d use the DOM methods to query for the existing `ul` element, create
    each list item (`li`) in the list, append text to the item, and append the item
    to the list.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we could cut out some of the steps? We could with the `template`. Given
    the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the JavaScript to add our “Hello World” template to a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In the example we access the `template` element, access the HTML element’s content,
    and then append it to the HTML document using `appendChild()`. As I noted, templates
    are very intuitive, but you might be wondering, what’s the point? All we’ve done
    is add more code for a process that’s already simple, but templates are important
    for their use in Custom Elements, discussed in [“Custom elements”](#custom_elements),
    as well as the [“Shadow DOM”](#shadow_dom).
  prefs: []
  type: TYPE_NORMAL
- en: Custom elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The Web Components construct that has generated the most interest is the custom
    element. Instead of having to deal with existing HTML elements and their default
    behaviors and appearance, we create a custom element, package in its styling and
    behavior, and just attach it to the web page. A custom element can either extend
    an existing element or be “autonomous,” meaning it is a completely new element.
    In the following example, I will extend the HTML `<p>` element to create a new
    element named `<hello-world>`. To do so, I will first need to define a class with
    any special methods for the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the class is defined, I can register my element. Note that the element
    name must contain a hyphen to avoid any potential conflicts with existing HTML
    elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now I can use my element in my HTML page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Shadow DOM
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I can’t see *shadow DOM* without thinking of the fictional character “The Shadow.”
    What a great character, and appropriate, too. Only The Shadow knew what evil lurked
    in the minds of men, and only the shadow DOM knows what lurks in its element’s
    DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Dragging ourselves away from fictional distraction, the shadow DOM is the most
    twisty of the Web Components. But intriguing, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the nonmysterious bits. The shadow DOM is a DOM, a tree of nodes just
    like we’re used to when we access elements from the `document` element. The primary
    difference is that it doesn’t exist, not in a way we know a DOM existing. When
    we create a *shadow root* of an element, then it comes into existence. But then,
    whatever the element used to have, is gone. That’s the key to remember about the
    shadow DOM: creating it replaces the element’s existing DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By using the `attachShadow` method, you can attach a shadow root to any element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The `attachShadow` method takes one parameter (`mode`), which accepts a value
    of either `open` or `closed`. Setting the value to `open` allows you to access
    the shadow DOM in the context of the page, like any other element. The most common
    shadow DOM use case is attaching a shadow DOM to a custom element as part of its
    constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Though the above example contains two HTML elements, global CSS styles will
    not apply to a shadow DOM element. To style a custom element with a shadow DOM,
    we would create a style element within the custom element class and apply the
    styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The [Polymer Project](https://oreil.ly/874AX) is a collection of libraries and
    tools for working with web components.
  prefs: []
  type: TYPE_NORMAL
- en: Web components are a very interesting part of the web standards ecosystem with
    great potential. HTML templates, custom HTML elements, and the shadow DOM provide
    a means for creating small, reusable UI components. This idea of lightweight components
    has been reflected in JavaScript libraries such as React and Vue.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a Front-End Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are building a complex web application that requires a JavaScript framework.
    How do you choose the right framework?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There was a time when JavaScript frameworks seemingly came in and out of style
    faster than a fashion week runway. Thankfully, over the past few years the framework
    wars have slowed down and we have been left with a handful of excellent choices.
    Despite the slowdown of new development, it can still be challenging to choose
    the best framework for you and your project. When evaluating frameworks for a
    project, I recommend asking yourself the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Do I need a JavaScript framework?
  prefs: []
  type: TYPE_NORMAL
- en: Don’t always reach for a framework by default. Oftentimes, simple sites and
    applications may be easier to write and maintain without a framework, while being
    more performant for a user.
  prefs: []
  type: TYPE_NORMAL
- en: What is the type of project I’ll be developing?
  prefs: []
  type: TYPE_NORMAL
- en: Is this a personal project? A project for a client? An enterprise project with
    long-term support needs? An open source project? Consider the maintainers of your
    project and what will best meet their needs.
  prefs: []
  type: TYPE_NORMAL
- en: What is the level of community adoption and the longevity of the project?
  prefs: []
  type: TYPE_NORMAL
- en: Consider the long-term support of the framework. Is it still an active project?
    Will it be supported by a large community to answer questions and fix bugs?
  prefs: []
  type: TYPE_NORMAL
- en: How well documented is the framework?
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the documentation is easy to understand and complete.
  prefs: []
  type: TYPE_NORMAL
- en: What does the developer ecosystem for the framework look like?
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate the tooling, plug-ins, and metaframeworks.
  prefs: []
  type: TYPE_NORMAL
- en: Am I familiar with the framework?
  prefs: []
  type: TYPE_NORMAL
- en: Is the framework something that you already know or have familiarity with or
    is this a learning project?
  prefs: []
  type: TYPE_NORMAL
- en: What will be the impact on my users?
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps the most important question of all. Determine if a framework will impact
    the performance, accessibility, or usability of your project.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this is far from an exhaustive list, the authors of this book recommend
    looking at the following frameworks: React, Vue, Svelte, and Angular.'
  prefs: []
  type: TYPE_NORMAL
- en: React
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[React](https://reactjs.org) is a UI-driven JavaScript framework developed
    and released by Facebook. React focuses on small visual components and commonly
    makes use of `jsx`, an XML syntax within JavaScript for rendering HTML components.
    React makes updates to the page more efficient by using a representation of the
    DOM, referred to as the [virtual DOM](https://oreil.ly/oK21x).'
  prefs: []
  type: TYPE_NORMAL
- en: Vue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Vue](https://vuejs.org) is a community-focused, UI-driven framework. Like
    React, Vue makes use of a virtual DOM to make page updates instantaneous. Many
    view Vue as an alternative to React. The feature set is similar, but Vue makes
    use of a more HTML-friendly template syntax and is community backed, rather than
    supported by Facebook. I’d recommend giving both React and Vue a spin to see which
    best matches you and your team’s development style.'
  prefs: []
  type: TYPE_NORMAL
- en: Svelte
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Svelte](https://svelte.dev) takes a different approach from the other JS frameworks
    here. Similar to React and Vue, it is a UI-focused library, but rather than doing
    the bulk of the work in the user’s browser, Svelte focuses on a compile step at
    development build time. The goal is to limit the tax on the user’s browser so
    that developers can build performant applications.'
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Angular](https://angular.io) is a full-featured JavaScript framework, developed
    and released by Google. Angular survived the first wave of “framework” wars and
    has adapted to a component-based architecture that is similar to modern libraries.
    Unlike React, Vue, and Svelte, Angular is a fully featured framework out of the
    box, with in-app navigation, data and state management, and testing built into
    the framework. For many, particularly enterprise-focused teams, this can be a
    useful feature as it limits decision making when building new applications or
    adding features.'
  prefs: []
  type: TYPE_NORMAL
