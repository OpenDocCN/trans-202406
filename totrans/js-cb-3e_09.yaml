- en: Chapter 8\. Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is JavaScript an object-oriented programming language? The answer depends on
    who you ask (and how you phrase the question). But the general consensus is *yes*,
    with some caveats.
  prefs: []
  type: TYPE_NORMAL
- en: Outside of academic circles, object-oriented programming languages usually revolve
    around concepts like classes, interfaces, and inheritance. But until recently,
    JavaScript was an outlier—an object-oriented programming language built on functions
    and *prototypes*. Then, along came ES6, and all of sudden classes were available
    as a native language construct, muddying the waters. Was it just syntactic sugar
    or a major language evolution?
  prefs: []
  type: TYPE_NORMAL
- en: The answer lies somewhere in between. Overall, ES6 classes are a higher-level
    language feature built on the familiar foundation of JavaScript prototypes. But
    the mapping isn’t exact, and the class model introduces some new subtleties that
    aren’t completely captured in the prototype model. Furthermore, it’s likely that
    classes will support new object-oriented features in the future, pushing the two
    overlapping models farther apart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bottom line is this: today new development favors using classes, but prototype-based
    code is still common (and far from obsolete). This chapter focuses on common patterns
    using classes, but also explores prototypes.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Reusable Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a reusable template for custom objects.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the `class` keyword, and give your class a name. Inside, add a constructor
    function that initializes your object. Here’s a complete `Person` class example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the `Person` class is a simple package that bundles together
    two public fields (`firstName` and `lastName`). But it’s easy enough to add methods
    to your class, which work like functions but don’t include the `function` keyword.
    Here’s how you would code a `Person.swapNames()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In essence of a JavaScript class is the constructor function. In fact, behind
    the scenes a JavaScript class *is* a constructor function, and all methods are
    attached to that function’s *prototype*. That means that a method like `Person.swapNames()`
    is shared between all the instances of the `Person` class, because they share
    the same prototype. (To dig deeper into this behind-the-scenes reality, check
    out the constructor pattern in [“Using the Constructor Pattern to Make a Custom
    Class”](#constructor_pattern).)
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes have their own syntax requirements that you must follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Constructor functions are always named `constructor`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Neither constructors nor methods use the keyword `function`, although they are
    declared like functions in every other respect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you write a constructor, you use `this` to create new public fields on
    the current object. You can then refer to these fields wherever you need them
    in your class methods, as long as you remember to always prefix the variable name
    with `this`. You can also access these fields outside of the class code, using
    the familiar dot syntax.
  prefs: []
  type: TYPE_NORMAL
- en: You might wonder how you can change this accessibility—say, make your fields
    private and wrap them with public properties. The answer is that currently you
    can’t—at least, not without a home brew solution that introduces complications
    of its own. For a full discussion of the subject, see [“Adding Properties to a
    Class”](#custom_class_properties).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with functions, JavaScript allows you to create classes in an *expression*.
    Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a specialized—but not rare—technique. It allows you to avoid adding
    a class to the current scope. For example, that might be useful in this example
    if you were worried that there might already be a definition for another `Person`
    class. (Another way to solve the problem of name collisions is by using modules,
    as described in [“Organizing Your JavaScript Classes with Modules”](#using_es6_modules).)
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the old-fashioned constructor pattern for object creation, see [“Using the
    Constructor Pattern to Make a Custom Class”](#constructor_pattern). To see how
    to create class properties, refer to [“Adding Properties to a Class”](#custom_class_properties).
    To learn how to connect classes in an inheritance relationship, see [“Inheriting
    Functionality from Another Class”](#custom_class_inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Multiple Constructors'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In most object-oriented languages it’s possible to create multiple constructors,
    so the code that creates the class has a choice of what parameters to specify.
    But JavaScript doesn’t support constructor overloading or method overloading.
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn’t quite as limiting as it seems, because JavaScript is notoriously
    loose with function arguments and never forces you to supply them. So even though
    `Person` has a single three-argument constructor, these are all valid ways to
    create an instance without supplying every argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Every class has exactly one constructor, and it always runs. Even if you don’t
    specify any arguments when you create a `Person` object, the three-argument constructor
    still runs and sets `this.firstName`, `this.lastName`, and `this.birthDate` (all
    of which will be set to `undefined`). If this isn’t acceptable, you can set default
    parameter values, just as you do with ordinary functions (see [“Providing a Default
    Parameter Value”](ch06.html#provide_default_parameter)).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you create a class without a constructor, JavaScript automatically gives
    it a blank no-argument constructor. This detail becomes significant if you decide
    to use class inheritance ([“Inheriting Functionality from Another Class”](#custom_class_inheritance)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to deal with optional arguments is using an object literal that
    gets passed to the constructor. That way the caller can choose to set only the
    named properties they want to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a common JavaScript design pattern that’s described in detail in [“Using
    Named Function Parameters”](ch06.html#named_parameters). One advantage it provides
    is that you don’t need to worry about the order of properties in the object literal.
    A disadvantage is that there’s nothing to prevent you from accidentally creating
    incorrectly named parameters that will be silently ignored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Another possible approach is to create a single constructor for your class,
    but add static methods that create differently configured instances of the object.
    Depending on the implementation, this is sometimes called the *builder pattern*
    or *factory pattern*. It’s described in [“Using a Static Method to Create Objects”](#factory_method).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Properties to a Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to add property getters and setters to wrap your class data.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, consider if properties are the best solution for your use case. (As
    explained in the discussion, they have well-known limitations and are slightly
    controversial.) If you decide to use properties, you can create `get` and `set`
    methods for each one. Here’s an example with a computed property, called `age`,
    which is calculated from the date stored in `this.dateOfBirth`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s up to you whether you include only a getter, only a setter, or both. Here’s
    an example that uses the property pattern to apply basic validation to the date
    of birth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: This example throws an exception ([“Throwing a Standard Error”](ch10.html#throwing_errors))
    to notify the caller when they attempt to set an invalid value. This is a reasonable
    design decision, but it’s not always the best choice. Having an error occur when
    setting a property (or even worse, when attempting to create a `Person` with an
    invalid date) is not expected behavior in JavaScript, and the potential error
    may not be anticipated by the calling code. (The alternative—silently ignoring
    the offending error—is also risky.) In the end, a better approach may be to use
    methods to supply potentially problematic data instead of properties.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many reasons you might consider creating property procedures. Some
    examples include:'
  prefs: []
  type: TYPE_NORMAL
- en: To calculate a value (like `Person.age`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To transform a field into another representation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To perform validation before updating a field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add hooks for some other service (like logging or testing) that should happen
    every time a field is read or set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To use some kind of lazy initialization, which only creates or calculates a
    property value when it’s needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To expose a single property of an object that’s stored in a field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe presents two examples. The `Person.age` property is a read-only
    computed property. The `Person.dateOfBirth` property is a settable property with
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you use properties, you must be careful to avoid name collisions. The
    field that stores the value cannot have the same name as the property or the constructor
    parameter. To understand why, let’s take a closer look at the `dateOfBirth` example.
    The constructor accepts a `date` parameter, which it sets like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At first glance, you might assume this statement stores the date in a public
    field named `this.dateOfBirth` (which is the usual pattern). But in this case,
    `this.dateOfBirth` refers to the `dateOfBirth` property. Its setter takes over:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the new value passes the test, it’s stored in a public field named `this._dateOfBirth`.
    The awkward naming is necessary, because both `this.dateOfBirth` (the property)
    and `this._dateOfBirth` (the field) have the same scope. If you use the same name
    for both, you’ll end up calling the wrong one (and triggering an infinite sequences
    of calls that will eventually overflow the stack).
  prefs: []
  type: TYPE_NORMAL
- en: The leading underscore in a variable name like `_dateOfBirth` has another purpose.
    Currently, JavaScript doesn’t have any way to create private fields. But the underscore
    signals that a field is *supposed* to be private to the class. Then, you trust
    that the calling code will avoid using this field. If you don’t follow this convention,
    you’re almost certain to run into a problem where the calling code accidentally
    uses the field instead of the property. And even if you *do* observe this pattern,
    there’s no guarantee that the calling code will follow it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many JavaScript developers argue that a more natural pattern in JavaScript
    is to use `setXxx()` and `getXxx()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This approach is a bit more cumbersome, but it has some advantages. It makes
    it obvious that you’re calling a method and running code, not simply setting a
    variable. As a result, the calling code can expect exceptions from type-checking
    or other side effects. Methods also prevent problems like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Both the [Google JavaScript Style Guide](https://google.github.io/styleguide/jsguide.html)
    and the often-consulted [Airbnb JavaScript Style Guide](https://github.com/airbnb/javascript)
    discourage the usage of property getters and setters but allow `setXxx()` and
    `getXxx()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: There’s one more wrinkle to consider with properties. Behind the scenes, JavaScript
    uses the `Object.defineProperty()` method to implement your property getters and
    setters. Most of the time, that works perfectly well. However, there are specialized
    cases when you may decide to use `defineProperty()` because it allows you to configure
    metadata details you can’t otherwise set. For example, if you want to make a property
    nonconfigurable (so its implementation can’t be altered) or nonenumerable (so
    it won’t show up in a `for...in` loop), you need to explicitly call `defineProperty()`.
    In this situation, the usual approach is to call `defineProperty` in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to use property procedures to react to property changes and trigger
    other actions (like logging), consider using proxies instead ([“Intercepting and
    Changing Actions on an Object with a Proxy”](ch07.html#modifications_with_proxies)).
    For more about creating properties with `Object.defineProperty()`, see [“Customizing
    the Way a Property Is Defined”](ch07.html#creating_properties_with_define_property).
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra: Private Fields'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, JavaScript does not have a way to make member variables (those created
    with `this`) private. Many workarounds are used, and many of them are dangerously
    creative. The most popular implementation uses a `WeakMap` to store internal data.
    It works, but it adds a dangerous layer of extra homemade complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better approach is to use the underscore convention (like `_firstName`) to
    name fields that should not be accessed outside a class. In the future, JavaScript
    will patch this gap and adopt some version of the [*private class fields* proposal](https://github.com/tc39/proposal-class-fields).
    Right now, the private field syntax uses a `#` to identify private fields, which
    can be declared at the beginning of your class block, making your class self documenting.
    Here’s what that looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: If you want to experiment with these features today, you can use [Babel](https://babeljs.io)
    to transpile your code, although be aware that the syntax may change.
  prefs: []
  type: TYPE_NORMAL
- en: Interestingly, this is one case where JavaScript classes have *less* functionality
    than the old-fashioned constructor pattern ([“Using the Constructor Pattern to
    Make a Custom Class”](#constructor_pattern)). That’s because the constructor pattern
    can use closures to store private variables, as explained in [“Creating a Function
    That Stores its State with a Closure”](ch06.html#create_a_function_that_remembers_its_sta).
  prefs: []
  type: TYPE_NORMAL
- en: Giving a Class a Better String Representation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to choose a suitable text representation that will be used for your
    object when it’s converted to a string.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a method named `toString()` to your class and return the string you want
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The default implementation of `toString()` for all objects displays the unhelpful
    text `[object Object]`. You can set your own text by adding a `toString()` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `toString()` method can be called explicitly (as in this example), or it
    can be called implicitly when your object is converted to a string. For example,
    if you concatenate your object with a string, `toString()` is called automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'However, calling `console.log()` on an object, on its own, does not trigger
    your `toString()`. That’s because `console.log()` has an extra bit of logic that
    iterates over the properties of your object and uses that to build its own custom
    string. You can get around this by calling `toString()` yourself, or using a template
    literal ([“Using Template Literals for Clearer String Concatenation”](ch02.html#using_template_literals)).
    Here’s a comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Using the Constructor Pattern to Make a Custom Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a reusable, class-like entity in your code. You want to use
    the traditional constructor pattern because it matches your existing code.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The constructor pattern is a slightly dated but still acceptable pattern for
    object creation. Even if you plan to use formal classes ([“Creating a Reusable
    Class”](#using_es6_classes)), it’s worth knowing the constructor pattern, because
    you’re likely to encounter it out in the wild. It can also help you understand
    how JavaScript classes work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s one of the `Person` class examples from [“Creating a Reusable Class”](#using_es6_classes),
    but written as a function with the constructor pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the code for using a function-based object is the same as the code
    for using a class-based with an identical constructor. As a result, you can usually
    migrate code from the constructor pattern to formal classes without disrupting
    the rest of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Classes were a relative latecomer to the JavaScript language. Before they existed,
    developers used functions in their place. This works because JavaScript allows
    you to create new *instances* of a function (function objects) using the `new`
    keyword. Every function gets its own scope, with its own local data.
  prefs: []
  type: TYPE_NORMAL
- en: The constructor pattern exists in several variants. The most common approach
    is to create a function with the name of your “class” and accept all the constructor
    parameters you need to create an instance. Inside your function, you use `this`
    to create public fields. You can also create ordinary variables, which won’t be
    visible to outside code, and are only usable by the constructor and any nested
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: There are two common ways to create method-like functions. The approach shown
    here creates each method using a function expression, and makes them publicly
    accessible with `this`. Because the method functions are wrapped inside the constructor
    function, they have the same scope as the constructor, and they have access to
    all the same variables and local variables. (Technically, the constructor function
    creates a closure, as explained in [“Creating a Function That Stores its State
    with a Closure”](ch06.html#create_a_function_that_remembers_its_sta).)
  prefs: []
  type: TYPE_NORMAL
- en: The other way to create methods is to explicitly add them to the *prototype*
    of your constructor function. If you haven’t encountered prototypes yet, they’re
    a basic (but mostly hidden) ingredient that allows objects to share functionality.
    When you attempt to call a method (like `Person.swapNames()`), JavaScript looks
    for the `swapNames()` function in the `Person` constructor. If it doesn’t find
    it, JavaScript looks for a `swapNames()` function in the prototype. The process
    gets a bit more involved when inheritance is involved, because JavaScript will
    search an entire *prototype chain* looking for a function, as explained in [“Inheriting
    Functionality from Another Class”](#custom_class_inheritance).
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do you add a function to a prototype? You can do it directly, using
    the `prototype` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This example behaves mostly the same as the version with the nested constructor
    functions. But there is a difference. Before, the `swapNames()` existed independently
    in each `Person` object. Now, there is a single `swapNames()` function set in
    the prototype and shared among all `Person` instances. This is important if you
    plan to create an inheritance relationship linking prototypes together (see [“Extra:
    Prototype Chains”](#prototype_chains)). It’s also significant if you attempt to
    use private variables with a closure ([“Creating a Function That Stores its State
    with a Closure”](ch06.html#create_a_function_that_remembers_its_sta)), because
    functions attached to the prototype don’t exist in the same context as the constructor
    function, and won’t have access to private variables defined in the constructor.'
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using prototypes, you can alter the behavior of built-in JavaScript objects.
    For example, you can add functionality to the base `Array` or `String` types.
    This sounds like a nifty feature, but it’s rife with complications and is strongly
    discouraged (except perhaps for building frameworks). Blurring the distinction
    between standard and custom code invites confusion, and creates the possibility
    for nonstandard patterns, poorly optimized code, and hidden mistakes. It can also
    fail outright if more than one person attempts to extend a built-in object with
    the same name.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s interesting to compare the constructor pattern to the `class` keyword
    shown in [“Creating a Reusable Class”](#using_es6_classes). Most of the code is
    exactly the same in both examples:'
  prefs: []
  type: TYPE_NORMAL
- en: You write a constructor function that accepts parameters and initializes your
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use the `this` keyword to create publicly accessible fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You use the `new` keyword when creating the object (only now it’s technically
    an instance of a function, not a class).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But there are also some subtle differences, most obviously in syntax. In the
    constructor pattern there are no dedicated properties, and methods are declared
    separately, not nested in the constructor or explicitly attached to the constructor’s
    prototype (although that’s exactly what happens at runtime).
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[“Creating a Reusable Class”](#using_es6_classes) demonstrates the preferred
    way to create a custom object template in modern JavaScript, which is using the
    `class` keyword.'
  prefs: []
  type: TYPE_NORMAL
- en: Supporting Method Chaining in Your Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to define your class methods in such a way that several methods can
    be called in quick succession, in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure to return the current object at the end of each method that should
    support method chaining. In a custom class, this is usually as simple as adding
    a `return this` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a custom `Book` object with two methods, `raisePrice()`
    and `releaseNewEdition()`, both of which use method chaining:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to directly call one method on the result of another method, in
    a single code statement, is known as *method chaining*. Here’s an example with
    a string and the `replaceAll()` method. Because `replaceAll()` returns a new string,
    you can call `replaceAll()` again on that string, and get a *third* string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Method chaining doesn’t have to be with the same method. It works with any
    method that returns an object. Consider how this code joins two arrays and then
    sorts the resulting array by chaining a call to `concat()` with one to `sort()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Chaining is used extensively in built-in JavaScript objects and in many JavaScript
    libraries and frameworks. To use this pattern in your own classes, you simply
    return a reference to `this` at the end of your method. The calling code can then
    ignore this reference, or use it to perform method chaining.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the current example, calling a method on `Book` changes the object and returns
    a reference to the changed object. The caller can ignore the return value, because
    they already have a reference to the `Book` object. However, many functional programming
    purists do something different. They write methods that return a changed object
    *copy*, while keeping the original object unchanged. Here’s how you’d implement
    this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This pattern doesn’t affect the way method chaining works, but it does mean
    the caller needs to take the return value, or they won’t see the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Static Methods to a Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a utility method that’s tied to your class, but can be called
    without creating an object.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Place the `static` keyword before the method. Make sure your method doesn’t
    attempt to use any instance fields, properties, or methods. Here’s an example
    with a static method named `Book.isEqual()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: You access a static method through the class name (as in `Book.isEqual()`).
    You can’t access it through an object variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Static methods have functionality that’s logically related to a class, but not
    tied to a specific instance. The `Array.isArray()` method is a good example—it
    lets you test whether any object is an array, without forcing you to create an
    array object first. Occasionally, classes are made up entirely of static methods.
    JavaScript’s `Math` class is a good example.
  prefs: []
  type: TYPE_NORMAL
- en: In the current example, you might want to give the `Book` class static methods
    related to processing or verifying ISBNs. You can also use static methods to make
    decisions about how objects of a certain class should be copied or compared. The
    solution demonstrates this principle with a static `isEqual()` method. You could
    also add a `compare()` method that would let you sort your objects in array (as
    shown in [“Sorting an Array of Objects by a Property Value”](ch05.html#sorting_array)).
  prefs: []
  type: TYPE_NORMAL
- en: In a static method, `this` refers to the current class, not an object instance.
    This can lead to problems, because your code will still be allowed to store data
    in `this` (or retrieve it). It just might not have the effect you expect. Essentially,
    everything in the static `this` acts like a class-scoped global variable, which
    is best avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you want one static method to call another static method, you can use the
    `this` keyword. For example, if you want to call the static `isEqual()` from another
    static method in the `Book` class, you can refer to it as `Book.isEqual()` or
    `this.isEqual()`, which may be clearer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Property `set` and `get` methods can also be static, although their usage is
    sometimes controversial. For example, you can use a static getter to store a constant,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write a static setter, which acts like a global variable in your application.
    However, because there’s no static constructor, you’ll be forced to run code somewhere
    to assign the initial value. This isn’t particularly clear, so a [new static property
    syntax is under development](https://oreil.ly/7O28H), and currently supported
    by more modern browser versions. It allows you to set a public static property
    using a variable-like syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: However, it’s best to avoid this language feature altogether—or at least until
    some future data when its use in JavaScript is more normative.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Static Method to Create Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a method that generates a preconfigured object, possibly
    to get around JavaScript’s single-constructor limitation.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a static method to your class that creates and returns the object you want.
    Here’s an example with a `Book` class that you can create through the constructor
    or through the static `Book.createSequel()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how you use the static method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using static methods, you can implement different types of *creational* patterns—basically,
    patterns that help you create preconfigured instances of a class. For example,
    the JavaScript `Date` class has a `now()` property that returns a new `Date` object
    that’s automatically set to the current date and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This approach is particularly suited to creating more complex combinations
    of objects. For example, you could extend the previous example with a `Book.createTrilogy()`
    method to get an array of three `Book` objects. In this example, the `Book` objects
    share a single `Author` object, which means that if you update the `Author` object,
    all the `Book` instances that link to it see the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Unlike constructors, there’s no limit to how many static methods you can add
    to support different object-creation scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Sometimes these static methods are called *factory methods*, although that description
    isn’t technically precise. In object-oriented design theory, the factory pattern
    is used when you don’t know the exact type of object you’re creating. For example,
    you might write a `createBook()` method that examines the arguments you supply
    and returns an instance of either the `TechBook` class or the `FictionBook` class,
    both of which inherit from a base `Book` class. It’s possible to implement this
    design in JavaScript, too, but opinions are mixed about how well the language
    handles the heavier weight of this sort of classical OOP abstraction.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting Functionality from Another Class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a custom class that inherits the functionality of another
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With inheritance, one or more *child* classes derive from a *parent* class.
    To model this in code, you use the `extends` keyword when you declare the child
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example with a `Triangle` class that inherits from a more basic parent
    class named `Shape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the parent class (`Shape`) doesn’t have any useful functionality.
    The `getArea()` method is only there as a placeholder. But in other cases, base
    classes may be useful on their own. For example, you could use inheritance with
    the `Book` class to create an `EBook` child or with the `Person` class to create
    a `Customer`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It may seem that there’s no point to build a `Triangle` that derives from a
    `Shape` if you only plan to use the `Triangle`. And in a loosely typed language
    like JavaScript, this is often true! But the potential value appears when you
    use a single parent class to standardize more child classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it becomes possible to write code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, JavaScript is a loosely typed language, and you could call `getArea()`
    on `Triangle` and `Circle` and `Square` objects even if they didn’t share a parent
    class that defined the method. But formalizing this interface with inheritance
    can help make these requirements explicit. It’s also important if you need to
    test objects using `instan⁠ce​of` ([“Checking if an Object Is a Certain Type”](ch07.html#check_object_type)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t write a constructor for a child class, JavaScript creates one automatically.
    That constructor calls the base class constructor (but provides no arguments).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you write a constructor for your child class, you *must* call the parent
    class constructor. Otherwise, you’ll receive a `ReferenceError` when you try to
    create an instance. To call the parent class constructor, you use the `super()`
    keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'If the parent class constructor accepts arguments, you should pass them to
    `super()` like you would when creating the object. Here’s an example with an `EBook`
    class that extends `Book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `super()` to call other methods or properties in the parent
    class. For example, if a child class wants to call the parent class implementation
    of `formatString()`, it would call `super.formatString()`.
  prefs: []
  type: TYPE_NORMAL
- en: Classes are a relatively late introduction to JavaScript. Although they support
    inheritance, many of the other tools you might be used to in traditional object-oriented
    languages, like abstract base classes, virtual methods, and interfaces, have no
    analog in JavaScript. Some developers enjoy the lightweight nature of JavaScript
    and its emphasis on prototypes, while others feel they are missing vital tools
    for building large, complex applications. (If you’re in the latter camp, your
    best better is to consider TypeScript, a more rigorous superset of JavaScript.)
  prefs: []
  type: TYPE_NORMAL
- en: 'But inheritance isn’t without its own tradeoffs. It can encourage you to write
    tightly coupled classes that are dependent on one another and difficult to adapt
    to future changes. Even worse, it’s often difficult to identify these dependencies,
    and developers become reluctant to make changes to the parent class (a situation
    called the *fragile base class* problem). Because of problems like these, modern
    development often prefers aggregating groups of objects instead of using inheritance
    relationships. For example, instead of building an `Employee` class that extends
    `Person`, you might create an `Employee` object that includes a `Person` property,
    along with all the other details it needs. This pattern is called *composition*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Extra: Prototype Chains'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may remember that the JavaScript class feature creates a prototype for an
    object. This prototype holds the implementation of all its methods and properties,
    and is shared between all instances of that class. Prototypes are also the secret
    to inheritance. When one class extends another, they are linked in a *prototype
    chain*.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the relationship of `Shape` and `Triangle`. The `Triangle`
    class has a prototype that holds whatever you’ve defined for the child class.
    However, that prototype has *its own* prototype, which is the prototype for `Shape`
    class, with all its members. The `Shape` prototype has its own prototype, too:
    the base `Object.prototype`, which ends the prototype chain.'
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance can go as many levels deep as you want, so a prototype chain can
    become much longer. When you call a method like `Triangle.getArea()`, JavaScript
    searches the prototype chain. It looks for a method in the `Triangle` prototype,
    then the `Shape` prototype, and then the `Object` prototype (at which point it
    fails with an error if it can’t find a matching method).
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, JavaScript classes are relatively new, and prototypes have been
    around since the first version of the language. So it’s no surprise that you can
    create inheritance-like relationships using prototypes even if you aren’t using
    JavaScript classes. Sometimes this is paired with the old-fashioned constructor
    pattern ([“Using the Constructor Pattern to Make a Custom Class”](#constructor_pattern)),
    which results in some decidedly inelegant code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This pattern *should* be mostly obsolete now, because classes give you a cleaner
    method to create inheritance relationships. But it still lingers in plenty of
    long-lived codebases.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing Your JavaScript Classes with Modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to encapsulate your classes in a separate namespace to facilitate reuse
    and prevent naming conflicts with other libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use the module system introduced with ES6\. There are three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Decide which functionality represents a complete module. Put the code for those
    classes, functions, and global variables in a separate script file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose which code details you want to *export* (make available to other scripts
    in other files).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In another script, *import* the features you want to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of a module; we’ll store it in a file named *lengthConverterModule.js*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The important line is the `export` statement at the end. It lists all the functions,
    variables, and classes that will be made accessible to other code files. In this
    example, the `Units` constant (really just an enum) and the `LengthConverter`
    class are made available, while the `InvisibleLogger` class is not.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you create module files, the extension *.mjs* is sometimes recommended.
    The *.mjs* extension clearly signals that you’re using an ES6 module, and it helps
    tools like Node and Babel recognize these files automatically. However, the *.mjs*
    extension can also cause problems if your web server isn’t configured to serve
    *.mjs* files with the right MIME type (`text/javascript`), like ordinary *.js*
    files. For that reason, we don’t use it in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Now you can import the functionality you need into another module. You can write
    this module as a separate file, or use a `<script>` block in a web page as we
    do here. But either way, your `<script>` tag must include the `type="module"`
    attribute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the complete page, including a button that triggers a `doSampleConversion()`
    test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has used a number of module systems over the years, most notably
    with Node and npm. But since ES6, JavaScript has had its own module standard,
    which is supported natively in all modern browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you create a solution with modules, there are a few considerations you
    should know:'
  prefs: []
  type: TYPE_NORMAL
- en: Browser security restrictions mean that you can’t run a module example from
    the local filesystem. Instead, you need to host your example on a development
    web server (as described in [“Setting Up a Local Test Server”](ch01.html#setting_up_test_server)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are locked into their own distinct “module” scope. You can’t access
    a module from a normal nonmodule script. Similarly, you can’t access modules from
    the developer console.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can’t access modules from the HTML of your page. That means you can’t wire
    up an event handler using an HTML attribute like `onclick`, for example, because
    the page won’t be able to access an event handler that’s inside a module. Instead,
    your module code needs to reach *out* to the surrounding browser context using
    `window` or `document`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules are automatically executed in strict mode ([“Using Strict Mode to Catch
    Common Mistakes”](ch01.html#using_strict_mode)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Module features can only be imported into another module. If you want to create
    a `<script>` block for a module in a web page, make sure you set the `type` attribute
    to `module`, or the module importing feature won’t work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'When you import functionality from a module, you must specify the file path
    of the module in the `from` part of the `import` statement. Modules support a
    convenient shortcut that lets you start relative paths with `./`, so `./lengthConverterModule.js`
    points to the *lengthConverterModule.js* file in the current folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s quite a bit of flexibility in the naming you use when you import module
    features. You can wrap your imports in a *module object*, which is a special sort
    of container that namespaces everything. Here’s an example that imports every
    exported type into a module object named `LConvert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Notice that no curly brackets are required when using module objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set a *default* export in your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you can import it using any name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The default export feature matches similar functionality in other module systems.
    That makes it easier for those modules to be migrated into the ES6 modules standard.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s likely that ES6 modules will eventually become the dominant module standard
    in JavaScript. But today, the implementation of ES modules in npm is still a bit
    rough around the edges. For the foreseeable future, that means developers will
    be juggling at least two module standards: the ES6 standard that’s recognized
    natively by modern browsers, and the older CommonJS standard that’s mature and
    well-established in the Node and npm ecosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For information on using CommonJS modules with Node and npm, see ​[Chapter 18](ch18.html#ch18).
  prefs: []
  type: TYPE_NORMAL
