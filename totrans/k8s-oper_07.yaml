- en: Chapter 7\. Operators in Go with the Operator SDK
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。使用运算符 SDK 中的 Go 运算符
- en: While the Helm and Ansible Operators can be created quickly and easily, their
    functionality is ultimately limited by those underlying technologies. Advanced
    use cases, such as those that involve dynamically reacting to specific changes
    in the application or the cluster as a whole, require a more flexixble solution.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Helm 和 Ansible 运算符可以快速简单地创建，但它们的功能最终受到这些基础技术的限制。像动态响应应用程序或整个集群中特定变化这样的高级用例需要更灵活的解决方案。
- en: The Operator SDK provides that flexibility by making it easy for developers
    to use the Go programming language, including its ecosystem of external libraries,
    in their Operators.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符 SDK 提供了这种灵活性，使开发者能够轻松使用 Go 编程语言，包括其外部库生态系统，在他们的运算符中使用。
- en: 'As the process is slightly more involved than for the Helm or Ansible Operators,
    it makes sense to start with a summary of the high–level steps:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该过程比 Helm 或 Ansible 运算符稍微复杂一些，因此从高层次步骤的摘要开始是有道理的：
- en: Create the necessary code that will tie in to Kubernetes and allow it to run
    the Operator as a controller.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建必要的代码，将其与 Kubernetes 绑定，允许其作为控制器运行运算符。
- en: Create one or more CRDs to model the application’s underlying business logic
    and provide the API for users to interact with.
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个或多个 CRD 来建模应用程序的基础业务逻辑，并为用户提供与之交互的 API。
- en: Create a controller for each CRD to handle the lifecycle of its resources.
  id: totrans-6
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个 CRD 创建一个控制器，以处理其资源的生命周期。
- en: Build the Operator image and create the accompanying Kubernetes manifests to
    deploy the Operator and its RBAC components (service accounts, roles, etc.).
  id: totrans-7
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建运算符镜像并创建相关的 Kubernetes 清单以部署运算符及其 RBAC 组件（服务账户、角色等）。
- en: While you can write all these pieces manually, the Operator SDK provides commands
    that will automate the creation of much of the supporting code, allowing you to
    focus on implementing the actual business logic of the Operator.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以手动编写所有这些部分，但运算符 SDK 提供了命令，可以自动创建大部分支持代码，使您可以专注于实现运算符的实际业务逻辑。
- en: This chapter uses the Operator SDK to build the project skeleton for implementing
    an Operator in Go (see [Chapter 4](ch04.html#the_operator_framework) for instructions
    on the SDK installation). We will explore the files that need to be edited with
    custom application logic and discuss some common practices for Operator development.
    Once the Operator is ready, we’ll run it in development mode for testing and debugging.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使用运算符 SDK 构建项目框架，实现 Go 中的运算符（参见[第 4 章](ch04.html#the_operator_framework)以获取
    SDK 安装说明）。我们将探讨需要用自定义应用逻辑编辑的文件，并讨论运算符开发的一些常见实践。一旦运算符准备就绪，我们将在开发模式下运行它以进行测试和调试。
- en: Initializing the Operator
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化运算符
- en: Since the Operator is written in Go, the project skeleton must adhere to the
    language conventions. In particular, the Operator code must be located in your
    `$GOPATH`. See the [`GOPATH` documentation](https://oreil.ly/2PU_Q) for more information.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于运算符是用 Go 编写的，项目框架必须遵循语言约定。特别是，运算符代码必须位于您的 `$GOPATH` 中。有关更多信息，请参阅 [`GOPATH`
    文档](https://oreil.ly/2PU_Q)。
- en: 'The SDK’s `new` command creates the necessary base files for the Operator.
    If a specific Operator type is not specified, the command generates a Go-based
    Operator project:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 的 `new` 命令创建了运算符所需的基础文件。如果未指定特定的运算符类型，该命令将生成一个基于 Go 的运算符项目：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[![1](assets/1.png)](#comarker1-011)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#comarker1-011)'
- en: The output is truncated for readability. The generation can take a few minutes
    as all of the Go dependencies are downloaded. The details of these dependencies
    will appear in the command output.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 输出已截断以提高可读性。生成过程可能需要几分钟，因为需要下载所有 Go 依赖项。这些依赖项的详细信息将显示在命令输出中。
- en: The SDK creates a new directory with the same name as `$OPERATOR_NAME`. The
    generation process produces hundreds of files, both generated and vendor files,
    that the Operator uses. Conveniently, you do not need to manually edit most of
    them. We will show you how to generate the files necessary to fulfill custom logic
    for an Operator in [“Custom Resource Definitions”](#custom_res_defs).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: SDK 创建一个与 `$OPERATOR_NAME` 同名的新目录。生成过程会产生数百个文件，包括生成的文件和供运算符使用的供应商文件。方便的是，大多数文件无需手动编辑。我们将向您展示如何生成满足运算符自定义逻辑所需的文件，详见[“自定义资源定义”](#custom_res_defs)。
- en: Operator Scope
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符范围
- en: 'One of the first decisions you need to make is the scope of the Operator. There
    are two options:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要首先做出的第一个决定是运算符的范围。有两个选项：
- en: Namespaced
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间
- en: Limits the Operator to managing resources in a single namespace
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 限制运算符管理单个命名空间中的资源
- en: Cluster
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Cluster
- en: Allows the Operator to manage resources across the entire cluster
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 允许运算符管理整个集群中的资源
- en: By default, Operators that the SDK generates are namespace-scoped.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SDK生成的运算符是命名空间范围的。
- en: 'While namespace-scoped Operators are often preferable, changing an SDK–generated
    Operator to be cluster-scoped is possible. Make the following changes to enable
    the Operator to work at the cluster level:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管命名空间范围的运算符通常更可取，但可以将SDK生成的运算符更改为集群范围的。执行以下更改以使运算符能够在集群级别运行：
- en: '*deploy/operator.yaml*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*deploy/operator.yaml*'
- en: Change the value of the `WATCH_NAMESPACE` variable to `""`, indicating all namespaces
    will be watched instead of only the namespace in which the Operator pod is deployed.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`WATCH_NAMESPACE`变量的值更改为`""`，表示将监视所有命名空间，而不仅仅是运算符Pod所部署的命名空间。
- en: '*deploy/role.yaml*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*deploy/role.yaml*'
- en: Change the `kind` from `Role` to `ClusterRole` to enable permissions outside
    of the Operator pod’s namespace.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`kind`从`Role`更改为`ClusterRole`，以便在运算符Pod的命名空间之外启用权限。
- en: '*deploy/role_binding.yaml*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*deploy/role_binding.yaml*'
- en: Change the `kind` from `RoleBinding` to `ClusterRoleBinding`.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`kind`从`RoleBinding`更改为`ClusterRoleBinding`。
- en: Under `roleRef`, change the `kind` to `ClusterRole`.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`roleRef`下，将`kind`更改为`ClusterRole`。
- en: Under `subjects`, add the key `namespace` with the value being the namespace
    in which the Operator pod is deployed.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`subjects`下，添加键为`namespace`，值为运算符Pod所部署的命名空间。
- en: 'Additionally, you need to update the generated CRDs (discussed in the following
    section) to indicate that the definition is cluster-scoped:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您需要更新生成的CRD（在下一节中讨论）以指示定义是集群范围的：
- en: In the `spec` section of the CRD file, change the `scope` field to `Cluster`
    instead of the default value of `Namespaced`.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CRD文件的`spec`部分中，将`scope`字段更改为`Cluster`，而不是默认值`Namespaced`。
- en: In the *_types.go* file for the CRD, add the tag `// +genclient:nonNamespaced`
    above the struct for the CR (this will have the same name as the `kind` field
    you used to create it). This ensures that future calls to the Operator SDK to
    refresh the CRD will not reset the value to the default.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在CRD的*_types.go*文件中，在CR的结构体上方添加标签`// +genclient:nonNamespaced`（这将与您用于创建它的`kind`字段具有相同的名称）。这样可以确保将来调用运算符SDK刷新CRD时不会将值重置为默认值。
- en: 'For example, the following modifications to the `VisitorsApp` struct indicate
    that it is cluster-scoped:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对`VisitorsApp`结构体的以下修改表明它是集群范围的：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO1-1)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO1-1)'
- en: The tag must be before the resource type struct.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 标签必须放在资源类型结构体之前。
- en: Custom Resource Definitions
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义资源定义
- en: 'In [Chapter 6](ch06.html#adapter_operators), we discussed the role of CRDs
    when creating an Operator. You can add new CRDs to an Operator using the SDK’s
    `add api` command. This command, run from the Operator project root directory,
    generates the CRD for the Visitors Site example used in this book (using the arbitrary
    “example.com” for demonstration purposes):'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html#adapter_operators)中，我们讨论了创建运算符时CRD的角色。您可以使用SDK的`add api`命令将新的CRD添加到运算符中。该命令从运算符项目的根目录运行，为本书中使用的访客站点示例生成CRD（使用任意的“example.com”进行演示）：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The command generates a number of files. In the following list, note how both
    the `api-version` and CR type name (`kind`) contribute to the generated names
    (file paths are relative to the Operator project root):'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令生成了多个文件。在以下列表中，请注意`api-version`和CR类型名称（`kind`）如何影响生成的名称（文件路径相对于运算符项目的根目录）：
- en: '*deploy/crds/example_v1_visitorsapp-cr.yaml*'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*deploy/crds/example_v1_visitorsapp-cr.yaml*'
- en: This is an example CR of the generated type. It is prepopulated with the appropriate
    `api-version` and `kind`, as well as a name for the resource. You’ll need to fill
    out the `spec` section with values relevant to the CRD you created.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成类型的示例CR。它预先填充了适当的`api-version`、`kind`以及资源的名称。您需要填写`spec`部分，使用与您创建的CRD相关的值。
- en: '*deploy/crds/example_v1_visitorsapp_crd.yaml*'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*deploy/crds/example_v1_visitorsapp_crd.yaml*'
- en: This file is the beginning of a CRD manifest. The SDK generates many of the
    fields related to the name of the resource type (such as plural and list variations),
    but you’ll need to add in the custom fields specific to your resource type. [Appendix B](app02.html#appendix_crd_validation)
    goes into detail on fleshing out this file.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件是 CRD 清单的开头。SDK 生成与资源类型名称相关的许多字段（例如复数形式和列表变体），但您需要添加自定义字段，特定于您的资源类型。[附录 B](app02.html#appendix_crd_validation)
    详细介绍了如何完善此文件。
- en: '*pkg/apis/example/v1/visitorsapp_types.go*'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '*pkg/apis/example/v1/visitorsapp_types.go*'
- en: This file contains a number of struct objects that the Operator codebase leverages.
    This file, unlike many of the generated Go files, is intended to be edited.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件包含操作员代码库利用的多个结构对象。与许多生成的 Go 文件不同，此文件旨在进行编辑。
- en: The `add api` command builds the appropriate skeleton code, but before you can
    use the resource type, you must define the set of configuration values that are
    specified when creating a new resource. You’ll also need to add a description
    of the fields the CR will use when reporting its status. You’ll add these sets
    of values in the definition template itself as well as the Go objects. The following
    two sections go into more detail about each step.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`add api` 命令构建适当的框架代码，但在您可以使用资源类型之前，必须定义创建新资源时指定的配置值集合。您还需要添加描述 CR 报告其状态时将使用的字段。您将在定义模板本身以及
    Go 对象中添加这些值集合。以下两个部分详细说明每个步骤。'
- en: Defining the Go Types
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Go 类型
- en: 'In the **_types.go* file (in this example, *visitorsapp_types.go*), there are
    two struct objects that you need to address:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **_types.go* 文件中（在本例中为 *visitorsapp_types.go*），有两个结构对象需要处理：
- en: 'The spec object (in this example, `VisitorsAppSpec`) must include all possible
    configuration values that may be specified for resources of this type. Each configuration
    value is made up of the following:'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规格对象（在本示例中为 `VisitorsAppSpec`）必须包括可为此类型资源指定的所有可能配置值。每个配置值由以下内容组成：
- en: The name of the variable as it will be referenced from within the Operator code
    (following Go conventions and beginning with a capital letter for language visibility
    purposes)
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的名称将在操作员代码中引用（遵循 Go 惯例，为了语言可见性目的以大写字母开头）
- en: The Go type for the variable
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于变量的 Go 类型
- en: The name of the field as it will be specified in the CR (in other words, the
    JSON or YAML manifest users will write to create the resource)
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量名称将在 CR 中指定的字段名称（换句话说，用户将编写的 JSON 或 YAML 清单）
- en: 'The status object (in this example, `VisitorsAppStatus`) must include all possible
    values that the Operator may set to convey the state of the CR. Each value consists
    of the following:'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态对象（在本示例中为 `VisitorsAppStatus`）必须包括操作员可能设置的所有可能值，以传达 CR 的状态。每个值由以下内容组成：
- en: The name of the variable as it will be referenced from within the Operator code
    (following Go conventions and beginning with a capital letter for visibility purposes)
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量的名称将在操作员代码中引用（遵循 Go 惯例，为了可见性目的以大写字母开头）
- en: The Go type for the variable
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于变量的 Go 类型
- en: The name of the field as it will appear in the description of the CR (for example,
    when getting the resource with the `-o yaml` flag)
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为在获取 `-o yaml` 标志的资源时，将出现在 CR 描述中的字段名称
- en: 'The Visitors Site example supports the following values in its VisitorsApp
    CR:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 访问者站点示例支持其访问者应用程序 CR 中的以下数值：
- en: '`Size`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`Size`'
- en: The number of backend replicas to create
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建的后端副本数量
- en: '`Title`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Title`'
- en: The text to display on the frontend web page
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 前端网页显示的文本
- en: It is important to realize that despite the fact that you are using these values
    in different pods in the application, you are including them in a single CRD.
    From the end user’s perspective, they are attributes of the overall application.
    It is the Operator’s responsibility to determine how to use the values.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，尽管您在应用程序的不同 Pod 中使用这些值，但将它们包含在单个 CRD 中。从最终用户的角度来看，它们是整个应用程序的属性。操作员的责任是确定如何使用这些值。
- en: 'The VisitorsApp CR uses the following values in the status of each resource:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 每个资源状态中的 VisitorsApp CR 使用以下数值：
- en: '`BackendImage`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackendImage`'
- en: Indicates the image and version used to deploy the backend pods
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 指示用于部署后端 Pod 的映像和版本
- en: '`FrontendImage`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrontendImage`'
- en: Indicates the image and version used to deploy the frontend pod
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 指示用于部署前端 Pod 的映像和版本
- en: 'The following snippet from the *visitorsapp_types.go* file demonstrates these
    additions:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*visitorsapp_types.go* 文件的以下片段演示了这些添加：'
- en: '[PRE3]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The remainder of the *visitorsapp_types.go* file does not require any further
    changes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '*visitorsapp_types.go* 文件的其余部分不需要进一步的更改。'
- en: 'After any change to a **_types.go* file, you need to update any generated code
    that works with these objects using the SDK’s `generate` command (from the project’s
    root directory):'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在对**_types.go* 文件进行任何更改后，您需要使用 SDK 的`generate`命令（从项目的根目录）更新与这些对象一起工作的任何生成代码：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The CRD Manifest
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CRD 清单
- en: The additions to the types file are useful within the Operator code, but provide
    no insight to the end user creating the resource. Those additions are made to
    the CRD itself.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类型文件的增加对 Operator 代码非常有用，但不提供给创建资源的最终用户任何洞察力。这些添加是对 CRD 本身进行的。
- en: Similar to the types file, you’ll make the additions to the CRD in the `spec`
    and `status` sections. [Appendix B](app02.html#appendix_crd_validation) describes
    the process of editing these sections.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于类型文件，您将在`spec`和`status`部分中对 CRD 进行增加。附录 B 描述了编辑这些部分的过程。
- en: Operator Permissions
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算权限
- en: In addition to generating a CRD, the Operator SDK creates the RBAC resources
    the Operator needs to run. The generated role is extremely permissive by default,
    and you should refine its granted permissions before you deploy the Operator to
    production. [Appendix C](app03.html#appendix_rbac) covers all of the RBAC-related
    files and talks about how to scope the permissions to what is applicable to the
    Operator.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 除了生成 CRD 外，Operator SDK 还创建 Operator 运行所需的 RBAC 资源。默认情况下，生成的角色权限非常宽松，您应在将 Operator
    部署到生产环境之前优化其授予的权限。附录 C 涵盖了所有与 RBAC 相关的文件，并讨论了如何将权限范围限定于适用于 Operator 的内容。
- en: Controller
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制器
- en: The CRD and its associated types file in Go define the inbound API through which
    users will communicate. Inside of the Operator pod itself, you need a controller
    to watch for changes to CRs and react accordingly.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CRD 及其相关的 Go 类型文件定义了用户将通过其中进行通信的入站 API。在 Operator Pod 内部，您需要一个控制器来监视 CR 的变化并相应地做出反应。
- en: 'Similar to adding a CRD, you use the SDK to generate the controller’s skeleton
    code. You’ll use the `api-version` and `kind` of the previously generated resource
    definition to scope the controller to that type. The following snippet continues
    the Visitors Site example:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加 CRD 类似，您可以使用 SDK 生成控制器的骨架代码。您将使用先前生成的资源定义的`api-version`和`kind`将控制器范围限定到该类型。以下片段继续介绍访客站点示例：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#comarker1-022)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#comarker1-022)'
- en: Note the name of this file. It contains the Kubernetes controller that implements
    the Operator’s custom logic.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意此文件的名称。它包含实现 Operator 自定义逻辑的 Kubernetes 控制器。
- en: As with the CRD, this command generates a number of files. Of particular interest
    is the controller file, which is located and named according to the associated
    `kind`. You do not need to manually edit the other generated files.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 与 CRD 一样，此命令生成多个文件。特别感兴趣的是控制器文件，其根据关联的`kind`进行定位和命名。您无需手动编辑其他生成的文件。
- en: The controller is responsible for “reconciling” a specific resource. The notion
    of a single reconcile operation is consistent with the declarative model that
    Kubernetes follows. Instead of having explicit handling for events such as add,
    delete, or update, the controller is passed the current state of the resource.
    It is up to the controller to determine the set of changes to update reality to
    reflect the desired state described in the resource. More information on Kubernetes
    controllers is found [in the official Kubernetes documentation](https://oreil.ly/E_hau).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器负责“协调”特定资源。单个协调操作的概念与 Kubernetes 遵循的声明模型一致。控制器不会明确处理诸如添加、删除或更新等事件，而是传递资源的当前状态给控制器。由控制器决定要进行的更改集，以更新现实以反映资源描述中所需的状态。有关
    Kubernetes 控制器的更多信息，请参阅[官方 Kubernetes 文档](https://oreil.ly/E_hau)。
- en: In addition to the reconcile logic, the controller also needs to establish one
    or more “watches.” A watch indicates that Kubernetes should invoke this controller
    when changes to the “watched” resources occur. While the bulk of the Operator
    logic resides in the controller’s `Reconcile` function, the `add` function establishes
    the watches that will trigger reconcile events. The SDK adds two such watches
    in the generated controller.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 除了调和逻辑外，控制器还需要建立一个或多个“监视器”。监视器表示当“监视”的资源发生更改时，Kubernetes 应调用此控制器。虽然运算符逻辑的大部分位于控制器的`Reconcile`函数中，但`add`函数建立了将触发调和事件的监视器。SDK
    在生成的控制器中添加了两个这样的监视器。
- en: 'The first watch listens for changes to the primary resource that the controller
    monitors. The SDK generates this watch against resources of the same type as the
    `kind` parameter that was used when first generating the controller. In most cases,
    this does not need to be changed. The following snippet creates the watch for
    the VisitorsApp resource type:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个监视器监听控制器监视的主资源的更改。SDK 根据生成控制器时使用的`kind`参数生成此监视器。在大多数情况下，这不需要更改。以下代码片段创建了
    VisitorsApp 资源类型的监视器：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The second watch, or more accurately, series of watches, listens for changes
    to any child resources the Operator created to support the primary resource. For
    example, creating a VisitorsApp resource results in the creation of multiple deployment
    and service objects to support its function. The controller creates a watch for
    each of these child types, being careful to scope the watch to only child resources
    whose owner is of the same type as the primary resource. For example, the following
    code creates two watches, one for deployments and one for services whose parent
    resource is of the type VisitorsApp:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个监视器，更确切地说，是一系列监视器，用于监听运算符创建以支持主资源的任何子资源的更改。例如，创建 VisitorsApp 资源会导致创建多个部署和服务对象以支持其功能。控制器为每种这些子类型创建一个监视器，注意仅作用于所有者与主资源相同类型的子资源。例如，以下代码创建了两个监视器，一个用于部署，一个用于服务，其父资源类型为
    VisitorsApp：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the watches created in this snippet, there are two areas of interest:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此代码片段创建的监视器，有两个感兴趣的区域：
- en: The value for `Type` in the constructor indicates the child resource type that
    Kubernetes watches. Each child resource type needs its own watch.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数中`Type`的值表示 Kubernetes 监视的子资源类型。每个子资源类型都需要有自己的监视器。
- en: The watches for each of the child resource types set the value for `OwnerType`
    to the primary resource type, scoping the watch and causing Kubernetes to trigger
    a reconcile on the parent resource. Without this, Kubernetes will trigger a reconcile
    on this controller for *all* service and deployment changes, regardless of whether
    or not they belong to the Operator.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个子资源类型的监视器将`OwnerType`的值设置为主资源类型，作用域限定监视器并导致 Kubernetes 触发父资源的调和。如果没有这个设置，Kubernetes
    将对此控制器触发关于*所有*服务和部署更改的调和，而不管它们是否属于运算符。
- en: The Reconcile Function
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调和函数
- en: The `Reconcile` function, also known as the *reconcile loop*, is where the Operator’s
    logic resides. The purpose of this function is to resolve the actual state of
    the system against the desired state requested by the resource. More information
    to help you write this function is included in the next section.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reconcile`函数，也称为*调和循环*，是运算符逻辑所在的地方。此函数的目的是根据资源请求的期望状态解决系统的实际状态。有关帮助编写此函数的更多信息，请参见下一节。'
- en: Warning
  id: totrans-100
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As Kubernetes invokes the `Reconcile` function multiple times throughout the
    lifecycle of a resource, it is important that the implementation be idempotent
    to prevent the creation of duplicate child resources. More information is found
    in [“Idempotency”](#idempotency).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Kubernetes 在资源的生命周期中多次调用`Reconcile`函数，因此实现必须是幂等的，以防止创建重复的子资源。更多信息请参见[“幂等性”](#idempotency)。
- en: 'The `Reconcile` function returns two objects: a `ReconcileResult` instance
    and an error (if one is encountered). These return values indicate whether or
    not Kubernetes should requeue the request. In other words, the Operator tells
    Kubernetes if the reconcile loop should execute again. The possible outcomes based
    on the return values are:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reconcile`函数返回两个对象：一个`ReconcileResult`实例和一个错误（如果有的话）。这些返回值指示 Kubernetes 是否应重新排队请求。换句话说，运算符告诉
    Kubernetes 是否应该再次执行调和循环。基于返回值的可能结果是：'
- en: '`return reconcile.Result{}, nil`'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`return reconcile.Result{}, nil`'
- en: The reconcile process finished with no errors and does not require another pass
    through the reconcile loop.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 调解过程完成且无错误，并且不需要通过调解循环再次进行。
- en: '`return reconcile.Result{}, err`'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`return reconcile.Result{}, err`'
- en: The reconcile failed due to an error and Kubernetes should requeue it to try
    again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 调解由于错误失败，Kubernetes应重新排队以再试。
- en: '`return reconcile.Result{Requeue: true}, nil`'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`return reconcile.Result{Requeue: true}, nil`'
- en: The reconcile did not encounter an error, but Kubernetes should requeue it to
    run for another iteration.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 调解未遇到错误，但Kubernetes应重新排队以进行另一个迭代运行。
- en: '`return reconcile.Result{RequeueAfter: time.Second*5}, nil`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`return reconcile.Result{RequeueAfter: time.Second*5}, nil`'
- en: Similar to the previous result, but this will wait for the specified amount
    of time before requeuing the request. This approach is useful when there are multiple
    steps that must run serially, but may take some time to complete. For example,
    if a backend service needs a running database prior to starting, the reconcile
    can be requeued with a delay to give the database time to start. Once the database
    is running, the Operator does not requeue the reconcile request, and the rest
    of the steps continue.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 与前面的结果类似，但这将在重新排队请求之前等待指定的时间。当必须按顺序运行多个步骤但可能需要一些时间才能完成时，这种方法很有用。例如，如果后端服务在启动之前需要运行数据库，则可以延迟重新排队调解以使数据库有时间启动。一旦数据库运行，操作员就不会重新排队调解请求，其余步骤将继续。
- en: Operator Writing Tips
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作员编写提示
- en: It is impossible to cover all of the conceivable uses and intricacies of Operators
    in a single book. The differences in application installation and upgrade alone
    are too many to enumerate, and those represent only the first two layers of the
    Operator Maturity Model. Instead, we will cover some general guidelines to get
    you started with the basic functions commonly performed by Operators.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在一本书中不可能涵盖所有操作员的可预见用途和复杂性。单单是应用程序的安装和升级的差异就太多了，这些仅代表操作员成熟模型的前两层。相反，我们将介绍一些通常由操作员执行的基本功能的一般指南，以帮助您入门。
- en: Since Go-based Operators make heavy use of the Go Kubernetes libraries, it may
    be useful to review [the API documentation](https://godoc.org/k8s.io/api). In
    particular, the core/v1 and apps/v1 modules are frequently used to interact with
    the common Kubernetes resources.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于基于Go的运算符大量使用Go Kubernetes库，因此审查[API文档](https://godoc.org/k8s.io/api)可能很有用。特别是，核心/v1和apps/v1模块经常用于与常见的Kubernetes资源交互。
- en: Retrieving the Resource
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检索资源
- en: 'The first step the `Reconcile` function typically performs is to retrieve the
    primary resource that triggered the reconcile request. The Operator SDK generates
    the code for this, which should look similar to the following from the Visitors
    Site example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reconcile`函数通常执行的第一步是检索触发调解请求的主资源。Operator SDK为此生成代码，其示例如下所示，类似于Visitors Site示例：'
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO2-1)'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO2-1)'
- en: Populates the previously created VisitorsApp object with the values from the
    resource that triggered the reconcile.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用触发调解的资源的值填充先前创建的VisitorsApp对象。
- en: '[![2](assets/2.png)](#co_operators_in_go_with_the_operator_sdk_CO2-2)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_operators_in_go_with_the_operator_sdk_CO2-2)'
- en: The variable `r` is the reconciler object the `Reconcile` function is called
    on. It provides the client object, which is an authenticated client for the Kubernetes
    API.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 变量`r`是调解器对象，`Reconcile`函数在其上调用。它提供了客户端对象，该对象是Kubernetes API的经过身份验证的客户端。
- en: '[![3](assets/3.png)](#co_operators_in_go_with_the_operator_sdk_CO2-3)'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_operators_in_go_with_the_operator_sdk_CO2-3)'
- en: When a resource is deleted, Kubernetes still calls the `Reconcile` function,
    in which case the `Get` call returns an error. In this example, the Operator requires
    no further cleanup of deleted resources and simply returns that the reconcile
    was a success. We provide more information on handling deleted resources in [“Child
    Resource Deletion”](#child_resource_del).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当资源被删除时，Kubernetes仍然调用`Reconcile`函数，在这种情况下，`Get`调用会返回错误。在此示例中，操作员不需要进一步清理已删除的资源，只需返回调解成功即可。我们在[“子资源删除”](#child_resource_del)中提供有关处理已删除资源的更多信息。
- en: 'The retrieved instance serves two primary purposes:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 检索到的实例有两个主要目的：
- en: Retrieving configuration values about the resource from its `Spec` field
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其`Spec`字段中检索有关资源配置值
- en: Setting the current state of the resource using its `Status` field, and saving
    that updated information into Kubernetes
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用其`Status`字段设置资源的当前状态，并将更新后的信息保存到Kubernetes中。
- en: 'In addition to the `Get` function, the client provides a function to update
    a resource’s values. When updating a resource’s `Status` field, you’ll use this
    function to persist the changes to the resource back into Kubernetes. The following
    snippet updates one of the fields in the previously retrieved VisitorsApp instance’s
    status and saves the changes back into Kubernetes:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`Get`函数外，客户端还提供了一个更新资源值的函数。当更新资源的`Status`字段时，你将使用此函数将更改持久化到Kubernetes中。以下代码片段更新了先前检索到的VisitorsApp实例状态中的一个字段，并将更改保存回Kubernetes：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Child Resource Creation
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子资源创建
- en: One of the first tasks commonly implemented in an Operator is to deploy the
    resources necessary to get the application running. It is critical that this operation
    be idempotent; subsequent calls to the `Reconcile` function should ensure the
    resource is running rather than creating duplicate resources.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作员常见的第一个任务中，是部署必要的资源以使应用程序运行起来。这个操作至关重要，必须是幂等的；对`Reconcile`函数的后续调用应确保资源正在运行，而不是创建重复的资源。
- en: 'These child resources commonly include, but are not limited to, deployment
    and service objects. The handling for them is similar and straightforward: check
    to see if the resource is present in the namespace and, if it is not, create it.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这些子资源通常包括但不限于部署和服务对象。它们的处理方式类似且简单：检查命名空间中资源是否存在，如果不存在，则创建。
- en: 'The following example snippet checks for the existence of a deployment in the
    target namespace:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码片段检查目标命名空间中是否存在部署：
- en: '[PRE10]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO3-1)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO3-1)'
- en: The Operator knows the names of the child resources it created, or at least
    how to derive them (see [“Child Resource Naming”](#child_resource_naming) for
    a more in-depth discussion). In real use cases, `"myDeployment"` is replaced with
    the same name the Operator used when the deployment was created, taking care to
    ensure uniqueness relative to the namespace as appropriate.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员知道它创建的子资源的名称，或者至少知道如何推断它们（详见[“子资源命名”](#child_resource_naming)进行更深入的讨论）。在实际用例中，`"myDeployment"`将被替换为操作员在创建部署时使用的相同名称，需要确保相对于命名空间的唯一性。
- en: '[![2](assets/2.png)](#co_operators_in_go_with_the_operator_sdk_CO3-2)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_operators_in_go_with_the_operator_sdk_CO3-2)'
- en: The `instance` variable was set in the earlier snippet about resource retrieval
    and refers to the object representing the primary resource being reconciled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`instance`变量是关于资源检索的早期片段中设置的，并且指代表示正在协调的主资源的对象。'
- en: '[![3](assets/3.png)](#co_operators_in_go_with_the_operator_sdk_CO3-3)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_operators_in_go_with_the_operator_sdk_CO3-3)'
- en: At this point, the child resource was not found and no further errors were retrieved
    from the Kubernetes API, so the resource creation logic should be executed.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，未找到子资源，并且从Kubernetes API中未检索到进一步的错误，因此应执行资源创建逻辑。
- en: The Operator creates resources by populating the necessary Kubernetes objects
    and using the client to request that they be created. Consult the Kubernetes Go
    client API for specifications on how to instantiate the resource for each type.
    You’ll find many of the desired specs in either the core/v1 or the apps/v1 module.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 操作员通过填充必要的Kubernetes对象并使用客户端请求创建资源。请查阅Kubernetes Go客户端API以获取每种类型资源实例化的规范。你可以在core/v1或者apps/v1模块中找到许多所需的规范。
- en: 'As an example, the following snippet creates a deployment specification for
    the MySQL database used in the Visitors Site example application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下代码片段创建了访客网站示例应用程序中使用的MySQL数据库的部署规范：
- en: '[PRE11]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO4-1)'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO4-1)'
- en: In many cases, the Operator would read the number of deployed pods from the
    primary resource’s spec. For simplicity, this is hardcoded to `1` in this example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，操作员将从主资源的规范中读取部署的Pod数目。为简单起见，在此示例中，将其硬编码为`1`。
- en: '[![2](assets/2.png)](#co_operators_in_go_with_the_operator_sdk_CO4-2)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_operators_in_go_with_the_operator_sdk_CO4-2)'
- en: This is the value used in the earlier snippet when you are attempting to see
    if the deployment exists.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试查看部署是否存在时，这就是在前面片段中使用的值。
- en: '[![3](assets/3.png)](#co_operators_in_go_with_the_operator_sdk_CO4-3)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_operators_in_go_with_the_operator_sdk_CO4-3)'
- en: For this example, these are hardcoded values. Take care to generate randomized
    values as appropriate.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例，这些是硬编码的值。请注意根据需要生成随机化值。
- en: '[![4](assets/4.png)](#co_operators_in_go_with_the_operator_sdk_CO4-4)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_operators_in_go_with_the_operator_sdk_CO4-4)'
- en: This is, arguably, the most important line in the definition. It establishes
    the parent/child relationship between the primary resource (VisitorsApp) and the
    child (deployment). Kubernetes uses this relationship for certain operations,
    as you’ll see in the following section.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以说是定义中最重要的一行。它建立了主资源（VisitorsApp）与子资源（deployment）之间的父/子关系。Kubernetes使用此关系执行某些操作，如下一节所示。
- en: The structure of the Go representation of the deployment closely resembles the
    YAML definition. Again, consult the API documentation for the specifics on how
    to use the Go object models.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: deployment的Go表示结构与YAML定义紧密相关。再次查阅API文档，了解如何使用Go对象模型的具体细节。
- en: 'Regardless of the child resource type (deployment, service, etc.), create it
    using the client:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 无论子资源类型是部署、服务等，都要使用客户端创建它：
- en: '[PRE12]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Child Resource Deletion
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子资源删除
- en: 'In most cases, deleting child resources is significantly simpler than creating
    them: Kubernetes will do it for you. If the child resource’s owner type is correctly
    set to the primary resource, when the parent is deleted, Kubernetes garbage collection
    will automatically clean up all of its child resources.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，删除子资源比创建它们简单得多：Kubernetes会为您完成。如果子资源的所有者类型正确设置为主资源，则在删除父资源时，Kubernetes垃圾回收将自动清理其所有子资源。
- en: It is important to understand that when Kubernetes deletes a resource, it still
    calls the `Reconcile` function. Kubernetes garbage collection is still performed,
    and the Operator will not be able to retrieve the primary resource. See [“Retrieving
    the Resource”](#retrieving_resource) for an example of the code that checks for
    this situation.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，当Kubernetes删除资源时，仍会调用`Reconcile`函数。仍然执行Kubernetes垃圾回收，并且运算符将无法检索到主资源。请参见[“检索资源”](#retrieving_resource)中检查此情况的代码示例。
- en: There are times, however, where specific cleanup logic is required. The approach
    in such instances is to block the deletion of the primary resource through the
    use of a *finalizer*.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在某些情况下，需要特定的清理逻辑。在这种情况下的方法是通过使用*finalizer*阻止主资源的删除。
- en: A finalizer is simply a series of strings on a resource. If one or more finalizers
    are present on a resource, the `metadata.deletionTimestamp` field of the object
    is populated, signifying the end user’s desire to delete the resource. However,
    Kubernetes will only perform the actual deletion once all of the finalizers are
    removed.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: finalizer只是资源上的一系列字符串。如果一个或多个finalizer存在于资源上，则对象的`metadata.deletionTimestamp`字段将被填充，表示最终用户希望删除该资源。然而，只有当所有finalizer都被移除后，Kubernetes才会执行实际的删除。
- en: Using this construct, you can block the garbage collection of a resource until
    the Operator has a chance to perform its own cleanup step. Once the Operator has
    finished with the necessary cleanup, it removes the finalizer, unblocking Kubernetes
    from performing its normal deletion steps.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此结构，您可以阻止资源的垃圾回收，直到运算符有机会执行自己的清理步骤。一旦运算符完成了必要的清理工作，它将删除finalizer，解除Kubernetes执行其正常删除步骤的阻塞。
- en: 'The following snippet demonstrates using a finalizer to provide a window in
    which the Operator can take pre-deletion steps. This code executes after the retrieval
    of the instance object, as outlined in [“Retrieving the Resource”](#retrieving_resource):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段演示了使用finalizer提供一个窗口，其中运算符可以执行预删除步骤。此代码在检索实例对象之后执行，如[“检索资源”](#retrieving_resource)中所述：
- en: '[PRE13]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO5-1)'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_operators_in_go_with_the_operator_sdk_CO5-1)'
- en: The presence of a deletion timestamp indicates that a requested delete is being
    blocked by one or more finalizers.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 删除时间戳的存在表明，一个或多个finalizer正在阻止所请求的删除。
- en: '[![2](assets/2.png)](#co_operators_in_go_with_the_operator_sdk_CO5-2)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_operators_in_go_with_the_operator_sdk_CO5-2)'
- en: Once the cleanup tasks have finished, the Operator removes the finalizer so
    Kubernetes can continue with the resource cleanup.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦清理任务完成，运算符会删除finalizer，因此Kubernetes可以继续进行资源清理。
- en: Child Resource Naming
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子资源命名
- en: 'While the end user provides the name of the CR when creating it, the Operator
    is responsible for generating the names of any child resources it creates. Take
    into consideration the following principles when creating these names:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然最终用户在创建 CR 时提供 CR 的名称，但操作员负责生成它创建的任何子资源的名称。在创建这些名称时，请考虑以下原则：
- en: Resource names must be unique within a given namespace.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源名称在给定命名空间内必须是唯一的。
- en: Child resource names should be dynamically generated. Hardcoding child resource
    names leads to conflicts if there are multiple resources of the CR type in the
    same namespace.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子资源名称应动态生成。如果在同一命名空间中存在多个相同类型的资源，则硬编码子资源名称会导致冲突。
- en: Child resource names must be reproducible and consistent. An Operator may need
    to access a resource’s children in a future iteration through the reconcile loop
    and must be able to reliably retrieve those resources by name.
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子资源名称必须可复制和一致。在未来迭代中，操作员可能需要通过协调循环访问资源的子项，并且必须能够可靠地通过名称检索这些资源。
- en: Idempotency
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 幂等性
- en: One of the biggest hurdles many developers face when writing controllers is
    the idea that Kubernetes uses a *declarative* API. End users don’t issue commands
    that Kubernetes immediately fulfills. Instead, they request an end state that
    the cluster should achieve.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发人员在编写控制器时面临的最大障碍之一是 Kubernetes 使用*声明式*API 的概念。最终用户不会立即发出 Kubernetes 立即执行的命令。相反，他们请求集群应达到的最终状态。
- en: As such, the interface for controllers (and by extension, Operators) doesn’t
    include imperative commands such as “add resource” or “change a configuration
    value.” Instead, Kubernetes simply asks the controller to reconcile the state
    of a resource. The Operator then determines what steps, if any, it will take to
    ensure that end state.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，控制器（及其扩展的操作员）的接口不包括“添加资源”或“更改配置值”等命令。相反，Kubernetes 只是要求控制器协调资源的状态。然后，操作员确定要采取哪些步骤（如果有的话）以确保达到最终状态。
- en: Therefore, it is critical that Operators are *idempotent*. Multiple calls to
    reconcile an unchanged resource must produce the same effect each time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，操作员的*幂等性*至关重要。对于未更改的资源的多次协调请求，必须每次产生相同的效果。
- en: 'The following tips can help you ensure idempotency in your Operators:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下提示可以帮助您确保操作员中的幂等性：
- en: Before creating child resources, check to see if they already exist. Remember,
    Kubernetes may call the reconcile loop for a variety of reasons beyond when a
    user first creates a CR. Your controller should not duplicate the CR’s children
    on each iteration through the loop.
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建子资源之前，请检查它们是否已存在。请记住，Kubernetes 可能出于各种原因调用协调循环，而不仅仅是在用户首次创建 CR 时。因此，您的控制器不应在每次循环迭代中复制
    CR 的子资源。
- en: Changes to a resource’s spec (in other words, its configuration values) trigger
    the reconcile loop. Therefore, it is often not enough to simply check for the
    existence of expected child resources. The Operator also needs to verify that
    the child resource configuration matches what is defined in the parent resource
    at the time of reconciliation.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对资源规范（即其配置值）的更改会触发协调循环。因此，仅仅检查预期子资源的存在通常是不够的。操作员还需要验证，在协调时，子资源配置是否与父资源中定义的相匹配。
- en: Reconciliation is not necessarily called for each change to the resource. It
    is possible that a single reconciliation may contain multiple changes. The Operator
    must be careful to ensure the entire state of the CR is represented by all of
    its child resources.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非每次对资源的更改都会调用协调。可能一次协调中包含多个更改。操作员必须小心确保所有子资源都代表了 CR 的整个状态。
- en: Just because an Operator does not need to make changes during a reconciliation
    request doesn’t mean it doesn’t need to update the CR’s `Status` field. Depending
    on what values are captured in the CR’s status, it may make sense to update these
    even if the Operator determines it doesn’t need to make any changes to the existing
    resources.
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使操作员确定不需要对现有资源进行任何更改，也不意味着它不需要更新 CR 的`Status`字段。根据 CR 状态中捕获的值，可能有必要更新这些值，即使操作员确定不需要对现有资源进行任何更改。
- en: Operator Impact
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作员的影响
- en: It is important to be aware of the impact your Operator will have on the cluster.
    In most cases, your Operator will create one or more resources. It also needs
    to communicate with the cluster through the Kubernetes APIs. If the Operator incorrectly
    handles these operations, they can negatively affect the performance of the entire
    cluster.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到您的 Operator 将对集群产生的影响。在大多数情况下，您的 Operator 将创建一个或多个资源。它还需要通过 Kubernetes
    API 与集群进行通信。如果 Operator 错误处理这些操作，可能会对整个集群的性能产生负面影响。
- en: 'How best to handle this varies from Operator to Operator. There is no set of
    rules that you can run through to ensure your Operator doesn’t overburden your
    cluster. However, you can use the following guidelines as a starting point to
    analyze your Operator’s approach:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 如何处理这一最佳实践因 Operator 而异。没有一套规则可以确保 Operator 不会过度负担集群。然而，您可以使用以下指南作为分析 Operator
    方法的起点：
- en: Be careful when making frequent calls to the Kubernetes API. Make sure you use
    sensible delays (on the order of seconds rather than milliseconds) when repeatedly
    checking the API for a certain state being met.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在频繁调用 Kubernetes API 时要小心。确保在重复检查 API 以满足特定状态时使用合理的延迟（以秒为单位，而不是毫秒）。
- en: When possible, try not to block the reconcile method for long periods of time.
    If, for instance, you are waiting for a child resource to be available before
    continuing, consider triggering another reconcile after a delay (see [“The Reconcile
    Function”](#reconcile_function) for more information on triggering subsequent
    iterations through the reconcile loop). This approach allows Kubernetes to manage
    its resources instead of having a reconcile request wait for long periods of time.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可能时，尽量不要阻塞调解方法长时间。例如，如果在继续之前等待子资源可用，请考虑在延迟后触发另一个调解（有关触发调解循环中后续迭代的更多信息，请参见 [“调解函数”](#reconcile_function)）。这种方法允许
    Kubernetes 管理其资源，而不是让调解请求长时间等待。
- en: If you are deploying a large number of resources, consider throttling the deployment
    requests across multiple iterations through the reconcile loop. Remember that
    other workloads are running concurrently on the cluster. Your Operator should
    not cause excessive stress on cluster resources by issuing many creation requests
    at once.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要部署大量资源，请考虑通过调解循环的多次迭代来限制部署请求。请记住集群上还同时运行其他工作负载。您的 Operator 不应通过同时发出许多创建请求来对集群资源造成过多压力。
- en: Running an Operator Locally
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本地运行 Operator
- en: The Operator SDK provides a means of running an Operator outside of a running
    cluster. This helps speed up development and testing by removing the need to go
    through the image creation and hosting steps. The process running the Operator
    may be outside of the cluster, but Kubernetes will treat it as it does any other
    controller.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Operator SDK 提供了在运行中的集群之外运行 Operator 的方法。这有助于通过省去镜像创建和托管步骤来加快开发和测试速度。运行 Operator
    的进程可能位于集群之外，但 Kubernetes 将其视为任何其他控制器。
- en: 'The high-level steps for testing an Operator are as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Operator 的高级步骤如下：
- en: '*Deploy the CRD.* You only need to do this once, unless further changes to
    the CRD are needed. In those cases, run the `kubectl` `apply` command again (from
    the Operator project root directory) to apply any changes:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*部署 CRD.* 您只需执行一次此操作，除非需要对 CRD 进行进一步更改。在这些情况下，从 Operator 项目根目录再次运行 `kubectl
    apply` 命令以应用任何更改：'
- en: '[PRE14]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*Start the Operator in local mode.* The Operator SDK uses credentials from
    the `kubectl` configuration file to connect to the cluster and attach the Operator.
    The running process acts as if it were an Operator pod running inside of the cluster
    and writes logging information to standard output:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*以本地模式启动 Operator.* Operator SDK 使用来自 `kubectl` 配置文件的凭据连接到集群并附加 Operator。运行的进程将作为在集群内运行的
    Operator pod，并将日志信息写入标准输出：'
- en: '[PRE15]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `--namespace` flag indicates the namespace in which the Operator will appear
    to be running.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`--namespace` 标志指示 Operator 将显示为运行的命名空间。'
- en: '*Deploy an example resource.* The SDK generates an example CR along with the
    CRD. It is located in the same directory and is named similarly to the CRD, but
    with the filename ending in *_cr.yaml* instead to denote its function.'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*部署示例资源.* SDK 生成了一个示例 CR 和 CRD。它们位于同一目录中，文件名以 *_cr.yaml* 结尾来表示其功能。'
- en: 'In most cases, you’ll want to edit the `spec` section of this file to provide
    the relevant configuration values for your resource. Once the necessary changes
    are made, deploy the CR (from the project root directory) using `kubectl`:'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在大多数情况下，您将希望编辑此文件的 `spec` 部分，以提供资源的相关配置值。完成必要的更改后，使用 `kubectl` 部署 CR（从项目根目录）：
- en: '[PRE16]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*Stop the running Operator process.* Stop the Operator process by pressing
    `Ctrl+C`. Unless the Operator adds finalizers to the CR, this is safe to do before
    deleting the CR itself, as Kubernetes will use the parent/child relationships
    of its resources to clean up any dependent objects.'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*停止正在运行的运算符进程。* 通过按下 `Ctrl+C` 停止运算符进程。除非运算符将 finalizers 添加到 CR 中，在删除 CR 本身之前，这样做是安全的，因为
    Kubernetes 将使用其资源的父/子关系清理任何依赖对象。'
- en: Note
  id: totrans-197
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The process described here is useful for development purposes, but for production,
    Operators are delivered as images. See [Appendix A](app01.html#appendix_operator_as_deployment)
    for more information on how to build and deploy an Operator as a container inside
    the cluster.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 此处描述的流程对于开发目的很有用，但对于生产环境，运算符作为镜像交付。有关如何在集群内作为容器构建和部署运算符的更多信息，请参见 [附录 A](app01.html#appendix_operator_as_deployment)。
- en: Visitors Site Example
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visitors Site 示例
- en: The codebase for the Visitors Site Operator is too large to include. You can
    find the fully built Operator available in [this book’s GitHub repository](https://github.com/kubernetes-operators-book/chapters/tree/master/ch07/visitors-operator).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: Visitors Site 运算符的代码库过大而无法包含。您可以在 [本书的 GitHub 存储库](https://github.com/kubernetes-operators-book/chapters/tree/master/ch07/visitors-operator)
    中找到完整构建的运算符。
- en: 'The Operator SDK generated many of the files in that repository. The files
    that were modified to run the Visitors Site application are:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Operator SDK 生成了该存储库中的许多文件。修改以运行 Visitors Site 应用程序的文件包括：
- en: '*deploy/crds/*'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '*deploy/crds/*'
- en: '*example_v1_visitorsapp_crd.yaml*'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*example_v1_visitorsapp_crd.yaml*'
- en: This file contains the CRD.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此文件包含了 CRD。
- en: '*example_v1_visitorsapp_cr.yaml*'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*example_v1_visitorsapp_cr.yaml*'
- en: This file defines a CR with sensible example data.
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个文件定义了一个带有合理示例数据的 CR。
- en: '*pkg/apis/example/v1/visitorsapp_types.go*'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*pkg/apis/example/v1/visitorsapp_types.go*'
- en: This file contains Go objects that represent the CR, including its `spec` and
    `status` fields.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该文件包含表示 CR 的 Go 对象，包括其 `spec` 和 `status` 字段。
- en: '*pkg/controller/visitorsapp/*'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '*pkg/controller/visitorsapp/*'
- en: '*backend.go*, *frontend.go*, *mysql.go*'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*backend.go*, *frontend.go*, *mysql.go*'
- en: These files contain all of the information specific to deploying those components
    of the Visitors Site. This includes the deployments and services that the Operator
    maintains, as well as the logic to handle updating existing resources when the
    end user changes the CR.
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些文件包含部署 Visitors Site 组件的所有特定信息。这包括运算符维护的部署和服务，以及处理最终用户更改 CR 时更新现有资源的逻辑。
- en: '*common.go*'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*common.go*'
- en: This file contains utility methods used to ensure the deployments and services
    are running, creating them if necessary.
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此文件包含用于确保部署和服务运行的实用方法，必要时创建它们。
- en: '*visitorsapp_controller.go*'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*visitorsapp_controller.go*'
- en: The Operator SDK initially generated this file, which was then modified for
    the Visitors Site–specific logic. The `Reconcile` method contains the majority
    of the changes; it drives the overall flow of the Operator by calling out to functions
    in the previously described files.
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Operator SDK 最初生成了此文件，然后为 Visitors Site 特定逻辑进行了修改。`Reconcile` 方法包含了大部分更改；通过调用先前描述的文件中的函数，它驱动运算符的整体流程。
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概要
- en: Writing an Operator requires a considerable amount of code to tie into Kubernetes
    as a controller. The Operator SDK eases development by generating much of this
    boilerplate code, letting you focus on the business logic aspects. The SDK also
    provides utilities for building and testing Operators, greatly reducing the effort
    needed to go from inception to a running Operator.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个运算符需要大量的代码来将其作为控制器与 Kubernetes 集成。Operator SDK 通过生成大部分样板代码来简化开发，让你专注于业务逻辑方面。SDK
    还提供了构建和测试运算符的实用工具，大大减少了从构思到运行运算符所需的工作量。
- en: Resources
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 资源
- en: '[Kubernetes CR documentation](https://oreil.ly/IwYGV)'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes CR 文档](https://oreil.ly/IwYGV)'
- en: '[Kubernetes API documentation](https://godoc.org/k8s.io/api)'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes API 文档](https://godoc.org/k8s.io/api)'
