<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:epub="http://www.idpf.org/2007/ops" lang="en" xml:lang="en" xsi:schemaLocation="http://www.w3.org/2002/06/xhtml2/ http://www.w3.org/MarkUp/SCHEMA/xhtml2.xsd">
  <head>
    <title>Unknown</title>
    <link rel="stylesheet" type="text/css" href="../stylesheet.css"/>
    <link rel="stylesheet" type="text/css" href="../page_styles.css"/>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  </head>
  <body class="calibre"><div id="sbo-rt-content" class="calibre1"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Container Probes" class="praise"><div class="dedication" id="container_probes">
<h1 class="calibre14"><span class="keep-together">Chapter 14. </span>Container Probes</h1>


<p class="author1">Applications running in containers do not operate under the premise of “fire and forget.” Once Kubernetes starts the container, you’ll want to know if the application is ready for consumption and is still working as expected in an hour, a week, or a month. A health probe is a periodically running mini-process that asks the application for its status and takes action upon certain conditions.</p>

<p class="author1">In this chapter, we’ll discuss container health probes—more specifically, readiness, liveness, and startup probes. You’ll learn about the different health verification methods and how to define them for the proper use cases.</p>
<aside data-type="sidebar" epub:type="sidebar" class="calibre48"><div class="sidebar" id="id483">
<h1 class="calibre49">Coverage of Curriculum Objectives</h1>
<p class="author1">This chapter addresses the following curriculum objective:</p>

<ul class="printings">
<li class="calibre13">
<p class="author1">Implement probes and health checks</p>
</li>
</ul>
</div></aside>






<section data-type="sect1" data-pdf-bookmark="Working with Probes" class="praise"><div class="dedication" id="id302">
<h1 class="calibre17">Working with Probes</h1>

<p class="author1">Even with the best testing strategy, it’s nearly impossible to find all bugs before deploying software to a production environment. That’s especially true for failure situations that occur only after operating the software for an extended period of time. It’s not uncommon to see memory leaks, deadlocks, infinite loops, and similar conditions crop up once end users put the application under load.</p>

<p class="author1">Proper monitoring can help with identifying those issues; however, you still need to act to mitigate the situation. First, you’ll likely want to restart the application to prevent further outages. Second, the development team needs to identify the underlying root cause and fix the application’s code.</p>








<section data-type="sect2" data-pdf-bookmark="Probe Types" class="praise"><div class="dedication" id="id303">
<h2 class="calibre33">Probe Types</h2>

<p class="author1">Kubernetes provides a concept called <em class="calibre3">health probing</em> to automate the detection and correction of such issues. You can configure a container to execute a periodic mini-process that checks for certain conditions. These processes are defined as follows:</p>
<dl class="calibre18">
<dt class="calibre19">Readiness probe</dt>
<dd class="calibre20">
<p class="calibre21">Even after an application has started up, it may still need to execute configuration procedures—for example, connecting to a database and preparing data. This probe checks if the application is ready to serve incoming requests. <a data-type="xref" href="#readiness_probe" class="calibre10">Figure 14-1</a> shows the readiness probe.</p>

<figure class="calibre35"><div id="readiness_probe" class="figure">
<img src="Images/ckd2_1401.png" alt="ckd2 1401" class="calibre94"/>
<h6 class="calibre32"><span class="keep-together">Figure 14-1. </span>A readiness probe checks if the application is ready to accept traffic</h6>
</div></figure>
</dd>
<dt class="calibre19">Liveness probe</dt>
<dd class="calibre20">
<p class="calibre21">Once the application is running, you want to make sure that it still works as expected without issues. This probe periodically checks for the application’s responsiveness. Kubernetes restarts the container automatically if the probe considers the application be in an unhealthy state, as shown in <a data-type="xref" href="#liveness_probe" class="calibre10">Figure 14-2</a>.</p>

<figure class="calibre35"><div id="liveness_probe" class="figure">
<img src="Images/ckd2_1402.png" alt="ckd2 1402" class="calibre95"/>
<h6 class="calibre32"><span class="keep-together">Figure 14-2. </span>A liveness probe checks if the application is healthy</h6>
</div></figure>
</dd>
<dt class="calibre19">Startup probe</dt>
<dd class="calibre20">
<p class="calibre21">Legacy applications in particular can take a long time to start up—possibly several minutes. A startup probe can be instantiated to wait for a predefined amount of time before a liveness probe is allowed to start probing. By setting up a startup probe, you can prevent the application process from being overwhelmed with probing requests. Startup probes kill the container if the application can’t start within the set time frame. <a data-type="xref" href="#startup_probe" class="calibre10">Figure 14-3</a> illustrates the behavior of a startup probe.</p>

<figure class="calibre35"><div id="startup_probe" class="figure">
<img src="Images/ckd2_1403.png" alt="ckd2 1403" class="calibre96"/>
<h6 class="calibre32"><span class="keep-together">Figure 14-3. </span>A startup probe holds off on starting the liveness probe</h6>
</div></figure>
</dd>
</dl>

<p class="author1">From an operational perspective, the most important probe to implement is the readiness probe. Without defining liveness and startup probes, the Kubernetes control plane components will handle the majority of the default behavior.</p>

<p class="author1">Each probe offers distinct methods to verify the health of a container, discussed in the next section.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Health Verification Methods" class="praise"><div class="dedication" id="id304">
<h2 class="calibre33">Health Verification Methods</h2>

<p class="author1">You can define one or many of the health verification methods for a container. <a data-type="xref" href="#available_health_verification_methods" class="calibre10">Table 14-1</a> describes the available health verification methods, their corresponding YAML attribute, and their runtime behavior.</p>
<table id="available_health_verification_methods" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 14-1. </span>Available health verification methods</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Method</th>
<th class="calibre63">Option</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1">Custom command</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">exec.command</code></p></td>
<td class="calibre65"><p class="author1">Executes a command inside the container (e.g., a <code class="calibre60">cat</code> command) and checks its exit code. Kubernetes considers a zero exit code to be successful. A non-zero exit code indicates an error.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1">HTTP GET request</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">httpGet</code></p></td>
<td class="calibre65"><p class="author1">Sends an HTTP GET request to an endpoint exposed by the application. An HTTP response code in the range of 200 to 399 indicates success. Any other response code is regarded as an error.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1">TCP socket connection</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">tcpSocket</code></p></td>
<td class="calibre65"><p class="author1">Tries to open a TCP socket connection to a port. If the connection could be established, the probing attempt was successful. The inability to connect is accounted for as an error.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1">gRPC</p></td>
<td class="calibre65"><p class="author1"><code class="calibre60">grpc</code></p></td>
<td class="calibre65"><p class="author1">The application implements the <a href="https://github.com/grpc/grpc/blob/master/doc/health-checking.md" class="calibre10">GRPC Health Checking Protocol</a>, which verifies whether the server is able to handle a Remote Procedure Call (RPC).</p></td>
</tr>
</tbody>
</table>

<p class="author1">Remember that you can combine any probe with any health check method. The health verification method you choose highly depends on the type of application you are running in the container. For example, the obvious choice for a web-based application is to use the HTTP GET request verification method.</p>
</div></section>








<section data-type="sect2" data-pdf-bookmark="Health Check Attributes" class="praise"><div class="dedication" id="id305">
<h2 class="calibre33">Health Check Attributes</h2>

<p class="author1">Every probe offers a set of attributes that can further configure the runtime behavior, as shown in <a data-type="xref" href="#attributes_for_fine_tuning_the_health_check_runtime_behavior" class="calibre10">Table 14-2</a>. For more information, see the API of the <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.28/#probe-v1-core" class="calibre10">Probe v1 core</a> object.</p>
<table id="attributes_for_fine_tuning_the_health_check_runtime_behavior" class="calibre58">
<caption class="calibre59"><span class="keep-together">Table 14-2. </span>Attributes for fine-tuning the health check runtime behavior</caption>
<thead class="calibre61">
<tr class="calibre62">
<th class="calibre63">Attribute</th>
<th class="calibre63">Default value</th>
<th class="calibre63">Description</th>
</tr>
</thead>
<tbody class="calibre64">
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">initialDelaySeconds</code></p></td>
<td class="calibre65"><p class="author1">0</p></td>
<td class="calibre65"><p class="author1">Delay in seconds until first check is executed.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">periodSeconds</code></p></td>
<td class="calibre65"><p class="author1">10</p></td>
<td class="calibre65"><p class="author1">Interval for executing a check (e.g., every 20 seconds).</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">timeoutSeconds</code></p></td>
<td class="calibre65"><p class="author1">1</p></td>
<td class="calibre65"><p class="author1">Maximum number of seconds until check operation times out.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">successThreshold</code></p></td>
<td class="calibre65"><p class="author1">1</p></td>
<td class="calibre65"><p class="author1">Number of successful check attempts until probe is considered successful after a failure.</p></td>
</tr>
<tr class="calibre62">
<td class="calibre65"><p class="author1"><code class="calibre60">failureThreshold</code></p></td>
<td class="calibre65"><p class="author1">3</p></td>
<td class="calibre65"><p class="author1">Number of failures for check attempts before probe is marked failed and action taken.</p></td>
</tr>
<tr class="calibre66">
<td class="calibre65"><p class="author1"><code class="calibre60">terminationGracePeriodSeconds</code></p></td>
<td class="calibre65"><p class="author1">30</p></td>
<td class="calibre65"><p class="author1">Grace period before forcing a container to stop upon failure.</p></td>
</tr>
</tbody>
</table>

<p class="author1">The following sections will demonstrate the usage of most verification methods for different probe types.</p>
</div></section>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The Readiness Probe" class="praise"><div class="dedication" id="id306">
<h1 class="calibre17">The Readiness Probe</h1>

<p class="author1">In this scenario, we’ll want to define a readiness probe for a Node.js application. The Node.js application exposes an HTTP endpoint on the root context path and runs on port 3000. Dealing with a web-based application makes an HTTP GET request a perfect fit for probing its readiness. You can find the source code of the application in the book’s GitHub repository.</p>

<p class="author1">In the YAML manifest shown in <a data-type="xref" href="#readiness_probe_example" class="calibre10">Example 14-1</a>, the readiness probe executes its first check after two seconds and repeats checking every eight seconds thereafter. All other attributes use the default values. A readiness probe will continue to periodically check, even after the application has been successfully started.</p>
<div id="readiness_probe_example" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 14-1. </span>A readiness probe that uses an HTTP GET request</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w">
</code><code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w">
</code><code class="nt">metadata</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">readiness-pod</code><code class="w">
</code><code class="nt">spec</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w">
</code><code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">bmuschko/nodejs-hello-world:1.0.0</code><code class="w">
</code><code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">hello-world</code><code class="w">
</code><code class="w">    </code><code class="nt">ports</code><code class="p">:</code><code class="w">
</code><code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nodejs-port</code><code class="w">     </code><a class="calibre10" id="co_container_probes_CO1-1" href="#callout_container_probes_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a><code class="w">
</code><code class="w">      </code><code class="nt">containerPort</code><code class="p">:</code><code class="w"> </code><code class="calibre15">3000</code><code class="w">
</code><code class="w">    </code><code class="nt">readinessProbe</code><code class="p">:</code><code class="w">
</code><code class="w">      </code><code class="nt">httpGet</code><code class="p">:</code><code class="w">
</code><code class="w">        </code><code class="nt">path</code><code class="p">:</code><code class="w"> </code><code class="calibre15">/</code><code class="w">
</code><code class="w">        </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre15">nodejs-port</code><code class="w">   </code><a class="calibre10" id="co_container_probes_CO1-2" href="#callout_container_probes_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a><code class="w">
</code><code class="w">      </code><code class="nt">initialDelaySeconds</code><code class="p">:</code><code class="w"> </code><code class="calibre15">2</code><code class="w">
</code><code class="w">      </code><code class="nt">periodSeconds</code><code class="p">:</code><code class="w"> </code><code class="calibre15">8</code></pre></div>
<dl class="calibre18">
<dt class="calibre52"><a class="calibre10" id="callout_container_probes_CO1-1" href="#co_container_probes_CO1-1"><img src="Images/1.png" alt="1" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">You can assign a name to a port so that it can be referenced in a probe.</p></dd>
<dt class="calibre52"><a class="calibre10" id="callout_container_probes_CO1-2" href="#co_container_probes_CO1-2"><img src="Images/2.png" alt="2" class="calibre51"/></a></dt>
<dd class="calibre20"><p class="calibre53">Instead of assigning port 3000 again, we simply use the port name.</p></dd>
</dl>

<p class="author1">Create a Pod by pointing the <code class="calibre15">apply</code> command to the YAML 
<span class="keep-together">manifest.</span> During the Pod’s startup process, it’s possible that the status shows <code class="calibre15">Running</code> but the container isn’t ready to accept incoming requests, as indicated by <code class="calibre15">0/1</code> in the <code class="calibre15">READY</code> column:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f readiness-probe.yaml</strong>
pod/readiness-pod created
<strong class="calibre38">$ kubectl get pod readiness-pod</strong>
NAME                READY   STATUS    RESTARTS   AGE
pod/readiness-pod   0/1     Running   0          6s
<strong class="calibre38">$ kubectl get pod readiness-pod</strong>
NAME                READY   STATUS    RESTARTS   AGE
pod/readiness-pod   1/1     Running   0          68s
<strong class="calibre38">$ kubectl describe pod readiness-pod</strong>
...
Containers:
  hello-world:
    ...
    Readiness:      http-get http://:nodejs-port/ delay=2s timeout=1s \
                    period=8s #success=1 #failure=3
...
</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The Liveness Probe" class="praise"><div class="dedication" id="id307">
<h1 class="calibre17">The Liveness Probe</h1>

<p class="author1">A liveness probe checks if the application is still working as expected. To demonstrate a liveness probe, we’ll use a custom command. A custom command is the most flexible way to verify the health of a container, as it allows for calling any command available to the container. This can be either a command-line tool that comes with the base image or a tool that you install as part of the containerization process.</p>

<p class="author1">In <a data-type="xref" href="#liveness_probe_example" class="calibre10">Example 14-2</a>, we’ll have the application create and update a file, <em class="calibre3">/tmp/heartbeat.txt</em>, to show that it’s still alive. We’ll do this by making it run the Unix <code class="calibre15">touch</code> command every five seconds. The probe will periodically check if the modification timestamp of the file is older than one minute. If it is, then Kubernetes can assume that the application isn’t functioning as expected and will restart the container.</p>
<div id="liveness_probe_example" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 14-2. </span>A liveness probe that uses a custom command</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">liveness-pod</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">busybox:1.36.1</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">app</code><code class="w"></code>
<code class="w">    </code><code class="nt">args</code><code class="p">:</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">/bin/sh</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">-c</code><code class="w"></code>
<code class="w">    </code><code class="calibre15">-</code><code class="w"> </code><code class="s">'while</code><code class="nv"> </code><code class="s">true;</code><code class="nv"> </code><code class="s">do</code><code class="nv"> </code><code class="s">touch</code><code class="nv"> </code><code class="s">/tmp/heartbeat.txt;</code><code class="nv"> </code><code class="s">sleep</code><code class="nv"> </code><code class="s">5;</code><code class="nv"> </code><code class="s">done;'</code><code class="w"></code>
<code class="w">    </code><code class="nt">livenessProbe</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">exec</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">command</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="calibre15">-</code><code class="w"> </code><code class="calibre15">test `find /tmp/heartbeat.txt -mmin -1`</code><code class="w"></code>
<code class="w">      </code><code class="nt">initialDelaySeconds</code><code class="p">:</code><code class="w"> </code><code class="calibre15">5</code><code class="w"></code>
<code class="w">      </code><code class="nt">periodSeconds</code><code class="p">:</code><code class="w"> </code><code class="calibre15">30</code><code class="w"></code></pre></div>

<p class="author1">The next command uses the YAML manifest shown in <a data-type="xref" href="#liveness_probe_example" class="calibre10">Example 14-2</a>, stored in the file <em class="calibre3">liveness-probe.yaml</em>, to create the Pod. Describing the Pod renders information on the liveness probe. We can not only inspect the custom command and its configuration, but also see how many times the container has been restarted upon a probing failure:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f liveness-probe.yaml</strong>
pod/liveness-pod created
<strong class="calibre38">$ kubectl get pod liveness-pod</strong>
NAME               READY   STATUS    RESTARTS   AGE
pod/liveness-pod   1/1     Running   0          22s
<strong class="calibre38">$ kubectl describe pod liveness-pod</strong>
...
Containers:
  app:
    ...
    Restart Count:  0
    Liveness:       exec [test `find /tmp/heartbeat.txt -mmin -1`] delay=5s \
                    timeout=1s period=30s #success=1 #failure=3
...
</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="The Startup Probe" class="praise"><div class="dedication" id="id308">
<h1 class="calibre17">The Startup Probe</h1>

<p class="author1">The purpose of a startup probe is to figure out when an application is fully started. Defining the probe is useful for an application that takes a long time to start up. The kubelet puts the readiness and liveness probes on hold while the startup probe is running. A startup probe finishes its operation under one of the following conditions:</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">If it can verify that the application has been started</p>
</li>
<li class="calibre56">
<p class="author1">If the application doesn’t respond within the timeout period</p>
</li>

</ol>

<p class="author1">To demonstrate the functionality of the startup probe, <a data-type="xref" href="#startup_probe_example" class="calibre10">Example 14-3</a> defines a Pod that runs the <a href="https://hub.docker.com/_/httpd" class="calibre10">Apache HTTP server</a> in a container. By default, the image exposes the container port 80, and that’s what we’re probing for using a TCP socket connection.</p>
<div id="startup_probe_example" data-type="example" class="calibre45">
<h5 class="calibre46"><span class="keep-together">Example 14-3. </span>A startup probe that uses a TCP socket connection</h5>

<pre data-type="programlisting" data-code-language="yaml" class="calibre47"><code class="nt">apiVersion</code><code class="p">:</code><code class="w"> </code><code class="calibre15">v1</code><code class="w"></code>
<code class="nt">kind</code><code class="p">:</code><code class="w"> </code><code class="calibre15">Pod</code><code class="w"></code>
<code class="nt">metadata</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">startup-pod</code><code class="w"></code>
<code class="nt">spec</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="nt">containers</code><code class="p">:</code><code class="w"></code>
<code class="w">  </code><code class="calibre15">-</code><code class="w"> </code><code class="nt">image</code><code class="p">:</code><code class="w"> </code><code class="calibre15">httpd:2.4.46</code><code class="w"></code>
<code class="w">    </code><code class="nt">name</code><code class="p">:</code><code class="w"> </code><code class="calibre15">http-server</code><code class="w"></code>
<code class="w">    </code><code class="nt">startupProbe</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="nt">tcpSocket</code><code class="p">:</code><code class="w"></code>
<code class="w">        </code><code class="nt">port</code><code class="p">:</code><code class="w"> </code><code class="calibre15">80</code><code class="w"></code>
<code class="w">      </code><code class="nt">initialDelaySeconds</code><code class="p">:</code><code class="w"> </code><code class="calibre15">3</code><code class="w"></code>
<code class="w">      </code><code class="nt">periodSeconds</code><code class="p">:</code><code class="w"> </code><code class="calibre15">15</code><code class="w"></code>
<code class="w">    </code><code class="nt">livenessProbe</code><code class="p">:</code><code class="w"></code>
<code class="w">      </code><code class="p">...</code><code class="w"></code></pre></div>

<p class="author1">As you can see in the following terminal output, the <code class="calibre15">describe</code> command can retrieve the configuration of a startup probe as well:</p>
<pre data-type="programlisting" class="calibre37">
<strong class="calibre38">$ kubectl apply -f startup-probe.yaml</strong>
pod/startup-pod created
<strong class="calibre38">$ kubectl get pod startup-pod</strong>
NAME              READY   STATUS    RESTARTS   AGE
pod/startup-pod   1/1     Running   0          31s
<strong class="calibre38">$ kubectl describe pod startup-pod</strong>
...
Containers:
  http-server:
     ...
     Startup:        tcp-socket :80 delay=3s timeout=1s period=15s \
                     #success=1 #failure=3
...
</pre>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Summary" class="praise"><div class="dedication" id="id309">
<h1 class="calibre17">Summary</h1>

<p class="author1">In this chapter, we looked at all available health probe types you can define for a Pod. A health probe is a periodically running mini-process that asks the application running in a container for its status. Think of it as taking the pulse of your system.</p>

<p class="author1">The readiness probe ensures that the container accepts incoming traffic only if the application runs properly. The liveness probe makes sure that the application is functioning as expected and will restart the container if necessary. The startup probe pauses a liveness probe until application startup has been completed. In practice, you’ll often find that a container defines all three probes.</p>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Exam Essentials" class="praise"><div class="dedication" id="id310">
<h1 class="calibre17">Exam Essentials</h1>
<dl class="calibre18">
<dt class="calibre19">Understand the purpose of all probes</dt>
<dd class="calibre20">
<p class="calibre21">To prepare for this section of the exam, focus on understanding and using health probes. You should understand the purpose of startup, readiness, and liveness probes and practice how to configure them. In your Kubernetes cluster, try to emulate success and failure conditions to see the effects of probes and the actions they take.</p>
</dd>
<dt class="calibre19">Practice the use of different verification methods</dt>
<dd class="calibre20">
<p class="calibre21">You can choose from a variety of verification methods applicable to probes. Gain a high-level understanding when to apply which verification method, and how to configure each one of them.</p>
</dd>
</dl>
</div></section>






<section data-type="sect1" data-pdf-bookmark="Sample Exercises" class="praise"><div class="dedication" id="id311">
<h1 class="calibre17">Sample Exercises</h1>

<p class="author1">Solutions to these exercises are available in <a href="app01_split_010.xhtml#appendix_a_container_probes" class="calibre10">Appendix A</a>.</p>
<ol class="calibre55">
<li class="calibre56">
<p class="author1">Define a new Pod named <code class="calibre15">web-server</code> with the image <code class="calibre15">nginx:1.23.0</code> in a YAML manifest. Expose the container port 80. Do not create the Pod yet.</p>

<p class="author1">For the container, declare a startup probe of type <code class="calibre15">httpGet</code>. Verify that the kubelet can make a request to the root context endpoint. Use the default configuration for the probe.</p>

<p class="author1">For the container, declare a readiness probe of type <code class="calibre15">httpGet</code>.Verify that the kubelet can make a request to the root context endpoint. Wait five seconds before checking for the first time.</p>

<p class="author1">For the container, declare a liveness probe of type <code class="calibre15">httpGet</code>. Verify that the kubelet can make a request to the root context endpoint. Wait 10 seconds before checking for the first time. The probe should run the check every 30 seconds.</p>

<p class="author1">Create the Pod and follow the life cycle phases of the Pod during the process.</p>

<p class="author1">Inspect the runtime details of the Pod’s probes.</p>
</li>

</ol>
</div></section>
</div></section></div></body>
</html>