<html><head></head><body><section data-pdf-bookmark="Chapter 4. Specificity, Inheritance, and the Cascade" data-type="chapter" epub:type="chapter"><div class="chapter" id="specificity_comma_inheritance">&#13;
<h1><span class="label">Chapter 4. </span>Specificity, Inheritance, and the Cascade</h1>&#13;
&#13;
&#13;
<p>Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#selectors">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#pseudo_classes_and_elements">3</a> showed how document structure and CSS selectors allow you to apply a wide variety of styles to elements. Knowing that every valid document generates a structural tree, you can create selectors that target elements based on their ancestors, attributes, sibling elements, and more. The structural tree is what allows selectors to function and is also central to a similarly crucial aspect of CSS: inheritance.</p>&#13;
&#13;
<p><em>Inheritance</em> is the <a data-primary="inheritance" data-type="indexterm" id="idm45176127846496"/><a data-primary="rules" data-secondary="cascade" data-type="indexterm" id="idm45176127845760"/><a data-primary="rules" data-secondary="inheritance" data-type="indexterm" id="idm45176127844816"/><a data-primary="CSS (Cascading Style Sheets)" data-secondary="cascade" data-type="indexterm" id="idm45176127843872"/><a data-primary="cascade" data-type="indexterm" id="idm45176127842960"/>mechanism by which some property values are passed on from an element to a descendant element. When determining which values should apply to an element, a user agent must consider not only inheritance but also the <em>specificity</em> of the declarations, as well as the origin of the declarations themselves. This process of consideration is what’s known as the <em>cascade</em>.</p>&#13;
&#13;
<p>We will explore the interrelation between these three mechanisms—specificity, inheritance, and the cascade—in this chapter. For now, the difference between the latter two can be summed up this way: when we write <code>h1 {color: red; color: blue;}</code>, the <code>&lt;h1&gt;</code> becomes blue because of the cascade, and any <code>&lt;span&gt;</code> inside the <code>&lt;h1&gt;</code> also becomes blue because of inheritance.</p>&#13;
&#13;
<p>Above all, regardless of how abstract things may seem, keep going! Your perseverance will be rewarded.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Specificity" data-type="sect1"><div class="sect1" id="specificity">&#13;
<h1>Specificity</h1>&#13;
&#13;
<p>You <a data-primary="selectors" data-secondary="specificity" data-type="indexterm" id="ix_selector_specificity"/><a data-primary="specificity" data-type="indexterm" id="ix_specificity_ch4"/><a data-primary="CSS (Cascading Style Sheets)" data-secondary="specificity" data-type="indexterm" id="ix_css_specificity_ch4"/>know from Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch02.html#selectors">2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch03.html#pseudo_classes_and_elements">3</a> that you can select elements by using a wide variety of means. In fact, the same element can often be selected by two or more rules, each with its own selector. Let’s consider the following three pairs of rules. Assume that each pair will match the same element:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">body</code> <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">green</code><code class="p">;}</code>&#13;
&#13;
<code class="nt">h2</code><code class="nc">.grape</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
&#13;
<code class="nt">html</code> <code class="o">&gt;</code> <code class="nt">body</code> <code class="nt">table</code> <code class="nt">tr</code><code class="o">[</code><code class="nt">id</code><code class="o">=</code><code class="s2">"totals"</code><code class="o">]</code> <code class="nt">td</code> <code class="nt">ul</code> <code class="o">&gt;</code> <code class="nt">li</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code>&#13;
<code class="nt">li</code><code class="nf">#answer</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">navy</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Only one of the two rules in each pair can be applied, or “win,” since the matched elements can be only one color at a time. How do we know which one will win?</p>&#13;
&#13;
<p>The answer is found in the <em>specificity</em> of each selector. For every rule, the user agent (i.e., a web browser) evaluates the specificity of the selector and attaches the specificity to each declaration in the rule within the cascade layer that has precedence. When an element has two or more conflicting property declarations, the one with the highest specificity will win out.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This isn’t the whole story in terms of conflict resolution, which is a bit more complicated than a single paragraph can cover. For now, just keep in mind that selector specificity is compared only to other selectors that share the same origin and cascade layer. We’ll cover those terms, and more in <a data-type="xref" href="#the_cascade">“The Cascade”</a>.</p>&#13;
</div>&#13;
&#13;
<p>A selector’s specificity is determined by the components of the selector itself. A specificity value can be expressed in three parts, like this: <code>0,0,0</code>. The actual specificity of a selector is determined as follows:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>For every ID attribute value given in the selector, add <code>1,0,0</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>For every class attribute value, attribute selection, or pseudo-class given in the selector, add <code>0,1,0</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>For every element and pseudo-element given in the selector, add <code>0,0,1</code>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Combinators do not contribute anything to the specificity.</p>&#13;
</li>&#13;
<li>&#13;
<p>Anything listed inside a <code>:where()</code> pseudo-class, and the universal selector, adds <code>0,0,0</code>. (While they do not contribute anything to the specificity weight, they do match elements, unlike combinators.)</p>&#13;
</li>&#13;
<li>&#13;
<p>The <a data-primary=":not() pseudo-class" data-primary-sortas="not() pseudo-class" data-type="indexterm" id="idm45176133192544"/><a data-primary=":has() pseudo-class" data-primary-sortas="has() pseudo-class" data-type="indexterm" id="idm45176133191536"/>specificity of an <code>:is()</code>, <code>:not()</code>, or <code>:has()</code> pseudo-class is equal to the specificity of the most specific selector in its selector list argument.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>For example, the following rules’ selectors result in the indicated specificities:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>                     <code class="c">/* specificity = 0,0,1 */</code>&#13;
<code class="nt">p</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>                <code class="c">/* specificity = 0,0,2 */</code>&#13;
<code class="nc">.grape</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>              <code class="c">/* specificity = 0,1,0 */</code>&#13;
<code class="o">*</code><code class="nc">.bright</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;}</code>            <code class="c">/* specificity = 0,1,0 */</code>&#13;
<code class="nt">p</code><code class="nc">.bright</code> <code class="nt">em</code><code class="nc">.dark</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code>    <code class="c">/* specificity = 0,2,2 */</code>&#13;
<code class="nf">#id216</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>                <code class="c">/* specificity = 1,0,0 */</code>&#13;
<code class="o">*</code><code class="nd">:is</code><code class="o">(</code><code class="nt">aside</code><code class="nf">#warn</code><code class="o">,</code> <code class="nt">code</code><code class="o">)</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code> <code class="c">/* specificity = 1,0,1 */</code>&#13;
<code class="nt">div</code><code class="nf">#sidebar</code> <code class="o">*[</code><code class="nt">href</code><code class="o">]</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code> <code class="c">/* specificity = 1,1,1 */</code></pre>&#13;
&#13;
<p>If an <code>&lt;em&gt;</code> element is matched by both the second and fifth rules in this example, that element will be maroon because the sixth rule’s specificity outweighs the second’s.</p>&#13;
&#13;
<p>Take <a data-primary=":is() pseudo-class" data-primary-sortas="is() pseudo-class" data-type="indexterm" id="idm45176133120032"/>special note of the next-to-last selector, <code>*:is(aside#warn, code)</code>.  The <code>:is()</code> pseudo-class is one of a small group of pseudo-classes for which the specificity is equal to the most specific selector in the selector list.  Here, the selector list is <code>aside#warn, code</code>.  The <code>aside#warn</code> compound selector has a specificity of <code>1,0,1</code>, and the <code>code</code> selector has a specificity of <code>0,0,1</code>.  Thus, the whole <code>:is()</code> portion of the selector is set to the specificity of the <code>aside#warn</code> selector.</p>&#13;
&#13;
<p>Now, let’s return to the pairs of rules from earlier in the section and fill in the specificities:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>         <code class="c">/* 0,0,1 */</code>&#13;
<code class="nt">body</code> <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">green</code><code class="p">;}</code>  <code class="c">/* 0,0,2 (winner)*/</code>&#13;
&#13;
<code class="nt">h2</code><code class="nc">.grape</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>  <code class="c">/* 0,1,1 (winner) */</code>&#13;
<code class="nt">h2</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>        <code class="c">/* 0,0,1 */</code>&#13;
&#13;
<code class="nt">html</code> <code class="o">&gt;</code> <code class="nt">body</code> <code class="nt">table</code> <code class="nt">tr</code><code class="o">[</code><code class="nt">id</code><code class="o">=</code><code class="s2">"totals"</code><code class="o">]</code> <code class="nt">td</code> <code class="nt">ul</code> <code class="o">&gt;</code> <code class="nt">li</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code>  <code class="c">/* 0,1,7 */</code>&#13;
<code class="nt">li</code><code class="nf">#answer</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">navy</code><code class="p">;}</code>                                       <code class="c">/* 1,0,1</code>&#13;
<code class="c">   (winner) */</code></pre>&#13;
&#13;
<p>We’ve indicated the winning rule in each pair; in each case, it’s because the specificity is higher. Notice how they’re listed and that the order of the rules doesn’t matter here.</p>&#13;
&#13;
<p>In the second pair, the selector <code>h2.grape</code> wins because it has an extra class: <code>0,1,1</code> beats out <code>0,0,1</code>. In the third pair, the second rule wins because <code>1,0,1</code> wins out over <code>0,1,7</code>. In fact, the specificity value <code>0,1,0</code> would win out over the value <code>0,0,13</code>.</p>&#13;
&#13;
<p>This happens because the values are compared from left to right. A specificity of <code>1,0,0</code> will win out over any specificity that begins with a <code>0</code>, no matter what the rest of the numbers might be. So <code>1,0,1</code> wins over <code>0,1,7</code> because the <code>1</code> in the first value’s first position beats the <code>0</code> in the second value’s first position.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Declarations and Specificity" data-type="sect2"><div class="sect2" id="declarations_and_specificity">&#13;
<h2>Declarations and Specificity</h2>&#13;
&#13;
<p>Once the <a data-primary="specificity" data-secondary="declarations" data-type="indexterm" id="ix_specificity_declar"/><a data-primary="declarations" data-secondary="specificity" data-type="indexterm" id="ix_declar_specific"/>specificity of a selector has been determined, the specificity value will be conferred on all of its associated declarations. Consider this rule:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<p>For specificity purposes, the user agent must treat the rule as if it were “ungrouped” into separate rules. Thus, the previous example would become the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Both have a specificity of <code>0,0,1</code>, and that’s the value conferred on each declaration. The same splitting-up process happens with a grouped selector as well. Given the rule,</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code><code class="o">,</code> <code class="nt">h2</code><code class="nc">.section</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<p>the user agent treats it as if it were the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>             <code class="c">/* 0,0,1 */</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>         <code class="c">/* 0,0,1 */</code>&#13;
<code class="nt">h2</code><code class="nc">.section</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>     <code class="c">/* 0,1,1 */</code>&#13;
<code class="nt">h2</code><code class="nc">.section</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code> <code class="c">/* 0,1,1 */</code></pre>&#13;
&#13;
<p>This becomes important when multiple rules match the same element and some of the declarations clash. For example, consider these rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="o">+</code> <code class="nt">p</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code> <code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>              <code class="c">/* 0,0,2 */</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">font-style</code><code class="o">:</code> <code class="n">normal</code><code class="p">;}</code> <code class="c">/* 0,0,1 */</code>&#13;
<code class="o">*</code><code class="nc">.callout</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>           <code class="c">/* 0,1,0 */</code></pre>&#13;
&#13;
<p>When applied to the following markup, the content will be rendered as shown in <a data-type="xref" href="#how_different_rules_affect_a_document">Figure 4-1</a>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1&gt;</code>Greetings!<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"callout"</code><code class="nt">&gt;</code><code class="w"/>&#13;
It's<code class="w"> </code>a<code class="w"> </code>fine<code class="w"> </code>way<code class="w"> </code>to<code class="w"> </code>start<code class="w"> </code>a<code class="w"> </code>day,<code class="w"> </code>don't<code class="w"> </code>you<code class="w"> </code>think?<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
There<code class="w"> </code>are<code class="w"> </code>many<code class="w"> </code>ways<code class="w"> </code>to<code class="w"> </code>greet<code class="w"> </code>a<code class="w"> </code>person,<code class="w"> </code>but<code class="w"> </code>the<code class="w"> </code>words<code class="w"> </code>are<code class="w"> </code>not<code class="w"> </code>as<code class="w"> </code>important<code class="w"/>&#13;
as<code class="w"> </code>the<code class="w"> </code>act<code class="w"> </code>of<code class="w"> </code>greeting<code class="w"> </code>itself.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;h1&gt;</code>Salutations!<code class="nt">&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
There<code class="w"> </code>is<code class="w"> </code>nothing<code class="w"> </code>finer<code class="w"> </code>than<code class="w"> </code>a<code class="w"> </code>hearty<code class="w"> </code>welcome<code class="w"> </code>from<code class="w"> </code>one's<code class="w"> </code>neighbor.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p</code><code class="w"> </code><code class="na">class=</code><code class="s">"callout"</code><code class="nt">&gt;</code><code class="w"/>&#13;
Although<code class="w"> </code>a<code class="w"> </code>steaming<code class="w"> </code>pot<code class="w"> </code>of<code class="w"> </code>fresh-made<code class="w"> </code>jambalaya<code class="w"> </code>runs<code class="w"> </code>a<code class="w"> </code>close<code class="w"> </code>second.<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure><div class="figure" id="how_different_rules_affect_a_document">&#13;
<img alt="css5 0401" src="assets/css5_0401.png"/>&#13;
<h6><span class="label">Figure 4-1. </span>How different rules affect a document</h6>&#13;
</div></figure>&#13;
&#13;
<p>In every <a data-primary="rules" data-secondary="cascade" data-type="indexterm" id="idm45176132608640"/>case, the user agent determines which rules match a given element, calculates all of the associated declarations and their specificities, determines which rules win out, and then applies the winners to the element to get the styled result. These machinations must be performed on every element, selector, and declaration. Fortunately, the user agent does it all automatically and nearly instantly. This behavior is an important component of the cascade, which we’ll discuss later in this chapter.<a data-primary="" data-startref="ix_declar_specific" data-type="indexterm" id="idm45176132607504"/><a data-primary="" data-startref="ix_specificity_declar" data-type="indexterm" id="idm45176132606560"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Resolving Multiple Matches" data-type="sect2"><div class="sect2" id="multiple_matches">&#13;
<h2>Resolving Multiple Matches</h2>&#13;
&#13;
<p>When an <a data-primary="specificity" data-secondary="multiple match resolution" data-type="indexterm" id="idm45176132603840"/>element is matched by more than one selector in a grouped selector, the most specific selector is used.  Consider the following CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">li</code><code class="o">,</code>            <code class="c">/* 0,0,1 */</code>&#13;
<code class="nc">.quirky</code><code class="o">,</code>       <code class="c">/* 0,1,0 */</code>&#13;
<code class="nf">#friendly</code><code class="o">,</code>     <code class="c">/* 1,0,0 */</code>&#13;
<code class="nt">li</code><code class="nc">.happy.happy.happy</code><code class="nf">#friendly</code> <code class="p">{</code> <code class="c">/* 1,3,1 */</code>&#13;
   <code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here we have one rule with a grouped selector, and each of the individual selectors has a very different specificity.  Now suppose we find this in our HTML:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;li</code><code class="w"> </code><code class="na">class=</code><code class="s">"happy quirky"</code><code class="w"> </code><code class="na">id=</code><code class="s">"friendly"</code><code class="nt">&gt;</code>This<code class="w"> </code>will<code class="w"> </code>be<code class="w"> </code>blue.<code class="nt">&lt;/li&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Every one of the selectors in the grouped selector applies to the list item!  Which one is used for specificity purposes?  The most specific.  Thus, in this example, the blue is applied with a specificity of <code>1,3,1</code>.</p>&#13;
&#13;
<p>You might have noticed that we repeated the <code>happy</code> class name three times in one of the selectors.  This is a bit of hack that can be used with classes, attributes, pseudo-classes, and even ID selectors to increase specificity.  Do be careful with it, since artificially inflating specificity can create problems in the future: you might want to override that rule with another, and that rule will need even more classes chained together.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Zeroed Selector Specificity" data-type="sect2"><div class="sect2" id="zeroed_selector_specificity">&#13;
<h2>Zeroed Selector Specificity</h2>&#13;
&#13;
<p>The <a data-primary="zeroed selector specificity" data-type="indexterm" id="idm45176132550560"/><a data-primary="specificity" data-secondary="zeroed selector" data-type="indexterm" id="idm45176132549856"/><a data-primary="* (asterisk)" data-secondary="universal selector" data-type="indexterm" id="idm45176132548912"/><a data-primary="selectors" data-secondary="universal" data-type="indexterm" id="idm45176132547968"/><a data-primary="asterisk (*)" data-secondary="universal selector" data-type="indexterm" id="idm45176132547024"/><a data-primary="universal selector (*)" data-secondary="zeroed selector specificity)" data-type="indexterm" id="idm45176132546080"/>universal selector does not contribute to specificity. It has a specificity of <code>0,0,0</code>, which is different from having no specificity (as we’ll discuss in <a data-type="xref" href="#inheritance">“Inheritance”</a>). Therefore, given the following two rules, a paragraph descended from a <code>&lt;div&gt;</code> will be black, but all other elements will be gray:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">div</code> <code class="nt">p</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code> <code class="c">/* 0,0,2 */</code>&#13;
<code class="o">*</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>      <code class="c">/* 0,0,0 */</code></pre>&#13;
&#13;
<p>This means the specificity of a selector that contains a universal selector along with other selectors is not changed by the presence of the universal selector. The following two selectors have exactly the same specificity:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="n">div</code> <code class="n">p</code>         <code class="c">/* 0,0,2 */</code>&#13;
<code class="n">body</code> <code class="o">*</code> <code class="n">strong</code> <code class="c">/* 0,0,2 */</code></pre>&#13;
&#13;
<p>The <a data-primary=":where() pseudo-class" data-primary-sortas="where() pseudo-class" data-type="indexterm" id="idm45176132458160"/>same is true for the <code>:where()</code> pseudo-class, regardless of whatever selectors might be in its selector list.  Thus, <code>:where(aside#warn, code)</code> has a specificity of <code>0,0,0</code>.</p>&#13;
&#13;
<p>Combinators, <a data-primary="combinators" data-secondary="specificity and" data-type="indexterm" id="idm45176132470672"/>including <code>~</code>, <code>&gt;</code>, <code>+</code>, and the space character, have no specificity at all—not even zero specificity. Thus, they have no impact on a selector’s overall specificity.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ID and Attribute Selector Specificity" data-type="sect2"><div class="sect2" id="id_and_attribute_selector_specificity">&#13;
<h2>ID and Attribute Selector Specificity</h2>&#13;
&#13;
<p>It’s <a data-primary="id attribute" data-type="indexterm" id="idm45176132430736"/><a data-primary="ID selectors" data-type="indexterm" id="idm45176132430000"/><a data-primary="specificity" data-secondary="ID selector and attribute" data-type="indexterm" id="idm45176132429328"/><a data-primary="attribute selectors" data-secondary="specificity" data-type="indexterm" id="idm45176132428416"/>important to note the difference in specificity between an ID selector and an attribute selector that targets an <code>id</code> attribute. Returning to the third pair of rules in the example code, we find the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">html</code> <code class="o">&gt;</code> <code class="nt">body</code> <code class="nt">table</code> <code class="nt">tr</code><code class="o">[</code><code class="nt">id</code><code class="o">=</code><code class="s2">"totals"</code><code class="o">]</code> <code class="nt">td</code> <code class="nt">ul</code> <code class="o">&gt;</code> <code class="nt">li</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code> <code class="c">/* 0,1,7 */</code>&#13;
<code class="nt">li</code><code class="nf">#answer</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">navy</code><code class="p">;}</code>                                      <code class="c">/* 1,0,1 (wins) */</code></pre>&#13;
&#13;
<p>The ID selector (<code>#answer</code>) in the second rule contributes <code>1,0,0</code> to the overall specificity of the selector. In the first rule, however, the attribute selector (<code>[id="totals"]</code>) contributes <code>0,1,0</code> to the overall specificity. Thus, given the following rules, the element with an <code>id</code> of <code>meadow</code> will be green:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#meadow</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">green</code><code class="p">;}</code>      <code class="c">/* 1,0,0 */</code>&#13;
<code class="o">*[</code><code class="nt">id</code><code class="o">=</code><code class="s2">"meadow"</code><code class="o">]</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code> <code class="c">/* 0,1,0 */</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Importance" data-type="sect2"><div class="sect2" id="importance">&#13;
<h2>Importance</h2>&#13;
&#13;
<p>Sometimes a <a data-primary="specificity" data-secondary="importance of" data-type="indexterm" id="ix_specificity_imp"/><a data-primary="rules" data-secondary="declarations" data-type="indexterm" id="ix_rules_declar_imp"/><a data-primary="declarations" data-secondary="important" data-type="indexterm" id="ix_declar_important"/><a data-primary="important declarations" data-type="indexterm" id="ix_import_declar"/><a data-primary="! (exclamation point)" data-secondary="in !important flag" data-type="indexterm" id="idm45176132329104"/><a data-primary="exclamation point (!)" data-secondary="in !important flag" data-type="indexterm" id="idm45176132328160"/><a data-primary="!important flag" data-primary-sortas="important flag" data-type="indexterm" id="idm45176132327216"/>declaration is so important that it outweighs all other considerations. CSS calls these <em>important declarations</em> (for hopefully obvious reasons) and lets you mark them by inserting the flag <code>!important</code> just before the terminating semicolon in a declaration:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.dark</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="m">#333</code> <code class="cp">!important</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Here, the color value of <code>#333</code> is marked with the <code>!important</code> flag, whereas the background value of <code>white</code> is not. If you wish to mark both declarations as important, each declaration needs its own <code>!important</code> flag:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.dark</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="m">#333</code> <code class="cp">!important</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">white</code> <code class="cp">!important</code><code class="p">;}</code></pre>&#13;
&#13;
<p>You must place the <code>!important</code> flag correctly, or the declaration may be invalidated: &#13;
<span class="keep-together"><code>!important</code></span> <em>always</em> goes at the end of a declaration, just before the semicolon. This placement is especially critical when it comes to properties that allow values containing multiple keywords, such as <code>font</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code><code class="nc">.light</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;</code> <code class="k">font</code><code class="o">:</code> <code class="nb">smaller</code> <code class="n">Times</code><code class="o">,</code> <code class="nb">serif</code> <code class="cp">!important</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If <code>!important</code> were placed anywhere else in the <code>font</code> declaration, the entire declaration would likely be invalidated and none of its styles applied.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>We realize that to those of you who come from a programming background, the syntax of this token instinctively translates to “not important.” For whatever reason, the bang (<code>!</code>) was chosen as the delimiter for important flags, and it does <em>not</em> mean “not” in CSS, no matter how many other languages give it that very meaning. This association is unfortunate, but we’re stuck with it.</p>&#13;
</div>&#13;
&#13;
<p>Declarations that are marked <code>!important</code> do not have a special specificity value, but are instead considered separately from unimportant declarations. In effect, all <code>!important</code> &#13;
<span class="keep-together">declarations</span> are grouped together, and specificity conflicts are resolved within that group. Similarly, all unimportant declarations are considered as a group, with any conflicts within the unimportant group as described previously. Thus, in any case where an important and an unimportant declaration conflict, an important declaration will always win (unless the user agent or user have declared the same property as important, which you’ll see later in the chapter).</p>&#13;
&#13;
<p><a data-type="xref" href="#important_rules_always_win">Figure 4-2</a> illustrates the result of the following rules and markup fragment:<a data-primary="" data-startref="ix_import_declar" data-type="indexterm" id="idm45176132197120"/><a data-primary="" data-startref="ix_declar_important" data-type="indexterm" id="idm45176132196176"/><a data-primary="" data-startref="ix_rules_declar_imp" data-type="indexterm" id="idm45176132195232"/><a data-primary="" data-startref="ix_specificity_imp" data-type="indexterm" id="idm45176132194288"/></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;</code> <code class="k">color</code><code class="o">:</code> <code class="nb">gray</code> <code class="cp">!important</code><code class="p">;}</code>&#13;
<code class="nc">.title</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="o">*</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">black</code> <code class="cp">!important</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1</code><code class="w"> </code><code class="na">class=</code><code class="s">"title"</code><code class="nt">&gt;</code>NightWing<code class="nt">&lt;/h1&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult bordernone"><div class="figure" id="important_rules_always_win">&#13;
<img alt="css5 0402" src="assets/css5_0402.png"/>&#13;
<h6><span class="label">Figure 4-2. </span>Important rules always win</h6>&#13;
</div></figure>&#13;
<div data-type="warning" epub:type="warning"><h6>Warning</h6>&#13;
<p>It’s generally bad practice to use <code>!important</code> in your CSS, and it is rarely needed.  If you find yourself reaching for <code>!important</code>, stop and look for other ways to get the same result without using &#13;
<span class="keep-together"><code>!important</code>.</span>  Cascade layers are one such possibility; see <a data-type="xref" href="#sorting_by_layer">“Sorting by Cascade Layer”</a> for more details.<a data-primary="" data-startref="ix_css_specificity_ch4" data-type="indexterm" id="idm45176132145840"/><a data-primary="" data-startref="ix_selector_specificity" data-type="indexterm" id="idm45176132103216"/><a data-primary="" data-startref="ix_specificity_ch4" data-type="indexterm" id="idm45176132102272"/></p>&#13;
</div>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Inheritance" data-type="sect1"><div class="sect1" id="inheritance">&#13;
<h1>Inheritance</h1>&#13;
&#13;
<p>Another <a data-primary="rules" data-secondary="inheritance" data-type="indexterm" id="ix_rules_inherit"/><a data-primary="document structure" data-secondary="inheritance based on" data-type="indexterm" id="ix_doc_struct_inherit"/><a data-primary="inheritance" data-type="indexterm" id="ix_inherit_ch4"/><a data-primary="CSS (Cascading Style Sheets)" data-secondary="inheritance" data-type="indexterm" id="ix_css_inherit"/>key concept in understanding how styles are applied to elements is <em>inheritance</em>. Inheritance is the mechanism by which some styles are applied not only to a specified element, but also to its descendants. If a color is applied to an <code>&lt;h1&gt;</code> element, for example, that color is applied to all text inside the <code>&lt;h1&gt;</code>, even the text enclosed within child elements of that <code>&lt;h1&gt;</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1&gt;</code>Meerkat<code class="w"> </code><code class="nt">&lt;em&gt;</code>Central<code class="nt">&lt;/em&gt;&lt;/h1&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Both the ordinary <code>&lt;h1&gt;</code> text and the <code>&lt;em&gt;</code> text are colored gray because the <code>&lt;em&gt;</code> element inherits the value of <code>color</code> from the <code>&lt;h1&gt;</code>. If property values could not be inherited by descendant elements, the <code>&lt;em&gt;</code> text would be black, not gray, and we’d have to color the elements separately.</p>&#13;
&#13;
<p>Consider an unordered list. Let’s say we apply a style of <code>color: gray;</code> for <code>&lt;ul&gt;</code> elements:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">ul</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>We expect that style applied to a <code>&lt;ul&gt;</code> will also be applied to its list items, as well as to any content of those list items, including the marker (i.e., the bullet next to each list item). Thanks to inheritance, that’s exactly what happens, as <a data-type="xref" href="#inheritance_of_styles">Figure 4-3</a> demonstrates.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="inheritance_of_styles">&#13;
<img alt="css5 0403" src="assets/css5_0403.png"/>&#13;
<h6><span class="label">Figure 4-3. </span>Inheritance of styles</h6>&#13;
</div></figure>&#13;
&#13;
<p>It’s easier to see how inheritance works by turning to a tree diagram of a document. <a data-type="xref" href="#a_simple_tree_diagram">Figure 4-4</a> shows the tree diagram for a document much like the very simple document shown in <a data-type="xref" href="#inheritance_of_styles">Figure 4-3</a>.</p>&#13;
&#13;
<figure><div class="figure" id="a_simple_tree_diagram">&#13;
<img alt="css5 0404" src="assets/css5_0404.png"/>&#13;
<h6><span class="label">Figure 4-4. </span>A simple tree diagram</h6>&#13;
</div></figure>&#13;
&#13;
<p>When the declaration <code>color: gray;</code> is applied to the <code>&lt;ul&gt;</code> element, that element takes on that declaration. The value is then propagated down the tree to the descendant elements and continues on until no more descendants remain to inherit the value. Values are <em>never</em> propagated upward; an element never passes values up to its ancestors.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The <a data-primary="backgrounds" data-secondary="applying styles in HTML" data-type="indexterm" id="idm45176132005280"/><a data-primary="HTML" data-secondary="upward propagation rule exception" data-type="indexterm" id="idm45176131986144"/>upward propagation rule in HTML has a notable exception: background styles applied to the <code>&lt;body&gt;</code> element can be passed to the <code>&lt;html&gt;</code> element, which is the document’s root element and therefore defines its canvas. This happens only if the <code>&lt;body&gt;</code> element has a defined background and the <code>&lt;html&gt;</code> element does not. A few other properties share this body-to-root behavior, such as <code>overflow</code>, but it happens only with the <code>&lt;body&gt;</code> element. No other elements risk inheriting properties from a descendant.</p>&#13;
</div>&#13;
&#13;
<p>Inheritance is one of those things about CSS that is so basic that you almost never think about it unless you have to. However, you should still keep a couple of things in mind.</p>&#13;
&#13;
<p>First, note that many <a data-primary="borders" data-secondary="inheritance risks with" data-type="indexterm" id="idm45176131981568"/>properties are not inherited—generally in order to avoid undesirable outcomes. For example, the property <code>border</code> (which is used to set borders on elements) does not inherit. A quick glance at <a data-type="xref" href="#why_borders_arenat_inherited">Figure 4-5</a> reveals why this is the case. If borders were inherited, documents would become much more cluttered—unless the author took the extra effort to turn off the inherited borders.</p>&#13;
&#13;
<figure class="bordernone"><div class="figure" id="why_borders_arenat_inherited">&#13;
<img alt="css5 0405" src="assets/css5_0405.png"/>&#13;
<h6><span class="label">Figure 4-5. </span>Why borders aren’t inherited</h6>&#13;
</div></figure>&#13;
&#13;
<p>As it happens, most of the <a data-primary="box-model properties" data-type="indexterm" id="idm45176131976528"/>box-model properties—including margins, padding, backgrounds, and borders—are not inherited for the same reason. After all, you likely wouldn’t want all of the links in a paragraph to inherit a 30-pixel left margin from their parent element!</p>&#13;
&#13;
<p>Second, inherited values have no specificity at all, not even zero specificity. This seems like an academic distinction until you work through the consequences of the lack of inherited specificity. Consider the following rules and markup fragment and compare them to the result shown in <a data-type="xref" href="#zero_specificity_defeats_no_specificity">Figure 4-6</a>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="o">*</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">h1</code><code class="nf">#page-title</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1</code><code class="w"> </code><code class="na">id=</code><code class="s">"page-title"</code><code class="nt">&gt;</code>Meerkat<code class="w"> </code><code class="nt">&lt;em&gt;</code>Central<code class="nt">&lt;/em&gt;&lt;/h1&gt;</code><code class="w"/>&#13;
<code class="nt">&lt;p&gt;</code><code class="w"/>&#13;
Welcome<code class="w"> </code>to<code class="w"> </code>the<code class="w"> </code>best<code class="w"> </code>place<code class="w"> </code>on<code class="w"> </code>the<code class="w"> </code>web<code class="w"> </code>for<code class="w"> </code>meerkat<code class="w"> </code>information!<code class="w"/>&#13;
<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="zero_specificity_defeats_no_specificity">&#13;
<img alt="css5 0406" src="assets/css5_0406.png"/>&#13;
<h6><span class="label">Figure 4-6. </span>Zero specificity defeats no specificity</h6>&#13;
</div></figure>&#13;
&#13;
<p>Since the <a data-primary="specificity" data-secondary="lack of in universal selector" data-type="indexterm" id="idm45176131900080"/><a data-primary="* (asterisk)" data-secondary="universal selector" data-type="indexterm" id="idm45176131899104"/><a data-primary="selectors" data-secondary="universal" data-type="indexterm" id="idm45176131898160"/><a data-primary="asterisk (*)" data-secondary="universal selector" data-type="indexterm" id="idm45176131897216"/><a data-primary="universal selector (*)" data-secondary="inheritance and)" data-type="indexterm" id="idm45176131896272"/>universal selector applies to all elements and has zero specificity, its color declaration’s value of <code>gray</code> wins out over the inherited value of <code>black</code>, which has no specificity at all. (And now you may understand why we listed <code>:where()</code> and the universal selector as having <code>0,0,0</code> specificity: they add no weight, but do match elements.) Therefore, the <code>&lt;em&gt;</code> element is rendered gray instead of black.</p>&#13;
&#13;
<p>This example vividly illustrates one of the potential problems of using the universal selector indiscriminately. Because it can match <em>any</em> element or pseudo-element, the universal selector often has the effect of short-circuiting inheritance. This can be worked around, but it’s usually more sensible to avoid the problem in the first place by not using the universal selector by itself indiscriminately.</p>&#13;
&#13;
<p>The complete lack of specificity for inherited values is not a trivial point. For example, assume that a stylesheet has been written such that all text in a toolbar is to be white on black:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#toolbar</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This will work so long as the element with an <code>id</code> of <code>toolbar</code> contains nothing but plain text. If, however, the text within this element is all hyperlinks (<code>a</code> elements), then the user agent’s styles for hyperlinks will take over. In a web browser, this means they’ll likely be colored blue, since the browser’s internal stylesheet probably contains an entry like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code></pre>&#13;
&#13;
<p>To overcome this problem, you must declare something like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#toolbar</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nf">#toolbar</code> <code class="nt">a</code><code class="nd">:any-link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;}</code></pre>&#13;
&#13;
<p>By targeting a rule directly at the <code>a</code> elements within the toolbar, you’ll get the result shown in <a data-type="xref" href="#directly_assigning_styles_to_the_relevan">Figure 4-7</a>.</p>&#13;
&#13;
<figure><div class="figure" id="directly_assigning_styles_to_the_relevan">&#13;
<img alt="css5 0407" src="assets/css5_0407.png"/>&#13;
<h6><span class="label">Figure 4-7. </span>Directly assigning styles to the relevant elements</h6>&#13;
</div></figure>&#13;
&#13;
<p>Another way to get the same result is to use the value <code>inherit</code>, covered in the next chapter. We can alter the previous example like so:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nf">#toolbar</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">white</code><code class="p">;</code> <code class="k">background</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>&#13;
<code class="nf">#toolbar</code> <code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">inherit</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This also leads to the result shown in <a data-type="xref" href="#directly_assigning_styles_to_the_relevan">Figure 4-7</a>, because the value of <code>color</code> is explicitly inherited thanks to an assigned rule whose selector has specificity.<a data-primary="" data-startref="ix_css_inherit" data-type="indexterm" id="idm45176131742480"/><a data-primary="" data-startref="ix_doc_struct_inherit" data-type="indexterm" id="idm45176131741568"/><a data-primary="" data-startref="ix_inherit_ch4" data-type="indexterm" id="idm45176131740624"/><a data-primary="" data-startref="ix_rules_inherit" data-type="indexterm" id="idm45176131739680"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The Cascade" data-type="sect1"><div class="sect1" id="the_cascade">&#13;
<h1>The Cascade</h1>&#13;
&#13;
<p>Throughout this <a data-primary="CSS (Cascading Style Sheets)" data-secondary="cascade" data-type="indexterm" id="ix_css_cascade_ch4"/><a data-primary="rules" data-secondary="cascade" data-type="indexterm" id="ix_rules_cascade_ch4"/><a data-primary="cascade" data-type="indexterm" id="ix_cascade_ch4"/><a data-primary="weight, in cascade rules" data-type="indexterm" id="ix_weight_casc_rules"/><a data-primary="declarations" data-secondary="cascade order" data-type="indexterm" id="ix_declar_casc_order"/><a data-primary="elements" data-secondary="order in cascade" data-type="indexterm" id="ix_elem_casc_order"/>chapter, we’ve skirted one rather important issue: what happens when two rules of equal specificity apply to the same element? How does the browser resolve the conflict? For example, consider the following rules:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Which one wins? Both have a specificity of <code>0,0,1</code>, so they have equal weight and should both apply. That can’t be the case because the element can’t be both red and blue. So which will it be?</p>&#13;
&#13;
<p class="pagebreak-before">At last, the name <em>Cascading Style Sheets</em> comes into focus: CSS is based on a method of causing styles to <em>cascade</em> together, which is made possible by combining inheritance and specificity with a few rules. The cascade rules for CSS are as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Find all rules containing a selector that matches a given element.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sort all <a data-primary="explicit weight, cascade order" data-type="indexterm" id="idm45176131700064"/>declarations applying to the given element by <em>explicit weight</em>.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sort all <a data-primary="author origin" data-type="indexterm" id="idm45176131697952"/><a data-primary="user agent origin" data-type="indexterm" id="idm45176131697216"/><a data-primary="reader origin" data-type="indexterm" id="idm45176131696544"/>declarations applying to the given element by <em>origin</em>. There are three basic origins: author, reader, and user agent. Under normal circumstances, the author’s styles (that is, your styles as the author of the page) win out over the reader’s styles, and both author and reader styles override the user agent’s default styles. This is reversed for rules marked <code>!important</code>, where user agent styles override author styles, and both override reader styles.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sort all <a data-primary="encapsulation context, cascade rules" data-type="indexterm" id="idm45176131669440"/>declarations applying to the given element by <em>encapsulation context</em>.  If a style is assigned via a shadow DOM, for example, it has an encapsulation context for all elements within that same shadow DOM and does not apply to elements outside that shadow DOM.  This allows encapsulated styles to override styles that are inherited from outside the shadow DOM.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sort all <a data-primary="element-attached declarations, cascade rules" data-type="indexterm" id="idm45176131667360"/>declarations by whether they are <em>element attached</em>.  Styles assigned via a <code>style</code> attribute are element attached.  Styles assigned from a stylesheet, whether external or embedded, are not.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sort all <a data-primary="cascade layer" data-type="indexterm" id="idm45176131664736"/>declarations by <em>cascade layer</em>.  For normal-weight styles, the later a cascade layer first appears in the CSS, the greater the precedence. Styles without a layer are considered to be part of a “default” final pseudo-layer, one that has higher precedence than styles in explicitly created layers.  For important-weight styles, the <em>earlier</em> a cascade layer appears in the CSS, the greater its precedence, and all important-weight styles in explicitly created layers win out over styles in the default layer, important or otherwise.  Cascade layers can appear in any origin.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sort all <a data-primary="specificity" data-secondary="in cascade rule order" data-secondary-sortas="cascade rule order" data-type="indexterm" id="idm45176131662176"/><a data-primary="cascade" data-secondary="by specificity" data-secondary-sortas="specificity" data-type="indexterm" id="idm45176131660896"/>declarations applying to the given element by <em>specificity</em>. Those elements with a higher specificity have more weight than those with lower specificity.</p>&#13;
</li>&#13;
<li>&#13;
<p>Sort all <a data-primary="appearance order, cascade rules" data-type="indexterm" id="idm45176131658192"/>declarations applying to the given element by <em>order of appearance</em>. The later a declaration appears in the stylesheet or document, the more weight it is given. Declarations that appear in an imported stylesheet are considered to come before all declarations within the stylesheet that imports them.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>To be clear about how this all works, let’s consider examples that illustrate some of the cascade rules.<a data-primary="" data-startref="ix_declar_casc_order" data-type="indexterm" id="idm45176131656240"/><a data-primary="" data-startref="ix_elem_casc_order" data-type="indexterm" id="idm45176131655264"/><a data-primary="" data-startref="ix_weight_casc_rules" data-type="indexterm" id="idm45176131654320"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Sorting by Importance and Origin" data-type="sect2"><div class="sect2" id="sorting_by_weight_and_origin">&#13;
<h2>Sorting by Importance and Origin</h2>&#13;
&#13;
<p>If two <a data-primary="origin, in cascade rules" data-type="indexterm" id="ix_origin_casc_rules"/><a data-primary="cascade" data-secondary="by importance and origin" data-secondary-sortas="importance and origin" data-type="indexterm" id="ix_cascade_imp_orig"/>rules apply to an element, and one is marked <code>!important</code>, the important rule &#13;
<span class="keep-together">wins out:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code> <code class="cp">!important</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"color: black;"</code><code class="nt">&gt;</code>Well,<code class="w"> </code><code class="nt">&lt;em&gt;</code>hello<code class="nt">&lt;/em&gt;</code><code class="w"> </code>there!<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Even though a color is assigned in the <code>style</code> attribute of the paragraph, the <code>!important</code> rule wins out, and the paragraph is gray.  This occurs because sorting by <code>!important</code> has higher precedence than sorting by element-attached styles (<code>style=""</code>). The gray is inherited by the <code>&lt;em&gt;</code> element as well.</p>&#13;
&#13;
<p>Note that if <code>!important</code> is added to the inline style in this situation, <em>it</em> will be the winner.  Thus, given the following, the paragraph (and its descendant element) will be black:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code> <code class="cp">!important</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">style=</code><code class="s">"color: black !important;"</code><code class="nt">&gt;</code>Well,<code class="w"> </code><code class="nt">&lt;em&gt;</code>hello<code class="nt">&lt;/em&gt;</code><code class="w"> </code>there!<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>If the <a data-primary="reader origin" data-type="indexterm" id="idm45176131564688"/><a data-primary="author origin" data-type="indexterm" id="idm45176131542064"/>importance is the same, the origin of a rule is considered. If an element is matched by normal styles in both the author’s stylesheet and the reader’s stylesheet, the author’s styles are used. For example, assume that the following styles come from the indicated origins:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code>    <code class="c">/* author's stylesheet */</code>&#13;
&#13;
<code class="nt">p</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;}</code>   <code class="c">/* reader's stylesheet */</code></pre>&#13;
&#13;
<p>In this case, emphasized text within paragraphs is colored black, not yellow, because the author styles win out over the reader styles. However, if both rules are marked &#13;
<span class="keep-together"><code>!important</code></span>, the situation changes:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code> <code class="cp">!important</code><code class="p">;}</code>    <code class="c">/* author's stylesheet */</code>&#13;
&#13;
<code class="nt">p</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">yellow</code> <code class="cp">!important</code><code class="p">;}</code>   <code class="c">/* reader's stylesheet */</code></pre>&#13;
&#13;
<p>Now the emphasized text in paragraphs will be yellow, not black.</p>&#13;
&#13;
<p>As it happens, the <a data-primary="user agent origin" data-type="indexterm" id="idm45176131446944"/>user agent’s default styles—which are often influenced by the user preferences—are figured into this step. The default style declarations are the least influential of all. Therefore, if an author-defined rule applies to anchors (e.g., declaring them to be <code>white</code>), then this rule overrides the user agent’s defaults.</p>&#13;
&#13;
<p>To sum up, CSS has eight basic levels to consider in terms of declaration precedence. In order of most to least precedence, these are as follows:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Transition declarations (see <a data-type="xref" href="ch18.html#x-transitions">Chapter 18</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p>User agent important declarations</p>&#13;
</li>&#13;
<li>&#13;
<p>Reader important declarations</p>&#13;
</li>&#13;
<li>&#13;
<p>Author important declarations</p>&#13;
</li>&#13;
<li>&#13;
<p>Animation declarations (see <a data-type="xref" href="ch19.html#animation">Chapter 19</a>)</p>&#13;
</li>&#13;
<li>&#13;
<p>Author normal declarations</p>&#13;
</li>&#13;
<li>&#13;
<p>Reader normal declarations</p>&#13;
</li>&#13;
<li>&#13;
<p>User agent declarations</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>Thus, a transition style will override all other rules, regardless of whether those other rules are marked <code>!important</code> or from what origin the rules come.<a data-primary="" data-startref="ix_cascade_imp_orig" data-type="indexterm" id="idm45176131422720"/><a data-primary="" data-startref="ix_origin_casc_rules" data-type="indexterm" id="idm45176131421744"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sorting by Element Attachment" data-type="sect2"><div class="sect2" id="sorting_by_element_attach">&#13;
<h2>Sorting by Element Attachment</h2>&#13;
&#13;
<p>Styles can be <a data-primary="cascade" data-secondary="by element attachment" data-secondary-sortas="element attachment" data-type="indexterm" id="idm45176131418800"/><a data-primary="element-attached styles, cascade rules" data-type="indexterm" id="idm45176131417520"/>attached to an element by using a markup attribute such as <code>style</code>.  These are called <em>element-attached</em> styles, and they are outweighed only by considerations of origin and weight.</p>&#13;
&#13;
<p>To understand this, consider the following rule and markup fragment:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1</code><code class="w"> </code><code class="na">style=</code><code class="s">"color: green;"</code><code class="nt">&gt;</code>The<code class="w"> </code>Meadow<code class="w"> </code>Party<code class="nt">&lt;/h1&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Given that the rule is applied to the <code>&lt;h1&gt;</code> element, you would still probably expect the text of the <code>&lt;h1&gt;</code> to be green. This happens because every inline declaration is element attached, and so has a higher weight than styles that aren’t element attached, like the <code>color: red</code> rule.</p>&#13;
&#13;
<p>This <a data-primary="inline styles" data-type="indexterm" id="idm45176131410160"/>means that even elements with <code>id</code> attributes that match a rule will obey the inline style declaration. Let’s modify the previous example to include an <code>id</code>:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code><code class="nf">#meadow</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;h1</code><code class="w"> </code><code class="na">id=</code><code class="s">"meadow"</code><code class="w"> </code><code class="na">style=</code><code class="s">"color: green;"</code><code class="nt">&gt;</code>The<code class="w"> </code>Meadow<code class="w"> </code>Party<code class="nt">&lt;/h1&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Thanks to the inline declaration’s weight, the text of the <code>&lt;h1&gt;</code> element will still be green.</p>&#13;
&#13;
<p>Just remember that inline styles are generally a bad practice, so try not to use them if at all possible.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sorting by Cascade Layer" data-type="sect2"><div class="sect2" id="sorting_by_layer">&#13;
<h2>Sorting by Cascade Layer</h2>&#13;
&#13;
<p><em>Cascade layers</em> allow <a data-primary="cascade" data-secondary="by cascade layer" data-secondary-sortas="cascade layer" data-type="indexterm" id="ix_cascade_bylayer"/>authors to group styles together so that they share a precedence level within the cascade.  This might sound like <code>!important</code>; in some ways they are similar—but in others, very different.  This is easier to demonstrate than it is to describe.  The ability to create cascade layers means authors can balance various needs, such as the needs of a component library, against the needs of a specific page or part of a web app.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Cascade layers were introduced to CSS at the end of 2021, so browser support for them exists only in browsers released from that point forward.</p>&#13;
</div>&#13;
&#13;
<p>If <a data-primary="@layer rule" data-primary-sortas="layer rule" data-type="indexterm" id="ix_at_layer_rule"/><a data-primary="at-rules" data-secondary="@layer" data-secondary-sortas="layer" data-type="indexterm" id="ix_atrule_layer"/>conflicting declarations apply to an element and all have the same explicit weight and origin, and none are element attached, they are next sorted by cascade layer.  The order of precedence for layers is set by the order in which the layers are first declared or used, with later declared layers taking precedence over earlier declared layers for normal styles.  Consider the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@layer</code> <code class="nt">site</code> <code class="p">{</code>&#13;
     <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@layer</code> <code class="nt">page</code> <code class="p">{</code>&#13;
     <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>These <code>&lt;h1&gt;</code> elements will be colored blue.  This is because the <code>page</code> layer comes later in the CSS than the <code>site</code> layer, and so has higher precedence.</p>&#13;
&#13;
<p>Any style not part of a named cascade layer is assigned to an implicit “default” layer, one that has higher precedence than any named layer for unimportant rules.  Suppose we alter the previous example as follows:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code>&#13;
<code class="k">@layer</code> <code class="nt">site</code> <code class="p">{</code>&#13;
     <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="k">@layer</code> <code class="nt">page</code> <code class="p">{</code>&#13;
     <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>The <code>&lt;h1&gt;</code> elements will now be maroon, because the implicit “default” layer to which the <code>h1 {color: maroon;}</code> belongs has higher precedence than any named layer.</p>&#13;
&#13;
<p>You can also define a specific precedence order for named cascade layers. Consider the following CSS:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@layer</code> <code class="nt">site</code><code class="o">,</code> <code class="nt">page</code><code class="p">;</code>&#13;
&#13;
<code class="k">@layer</code> <code class="nt">page</code> <code class="p">{</code>&#13;
   <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">@layer</code> <code class="nt">site</code> <code class="p">{</code>&#13;
   <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Here, the first line defines an order of precedence for the layers: the <code>page</code> layer will be given higher precedence than the <code>site</code> layer for normal-weight rules like those shown in the example.  Thus, in this case, <code>&lt;h1&gt;</code> elements will be blue, because when the layers are sorted, <code>page</code> is given more precedence than <code>site</code>.  For important-flagged rules, the order of precedence is reversed.  Thus, if both rules were marked <code>!important</code>, the precedence would flip and <code>&lt;h1&gt;</code> elements would be red.</p>&#13;
&#13;
<p>Let’s talk a little bit more about how cascade layers specifically work, especially since they’re so new to CSS.  Let’s say you want to define three layers: one for the basic site styles, one for individual page styles, and one for a component library whose styles are imported from an external stylesheet.  <a data-primary="@import rule" data-primary-sortas="import rule" data-type="indexterm" id="ix_import_rule_ch4"/><a data-primary="at-rules" data-secondary="@import" data-secondary-sortas="import" data-type="indexterm" id="ix_atrule_import2"/>The CSS might look like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="cp">@layer site, page;</code>&#13;
<code class="cp">@import url(/assets/css/components.css) layer(components);</code></pre>&#13;
&#13;
<p>This ordering will have normal-weight <code>components</code> styles override and <code>page</code> and <code>site</code> normal-weight styles, and normal-weight <code>page</code> styles will override only <code>site</code> normal-weight styles.  Conversely, important <code>site</code> styles will override all <code>page</code> and <code>components</code> styles, whether they’re important or normal weight, and <code>page</code> important styles will override all <code>components</code> styles.</p>&#13;
&#13;
<p>Here’s a small example of how layers might be managed:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@layer</code> <code class="nt">site</code><code class="o">,</code> <code class="nt">component</code><code class="o">,</code> <code class="nt">page</code><code class="p">;</code>&#13;
<code class="k">@import</code> <code class="sx">url(/c/lib/core.css)</code> <code class="nt">layer</code><code class="p">(</code><code class="n">component</code><code class="p">);</code>&#13;
<code class="k">@import</code> <code class="sx">url(/c/lib/widgets.css)</code> <code class="nt">layer</code><code class="p">(</code><code class="n">component</code><code class="p">);</code>&#13;
<code class="k">@import</code> <code class="sx">url(/c/site.css)</code> <code class="nt">layer</code><code class="p">(</code><code class="n">site</code><code class="p">);</code>&#13;
&#13;
<code class="k">@layer</code> <code class="nt">page</code> <code class="p">{</code>&#13;
   <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code>&#13;
   <code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="k">@layer</code> <code class="nt">site</code> <code class="p">{</code>&#13;
   <code class="nt">body</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">1.1rem</code><code class="p">;}</code>&#13;
   <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;}</code>&#13;
   <code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This example has three imported stylesheets, one of which is assigned to the <code>site</code> layer and two of which are in the <code>component</code> layer.  Then some rules are assigned to the <code>page</code> layer, and a couple of rules are placed in the <code>site</code> layer.  The rules in the <code>@layer site {}</code> block will be combined with the rules from <code>/c/site.css</code> into a single <code>site</code> layer.</p>&#13;
&#13;
<p>After that, there’s a rule outside the explicit cascade layers, which means it’s part of the implicit “default” layer.  Rules in this default layer will override the styles of any of the other layers.  So, given the code shown, paragraphs will have top margins of <code>1em</code>.</p>&#13;
&#13;
<p>But before all of that, a directive sets the precedence order of the named layers: <code>page</code> overrules <code>component</code> and <code>site</code>, and <code>component</code> overrules <code>site</code>.  Here’s how those various rules are grouped as far as the cascade is concerned, with comments to describe their placement in the sorting:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="c">/* 'site' layer is the lowest weighted */</code>&#13;
<code class="k">@import</code> <code class="sx">url(/c/site.css)</code> <code class="nt">layer</code><code class="p">(</code><code class="n">site</code><code class="p">);</code>&#13;
<code class="k">@layer</code> <code class="nt">site</code> <code class="p">{</code>&#13;
   <code class="nt">body</code> <code class="p">{</code><code class="k">font-size</code><code class="o">:</code> <code class="m">1.1rem</code><code class="p">;}</code>&#13;
   <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;}</code>&#13;
   <code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">0.5em</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c">/* 'component' layer is the next-lowest weighted */</code>&#13;
<code class="k">@import</code> <code class="sx">url(/c/lib/core.css)</code> <code class="nt">layer</code><code class="p">(</code><code class="n">component</code><code class="p">);</code>&#13;
<code class="k">@import</code> <code class="sx">url(/c/lib/widgets.css)</code> <code class="nt">layer</code><code class="p">(</code><code class="n">component</code><code class="p">);</code>&#13;
&#13;
<code class="c">/* 'page' layer is the next-highest weighted */</code>&#13;
<code class="k">@layer</code> <code class="nt">page</code> <code class="p">{</code>&#13;
   <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code>&#13;
   <code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c">/* the implicit layer is the highest weighted */</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code></pre>&#13;
&#13;
<p>As you can see, the later a layer comes in the ordering of the layers, the more weight it’s given by the cascade’s sorting algorithm.</p>&#13;
&#13;
<p>To be clear, cascade layers don’t have to be named. Naming just keeps things a lot clearer in terms of setting an order for them, and it also enables adding styles to the layer.  Here are some examples of using unnamed cascade layers:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@import</code> <code class="sx">url(base.css)</code> <code class="nt">layer</code><code class="p">;</code>&#13;
&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">1em</code><code class="p">;}</code>&#13;
&#13;
<code class="k">@layer</code> <code class="p">{</code>&#13;
   <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">maroon</code><code class="p">;}</code>&#13;
   <code class="nt">body</code> <code class="nt">p</code> <code class="p">{</code><code class="k">margin-top</code><code class="o">:</code> <code class="m">0</code><code class="p">;}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In this case, the rules imported from <em>base.css</em> are assigned to an unnamed layer.  Even though this layer doesn’t actually have a name, let’s think of it as CL1.  Then a rule outside the layers sets paragraph top margins to <code>1em</code>.  Finally, an unnamed layer block has a couple of rules; let’s think of this layer as CL2.</p>&#13;
&#13;
<p>So now we have rules in three layers: CL1, CL2, and the implicit layer.  And that’s the order they’re considered in, so in the case of any conflicting normal rules, the rules in the implicit default layer (which comes last in the ordering) will win over conflicting rules in the other two layers, and rules in CL2 will win over conflicting rules in CL1.</p>&#13;
&#13;
<p>At least, that’s the case for normal-weight rules.  For <code>!important</code> rules, the order of precedence is flipped, so those in CL1 will win over conflicting important rules in the other two layers, and important rules in CL2 win over conflicting important rules in the implicit layer.  Strange but true!</p>&#13;
&#13;
<p>This sorting by order will come up again in just a little bit, but first let’s bring specificity into the cascade.<a data-primary="" data-startref="ix_atrule_layer" data-type="indexterm" id="idm45176133967952"/><a data-primary="" data-startref="ix_cascade_bylayer" data-type="indexterm" id="idm45176133966976"/><a data-primary="" data-startref="ix_at_layer_rule" data-type="indexterm" id="idm45176133966032"/><a data-primary="" data-startref="ix_atrule_import2" data-type="indexterm" id="idm45176133965088"/><a data-primary="" data-startref="ix_at_import2" data-type="indexterm" id="idm45176121632800"/><a data-primary="" data-startref="ix_import_rule_ch4" data-type="indexterm" id="idm45176121631856"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Sorting by Specificity" data-type="sect2"><div class="sect2" id="sorting_by_specificity">&#13;
<h2>Sorting by Specificity</h2>&#13;
&#13;
<p>If conflicting <a data-primary="cascade" data-secondary="by specificity" data-secondary-sortas="specificity" data-type="indexterm" id="idm45176121629216"/><a data-primary="specificity" data-secondary="in cascade rule order" data-secondary-sortas="cascade rule order" data-type="indexterm" id="idm45176121627936"/>declarations apply to an element and those declarations all have the same explicit weight, origin, element attachment (or lack thereof), and cascade layer, they are then sorted by specificity. The most specific declaration wins out, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@layer</code> <code class="nt">page</code> <code class="p">{</code>&#13;
  <code class="nt">p</code><code class="nf">#bright#bright#bright</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="n">grey</code><code class="p">;}</code>&#13;
<code class="p">}</code>&#13;
<code class="nt">p</code><code class="nf">#bright</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code>&#13;
<code class="nt">p</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">black</code><code class="p">;}</code></pre>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="nt">&lt;p</code><code class="w"> </code><code class="na">id=</code><code class="s">"bright"</code><code class="nt">&gt;</code>Well,<code class="w"> </code>hello<code class="w"> </code>there!<code class="nt">&lt;/p&gt;</code><code class="w"/></pre>&#13;
&#13;
<p>Given these rules, the text of the paragraph will be silver, as illustrated in <a data-type="xref" href="#higher_specificity_wins_out_over_lower">Figure 4-8</a>. Why? Because the specificity of <code>p#bright</code> (<code>1,0,1</code>) overrides the specificity of <code>p</code> (<code>0,0,1)</code>, even though the latter rule comes later in the stylesheet. The styles from the <code>page</code> layer, even though they have the strongest selector (<code>3,0,1</code>), aren’t even compared. Only the declarations from the layer with precedence are in contention.</p>&#13;
&#13;
<figure class="coderesult"><div class="figure" id="higher_specificity_wins_out_over_lower">&#13;
<img alt="css5 0408" src="assets/css5_0408.png"/>&#13;
<h6><span class="label">Figure 4-8. </span>Higher specificity wins out over lower specificity</h6>&#13;
</div></figure>&#13;
&#13;
<p>Remember that this rule applies only if the rules are part of the same cascade layer.  If not, specificity doesn’t matter: a <code>0,0,1</code> selector in the implicit layer will win over any unimportant rule in an explicitly created cascade layer, no matter how high the latter’s specificity gets.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Sorting by Order" data-type="sect2"><div class="sect2" id="sorting_by_order">&#13;
<h2>Sorting by Order</h2>&#13;
&#13;
<p>Finally, if <a data-primary="order, cascade by" data-type="indexterm" id="ix_order_cascade_by_ch4"/><a data-primary="cascade" data-secondary="by order" data-secondary-sortas="order" data-type="indexterm" id="ix_cascade_order_ch4"/>two rules have exactly the same explicit weight, origin, element attachment, cascade layer, and specificity, then the one that appears later in the stylesheet wins out, similar to the way cascade layers are sorted in order so that later layers win over earlier layers.</p>&#13;
&#13;
<p>Let’s return to an earlier example, where we find the following two rules in the document’s stylesheet:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">body</code> <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">html</code> <code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code></pre>&#13;
&#13;
<p>In this case, the value of <code>color</code> for all <code>&lt;h1&gt;</code> elements in the document will be <code>blue</code>, not <code>red</code>. This is because the two rules are tied with each other in terms of explicit weight and origin, are in the same cascade layer, and the selectors have equal specificity, so the last one declared is the winner.  It doesn’t matter how close together the elements are in the document tree; even though <code>&lt;body&gt;</code> and <code>&lt;h1&gt;</code> are closer together than <code>&lt;html&gt;</code> and <code>&lt;h1&gt;</code>, the later one wins. The only thing that matters (when the origin, cascade layer, layer, and specificity are the same) is the order in which the rules appear in the CSS.</p>&#13;
&#13;
<p>So what happens if rules from completely separate stylesheets conflict? For example, suppose the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="k">@import</code> <code class="sx">url(basic.css)</code><code class="p">;</code>&#13;
<code class="nt">h1</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code></pre>&#13;
&#13;
<p>What if <code>h1 {color: red;}</code> appears in <em>basic.css</em>? In this case, since there are no cascade layers in play, the entire contents of <em>basic.css</em> are treated as if they were pasted into the stylesheet at the point where the <code>@import</code> occurs. Thus, any rule contained in the document’s stylesheet occurs later than those from the <code>@import</code>. If they tie in terms of explicit weight and specificity, the document’s stylesheet contains the winner. Consider the &#13;
<span class="keep-together">following:</span></p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">p</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>  <code class="c">/* from imported stylesheet */</code>&#13;
&#13;
<code class="nt">p</code> <code class="nt">em</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>    <code class="c">/* rule contained within the document */</code></pre>&#13;
&#13;
<p>In this case, the second rule wins out over the imported rule because it is the last one specified, and both are in the implicit cascade layer.</p>&#13;
&#13;
<p>Order <a data-primary="link-visited-focus-hover-active (LVFHA) ordering" data-type="indexterm" id="ix_lvfha_spellout_order"/><a data-primary="LVFHA (link-visited-focus-hover-active) ordering" data-type="indexterm" id="ix_lvfha_acronym_order"/><a data-primary="links" data-secondary="LVFHA ordering" data-type="indexterm" id="ix_link_lvfha"/>sorting is the reason behind the often-recommended ordering of link styles. The recommendation is that you write your link styles in the order <code>link</code>, <code>visited</code>, <code>focus</code>, <code>hover</code>, <code>active</code>, or LVFHA, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:focus</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">green</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:active</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Thanks to the information in this chapter, you now know that the specificity of all of these selectors is the same: <code>0,1,1</code>. Because they all have the same explicit weight, origin, and specificity, the last one that matches an element will win out. An unvisited link that is being clicked or otherwise activated, such as via the keyboard, is matched by four of the rules—<code>:link</code>, <code>:focus</code>, <code>:hover</code>, and <code>:active</code>—so the last one of those four will win out. Given the LVFHA ordering, <code>:active</code> will win, which is likely what the author intended.</p>&#13;
&#13;
<p>Assume for a moment that you decide to ignore the common ordering and alphabetize your link styles instead. This would yield the following:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:active</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:focus</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">green</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Given this ordering, no link would ever show <code>:hover</code>, <code>:focus</code>, or <code>:active</code> styles because the <code>:link</code> and <code>:visited</code> rules come after the other three. Every link must be either visited or unvisited, so those styles will always override the others.</p>&#13;
&#13;
<p>Let’s consider a variation on the LVFHA order that an author might want to use. In this ordering, only unvisited links will get a hover style; visited links will not. Both visited and unvisited links will get an active style:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:focus</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">green</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:active</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Such conflicts arise only when all the states attempt to set the same property. If each state’s styles address a different property, the order does not matter. In the following case, the link styles could be given in any order and would still function as intended:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">font-weight</code><code class="o">:</code> <code class="nb">bold</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">font-style</code><code class="o">:</code> <code class="nb">italic</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:focus</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">green</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:active</code> <code class="p">{</code><code class="k">background</code><code class="o">:</code> <code class="nb">yellow</code><code class="p">;}</code></pre>&#13;
&#13;
<p>You may also have realized that the order of the <code>:link</code> and <code>:visited</code> styles doesn’t matter. You could order the styles LVFHA or VLFHA with no ill effect.</p>&#13;
&#13;
<p>The ability to chain pseudo-classes together eliminates all these worries. The following could be listed in any order without any overrides, as the specificity of the latter two is greater than that of the first two:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:link:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code></pre>&#13;
&#13;
<p>Because each rule applies to a unique set of link states, they do not conflict. Therefore, changing their order will not change the styling of the document. The last two rules do have the same specificity, but that doesn’t matter. A hovered unvisited link will not be matched by the rule regarding hovered visited links, and vice versa. If we were to add active-state styles, order would start to matter again. Consider this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">purple</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:link:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">red</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited:hover</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">gray</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:link:active</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited:active</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>If the active styles were moved before the hover styles, they would be ignored. Again, this would happen because of specificity conflicts. The conflicts could be avoided by adding more pseudo-classes to the chains, like this:</p>&#13;
&#13;
<pre data-code-language="css" data-type="programlisting"><code class="nt">a</code><code class="nd">:link:hover:active</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">orange</code><code class="p">;}</code>&#13;
<code class="nt">a</code><code class="nd">:visited:hover:active</code> <code class="p">{</code><code class="k">color</code><code class="o">:</code> <code class="nb">silver</code><code class="p">;}</code></pre>&#13;
&#13;
<p>This does have the effect of raising the specificity of the selectors—both have a specificity value of <code>0,3,1</code>—but they don’t conflict because the actual selection states are mutually exclusive.  A link can’t be both a visited hovered active link <em>and</em> an unvisited hovered active link: only one of the two rules will match.<a data-primary="" data-startref="ix_cascade_order_ch4" data-type="indexterm" id="idm45176120939568"/><a data-primary="" data-startref="ix_order_cascade_by_ch4" data-type="indexterm" id="idm45176120938688"/><a data-primary="" data-startref="ix_link_lvfha" data-type="indexterm" id="idm45176120937744"/><a data-primary="" data-startref="ix_lvfha_spellout_order" data-type="indexterm" id="idm45176120936800"/><a data-primary="" data-startref="ix_lvfha_acronym_order" data-type="indexterm" id="idm45176120935856"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Working with Non-CSS Presentational Hints" data-type="sect2"><div class="sect2" id="non-css_presentational_hints">&#13;
<h2>Working with Non-CSS Presentational Hints</h2>&#13;
&#13;
<p>A <a data-primary="non-CSS presentational hints" data-type="indexterm" id="idm45176120933568"/><a data-primary="presentational hints, non-CSS" data-type="indexterm" id="idm45176120932864"/>document could contain presentational hints that are not CSS—for example, the deprecated <code>&lt;font&gt;</code> element, or the still very much used <code>height</code>, <code>width</code>, and <code>hidden</code> attributes. Such presentational hints will be overridden by any author or reader styles, but not by the user agent’s styles. In modern browsers, presentational hints from outside CSS are treated as if they belong to the user agent’s stylesheet.<a data-primary="" data-startref="ix_cascade_ch4" data-type="indexterm" id="idm45176120905936"/><a data-primary="" data-startref="ix_css_cascade_ch4" data-type="indexterm" id="idm45176120904960"/><a data-primary="" data-startref="ix_rules_cascade_ch4" data-type="indexterm" id="idm45176120904016"/></p>&#13;
</div></section>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="summary-id1">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>Perhaps the most fundamental aspect of Cascading Style Sheets is the cascade itself—the process used to sort out conflicting declarations and determine the final document presentation. Integral to this process is the specificity of selectors and their associated declarations, and the mechanism of inheritance.</p>&#13;
</div></section>&#13;
</div></section></body></html>