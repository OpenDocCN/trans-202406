<html><head></head><body><section data-pdf-bookmark="Appendix D. Recipes for Writing Declaration Files for Third-Party JavaScript Modules" data-type="appendix" epub:type="appendix"><div class="appendix" id="module-typing-recipes">&#13;
<h1><span class="label">Appendix D. </span>Recipes for Writing Declaration Files for Third-Party JavaScript Modules</h1>&#13;
&#13;
&#13;
<p>This appendix covers a few key building blocks and patterns that come up over and over again when typing third-party modules<a data-primary="modules" data-secondary="writing declaration files for third-party JavaScript modules" data-type="indexterm" id="ix_moddec"/>. For a deeper discussion of typing third-party code, head over to <a data-type="xref" href="ch11.html#writing-3rd-party-typings">“JavaScript That Doesn’t Have Type Declarations on DefinitelyTyped”</a>.</p>&#13;
&#13;
<p>Since module declaration files have to live in <em>.d.ts</em> files and so can’t contain values, when you declare module types you need to use the <code>declare</code> keyword to affirm that values of the given type really are exported by your module. <a data-type="xref" href="#type-only-table">Table D-1</a> provides a short summary of regular declarations and their type declaration equivalents.</p>&#13;
<table id="type-only-table">&#13;
<caption><span class="label">Table D-1. </span>TypeScript and its type-only equivalents</caption>&#13;
<thead>&#13;
<tr>&#13;
<th><em>.ts</em></th>&#13;
<th><em>.d.ts</em></th>&#13;
</tr>&#13;
</thead>&#13;
<tbody>&#13;
<tr>&#13;
<td><p><code>var a = 1</code></p></td>&#13;
<td><p><code>declare var a: number</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>let a = 1</code></p></td>&#13;
<td><p><code>declare let a: number</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>const a = 1</code></p></td>&#13;
<td><p><code>declare const a: 1</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>function a(b) { return b.toFixed() }</code></p></td>&#13;
<td><p><code>declare function a(b: number): string</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>class A { b() { return 3 } }</code></p></td>&#13;
<td><p><code>declare class A { b(): number }</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>namespace A {}</code></p></td>&#13;
<td><p><code>declare namespace A {}</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>type A = number</code></p></td>&#13;
<td><p><code>type A = number</code></p></td>&#13;
</tr>&#13;
<tr>&#13;
<td><p><code>interface A { b?: string }</code></p></td>&#13;
<td><p><code>interface A { b?: string }</code></p></td>&#13;
</tr>&#13;
</tbody>&#13;
</table>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Types of Exports" data-type="sect1"><div class="sect1" id="idm46304948396152">&#13;
<h1>Types of Exports</h1>&#13;
&#13;
<p>Whether your module uses global, ES2015, or CommonJS exports will affect how you write your declaration files.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Globals" data-type="sect2"><div class="sect2" id="idm46304948394456">&#13;
<h2>Globals</h2>&#13;
&#13;
<p>If your module only assigns values to the global namespace and doesn’t actually export anything, you can just create a script-mode file (see <a data-type="xref" href="ch10.html#module-mode">“Module Mode Versus Script Mode”</a>) and prefix your variable, function, and class declarations with <code>declare</code> (every other kind of declaration—<code>enum</code>, <code>type</code>, and so on—remains unchanged):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Global variable</code>&#13;
<code class="kr">declare</code> <code class="kd">let</code> <code class="nx">someGlobal</code>: <code class="kt">GlobalType</code>&#13;
&#13;
<code class="c1">// Global class</code>&#13;
<code class="kr">declare</code> <code class="kr">class</code> <code class="nx">GlobalClass</code> <code class="p">{}</code>&#13;
&#13;
<code class="c1">// Global function</code>&#13;
<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">globalFunction</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code>&#13;
&#13;
<code class="c1">// Global enum</code>&#13;
<code class="kr">enum</code> <code class="nx">GlobalEnum</code> <code class="p">{</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">}</code>&#13;
&#13;
<code class="c1">// Global namespace</code>&#13;
<code class="nx">namespace</code> <code class="nx">GlobalNamespace</code> <code class="p">{}</code>&#13;
&#13;
<code class="c1">// Global type alias</code>&#13;
<code class="nx">type</code> <code class="nx">GlobalType</code> <code class="o">=</code> <code class="kt">number</code>&#13;
&#13;
<code class="c1">// Global interface</code>&#13;
<code class="kr">interface</code> <code class="nx">GlobalInterface</code> <code class="p">{}</code></pre>&#13;
&#13;
<p>Each of these declarations will be globally available to every file in your project without requiring an explicit import. Here, you could use <code>someGlobal</code> in any file in your project without importing it first, but at runtime, <code>someGlobal</code> would need to be assigned to the global namespace (<code>window</code> in browsers or <code>global</code> in NodeJS).</p>&#13;
&#13;
<p>Be careful to avoid <code>import</code>s and <code>export</code>s in your declaration file in order to keep your file in script mode.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="ES2015 Exports" data-type="sect2"><div class="sect2" id="typing-es2015-exports">&#13;
<h2>ES2015 Exports</h2>&#13;
&#13;
<p>If your module uses ES2015 exports—that is, the <code>export</code> keyword—simply replace <code>declare</code> (which affirms that a global variable is defined) with <code>export</code> (which affirms that an ES2015 binding is exported):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Default export</code>&#13;
<code class="kr">declare</code> <code class="kd">let</code> <code class="nx">defaultExport</code>: <code class="kt">SomeType</code>&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">defaultExport</code>&#13;
&#13;
<code class="c1">// Named export</code>&#13;
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">SomeExport</code> <code class="p">{</code>&#13;
  <code class="nx">a</code>: <code class="kt">SomeOtherType</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Class export</code>&#13;
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">ExportedClass</code> <code class="p">{}</code>&#13;
&#13;
<code class="c1">// Function export</code>&#13;
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">exportedFunction</code><code class="p">()</code><code class="o">:</code> <code class="kt">string</code>&#13;
&#13;
<code class="c1">// Enum export</code>&#13;
<code class="kr">enum</code> <code class="nx">ExportedEnum</code> <code class="p">{</code><code class="nx">A</code><code class="p">,</code> <code class="nx">B</code><code class="p">,</code> <code class="nx">C</code><code class="p">}</code>&#13;
&#13;
<code class="c1">// Namespace export</code>&#13;
<code class="kr">export</code> <code class="nx">namespace</code> <code class="nx">SomeNamespace</code> <code class="p">{</code>&#13;
  <code class="kd">let</code> <code class="nx">someNamespacedExport</code>: <code class="kt">number</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Type export</code>&#13;
<code class="kr">export</code> <code class="nx">type</code> <code class="nx">SomeType</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">a</code>: <code class="kt">number</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Interface export</code>&#13;
<code class="kr">export</code> <code class="kr">interface</code> <code class="nx">SomeOtherType</code> <code class="p">{</code>&#13;
  <code class="nx">b</code>: <code class="kt">string</code>&#13;
<code class="p">}</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CommonJS Exports" data-type="sect2"><div class="sect2" id="idm46304948343048">&#13;
<h2>CommonJS Exports</h2>&#13;
&#13;
<p>CommonJS was the de facto module standard before ES2015, and is still the standard for NodeJS at the time of writing. It also uses the <code>export</code> keyword, but the syntax is a bit different:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">declare</code> <code class="kd">let</code> <code class="nx">defaultExport</code>: <code class="kt">SomeType</code>&#13;
<code class="kr">export</code> <code class="o">=</code> <code class="nx">defaultExport</code></pre>&#13;
&#13;
<p>Notice how we assigned our exports to <code>export</code>, rather than using <code>export</code> as a modifier (like we do for ES2015 exports).</p>&#13;
&#13;
<p>A type declaration for a third-party CommonJS module can contain exactly one export. To export multiple things, we take advantage of declaration merging (see <a data-type="xref" href="app03.html#types-and-values">Appendix C</a>).</p>&#13;
&#13;
<p>For example, to type multiple exports and no default export, we export a single <span class="keep-together"><code>namespace</code></span>:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">declare</code> <code class="nx">namespace</code> <code class="nx">MyNamedExports</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">let</code> <code class="nx">someExport</code>: <code class="kt">SomeType</code>&#13;
  <code class="kr">export</code> <code class="nx">type</code> <code class="nx">SomeType</code> <code class="o">=</code> <code class="kt">number</code>&#13;
  <code class="kr">export</code> <code class="kr">class</code> <code class="nx">OtherExport</code> <code class="p">{</code>&#13;
    <code class="nx">otherType</code>: <code class="kt">string</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code>&#13;
<code class="kr">export</code> <code class="o">=</code> <code class="nx">MyNamedExports</code></pre>&#13;
&#13;
<p>What about a CommonJS module that has both a default export and named exports? We take advantage of declaration merging:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">declare</code> <code class="nx">namespace</code> <code class="nx">MyExports</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">let</code> <code class="nx">someExport</code>: <code class="kt">SomeType</code>&#13;
  <code class="kr">export</code> <code class="nx">type</code> <code class="nx">SomeType</code> <code class="o">=</code> <code class="kt">number</code>&#13;
<code class="p">}</code>&#13;
<code class="kr">declare</code> <code class="kd">function</code> <code class="nx">MyExports</code><code class="p">(</code><code class="nx">a</code>: <code class="kt">number</code><code class="p">)</code><code class="o">:</code> <code class="kt">string</code>&#13;
<code class="kr">export</code> <code class="o">=</code> <code class="nx">MyExports</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="UMD Exports" data-type="sect2"><div class="sect2" id="idm46304948127608">&#13;
<h2>UMD Exports</h2>&#13;
&#13;
<p>Typing a UMD module is nearly identical to typing an ES2015 module. The only difference is that if you want to make your module globally available to script-mode files (see <a data-type="xref" href="ch10.html#module-mode">“Module Mode Versus Script Mode”</a>), you use the special <code>export as namespace</code> syntax. For example:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="c1">// Default export</code>&#13;
<code class="kr">declare</code> <code class="kd">let</code> <code class="nx">defaultExport</code>: <code class="kt">SomeType</code>&#13;
<code class="kr">export</code> <code class="k">default</code> <code class="nx">defaultExport</code>&#13;
&#13;
<code class="c1">// Named export</code>&#13;
<code class="kr">export</code> <code class="kr">class</code> <code class="nx">SomeExport</code> <code class="p">{</code>&#13;
  <code class="nx">a</code>: <code class="kt">SomeType</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="c1">// Type export</code>&#13;
<code class="kr">export</code> <code class="nx">type</code> <code class="nx">SomeType</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">a</code>: <code class="kt">number</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="kr">export</code> <code class="kr">as</code> <code class="nx">namespace</code> <code class="nx">MyModule</code></pre>&#13;
&#13;
<p>Notice that last line—if you have a script-mode file in your project, you can now use that module directly (without importing it first) on the global <code>MyModule</code> namespace:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyModule</code><code class="p">.</code><code class="nx">SomeExport</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Extending a Module" data-type="sect1"><div class="sect1" id="extending-a-module">&#13;
<h1>Extending a Module</h1>&#13;
&#13;
<p>Extending a module’s type declaration is less common than typing a module, but it might come up if you write a JQuery plugin or a Lodash mixin. Try to avoid doing it when possible; instead, consider using a separate module. That is, instead of a Lodash mixin use a regular function, and instead of a JQuery plugin—wait, why are you still using JQuery?</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Globals" data-type="sect2"><div class="sect2" id="extending-a-global">&#13;
<h2>Globals</h2>&#13;
&#13;
<p>If you want to extend another module’s global namespace or interface, just create a script-mode file (see <a data-type="xref" href="ch10.html#module-mode">“Module Mode Versus Script Mode”</a>), and augment it. Note that this only works for interfaces and namespaces because TypeScript will take care of merging them for you.</p>&#13;
&#13;
<p>For example, let’s add an awesome new <code>marquee</code> method to JQuery. We’ll start by installing <code>jquery</code> itself:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">npm install jquery --save&#13;
npm install @types/jquery --save-dev</pre>&#13;
&#13;
<p>We’ll then create a new file—say <em>jquery-extensions.d.ts</em>—in our project, and add <code>marquee</code> to JQuery’s global <code>JQuery</code> interface (I found that JQuery defines its methods on the <code>JQuery</code> interface by sleuthing through its type declarations):</p>&#13;
&#13;
<pre data-code-language="js" data-type="programlisting"><code class="kr">interface</code> <code class="nx">JQuery</code> <code class="p">{</code>&#13;
  <code class="nx">marquee</code><code class="p">(</code><code class="nx">speed</code><code class="o">:</code> <code class="nx">number</code><code class="p">)</code><code class="o">:</code> <code class="nx">JQuery</code><code class="o">&lt;</code><code class="nx">HTMLElement</code><code class="o">&gt;</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Now, in any file where we use JQuery, we can use <code>marquee</code> (of course, we’ll want to add a runtime implementation for <code>marquee</code> too):</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="nx">$</code> <code class="nx">from</code> <code class="s1">'jquery'</code>&#13;
<code class="nx">$</code><code class="p">(</code><code class="nx">myElement</code><code class="p">).</code><code class="nx">marquee</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code></pre>&#13;
&#13;
<p>Note that this is the same technique we used to extend built-in globals in <a data-type="xref" href="ch06.html#extending-the-prototype">“Safely Extending the Prototype”</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Modules" data-type="sect2"><div class="sect2" id="idm46304948018680">&#13;
<h2>Modules</h2>&#13;
&#13;
<p>Extending module exports is a bit trickier, and has more pitfalls: you need to type your extension correctly, load your modules in the correct order at runtime, and make sure to update your extension’s types when the structure of the type declarations for the module you’re extending changes.</p>&#13;
&#13;
<p>As an example, let’s type a new export for React. We’ll start by installing React and its type declarations:</p>&#13;
&#13;
<pre data-code-language="sh" data-type="programlisting">npm install react --save&#13;
npm install @types/react --save-dev</pre>&#13;
&#13;
<p>Then we’ll take advantage of module merging (see <a data-type="xref" href="ch10.html#namespace-merging">“Declaration Merging”</a>) and simply declare a module with the same name as our React module:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="p">{</code><code class="nx">ReactNode</code><code class="p">}</code> <code class="nx">from</code> <code class="s1">'react'</code>&#13;
&#13;
<code class="kr">declare</code> <code class="nx">module</code> <code class="s1">'react'</code> <code class="p">{</code>&#13;
  <code class="kr">export</code> <code class="kd">function</code> <code class="nx">inspect</code><code class="p">(</code><code class="nx">element</code>: <code class="kt">ReactNode</code><code class="p">)</code><code class="o">:</code> <code class="k">void</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Note that unlike in our example for extending globals, it doesn’t matter whether our extension file is in module mode or script mode.</p>&#13;
&#13;
<p>What about extending a specific export from a module? Inspired by <a href="https://reasonml.github.io/reason-react">ReasonReact</a>, let’s say we want to add a built-in reducer for our React components (a reducer is a way to declare an explicit set of state transitions for a React component). At the time of writing, React’s type declarations declare the <code>React.Component</code> type as an interface and a class that get merged together into a single UMD export:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">export</code> <code class="o">=</code> <code class="nx">React</code>&#13;
<code class="kr">export</code> <code class="kr">as</code> <code class="nx">namespace</code> <code class="nx">React</code>&#13;
&#13;
<code class="kr">declare</code> <code class="nx">namespace</code> <code class="nx">React</code> <code class="p">{</code>&#13;
  <code class="kr">interface</code> <code class="nx">Component</code><code class="o">&lt;</code><code class="nx">P</code> <code class="o">=</code> <code class="p">{},</code> <code class="nx">S</code> <code class="o">=</code> <code class="p">{},</code> <code class="nx">SS</code> <code class="o">=</code> <code class="nx">any</code><code class="o">&gt;</code>&#13;
    <code class="kr">extends</code> <code class="nx">ComponentLifecycle</code><code class="o">&lt;</code><code class="nx">P</code><code class="p">,</code> <code class="nx">S</code><code class="p">,</code> <code class="nx">SS</code><code class="o">&gt;</code> <code class="p">{}</code>&#13;
  <code class="kr">class</code> <code class="nx">Component</code><code class="o">&lt;</code><code class="nx">P</code><code class="p">,</code> <code class="nx">S</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
    <code class="kr">constructor</code><code class="p">(</code><code class="nx">props</code>: <code class="kt">Readonly</code><code class="o">&lt;</code><code class="nx">P</code><code class="o">&gt;</code><code class="p">)</code>&#13;
    <code class="c1">// ...</code>&#13;
  <code class="p">}</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Let’s extend <code>Component</code> with our <code>reducer</code> method. We can do this by entering the following in a <em>react-extensions.d.ts</em> file in the project root:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code><code> </code><code class="s1">'react'</code><code> </code><a class="co" href="#callout_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-1" id="co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-1"><img alt="1" src="assets/1.png"/></a><code>&#13;
&#13;
</code><code class="kr">declare</code><code> </code><code class="nx">module</code><code> </code><code class="s1">'react'</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-2" id="co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-2"><img alt="2" src="assets/2.png"/></a><code>&#13;
  </code><code class="kr">interface</code><code> </code><code class="nx">Component</code><code class="o">&lt;</code><code class="nx">P</code><code class="p">,</code><code> </code><code class="nx">S</code><code class="o">&gt;</code><code> </code><code class="p">{</code><code> </code><a class="co" href="#callout_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-3" id="co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-3"><img alt="3" src="assets/3.png"/></a><code>&#13;
    </code><code class="nx">reducer</code><code class="p">(</code><code class="nx">action</code><code>: </code><code class="kt">object</code><code class="p">,</code><code> </code><code class="nx">state</code><code>: </code><code class="kt">S</code><code class="p">)</code><code class="o">:</code><code> </code><code class="nx">S</code><code> </code><a class="co" href="#callout_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-4" id="co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-4"><img alt="4" src="assets/4.png"/></a><code>&#13;
  </code><code class="p">}</code><code>&#13;
</code><code class="p">}</code></pre>&#13;
<dl class="calloutlist">&#13;
<dt><a class="co" href="#co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-1" id="callout_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-1"><img alt="1" src="assets/1.png"/></a></dt>&#13;
<dd><p>We import <code>'react'</code>, switching our extension file into script mode, which we need to be in to consume a React module. Note that there are other ways we could have switched to script mode, like importing something else, exporting something, or exporting an empty object (<code>export {}</code>)—we didn’t have to import <code>'react'</code> specifically.</p></dd>&#13;
<dt><a class="co" href="#co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-2" id="callout_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-2"><img alt="2" src="assets/2.png"/></a></dt>&#13;
<dd><p>We declare the <code>'react'</code> module, indicating to TypeScript that we want to declare types for that specific <code>import</code> path. Because we already installed <code>@types/react</code> (which defines an export for the same exact <code>'react'</code> path), TypeScript will merge this module declaration with the one provided by <code>@types/react</code>.</p></dd>&#13;
<dt><a class="co" href="#co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-3" id="callout_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-3"><img alt="3" src="assets/3.png"/></a></dt>&#13;
<dd><p>We augment the <code>Component</code> interface provided by React by declaring our own <code>Component</code> interface. Following the rules of interface merging (<a data-type="xref" href="ch05.html#interface-merging">“Declaration Merging”</a>), we have to use the same exact signature in our declaration as the one in <code>@types/react</code>.</p></dd>&#13;
<dt><a class="co" href="#co_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-4" id="callout_recipes_for_writing_declaration_files_for_third_party_javascript_modules_CO1-4"><img alt="4" src="assets/4.png"/></a></dt>&#13;
<dd><p>Finally, we declare our <code>reducer</code> method.</p></dd>&#13;
</dl>&#13;
&#13;
<p>After declaring these types (and assuming we’ve implemented the runtime behavior to support this update somewhere), we can now declare React components with built-in <code>reducers</code> in a typesafe way:</p>&#13;
&#13;
<pre data-code-language="ts" data-type="programlisting"><code class="kr">import</code> <code class="o">*</code> <code class="kr">as</code> <code class="nx">React</code> <code class="nx">from</code> <code class="s1">'react'</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">Props</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="c1">// ...</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">State</code> <code class="o">=</code> <code class="p">{</code>&#13;
  <code class="nx">count</code>: <code class="kt">number</code>&#13;
  <code class="nx">item</code>: <code class="kt">string</code>&#13;
<code class="p">}</code>&#13;
&#13;
<code class="nx">type</code> <code class="nx">Action</code> <code class="o">=</code>&#13;
  <code class="o">|</code> <code class="p">{</code><code class="nx">type</code><code class="o">:</code> <code class="s1">'SET_ITEM'</code><code class="p">,</code> <code class="nx">value</code>: <code class="kt">string</code><code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code><code class="nx">type</code><code class="o">:</code> <code class="s1">'INCREMENT_COUNT'</code><code class="p">}</code>&#13;
  <code class="o">|</code> <code class="p">{</code><code class="nx">type</code><code class="o">:</code> <code class="s1">'DECREMENT_COUNT'</code><code class="p">}</code>&#13;
&#13;
<code class="kr">class</code> <code class="nx">ShoppingBasket</code> <code class="kr">extends</code> <code class="nx">React</code><code class="p">.</code><code class="nx">Component</code><code class="o">&lt;</code><code class="nx">Props</code><code class="p">,</code> <code class="nx">State</code><code class="o">&gt;</code> <code class="p">{</code>&#13;
  <code class="nx">reducer</code><code class="p">(</code><code class="nx">action</code>: <code class="kt">Action</code><code class="p">,</code> <code class="nx">state</code>: <code class="kt">State</code><code class="p">)</code><code class="o">:</code> <code class="nx">State</code> <code class="p">{</code>&#13;
    <code class="k">switch</code> <code class="p">(</code><code class="nx">action</code><code class="p">.</code><code class="nx">type</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="k">case</code> <code class="s1">'SET_ITEM'</code><code class="o">:</code>&#13;
        <code class="k">return</code> <code class="p">{...</code><code class="nx">state</code><code class="p">,</code> <code class="nx">item</code>: <code class="kt">action.value</code><code class="p">}</code>&#13;
      <code class="k">case</code> <code class="s1">'INCREMENT_COUNT'</code><code class="o">:</code>&#13;
        <code class="k">return</code> <code class="p">{...</code><code class="nx">state</code><code class="p">,</code> <code class="nx">count</code>: <code class="kt">state.count</code> <code class="o">+</code> <code class="mi">1</code><code class="p">}</code>&#13;
      <code class="k">case</code> <code class="s1">'DECREMENT_COUNT'</code><code class="o">:</code>&#13;
        <code class="k">return</code> <code class="p">{...</code><code class="nx">state</code><code class="p">,</code> <code class="nx">count</code>: <code class="kt">state.count</code> <code class="o">-</code> <code class="mi">1</code><code class="p">}</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>As noted at the start of this section, it’s good practice to avoid this pattern when possible (even though it’s cool) because it can make your modules brittle and dependent on load order. Instead, try to use composition so that your module extensions consume the module they’re extending, and export a wrapper rather than modifying that module.<a data-primary="modules" data-secondary="writing declaration files for third-party JavaScript modules" data-startref="ix_moddec" data-type="indexterm" id="idm46304947609224"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>