- en: Chapter 3\. Functional Programming with JavaScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start to explore React, you’ll likely notice that the topic of functional
    programming comes up a lot. Functional techniques are being used more and more
    in JavaScript projects, particularly React projects.
  prefs: []
  type: TYPE_NORMAL
- en: It’s likely that you’ve already written functional JavaScript code without thinking
    about it. If you’ve mapped or reduced an array, then you’re already on your way
    to becoming a functional JavaScript programmer. Functional programming techniques
    are core not only to React but to many of the libraries in the React ecosystem
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re wondering where this functional trend came from, the answer is the
    1930s, with the invention of *lambda calculus*, or λ-calculus.^([1](ch03.html#idm45901652156344))
    Functions have been a part of calculus since it emerged in the 17th century. Functions
    can be sent to functions as arguments or returned from functions as results.  More
    complex functions, called *higher-order functions*, can manipulate functions and
    use them as either arguments or results or both. In the 1930s, Alonzo Church was
    at Princeton experimenting with these higher-order functions when he invented
    lambda calculus.
  prefs: []
  type: TYPE_NORMAL
- en: In the late 1950s, John McCarthy took the concepts derived from λ-calculus and
    applied them to a new programming language called Lisp. Lisp implemented the concept
    of higher-order functions and functions as *first-class members* or *first-class
    citizens*. A function is considered a first-class member when it can be declared
    as a variable and sent to functions as an argument. These functions can even be
    returned from functions.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’re going to go over some of the key concepts of functional
    programming, and we’ll cover how to implement functional techniques with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: What It Means to Be Functional
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript supports functional programming because JavaScript functions are
    first-class citizens. This means that functions can do the same things that variables
    can do. The latest JavaScript syntax adds language improvements that can beef
    up your functional programming techniques, including arrow functions, promises,
    and the spread operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, functions can represent data in your application. You may have
    noticed that you can declare functions with the `var`, `let`, or `const` keywords
    the same way you can declare strings, numbers, or any other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can write the same function using an arrow function. Functional programmers
    write a lot of small functions, and the arrow function syntax makes that much
    easier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Since functions are variables, we can add them to objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Both of these statements do the same thing: they store a function in a variable
    called `log`. Additionally, the `const` keyword was used to declare the second
    function, which will prevent it from being overwritten.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add functions to arrays in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions can be sent to other functions as arguments, just like other variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'They can also be returned from other functions, just like variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The last two examples were of higher-order functions: functions that either
    take or return other functions. We could describe the same `createScream` higher-order
    function with arrows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If you see more than one arrow used during a function declaration, this means
    that you’re using a higher-order function.
  prefs: []
  type: TYPE_NORMAL
- en: We can say that JavaScript supports functional programming because its functions
    are first-class citizens. This means that functions are data. They can be saved,
    retrieved, or flow through your applications just like variables.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative Versus Declarative
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functional programming is a part of a larger programming paradigm: *declarative
    programming*. Declarative programming is a style of programming where applications
    are structured in a way that prioritizes describing *what* should happen over
    defining *how* it should happen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand declarative programming, we’ll contrast it with *imperative
    programming*, or a style of programming that’s only concerned with how to achieve
    results with code. Let’s consider a common task: making a string URL-friendly.
    Typically, this can be accomplished by replacing all of the spaces in a string
    with hyphens, since spaces are not URL-friendly. First, let’s examine an imperative
    approach to this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we loop through every character in the string, replacing spaces
    as they occur. The structure of this program is only concerned with how such a
    task can be achieved. We use a `for` loop and an `if` statement and set values
    with an equality operator. Just looking at the code alone does not tell us much.
    Imperative programs require lots of comments in order to understand what’s going
    on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s look at a declarative approach to the same problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we are using `string.replace` along with a regular expression to replace
    all instances of spaces with hyphens. Using `string.replace` is a way of describing
    what’s supposed to happen: spaces in the string should be replaced. The details
    of how spaces are dealt with are abstracted away inside the `replace` function.
    In a declarative program, the syntax itself describes what should happen, and
    the details of how things happen are abstracted away.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Declarative programs are easy to reason about because the code itself describes
    what is happening. For example, read the syntax in the following sample. It details
    what happens after members are loaded from an API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The declarative approach is more readable and, thus, easier to reason about.
    The details of how each of these functions is implemented are abstracted away.
    Those tiny functions are named well and combined in a way that describes how member
    data goes from being loaded to being saved and printed on a map, and this approach
    does not require many comments. Essentially, declarative programming produces
    applications that are easier to reason about, and when it’s easier to reason about
    an application, that application is easier to scale. Additional details about
    the declarative programming paradigm can be found at the [Declarative Programming
    wiki](https://oreil.ly/7MbkB).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s consider the task of building a document object model, or [DOM](https://www.w3.org/DOM).
    An imperative approach would be concerned with how the DOM is constructed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This code is concerned with creating elements, setting elements, and adding
    them to the document. It would be very hard to make changes, add features, or
    scale 10,000 lines of code where the DOM is constructed imperatively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s take a look at how we can construct a DOM declaratively using a React
    component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: React is declarative. Here, the `Welcome` component describes the DOM that should
    be rendered. The `render` function uses the instructions declared in the component
    to build the DOM, abstracting away the details of how the DOM is to be rendered.
    We can clearly see that we want to render our `Welcome` component into the element
    with the ID of `target`.
  prefs: []
  type: TYPE_NORMAL
- en: Functional Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you’ve been introduced to functional programming and what it means
    to be “functional” or “declarative,” we’ll move on to introducing the core concepts
    of functional programming: immutability, purity, data transformation, higher-order
    functions, and recursion.'
  prefs: []
  type: TYPE_NORMAL
- en: Immutability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To mutate is to change, so to be *immutable* is to be unchangeable. In a functional
    program, data is immutable. It never changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to share your birth certificate with the public but want to redact
    or remove private information, you essentially have two choices: you can take
    a big Sharpie to your original birth certificate and cross out your private data,
    or you can find a copy machine. Finding a copy machine, making a copy of your
    birth certificate, and writing all over that copy with that big Sharpie would
    be preferable. This way you can have a redacted birth certificate to share and
    your original that’s still intact.'
  prefs: []
  type: TYPE_NORMAL
- en: This is how immutable data works in an application. Instead of changing the
    original data structures, we build changed copies of those data structures and
    use them instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand how immutability works, let’s take a look at what it means to
    mutate data. Consider an object that represents the color `lawn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We could build a function that would rate colors and use that function to change
    the rating of the `color` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'In JavaScript, function arguments are references to the actual data. Setting
    the color’s rating like this changes or mutates the original color object. (Imagine
    if you tasked a business with redacting and sharing your birth certificate and
    they returned your original birth certificate with black marker covering the important
    details. You’d hope that a business would have the common sense to make a copy
    of your birth certificate and return the original unharmed.) We can rewrite the
    `rateColor` function so that it does not harm the original goods (the `color`
    object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used `Object.assign` to change the color rating. `Object.assign` is
    the copy machine. It takes a blank object, copies the color to that object, and
    overwrites the rating on the copy. Now we can have a newly rated color object
    without having to change the original.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write the same function using an arrow function along with the object
    spread operator. This `rateColor` function uses the spread operator to copy the
    color into a new object and then overwrite its rating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This version of the `rateColor` function is exactly the same as the previous
    one. It treats color as an immutable object, does so with less syntax, and looks
    a little bit cleaner. Notice that we wrap the returned object in parentheses.
    With arrow functions, this is a required step since the arrow can’t just point
    to an object’s curly braces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider an array of color names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We could create a function that will add colors to that array using `Array.push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `Array.push` is not an immutable function. This `addColor` function
    changes the original array by adding another field to it. In order to keep the
    `colors` array immutable, we must use `Array.concat` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.concat` concatenates arrays. In this case, it takes a new object with
    a new color title and adds it to a copy of the original array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the spread operator to concatenate arrays in the same way
    it can be used to copy objects. Here’s the emerging JavaScript equivalent of the
    previous `addColor` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This function copies the original list to a new array and then adds a new object
    containing the color’s title to that copy. It is immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Pure Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *pure function* is a function that returns a value that’s computed based on
    its arguments. Pure functions take at least one argument and always return a value
    or another function. They do not cause side effects, set global variables, or
    change anything about application state. They treat their arguments as immutable
    data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to understand pure functions, let’s first take a look at an impure
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `selfEducate` function is not a pure function. It does not take any arguments,
    and it does not return a value or a function. It also changes a variable outside
    of its scope: `Frederick`. Once the `selfEducate` function is invoked, something
    about the “world” has changed. It causes side effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Pure Functions Are Testable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Pure functions are naturally *testable*. They do not change anything about
    their environment or “world,” and therefore do not require a complicated test
    setup or teardown. Everything a pure function needs to operate it accesses via
    arguments. When testing a pure function, you control the arguments, and thus you
    can estimate the outcome. This `selfEducate` function is also impure: it causes
    side effects. Invoking this function mutates the objects that are sent to it.
    If we could treat the arguments sent to this function as immutable data, then
    we would have a pure function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have this function take an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, this version of `selfEducate` is a pure function. It computes a value
    based on the argument that was sent to it: the `person`. It returns a new `person`
    object without mutating the argument sent to it and therefore has no side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s examine an impure function that mutates the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Header` function creates a heading—one element with specific text—and
    adds it to the DOM. This function is impure. It does not return a function or
    a value, and it causes side effects: a changed DOM.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In React, the UI is expressed with pure functions. In the following sample,
    `Header` is a pure function that can be used to create `h1` elements just like
    in the previous example. However, this function on its own does not cause side
    effects because it does not mutate the DOM. This function will create an `h1`
    element, and it’s up to some other part of the application to use that element
    to change the DOM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Pure functions are another core concept of functional programming. They will
    make your life much easier because they will not affect your application’s state.
    When writing functions, try to follow these three rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The function should take in at least one argument.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function should return a value or another function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function should not change or mutate any of its arguments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Data Transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How does anything change in an application if the data is immutable? Functional
    programming is all about transforming data from one form to another. We’ll produce
    transformed copies using functions. These functions make our code less imperative
    and thus reduce complexity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You do not need a special framework to understand how to produce one dataset
    that is based upon another. JavaScript already has the necessary tools for this
    task built into the language. There are two core functions that you must master
    in order to be proficient with functional JavaScript: `Array.map` and `Array.reduce`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll take a look at how these and some other core functions
    transform data from one type to another.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this array of high schools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can get a comma-delimited list of these and some other strings by using
    the `Array.join` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.join` is a built-in JavaScript array method that we can use to extract
    a delimited string from our array. The original array is still intact; `join`
    simply provides a different take on it. The details of how this string is produced
    are abstracted away from the programmer.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wanted to create a function that creates a new array of the schools that
    begin with the letter “W,” we could use the `Array.filter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Array.filter` is a built-in JavaScript function that produces a new array
    from a source array. This function takes a *predicate* as its only argument. A
    predicate is a function that always returns a Boolean value: `true` or `false`.
    `Array.filter` invokes this predicate once for every item in the array. That item
    is passed to the predicate as an argument, and the return value is used to decide
    if that item will be added to the new array. In this case, `Array.filter` is checking
    every school to see if its name begins with a “W.”'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it’s time to remove an item from an array, we should use `Array.filter`
    over `Array.pop` or `Array.splice` because `Array.filter` is immutable. In this
    next sample, the `cutSchool` function returns new arrays that filter out specific
    school names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `cutSchool` function is used to return a new array that does
    not contain “Washington & Liberty.” Then, the `join` function is used with this
    new array to create a string out of the remaining two school names. `cutSchool`
    is a pure function. It takes a list of schools and the name of the school that
    should be removed and returns a new array without that specific school.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another array function that is essential to functional programming is `Array.map`.
    Instead of a predicate, the `Array.map` method takes a function as its argument.
    This function will be invoked once for every item in the array, and whatever it
    returns will be added to the new array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `map` function was used to append “High School” to each school
    name. The `schools` array is still intact.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last example, we produced an array of strings from an array of strings.
    The `map` function can produce an array of objects, values, arrays, other functions—any
    JavaScript type. Here’s an example of the `map` function returning an object for
    every school:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: An array containing objects was produced from an array that contains strings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need to create a pure function that changes one object in an array of
    objects, `map` can be used for this, too. In the following example, we’ll change
    the school with the name of “Stratford” to “HB Woodlawn” without mutating the
    `schools` array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `schools` array is an array of objects. The `updatedSchools` variable calls
    the `editName` function and we send it the school we want to update, the new school,
    and the `schools` array. This changes the new array but makes no edits to the
    original:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Within `editName`, the `map` function is used to create a new array of objects
    based upon the original array. The `editName` function can be written entirely
    in one line. Here’s an example of the same function using a shorthand `if/else`
    statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: If you need to transform an array into an object, you can use `Array.map` in
    conjunction with `Object.keys`. `Object.keys` is a method that can be used to
    return an array of keys from an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we needed to transform the `schools` object into an array of schools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, `Object.keys` returns an array of school names, and we can
    use `map` on that array to produce a new array of the same length. The `name`
    of the new object will be set using the key, and `wins` is set equal to the value.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve learned that we can transform arrays with `Array.map` and `Array.filter`.
    We’ve also learned that we can change arrays into objects by combining `Object.keys`
    with `Array.map`. The final tool that we need in our functional arsenal is the
    ability to transform arrays into primitives and other objects.
  prefs: []
  type: TYPE_NORMAL
- en: The `reduce` and `reduceRight` functions can be used to transform an array into
    any value, including a number, string, boolean, object, or even a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say we need to find the maximum number in an array of numbers. We need
    to transform an array into a number; therefore, we can use `reduce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ages` array has been reduced into a single value: the maximum age, `64`.
    `reduce` takes two arguments: a callback function and an original value. In this
    case, the original value is `0`, which sets the initial maximum value to `0`.
    The callback is invoked once for every item in the array. The first time this
    callback is invoked, `age` is equal to `21`, the first value in the array, and
    `max` is equal to `0`, the initial value. The callback returns the greater of
    the two numbers, `21`, and that becomes the `max` value during the next iteration.
    Each iteration compares each `age` against the `max` value and returns the greater
    of the two. Finally, the last number in the array is compared and returned from
    the previous callback.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If we remove the `console.log` statement from the preceding function and use
    a shorthand `if/else` statement, we can calculate the max value in any array of
    numbers with the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Array.reduceRight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Array.reduceRight` works the same way as `Array.reduce`; the difference is
    that it starts reducing from the end of the array rather than the beginning.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes we need to transform an array into an object. The following example
    uses `reduce` to transform an array that contains colors into a hash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the second argument sent to the `reduce` function is an empty
    object. This is our initial value for the hash. During each iteration, the callback
    function adds a new key to the hash using bracket notation and sets the value
    for that key to the `id` field of the array. `Array.reduce` can be used in this
    way to reduce an array to a single value—in this case, an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even transform arrays into completely different arrays using `reduce`.
    Consider reducing an array with multiple instances of the same value to an array
    of unique values. The `reduce` method can be used to accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `colors` array is reduced to an array of distinct values.
    The second argument sent to the `reduce` function is an empty array. This will
    be the initial value for `distinct`. When the `distinct` array does not already
    contain a specific color, it will be added. Otherwise, it will be skipped, and
    the current `distinct` array will be returned.
  prefs: []
  type: TYPE_NORMAL
- en: '`map` and `reduce` are the main weapons of any functional programmer, and JavaScript
    is no exception. If you want to be a proficient JavaScript engineer, then you
    must master these functions. The ability to create one dataset from another is
    a required skill and is useful for any type of programming paradigm.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-Order Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of *higher-order functions* is also essential to functional programming.
    We’ve already mentioned higher-order functions, and we’ve even used a few in this
    chapter. Higher-order functions are functions that can manipulate other functions.
    They can take functions in as arguments or return functions or both.
  prefs: []
  type: TYPE_NORMAL
- en: The first category of higher-order functions are functions that expect other
    functions as arguments. `Array.map`, `Array.filter`, and `Array.reduce` all take
    functions as arguments. They are higher-order functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at how we can implement a higher-order function. In the following
    example, we create an `invokeIf` callback function that will test a condition
    and invoke a callback function when it’s true and another callback function when
    the condition is false:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '`invokeIf` expects two functions: one for true and one for false. This is demonstrated
    by sending both `showWelcome` and `showUnauthorized` to `invokeIf`. When the condition
    is true, `showWelcome` is invoked. When it’s false, `showUnauthorized` is invoked.'
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order functions that return other functions can help us handle the complexities
    associated with asynchronicity in JavaScript. They can help us create functions
    that can be used or reused at our convenience.
  prefs: []
  type: TYPE_NORMAL
- en: '*Currying* is a functional technique that involves the use of higher-order
    functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of currying. The `userLogs` function hangs on to
    some information (the username) and returns a function that can be used and reused
    when the rest of the information (the message) is made available. In this example,
    log messages will all be prepended with the associated username. Notice that we’re
    using the `getFakeMembers` function that returns a promise from [Chapter 2](ch02.html#javascript-for-react):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '`userLogs` is the higher-order function. The `log` function is produced from
    `userLogs`, and every time the `log` function is used, “grandpa23” is prepended
    to the message.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Recursion is a technique that involves creating functions that recall themselves.
    Often, when faced with a challenge that involves a loop, a recursive function
    can be used instead. Consider the task of counting down from 10\. We could create
    a `for` loop to solve this problem, or we could alternatively use a recursive
    function. In this example, `countdown` is the recursive function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '`countdown` expects a number and a function as arguments. In this example,
    it’s invoked with a value of `10` and a callback function. When `countdown` is
    invoked, the callback is invoked, which logs the current value. Next, `countdown`
    checks the value to see if it’s greater than `0`. If it is, `countdown` recalls
    itself with a decremented value. Eventually, the value will be `0`, and `countdown`
    will return that value all the way back up the call stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursion is a pattern that works particularly well with asynchronous processes.
    Functions can recall themselves when they’re ready, like when the data is available
    or when a timer has finished.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `countdown` function can be modified to count down with a delay. This modified
    version of the `countdown` function can be used to create a countdown clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create a 10-second countdown by initially invoking `countdown`
    once with the number `10` in a function that logs the countdown. Instead of recalling
    itself right away, the `countdown` function waits one second before recalling
    itself, thus creating a clock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recursion is a good technique for searching data structures. You can use recursion
    to iterate through subfolders until a folder that contains only files is identified.
    You can also use recursion to iterate though the HTML DOM until you find an element
    that does not contain any children. In the next example, we’ll use recursion to
    iterate deeply into an object to retrieve a nested value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '`deepPick` can be used to access `Dan`’s type, stored immediately in the first
    object, or to dig down into nested objects to locate `Dan`’s first name. Sending
    a string that uses dot notation, we can specify where to locate values that are
    nested deep within an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The `deepPick` function is either going to return a value or recall itself until
    it eventually returns a value. First, this function splits the dot-notated fields
    string into an array and uses array destructuring to separate the first value
    from the remaining values. If there are remaining values, `deepPick` recalls itself
    with slightly different data, allowing it to dig one level deeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function continues to call itself until the fields string no longer contains
    dots, meaning that there are no more remaining fields. In this sample, you can
    see how the values for `first`, `remaining`, and `object[first]` change as `deepPick`
    iterates through:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Recursion is a powerful functional technique that’s fun to implement.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functional programs break up their logic into small, pure functions that are
    focused on specific tasks. Eventually, you’ll need to put these smaller functions
    together. Specifically, you may need to combine them, call them in series or parallel,
    or compose them into larger functions until you eventually have an application.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to composition, there are a number of different implementations,
    patterns, and techniques. One that you may be familiar with is chaining. In JavaScript,
    functions can be chained together using dot notation to act on the return value
    of the previous function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings have a replace method. The replace method returns a template string,
    which will also have a replace method. Therefore, we can chain together replace
    methods with dot notation to transform a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the template is a string. By chaining replace methods to the
    end of the template string, we can replace hours, minutes, seconds, and time of
    day in the string with new values. The template itself remains intact and can
    be reused to create more clock time displays.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `both` function is one function that pipes a value through two separate
    functions. The output of civilian hours becomes the input for `appendAMPM`, and
    we can change a date using both of these functions combined into one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: However, this syntax is hard to comprehend and therefore tough to maintain or
    scale. What happens when we need to send a value through 20 different functions?
  prefs: []
  type: TYPE_NORMAL
- en: 'A more elegant approach is to create a higher-order function we can use to
    compose functions into larger functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This approach looks much better. It’s easy to scale because we can add more
    functions at any point. This approach also makes it easy to change the order of
    the composed functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `compose` function is a higher-order function. It takes functions as arguments
    and returns a single value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`compose` takes in functions as arguments and returns a single function. In
    this implementation, the spread operator is used to turn those function arguments
    into an array called `fns`. A function is then returned that expects one argument,
    `arg`. When this function is invoked, the `fns` array is piped starting with the
    argument we want to send through the function. The argument becomes the initial
    value for `compose`, then each iteration of the reduced callback returns. Notice
    that the callback takes two arguments: composed and a function `f`. Each function
    is invoked with `compose`, which is the result of the previous function’s output.
    Eventually, the last function will be invoked and the last result returned.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple example of a `compose` function designed to illustrate composition
    techniques. This function becomes more complex when it’s time to handle more than
    one argument or deal with arguments that are not functions.
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve been introduced to the core concepts of functional programming,
    let’s put those concepts to work for us and build a small JavaScript application.
  prefs: []
  type: TYPE_NORMAL
- en: Our challenge is to build a ticking clock. The clock needs to display hours,
    minutes, seconds, and time of day in civilian time. Each field must always have
    double digits, meaning leading zeros need to be applied to single-digit values
    like 1 or 2\. The clock must also tick and change the display every second.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s review an imperative solution for the clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This solution works, and the comments help us understand what’s happening. However,
    these functions are large and complicated. Each function does a lot. They’re hard
    to comprehend, they require comments, and they’re tough to maintain. Let’s see
    how a functional approach can produce a more scalable application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our goal will be to break the application logic up into smaller parts: functions.
    Each function will be focused on a single task, and we’ll compose them into larger
    functions that we can use to create the clock.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create some functions that give us values and manage the console.
    We’ll need a function that gives us one second, a function that gives us the current
    time, and a couple of functions that will log messages on a console and clear
    the console. In functional programs, we should use functions over values wherever
    possible. We’ll invoke the function to obtain the value when needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we’ll need some functions for transforming data. These three functions
    will be used to mutate the `Date` object into an object that can be used for our
    clock:'
  prefs: []
  type: TYPE_NORMAL
- en: '`serializeClockTime`'
  prefs: []
  type: TYPE_NORMAL
- en: Takes a date object and returns an object for clock time that contains hours,
    minutes, and seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '`civilianHours`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Takes the clock time object and returns an object where hours are converted
    to civilian time. For example: 1300 becomes 1:00.'
  prefs: []
  type: TYPE_NORMAL
- en: '`appendAMPM`'
  prefs: []
  type: TYPE_NORMAL
- en: Takes the clock time object and appends time of day (AM or PM) to that object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: These three functions are used to transform data without changing the original.
    They treat their arguments as immutable objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we’ll need a few higher-order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`display`'
  prefs: []
  type: TYPE_NORMAL
- en: Takes a target function and returns a function that will send a time to the
    target. In this example, the target will be `console.log`.
  prefs: []
  type: TYPE_NORMAL
- en: '`formatClock`'
  prefs: []
  type: TYPE_NORMAL
- en: Takes a template string and uses it to return clock time formatted based on
    the criteria from the string. In this example, the template is “hh:mm:ss tt”.
    From there, `formatClock` will replace the placeholders with hours, minutes, seconds,
    and time of day.
  prefs: []
  type: TYPE_NORMAL
- en: '`prependZero`'
  prefs: []
  type: TYPE_NORMAL
- en: Takes an object’s key as an argument and prepends a zero to the value stored
    under that object’s key. It takes in a key to a specific field and prepends values
    with a zero if the value is less than 10.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: These higher-order functions will be invoked to create the functions that will
    be reused to format the clock time for every tick. Both `formatClock` and `prependZero`
    will be invoked once, initially setting up the required template or key. The inner
    functions they return will be invoked once every second to format the time for
    display.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have all of the functions required to build a ticking clock, we’ll
    need to compose them. We’ll use the `compose` function that we defined in the
    last section to handle composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '`convertToCivilianTime`'
  prefs: []
  type: TYPE_NORMAL
- en: A single function that takes clock time as an argument and transforms it into
    civilian time by using both civilian hours.
  prefs: []
  type: TYPE_NORMAL
- en: '`doubleDigits`'
  prefs: []
  type: TYPE_NORMAL
- en: A single function that takes civilian clock time and makes sure the hours, minutes,
    and seconds display double digits by prepending zeros where needed.
  prefs: []
  type: TYPE_NORMAL
- en: '`startTicking`'
  prefs: []
  type: TYPE_NORMAL
- en: Starts the clock by setting an interval that invokes a callback every second.
    The callback is composed using all our functions. Every second the console is
    cleared, `currentTime` is obtained, converted, civilianized, formatted, and displayed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This declarative version of the clock achieves the same results as the imperative
    version. However, there quite a few benefits to this approach. First, all of these
    functions are easily testable and reusable. They can be used in future clocks
    or other digital displays. Also, this program is easily scalable. There are no
    side effects. There are no global variables outside of functions themselves. There
    could still be bugs, but they’ll be easier to find.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ve introduced functional programming principles. Throughout
    the book when we discuss best practices in React, we’ll continue to demonstrate
    how many React concepts are based in functional techniques. In the next chapter,
    we’ll dive into React officially with an improved understanding of the principles
    that guided its development.
  prefs: []
  type: TYPE_NORMAL
- en: '^([1](ch03.html#idm45901652156344-marker)) Dana S. Scott, [“λ-Calculus: Then
    & Now”](https://oreil.ly/k0EpX).'
  prefs: []
  type: TYPE_NORMAL
