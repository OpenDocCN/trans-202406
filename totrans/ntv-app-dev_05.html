<html><head></head><body><section data-pdf-bookmark="Chapter 4. User Input" data-type="chapter" epub:type="chapter"><div class="chapter" id="topics_user_input">&#13;
<h1><span class="label">Chapter 4. </span>User Input</h1>&#13;
&#13;
&#13;
<p>For<a data-primary="user input" data-secondary="forms of" data-type="indexterm" id="idm46177239433032"/> decades, the primary means by which to interface with computers was by keyboard and mouse. A user was, quite literally, tethered to the device that they were using. The only way to get work done was to sit down at a workstation and get started. Eventually, laptops and notebooks allowed more mobility, but the input mechanisms were mostly the same.</p>&#13;
&#13;
<p>Then came touch.</p>&#13;
&#13;
<p>Today, Android and iOS devices are no longer kept an arm’s length away from a user. They exist in intimate, physical contact with users. When a button is pressed, it is, from the user’s perspective, tapped directly instead of through a trackpad or keyboard shortcut. This makes input one of the most critically important aspects of transforming any old app into a dynamic work of art that understands its user.</p>&#13;
&#13;
<p>Input can take many shapes and form: tapping links in a web view, typing a password into a login form, or swiping across the screen at faces to see if there is an emotional connection with another lonely soul that might lead to the start of a relationship—or maybe even eventually blossom into love. The stakes are high, but the platforms are there to support you with a robust set of tools to take raw input from a user and transform it into an action that has a result they can see, hear, or touch.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Tasks" data-type="sect1"><div class="sect1" id="idm46177239429208">&#13;
<h1>Tasks</h1>&#13;
&#13;
<p>In<a data-primary="user input" data-secondary="task overview" data-type="indexterm" id="idm46177239427880"/> this chapter, you’ll learn to:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Receive and react to a tap.</p>&#13;
</li>&#13;
<li>&#13;
<p>Receive and react to keyboard input.</p>&#13;
</li>&#13;
<li>&#13;
<p>Handle compound gestures.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Android" data-type="sect1"><div class="sect1" id="idm46177239423384">&#13;
<h1>Android</h1>&#13;
&#13;
<p>While Android gesture APIs can be a little cumbersome, they are fairly transparent, and as a developer, you’ll have all the information and access required to satisfy  even the most demanding touch-heavy apps.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Receive and React to a Tap" data-type="sect2"><div class="sect2" id="idm46177239421464">&#13;
<h2>Receive and React to a Tap</h2>&#13;
&#13;
<p>The<a data-primary="user input" data-secondary="Android" data-tertiary="taps" data-type="indexterm" id="UItap04"/><a data-primary="Android" data-secondary="user input" data-tertiary="taps" data-type="indexterm" id="Atap04"/><a data-primary="taps" data-secondary="Android" data-type="indexterm" id="tap04"/> tap is perhaps the most common form of user input in most modern mobile applications. Whether it’s tapping a button to submit a form, tapping an input text field to set focus to it, long tapping to reveal contextual options, or double tapping to zoom in or out of a map, this event is an intuitive expression of selection and <span class="keep-together">acceptance</span>.</p>&#13;
&#13;
<p>It’s no surprise then that the Android framework makes capturing taps both simple and highly available.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>For<a data-primary="clicks" data-type="indexterm" id="idm46177239412424"/> legacy reasons, the Android framework still uses the term “click” in some cases. In most touchscreen frameworks, “click” is synonymous with “tap.”</p>&#13;
</div>&#13;
&#13;
<p>All<a data-primary="View.OnClickListener" data-type="indexterm" id="VIonclicklisten04"/> <code>View</code> instances (including <code>ViewGroups</code>) accept a <code>View.OnClickListener</code> as a settable property (via <code>setOnClickListener</code>). Once set, the framework handles the underlying complexity, and the listener’s <code>onClick</code> method will be fired when any gesture matches the framework’s qualifications. To remove an action due to a tap on a given view, simply set the listener to null: <code>myView.setOnClickListener(null);</code>.</p>&#13;
&#13;
<p>Note that <code>View.OnClickListener</code> is a simple functional interface with a single method: <code>onClick(View view)</code>. This is literally copied and pasted from <a href="https://oreil.ly/NGg8e">the source code</a> at the time of this writing:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">interface</code> <code class="nc">OnClickListener</code> <code class="o">{</code>&#13;
  <code class="kt">void</code> <code class="nf">onClick</code><code class="o">(</code><code class="n">View</code> <code class="n">v</code><code class="o">);</code>&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>This kind of architecture means that the interface can be implemented at virtually any level—on a controller like an <code>Activity</code> or <code>Fragment</code>, on the <code>View</code> instance itself, or on an anonymous class, a lambda, or a method reference. Additionally, click listeners can be assigned in XML layouts. We’ll take a look at each of these approaches.</p>&#13;
&#13;
<p>Using<a data-primary="Kotlin" data-secondary="user input" data-tertiary="taps" data-type="indexterm" id="KUtap04"/><a data-primary="Java" data-secondary="user input" data-tertiary="taps" data-type="indexterm" id="JUtap04"/> a controller to implement <code>View.OnClickListener</code>:</p>&#13;
<aside class="java-kotlin less_space pagebreak-before" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177239385976">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyActivity</code> <code class="kd">extends</code> <code class="n">Activity</code> <code class="kd">implements</code> <code class="n">View</code><code class="o">.</code><code class="na">OnClickListener</code> <code class="o">{</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
   <code class="kd">protected</code> <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">Bundle</code> <code class="n">savedInstanceState</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kd">super</code><code class="o">.</code><code class="na">onCreate</code><code class="o">(</code><code class="n">savedInstanceState</code><code class="o">);</code>&#13;
    <code class="n">Button</code> <code class="n">button</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Button</code><code class="o">(</code><code class="k">this</code><code class="o">);</code>&#13;
    <code class="n">button</code><code class="o">.</code><code class="na">setText</code><code class="o">(</code><code class="s">"Click me!"</code><code class="o">);</code>&#13;
    <code class="n">button</code><code class="o">.</code><code class="na">setOnClickListener</code><code class="o">(</code><code class="k">this</code><code class="o">);</code>&#13;
    <code class="n">setContentView</code><code class="o">(</code><code class="n">button</code><code class="o">);</code>&#13;
   <code class="o">}</code>&#13;
&#13;
   <code class="nd">@Override</code>&#13;
   <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onClick</code><code class="o">(</code><code class="n">View</code> <code class="n">view</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"View was clicked "</code> <code class="o">+</code> <code class="n">view</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code>&#13;
   <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyActivity</code> <code class="p">:</code> <code class="n">Activity</code><code class="p">(),</code> <code class="n">View</code><code class="p">.</code><code class="n">OnClickListener</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">button</code> <code class="p">=</code> <code class="n">Button</code><code class="p">(</code><code class="k">this</code><code class="p">)</code>&#13;
    <code class="n">button</code><code class="p">.</code><code class="n">text</code> <code class="p">=</code> <code class="s">"Click me!"</code>&#13;
    <code class="n">button</code><code class="p">.</code><code class="n">setOnClickListener</code><code class="p">(</code><code class="k">this</code><code class="p">)</code>&#13;
    <code class="n">setContentView</code><code class="p">(</code><code class="n">button</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onClick</code><code class="p">(</code><code class="n">view</code><code class="p">:</code> <code class="n">View</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"View was clicked $view"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Using a controller to implement a method reference:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177239250440">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyActivity</code> <code class="kd">extends</code> <code class="n">Activity</code> <code class="o">{</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
   <code class="kd">protected</code> <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">Bundle</code> <code class="n">savedInstanceState</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kd">super</code><code class="o">.</code><code class="na">onCreate</code><code class="o">(</code><code class="n">savedInstanceState</code><code class="o">);</code>&#13;
    <code class="n">Button</code> <code class="n">button</code> <code class="o">=</code> <code class="k">new</code> <code class="n">Button</code><code class="o">(</code><code class="k">this</code><code class="o">);</code>&#13;
    <code class="n">button</code><code class="o">.</code><code class="na">setText</code><code class="o">(</code><code class="s">"Click me!"</code><code class="o">);</code>&#13;
    <code class="n">button</code><code class="o">.</code><code class="na">setOnClickListener</code><code class="o">(</code><code class="k">this</code><code class="o">::</code><code class="n">myClickMethod</code><code class="o">);</code>&#13;
    <code class="n">setContentView</code><code class="o">(</code><code class="n">button</code><code class="o">);</code>&#13;
   <code class="o">}</code>&#13;
&#13;
   <code class="kd">public</code> <code class="kt">void</code> <code class="nf">myClickMethod</code><code class="o">(</code><code class="n">View</code> <code class="n">view</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"View was clicked "</code> <code class="o">+</code> <code class="n">view</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code>&#13;
   <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p class="less_space pagebreak-before"><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyActivity</code> <code class="p">:</code> <code class="n">Activity</code><code class="p">()</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code>&#13;
    <code class="k">val</code> <code class="py">button</code> <code class="p">=</code> <code class="n">Button</code><code class="p">(</code><code class="k">this</code><code class="p">)</code>&#13;
    <code class="n">button</code><code class="p">.</code><code class="n">text</code> <code class="p">=</code> <code class="s">"Click me!"</code>&#13;
    <code class="n">button</code><code class="p">.</code><code class="n">setOnClickListener</code><code class="p">(</code><code class="o">::</code><code class="n">onClick</code><code class="p">)</code>&#13;
    <code class="n">setContentView</code><code class="p">(</code><code class="n">button</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">fun</code> <code class="nf">onClick</code><code class="p">(</code><code class="n">view</code><code class="p">:</code> <code class="n">View</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"View was clicked $view"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Using a lambda:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177239028600">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">button</code><code class="o">.</code><code class="na">setOnClickListener</code><code class="o">(</code><code class="n">view</code> <code class="o">-&gt;</code> <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"clicked!"</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">button</code><code class="p">.</code><code class="n">setOnClickListener</code> <code class="p">{</code> <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"clicked!"</code><code class="p">)</code> <code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Using an anonymous class instance:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177238909256">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">button</code><code class="o">.</code><code class="na">setOnClickListener</code><code class="o">(</code><code class="k">new</code> <code class="n">View</code><code class="o">.</code><code class="na">OnClickListener</code><code class="o">()</code> <code class="o">{</code>&#13;
  <code class="kd">private</code> <code class="kt">boolean</code> <code class="n">mToggled</code><code class="o">;</code>&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onClick</code><code class="o">(</code><code class="n">View</code> <code class="n">view</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">mToggled</code> <code class="o">=</code> <code class="o">!</code><code class="n">mToggled</code><code class="o">;</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"toggled? "</code> <code class="o">+</code> <code class="n">mToggled</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
<code class="o">});</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="n">button</code><code class="p">.</code><code class="n">setOnClickListener</code><code class="p">(</code><code class="k">object</code><code class="p">:</code><code class="n">View</code><code class="p">.</code><code class="n">OnClickListener</code><code class="p">()</code> <code class="p">{</code>&#13;
  <code class="k">private</code> <code class="k">var</code> <code class="py">toggled</code><code class="p">:</code><code class="n">Boolean</code> <code class="p">=</code> <code class="k">false</code>&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onClick</code><code class="p">(</code><code class="n">view</code><code class="p">:</code><code class="n">View</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">toggled</code> <code class="p">=</code> <code class="p">!</code><code class="n">toggled</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"toggled? $toggled"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>On a <code>View</code> subclass that will always have the same click behavior:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177238709176">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyButton</code> <code class="kd">extends</code> <code class="n">Button</code> <code class="kd">implements</code> <code class="n">View</code><code class="o">.</code><code class="na">OnClickListener</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">MyButton</code><code class="o">(</code><code class="n">Context</code> <code class="n">context</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">this</code><code class="o">(</code><code class="n">context</code><code class="o">,</code> <code class="kc">null</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">MyButton</code><code class="o">(</code><code class="n">Context</code> <code class="n">context</code><code class="o">,</code> <code class="nd">@Nullable</code> <code class="n">AttributeSet</code> <code class="n">attrs</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">this</code><code class="o">(</code><code class="n">context</code><code class="o">,</code> <code class="n">attrs</code><code class="o">,</code> <code class="mi">0</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="kd">public</code> <code class="nf">MyButton</code><code class="o">(</code><code class="n">Context</code> <code class="n">context</code><code class="o">,</code> <code class="nd">@Nullable</code> <code class="n">AttributeSet</code> <code class="n">attrs</code><code class="o">,</code> <code class="kt">int</code> <code class="n">defStyleAttr</code><code class="o">)</code> <code class="o">{</code>&#13;
   <code class="kd">super</code><code class="o">(</code><code class="n">context</code><code class="o">,</code> <code class="n">attrs</code><code class="o">,</code> <code class="n">defStyleAttr</code><code class="o">);</code>&#13;
   <code class="n">setOnClickListener</code><code class="o">(</code><code class="k">this</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onClick</code><code class="o">(</code><code class="n">View</code> <code class="n">view</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">mToggled</code> <code class="o">=</code> <code class="o">!</code><code class="n">mToggled</code><code class="o">;</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"toggled? "</code> <code class="o">+</code> <code class="n">mToggled</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
 <code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyButton</code> <code class="n">@JvmOverloads</code> <code class="n">constructor</code><code class="p">(</code><code class="n">context</code><code class="p">:</code> <code class="n">Context</code><code class="p">,</code> <code class="n">attrs</code><code class="p">:</code> <code class="n">AttributeSet</code><code class="p">?</code> <code class="p">=</code> <code class="k">null</code><code class="p">,</code>&#13;
  <code class="n">defStyleAttr</code><code class="p">:</code> <code class="n">Int</code> <code class="p">=</code> <code class="m">0</code><code class="p">)</code> <code class="p">:</code> <code class="n">Button</code><code class="p">(</code><code class="n">context</code><code class="p">,</code> <code class="n">attrs</code><code class="p">,</code> <code class="n">defStyleAttr</code><code class="p">),</code> <code class="n">View</code><code class="p">.</code><code class="n">OnClickListener</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">var</code> <code class="py">toggled</code> <code class="p">=</code> <code class="k">false</code>&#13;
&#13;
  <code class="n">init</code> <code class="p">{</code>&#13;
    <code class="n">setOnClickListener</code><code class="p">(</code><code class="k">this</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onClick</code><code class="p">(</code><code class="n">view</code><code class="p">:</code> <code class="n">View</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">toggled</code> <code class="p">=</code> <code class="p">!</code><code class="n">toggled</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"toggled? $toggled"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Finally, you can use a method name (as a <code>String</code>) in the XML of a layout to assign a click listener. The containing <code>Activity</code> must have a public method with that name, which matches the signature of <code>View.OnClickListener.onClick</code>:</p>&#13;
&#13;
<pre data-code-language="xml" data-type="programlisting"><code class="c">&lt;!-- contents of res/layout/myactivity_layout.xml --&gt;</code>&#13;
<code class="nt">&lt;Button</code> <code class="na">xmlns:android=</code><code class="s">"http://schemas.android.com/apk/res/android"</code>&#13;
    <code class="na">android:layout_width=</code><code class="s">"wrap_content"</code>&#13;
    <code class="na">android:layout_height=</code><code class="s">"wrap_content"</code>&#13;
    <code class="na">android:text=</code><code class="s">"Click me!"</code>&#13;
    <code class="na">android:onClick=</code><code class="s">"myClickHandler"</code> <code class="nt">/&gt;</code></pre>&#13;
&#13;
<p>Note the <code>Activity</code> will automatically pick up the relationship and create the binding logic, without explicit references to either the method or the <code>View</code>:</p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyActivity</code> <code class="kd">extends</code> <code class="n">Activity</code> <code class="o">{</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
   <code class="kd">protected</code> <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">Bundle</code> <code class="n">savedInstanceState</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kd">super</code><code class="o">.</code><code class="na">onCreate</code><code class="o">(</code><code class="n">savedInstanceState</code><code class="o">);</code>&#13;
    <code class="n">setContentView</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">layout</code><code class="o">.</code><code class="na">myactivity_layout</code><code class="o">);</code>&#13;
   <code class="o">}</code>&#13;
&#13;
   <code class="kd">public</code> <code class="kt">void</code> <code class="nf">myClickHandler</code><code class="o">(</code><code class="n">View</code> <code class="n">view</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"View was clicked "</code> <code class="o">+</code> <code class="n">view</code><code class="o">.</code><code class="na">toString</code><code class="o">());</code>&#13;
   <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p>Note that a <code>View</code> can have at most a single <code>OnClickListener</code> set at any given time. In order to have multiple click listeners, you’ll either need to update the listener to call other listeners, or create a small framework to support it. For example, you could use the following to manage a list of callbacks in a single listener:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177238325032">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">CompositeClickListener</code> <code class="kd">extends</code> <code class="n">ArrayList</code><code class="o">&lt;</code><code class="n">View</code><code class="o">.</code><code class="na">OnClickListener</code><code class="o">&gt;</code>&#13;
  <code class="kd">implements</code> <code class="n">View</code><code class="o">.</code><code class="na">OnClickListener</code> <code class="o">{</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onClick</code><code class="o">(</code><code class="n">View</code> <code class="n">view</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="k">for</code> <code class="o">(</code><code class="n">View</code><code class="o">.</code><code class="na">OnClickListener</code> <code class="n">listener</code> <code class="o">:</code> <code class="k">this</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="n">lister</code><code class="o">.</code><code class="na">onClick</code><code class="o">(</code><code class="n">view</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
  <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">CompositeClickListener</code> <code class="p">:</code> <code class="n">ArrayList</code><code class="p">&lt;</code><code class="n">View</code><code class="p">.</code><code class="n">OnClickListener</code><code class="p">&gt;(),</code> <code class="n">View</code><code class="p">.</code><code class="n">OnClickListener</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onClick</code><code class="p">(</code><code class="n">view</code><code class="p">:</code> <code class="n">View</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="k">for</code> <code class="p">(</code><code class="n">listener</code> <code class="k">in</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>&#13;
      <code class="n">listener</code><code class="p">.</code><code class="n">onClick</code><code class="p">(</code><code class="n">view</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>This could be used as follows:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177238243448">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre data-code-language="java" data-type="programlisting"><code class="n">CompositeClickListener</code> <code class="n">listener</code> <code class="o">=</code> <code class="k">new</code> <code class="n">CompositeClickListener</code><code class="o">();</code>&#13;
<code class="n">listener</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">view</code> <code class="o">-&gt;</code> <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"hello!"</code><code class="o">);</code>&#13;
<code class="n">listener</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">view</code> <code class="o">-&gt;</code> <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"hola!"</code><code class="o">);</code>&#13;
<code class="n">listener</code><code class="o">.</code><code class="na">add</code><code class="o">(</code><code class="n">view</code> <code class="o">-&gt;</code> <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"bonjour!"</code><code class="o">);</code>&#13;
<code class="n">myView</code><code class="o">.</code><code class="na">setOnClickListener</code><code class="o">(</code><code class="n">listener</code><code class="o">);</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">listener</code> <code class="p">=</code> <code class="n">CompositeClickListener</code><code class="p">()</code>&#13;
<code class="n">listener</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">View</code><code class="p">.</code><code class="n">OnClickListener</code><code class="p">{</code> <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"hello!"</code><code class="p">)</code> <code class="p">})</code>&#13;
<code class="n">listener</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">View</code><code class="p">.</code><code class="n">OnClickListener</code><code class="p">{</code> <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"hola!"</code><code class="p">)</code> <code class="p">})</code>&#13;
<code class="n">listener</code><code class="p">.</code><code class="n">add</code><code class="p">(</code><code class="n">View</code><code class="p">.</code><code class="n">OnClickListener</code><code class="p">{</code> <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"bonjour!"</code><code class="p">})</code>&#13;
<code class="n">myView</code><code class="p">.</code><code class="n">setOnClickListener</code><code class="p">(</code><code class="n">listener</code><code class="p">)</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>While this might seem like a broad range of options to handle tap events, this is really just the tip of the iceberg. The Android framework provides access to touch events at multiple levels, and you could implement your own tap logic if you so choose—for example, you might want to fire a tap only after some delay, or you might want a more liberal (or more conservative) “wander” area (how far the original touch event can have traveled before it is no longer considered a tap). Fortunately, it’s unlikely you’ll ever need to do that, but we’ll dig into gesture management later in this chapter.<a data-primary="" data-startref="JUtap04" data-type="indexterm" id="idm46177238001832"/><a data-primary="" data-startref="KUtap04" data-type="indexterm" id="idm46177238000984"/><a data-primary="" data-startref="tap04" data-type="indexterm" id="idm46177238000072"/><a data-primary="" data-startref="Atap04" data-type="indexterm" id="idm46177237999128"/><a data-primary="" data-startref="UItap04" data-type="indexterm" id="idm46177237998184"/><a data-primary="" data-startref="VIonclicklisten04" data-type="indexterm" id="idm46177237997240"/></p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Receive and React to Keyboard Input" data-type="sect2"><div class="sect2" id="idm46177238102616">&#13;
<h2>Receive and React to Keyboard Input</h2>&#13;
&#13;
<p>The<a data-primary="user input" data-secondary="Android" data-tertiary="keyboards" data-type="indexterm" id="UIKey04"/><a data-primary="Android" data-secondary="user input" data-tertiary="keyboards" data-type="indexterm" id="AUIkey04"/><a data-primary="keyboard input" data-secondary="Android" data-type="indexterm" id="keyb04"/> Android framework handles key events quite differently than other UI frameworks you might have dealt with. Even<a data-primary="KeyEvent API" data-type="indexterm" id="idm46177237990904"/> <code>KeyEvent</code>—which is probably the API you’d expect to be dealing with directly—is very rarely accessed directly by a developer. Note that even the current documentation states:</p>&#13;
<blockquote>&#13;
<p>As soft input methods can use multiple and inventive ways of inputting text, there is no guarantee that any key press on a soft keyboard will generate a key event: this is left to the IME’s discretion, and in fact sending such events is discouraged. You should never rely on receiving KeyEvents for any key on a soft input method.</p></blockquote>&#13;
&#13;
<p>This simply states that key events from “soft” (on-screen) keyboards are not guaranteed. They are guaranteed for “hard” keyboards (physical keyboards, like you’d find on a small selection of modern smartphones, or a portable keyboard attached via Bluetooth or USB); however, this isn’t very helpful since the great majority of key input events you’ll want to react to will be generated from a soft keyboard. Further, even hooking into these events requires some fairly complicated setup, including binding to an “IME” (input method), registering for focus, expanding and contracting a keyboard as required, etc.</p>&#13;
&#13;
<p>When digging deeper into the developer documentation, we find a section entitled “Handle Keyboard Actions.” Sounds promising, but again we’re immediately presented with an attention-grabbing banner:</p>&#13;
<blockquote>&#13;
<p>When handling keyboard events with the KeyEvent class and related APIs, you should expect that such keyboard events come only from a hardware keyboard. You should never rely on receiving key events for any key on a soft input method (an on-screen keyboard).</p></blockquote>&#13;
&#13;
<p>So what do we do? We have a couple strategies…</p>&#13;
&#13;
<p>First, and more commonly, we might actually be more interested in change events fired when the value of an edit text changes, rather than the actual <code>KeyEvent</code>. In<a data-primary="Android commands and methods" data-secondary="onTextChanged" data-type="indexterm" id="idm46177237984072"/><a data-primary="Android commands and methods" data-secondary="beforeTextChanged" data-type="indexterm" id="idm46177237983096"/><a data-primary="Android commands and methods" data-secondary="afterTextChanged" data-type="indexterm" id="idm46177237982184"/> these cases, we have access<a data-primary="TextWatcher interface" data-type="indexterm" id="idm46177237981144"/> to the <code>TextWatcher</code> interface, which requires three method implementations:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>onTextChanged</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>beforeTextChanged</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>afterTextChanged</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p><code>TextWatchers</code> can listen for text change events on <code>TextView</code> instances, including <code>EditText</code>, using the <code>addTextChangedListener</code> listener.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>This<a data-primary="Android commands and methods" data-secondary="removeTextChangedListener" data-type="indexterm" id="idm46177237973480"/> is one of the few listener APIs that allow multiple listeners to be attached. To support that, there’s a corresponding <code><span class="keep-together">removeText</span><span class="keep-together">ChangedListener</span></code> method as well.</p>&#13;
</div>&#13;
&#13;
<p>Using a <code>TextWatcher</code>, we can detect when the value of an input text field has changed, which is often exactly what we’re looking to do when listening for key events. While the method signatures of the <code>TextWatcher</code> interface can vary significantly, each provides<a data-primary="Java" data-secondary="user input" data-tertiary="keyboards" data-type="indexterm" id="idm46177237968904"/><a data-primary="Kotlin" data-secondary="user input" data-tertiary="keyboards" data-type="indexterm" id="idm46177237967656"/> access to the text that was changed, either as an <code>Editable</code> instance or as a <code><span class="keep-together">CharSequence</span></code> instance:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177237964984">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="n">EditText</code> <code class="n">editText</code> <code class="o">=</code> <code class="k">new</code> <code class="n">EditText</code><code class="o">(</code><code class="k">this</code><code class="o">);</code>&#13;
<code class="n">editText</code><code class="o">.</code><code class="na">addTextChangedListener</code><code class="o">(</code><code class="k">new</code> <code class="n">TextWatcher</code><code class="o">()</code> <code class="o">{</code>&#13;
    <code class="nd">@Override</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onTextChanged</code><code class="o">(</code><code class="n">CharSequence</code> <code class="n">s</code><code class="o">,</code> <code class="kt">int</code> <code class="n">start</code><code class="o">,</code> <code class="kt">int</code> <code class="n">before</code><code class="o">,</code> <code class="kt">int</code> <code class="n">count</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"onTextChanged: "</code> <code class="o">+</code> <code class="n">s</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
    <code class="nd">@Override</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">beforeTextChanged</code><code class="o">(</code><code class="n">CharSequence</code> <code class="n">s</code><code class="o">,</code> <code class="kt">int</code> <code class="n">start</code><code class="o">,</code> <code class="kt">int</code> <code class="n">count</code><code class="o">,</code>&#13;
      <code class="kt">int</code> <code class="n">after</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"beforeTextChanged: "</code> <code class="o">+</code> <code class="n">s</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
    <code class="nd">@Override</code>&#13;
    <code class="kd">public</code> <code class="kt">void</code> <code class="nf">afterTextChanged</code><code class="o">(</code><code class="n">Editable</code> <code class="n">s</code><code class="o">)</code> <code class="o">{</code>&#13;
      <code class="n">Log</code><code class="o">.</code><code class="na">d</code><code class="o">(</code><code class="s">"MyTag"</code><code class="o">,</code> <code class="s">"afterTextChanged: "</code> <code class="o">+</code> <code class="n">s</code><code class="o">);</code>&#13;
    <code class="o">}</code>&#13;
<code class="o">});</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre class="small" data-code-language="kotlin" data-type="programlisting"><code class="k">val</code> <code class="py">editText</code> <code class="p">=</code> <code class="n">EditText</code><code class="p">(</code><code class="k">this</code><code class="p">)</code>&#13;
<code class="n">editText</code><code class="p">.</code><code class="n">addTextChangedListener</code><code class="p">(</code><code class="k">object</code> <code class="err">: </code><code class="nc">TextWatcher</code> <code class="p">{</code>&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onTextChanged</code><code class="p">(</code><code class="n">s</code><code class="p">:</code> <code class="n">CharSequence</code><code class="p">,</code> <code class="n">start</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">before</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">count</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"onTextChanged: $s"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">beforeTextChanged</code><code class="p">(</code><code class="n">s</code><code class="p">:</code> <code class="n">CharSequence</code><code class="p">,</code> <code class="n">start</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code> <code class="n">count</code><code class="p">:</code> <code class="n">Int</code><code class="p">,</code>&#13;
    <code class="n">after</code><code class="p">:</code> <code class="n">Int</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"beforeTextChanged: $s"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">afterTextChanged</code><code class="p">(</code><code class="n">s</code><code class="p">:</code> <code class="n">Editable</code><code class="p">)</code> <code class="p">{</code>&#13;
    <code class="n">Log</code><code class="p">.</code><code class="n">d</code><code class="p">(</code><code class="s">"MyTag"</code><code class="p">,</code> <code class="s">"afterTextChanged: $s"</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
<code class="p">})</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>Beyond<a data-primary="IME (input method editor)" data-type="indexterm" id="idm46177237825624"/> text changes, and assuming our users are only rarely going to be using an external, physical keyboard, we need to concede that we’re mostly interested in soft keyboard behavior and understand the concept of “IME” a little. “IME” stands for “input method editor,” which is technically anything that can handle events from hardware components, but in reality is almost exclusively referring to soft keyboard management, usually through a <code>TextView</code>, and most commonly through an <code>EditText</code> instance, a subclass of <code>TextView</code> that has editing functionality built in.</p>&#13;
&#13;
<p>Like most <code>View</code> configurations, an IME can usually be handled in either XML instructions or programmatic statements. The<a data-primary="Android commands and methods" data-secondary="TextView.setImeOptions" data-type="indexterm" id="idm46177237672728"/> most common IME API is “IME options”: either<a data-primary="Android commands and methods" data-secondary="android:imeOptions" data-type="indexterm" id="idm46177237671656"/> <code>android:imeOptions</code> or <code>TextView.setImeOptions</code>, either of which accepts an integer representing various IME flags, thinks like “go,” “next,” “previous,” “search,” “done,” and “send” (among others). While the option semantic is sometimes expressed with behavior, that’s not always the case. For example, while “next” and “previous” will change the screen’s focus, “go,” “done,” and “send” may do nothing explicitly different, but should pass different values to attached listeners.</p>&#13;
&#13;
<p>For example, you<a data-primary="Android commands and methods" data-secondary="android:imeOptions=&quot;actionSend&quot;" data-type="indexterm" id="idm46177237668744"/> can create an <code>EditText</code> with <code>android:imeOptions="actionSend"</code>. When that <code>EditText</code> receives focus, it will open a soft keyboard on the screen, with a button dedicated to the “Send” action (often this will appear as a button on the keyboard labeled “Send” in the device’s local language). Tapping this button will then trigger a registered <code>TextView.OnEditorActionListener</code> to fire its <code>onEditorAction</code> events (more on that in just a moment).</p>&#13;
&#13;
<p>Similarly, you<a data-primary="Android commands and methods" data-secondary="android:imeOptions=&quot;actionNext&quot;" data-type="indexterm" id="idm46177237664888"/> might have <code>android:imeOptions="actionNext"</code>, which suggests the soft keyboard render a button with a “next” representation (often a right-pointing arrow). Tapping this button will generally send focus to the next available IME (probably an <code>EditText</code>) in the view tree.</p>&#13;
&#13;
<p>If you want more specific control over the behavior of IME buttons, you have access to the <code>TextView.OnEditorActionListener</code>. You can assign an instance of this listener to an IME (like an <code>EditText</code>) using the <code>setOnEditorActionListener</code> method, just like you would any listener (and similarly, set this value to <code>null</code> to remove previously attached listeners).</p>&#13;
&#13;
<p><code>OnEditorActionListener</code> instances implement a single method: <code>public boolean onEditorAction(TextView view, int actionId, KeyEvent event)</code>. Feel free to use any of the arguments passed to the listener, but generally the <code>actionId</code> flag will be the most interesting. In the last example, when the right-pointing button is tapped, any attached <code>OnEditActionListener</code> instances will fire their <code>onEditAction</code> methods, with the following parameters: the <code>View</code> instance<a data-primary="" data-startref="UIKey04" data-type="indexterm" id="idm46177237656968"/><a data-primary="" data-startref="AUIkey04" data-type="indexterm" id="idm46177237655960"/><a data-primary="" data-startref="keyb04" data-type="indexterm" id="idm46177237655016"/> that opened the keyboard, an integer constant equal to <code>EditorInfo.IME_ACTION_NEXT</code>, and a <code>KeyEvent</code> describing the “next” <a href="https://oreil.ly/pOZn8">key press event</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Handle Compound Gestures" data-type="sect2"><div class="sect2" id="idm46177237996168">&#13;
<h2>Handle Compound Gestures</h2>&#13;
&#13;
<p>If<a data-primary="user input" data-secondary="Android" data-tertiary="compound gestures" data-type="indexterm" id="UIAcomp04"/><a data-primary="Android" data-secondary="user input" data-tertiary="compound gestures" data-type="indexterm" id="AUIcompoind04"/><a data-primary="compound gestures" data-secondary="Android" data-type="indexterm" id="CGand04"/><a data-primary="gestures" data-secondary="Android" data-type="indexterm" id="Gand04"/> you need gesture functionality beyond what’s provided out of the box, you have a couple mechanisms available. The most straightforward approach in our opinion is to simply override the<a data-primary="Android commands and methods" data-secondary="onTouchEvent" data-type="indexterm" id="idm46177237644872"/> <code>onTouchEvent</code> of a <code>ViewGroup</code> (or an <span class="keep-together"><code>Activity</code></span>!) and manage each event in whatever fashion suits your needs. Each motion event has a type flag (e.g., a finger begins a gesture [<code>ACTION_DOWN</code>], moves across the screen [<code>ACTION_MOVE</code>], ends a gesture [<code>ACTION_UP</code>], or other, similar methods for multitouch). With this information and the judicious use of timestamps, you can accomplish any custom behavior your app may require.</p>&#13;
&#13;
<p>There are additional APIs available that can make complex tasks easier when writing custom gesture functionality, like <code>Scroller</code>, which despite its name doesn’t actually perform any scroll movement but does have some very handy calculation methods for flings or inertial scroll decay. <code>VelocityTracker</code> is available to record motion events and provide information about velocity and acceleration across either axis.</p>&#13;
&#13;
<p>If these are not enough or your needs don’t require that fine-grain control, a simple way to access gestures is to use <code>GestureDetector</code> (or <code>GestureDetectorCompat</code> from the support library). A <code>GestureDetector</code> instance can be passed a <code>GestureListener</code>, and provided touch events, to pass back common<a data-primary="Android commands and methods" data-secondary="onDown" data-type="indexterm" id="idm46177237636376"/><a data-primary="Android commands and methods" data-secondary="onFling" data-type="indexterm" id="idm46177237635336"/><a data-primary="Android commands and methods" data-secondary="onLongPress" data-type="indexterm" id="idm46177237634376"/><a data-primary="Android commands and methods" data-secondary="onScroll" data-type="indexterm" id="idm46177237633416"/><a data-primary="Android commands and methods" data-secondary="onShowPress" data-type="indexterm" id="idm46177237632456"/><a data-primary="Android commands and methods" data-secondary="onSingleTapUp" data-type="indexterm" id="idm46177237631496"/> callbacks, including:</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>onDown</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>onFling</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>onLongPress</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>onScroll</code> (think of this as “drag”)</p>&#13;
</li>&#13;
<li>&#13;
<p><code>onShowPress</code></p>&#13;
</li>&#13;
<li>&#13;
<p><code>onSingleTapUp</code></p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To<a data-primary="Java" data-secondary="user input" data-tertiary="compound gestures" data-type="indexterm" id="idm46177237623304"/><a data-primary="Kotlin" data-secondary="user input" data-tertiary="compound gestures" data-type="indexterm" id="idm46177237622024"/> accomplish that, you’ll need an instance of <code>GestureDetector</code>, which requires a <code>Context</code> instance and a <code>GestureListener</code> instance:</p>&#13;
<aside class="java-kotlin" data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46177237619208">&#13;
<h5/>&#13;
<p><em>Java</em></p>&#13;
&#13;
<pre class="small" data-code-language="java" data-type="programlisting"><code class="kd">public</code> <code class="kd">class</code> <code class="nc">MyActivity</code> <code class="kd">extends</code> <code class="n">Activity</code> <code class="kd">implements</code> <code class="n">GestureDetector</code><code class="o">.</code><code class="na">OnGestureListener</code> <code class="o">{</code>&#13;
&#13;
  <code class="kd">private</code> <code class="n">GestureDetector</code> <code class="n">mGestureDetector</code> <code class="o">=</code> <code class="k">new</code> <code class="n">GestureDetector</code><code class="o">(</code><code class="k">this</code><code class="o">,</code> <code class="k">this</code><code class="o">);</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kt">void</code> <code class="nf">onCreate</code><code class="o">(</code><code class="n">Bundle</code> <code class="n">savedInstanceState</code><code class="o">)</code> <code class="o">{</code>&#13;
    <code class="kd">super</code><code class="o">.</code><code class="na">onCreate</code><code class="o">(</code><code class="n">savedInstanceState</code><code class="o">);</code>&#13;
    <code class="n">setContentView</code><code class="o">(</code><code class="n">R</code><code class="o">.</code><code class="na">layout</code><code class="o">.</code><code class="na">my_activity</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">onTouchEvent</code><code class="o">(</code><code class="n">MotionEvent</code> <code class="n">e</code><code class="o">){</code>&#13;
    <code class="k">return</code> <code class="n">mGestureDetector</code><code class="o">.</code><code class="na">onTouchEvent</code><code class="o">(</code><code class="n">e</code><code class="o">)</code> <code class="o">||</code> <code class="kd">super</code><code class="o">.</code><code class="na">onTouchEvent</code><code class="o">(</code><code class="n">e</code><code class="o">);</code>&#13;
  <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">onDown</code><code class="o">(</code><code class="n">MotionEvent</code> <code class="n">event</code><code class="o">)</code> <code class="o">{</code> <code class="k">return</code> <code class="kc">true</code><code class="o">;</code> <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">onFling</code><code class="o">(</code><code class="n">MotionEvent</code> <code class="n">e1</code><code class="o">,</code> <code class="n">MotionEvent</code> <code class="n">e2</code><code class="o">,</code> <code class="kt">float</code> <code class="n">vX</code><code class="o">,</code>&#13;
  <code class="kt">float</code> <code class="n">vY</code><code class="o">)</code> <code class="o">{</code> <code class="k">return</code> <code class="kc">true</code><code class="o">;</code> <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onLongPress</code><code class="o">(</code><code class="n">MotionEvent</code> <code class="n">e</code><code class="o">)</code> <code class="o">{}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">onScroll</code><code class="o">(</code><code class="n">MotionEvent</code> <code class="n">e1</code><code class="o">,</code> <code class="n">MotionEvent</code> <code class="n">e2</code><code class="o">,</code> <code class="kt">float</code> <code class="n">dX</code><code class="o">,</code>&#13;
          <code class="kt">float</code> <code class="n">dY</code><code class="o">)</code> <code class="o">{</code> <code class="k">return</code> <code class="kc">true</code><code class="o">;</code> <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">void</code> <code class="nf">onShowPress</code><code class="o">(</code><code class="n">MotionEvent</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code> <code class="o">}</code>&#13;
&#13;
  <code class="nd">@Override</code>&#13;
  <code class="kd">public</code> <code class="kt">boolean</code> <code class="nf">onSingleTapUp</code><code class="o">(</code><code class="n">MotionEvent</code> <code class="n">e</code><code class="o">)</code> <code class="o">{</code> <code class="k">return</code> <code class="kc">true</code><code class="o">;</code> <code class="o">}</code>&#13;
&#13;
<code class="o">}</code></pre>&#13;
&#13;
<p><em>Kotlin</em></p>&#13;
&#13;
<pre data-code-language="kotlin" data-type="programlisting"><code class="k">class</code> <code class="nc">MyActivity</code> <code class="p">:</code> <code class="n">Activity</code><code class="p">(),</code> <code class="n">GestureDetector</code><code class="p">.</code><code class="n">OnGestureListener</code> <code class="p">{</code>&#13;
&#13;
  <code class="k">private</code> <code class="k">val</code> <code class="py">gestureDetector</code><code class="p">:</code> <code class="n">GestureDetector</code> <code class="p">=</code> <code class="n">GestureDetector</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="k">this</code><code class="p">)</code>&#13;
&#13;
  <code class="k">public</code> <code class="k">override</code> <code class="k">fun</code> <code class="nf">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">:</code> <code class="n">Bundle</code><code class="p">?)</code> <code class="p">{</code>&#13;
    <code class="k">super</code><code class="p">.</code><code class="n">onCreate</code><code class="p">(</code><code class="n">savedInstanceState</code><code class="p">)</code>&#13;
    <code class="n">setContentView</code><code class="p">(</code><code class="n">R</code><code class="p">.</code><code class="n">layout</code><code class="p">.</code><code class="n">activity_main</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onTouchEvent</code><code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">):</code> <code class="n">Boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="n">gestureDetector</code><code class="p">.</code><code class="n">onTouchEvent</code><code class="p">(</code><code class="n">e</code><code class="p">)</code> <code class="p">||</code> <code class="k">super</code><code class="p">.</code><code class="n">onTouchEvent</code><code class="p">(</code><code class="n">e</code><code class="p">)</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onDown</code><code class="p">(</code><code class="n">event</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">):</code> <code class="n">Boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">true</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onFling</code><code class="p">(</code><code class="n">e1</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">,</code> <code class="n">e2</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">,</code> <code class="n">vX</code><code class="p">:</code> <code class="n">Float</code><code class="p">,</code>&#13;
    <code class="n">vY</code><code class="p">:</code> <code class="n">Float</code><code class="p">):</code> <code class="n">Boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">true</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onLongPress</code><code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">)</code> <code class="p">{}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onScroll</code><code class="p">(</code><code class="n">e1</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">,</code> <code class="n">e2</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">,</code> <code class="n">dX</code><code class="p">:</code> <code class="n">Float</code><code class="p">,</code>&#13;
    <code class="n">dY</code><code class="p">:</code> <code class="n">Float</code><code class="p">):</code> <code class="n">Boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">true</code>&#13;
  <code class="p">}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onShowPress</code><code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">)</code> <code class="p">{}</code>&#13;
&#13;
  <code class="k">override</code> <code class="k">fun</code> <code class="nf">onSingleTapUp</code><code class="p">(</code><code class="n">e</code><code class="p">:</code> <code class="n">MotionEvent</code><code class="p">):</code> <code class="n">Boolean</code> <code class="p">{</code>&#13;
    <code class="k">return</code> <code class="k">true</code>&#13;
  <code class="p">}</code>&#13;
&#13;
<code class="p">}</code></pre>&#13;
</div></aside>&#13;
&#13;
<p>The <code>GestureDetector</code> instance takes care of most of the accounting; it’ll use system-provided values for things like gravity and touch slop, so you can be assured that your app will start a fling under the same conditions that a <code>ScrollView</code> or <code>RecyclerView</code> would.</p>&#13;
&#13;
<p>When a parent <code>ViewGroup</code> contains <code>View</code> children that can consume touch events (even by having a simple <code>View.onClickListener</code>), an already complicated gesture management system can quickly become hard to manage. Generally speaking, you can use <code>onInterceptTouchEvent</code> in conjunction with <code>onTouchEvent</code> (see the <a href="https://oreil.ly/qCLNx">developer docs on the former</a>); between the two you’re pretty sure to be able to at least get access to touch events happening within any container.</p>&#13;
&#13;
<p>Other<a data-primary="Android commands and methods" data-secondary="onKeyDown(int, KeyEvent)" data-type="indexterm" id="idm46177237154456"/><a data-primary="Android commands and methods" data-secondary="onKeyUp(int, KeyEvent)" data-type="indexterm" id="idm46177237153416"/><a data-primary="Android commands and methods" data-secondary="onTrackballEvent(MotionEvent)" data-type="indexterm" id="idm46177237152456"/><a data-primary="Android commands and methods" data-secondary="onTouchEvent(MotionEvent)" data-type="indexterm" id="idm46177237151480"/><a data-primary="Android commands and methods" data-secondary="onFocusChanged(boolean, int, Rect)" data-type="indexterm" id="idm46177237150504"/> event callbacks available to <code>View</code> class instances include:<sup><a data-type="noteref" href="ch04.html#idm46177237148968" id="idm46177237148968-marker">1</a></sup></p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p><code>onKeyDown(int, KeyEvent)</code>: Called when a new key event occurs.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>onKeyUp(int, KeyEvent)</code>: Called when a key up event occurs.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>onTrackballEvent(MotionEvent)</code>: Called when a trackball motion event occurs.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>onTouchEvent(MotionEvent)</code>: Called when a touch screen motion event occurs.</p>&#13;
</li>&#13;
<li>&#13;
<p><code>onFocusChanged(boolean, int, Rect)</code>: Called when the view gains or loses focus.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>To<a data-primary="" data-startref="UIAcomp04" data-type="indexterm" id="idm46177237141000"/><a data-primary="" data-startref="AUIcompoind04" data-type="indexterm" id="idm46177237139992"/><a data-primary="" data-startref="CGand04" data-type="indexterm" id="idm46177237139048"/><a data-primary="" data-startref="Gand04" data-type="indexterm" id="idm46177237138104"/> learn more about gesture detection, check out <a href="https://oreil.ly/tFb5K">Android’s great guide</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="iOS" data-type="sect1"><div class="sect1" id="idm46177237651896">&#13;
<h1>iOS</h1>&#13;
&#13;
<p>In<a data-primary="user input" data-secondary="iOS" data-tertiary="Multi-Touch" data-type="indexterm" id="idm46177237134808"/><a data-primary="iOS" data-secondary="user input" data-tertiary="Multi-Touch" data-type="indexterm" id="idm46177237133528"/><a data-primary="Multi-Touch (iOS)" data-type="indexterm" id="idm46177237132312"/> 2007, Apple introduced the iPhone, and with it, Multi-Touch was born. Despite the ubiquity now, having the ability to use more than one finger on a glass screen was revolutionary at the time and transformed user interfaces. Touch is currently the primary method of interaction with a smartphone, but certainly not the only one. This chapter covers two of the most common input methods: touches and keyboards. Let’s dig in.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Receive and React to a Tap" data-type="sect2"><div class="sect2" id="idm46177237130936">&#13;
<h2>Receive and React to a Tap</h2>&#13;
&#13;
<p>The<a data-primary="user input" data-secondary="iOS" data-tertiary="taps" data-type="indexterm" id="idm46177237129400"/><a data-primary="iOS" data-secondary="user input" data-tertiary="taps" data-type="indexterm" id="idm46177237128120"/><a data-primary="taps" data-secondary="iOS" data-type="indexterm" id="idm46177237126904"/> touch event APIs available in iOS are, arguably, the best in the industry. They’ve evolved slightly over time but have largely remained the same since iOS 4, which introduced gesture recognizers. This is by far the simplest method of intercepting touch events. Here’s an example of how to listen for a single tap on an image view within a view controller:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">imageView</code><code class="p">:</code> <code class="bp">UIImageView</code><code class="p">!</code>&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
        <code class="n">imageView</code> <code class="p">=</code> <code class="bp">UIImageView</code><code class="p">(</code><code class="n">image</code><code class="p">:</code> <code class="p">...)</code>&#13;
        <code class="kd">let</code> <code class="nv">gestureRecognizer</code> <code class="p">=</code>&#13;
          <code class="bp">UITapGestureRecognizer</code><code class="p">(</code><code class="n">target</code><code class="p">:</code> <code class="kc">self</code><code class="p">,</code> <code class="n">action</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">handleTap</code><code class="p">(</code><code class="kc">_</code><code class="p">:)))</code>&#13;
        <code class="n">gestureRecognizer</code><code class="p">.</code><code class="n">numberOfTapsRequired</code> <code class="p">=</code> <code class="mi">1</code>&#13;
        <code class="n">imageView</code><code class="p">.</code><code class="n">addGestureRecognizer</code><code class="p">(</code><code class="n">gestureRecognizer</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">@objc</code> <code class="kd">func</code> <code class="nf">handleTap</code><code class="p">(</code><code class="kc">_</code> <code class="n">gestureRecognizer</code><code class="p">:</code> <code class="bp">UIGestureRecognizer</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="s">"Image tapped!"</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>We begin by declaring our <code>UIViewController</code> subclass, <code>SomeViewController</code>. Most<a data-primary="iOS methods" data-secondary="viewDidLoad" data-type="indexterm" id="idm46177237046344"/> of the action in this class happens within <code>viewDidLoad()</code>. This is part of the view life cycle in iOS and is where setup for a view controller’s view can often occur. Check out <a data-type="xref" href="ch02.html#topics_views">Chapter 2</a> for more information on views.</p>&#13;
&#13;
<p>Within<a data-primary="UIKit" data-secondary="UITapGestureRecognizer" data-type="indexterm" id="idm46177236970520"/> this method, the class’s image view, <code>imageView</code>, is set up. On the next line we declare a gesture recognizer of type <code>UITapGestureRecognizer</code> that is targeting this class via <code>self</code> and providing the <code>handleTap(_:)</code> method as the function to call when this gesture recognizer fires.</p>&#13;
&#13;
<p>After setting the <code>numberOfTapsRequired</code> property on the gesture recognizer to <code>1</code>, indicating it’s a single tap recognizer, we add the gesture recognizer to the image view defined before. Attaching a gesture recognizer to a view is required to get that recognizer to fire. In our example, this means whenever the image view is touched or tapped, it’ll go through the list of recognizer associated with it and attempt to resolve what touches are valid to trigger a particular gesture recognizer.</p>&#13;
&#13;
<p>Assuming a touch registers for our gesture recognizers, the recognizer itself will call<a data-primary="iOS methods" data-secondary="handleTap(_:)" data-type="indexterm" id="idm46177236965720"/> <code>handleTap(_:)</code>, which we defined as the action a moment ago.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Note that <code>handleTap(_:)</code> is an <code>@objc</code> method. This is because <code>UIGestureRecognizer</code> and subclasses require a <code>#selector(...)</code> to be passed in as the action fired when a gesture recognizer is activated.</p>&#13;
</div>&#13;
&#13;
<p class="less_space pagebreak-before">There’s a little bit of boilerplate for our example, but it essentially comes down to two lines:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">gestureRecognizer</code> <code class="p">=</code> <code class="bp">UITapGestureRecognizer</code><code class="p">(</code><code class="n">target</code><code class="p">:</code> <code class="kc">self</code><code class="p">,</code> <code class="n">action</code><code class="p">:</code>&#13;
<code class="k">#selector</code><code class="p">(</code><code class="n">handleTap</code><code class="p">(</code><code class="kc">_</code><code class="p">:)))</code>&#13;
<code class="n">imageView</code><code class="p">.</code><code class="n">addGestureRecognizer</code><code class="p">(</code><code class="n">gestureRecognizer</code><code class="p">)</code></pre>&#13;
&#13;
<p>We declare the gesture recognizer and attach it to a view.</p>&#13;
&#13;
<p>Gesture recognizers are incredibly powerful. We’ll talk about them later in the chapter. For now, let’s turn our attention to another primary input source on iOS: the <span class="keep-together">keyboard</span>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Receive and React to Keyboard Input" data-type="sect2"><div class="sect2" id="idm46177237130344">&#13;
<h2>Receive and React to Keyboard Input</h2>&#13;
&#13;
<p>Unlike<a data-primary="user input" data-secondary="iOS" data-tertiary="keyboards" data-type="indexterm" id="idm46177236939032"/><a data-primary="iOS" data-secondary="user input" data-tertiary="keyboards" data-type="indexterm" id="idm46177236937752"/><a data-primary="keyboard input" data-secondary="iOS" data-type="indexterm" id="idm46177236936536"/> on Android, there have never been iPhones or iPads with physical keyboards built into them. It’s theoretically possible this might change in the future but is <em>highly</em> unlikely given Apple’s stance in the past. There are external keyboards (including a case made by Apple) for iPads, and certainly a Bluetooth keyboard can be connected to a device to serve as a replacement for the on-screen keyboard. That said, for an ecosystem so dependent on “soft keyboards,” the keyboard and text field libraries in UIKit are frustratingly—and shockingly—complex given how easy to use some of the other areas of UIKit are.</p>&#13;
&#13;
<p>For<a data-primary="UIKit" data-secondary="UITextFields" data-type="indexterm" id="idm46177236934024"/><a data-primary="UIKit" data-secondary="UIText Views" data-type="indexterm" id="idm46177236933016"/> example, the primary way to edit text on iOS is via <code>UITextField</code>s or <code>UITextView</code>s. There are separate delegate protocols for each of these user interface controls, and they differ slightly in functionality, but mostly in name. Each of these delegate protocols, although robust, does not have a purpose-built method to get updates whenever a text field changes.</p>&#13;
&#13;
<p>There are other approaches to consider. For example, it’s possible to wire up a text field to call a handler for edit events like so:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
        <code class="n">textField</code> <code class="p">=</code> <code class="bp">UITextField</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="p">...)</code>&#13;
        <code class="n">textField</code><code class="p">.</code><code class="n">addTarget</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">action</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">textFieldDidChange</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
        <code class="k">for</code><code class="p">:</code> <code class="p">.</code><code class="n">editingChanged</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">@objc</code> <code class="kd">func</code> <code class="nf">textFieldDidChange</code><code class="p">(</code><code class="kc">_</code> <code class="n">textField</code><code class="p">:</code> <code class="bp">UITextField</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="n">textField</code><code class="p">.</code><code class="n">text</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>In<a data-primary="iOS methods" data-secondary="textFieldDidChange(_:)" data-type="indexterm" id="idm46177236928232"/> the example, within the <code>SomeViewController</code> view controller, we define a <code>UITextField</code> named <code>textField</code> that adds a target action for <code>textFieldDidChange(_:)</code> on the <code>.editingChanged</code> event. Whenever a user edits text in a text field, the <code>textFieldDidChange(_:)</code> method will get called for each character that is added or updated; in our example, we <code>print()</code> out the text field’s text via <code>print(textField.text)</code>.</p>&#13;
&#13;
<p>This works most of the time until the text field is edited programmatically. Then, our <code>textFieldDidChange(_:)</code> method falls silent, and our text changes surreptitiously without notification.</p>&#13;
&#13;
<p>A more foolproof method to capture text field edits is by adding a notification observer like so:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
        <code class="n">textField</code> <code class="p">=</code> <code class="bp">UITextField</code><code class="p">(</code><code class="n">frame</code><code class="p">:</code> <code class="p">...)</code>&#13;
        <code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
            <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">selector</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">textFieldDidChange</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
            <code class="n">name</code><code class="p">:</code> <code class="bp">UITextField</code><code class="p">.</code><code class="n">textDidChangeNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="n">textField</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">@objc</code> <code class="kd">func</code> <code class="nf">textFieldDidChange</code><code class="p">(</code><code class="kc">_</code> <code class="n">notification</code><code class="p">:</code> <code class="n">Notification</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kd">let</code> <code class="nv">textField</code> <code class="p">=</code> <code class="n">notification</code><code class="p">.</code><code class="n">object</code> <code class="k">as</code><code class="p">!</code> <code class="bp">UITextField</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="n">textField</code><code class="p">.</code><code class="n">text</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>This example is similar to the previous example, but has a few differences. First of all, after defining our <code>UITextField</code>, we are no longer listening for the <code>.editingChanged</code> event; we are now listening for the <code>UITextField.textDidChangeNotification</code>. Our same method from before, <code>textFieldDidChange(_:)</code>, is called whenever the <span class="keep-together">notification</span> observer fires; however, in order to target the text field, we cast the <code>notification.object</code> to a <code>UITextField</code> in order to read out the <code>text</code> value in the subsequent <code>print(textField.text)</code> line.</p>&#13;
&#13;
<p>Up to now, we’ve been operating only on <code>UITextField</code>. What happens when you need to observe multiple text inputs and a mix of <code>UITextField</code> and <code>UITextView</code> objects? Your code quickly might spiral into something such as this:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">class</code> <code class="nc">SomeViewController</code><code class="p">:</code> <code class="bp">UIViewController</code> <code class="p">{</code>&#13;
    <code class="kd">var</code> <code class="nv">textField1</code><code class="p">:</code> <code class="bp">UITextField</code><code class="p">!</code>&#13;
    <code class="kd">var</code> <code class="nv">textField2</code><code class="p">:</code> <code class="bp">UITextField</code><code class="p">!</code>&#13;
    <code class="kd">var</code> <code class="nv">textField3</code><code class="p">:</code> <code class="bp">UITextField</code><code class="p">!</code>&#13;
    <code class="kd">var</code> <code class="nv">textView1</code><code class="p">:</code> <code class="bp">UITextView</code><code class="p">!</code>&#13;
    <code class="kd">var</code> <code class="nv">textView2</code><code class="p">:</code> <code class="bp">UITextView</code><code class="p">!</code>&#13;
    <code class="kd">var</code> <code class="nv">textView3</code><code class="p">:</code> <code class="bp">UITextView</code><code class="p">!</code>&#13;
&#13;
&#13;
    <code class="kr">override</code> <code class="kd">func</code> <code class="nf">viewDidLoad</code><code class="p">()</code> <code class="p">{</code>&#13;
        <code class="kc">super</code><code class="p">.</code><code class="n">viewDidLoad</code><code class="p">()</code>&#13;
        <code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
            <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">selector</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">textFieldDidChange</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
            <code class="n">name</code><code class="p">:</code> <code class="bp">UITextField</code><code class="p">.</code><code class="n">textDidChangeNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
        <code class="n">NotificationCenter</code><code class="p">.</code><code class="k">default</code>&#13;
            <code class="p">.</code><code class="n">addObserver</code><code class="p">(</code><code class="kc">self</code><code class="p">,</code> <code class="n">selector</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">textViewDidChange</code><code class="p">(</code><code class="kc">_</code><code class="p">:)),</code>&#13;
            <code class="n">name</code><code class="p">:</code> <code class="bp">UITextView</code><code class="p">.</code><code class="n">textDidChangeNotification</code><code class="p">,</code> <code class="n">object</code><code class="p">:</code> <code class="kc">nil</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">@objc</code> <code class="kd">func</code> <code class="nf">textFieldDidChange</code><code class="p">(</code><code class="kc">_</code> <code class="n">notification</code><code class="p">:</code> <code class="n">Notification</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kd">let</code> <code class="nv">textField</code> <code class="p">=</code> <code class="n">notification</code><code class="p">.</code><code class="n">object</code> <code class="k">as</code><code class="p">!</code> <code class="bp">UITextField</code>&#13;
        <code class="n">doSomething</code><code class="p">(</code><code class="n">textField</code><code class="p">.</code><code class="n">text</code><code class="p">!)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kr">@objc</code> <code class="kd">func</code> <code class="nf">textViewDidChange</code><code class="p">(</code><code class="kc">_</code> <code class="n">notification</code><code class="p">:</code> <code class="n">Notification</code><code class="p">)</code> <code class="p">{</code>&#13;
        <code class="kd">let</code> <code class="nv">textView</code> <code class="p">=</code> <code class="n">notification</code><code class="p">.</code><code class="n">object</code> <code class="k">as</code><code class="p">!</code> <code class="bp">UITextView</code>&#13;
        <code class="n">doSomething</code><code class="p">(</code><code class="n">textView</code><code class="p">.</code><code class="n">text</code><code class="p">!)</code>&#13;
    <code class="p">}</code>&#13;
&#13;
    <code class="kd">private</code> <code class="kd">func</code> <code class="nf">doSomething</code><code class="p">(</code><code class="k">for</code> <code class="n">text</code><code class="p">:</code> <code class="nb">String</code><code class="p">?)</code> <code class="p">{</code>&#13;
        <code class="bp">print</code><code class="p">(</code><code class="n">text</code><code class="p">)</code>&#13;
    <code class="p">}</code>&#13;
<code class="p">}</code></pre>&#13;
&#13;
<p>Sad.</p>&#13;
&#13;
<p>But let’s take these melancholy thoughts and incomplete frameworks and focus on something different. Let’s bring it back around to touch input again and discuss more complex gesture recognizers. This is an area of UIKit that scales successfully from straightforward logic to elaborate experiences without too much weight placed upon the developer.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Handle Compound Gestures" data-type="sect2"><div class="sect2" id="idm46177236946056">&#13;
<h2>Handle Compound Gestures</h2>&#13;
&#13;
<p>Gesture<a data-primary="iOS" data-secondary="user input" data-tertiary="compound gestures" data-type="indexterm" id="idm46177236500456"/><a data-primary="user input" data-secondary="iOS" data-tertiary="compound gestures" data-type="indexterm" id="idm46177236499176"/><a data-primary="compound gestures" data-secondary="iOS" data-type="indexterm" id="idm46177236497960"/><a data-primary="gestures" data-secondary="iOS" data-type="indexterm" id="idm46177236497016"/> recognizers are great for simple tap gestures with one finger. But they are also handy for complex interaction chains. Let’s take a look at the following example:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">doubleTapRecognizer</code> <code class="p">=</code> <code class="bp">UITapGestureRecognizer</code><code class="p">(</code><code class="n">target</code><code class="p">:</code> <code class="kc">self</code><code class="p">,</code>&#13;
<code class="n">action</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">handleTap</code><code class="p">(</code><code class="kc">_</code><code class="p">:)))</code>&#13;
<code class="n">doubleTapRecognizer</code><code class="p">.</code><code class="n">numberOfTapsRequired</code> <code class="p">=</code> <code class="mi">2</code></pre>&#13;
&#13;
<p>This code is similar to our code from before for our single-tap gesture recognizer. However, by simply changing one property value we can transform it into a double-tap gesture recognizer.</p>&#13;
&#13;
<p>There are other gesture recognizers prebuilt into UIKit. If you’re looking to recognize three-finger pan gestures, you can create one with the following code:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">panGestureRecognizer</code> <code class="p">=</code> <code class="bp">UIPanGestureRecognizer</code><code class="p">(</code><code class="n">target</code><code class="p">:</code> <code class="kc">self</code><code class="p">,</code>&#13;
<code class="n">action</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">handlePan</code><code class="p">(</code><code class="kc">_</code><code class="p">:)))</code>&#13;
<code class="n">panGestureRecognizer</code><code class="p">.</code><code class="n">minimumNumberOfTouches</code> <code class="p">=</code> <code class="mi">3</code></pre>&#13;
&#13;
<p>Or, if you’d rather listen for something that requires a physicality beyond our reach, we present the five-fingered, triple-tap gesture:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="kd">let</code> <code class="nv">fiveFingerTapRecognizer</code> <code class="p">=</code> <code class="bp">UITapGestureRecognizer</code><code class="p">(</code><code class="n">target</code><code class="p">:</code> <code class="kc">self</code><code class="p">,</code>&#13;
<code class="n">action</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">handleTap</code><code class="p">(</code><code class="kc">_</code><code class="p">:)))</code>&#13;
<code class="n">fiveFingerTapRecognizer</code><code class="p">.</code><code class="n">numberOfTapsRequired</code> <code class="p">=</code> <code class="mi">3</code>&#13;
<code class="n">fiveFingerTapRecognizer</code><code class="p">.</code><code class="n">numberOfTouchesRequired</code> <code class="p">=</code> <code class="mi">5</code></pre>&#13;
&#13;
<p>You’re probably not likely to see that in many shipping apps. However, a common problem in touch interfaces is that you’re often listening for multiple touch events on a single view. How do you listen for a single-tap gesture <em>and</em> a double-tap gesture without accidentally firing the single-tap gesture first? Here’s how it might look:</p>&#13;
&#13;
<pre class="small" data-code-language="swift" data-type="programlisting"><code class="c1">// Create a double tap recognizer</code>&#13;
<code class="kd">let</code> <code class="nv">doubleTapRecognizer</code> <code class="p">=</code> <code class="bp">UITapGestureRecognizer</code><code class="p">(</code><code class="n">target</code><code class="p">:</code> <code class="kc">self</code><code class="p">,</code>&#13;
<code class="n">action</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">handleTap</code><code class="p">(</code><code class="kc">_</code><code class="p">:)))</code>&#13;
<code class="n">doubleTapRecognizer</code><code class="p">.</code><code class="n">numberOfTapsRequired</code> <code class="p">=</code> <code class="mi">2</code>&#13;
&#13;
<code class="c1">// Create a single tap recognizer</code>&#13;
<code class="kd">let</code> <code class="nv">singleTapRecognizer</code> <code class="p">=</code> <code class="bp">UITapGestureRecognizer</code><code class="p">(</code><code class="n">target</code><code class="p">:</code> <code class="kc">self</code><code class="p">,</code>&#13;
<code class="n">action</code><code class="p">:</code> <code class="k">#selector</code><code class="p">(</code><code class="n">handleTap</code><code class="p">(</code><code class="kc">_</code><code class="p">:)))</code>&#13;
<code class="n">singleTapRecognizer</code><code class="p">.</code><code class="n">numberOfTapsRequired</code> <code class="p">=</code> <code class="mi">1</code>&#13;
<code class="n">singleTapRecognizer</code><code class="p">.</code><code class="n">require</code><code class="p">(</code><code class="n">toFail</code><code class="p">:</code> <code class="n">doubleTapRecognizer</code><code class="p">)</code></pre>&#13;
&#13;
<p>First, we create a double-tap gesture recognizer named <code>doubleTapRecognizer</code>. We set the <code>numberOfTapRequired</code> to <code>2</code>. Next, we create a single-tap gesture recognizer named <code>singleTapRecognizer</code>. We set the number of taps to <code>1</code>, but then call a separate method, <code>require(toFail:)</code>, and pass in the double-tap gesture recognizer from before.</p>&#13;
&#13;
<p>The<a data-primary="iOS methods" data-secondary="require(toFail:)" data-type="indexterm" id="idm46177236215304"/> <code>require(toFail:)</code> method is a method that all gesture recognizers have that allows them to fire only if another recognized gesture recognizer fails first. Wiring the recognizers up this way allows the single-tap recognizer to wait until the double-tap gesture recognizer fails before it’ll call its handler. Not linking the two gesture recognizers would mean that the single-tap recognizer would fire on the first tap of the double-tap gesture recognizer and on the second tap.</p>&#13;
&#13;
<p>Ideally, this makes it easy to see how it’s possible to wire up multiple compound gestures with defined execution priority. The number of gesture recognizer combinations you can create is essentially infinite; it’s beyond the scope of this book to catalog them all, but if you’re interested in finding out about more gesture types, check out the Apple developer documentation on <code>UIGestureRecognizer</code>.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Touch Events API" data-type="sect3"><div class="sect3" id="idm46177236212024">&#13;
<h3>Touch Events API</h3>&#13;
&#13;
<p>One<a data-primary="iOS" data-secondary="user input" data-tertiary="Touch Events API" data-type="indexterm" id="idm46177236210664"/><a data-primary="Touch Events API" data-type="indexterm" id="idm46177236209384"/><a data-primary="user input" data-secondary="iOS" data-tertiary="Touch Events API" data-type="indexterm" id="idm46177236208712"/> of the features of the responder chain on iOS is the fine-grained touch events API available to all responders (e.g., views and view controllers). It’s an incredibly powerful set of methods that are fired whenever a touch begins, moves, ends, or is cancelled. However, given the simplicity and powerful functionality of gesture recognizers, they are almost always the preferred method except in specific circumstances where a custom user interface requires a bit more fine-grained touch interaction. For these cases, check out touch events available to <code>UIResponder</code> objects.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="What We’ve Learned" data-type="sect1"><div class="sect1" id="idm46177236697576">&#13;
<h1>What We’ve Learned</h1>&#13;
&#13;
<p>In this chapter we’ve seen the similarities and differences in listening for and receiving user input in Android and iOS. User input can be in the form of simple touches, complex gestures, or on-screen and external keyboards.</p>&#13;
&#13;
<ul>&#13;
<li>&#13;
<p>Both platforms have similar mechanisms for listening to and responding to simple touch events.</p>&#13;
</li>&#13;
<li>&#13;
<p>Both Android and iOS can receive text input from a variety of sources, but iOS requires a bit of hand-holding due to a slightly unwieldy pattern for receiving said input.</p>&#13;
</li>&#13;
<li>&#13;
<p>There are ways to detect and respond to complex gestures built in to the operating systems, but both platforms have gestures that aren’t typically used in the other platform.</p>&#13;
</li>&#13;
</ul>&#13;
&#13;
<p>Touch input is what makes Android and iOS devices so intuitive and intimate. It’s important to understand how to handle and construct an app that receives input to build an app that is usable.</p>&#13;
&#13;
<p>In the next chapter, we’ll dive a bit more into the objects and patterns that aren’t as directly user facing as what’s been covered so far. Let’s go!</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<div data-type="footnotes"><p data-type="footnote" id="idm46177237148968"><sup><a href="ch04.html#idm46177237148968-marker">1</a></sup> From <a href="https://oreil.ly/HvEKV">Android developer documentation</a></p></div></div></section></body></html>