- en: Chapter 26\. Access Control
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第26章 访问控制
- en: 'As the world becomes increasingly reliant on cloud infrastructure and containerization,
    the importance of security can never be understated. In 2022, security researchers
    made a troubling discovery: nearly one million Kubernetes instances were left
    exposed on the internet due to misconfigurations.^([1](ch26.html#idm45902085697664))
    Using specialized security scanners, researchers were able to easily access these
    vulnerable nodes, highlighting the need for stringent access-control measures
    to protect the Kubernetes control plane. But while developers often focus on application-level
    authorization, they sometimes also need to extend Kubernetes capabilities using
    the *Operator* pattern from [Chapter 28](ch28.html#Operator). In these cases,
    access control on the Kubernetes platform becomes critical. In this chapter, we
    delve into the *Access Control* pattern and explore the concepts of Kubernetes
    authorization. With the potential risks and consequences at stake, it’s never
    been more important to ensure the security of your Kubernetes deployment.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 随着世界越来越依赖云基础架构和容器化，安全性的重要性不可低估。2022年，安全研究人员做出了令人担忧的发现：由于错误配置，近100万个 Kubernetes
    实例暴露在互联网上。^([1](ch26.html#idm45902085697664)) 利用专门的安全扫描器，研究人员能够轻松访问这些易受攻击的节点，突显了保护
    Kubernetes 控制平面的严格访问控制措施的必要性。但是，虽然开发人员通常关注应用程序级授权，但有时也需要使用第28章中的*操作者*模式扩展 Kubernetes
    的能力。在这些情况下，Kubernetes 平台上的访问控制变得至关重要。在本章中，我们深入探讨了*访问控制*模式，并探索了 Kubernetes 授权的概念。面对潜在的风险和后果，确保
    Kubernetes 部署的安全性从未如此重要。
- en: Problem
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Security is a crucial concern when it comes to operating applications. At the
    core of security are two essential concepts: authentication and authorization.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及操作应用程序时，安全性是一个关键问题。在安全性的核心是两个重要的概念：认证和授权。
- en: '*Authentication* focuses on identifying the subject, or *who*, of an operation
    and preventing access by unauthorized actors. *Authorization*, on the other hand,
    involves determining the permissions for *what* actions are allowed on resources.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '*认证* 关注操作的主体，即操作的*谁*，并防止未经授权的访问。*授权* 则涉及确定对资源允许执行哪些操作的权限。'
- en: In this chapter, we will discuss authentication briefly, as it is primarily
    an administrative concern that involves integrating various identity-management
    techniques with Kubernetes. On the other hand, developers are typically more concerned
    with authorization, such as who can perform which operations in the cluster and
    access specific parts of an application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要讨论身份验证，因为它主要是一个涉及将各种身份管理技术与 Kubernetes 集成的管理问题。另一方面，开发人员通常更关心授权，例如谁可以在集群中执行哪些操作以及访问应用程序的特定部分。
- en: To secure access to their applications running on top of Kubernetes, developers
    must consider a range of security strategies, from simple web-based authentication
    to sophisticated single-sign-on scenarios involving external providers for identity
    and access management. At the same time, access control to the Kubernetes API
    server is also an essential concern for applications running on Kubernetes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护运行在 Kubernetes 顶部的应用程序的访问权限，开发人员必须考虑一系列安全策略，从简单的基于Web的认证到涉及外部提供商进行身份和访问管理的复杂单点登录场景。同时，对
    Kubernetes API 服务器的访问控制对运行在 Kubernetes 上的应用程序同样重要。
- en: Misconfigured access can lead to privilege escalation and deployment failures.
    High-privilege deployments can access or modify configuration and resources for
    other deployments, increasing the risk of a cluster compromise.^([2](ch26.html#idm45902085687920))
    It is important for developers to understand the authorization rules set up by
    administrators and consider security when making configuration changes and deploying
    new workloads to meet the organization-wide policies in the Kubernetes cluster.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 错误配置的访问可能导致特权升级和部署失败。高特权的部署可以访问或修改其他部署的配置和资源，增加了集群妥协的风险。^([2](ch26.html#idm45902085687920))
    开发人员理解管理员设置的授权规则，并在进行配置更改和部署新工作负载以符合组织范围政策时考虑安全性非常重要。
- en: Furthermore, as more and more Kubernetes-native applications extend the Kubernetes
    API and offer their services via CustomResourceDefinitions (CRDs) to users, as
    described in [“Controller and Operator Classification”](ch28.html#operator-classification),
    access control becomes even more critical. Kubernetes patterns like [Chapter 27,
    “Controller”](ch27.html#Controller), and [Chapter 28, “Operator”](ch28.html#Operator),
    require high privileges to observe the state of cluster-wide resources, making
    it crucial to have fine-grained access management and restrictions in place to
    limit the impact of any potential security breaches.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着越来越多的 Kubernetes 本地应用程序通过自定义资源定义（CRD）扩展 Kubernetes API 并向用户提供服务，如[“控制器和操作员分类”](ch28.html#operator-classification)所述，访问控制变得更加关键。Kubernetes
    模式，如[第27章，“控制器”](ch27.html#Controller)和[第28章，“操作员”](ch28.html#Operator)，需要高权限来观察整个集群资源的状态，因此至关重要的是进行精细化的访问管理和限制，以限制任何潜在安全漏洞可能带来的影响。
- en: Solution
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案
- en: Every request to the Kubernetes API server has to pass through three stages—Authentication,
    Authorization, and Admission Control, as shown in [Figure 26-1](#img-accesscontrol-auth-acc-ad).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个请求到 Kubernetes API 服务器必须经过三个阶段：认证、授权和准入控制，如[图26-1](#img-accesscontrol-auth-acc-ad)所示。
- en: '![Stages that need to be passed by a request to the Kubernetes API server](assets/kup2_2601.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![请求到 Kubernetes API 服务器的必经阶段](assets/kup2_2601.png)'
- en: Figure 26-1\. A request to the Kubernetes API server must pass through these
    stages
  id: totrans-12
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图26-1\. 请求到 Kubernetes API 服务器必须经过这些阶段
- en: Once a request passes the Authentication and Authorization stages described
    in the following sections, a final check is done by Admission controllers before
    the request is eventually processed. Let’s look at these stages separately.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求通过下面描述的认证和授权阶段，最终由准入控制器进行最终检查后，请求最终才会被处理。让我们分别看看这些阶段。
- en: Authentication
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 认证
- en: 'As mentioned, we won’t go into too much detail about authentication because
    it is mainly an administration concern. But it’s good to know which options are
    available, so let’s have a look at the pluggable authentication strategies Kubernetes
    has to offer that an administrator can configure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们不会深入讨论认证，因为它主要是管理问题。但了解 Kubernetes 提供的可插拔认证策略是有好处的，让管理员可以配置：
- en: Bearer Tokens (OpenID Connect) with OIDC Authenticators
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 OIDC Authenticator 的 Bearer Tokens（OpenID Connect）
- en: OpenID Connect (OIDC) Bearer Tokens can authenticate clients and grant access
    to the API Server. OIDC is a standard protocol that allows clients to authenticate
    with an OAuth2 provider that supports OIDC. The client sends the OIDC token in
    the Authorization header of their request, and the API Server validates the token
    to allow access. For the entire flow, see the Kubernetes documentation at [OpenID
    Connect Tokens](https://oreil.ly/ZWXVD).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: OpenID Connect（OIDC）的 Bearer Tokens 可以对客户端进行认证并授予对 API 服务器的访问权限。OIDC 是一种标准协议，允许客户端与支持
    OIDC 的 OAuth2 提供者进行认证。客户端在其请求的 Authorization 标头中发送 OIDC 令牌，API 服务器验证该令牌以允许访问。有关整个流程，请参阅
    Kubernetes 文档中的[OpenID Connect Tokens](https://oreil.ly/ZWXVD)。
- en: Client certificates (X.509)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端证书（X.509）
- en: By using client certificates, the client presents a TLS certificate to the API
    Server, which is then validated and used to grant access.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用客户端证书，客户端向 API 服务器提供一个 TLS 证书，然后对其进行验证并用于授权访问。
- en: Authenticating Proxy
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 认证代理
- en: This configuration option refers to using a custom authenticating proxy to verify
    the client’s identity before granting access to the API Server. The proxy acts
    as an intermediary between the client and the API Server and performs authentication
    and authorization checks before allowing access.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此配置选项是指使用自定义认证代理来验证客户端的身份，然后才允许访问 API 服务器。代理充当客户端和 API 服务器之间的中介，并在允许访问之前执行认证和授权检查。
- en: Static Token files
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 静态令牌文件
- en: Tokens can also be stored in standard files and used for authentication. In
    this approach, the client presents a token to the API Server, which is then used
    to look up the token file and search for a match.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Token 也可以存储在标准文件中，并用于认证。在此方法中，客户端向 API 服务器提供一个令牌，然后用于查找令牌文件并搜索匹配项。
- en: Webhook Token Authentication
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook Token 认证
- en: A webhook can authenticate clients and grant access to the API Server. In this
    approach, the client sends a token in the Authorization header of their request,
    and the API Server forwards the token to a configured webhook for validation.
    The client is granted access to the API Server if the webhook returns a valid
    response. This technique is similar to the Bearer Token option, except that you
    can use an external custom service for performing the token validation.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Webhook 可以对客户端进行身份验证，并授予对 API 服务器的访问权限。在这种方法中，客户端在其请求的授权头部发送一个令牌，API 服务器将该令牌转发给预先配置的
    Webhook 进行验证。如果 Webhook 返回有效响应，则客户端被授予访问 API 服务器的权限。这种技术类似于 Bearer Token 选项，不同之处在于可以使用外部自定义服务进行令牌验证。
- en: Kubernetes allows you to use multiple authentication plugins simultaneously,
    such as Bearer Tokens and Client certificates. If the Bearer Token strategy authenticates
    a request, Kubernetes won’t check the Client certificates, and vice versa. Unfortunately,
    the order in which these strategies are evaluated is not fixed, so it’s impossible
    to know which one will be checked first. When evaluating the strategies, the process
    will stop after one is successful, and Kubernetes will forward the request to
    the next stage.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 允许同时使用多个身份验证插件，如 Bearer Tokens 和客户端证书。如果 Bearer Token 策略验证了请求，Kubernetes
    将不会检查客户端证书，反之亦然。不幸的是，这些策略评估的顺序不是固定的，因此无法知道哪一个会首先被检查。在评估策略时，一旦成功，过程将停止，并且 Kubernetes
    将请求转发到下一个阶段。
- en: After authentication, the authorization process will begin.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证后，将开始授权过程。
- en: Authorization
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权
- en: Kubernetes provides RBAC as a standard way to manage access to the system. RBAC
    allows developers to control and execute actions in a fine-grained manner. The
    authorization plugin in Kubernetes also provides easy pluggability, allowing users
    to switch between the default RBAC and other models, such as attribute-based access
    control (ABAC), webhooks, or delegation to a custom authority.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供 RBAC 作为管理系统访问权限的标准方式。RBAC 允许开发者以精细化的方式控制和执行操作。Kubernetes 中的授权插件还提供了易于插拔的特性，允许用户在默认
    RBAC 和其他模型（如基于属性的访问控制（ABAC）、Webhook 或委托给自定义权威）之间进行切换。
- en: The [ABAC-based approach](https://oreil.ly/xNBK8) requires a file containing
    policies in a JSON per-line format. However, this approach requires the server
    to be reloaded for any changes, which can be a disadvantage. This static nature
    is one of the reasons ABAC-based authorization is used only in some cases.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的访问控制（ABAC）方法需要一个文件，其中包含以 JSON 每行一条的策略。然而，这种方法需要服务器重新加载以应用任何更改，这可能是一个缺点。这种静态特性是
    ABAC 授权仅在某些情况下使用的原因之一。
- en: Instead, nearly every Kubernetes cluster uses the default RBAC-based access
    control, which we describe in great detail in [“Role-Based Access Control”](#accesscontrol-rbac).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，几乎每个 Kubernetes 集群都使用默认的基于 RBAC 的访问控制，我们在[“基于角色的访问控制”](#accesscontrol-rbac)中详细描述了该控制方式。
- en: Before we focus on authorization in the rest of this chapter, let’s quickly
    look at the last stage performed by admission controllers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分关注授权之前，让我们快速看一下准入控制器执行的最后阶段。
- en: Admission Controllers
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准入控制器
- en: Admission controllers are a feature of the Kubernetes API server that allows
    you to intercept requests to the API server and take additional actions based
    on those requests. For example, you can use them to enforce policies, perform
    validations, and modify incoming resources.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 准入控制器是 Kubernetes API 服务器的一个特性，允许您拦截对 API 服务器的请求，并根据这些请求执行附加操作。例如，您可以使用它们来强制执行策略、执行验证和修改传入的资源。
- en: Kubernetes uses Admission controller plugins for implementing various functions.
    The functionality ranges from setting default values on specific resources (like
    the default storage class on persistent volumes), to validations (like the allowed
    resource limits for Pods), by calling external web hooks.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 使用准入控制器插件来实现各种功能。这些功能范围从在特定资源上设置默认值（如持久卷上的默认存储类），到验证（如 Pod 的允许资源限制），通过调用外部
    Webhook 实现。
- en: These external webhooks can be configured with dedicated resources and are used
    for validation (ValidatingWebhookConfiguration) and updating (MutatingWebhookConfiguration)
    API resources. The details of configuring such webhooks are explained in detail
    in the Kubernetes documentation [“Dynamic Admission Control”](https://oreil.ly/JEBu6).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些外部 Webhook 可以配置为专用资源，并用于验证（ValidatingWebhookConfiguration）和更新（MutatingWebhookConfiguration）API
    资源。有关配置此类 Webhook 的详细信息，请参阅 Kubernetes 文档[“动态 Admission 控制”](https://oreil.ly/JEBu6)。
- en: We won’t go into more detail here as Admission controllers are mostly an administrative
    concept, and many other good resources describe Admission controllers in particular
    (see [“More Information”](#accesscontrol-more-information) for some references).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里不会详细介绍 Admission controllers，因为它们大多是一个管理概念，还有很多其他好的资源专门描述了 Admission controllers（参见[“更多信息”](#accesscontrol-more-information)）。
- en: Instead, for the remainder of the chapter, we will focus on the authorization
    aspect and how we can configure a fine-grained permission model for securing access
    to the Kubernetes API server.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，本章的剩余部分，我们将专注于授权方面，以及如何为保护对 Kubernetes API 服务器的访问配置精细化的权限模型。
- en: 'As mentioned, authentication has two fundamental parts and authorization: the
    *who*, represented by a subject that can be either a human person or a workload
    identity, and the *what*, representing the actions those subjects can trigger
    at the Kubernetes API server. In the next section, we discuss the who before diving
    into the details of the *what*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如提到的，认证有两个基本部分和授权：*谁*，由一个主体表示，可以是一个人或者一个工作负载身份，以及*什么*，代表这些主体可以触发 Kubernetes
    API 服务器上的操作。在接下来的章节中，我们先讨论*谁*，然后再深入讨论*什么*的细节。
- en: Subject
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主体
- en: 'A *subject* is all about the *who*, the identity associated with a request
    to the Kubernetes API server. In Kubernetes, there are two kinds of subjects,
    as shown in [Figure 26-2](#img-accesscontrol-subject): human *users* and *service
    accounts* that represent the workload identity of Pods.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*主体* 关注的是*谁*，与请求到 Kubernetes API 服务器相关联的身份。在 Kubernetes 中，有两种类型的主体，如图[26-2](#img-accesscontrol-subject)所示：人类*用户*和代表
    Pod 工作负载身份的*服务账户*。'
- en: '![Subject requests to API Server](assets/kup2_2602.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![主体请求到 API Server](assets/kup2_2602.png)'
- en: Figure 26-2\. Subject (user or service account) requests to API Server
  id: totrans-43
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图26-2\. 主体（用户或服务账户）请求到 API Server
- en: Human users and ServiceAccounts can be separately grouped in *user groups* and
    *service account groups*, respectively. Those groups can act as a single subject
    in which all members of the group share the same permission model. We will talk
    about groups later in this chapter, but first, let’s look closely at how human
    users are represented in the Kubernetes API.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 人类用户和服务账户可以分别分组为*用户组*和*服务账户组*，这些组可以作为单一主体，其中组的所有成员共享相同的权限模型。我们将在本章后面讨论组，但首先，让我们仔细看看人类用户在
    Kubernetes API 中的表示。
- en: Users
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户
- en: Unlike many other entities in Kubernetes, human users are not defined as explicit
    resources in the Kubernetes API. This design decision implies that you can’t manage
    users via an API call. The authentication and mapping to a user subject happens
    outside the usual Kubernetes API machinery by external user management.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Kubernetes 中许多其他实体不同，人类用户不作为显式资源在 Kubernetes API 中定义。这种设计决策意味着您无法通过 API 调用管理用户。认证和映射到用户主体是在通常的
    Kubernetes API 机制之外由外部用户管理完成的。
- en: As we have seen, Kubernetes supports many ways of authenticating an external
    user. Each component knows how to extract the subject information after successful
    authentication. Although this mechanism is different for each authentication component,
    they will eventually create the same user representation and add it to the actual
    API request to verify by later stages, as shown in [Example 26-1](#ex-access-control-uid).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，Kubernetes 支持多种方法来验证外部用户的身份。每个组件都知道如何在成功验证后提取主体信息。虽然每个认证组件的机制都不同，但它们最终会创建相同的用户表示，并将其添加到实际的
    API 请求中，在后续阶段进行验证，如图[例子 26-1](#ex-access-control-uid)所示。
- en: Example 26-1\. Representation of an external user after successful authentication
  id: totrans-48
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 例子 26-1\. 成功验证外部用户的表示
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This comma-separated list is a representation of the user and contains the
    following parts:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个逗号分隔的列表表示用户，并包含以下部分：
- en: The username (`alice`)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户名（`alice`）
- en: A unique user id (UID) (`4bc01e30-406b-4514`)
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 唯一用户标识符（UID）（`4bc01e30-406b-4514`）
- en: A list of groups that this user belongs to (`system:authenticated,developers`)
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该用户所属的组列表（`system:authenticated,developers`）
- en: Additional information as comma-separated key-value pairs (`scopes:openid`)
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加信息作为逗号分隔的键值对 (`scopes:openid`)
- en: This information is evaluated by the Authorization plugin against the authorization
    rules associated with the user or via its membership to a user group. In [Example 26-1](#ex-access-control-uid),
    a user with the username `alice` has the default access associated with the group
    `system:authenticated` and the group `developers`. The extra information `scope:openid`
    indicates OIDC is being used to verify the user’s identity.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此信息由授权插件根据用户关联的授权规则或其所属用户组进行评估。在 [示例 26-1](#ex-access-control-uid) 中，用户名为 `alice`
    的用户具有与 `system:authenticated` 组和 `developers` 组关联的默认访问权限。额外的信息 `scope:openid`
    表示正在使用 OIDC 验证用户身份。
- en: Certain usernames are reserved for internal Kubernetes use and are distinguished
    by the special prefix `system:`. For example, the username `system:anonymous`
    represents anonymous requests to the Kubernetes API server. It is recommended
    to avoid creating your own users or groups with the `system:` prefix to avoid
    conflicts. [Table 26-1](#table-accesscontrol-default-users) lists the default
    usernames in Kubernetes that are used when internal Kubernetes components communicate
    to one another.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 某些用户名专为 Kubernetes 内部使用保留，并由特殊前缀 `system:` 区分。例如，用户名 `system:anonymous` 代表对
    Kubernetes API 服务器的匿名请求。建议避免以 `system:` 前缀创建自己的用户或组，以避免冲突。[表 26-1](#table-accesscontrol-default-users)
    列出了在 Kubernetes 中用于内部组件间通信时使用的默认用户名。
- en: Table 26-1\. Default usernames in Kubernetes
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 表 26-1\. Kubernetes 中的默认用户名
- en: '| Username | Purpose |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| 用户名 | 用途 |'
- en: '| --- | --- |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `system:anonymous` | Represents anonymous requests to the Kubernetes API
    server |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| `system:anonymous` | 表示对 Kubernetes API 服务器的匿名请求 |'
- en: '| `system:apiserver` | Represents the API server itself |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| `system:apiserver` | 表示 API 服务器本身 |'
- en: '| `system:kube-proxy` | Represents process identity of the kube-proxy service
    |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| `system:kube-proxy` | 表示 kube-proxy 服务的进程身份 |'
- en: '| `system:kube-controller-manager` | Represents the user agent of the controller
    manager |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| `system:kube-controller-manager` | 表示控制器管理器的用户代理 |'
- en: '| `system:kube-scheduler` | Represents the user of the scheduler |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| `system:kube-scheduler` | 表示调度程序的用户 |'
- en: While the management and authentication of external users can vary depending
    on the specific setup of a Kubernetes cluster, the management of workload identities
    for Pods is a standardized part of the Kubernetes API and is consistent across
    all clusters.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 集群的外部用户管理和认证可能因具体设置而异，但对 Pod 的工作负载身份的管理是 Kubernetes API 的标准化部分，并在所有集群中保持一致。
- en: Service accounts
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Service 账户
- en: Service accounts in Kubernetes represent nonhuman actors within the cluster
    and are used as workload identities. They are associated with Pods and allow running
    processes inside a Pod to communicate with the Kubernetes API Server. In contrast
    to the many ways that Kubernetes can authenticate human users, service accounts
    always use an [OpenID Connect handshake](https://oreil.ly/0fhR8) and JSON Web
    Tokens to prove their identity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的服务账户代表集群内的非人类实体，并用作工作负载标识。它们与 Pod 关联，允许 Pod 内的运行进程与 Kubernetes
    API 服务器通信。与 Kubernetes 可以对人类用户进行身份验证的多种方式不同，服务账户始终使用 [OpenID Connect 握手](https://oreil.ly/0fhR8)
    和 JSON Web Tokens 来证明其身份。
- en: 'Service accounts in Kubernetes are authenticated by the API server using a
    username in the following format: `system:serviceaccount:<namespace>:<name>`.
    For example, if you have a service account, `random-sa`, in the `default` namespace,
    the service account’s username would be `system:serviceaccount:default:random-sa`.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的服务账户通过 API 服务器使用以下格式的用户名进行身份验证：`system:serviceaccount:<namespace>:<name>`。例如，如果在
    `default` 命名空间中有一个名为 `random-sa` 的服务账户，则服务账户的用户名将是 `system:serviceaccount:default:random-sa`。
- en: A ServiceAccount is a standard Kubernetes resource, as shown in [Example 26-2](#ex-accesscontrol-yaml-sa).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount 是 Kubernetes 的标准资源，如 [示例 26-2](#ex-accesscontrol-yaml-sa) 所示。
- en: Example 26-2\. ServiceAccount definition
  id: totrans-70
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-2\. ServiceAccount 定义
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[![1](assets/1.png)](#co_access_control_CO1-1)'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO1-1)'
- en: Name of the service account.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 服务账户的名称。
- en: '[![2](assets/2.png)](#co_access_control_CO1-2)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO1-2)'
- en: Flag indicating whether the service account token should be mounted by default
    into a Pod. The default is set to `true`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 指示是否默认将服务账户令牌挂载到 Pod 中的标志。默认设置为 `true`。
- en: A ServiceAccount has a simple structure and serves all identity-related information
    needed for a Pod when talking with the Kubernetes API server. Every namespace
    has a default ServiceAccount with the name `default` used to identify any Pod
    that does not define an associated ServiceAccount.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount具有简单的结构，并为Pod在与Kubernetes API服务器通信时所需的所有身份相关信息提供服务。每个命名空间都有一个默认的ServiceAccount，名称为`default`，用于标识未定义关联ServiceAccount的任何Pod。
- en: Each ServiceAccount has a JWT associated with it that is fully managed by the
    Kubernetes backend. A Pod’s associated ServiceAccount’s token is automatically
    mounted into the filesystem of each Pod. [Example 26-3](#ex-accesscontrol-pod-spec)
    shows the relevant part of a Pod specification that Kubernetes has automatically
    added for every Pod created.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每个ServiceAccount都有一个与之关联的JWT，完全由Kubernetes后端管理。每个Pod的关联ServiceAccount令牌会自动挂载到每个Pod的文件系统中。[示例 26-3](#ex-accesscontrol-pod-spec)显示了Kubernetes自动为每个创建的Pod添加的相关部分。
- en: Example 26-3\. ServiceAccount token mounted as a file for a Pod
  id: totrans-78
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-3\. ServiceAccount令牌作为Pod的文件挂载
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[![1](assets/1.png)](#co_access_control_CO2-1)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO2-1)'
- en: '`serviceAccountName` to set the name of the service account (`serviceAccount`
    is a deprecated alias for `serviceAccountName`).'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`serviceAccountName`用于设置服务帐户的名称（`serviceAccount`是`serviceAccountName`的已弃用别名）。'
- en: '[![2](assets/2.png)](#co_access_control_CO2-2)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO2-2)'
- en: '*/var/run/secrets/kubernetes.io/serviceaccount* is the directory under which
    the service account token is mounted.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*/var/run/secrets/kubernetes.io/serviceaccount*是服务帐户令牌挂载的目录。'
- en: '[![3](assets/3.png)](#co_access_control_CO2-3)'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_access_control_CO2-3)'
- en: Kubernetes assigns a random Pod-unique name to the auto-generated volume.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes为自动生成的卷分配一个随机的Pod唯一名称。
- en: '[![4](assets/4.png)](#co_access_control_CO2-4)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_access_control_CO2-4)'
- en: A projected volume injects the ServiceAccount token directly into the filesystem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一个投影体积直接将ServiceAccount令牌注入文件系统。
- en: '[![5](assets/5.png)](#co_access_control_CO2-5)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_access_control_CO2-5)'
- en: Expiration time of the token in seconds. After this time, the token expires,
    and the mounted token file is updated with a new token.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 令牌的过期时间以秒计。此时间后，令牌过期，并且挂载的令牌文件将使用新令牌更新。
- en: '[![6](assets/6.png)](#co_access_control_CO2-6)'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '[![6](assets/6.png)](#co_access_control_CO2-6)'
- en: The name of the file that will contain the token.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 文件名将包含令牌的名称。
- en: To view the mounted token, we can execute a `cat` on the mounted file in the
    running Pod, as shown in [Example 26-4](#ex-accesscontrol-cat-token).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看挂载的令牌，我们可以在运行中的Pod中执行对挂载文件的`cat`，如[示例 26-4](#ex-accesscontrol-cat-token)所示。
- en: Example 26-4\. Print out the service account JWT (output is shortened)
  id: totrans-93
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-4\. 打印出服务帐户JWT（输出已缩短）
- en: '[PRE3]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In [Example 26-3](#ex-accesscontrol-pod-spec), the token is mounted into the
    Pod as a projected volume. Projected volumes allow you to merge multiple volume
    sources, such as Secret and ConfigMap volumes (described in [Chapter 20, “Configuration
    Resource”](ch20.html#ConfigurationResource)), into a single directory. With this
    volume type, the ServiceAccount token can also be directly mapped into the Pod’s
    filesystem using a `serviceAccountToken` subtype. This method has several benefits,
    including reducing the attack surface by eliminating the need for an intermediate
    representation of the token and by providing the ability to set an expiration
    time for the token, which the Kubernetes token controller will rotate after it
    expires. Furthermore, the token injected into the Pod will be valid only for the
    duration of the Pod’s existence, further reducing the risk of unauthorized inspection
    of the service account’s token.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 26-3](#ex-accesscontrol-pod-spec)中，令牌作为投影体积装载到Pod中。投影体积允许您合并多个卷源，如Secret和ConfigMap卷（在[第20章，“配置资源”](ch20.html#ConfigurationResource)中描述），进入单个目录。通过这种卷类型，ServiceAccount令牌也可以直接映射到Pod的文件系统，使用`serviceAccountToken`子类型。该方法有几个好处，包括通过消除令牌中间表示的需要来减少攻击面，并提供设置令牌过期时间的能力，Kubernetes令牌控制器将在过期后进行轮换。此外，注入到Pod中的令牌仅在Pod存在期间有效，进一步减少未经授权查看服务帐户令牌的风险。
- en: Before Kubernetes 1.24, Secrets were used to represent these tokens and were
    mounted directly with a `secret` volume type, which had the disadvantage of long
    lifetimes and lack of rotation. Thanks to the new projected volume type, the token
    is available only to the Pod and is not exposed as an additional resource, which
    reduces the attack surface. You can still create a Secret manually to contain
    a ServiceAccount’s token, as demonstrated in [Example 26-5](#ex-accesscontrol-token-secret).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes 1.24之前，秘密用于表示这些令牌，并直接通过`secret`卷类型挂载，其缺点是寿命长且缺乏轮换。由于新的投影卷类型，令牌仅对Pod可用，并且不作为附加资源公开，这减少了攻击面。您仍然可以手动创建一个包含ServiceAccount令牌的秘密，如[示例 26-5](#ex-accesscontrol-token-secret)所示。
- en: Example 26-5\. Create a Secret for ServiceAccount `random-sa`
  id: totrans-97
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-5\. 为ServiceAccount `random-sa`创建一个秘密
- en: '[PRE4]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[![1](assets/1.png)](#co_access_control_CO3-1)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO3-1)'
- en: Special type to indicate that this Secret is about holding a ServiceAccount.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一种特殊类型，表示这个秘密用于保存ServiceAccount。
- en: '[![2](assets/2.png)](#co_access_control_CO3-2)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO3-2)'
- en: Reference to ServiceAccount, whose token should be added.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 引用应添加其令牌的ServiceAccount。
- en: Kubernetes will fill in the token and the public key for validation into the
    secret. Also, the lifecycle of this Secret is now bound to the ServiceAccount
    itself. If you delete the ServiceAccount, Kubernetes will also delete this secret.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes将token和用于验证的公钥填充到秘密中。此秘密的生命周期现在与ServiceAccount本身绑定。如果删除了ServiceAccount，Kubernetes也会删除这个秘密。
- en: 'The ServiceAccount resource has two additional fields for specifying credentials
    for pulling container images and defining the secrets allowed to be mounted:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount资源有两个额外的字段，用于指定用于拉取容器映像的凭据和定义允许挂载的秘密：
- en: Image pull secrets
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 映像拉取秘密
- en: Image pull secrets allow a workload to authenticate with a private registry
    when pulling images. Typically, you would need to manually specify the pull secrets
    as part of the Pod specification in the fields `.spec.imagePullSecrets`. However,
    Kubernetes provides a shortcut by allowing you to attach a pull secret directly
    to a ServiceAccount in the top-level field `imagePullSecrets`. Every Pod associated
    with the ServiceAccount will automatically have the pull secrets injected into
    its specification when it is created. This automation eliminates the need to manually
    include the image pull secrets in the Pod specification every time a new Pod is
    created in the namespace, reducing the manual effort required.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 映像拉取秘密允许工作负载在拉取映像时与私有注册表进行身份验证。通常，您需要在Pod规范的字段`.spec.imagePullSecrets`中手动指定拉取秘密。但是，Kubernetes通过允许直接将拉取秘密附加到顶级字段`imagePullSecrets`的ServiceAccount中提供了一种快捷方式。与ServiceAccount关联的每个Pod在创建时都将自动将拉取秘密注入其规范中。这种自动化消除了在每次在命名空间中创建新Pod时手动包含映像拉取秘密的需求，从而减少了所需的手动工作。
- en: Mountable secrets
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 可挂载的秘密
- en: The `secrets` field in the ServiceAccount resource allows you to specify which
    secrets a Pod associated with the ServiceAccount can mount. You can enable this
    restriction by adding the `kubernetes.io/enforce-mountable-secrets` annotation
    to the ServiceAccount. If this annotation is set to `true`, only the Secrets listed
    will be allowed to be mounted by Pods associated with the ServiceAccount.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount资源中的`secrets`字段允许您指定与ServiceAccount关联的Pod可以挂载的秘密。您可以通过向ServiceAccount添加`kubernetes.io/enforce-mountable-secrets`注释来启用此限制。如果将此注释设置为`true`，则只允许Pod挂载列出的秘密。
- en: Groups
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 组
- en: Both user and service accounts in Kubernetes can belong to one or more groups.
    Groups are attached to requests by the authentication system and are used to grant
    permissions to all group members. As seen in [Example 26-1](#ex-access-control-uid),
    group names are plain strings that represent the group name.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes中的用户和服务账户都可以属于一个或多个组。组是由认证系统附加到请求的，用于授予所有组成员权限。如[示例 26-1](#ex-access-control-uid)中所见，组名是表示组名称的纯字符串。
- en: As mentioned earlier, groups can be freely defined and managed by the identity
    provider to create groups of subjects with the same permission model. A set of
    predefined groups in Kubernetes are also implicitly defined and have a `system:`
    prefix in their name. These predefined groups are listed in [Table 26-2](#table-accesscontrol-default-groups).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前面提到的，组可以由身份提供者自由定义和管理，以创建具有相同权限模型的主体组。Kubernetes中还隐含定义了一组预定义的组，其名称以`system:`为前缀。这些预定义组列在[表 26-2](#table-accesscontrol-default-groups)中。
- en: We will see how group names can be used in a RoleBinding to grant permissions
    to all group members in [“RoleBinding”](#accesscontrol-rolebinding).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何在[“角色绑定”](#accesscontrol-rolebinding)中使用组名来授予所有组成员的权限。
- en: Table 26-2\. System groups in Kubernetes
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 26-2\. Kubernetes中的系统组
- en: '| Group | Purpose |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 组 | 用途 |'
- en: '| --- | --- |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `system:unauthenticated` | Group assigned to every unauthenticated request
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `system:unauthenticated` | 分配给每个未经身份验证请求的组 |'
- en: '| `system:authenticated` | Group assigned to an authenticated user |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| `system:authenticated` | 分配给已认证用户的组 |'
- en: '| `system:masters` | Group whose members have unrestricted access to the Kubernetes
    API server |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| `system:masters` | 其成员对Kubernetes API服务器拥有无限制访问权限的组 |'
- en: '| `system:serviceaccounts` | Group with all ServiceAccounts of the cluster
    |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| `system:serviceaccounts` | 集群中所有服务账户的组 |'
- en: '| `system:serviceaccounts:<namespace>` | Group with all ServiceAccounts of
    this namespace |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| `system:serviceaccounts:<namespace>` | 此命名空间中所有服务账户的组 |'
- en: Now that you have a clear understanding of users, ServiceAccounts, and groups,
    let’s examine how these subjects can be associated with Roles that define the
    actions they are allowed to perform against the Kubernetes API server.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经清楚了解用户、服务账户和组，让我们检查如何将这些主体与定义其允许执行的操作的角色关联到Kubernetes API服务器。
- en: Role-Based Access Control
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于角色的访问控制
- en: In Kubernetes, Roles define the specific actions that a subject can perform
    on particular resources. You can then assign these Roles to subjects, such as
    users or service accounts, as described in [“Subject”](#accesscontrol-subject),
    through the use of RoleBindings. Roles and RoleBindings are Kubernetes resources
    that can be created and managed like any other resource. They are tied to a specific
    namespace and apply to its resources.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes中，角色定义了主体可以对特定资源执行的具体操作。然后，您可以将这些角色分配给主体，如用户或服务账户，如[“主体”](#accesscontrol-subject)中所述，通过使用角色绑定。角色和角色绑定是可以像任何其他资源一样创建和管理的Kubernetes资源。它们与特定命名空间绑定，并适用于其资源。
- en: '[Figure 26-3](#img-accesscontrol-rbac) illustrates the relationship between
    subjects, Roles, and RoleBindings.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 26-3](#img-accesscontrol-rbac)展示了主体、角色和角色绑定之间的关系。'
- en: '![Relationship between Role, Rolebinding and subjects](assets/kup2_2603.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![角色、角色绑定和主体之间的关系](assets/kup2_2603.png)'
- en: Figure 26-3\. Relationship between Role, RoleBinding, and subjects
  id: totrans-126
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 26-3\. 角色、角色绑定和主体之间的关系
- en: In Kubernetes RBAC, it is important to understand that there is a many-to-many
    relationship between subjects and Roles. This means that a single subject can
    have multiple Roles, and a single Role can be applied to multiple subjects. The
    relationship between a subject and a Role is established using a RoleBinding,
    which contains references to a list of subjects and a specific Role.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kubernetes RBAC中，了解主体与角色之间存在多对多的关系很重要。这意味着单个主体可以具有多个角色，并且单个角色可以应用于多个主体。使用包含对主体列表和特定角色的引用的角色绑定来建立主体与角色之间的关系。
- en: The RBAC concepts are best explained with a concrete example. [Example 26-6](#ex-accesscontrol-role)
    shows the definition of a Role in Kubernetes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: RBAC概念通过具体示例最好解释。[示例 26-6](#ex-accesscontrol-role)展示了Kubernetes中角色的定义。
- en: Example 26-6\. Role for allowing access to core resources
  id: totrans-129
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-6\. 允许访问核心资源的角色
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[![1](assets/1.png)](#co_access_control_CO4-1)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO4-1)'
- en: The name of the Role, which is used to reference it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用于引用此角色的角色名称。
- en: '[![2](assets/2.png)](#co_access_control_CO4-2)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO4-2)'
- en: Namespace to which this Role applies. Roles are always connected to a namespace.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此角色适用的命名空间。角色始终与命名空间关联。
- en: '[![3](assets/3.png)](#co_access_control_CO4-3)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_access_control_CO4-3)'
- en: An empty string indicates the core API group.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 空字符串表示核心API组。
- en: '[![4](assets/4.png)](#co_access_control_CO4-4)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_access_control_CO4-4)'
- en: List of Kubernetes core resources to which the rule applies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 规则适用的Kubernetes核心资源列表。
- en: '[![5](assets/5.png)](#co_access_control_CO4-5)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '[![5](assets/5.png)](#co_access_control_CO4-5)'
- en: API actions are represented by verbs allowed by subjects associated with this
    Role.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: API操作由与该角色关联的主体允许的动词表示。
- en: The Role defined in [Example 26-6](#ex-accesscontrol-role) specifies that any
    user or service account associated with this Role can perform read-only operations
    on Pods and Services.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 26-6](#ex-accesscontrol-role)中定义的角色指定了与该角色关联的任何用户或服务账户可以对Pod和Service执行只读操作。
- en: This Role can then be referenced in the RoleBinding shown in [Example 26-7](#ex-accesscontrol-rolebinding)
    to grant access to both the user, `alice`, and the ServiceAccount, `contractor`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以在 [示例 26-7](#ex-accesscontrol-rolebinding) 中显示的 RoleBinding 中引用此 Role，以授予用户
    `alice` 和 ServiceAccount `contractor` 的访问权限。
- en: Example 26-7\. RoleBinding specification
  id: totrans-143
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例 26-7\. RoleBinding 规范
- en: '[PRE6]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[![1](assets/1.png)](#co_access_control_CO5-1)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO5-1)'
- en: List of subjects to connect to a Role.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到 Role 的主题列表。
- en: '[![2](assets/2.png)](#co_access_control_CO5-2)'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO5-2)'
- en: Human user reference for a user named `alice`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `alice` 的用户的人类用户引用。
- en: '[![3](assets/3.png)](#co_access_control_CO5-3)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_access_control_CO5-3)'
- en: Service account with name `contractor`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 名为 `contractor` 的 Service account。
- en: '[![4](assets/4.png)](#co_access_control_CO5-4)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](assets/4.png)](#co_access_control_CO5-4)'
- en: Reference to the Role with the name `developer-ro` that has been defined in
    [Example 26-6](#ex-accesscontrol-role).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 引用已在 [示例 26-6](#ex-accesscontrol-role) 中定义的名为 `developer-ro` 的 Role。
- en: Now that you have a basic understanding of the relationship between subjects,
    Roles, and RoleBindings, let’s delve deeper into the specifics of Roles and RoleBindings.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经对主题、Roles 和 RoleBindings 之间的关系有了基本的了解，让我们深入探讨 Roles 和 RoleBindings 的具体细节。
- en: Role
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Role
- en: 'Roles in Kubernetes allow you to define a set of permitted actions for a group
    of Kubernetes resources or subresources. Typical activities on Kubernetes resources
    include the following:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 Roles 允许您为一组 Kubernetes 资源或子资源定义一组允许的操作。在 Kubernetes 资源上的典型活动包括以下内容：
- en: Getting Pods
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取 Pods
- en: Deleting Secrets
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除 Secrets
- en: Updating ConfigMaps
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 ConfigMaps
- en: Creating ServiceAccounts
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 ServiceAccounts
- en: You have already seen a Role in [Example 26-6](#ex-accesscontrol-role). Besides
    metadata, such as names and namespaces, a Role definition consists of a list of
    rules that describe which resources can be accessed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经在 [示例 26-6](#ex-accesscontrol-role) 中看到了一个 Role。除了名称和命名空间等元数据外，Role 定义还包括一系列规则，描述了可以访问哪些资源。
- en: 'Only one rule must match a request to grant access to this Role. Three fields
    describe each `rule`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 只需匹配一个请求以授予对此 Role 的访问权限。每个 `rule` 描述了三个字段：
- en: apiGroups
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: apiGroups
- en: This list is used rather than a single value because wildcards can specify all
    resources of multiple API groups. For example, an empty string (`""`) is used
    for the core API group, which contains primary Kubernetes resources such as Pods
    and Services. A wildcard character (*) can match all available API groups the
    cluster is aware of.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表用于代替单个值，因为通配符可以指定多个 API 组的所有资源。例如，空字符串 (`""`) 用于核心 API 组，其中包含主要的 Kubernetes
    资源，如 Pods 和 Services。通配符字符 (`*`) 可以匹配集群感知的所有可用 API 组。
- en: resources
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 资源
- en: This list specifies the resources that Kubernetes should grant access to. Each
    entry should belong to at least one of the configured `apiGroups`. A single `*`
    wildcard entry means all resources from all configured `apiGroups` are allowed.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表指定了 Kubernetes 应授予访问权限的资源。每个条目应属于至少一个配置的 `apiGroups`。单个 `*` 通配符条目表示允许来自所有配置的
    `apiGroups` 的所有资源。
- en: verbs
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 动词
- en: Allowed actions in a system are defined using verbs that are similar to HTTP
    methods. These verbs include CRUD operations on resources (CRUD stands for *Create-Read-Update-Delete*
    and describes the usual read-write operations that you can perform on persistent
    entities), and separate actions for operations on collections, such as `list`
    and `deletecollection`. Additionally, a `watch` verb allows access to resource
    change events and is separate from directly reading the resource with `get`. This
    `watch` verb is crucial for operators to receive notifications about the current
    status of resources they are managing. [Chapter 27, “Controller”](ch27.html#Controller),
    and [Chapter 28, “Operator”](ch28.html#Operator), has more on this topic. [Table 26-3](#table-accesscontrol-verbs)
    lists the most common verbs. Using the `*` wildcard character is also possible
    to allow all operations on the configured resources for a given rule.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在系统中允许的操作通过类似于 HTTP 方法的动词来定义。这些动词包括对资源的 CRUD 操作（CRUD 代表*创建-读取-更新-删除*，描述了你可以对持久化实体执行的常规读写操作），以及针对集合的单独操作，例如
    `list` 和 `deletecollection`。此外，`watch` 动词允许访问资源变更事件，并与使用 `get` 直接读取资源的操作分开。对于运营人员来说，`watch`
    动词对于接收他们正在管理的资源的当前状态通知至关重要。[第 27 章，“Controller”](ch27.html#Controller) 和 [第 28
    章，“Operator”](ch28.html#Operator) 中有更多相关内容。[表格 26-3](#table-accesscontrol-verbs)
    列出了最常见的动词。还可以使用 `*` 通配符字符来允许针对给定规则配置的所有资源的所有操作。
- en: Table 26-3\. Kubernetes verb mapping to HTTP request methods for CRUD operations
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 表 26-3\. Kubernetes CRUD 操作的 HTTP 请求方法映射
- en: '| Verbs | HTTP request methods |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 动词 | HTTP 请求方法 |'
- en: '| --- | --- |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| get, watch, list | GET |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| get, watch, list | GET |'
- en: '| create | POST |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| create | POST |'
- en: '| patch | PATCH |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| patch | PATCH |'
- en: '| update | PUT |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| update | PUT |'
- en: '| delete, delete collection | DELETE |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| delete, delete collection | DELETE |'
- en: Wildcard permissions make it easier to define all operations without listing
    each option individually. All of the properties of a Role’s `rule` element allow
    for an `*` wildcard, which matches everything. [Example 26-8](#table-accesscontrol-wildcards)
    allows for all operations on all resources in the core and `networking.k8s.io`
    API group. If a wildcard is used, this list should have only this wildcard as
    its single entry.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符权限使得能够在不单独列出每个选项的情况下更轻松地定义所有操作。角色的 `rule` 元素的所有属性都允许使用 `*` 通配符，该通配符匹配所有内容。[示例 26-8](#table-accesscontrol-wildcards)
    允许在核心和 `networking.k8s.io` API 组中的所有资源上执行所有操作。如果使用通配符，此列表应仅包含此通配符作为其唯一条目。
- en: Example 26-8\. Wildcard permission for resources and permitted operations
  id: totrans-177
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 26-8\. 资源和允许操作的通配符权限
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[![1](assets/1.png)](#co_access_control_CO6-1)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO6-1)'
- en: All Resources in the listed API groups, core, and `networking.k8s.io.`
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 所有列出的 API 组中的所有资源，核心和 `networking.k8s.io`。
- en: '[![2](assets/2.png)](#co_access_control_CO6-2)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO6-2)'
- en: All actions are allowed on those resources.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些资源允许执行所有操作。
- en: Wildcards help developers to configure rules quickly. But they come with the
    security risk of privilege escalation. Such broader privileges can cause security
    gaps and allow users to perform any operations that can compromise the Kubernetes
    cluster or cause unwanted changes.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通配符帮助开发人员快速配置规则。但它们伴随着特权升级的安全风险。这种更广泛的特权可能导致安全漏洞，并允许用户执行可能危及 Kubernetes 集群或引起不必要更改的任何操作。
- en: Now that we have looked into the *what* (Roles) and *who* (subjects) of the
    Kubernetes RBAC model, let’s have a closer look at how we can combine both concepts
    with RoleBindings.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经深入探讨了 Kubernetes RBAC 模型中角色（*what*）和主体（*who*）的内容，让我们更详细地看看如何结合这两个概念与RoleBindings。
- en: RoleBinding
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RoleBinding
- en: In [Example 26-7](#ex-accesscontrol-rolebinding), we saw how RoleBindings link
    one or more subjects to a given Role.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在[示例 26-7](#ex-accesscontrol-rolebinding)中，我们看到了RoleBindings如何将一个或多个主体链接到给定的角色。
- en: Each RoleBinding can connect a list of subjects to a Role. The `subjects` list
    field takes resource references as elements. Those resource references have a
    `name` field plus `kind` and `apiGroup` fields for defining the resource type
    to reference.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个RoleBinding可以将一组主体连接到一个角色。`subjects` 列表字段以资源引用为元素。这些资源引用具有 `name` 字段以及用于定义引用的资源类型的
    `kind` 和 `apiGroup` 字段。
- en: 'A subject in a RoleBinding can be one of the following types:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: RoleBinding中的主体可以是以下类型之一：
- en: User
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 用户
- en: A user is a human or system authenticated by the API server, as described in
    [“Users”](#accesscontrol-users). User entries have a fixed `apiGroup` value of
    `rbac.authorization.k8s.io`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 用户是由 API 服务器认证的人或系统，如[“用户”](#accesscontrol-users)中所述。用户条目具有固定的 `apiGroup` 值为
    `rbac.authorization.k8s.io`。
- en: Group
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 组
- en: A group is a collection of users, as explained in [“Groups”](#accesscontrol-groups).
    As for users, the group entries carry a `rbac.authorization.k8s.io` as `apiGroup`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 组是用户的集合，如[“组”](#accesscontrol-groups)所解释的那样。对于用户，组条目带有 `rbac.authorization.k8s.io`
    作为 `apiGroup`。
- en: ServiceAccount
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ServiceAccount
- en: We discussed ServiceAccount in depth in [“Service accounts”](#accesscontrol-service-accounts).
    ServiceAccounts belong to the core API Group that is represented by an empty string
    (`""`). One unique aspect of ServiceAccounts is that it is the only subject type
    that can also carry a `namespace` field. This allows you to grant access to Pods
    from other namespaces.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[“Service accounts”](#accesscontrol-service-accounts)中深入讨论了ServiceAccount。ServiceAccounts
    属于核心 API 组，由空字符串 (`""`) 表示。ServiceAccounts 的一个独特之处在于它是唯一可以携带 `namespace` 字段的主体类型。这使您可以授予对其他命名空间中Pod的访问权限。
- en: '[Table 26-4](#table-accesscontrol-rb-subjects) summarizes the possible field
    values for entries in a RoleBinding’s `subject` list.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[表 26-4](#table-accesscontrol-rb-subjects) 总结了RoleBinding `subject` 列表条目的可能字段值。'
- en: Table 26-4\. Possible types for an element `subjects` list in a RoleBinding
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 表 26-4\. RoleBinding `subjects` 列表中元素的可能类型
- en: '| Kind | API Group | Namespace | Description |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | API 组 | 命名空间 | 描述 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| User | rbac.authorization.k8s.io | N/A | `name` is a reference to a user.
    |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| User | rbac.authorization.k8s.io | N/A | `name` 是对用户的引用。 |'
- en: '| Group | rbac.authorization.k8s.io | N/A | `name` is a reference to a group
    of users. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| Group | rbac.authorization.k8s.io | N/A | `name` 是用户组的引用。 |'
- en: '| ServiceAccount | “” | Optional | `name` is a reference to a ServiceAccount
    resource in the configured namespace. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| ServiceAccount | “” | Optional | `name` 是配置的命名空间中 ServiceAccount 资源的引用。 |'
- en: The other end of a RoleBinding points to a single Role. This Role can either
    be a Role resource within the same namespace as the RoleBinding or a ClusterRole
    resource shared across multiple bindings in the cluster. ClusterRoles are described
    in detail in [“ClusterRole”](#accesscontrol-clusterrole).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: RoleBinding 的另一端指向一个单独的 Role。这个 Role 可以是与 RoleBinding 相同命名空间内的 Role 资源，也可以是集群中多个绑定共享的
    ClusterRole 资源。ClusterRoles 的详细描述在 [“ClusterRole”](#accesscontrol-clusterrole)
    中。
- en: Similar to the subjects list, Role references are specified by `name`, `kind`,
    and `apiGroup`. [Table 26-5](#table-accesscontrol-rb-roleref) shows the possible
    values for the `roleRef` field.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于主体列表，Role 引用由 `name`、`kind` 和 `apiGroup` 指定。[Table 26-5](#table-accesscontrol-rb-roleref)
    展示了 `roleRef` 字段可能的值。
- en: Table 26-5\. Possible types for a `roleRef` field in a RoleBinding
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: Table 26-5\. RoleBinding 中 `roleRef` 字段的可能类型
- en: '| Kind | API Group | Description |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| Kind | API Group | Description |'
- en: '| --- | --- | --- |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Role | rbac.authorization.k8s.io | `name` is a reference to a Role in the
    same namespace. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| Role | rbac.authorization.k8s.io | `name` 是同一命名空间中 Role 的引用。 |'
- en: '| ClusterRole | rbac.authorization.k8s.io | `name` is a reference to cluster-wide
    ClusterRole. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| ClusterRole | rbac.authorization.k8s.io | `name` 是集群范围内 ClusterRole 的引用。
    |'
- en: ClusterRole
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ClusterRole
- en: 'ClusterRoles in Kubernetes are similar to regular Roles but are applied cluster-wide
    rather than to a specific namespace. They have two primary uses:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的 ClusterRoles 类似于常规 Roles，但是应用于整个集群而不是特定的命名空间。它们有两个主要用途：
- en: Securing cluster-wide resources such as CustomResourceDefinitions or StorageClasses.
    These resources are typically managed at the cluster-admin level and require additional
    access control. For example, developers may have read access to these resources
    but need help writing to them. ClusterRoleBindings are used to grant subjects
    access to cluster-wide resources.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护集群范围的资源，例如 CustomResourceDefinitions 或 StorageClasses。这些资源通常在集群管理员级别管理，并需要额外的访问控制。例如，开发人员可能对这些资源具有读取访问权限，但需要帮助编写访问权限。ClusterRoleBindings
    用于授予主体对集群范围资源的访问权限。
- en: Defining typical Roles that are shared across namespaces. As we saw in [“RoleBinding”](#accesscontrol-rolebinding),
    RoleBindings can refer only to Roles defined in the same namespace. ClusterRoles
    allow you to define general-access control Roles (e.g., “view” for read-only access
    to all resources) that can be used in multiple RoleBindings.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义跨命名空间共享的典型 Role。正如我们在 [“RoleBinding”](#accesscontrol-rolebinding) 中看到的，RoleBindings
    只能引用同一命名空间中定义的 Roles。ClusterRoles 允许您定义一般访问控制角色（例如，对所有资源的只读访问的 “view” 角色），这些角色可以在多个
    RoleBindings 中使用。
- en: '[Example 26-9](#ex-accesscontrol-clusterole) shows a ClusterRole that can be
    reused in multiple RoleBindings. It has the same schema as a Role except that
    it ignores any `.meta.namespace` field.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[Example 26-9](#ex-accesscontrol-clusterole) 展示了一个可以在多个 RoleBindings 中重复使用的
    ClusterRole。它与 Role 具有相同的模式，只是忽略了任何 `.meta.namespace` 字段。'
- en: Example 26-9\. ClusterRole
  id: totrans-214
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: Example 26-9\. ClusterRole
- en: '[PRE8]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[![1](assets/1.png)](#co_access_control_CO7-1)'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO7-1)'
- en: Name of the ClusterRole but no namespace declaration.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterRole 的名称，但没有命名空间声明。
- en: '[![2](assets/2.png)](#co_access_control_CO7-2)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO7-2)'
- en: Rule that allows reading operations on all Pods.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 允许对所有 Pods 进行读操作的规则。
- en: '[Figure 26-4](#img-accesscontrol-clusterrole) shows how a single ClusterRole
    can be shared across multiple RoleBindings in different namespaces. In this example,
    the ClusterRole allows the reading of Pods in the `dev-1` and `dev-2` namespaces
    by a ServiceAccount in the `test` namespace.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '[Figure 26-4](#img-accesscontrol-clusterrole) 展示了一个单一 ClusterRole 如何在不同命名空间的多个
    RoleBindings 中共享。在这个例子中，ClusterRole 允许 ServiceAccount 在 `test` 命名空间中读取 `dev-1`
    和 `dev-2` 命名空间中的 Pods。'
- en: '![Sharing ClusterRole in multiple namespaces](assets/kup2_2604.png)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![在多个命名空间中共享 ClusterRole](assets/kup2_2604.png)'
- en: Figure 26-4\. Sharing a ClusterRole in multiple namespaces
  id: totrans-222
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Figure 26-4\. 在多个命名空间中共享 ClusterRole
- en: Using a single ClusterRole in multiple RoleBindings allows you to create typical
    access-control schemes that can be easily reused. For example, [Table 26-6](#table-accesscontrol-clusterrole-default)
    includes a selection of useful user-facing ClusterRoles that Kubernetes provides
    out of the box. You can view the complete list of ClusterRoles available in a
    Kubernetes cluster using the `kubectl get clusterroles` command, or refer to the
    [Kubernetes documentation](https://oreil.ly/QklvQ) for a list of default ClusterRoles.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单个ClusterRole在多个RoleBindings中允许您创建可以轻松重复使用的典型访问控制方案。例如，[Table 26-6](#table-accesscontrol-clusterrole-default)
    包含Kubernetes默认提供的一些有用的面向用户的ClusterRoles的选择。您可以使用`kubectl get clusterroles`命令查看Kubernetes集群中可用的ClusterRoles的完整列表，或参考[Kubernetes文档](https://oreil.ly/QklvQ)获取默认ClusterRoles的列表。
- en: Table 26-6\. Standard user-facing ClusterRoles
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 表26-6. 标准用户界面ClusterRoles
- en: '| ClusterRole | Purpose |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| ClusterRole | 用途 |'
- en: '| --- | --- |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `view` | Allows reading for most resources in a namespace, except Role, RoleBinding,
    and Secret |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `view` | 允许在命名空间中大多数资源上进行读取，但不包括Role、RoleBinding和Secret |'
- en: '| `edit` | Allows reading and modifying most resources in a namespace, except
    Role and RoleBinding |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `edit` | 允许在命名空间中读取和修改大多数资源，但不包括Role和RoleBinding |'
- en: '| `admin` | Grants full control of all resources in a namespace, including
    Role and RoleBinding |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| `admin` | 授予对命名空间中所有资源的完全控制权限，包括Role和RoleBinding |'
- en: '| `cluster-admin` | Grants full control of all namespace resources, including
    cluster-wide resources |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| `cluster-admin` | 授予对所有命名空间资源的完全控制权限，包括整个集群范围的资源 |'
- en: Sometimes you may need to combine the permissions defined in two ClusterRoles.
    One way to do this is to create multiple RoleBindings that refer to both ClusterRoles.
    However, there is a more elegant way to achieve this using aggregation.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能需要结合两个ClusterRoles中定义的权限。一种方法是创建引用这两个ClusterRoles的多个RoleBinding。然而，还有一种更优雅的方法可以使用聚合来实现这一点。
- en: To use aggregation, you can define a ClusterRole with an empty `rules` field
    and a populated `aggregationRule` field containing a list of label selectors.
    Then, the rules defined by every other ClusterRole that has labels matching these
    selectors will be combined and used to populate the `rules` field of the aggregated
    ClusterRole.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用聚合功能，您可以定义一个具有空`rules`字段和填充的`aggregationRule`字段的ClusterRole，其中包含一组标签选择器。然后，每个其他具有匹配这些选择器的标签的ClusterRole定义的规则将被合并并用于填充聚合ClusterRole的`rules`字段。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: When you set the `aggregationRule` field, you are handing ownership of the `rules`
    field over to Kubernetes, which will fully manage it. Therefore, any manual changes
    to the rules field will be constantly overwritten with the aggregated rules from
    the selected ClusterRoles in the `aggregationRule`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当您设置`aggregationRule`字段时，您正在将`rules`字段的所有权交给Kubernetes，Kubernetes将完全管理它。因此，对规则字段的任何手动更改都将被聚合ClusterRole中选择的ClusterRoles的聚合规则不断覆盖。
- en: This aggregation technique allows you to dynamically and elegantly build up
    large rule sets by combining smaller, more focused ClusterRoles.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此聚合技术允许您通过组合更小、更专注的ClusterRoles来动态且优雅地构建大型规则集。
- en: '[Example 26-10](#ex-accesscontrol-clusterrole-aggregation) shows how the default
    `view` role uses aggregation to pick up more specific ClusterRoles labeled with
    `rbac.authorization.k8s.io/aggregate-to-view`. The `view` role itself also has
    the label `rbac.authorization.k8s.io/aggregate-to-edit`, which is used by the
    `edit` role to include the aggregated rules from the `view` ClusterRole.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 示例26-10（#ex-accesscontrol-clusterrole-aggregation）显示了默认的`view`角色如何使用聚合来获取带有`rbac.authorization.k8s.io/aggregate-to-view`标签的更具体的ClusterRoles。`view`角色本身还具有`rbac.authorization.k8s.io/aggregate-to-edit`标签，该标签由`edit`角色使用，以包含来自`view`ClusterRole的聚合规则。
- en: Example 26-10\. Aggregated ClusterRole
  id: totrans-237
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例26-10. 聚合ClusterRole
- en: '[PRE9]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[![1](assets/1.png)](#co_access_control_CO8-1)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO8-1)'
- en: This label exposes the ClusterRole as eligible for inclusion in the `edit` role.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 此标签将ClusterRole公开为符合包含在`edit`角色中的资格。
- en: '[![2](assets/2.png)](#co_access_control_CO8-2)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO8-2)'
- en: All ClusterRoles that match this selector will be picked up for the `view` ClusterRole.
    Note that this ClusterRole declaration does not need to be changed if you want
    to add additional permissions to the `view` ClusterRole—you can create a new ClusterRole
    with the appropriate label.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 所有匹配此选择器的ClusterRoles将被选中用于`view`ClusterRole。请注意，如果您希望向`view`ClusterRole添加额外权限，则无需更改此ClusterRole声明—您可以创建具有适当标签的新ClusterRole。
- en: '[![3](assets/3.png)](#co_access_control_CO8-3)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](assets/3.png)](#co_access_control_CO8-3)'
- en: The `rules` field will be managed by Kubernetes and populated with the aggregated
    rules.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`rules` 字段将由 Kubernetes 管理，并填充聚合规则。'
- en: This technique allows you to quickly compose more specialized ClusterRoles by
    aggregating a set of basic ClusterRoles. [Example 26-10](#ex-accesscontrol-clusterrole-aggregation)
    also demonstrates how aggregation can be nested to build an inheritance chain
    of permission rule sets.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 此技术允许您通过聚合一组基本的 ClusterRoles 快速组合更专业化的 ClusterRoles。[示例26-10](#ex-accesscontrol-clusterrole-aggregation)
    还演示了如何嵌套聚合以构建权限规则集的继承链。
- en: Since all of the user-facing default ClusterRoles use this aggregation technique,
    you can quickly hook into the permission model of custom resources (as described
    in [Chapter 28, “Operator”](ch28.html#Operator)) by simply adding the aggregation-triggering
    labels of the standard ClusterRoles (e.g., `view`, `edit`, and `admin`).
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有用户界面的默认 ClusterRoles 使用了这种聚合技术，您可以通过简单地添加标准 ClusterRoles 的聚合触发标签（例如 `view`、`edit`
    和 `admin`）来快速接入自定义资源的权限模型（如 [第28章，“操作员”](ch28.html#Operator) 中描述的）。
- en: Now that we’ve covered the creation of a flexible and reusable permission model
    using ClusterRoles and RoleBindings, the final piece of the puzzle is establishing
    cluster-wide access rules with ClusterRoleBindings.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了如何使用 ClusterRoles 和 RoleBindings 创建灵活和可重用的权限模型，那么谜题的最后一块是使用 ClusterRoleBindings
    建立集群范围的访问规则。
- en: ClusterRoleBinding
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ClusterRoleBinding
- en: The schema for a ClusterRoleBinding is similar to that of a RoleBinding, except
    that it ignores the `namespace` field. The rules defined in a ClusterRoleBinding
    apply to all namespaces in the cluster.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterRoleBinding 的模式与 RoleBinding 的模式类似，但它忽略了 `namespace` 字段。在 ClusterRoleBinding
    中定义的规则适用于集群中的所有命名空间。
- en: '[Example 26-11](#ex-accesscontrol-clusterrolebinding-all-namespaces) shows
    a ClusterRoleBinding that connects a ServiceAccount `test-sa` with the ClusterRole
    `view-pod` defined in [Example 26-9](#ex-accesscontrol-clusterole).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[示例26-11](#ex-accesscontrol-clusterrolebinding-all-namespaces) 显示了一个将 ServiceAccount
    `test-sa` 与在 [示例26-9](#ex-accesscontrol-clusterole) 中定义的 ClusterRole `view-pod`
    连接起来的 ClusterRoleBinding。'
- en: Example 26-11\. ClusterRoleBinding
  id: totrans-251
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
  zh: 示例26-11\. ClusterRoleBinding
- en: '[PRE10]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[![1](assets/1.png)](#co_access_control_CO9-1)'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](assets/1.png)](#co_access_control_CO9-1)'
- en: Connects ServiceAccount `test-sa` from the `test` namespace.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 连接来自 `test` 命名空间的 ServiceAccount `test-sa`。
- en: '[![2](assets/2.png)](#co_access_control_CO9-2)'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](assets/2.png)](#co_access_control_CO9-2)'
- en: Allows the rules from the ClusterRole `view-pod` for every namespace.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 允许每个命名空间使用 ClusterRole `view-pod` 的规则。
- en: The rules defined in the ClusterRole `view-pod` apply to all namespaces in the
    cluster so that any Pod associated with the ServiceAccount `test-sa` can read
    all Pods in every namespace, which is illustrated in [Figure 26-5](#img-accesscontrol-clusterrolebinding).
    However, it is crucial to use ClusterRoleBindings with caution, as they grant
    wide-ranging permissions across the entire cluster. Therefore, it is recommended
    that you carefully consider whether using a ClusterRoleBinding is necessary.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ClusterRole `view-pod` 中定义的规则适用于集群中的所有命名空间，因此与 ServiceAccount `test-sa` 关联的任何
    Pod 都可以读取每个命名空间中的所有 Pods，如 [图26-5](#img-accesscontrol-clusterrolebinding) 所示。然而，使用
    ClusterRoleBindings 需要谨慎，因为它们在整个集群范围内授予了广泛的权限。因此，建议您仔细考虑是否需要使用 ClusterRoleBinding。
- en: Using a ClusterRoleBinding may be convenient as it automatically grants permissions
    to newly created namespaces. However, using individual RoleBindings per namespace
    is generally better for more granular control over permissions. This extra effort
    allows you to omit specific namespaces, such as `kube-system`, from unauthorized
    access.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 ClusterRoleBinding 可能很方便，因为它会自动向新创建的命名空间授予权限。然而，通常更好地使用每个命名空间的单独 RoleBindings
    可以更精细地控制权限。这额外的工作允许您省略特定命名空间（例如 `kube-system`）的未经授权访问。
- en: '![ClusterRoleBinding for reading all Pods](assets/kup2_2605.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![用于读取所有 Pods 的 ClusterRoleBinding](assets/kup2_2605.png)'
- en: Figure 26-5\. ClusterRoleBinding for reading all Pods
  id: totrans-260
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图26-5\. 用于读取所有 Pods 的 ClusterRoleBinding
- en: ClusterRoleBindings should be used only for administrative tasks, such as managing
    cluster-wide resources like Nodes, Namespaces, CustomResourceDefinitions, or even
    ClusterRoleBindings.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: ClusterRoleBindings 应仅用于管理集群范围的资源，如节点、命名空间、自定义资源定义或甚至 ClusterRoleBindings。
- en: These final warnings conclude our tour through the world of Kubernetes RBAC.
    This machinery is mighty, but it’s also complex to understand and sometimes even
    more complicated to debug. The following sidebar gives you some tips for better
    understanding a given RBAC setup.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 这些最终警告结束了我们对 Kubernetes RBAC 世界的探索之旅。这个机制很强大，但理解它有时也很复杂，甚至更难调试。下面的边栏给出了一些帮助您更好理解给定
    RBAC 设置的提示。
- en: The final section will discuss some general tips for properly using Kubernetes
    RBAC.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一节将讨论一些关于正确使用 Kubernetes RBAC 的通用提示。
- en: Discussion
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 讨论
- en: 'Kubernetes RBAC is a powerful tool for controlling access to API resources.
    However, it can be challenging to understand which definition objects to use and
    how to combine them to fit a particular security setup. Here are some guidelines
    to help you navigate these decisions:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes RBAC 是控制访问 API 资源的强大工具。然而，了解要使用哪些定义对象以及如何组合它们以适应特定的安全设置可能是具有挑战性的。以下是一些指导方针，帮助您在这些决策中导航：
- en: If you want to secure resources in a specific namespace, use a Role with a RoleBinding
    that connects to a user or ServiceAccount. The ServiceAccount does not have to
    be in the same namespace, allowing you to grant access to Pods from other namespaces.
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要保护特定命名空间中的资源，请使用具有与用户或 ServiceAccount 连接的 RoleBinding 的 Role。ServiceAccount
    不必在同一命名空间中，这允许您授予来自其他命名空间的 Pods 的访问权限。
- en: If you want to reuse the same access rules in multiple namespaces, use a RoleBinding
    with a ClusterRole that defines these shared-access rules.
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要在多个命名空间中重用相同的访问规则，请使用具有定义这些共享访问规则的 ClusterRole 的 RoleBinding。
- en: If you want to extend one or more existing predefined ClusterRoles, create a
    new ClusterRole with an `aggregationRule` field that refers to the ClusterRoles
    you wish to extend, and add your permissions to the `rules` field.
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要扩展一个或多个现有的预定义 ClusterRoles，请创建一个新的 ClusterRole，并在其中添加一个 `aggregationRule`
    字段，该字段引用您希望扩展的 ClusterRoles，并将权限添加到 `rules` 字段中。
- en: If you want to grant a user or ServiceAccount access to all resources of a specific
    kind in all namespaces, use a ClusterRole and a ClusterRoleBinding.
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要授予用户或 ServiceAccount 访问所有命名空间中特定类型的所有资源，请使用 ClusterRole 和 ClusterRoleBinding。
- en: If you want to manage access to a cluster-wide resource like a CustomResourceDefinition,
    use a ClusterRole and a ClusterRoleBinding.
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果要管理对集群范围资源（如 CustomResourceDefinition）的访问权限，请使用 ClusterRole 和 ClusterRoleBinding。
- en: 'We have seen how RBAC allows us to define fine-grained permissions and manage
    them. It can reduce risk by ensuring the applied permission does not leave gaps
    for the escalation path. On the other hand, defining any broad open permissions
    can lead to security escalations. Let’s close this chapter with a summary of some
    general RBAC advice:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了如何使用 RBAC 定义细粒度权限并对其进行管理。它可以通过确保应用的权限不留下升级路径的空白来降低风险。另一方面，定义任何广泛开放的权限可能会导致安全升级。让我们通过总结一些通用的
    RBAC 建议来结束这一章节：
- en: Avoid wildcard permissions
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用通配符权限。
- en: We recommend following the principle of least privilege when composing the fine-grained
    access control in the Kubernetes cluster. To avoid unintentional operations, avoid
    wildcard permissions when defining the Role and ClusterRoles. For rare occasions,
    it might make sense to use wildcards (i.e., to secure all resources of an API
    group), but it is a good practice to establish a general “no wildcard” policy
    that could be relaxed for well-reasoned exceptions.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议在组成 Kubernetes 集群中的细粒度访问控制时遵循最小特权原则。为了避免意外操作，在定义 Role 和 ClusterRoles 时避免使用通配符权限。在极少数情况下，使用通配符可能是有道理的（即，为了保护
    API 组的所有资源），但建立一个通常的“无通配符”策略，并为合理的例外情况放宽限制是一个良好的做法。
- en: Avoid `cluster-admin` ClusterRole
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `cluster-admin` ClusterRole。
- en: ServiceAccounts with high privileges can allow you to perform actions over any
    resources, like modifying permissions or viewing secrets in any namespace, which
    can lead to severe security implications. Therefore, never assign the `cluster-admin`
    ClusterRole to a Pod. Never.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有高权限的 ServiceAccounts 可以让您在任何资源上执行操作，比如修改权限或查看任何命名空间中的 secrets，这可能会导致严重的安全问题。因此，永远不要将
    `cluster-admin` ClusterRole 分配给 Pod。绝对不要。
- en: Don’t automount ServiceAccount tokens
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 不要自动挂载 ServiceAccount 令牌。
- en: By default, tokens of ServiceAccounts are mounted within a container’s filesystem
    at */var/run/secrets/kubernetes.io/serviceaccount/token*. If such a Pod gets compromised,
    any attacker can talk with the API server with the permissions of the Pod’s associated
    ServiceAccount. However, many applications don’t need that token for business
    operations. For such a use case, avoid the token mount by setting the ServiceAccount’s
    field `automountServiceAccountToken` to `false`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，ServiceAccount 的令牌被挂载到容器的文件系统中，路径为 */var/run/secrets/kubernetes.io/serviceaccount/token*。如果这样的
    Pod 被 compromise，任何攻击者都可以使用 Pod 关联的 ServiceAccount 的权限与 API 服务器通信。然而，许多应用程序在业务运作中并不需要该令牌。对于这种情况，可以通过将
    ServiceAccount 的字段 `automountServiceAccountToken` 设置为 `false` 来避免挂载令牌。
- en: Kubernetes RBAC is a flexible and powerful method for controlling access to
    the Kubernetes API. Therefore, even if your application is not directly interacting
    with the API Server to install your application and connect it to other Kubernetes
    servers, *Access Control* is a valuable pattern to secure the operation of your
    application.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的 RBAC 是一种灵活且强大的方法，用于控制对 Kubernetes API 的访问。因此，即使您的应用程序不直接与 API Server
    交互来安装应用程序并将其连接到其他 Kubernetes 服务器，*访问控制* 也是一种保护应用程序操作的有价值模式。
- en: More Information
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多信息
- en: '[Access Control Example](https://oreil.ly/GyIlq)'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[访问控制示例](https://oreil.ly/GyIlq)'
- en: '[Escalation Paths](https://oreil.ly/HHT3G)'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[升级路径](https://oreil.ly/HHT3G)'
- en: '[Controlling Access to the Kubernetes API](https://oreil.ly/BtTB9)'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[控制对 Kubernetes API 的访问](https://oreil.ly/BtTB9)'
- en: '[Auditing](https://oreil.ly/XgzNL)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[审计](https://oreil.ly/XgzNL)'
- en: '[Admission Controllers Reference](https://oreil.ly/QSqW8)'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[准入控制器参考](https://oreil.ly/QSqW8)'
- en: '[Dynamic Admission Control](https://oreil.ly/7oCSg)'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[动态准入控制](https://oreil.ly/7oCSg)'
- en: '[Kubernetes: Authentication Strategies](https://oreil.ly/hSISq)'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes：认证策略](https://oreil.ly/hSISq)'
- en: '[RBAC Good Practices](https://oreil.ly/h7XHg)'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RBAC 良好实践](https://oreil.ly/h7XHg)'
- en: '[Workload Creation](https://oreil.ly/uC307)'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[工作负载创建](https://oreil.ly/uC307)'
- en: '[Bound Service Account Tokens](https://oreil.ly/bJVhD)'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[绑定的 Service Account 令牌](https://oreil.ly/bJVhD)'
- en: '[BIG Change in K8s 1.24 About ServiceAccounts and Their Secrets](https://oreil.ly/T22fJ)'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[K8s 1.24 关于 ServiceAccount 及其密钥的重大变更](https://oreil.ly/T22fJ)'
- en: '[Efficient Detection of Changes](https://oreil.ly/RdlPi)'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[高效的变更检测](https://oreil.ly/RdlPi)'
- en: '[Add ImagePullSecrets to a Service Account](https://oreil.ly/jVXQN)'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[向 Service Account 添加 ImagePullSecrets](https://oreil.ly/jVXQN)'
- en: '[RBAC Dev](https://rbac.dev)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[RBAC Dev](https://rbac.dev)'
- en: '[Rakkess](https://oreil.ly/fE1I_)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Rakkess](https://oreil.ly/fE1I_)'
- en: '[How the Basics of Kubernetes Auth Scale for Organizations](https://oreil.ly/nAFu2)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes 认证基础的组织规模化基础](https://oreil.ly/nAFu2)'
- en: '[Kubernetes CVE-2020-8559 Proof of Concept PoC Exploit](https://oreil.ly/BC6aO)'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[Kubernetes CVE-2020-8559 漏洞验证 PoC 攻击](https://oreil.ly/BC6aO)'
- en: '[OAuth Is Not Authentication](https://oreil.ly/UVz7Y)'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[OAuth 不是认证](https://oreil.ly/UVz7Y)'
- en: ^([1](ch26.html#idm45902085697664-marker)) See the blog post [“Exposed Kubernetes
    Clusters”](https://oreil.ly/uGzr_).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: ^([1](ch26.html#idm45902085697664-marker)) 详见博文 [“暴露的 Kubernetes 集群”](https://oreil.ly/uGzr_).
- en: ^([2](ch26.html#idm45902085687920-marker)) An [attacker with escalated privileges](https://oreil.ly/h1YGJ)
    on a node can compromise a full Kubernetes cluster.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: ^([2](ch26.html#idm45902085687920-marker)) 在节点上具有升级权限的攻击者可以 compromise 整个 Kubernetes
    集群。
