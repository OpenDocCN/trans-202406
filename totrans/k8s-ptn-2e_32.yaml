- en: Chapter 26\. Access Control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As the world becomes increasingly reliant on cloud infrastructure and containerization,
    the importance of security can never be understated. In 2022, security researchers
    made a troubling discovery: nearly one million Kubernetes instances were left
    exposed on the internet due to misconfigurations.^([1](ch26.html#idm45902085697664))
    Using specialized security scanners, researchers were able to easily access these
    vulnerable nodes, highlighting the need for stringent access-control measures
    to protect the Kubernetes control plane. But while developers often focus on application-level
    authorization, they sometimes also need to extend Kubernetes capabilities using
    the *Operator* pattern from [Chapter 28](ch28.html#Operator). In these cases,
    access control on the Kubernetes platform becomes critical. In this chapter, we
    delve into the *Access Control* pattern and explore the concepts of Kubernetes
    authorization. With the potential risks and consequences at stake, it’s never
    been more important to ensure the security of your Kubernetes deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Security is a crucial concern when it comes to operating applications. At the
    core of security are two essential concepts: authentication and authorization.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Authentication* focuses on identifying the subject, or *who*, of an operation
    and preventing access by unauthorized actors. *Authorization*, on the other hand,
    involves determining the permissions for *what* actions are allowed on resources.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss authentication briefly, as it is primarily
    an administrative concern that involves integrating various identity-management
    techniques with Kubernetes. On the other hand, developers are typically more concerned
    with authorization, such as who can perform which operations in the cluster and
    access specific parts of an application.
  prefs: []
  type: TYPE_NORMAL
- en: To secure access to their applications running on top of Kubernetes, developers
    must consider a range of security strategies, from simple web-based authentication
    to sophisticated single-sign-on scenarios involving external providers for identity
    and access management. At the same time, access control to the Kubernetes API
    server is also an essential concern for applications running on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Misconfigured access can lead to privilege escalation and deployment failures.
    High-privilege deployments can access or modify configuration and resources for
    other deployments, increasing the risk of a cluster compromise.^([2](ch26.html#idm45902085687920))
    It is important for developers to understand the authorization rules set up by
    administrators and consider security when making configuration changes and deploying
    new workloads to meet the organization-wide policies in the Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, as more and more Kubernetes-native applications extend the Kubernetes
    API and offer their services via CustomResourceDefinitions (CRDs) to users, as
    described in [“Controller and Operator Classification”](ch28.html#operator-classification),
    access control becomes even more critical. Kubernetes patterns like [Chapter 27,
    “Controller”](ch27.html#Controller), and [Chapter 28, “Operator”](ch28.html#Operator),
    require high privileges to observe the state of cluster-wide resources, making
    it crucial to have fine-grained access management and restrictions in place to
    limit the impact of any potential security breaches.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every request to the Kubernetes API server has to pass through three stages—Authentication,
    Authorization, and Admission Control, as shown in [Figure 26-1](#img-accesscontrol-auth-acc-ad).
  prefs: []
  type: TYPE_NORMAL
- en: '![Stages that need to be passed by a request to the Kubernetes API server](assets/kup2_2601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-1\. A request to the Kubernetes API server must pass through these
    stages
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Once a request passes the Authentication and Authorization stages described
    in the following sections, a final check is done by Admission controllers before
    the request is eventually processed. Let’s look at these stages separately.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, we won’t go into too much detail about authentication because
    it is mainly an administration concern. But it’s good to know which options are
    available, so let’s have a look at the pluggable authentication strategies Kubernetes
    has to offer that an administrator can configure:'
  prefs: []
  type: TYPE_NORMAL
- en: Bearer Tokens (OpenID Connect) with OIDC Authenticators
  prefs: []
  type: TYPE_NORMAL
- en: OpenID Connect (OIDC) Bearer Tokens can authenticate clients and grant access
    to the API Server. OIDC is a standard protocol that allows clients to authenticate
    with an OAuth2 provider that supports OIDC. The client sends the OIDC token in
    the Authorization header of their request, and the API Server validates the token
    to allow access. For the entire flow, see the Kubernetes documentation at [OpenID
    Connect Tokens](https://oreil.ly/ZWXVD).
  prefs: []
  type: TYPE_NORMAL
- en: Client certificates (X.509)
  prefs: []
  type: TYPE_NORMAL
- en: By using client certificates, the client presents a TLS certificate to the API
    Server, which is then validated and used to grant access.
  prefs: []
  type: TYPE_NORMAL
- en: Authenticating Proxy
  prefs: []
  type: TYPE_NORMAL
- en: This configuration option refers to using a custom authenticating proxy to verify
    the client’s identity before granting access to the API Server. The proxy acts
    as an intermediary between the client and the API Server and performs authentication
    and authorization checks before allowing access.
  prefs: []
  type: TYPE_NORMAL
- en: Static Token files
  prefs: []
  type: TYPE_NORMAL
- en: Tokens can also be stored in standard files and used for authentication. In
    this approach, the client presents a token to the API Server, which is then used
    to look up the token file and search for a match.
  prefs: []
  type: TYPE_NORMAL
- en: Webhook Token Authentication
  prefs: []
  type: TYPE_NORMAL
- en: A webhook can authenticate clients and grant access to the API Server. In this
    approach, the client sends a token in the Authorization header of their request,
    and the API Server forwards the token to a configured webhook for validation.
    The client is granted access to the API Server if the webhook returns a valid
    response. This technique is similar to the Bearer Token option, except that you
    can use an external custom service for performing the token validation.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes allows you to use multiple authentication plugins simultaneously,
    such as Bearer Tokens and Client certificates. If the Bearer Token strategy authenticates
    a request, Kubernetes won’t check the Client certificates, and vice versa. Unfortunately,
    the order in which these strategies are evaluated is not fixed, so it’s impossible
    to know which one will be checked first. When evaluating the strategies, the process
    will stop after one is successful, and Kubernetes will forward the request to
    the next stage.
  prefs: []
  type: TYPE_NORMAL
- en: After authentication, the authorization process will begin.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes provides RBAC as a standard way to manage access to the system. RBAC
    allows developers to control and execute actions in a fine-grained manner. The
    authorization plugin in Kubernetes also provides easy pluggability, allowing users
    to switch between the default RBAC and other models, such as attribute-based access
    control (ABAC), webhooks, or delegation to a custom authority.
  prefs: []
  type: TYPE_NORMAL
- en: The [ABAC-based approach](https://oreil.ly/xNBK8) requires a file containing
    policies in a JSON per-line format. However, this approach requires the server
    to be reloaded for any changes, which can be a disadvantage. This static nature
    is one of the reasons ABAC-based authorization is used only in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, nearly every Kubernetes cluster uses the default RBAC-based access
    control, which we describe in great detail in [“Role-Based Access Control”](#accesscontrol-rbac).
  prefs: []
  type: TYPE_NORMAL
- en: Before we focus on authorization in the rest of this chapter, let’s quickly
    look at the last stage performed by admission controllers.
  prefs: []
  type: TYPE_NORMAL
- en: Admission Controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Admission controllers are a feature of the Kubernetes API server that allows
    you to intercept requests to the API server and take additional actions based
    on those requests. For example, you can use them to enforce policies, perform
    validations, and modify incoming resources.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes uses Admission controller plugins for implementing various functions.
    The functionality ranges from setting default values on specific resources (like
    the default storage class on persistent volumes), to validations (like the allowed
    resource limits for Pods), by calling external web hooks.
  prefs: []
  type: TYPE_NORMAL
- en: These external webhooks can be configured with dedicated resources and are used
    for validation (ValidatingWebhookConfiguration) and updating (MutatingWebhookConfiguration)
    API resources. The details of configuring such webhooks are explained in detail
    in the Kubernetes documentation [“Dynamic Admission Control”](https://oreil.ly/JEBu6).
  prefs: []
  type: TYPE_NORMAL
- en: We won’t go into more detail here as Admission controllers are mostly an administrative
    concept, and many other good resources describe Admission controllers in particular
    (see [“More Information”](#accesscontrol-more-information) for some references).
  prefs: []
  type: TYPE_NORMAL
- en: Instead, for the remainder of the chapter, we will focus on the authorization
    aspect and how we can configure a fine-grained permission model for securing access
    to the Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, authentication has two fundamental parts and authorization: the
    *who*, represented by a subject that can be either a human person or a workload
    identity, and the *what*, representing the actions those subjects can trigger
    at the Kubernetes API server. In the next section, we discuss the who before diving
    into the details of the *what*.'
  prefs: []
  type: TYPE_NORMAL
- en: Subject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *subject* is all about the *who*, the identity associated with a request
    to the Kubernetes API server. In Kubernetes, there are two kinds of subjects,
    as shown in [Figure 26-2](#img-accesscontrol-subject): human *users* and *service
    accounts* that represent the workload identity of Pods.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Subject requests to API Server](assets/kup2_2602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-2\. Subject (user or service account) requests to API Server
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Human users and ServiceAccounts can be separately grouped in *user groups* and
    *service account groups*, respectively. Those groups can act as a single subject
    in which all members of the group share the same permission model. We will talk
    about groups later in this chapter, but first, let’s look closely at how human
    users are represented in the Kubernetes API.
  prefs: []
  type: TYPE_NORMAL
- en: Users
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike many other entities in Kubernetes, human users are not defined as explicit
    resources in the Kubernetes API. This design decision implies that you can’t manage
    users via an API call. The authentication and mapping to a user subject happens
    outside the usual Kubernetes API machinery by external user management.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, Kubernetes supports many ways of authenticating an external
    user. Each component knows how to extract the subject information after successful
    authentication. Although this mechanism is different for each authentication component,
    they will eventually create the same user representation and add it to the actual
    API request to verify by later stages, as shown in [Example 26-1](#ex-access-control-uid).
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-1\. Representation of an external user after successful authentication
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This comma-separated list is a representation of the user and contains the
    following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The username (`alice`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique user id (UID) (`4bc01e30-406b-4514`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of groups that this user belongs to (`system:authenticated,developers`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional information as comma-separated key-value pairs (`scopes:openid`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This information is evaluated by the Authorization plugin against the authorization
    rules associated with the user or via its membership to a user group. In [Example 26-1](#ex-access-control-uid),
    a user with the username `alice` has the default access associated with the group
    `system:authenticated` and the group `developers`. The extra information `scope:openid`
    indicates OIDC is being used to verify the user’s identity.
  prefs: []
  type: TYPE_NORMAL
- en: Certain usernames are reserved for internal Kubernetes use and are distinguished
    by the special prefix `system:`. For example, the username `system:anonymous`
    represents anonymous requests to the Kubernetes API server. It is recommended
    to avoid creating your own users or groups with the `system:` prefix to avoid
    conflicts. [Table 26-1](#table-accesscontrol-default-users) lists the default
    usernames in Kubernetes that are used when internal Kubernetes components communicate
    to one another.
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-1\. Default usernames in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: '| Username | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `system:anonymous` | Represents anonymous requests to the Kubernetes API
    server |'
  prefs: []
  type: TYPE_TB
- en: '| `system:apiserver` | Represents the API server itself |'
  prefs: []
  type: TYPE_TB
- en: '| `system:kube-proxy` | Represents process identity of the kube-proxy service
    |'
  prefs: []
  type: TYPE_TB
- en: '| `system:kube-controller-manager` | Represents the user agent of the controller
    manager |'
  prefs: []
  type: TYPE_TB
- en: '| `system:kube-scheduler` | Represents the user of the scheduler |'
  prefs: []
  type: TYPE_TB
- en: While the management and authentication of external users can vary depending
    on the specific setup of a Kubernetes cluster, the management of workload identities
    for Pods is a standardized part of the Kubernetes API and is consistent across
    all clusters.
  prefs: []
  type: TYPE_NORMAL
- en: Service accounts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Service accounts in Kubernetes represent nonhuman actors within the cluster
    and are used as workload identities. They are associated with Pods and allow running
    processes inside a Pod to communicate with the Kubernetes API Server. In contrast
    to the many ways that Kubernetes can authenticate human users, service accounts
    always use an [OpenID Connect handshake](https://oreil.ly/0fhR8) and JSON Web
    Tokens to prove their identity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service accounts in Kubernetes are authenticated by the API server using a
    username in the following format: `system:serviceaccount:<namespace>:<name>`.
    For example, if you have a service account, `random-sa`, in the `default` namespace,
    the service account’s username would be `system:serviceaccount:default:random-sa`.'
  prefs: []
  type: TYPE_NORMAL
- en: A ServiceAccount is a standard Kubernetes resource, as shown in [Example 26-2](#ex-accesscontrol-yaml-sa).
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-2\. ServiceAccount definition
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the service account.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Flag indicating whether the service account token should be mounted by default
    into a Pod. The default is set to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: A ServiceAccount has a simple structure and serves all identity-related information
    needed for a Pod when talking with the Kubernetes API server. Every namespace
    has a default ServiceAccount with the name `default` used to identify any Pod
    that does not define an associated ServiceAccount.
  prefs: []
  type: TYPE_NORMAL
- en: Each ServiceAccount has a JWT associated with it that is fully managed by the
    Kubernetes backend. A Pod’s associated ServiceAccount’s token is automatically
    mounted into the filesystem of each Pod. [Example 26-3](#ex-accesscontrol-pod-spec)
    shows the relevant part of a Pod specification that Kubernetes has automatically
    added for every Pod created.
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-3\. ServiceAccount token mounted as a file for a Pod
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '`serviceAccountName` to set the name of the service account (`serviceAccount`
    is a deprecated alias for `serviceAccountName`).'
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '*/var/run/secrets/kubernetes.io/serviceaccount* is the directory under which
    the service account token is mounted.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_access_control_CO2-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes assigns a random Pod-unique name to the auto-generated volume.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_access_control_CO2-4)'
  prefs: []
  type: TYPE_NORMAL
- en: A projected volume injects the ServiceAccount token directly into the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_access_control_CO2-5)'
  prefs: []
  type: TYPE_NORMAL
- en: Expiration time of the token in seconds. After this time, the token expires,
    and the mounted token file is updated with a new token.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_access_control_CO2-6)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the file that will contain the token.
  prefs: []
  type: TYPE_NORMAL
- en: To view the mounted token, we can execute a `cat` on the mounted file in the
    running Pod, as shown in [Example 26-4](#ex-accesscontrol-cat-token).
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-4\. Print out the service account JWT (output is shortened)
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In [Example 26-3](#ex-accesscontrol-pod-spec), the token is mounted into the
    Pod as a projected volume. Projected volumes allow you to merge multiple volume
    sources, such as Secret and ConfigMap volumes (described in [Chapter 20, “Configuration
    Resource”](ch20.html#ConfigurationResource)), into a single directory. With this
    volume type, the ServiceAccount token can also be directly mapped into the Pod’s
    filesystem using a `serviceAccountToken` subtype. This method has several benefits,
    including reducing the attack surface by eliminating the need for an intermediate
    representation of the token and by providing the ability to set an expiration
    time for the token, which the Kubernetes token controller will rotate after it
    expires. Furthermore, the token injected into the Pod will be valid only for the
    duration of the Pod’s existence, further reducing the risk of unauthorized inspection
    of the service account’s token.
  prefs: []
  type: TYPE_NORMAL
- en: Before Kubernetes 1.24, Secrets were used to represent these tokens and were
    mounted directly with a `secret` volume type, which had the disadvantage of long
    lifetimes and lack of rotation. Thanks to the new projected volume type, the token
    is available only to the Pod and is not exposed as an additional resource, which
    reduces the attack surface. You can still create a Secret manually to contain
    a ServiceAccount’s token, as demonstrated in [Example 26-5](#ex-accesscontrol-token-secret).
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-5\. Create a Secret for ServiceAccount `random-sa`
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Special type to indicate that this Secret is about holding a ServiceAccount.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to ServiceAccount, whose token should be added.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes will fill in the token and the public key for validation into the
    secret. Also, the lifecycle of this Secret is now bound to the ServiceAccount
    itself. If you delete the ServiceAccount, Kubernetes will also delete this secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ServiceAccount resource has two additional fields for specifying credentials
    for pulling container images and defining the secrets allowed to be mounted:'
  prefs: []
  type: TYPE_NORMAL
- en: Image pull secrets
  prefs: []
  type: TYPE_NORMAL
- en: Image pull secrets allow a workload to authenticate with a private registry
    when pulling images. Typically, you would need to manually specify the pull secrets
    as part of the Pod specification in the fields `.spec.imagePullSecrets`. However,
    Kubernetes provides a shortcut by allowing you to attach a pull secret directly
    to a ServiceAccount in the top-level field `imagePullSecrets`. Every Pod associated
    with the ServiceAccount will automatically have the pull secrets injected into
    its specification when it is created. This automation eliminates the need to manually
    include the image pull secrets in the Pod specification every time a new Pod is
    created in the namespace, reducing the manual effort required.
  prefs: []
  type: TYPE_NORMAL
- en: Mountable secrets
  prefs: []
  type: TYPE_NORMAL
- en: The `secrets` field in the ServiceAccount resource allows you to specify which
    secrets a Pod associated with the ServiceAccount can mount. You can enable this
    restriction by adding the `kubernetes.io/enforce-mountable-secrets` annotation
    to the ServiceAccount. If this annotation is set to `true`, only the Secrets listed
    will be allowed to be mounted by Pods associated with the ServiceAccount.
  prefs: []
  type: TYPE_NORMAL
- en: Groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Both user and service accounts in Kubernetes can belong to one or more groups.
    Groups are attached to requests by the authentication system and are used to grant
    permissions to all group members. As seen in [Example 26-1](#ex-access-control-uid),
    group names are plain strings that represent the group name.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, groups can be freely defined and managed by the identity
    provider to create groups of subjects with the same permission model. A set of
    predefined groups in Kubernetes are also implicitly defined and have a `system:`
    prefix in their name. These predefined groups are listed in [Table 26-2](#table-accesscontrol-default-groups).
  prefs: []
  type: TYPE_NORMAL
- en: We will see how group names can be used in a RoleBinding to grant permissions
    to all group members in [“RoleBinding”](#accesscontrol-rolebinding).
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-2\. System groups in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: '| Group | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `system:unauthenticated` | Group assigned to every unauthenticated request
    |'
  prefs: []
  type: TYPE_TB
- en: '| `system:authenticated` | Group assigned to an authenticated user |'
  prefs: []
  type: TYPE_TB
- en: '| `system:masters` | Group whose members have unrestricted access to the Kubernetes
    API server |'
  prefs: []
  type: TYPE_TB
- en: '| `system:serviceaccounts` | Group with all ServiceAccounts of the cluster
    |'
  prefs: []
  type: TYPE_TB
- en: '| `system:serviceaccounts:<namespace>` | Group with all ServiceAccounts of
    this namespace |'
  prefs: []
  type: TYPE_TB
- en: Now that you have a clear understanding of users, ServiceAccounts, and groups,
    let’s examine how these subjects can be associated with Roles that define the
    actions they are allowed to perform against the Kubernetes API server.
  prefs: []
  type: TYPE_NORMAL
- en: Role-Based Access Control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, Roles define the specific actions that a subject can perform
    on particular resources. You can then assign these Roles to subjects, such as
    users or service accounts, as described in [“Subject”](#accesscontrol-subject),
    through the use of RoleBindings. Roles and RoleBindings are Kubernetes resources
    that can be created and managed like any other resource. They are tied to a specific
    namespace and apply to its resources.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 26-3](#img-accesscontrol-rbac) illustrates the relationship between
    subjects, Roles, and RoleBindings.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Relationship between Role, Rolebinding and subjects](assets/kup2_2603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-3\. Relationship between Role, RoleBinding, and subjects
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Kubernetes RBAC, it is important to understand that there is a many-to-many
    relationship between subjects and Roles. This means that a single subject can
    have multiple Roles, and a single Role can be applied to multiple subjects. The
    relationship between a subject and a Role is established using a RoleBinding,
    which contains references to a list of subjects and a specific Role.
  prefs: []
  type: TYPE_NORMAL
- en: The RBAC concepts are best explained with a concrete example. [Example 26-6](#ex-accesscontrol-role)
    shows the definition of a Role in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-6\. Role for allowing access to core resources
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the Role, which is used to reference it.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Namespace to which this Role applies. Roles are always connected to a namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_access_control_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: An empty string indicates the core API group.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_access_control_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: List of Kubernetes core resources to which the rule applies.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_access_control_CO4-5)'
  prefs: []
  type: TYPE_NORMAL
- en: API actions are represented by verbs allowed by subjects associated with this
    Role.
  prefs: []
  type: TYPE_NORMAL
- en: The Role defined in [Example 26-6](#ex-accesscontrol-role) specifies that any
    user or service account associated with this Role can perform read-only operations
    on Pods and Services.
  prefs: []
  type: TYPE_NORMAL
- en: This Role can then be referenced in the RoleBinding shown in [Example 26-7](#ex-accesscontrol-rolebinding)
    to grant access to both the user, `alice`, and the ServiceAccount, `contractor`.
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-7\. RoleBinding specification
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List of subjects to connect to a Role.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO5-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Human user reference for a user named `alice`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_access_control_CO5-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Service account with name `contractor`.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_access_control_CO5-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Reference to the Role with the name `developer-ro` that has been defined in
    [Example 26-6](#ex-accesscontrol-role).
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a basic understanding of the relationship between subjects,
    Roles, and RoleBindings, let’s delve deeper into the specifics of Roles and RoleBindings.
  prefs: []
  type: TYPE_NORMAL
- en: Role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Roles in Kubernetes allow you to define a set of permitted actions for a group
    of Kubernetes resources or subresources. Typical activities on Kubernetes resources
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating ConfigMaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating ServiceAccounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have already seen a Role in [Example 26-6](#ex-accesscontrol-role). Besides
    metadata, such as names and namespaces, a Role definition consists of a list of
    rules that describe which resources can be accessed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only one rule must match a request to grant access to this Role. Three fields
    describe each `rule`:'
  prefs: []
  type: TYPE_NORMAL
- en: apiGroups
  prefs: []
  type: TYPE_NORMAL
- en: This list is used rather than a single value because wildcards can specify all
    resources of multiple API groups. For example, an empty string (`""`) is used
    for the core API group, which contains primary Kubernetes resources such as Pods
    and Services. A wildcard character (*) can match all available API groups the
    cluster is aware of.
  prefs: []
  type: TYPE_NORMAL
- en: resources
  prefs: []
  type: TYPE_NORMAL
- en: This list specifies the resources that Kubernetes should grant access to. Each
    entry should belong to at least one of the configured `apiGroups`. A single `*`
    wildcard entry means all resources from all configured `apiGroups` are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: verbs
  prefs: []
  type: TYPE_NORMAL
- en: Allowed actions in a system are defined using verbs that are similar to HTTP
    methods. These verbs include CRUD operations on resources (CRUD stands for *Create-Read-Update-Delete*
    and describes the usual read-write operations that you can perform on persistent
    entities), and separate actions for operations on collections, such as `list`
    and `deletecollection`. Additionally, a `watch` verb allows access to resource
    change events and is separate from directly reading the resource with `get`. This
    `watch` verb is crucial for operators to receive notifications about the current
    status of resources they are managing. [Chapter 27, “Controller”](ch27.html#Controller),
    and [Chapter 28, “Operator”](ch28.html#Operator), has more on this topic. [Table 26-3](#table-accesscontrol-verbs)
    lists the most common verbs. Using the `*` wildcard character is also possible
    to allow all operations on the configured resources for a given rule.
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-3\. Kubernetes verb mapping to HTTP request methods for CRUD operations
  prefs: []
  type: TYPE_NORMAL
- en: '| Verbs | HTTP request methods |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| get, watch, list | GET |'
  prefs: []
  type: TYPE_TB
- en: '| create | POST |'
  prefs: []
  type: TYPE_TB
- en: '| patch | PATCH |'
  prefs: []
  type: TYPE_TB
- en: '| update | PUT |'
  prefs: []
  type: TYPE_TB
- en: '| delete, delete collection | DELETE |'
  prefs: []
  type: TYPE_TB
- en: Wildcard permissions make it easier to define all operations without listing
    each option individually. All of the properties of a Role’s `rule` element allow
    for an `*` wildcard, which matches everything. [Example 26-8](#table-accesscontrol-wildcards)
    allows for all operations on all resources in the core and `networking.k8s.io`
    API group. If a wildcard is used, this list should have only this wildcard as
    its single entry.
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-8\. Wildcard permission for resources and permitted operations
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: All Resources in the listed API groups, core, and `networking.k8s.io.`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: All actions are allowed on those resources.
  prefs: []
  type: TYPE_NORMAL
- en: Wildcards help developers to configure rules quickly. But they come with the
    security risk of privilege escalation. Such broader privileges can cause security
    gaps and allow users to perform any operations that can compromise the Kubernetes
    cluster or cause unwanted changes.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked into the *what* (Roles) and *who* (subjects) of the
    Kubernetes RBAC model, let’s have a closer look at how we can combine both concepts
    with RoleBindings.
  prefs: []
  type: TYPE_NORMAL
- en: RoleBinding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Example 26-7](#ex-accesscontrol-rolebinding), we saw how RoleBindings link
    one or more subjects to a given Role.
  prefs: []
  type: TYPE_NORMAL
- en: Each RoleBinding can connect a list of subjects to a Role. The `subjects` list
    field takes resource references as elements. Those resource references have a
    `name` field plus `kind` and `apiGroup` fields for defining the resource type
    to reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'A subject in a RoleBinding can be one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: User
  prefs: []
  type: TYPE_NORMAL
- en: A user is a human or system authenticated by the API server, as described in
    [“Users”](#accesscontrol-users). User entries have a fixed `apiGroup` value of
    `rbac.authorization.k8s.io`.
  prefs: []
  type: TYPE_NORMAL
- en: Group
  prefs: []
  type: TYPE_NORMAL
- en: A group is a collection of users, as explained in [“Groups”](#accesscontrol-groups).
    As for users, the group entries carry a `rbac.authorization.k8s.io` as `apiGroup`.
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccount
  prefs: []
  type: TYPE_NORMAL
- en: We discussed ServiceAccount in depth in [“Service accounts”](#accesscontrol-service-accounts).
    ServiceAccounts belong to the core API Group that is represented by an empty string
    (`""`). One unique aspect of ServiceAccounts is that it is the only subject type
    that can also carry a `namespace` field. This allows you to grant access to Pods
    from other namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[Table 26-4](#table-accesscontrol-rb-subjects) summarizes the possible field
    values for entries in a RoleBinding’s `subject` list.'
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-4\. Possible types for an element `subjects` list in a RoleBinding
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind | API Group | Namespace | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| User | rbac.authorization.k8s.io | N/A | `name` is a reference to a user.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Group | rbac.authorization.k8s.io | N/A | `name` is a reference to a group
    of users. |'
  prefs: []
  type: TYPE_TB
- en: '| ServiceAccount | “” | Optional | `name` is a reference to a ServiceAccount
    resource in the configured namespace. |'
  prefs: []
  type: TYPE_TB
- en: The other end of a RoleBinding points to a single Role. This Role can either
    be a Role resource within the same namespace as the RoleBinding or a ClusterRole
    resource shared across multiple bindings in the cluster. ClusterRoles are described
    in detail in [“ClusterRole”](#accesscontrol-clusterrole).
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the subjects list, Role references are specified by `name`, `kind`,
    and `apiGroup`. [Table 26-5](#table-accesscontrol-rb-roleref) shows the possible
    values for the `roleRef` field.
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-5\. Possible types for a `roleRef` field in a RoleBinding
  prefs: []
  type: TYPE_NORMAL
- en: '| Kind | API Group | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Role | rbac.authorization.k8s.io | `name` is a reference to a Role in the
    same namespace. |'
  prefs: []
  type: TYPE_TB
- en: '| ClusterRole | rbac.authorization.k8s.io | `name` is a reference to cluster-wide
    ClusterRole. |'
  prefs: []
  type: TYPE_TB
- en: ClusterRole
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'ClusterRoles in Kubernetes are similar to regular Roles but are applied cluster-wide
    rather than to a specific namespace. They have two primary uses:'
  prefs: []
  type: TYPE_NORMAL
- en: Securing cluster-wide resources such as CustomResourceDefinitions or StorageClasses.
    These resources are typically managed at the cluster-admin level and require additional
    access control. For example, developers may have read access to these resources
    but need help writing to them. ClusterRoleBindings are used to grant subjects
    access to cluster-wide resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining typical Roles that are shared across namespaces. As we saw in [“RoleBinding”](#accesscontrol-rolebinding),
    RoleBindings can refer only to Roles defined in the same namespace. ClusterRoles
    allow you to define general-access control Roles (e.g., “view” for read-only access
    to all resources) that can be used in multiple RoleBindings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Example 26-9](#ex-accesscontrol-clusterole) shows a ClusterRole that can be
    reused in multiple RoleBindings. It has the same schema as a Role except that
    it ignores any `.meta.namespace` field.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-9\. ClusterRole
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the ClusterRole but no namespace declaration.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO7-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Rule that allows reading operations on all Pods.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 26-4](#img-accesscontrol-clusterrole) shows how a single ClusterRole
    can be shared across multiple RoleBindings in different namespaces. In this example,
    the ClusterRole allows the reading of Pods in the `dev-1` and `dev-2` namespaces
    by a ServiceAccount in the `test` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sharing ClusterRole in multiple namespaces](assets/kup2_2604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-4\. Sharing a ClusterRole in multiple namespaces
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using a single ClusterRole in multiple RoleBindings allows you to create typical
    access-control schemes that can be easily reused. For example, [Table 26-6](#table-accesscontrol-clusterrole-default)
    includes a selection of useful user-facing ClusterRoles that Kubernetes provides
    out of the box. You can view the complete list of ClusterRoles available in a
    Kubernetes cluster using the `kubectl get clusterroles` command, or refer to the
    [Kubernetes documentation](https://oreil.ly/QklvQ) for a list of default ClusterRoles.
  prefs: []
  type: TYPE_NORMAL
- en: Table 26-6\. Standard user-facing ClusterRoles
  prefs: []
  type: TYPE_NORMAL
- en: '| ClusterRole | Purpose |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `view` | Allows reading for most resources in a namespace, except Role, RoleBinding,
    and Secret |'
  prefs: []
  type: TYPE_TB
- en: '| `edit` | Allows reading and modifying most resources in a namespace, except
    Role and RoleBinding |'
  prefs: []
  type: TYPE_TB
- en: '| `admin` | Grants full control of all resources in a namespace, including
    Role and RoleBinding |'
  prefs: []
  type: TYPE_TB
- en: '| `cluster-admin` | Grants full control of all namespace resources, including
    cluster-wide resources |'
  prefs: []
  type: TYPE_TB
- en: Sometimes you may need to combine the permissions defined in two ClusterRoles.
    One way to do this is to create multiple RoleBindings that refer to both ClusterRoles.
    However, there is a more elegant way to achieve this using aggregation.
  prefs: []
  type: TYPE_NORMAL
- en: To use aggregation, you can define a ClusterRole with an empty `rules` field
    and a populated `aggregationRule` field containing a list of label selectors.
    Then, the rules defined by every other ClusterRole that has labels matching these
    selectors will be combined and used to populate the `rules` field of the aggregated
    ClusterRole.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When you set the `aggregationRule` field, you are handing ownership of the `rules`
    field over to Kubernetes, which will fully manage it. Therefore, any manual changes
    to the rules field will be constantly overwritten with the aggregated rules from
    the selected ClusterRoles in the `aggregationRule`.
  prefs: []
  type: TYPE_NORMAL
- en: This aggregation technique allows you to dynamically and elegantly build up
    large rule sets by combining smaller, more focused ClusterRoles.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 26-10](#ex-accesscontrol-clusterrole-aggregation) shows how the default
    `view` role uses aggregation to pick up more specific ClusterRoles labeled with
    `rbac.authorization.k8s.io/aggregate-to-view`. The `view` role itself also has
    the label `rbac.authorization.k8s.io/aggregate-to-edit`, which is used by the
    `edit` role to include the aggregated rules from the `view` ClusterRole.'
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-10\. Aggregated ClusterRole
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: This label exposes the ClusterRole as eligible for inclusion in the `edit` role.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO8-2)'
  prefs: []
  type: TYPE_NORMAL
- en: All ClusterRoles that match this selector will be picked up for the `view` ClusterRole.
    Note that this ClusterRole declaration does not need to be changed if you want
    to add additional permissions to the `view` ClusterRole—you can create a new ClusterRole
    with the appropriate label.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_access_control_CO8-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The `rules` field will be managed by Kubernetes and populated with the aggregated
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: This technique allows you to quickly compose more specialized ClusterRoles by
    aggregating a set of basic ClusterRoles. [Example 26-10](#ex-accesscontrol-clusterrole-aggregation)
    also demonstrates how aggregation can be nested to build an inheritance chain
    of permission rule sets.
  prefs: []
  type: TYPE_NORMAL
- en: Since all of the user-facing default ClusterRoles use this aggregation technique,
    you can quickly hook into the permission model of custom resources (as described
    in [Chapter 28, “Operator”](ch28.html#Operator)) by simply adding the aggregation-triggering
    labels of the standard ClusterRoles (e.g., `view`, `edit`, and `admin`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the creation of a flexible and reusable permission model
    using ClusterRoles and RoleBindings, the final piece of the puzzle is establishing
    cluster-wide access rules with ClusterRoleBindings.
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRoleBinding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The schema for a ClusterRoleBinding is similar to that of a RoleBinding, except
    that it ignores the `namespace` field. The rules defined in a ClusterRoleBinding
    apply to all namespaces in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[Example 26-11](#ex-accesscontrol-clusterrolebinding-all-namespaces) shows
    a ClusterRoleBinding that connects a ServiceAccount `test-sa` with the ClusterRole
    `view-pod` defined in [Example 26-9](#ex-accesscontrol-clusterole).'
  prefs: []
  type: TYPE_NORMAL
- en: Example 26-11\. ClusterRoleBinding
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_access_control_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Connects ServiceAccount `test-sa` from the `test` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_access_control_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Allows the rules from the ClusterRole `view-pod` for every namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The rules defined in the ClusterRole `view-pod` apply to all namespaces in the
    cluster so that any Pod associated with the ServiceAccount `test-sa` can read
    all Pods in every namespace, which is illustrated in [Figure 26-5](#img-accesscontrol-clusterrolebinding).
    However, it is crucial to use ClusterRoleBindings with caution, as they grant
    wide-ranging permissions across the entire cluster. Therefore, it is recommended
    that you carefully consider whether using a ClusterRoleBinding is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Using a ClusterRoleBinding may be convenient as it automatically grants permissions
    to newly created namespaces. However, using individual RoleBindings per namespace
    is generally better for more granular control over permissions. This extra effort
    allows you to omit specific namespaces, such as `kube-system`, from unauthorized
    access.
  prefs: []
  type: TYPE_NORMAL
- en: '![ClusterRoleBinding for reading all Pods](assets/kup2_2605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 26-5\. ClusterRoleBinding for reading all Pods
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: ClusterRoleBindings should be used only for administrative tasks, such as managing
    cluster-wide resources like Nodes, Namespaces, CustomResourceDefinitions, or even
    ClusterRoleBindings.
  prefs: []
  type: TYPE_NORMAL
- en: These final warnings conclude our tour through the world of Kubernetes RBAC.
    This machinery is mighty, but it’s also complex to understand and sometimes even
    more complicated to debug. The following sidebar gives you some tips for better
    understanding a given RBAC setup.
  prefs: []
  type: TYPE_NORMAL
- en: The final section will discuss some general tips for properly using Kubernetes
    RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Kubernetes RBAC is a powerful tool for controlling access to API resources.
    However, it can be challenging to understand which definition objects to use and
    how to combine them to fit a particular security setup. Here are some guidelines
    to help you navigate these decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: If you want to secure resources in a specific namespace, use a Role with a RoleBinding
    that connects to a user or ServiceAccount. The ServiceAccount does not have to
    be in the same namespace, allowing you to grant access to Pods from other namespaces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to reuse the same access rules in multiple namespaces, use a RoleBinding
    with a ClusterRole that defines these shared-access rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to extend one or more existing predefined ClusterRoles, create a
    new ClusterRole with an `aggregationRule` field that refers to the ClusterRoles
    you wish to extend, and add your permissions to the `rules` field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to grant a user or ServiceAccount access to all resources of a specific
    kind in all namespaces, use a ClusterRole and a ClusterRoleBinding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to manage access to a cluster-wide resource like a CustomResourceDefinition,
    use a ClusterRole and a ClusterRoleBinding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have seen how RBAC allows us to define fine-grained permissions and manage
    them. It can reduce risk by ensuring the applied permission does not leave gaps
    for the escalation path. On the other hand, defining any broad open permissions
    can lead to security escalations. Let’s close this chapter with a summary of some
    general RBAC advice:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid wildcard permissions
  prefs: []
  type: TYPE_NORMAL
- en: We recommend following the principle of least privilege when composing the fine-grained
    access control in the Kubernetes cluster. To avoid unintentional operations, avoid
    wildcard permissions when defining the Role and ClusterRoles. For rare occasions,
    it might make sense to use wildcards (i.e., to secure all resources of an API
    group), but it is a good practice to establish a general “no wildcard” policy
    that could be relaxed for well-reasoned exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid `cluster-admin` ClusterRole
  prefs: []
  type: TYPE_NORMAL
- en: ServiceAccounts with high privileges can allow you to perform actions over any
    resources, like modifying permissions or viewing secrets in any namespace, which
    can lead to severe security implications. Therefore, never assign the `cluster-admin`
    ClusterRole to a Pod. Never.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t automount ServiceAccount tokens
  prefs: []
  type: TYPE_NORMAL
- en: By default, tokens of ServiceAccounts are mounted within a container’s filesystem
    at */var/run/secrets/kubernetes.io/serviceaccount/token*. If such a Pod gets compromised,
    any attacker can talk with the API server with the permissions of the Pod’s associated
    ServiceAccount. However, many applications don’t need that token for business
    operations. For such a use case, avoid the token mount by setting the ServiceAccount’s
    field `automountServiceAccountToken` to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes RBAC is a flexible and powerful method for controlling access to
    the Kubernetes API. Therefore, even if your application is not directly interacting
    with the API Server to install your application and connect it to other Kubernetes
    servers, *Access Control* is a valuable pattern to secure the operation of your
    application.
  prefs: []
  type: TYPE_NORMAL
- en: More Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[Access Control Example](https://oreil.ly/GyIlq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Escalation Paths](https://oreil.ly/HHT3G)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Controlling Access to the Kubernetes API](https://oreil.ly/BtTB9)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Auditing](https://oreil.ly/XgzNL)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Admission Controllers Reference](https://oreil.ly/QSqW8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Dynamic Admission Control](https://oreil.ly/7oCSg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubernetes: Authentication Strategies](https://oreil.ly/hSISq)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RBAC Good Practices](https://oreil.ly/h7XHg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Workload Creation](https://oreil.ly/uC307)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Bound Service Account Tokens](https://oreil.ly/bJVhD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[BIG Change in K8s 1.24 About ServiceAccounts and Their Secrets](https://oreil.ly/T22fJ)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Efficient Detection of Changes](https://oreil.ly/RdlPi)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Add ImagePullSecrets to a Service Account](https://oreil.ly/jVXQN)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[RBAC Dev](https://rbac.dev)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Rakkess](https://oreil.ly/fE1I_)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[How the Basics of Kubernetes Auth Scale for Organizations](https://oreil.ly/nAFu2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Kubernetes CVE-2020-8559 Proof of Concept PoC Exploit](https://oreil.ly/BC6aO)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[OAuth Is Not Authentication](https://oreil.ly/UVz7Y)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch26.html#idm45902085697664-marker)) See the blog post [“Exposed Kubernetes
    Clusters”](https://oreil.ly/uGzr_).
  prefs: []
  type: TYPE_NORMAL
- en: ^([2](ch26.html#idm45902085687920-marker)) An [attacker with escalated privileges](https://oreil.ly/h1YGJ)
    on a node can compromise a full Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
