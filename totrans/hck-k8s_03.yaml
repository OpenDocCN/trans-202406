- en: Chapter 2\. Pod-Level Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter concerns the atomic unit of Kubernetes deployment: a pod. Pods
    run apps, and an app may be one or more containers working together in one or
    more pods.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: We’ll consider what bad things can happen in and around a pod, and look at how
    you can mitigate the risk of getting attacked.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: As with any sensible security effort, we’ll begin by defining a lightweight
    threat model for your system, identifying the threat actors it defends against,
    and highlighting the most dangerous threats. This gives you a solid basis to devise
    countermeasures and controls, and take defensive steps to protect your customer’s
    valuable data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go deep into the security model of a pod and look at what is trusted by
    default, where we can tighten security with configuration, and what an attacker’s
    journey looks like.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Defaults
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes has historically not been security hardened out of the box, and sometimes
    this may lead to privilege escalation or container breakout.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: If we zoom in on the relationship between a single pod and the host in [Figure 2-1](#pod-diagram-temp),
    we can see the services offered to the container by the `kubelet` and potential
    security boundaries that may keep an adversary at bay.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: By default much of this is sensibly configured with least privilege, but where
    user-supplied configuration is more common (pod YAML, cluster policy, container
    images) there are more opportunities for accidental or malicious misconfiguration.
    Most defaults are sane—in this chapter we will show you where they are not, and
    demonstrate how to test that your clusters and workloads are configured securely.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: '![Pod Architecture](Images/haku_0201.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. Pod architecture
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Threat Model
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We define a scope for each threat model. Here, you are threat modeling a pod.
    Let’s consider a simple group of Kubernetes threats to begin with:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[Attacker on the network](https://oreil.ly/PoRXb)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Sensitive endpoints (such as the API server) can be attacked easily if public.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[Compromised application leads to foothold in container](https://oreil.ly/CYG04)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: A compromised application (remote code execution, supply chain compromise) is
    the start of an attack.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[Establish persistence](https://oreil.ly/zJGhK)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Stealing credentials or gaining persistence resilient to pod, node, and/or container
    restarts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[Malicious code execution](https://oreil.ly/POnQ9)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Running exploits to pivot or escalate and enumerating endpoints.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[Access sensitive data](https://oreil.ly/agQ7E)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Reading Secret data from the API server, attached storage, and network-accessible
    datastores.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[Denial of service](https://oreil.ly/nr7Cb)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Rarely a good use of an attacker’s time. Denial of Wallet and cryptolocking
    are common variants.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The threat sources in [“Prior Art”](ch01.xhtml#PriorArt) have other negative
    outcomes to cross-reference with this list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of the Attack
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '![captain](Images/haku_0000.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
- en: Captain Hashjack started their assault on your systems by enumerating BCTL’s
    DNS subdomains and S3 buckets. These could have offered an easy way into the organization’s
    systems, but there was nothing easily exploitable on this occasion.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Undeterred, they create an account on the public website and log in, using a
    web application scanner like [zaproxy](https://www.zaproxy.org) (OWASP Zed Attack
    Proxy) to pry into API calls and application code for unexpected responses. They’re
    on the search for leaking web-server banner and version information (to learn
    which exploits might succeed) and are generally injecting and fuzzing APIs for
    poorly handled user input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: This is not a level of scrutiny that your poorly maintained codebase and systems
    are likely to withstand for long. Attackers may be searching for a needle in a
    haystack, but only the safest haystack has no needles at all.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Caution
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Any computer should be resistant to this type of indiscriminate attack: a Kubernetes
    system should achieve “minimum viable security” through the capability to protect
    itself from casual attack with up-to-date software and hardened configuration.
    Kubernetes encourages regular updates by supporting the last three minor releases
    (e.g., 1.24, 1.23, and 1.22), which are released every 4 months and ensure a year
    of patch support. Older versions are unsupported and likely to be vulnerable.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: Although many parts of an attack can be automated, this is an involved process.
    A casual attacker is more likely to scan widely for software paths that trigger
    published CVEs and run automated tools and scripts against large ranges of IPs
    (such as the ranges advertised by public cloud providers). These are noisy approaches.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Remote Code Execution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If a vulnerability in your application can be used to run untrusted (and in
    this case, external) code, it is called a remote code execution (RCE). An adversary
    can use an RCE to spawn a remote control session into the application’s environment:
    here it is the container handling the network request, but if the RCE manages
    to pass untrusted input deeper into the system, it may exploit a different process,
    pod, or cluster.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: Your first goal of Kubernetes and pod security should be to prevent RCE, which
    could be as simple as a `kubectl exec`, or as complex as a reverse shell, such
    as the one demonstrated in [Figure 2-2](#pods-reverse-shell).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![haku 0202](Images/haku_0202.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: Figure 2-2\. Reverse shell into a Kubernetes pod
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Application code changes frequently and may hide undiscovered bugs, so robust
    application security (AppSec) practices (including IDE and CI/CD integration of
    tooling and dedicated security requirements as task acceptance criteria) are essential
    to keep an attacker from compromising the processes running in a pod.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The Java framework Struts was one of the most widely deployed libraries to have
    suffered a remotely exploitable vulnerability (CVE-2017-5638), which contributed
    to the breach of Equifax customer data. To fix a supply chain vulnerability like
    this in a container, it is quickly rebuilt in CI with a patched library and redeployed,
    reducing the risk window of vulnerable libraries being exposed to the internet.
    We examine other ways to get remote code execution throughout the book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: With that, let’s move on to the network aspects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Network Attack Surface
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The greatest attack surface of a Kubernetes cluster is its network interfaces
    and public-facing pods. Network-facing services such as web servers are the first
    line of defense in keeping your clusters secure, a topic we will dive into in
    [Chapter 5](ch05.xhtml#ch-networking).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: This is because unknown users coming in from across the network can scan network-facing
    applications for the exploitable signs of RCE. They can use automated network
    scanners to attempt to exploit known vulnerabilities and input-handling errors
    in network-facing code. If a process or system can be forced to run in an unexpected
    way, there is the possibility that it can be compromised through these untested
    logic paths.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: To investigate how an attacker may establish a foothold in a remote system using
    only the humble, all-powerful Bash shell, see, for example, Chapter 16 of [*Cybersecurity
    Ops with bash*](https://oreil.ly/ZmILo) by Paul Troncone and Carl Albing (O’Reilly).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: To defend against this, we must scan containers for operating system and application
    CVEs in the hope of updating them before they are exploited.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: If Captain Hashjack has an RCE into a pod, it’s a foothold to attack your system
    more deeply from the pod’s network position and permissions set. You should strive
    to limit what an attacker can do from this position, and customize your security
    configuration to a workload’s sensitivity. If your controls are too loose, this
    may be the beginning of an organization-wide breach for your employer, BCTL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: For an example of spawning a shell via Struts with Metasploit, see [Sam Bowne’s
    guide](https://oreil.ly/nzsxP).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: As Dread Pirate Hashjack has just discovered, we have also been running a vulnerable
    version of the Struts library. This offers an opportunity to start attacking the
    cluster from within.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A simple Bash reverse shell like this one is a good reason to remove Bash from
    your containers. It uses Bash’s virtual */dev/tcp/* filesystem, and is not exploitable
    in `sh`, which doesn’t include this oft-abused feature:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As the attack begins, let’s take a look at where the pirates have landed: inside
    a Kubernetes pod.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Kubernetes Workloads: Apps in a Pod'
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Multiple cooperating containers can be logically grouped into a single pod,
    and every container Kubernetes runs must run inside a pod. Sometimes a pod is
    called a “workload,” which is one of many copies of the same execution environment.
    Each pod must run on a Node in your Kubernetes cluster as shown in [Figure 2-3](#pod-cluster-example).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: A pod is a single instance of your application, and to scale to demand, many
    identical pods are used to replicate the application by a workload resource (such
    as a Deployment, DaemonSet, or StatefulSet).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Your pods may include sidecar containers supporting monitoring, network, and
    security, and “init” containers for pod bootstrap, enabling you to deploy different
    application styles. These sidecars are likely to have elevated privileges and
    be of interest to an adversary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: “Init” containers run in order (first to last) to set up a pod and can make
    security changes to the namespaces, like Istio’s init container that configures
    the pod’s *iptables* (in the kernel’s netfilter) so the runtime (non-init container)
    pods route traffic through a sidecar container. Sidecars run alongside the primary
    container in the pod, and all non-init containers in a pod start at the same time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Cluster deployment example](Images/haku_0203.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3\. Cluster deployment example; source: [Kubernetes documentation](https://oreil.ly/Co9Hx)'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What’s inside a pod? Cloud native applications are often microservices, web
    servers, workers, and batch processes. Some pods run one-shot tasks (wrapped with
    a job, or maybe one single nonrestarting container), perhaps running multiple
    other pods to assist. All these pods present an opportunity to an attacker. Pods
    get hacked. Or, more often, a network-facing container process gets hacked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: A pod is a trust boundary encompassing all the containers inside, including
    their identity and access. There is still separation between pods that you can
    enhance with policy configuration, but you should consider the entire contents
    of a pod when threat modeling it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kubernetes is a distributed system, and ordering of actions (such as applying
    a multidoc YAML file) is eventually consistent, meaning that API calls don’t always
    complete in the order that you expect. Ordering depends on various factors and
    shouldn’t be relied upon. Tabitha Sable has a mechanically sympathetic definition
    of Kubernetes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![tabby sable](Images/haku_0204.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: What’s a Pod?
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pod as depicted in [Figure 2-4](#pod-examples) is a Kubernetes invention.
    It’s an environment for multiple containers to run inside. The pod is the smallest
    deployable unit you can ask Kubernetes to run and all containers in it will be
    launched on the same node. A pod has its own IP address, can mount in storage,
    and its namespaces surround the containers created by the container runtime such
    as `containerd` or CRI-O.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Example pods](Images/haku_0205.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4\. Example pods (source: [Kubernetes documentation](https://oreil.ly/YwBSv))'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A container is a mini-Linux, and its processes are containerized with control
    groups (`cgroups`) to limit resource usage and namespaces to limit access. A variety
    of other controls can be applied to restrict a containerized process’s behavior,
    as we’ll see in this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle of a pod is controlled by the `kubelet`, the Kubernetes API server’s
    deputy, deployed on each node in the cluster to manage and run containers. If
    the `kubelet` loses contact with the API server, it will continue to manage its
    workloads, restarting them if necessary. If the `kubelet` crashes, the container
    manager will also keep containers running in case they crash. The `kubelet` and
    container manager oversee your workloads.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: The `kubelet` runs pods on worker nodes to instruct the container runtime and
    configuring network and storage. Each container in a pod is a collection of Linux
    namespaces, `cgroups`, capabilities, and Linux Security Modules (LSMs). As the
    container runtime builds a container, each namespace is created and configured
    individually before being combined into a container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Capabilities are individual switches for “special” root user operations such
    as changing any file’s permissions, loading modules into the kernel, accessing
    devices in raw mode (e.g., networks and I/O), BPF and performance monitoring,
    and every other operation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: The root user has all capabilities, and capabilities can be granted to any process
    or user (“ambient capabilities”). Excess capability grants may lead to container
    breakout, as we see later in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: In Kubernetes, a newly created container is added to the pod by the container
    runtime, where it shares network and interprocess communication namespaces between
    pod containers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-5](#node-examples) shows a `kubelet` running four individual pods
    on a single node.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'The container is the first line of defense against an adversary, and container
    images should be scanned for CVEs before being run. This simple step reduces the
    risk of running an outdated or malicious container and informs your risk-based
    deployment decisions: do you ship to production, or is there an exploitable CVE
    that needs patching first?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Example pods on a node](Images/haku_0206.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-5\. Example pods on a node (source: [Kubernetes documentation](https://oreil.ly/ksFim))'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: “Official” container images in public registries have a greater likelihood of
    being up to date and well-patched, and Docker Hub signs all official images with
    Notary, as we’ll see in [Chapter 4](ch04.xhtml#ch-apps-supply-chain).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Public container registries often host malicious images, so detecting them before
    production is essential. [Figure 2-6](#app-poison-container-registry) shows how
    this might happen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: The `kubelet` attaches pods to a Container Network Interface (CNI). CNI network
    traffic is treated as layer 4 TCP/IP (although the underlying network technology
    used by the CNI plug-in may differ), and encryption is the job of the CNI plug-in,
    the application, a service mesh, or at a minimum, the underlay networking between
    the nodes. If traffic is unencrypted, it may be sniffed by a compromised pod or
    node.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![Poisoning a public container registry](Images/haku_0207.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: Figure 2-6\. Poisoning a public container registry
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Although starting a malicious container under a correctly configured container
    runtime is usually safe, there have been attacks against the container bootstrap
    phase. We examine the */proc/self/exe* breakout CVE-2019-5736 later in this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Pods can also have storage attached by Kubernetes, using the ([Container Storage
    Interface (CSI)](https://oreil.ly/S8v3B)), which includes the PersistentVolumeClaim
    and StorageClass shown in [Figure 2-7](#pod-cluster-example-2). In [Chapter 6](ch06.xhtml#ch-storage)
    we will get deeper into the storage aspects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Figure 2-7](#pod-cluster-example-2) you can see a view of the control plane
    and the API server’s central role in the cluster. The API server is responsible
    for interacting with the cluster datastore (`etcd`), hosting the cluster’s extensible
    API surface, and managing the `kubelet`s. If the API server or `etcd` instance
    is compromised, the attacker has complete control of the cluster: these are the
    most sensitive parts of the system.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![Cluster Example 2](Images/haku_0208.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-7\. Cluster example 2 (source: [Tsuyoshi Ushio](https://oreil.ly/szUug))'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Warning
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vulnerabilities have been found in many storage drivers, including CVE-2018-11235,
    which exposed a Git attack on the `gitrepo` storage volume, and CVE-2017-1002101,
    a subpath volume mount mishandling error. We will cover these in [Chapter 6](ch06.xhtml#ch-storage).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: For performance in larger clusters, the control plane should run on separate
    infrastructure to `etcd`, which requires high disk and network I/O to support
    reasonable response times for its distributed consensus algorithm, [Raft](https://oreil.ly/V5lbf).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: 'As the API server is the `etcd` cluster’s only client, compromise of either
    effectively roots the cluster: due to the asynchronous scheduling, in Kubernetes
    the injection of malicious, unscheduled pods into `etcd` will trigger their scheduling
    to a `kubelet`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: As with all fast-moving software, there have been vulnerabilities in most parts
    of the Kubernetes stack. The only solution to running modern software is a healthy
    continuous integration infrastructure capable of promptly redeploying vulnerable
    clusters upon a vulnerability announcement.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Containers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, so we have a high-level view of a cluster. But at a low level, what is
    a “container”? It is a microcosm of Linux that gives a process the illusion of
    a dedicated kernel, network, and userspace. Software trickery fools the process
    inside your container into believing it is the only process running on the host
    machine. This is useful for isolation and migration of your existing workloads
    into Kubernetes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As [Christian Brauner](https://oreil.ly/lBByx) and [Stéphane Graber](https://oreil.ly/DsmkD)
    like [to say](https://oreil.ly/sTkqN) “(Linux) containers are a userspace fiction,”
    a collection of configurations that present an illusion of isolation to a process
    inside. Containers emerged from the primordial kernel soup, a child of evolution
    rather than intelligent design that has been morphed, refined, and coerced into
    shape so that we now have something usable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Containers don’t exist as a single API, library, or kernel feature. They are
    merely the resultant bundling and isolation that’s left over once the kernel has
    started a collection of namespaces, configured some `cgroups` and capabilities,
    added Linux Security Modules like AppArmor and SELinux, and started our precious
    little process inside.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: A container is a process in a special environment with some combination of namespaces
    either enabled or shared with the host (or other containers). The process comes
    from a container image, a TAR file containing the container’s root filesystem,
    its application(s), and any dependencies. When the image is unpacked into a directory
    on the host and a special filesystem “pivot root” is created, a “container” is
    constructed around it, and its `ENTRYPOINT` is run from the filesystem within
    the container. This is roughly how a container starts, and each container in a
    pod must go through this process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: 'Container security has two parts: the contents of the container image, and
    its runtime configuration and security context. An abstract risk rating of a container
    can be derived from the number of security primitives it enables and uses safely,
    avoiding host namespaces, limiting resource use with `cgroups`, dropping unneeded
    capabilities, tightening security module configuration for the process’s usage
    pattern, and minimizing process and filesystem ownership and contents. [Kubesec.io](https://kubesec.io)
    rates a pod configuration’s security on how well it enables these features at
    runtime.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: 'When the kernel detects a network namespace is empty, it will destroy the namespace,
    removing any IPs allocated to network adapters in it. For a pod with only a single
    container to hold the network namespace’s IP allocation, a crashed and restarting
    container would have a new network namespace created and so have a new IP assigned.
    This rapid churn of IPs would create unnecessary noise for your operators and
    security monitoring. Kubernetes uses the so-called pause container (see also [“Intra-Pod
    Networking”](ch05.xhtml#workload-networking-intra-pod)), to hold the pod’s shared
    network namespace open in the event of a crash-looping tenant container. From
    inside a worker node, the companion pause container in each pod looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This pause container is invisible via the Kubernetes API, but visible to the
    container runtime on the worker node.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'CRI-O dispenses with the pause container (unless absolutely necessary) by pinning
    namespaces, as described in the KubeCon talk [“CRI-O: Look Ma, No Pause”](https://oreil.ly/EqEwr).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Network and Storage
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A group of containers in a pod share a network namespace, so all your containers’
    ports are available on the same network adapter to every container in the pod.
    This gives an attacker in one container of the pod a chance to attack private
    sockets available on any network interface, including the loopback adapter `127.0.0.1`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We examine these concepts in greater detail in Chapters [5](ch05.xhtml#ch-networking)
    and [6](ch06.xhtml#ch-storage).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Each container runs in a root filesystem from its container image that is not
    shared between containers. Volumes must be mounted into each container in the
    pod configuration, but a pod’s volumes may be available to all containers if configured
    that way, as you saw in [Figure 2-4](#pod-examples).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-8](#pod-namespace-nested) shows some of the paths inside a container
    workload that an attacker may be interested in (note the `user` and `time` namespaces
    are not currently in use).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested Pod Namespaces](Images/haku_0209.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Namespaces wrapping the containers in a pod ([inspired by Ian Lewis](https://oreil.ly/nH9y8))
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'User namespaces are the ultimate kernel security frontier, and are generally
    not enabled due to historically being likely entry points for kernel attacks:
    everything in Linux is a file, and user namespace implementation cuts across the
    whole kernel, making it more difficult to secure than other namespaces.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The special virtual filesystems listed here are all possible paths of breakout
    if misconfigured and accessible inside the container: */dev* may give access to
    the host’s devices, */proc* can leak process information, or */sys* supports functionality
    like launching new containers.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: What’s the Worst That Could Happen?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CISO is responsible for the organization’s security. Your role as a CISO means
    you should consider worst-case scenarios, to ensure that you have appropriate
    defenses and mitigations in place. Attack trees help to model these negative outcomes,
    and one of the data sources you can use is the [threat matrix](https://oreil.ly/LyjsO)
    as shown in [Figure 2-9](#pod-threat-matrix).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '![Microsoft Kubernetes Threat Matrix](Images/haku_0210.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-9\. Microsoft Kubernetes threat matrix; source: [“Secure Containerized
    Environments with Updated Threat Matrix for Kubernetes”](https://oreil.ly/JzdmV)'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But there are some threats missing, and the community has added some (thanks
    to Alcide, and [Brad Geesaman](https://oreil.ly/Ll2de) and [Ian Coldwater](https://oreil.ly/NmidV)
    again), as shown in [Table 2-1](#table0201).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Our enhanced Microsoft Kubernetes threat matrix
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '| Initial access (popping a shell pt 1 - prep) | Execution (popping a shell
    pt 2 - exec) | Persistence (keeping the shell) | Privilege escalation (container
    breakout) | Defense evasion (assuming no IDS) | Credential access (juicy creds)
    | Discovery (enumerate possible pivots) | Lateral movement (pivot) | Command &
    control (C2 methods) | Impact (dangers) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
- en: '| Using cloud credentials: service account keys, impersonation | Exec into
    container (bypass admission control policy) | Backdoor container (add a reverse
    shell to local or container registry image) | Privileged container (legitimate
    escalation to host) | Clear container logs (covering tracks after host breakout)
    | List K8s Secrets | List K8s API server (nmap, curl) | Access cloud resources
    (workload identity and cloud integrations) | Dynamic resolution (DNS tunneling)
    | Data destruction (datastores, files, NAS, ransomware…) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
- en: '| Compromised images in registry (supply chain unpatched or malicious) | BASH/CMD
    inside container (implant or trojan, RCE/reverse shell, malware, C2, DNS tunneling)
    | Writable host path mount (host mount breakout) | Cluster admin role binding
    (untested RBAC) | Delete K8s events (covering tracks after host breakout) | Mount
    service principal (Azure specific) | Access `kubelet` API | Container service
    account (API server) | App protocols (L7 protocols, TLS, …) | Resource hijacking
    (cryptojacking, malware C2/distribution, open relays, botnet membership) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
- en: '| Application vulnerability (supply chain unpatched or malicious) | Start new
    container (with malicious payload: persistence, enumeration, observation, escalation)
    | K8s CronJob (reverse shell on a timer) | Access cloud resources (metadata attack
    via workload identity) | Connect from proxy server (to cover source IP, external
    to cluster) | Applications credentials in config files (key material) | Access
    K8s dashboard (UI requires service account credentials) | Cluster internal networking
    (attack neighboring pods or systems) | Botnet (k3d, or traditional) | Application
    DoS |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
- en: '| kubeconfig file (exfiltrated, or uploaded to the wrong place) | Application
    exploit (RCE) | Static pods (reverse shell, shadow API server to read audit-log-only
    headers) | Pod `hostPath` mount (logs to container breakout) | Pod/container name
    similarity (visual evasion, CronJob attack) | Access container service account
    (RBAC lateral jumps) | Network mapping (nmap, curl) | Access container service
    account (RBAC lateral jumps) |  | Node scheduling DoS |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
- en: '| Compromise user endpoint (2FA and federating auth mitigate) | SSH server
    inside container (bad practice) | Injected sidecar containers (malicious mutating
    webhook) | Node to cluster escalation (stolen credentials, node label rebinding
    attack) | Dynamic resolution (DNS) (DNS tunneling/exfiltration) | Compromise admission
    controllers | Instance metadata API (workload identity) | Host writable volume
    mounts |  | Service discovery DoS |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
- en: '| K8s API server vulnerability (needs CVE and unpatched API server) | Container
    lifecycle hooks (`postStart` and `preStop` events in pod YAML) | Rewrite container
    lifecycle hooks (`postStart` and `preStop` events in pod YAML) | Control plane
    to cloud escalation (keys in Secrets, cloud or control plane credentials) | Shadow
    admission control or API server |  | Compromise K8s Operator (sensitive RBAC)
    | Access K8s dashboard |  | PII or IP exfiltration (cluster or cloud datastores,
    local accounts) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
- en: '| Compromised host (credentials leak/stuffing, unpatched services, supply chain
    compromise) |  | Rewrite liveness probes (exec into and reverse shell in container)
    | Compromise admission controller (reconfigure and bypass to allow blocked image
    with flag) |  |  | Access host filesystem (host mounts) | Access tiller endpoint
    (Helm v3 negates this) |  | Container pull rate limit DoS (container registry)
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
- en: '| Compromised `etcd` (missing auth) |  | Shadow admission control or API server
    (privileged RBAC, reverse shell) | Compromise K8s Operator (compromise flux and
    read any Secrets) |  |  |  | Access K8s Operator |  | SOC/SIEM DoS (event/audit/log
    rate limit) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
- en: '|  |  | K3d botnet (secondary cluster running on compromised nodes) | Container
    breakout (kernel or runtime vulnerability e.g., DirtyCOW, `/proc/self/exe`, eBPF
    verifier bugs, Netfilter) |  |  |  |  |  |  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
- en: We’ll explore these threats in detail as we progress through the book. But the
    first threat, and the greatest risk to the isolation model of our systems, is
    an attacker breaking out of the container itself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: Container Breakout
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A cluster admin’s worst fear is a container breakout; that is, a user or process
    inside a container that can run code outside of the container’s execution environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Speaking strictly, a container breakout should exploit the kernel, attacking
    the code a container is supposed to be constrained by. In the authors’ opinion,
    any avoidance of isolation mechanisms breaks the contract the container’s maintainer
    or operator thought they had with the process(es) inside. This means it should
    be considered equally threatening to the security of the host system and its data,
    so we define container breakout to include any evasion of isolation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Container breakouts may occur in various ways:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: An *exploit* including against the kernel, network or storage stack, or container
    runtime
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *pivot* such as attacking exposed local, cloud, or network services, or escalating
    privilege and abusing discovered or inherited credentials
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A *misconfiguration* that allows an attacker an easier or legitimate path to
    exploit or pivot (this is the most likely way)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the running process is owned by an unprivileged user (that is, one with no
    root capabilities), many breakouts are not possible. In that case the process
    or user must gain capabilities with a local privilege escalation inside the container
    before attempting to break out.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is achieved, a breakout may start with a hostile root-owned process
    running in a poorly configured container. Access to the root user’s capabilities
    within a container is the precursor to most escapes: without root (and sometimes
    `CAP_SYS_ADMIN`), many breakouts are nullified.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The `securityContext` and LSM configurations are vital to constrain unexpected
    activity from zero-day vulnerabilities, or supply chain attacks (library code
    loaded into the container and exploited automatically at runtime).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define the active user, group, and filesystem group (set on mounted
    volumes for readability, gated by `fsGroupChangePolicy`) in your workloads’ security
    contexts, and enforce it with admission control (see [Chapter 8](ch08.xhtml#ch-policy)),
    as this [example from the docs](https://oreil.ly/YJNS6) shows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a container breakout scenario, if the user is root inside the container
    or has mount capabilities (granted by default under `CAP_SYS_ADMIN`, which root
    is granted unless dropped), they can interact with virtual and physical disks
    mounted into the container. If the container is privileged (which among other
    things disables masking of kernel paths in */dev*), it can see and mount the host
    filesystem:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We look at `nsenter` privileged container breakouts, which escape more elegantly
    by entering the host’s namespaces, in [Chapter 6](ch06.xhtml#ch-storage).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: While you should prevent this attack easily by avoiding the root user and privilege
    mode, and enforcing that with admission control, it’s an indication of just how
    slim the container security boundary can be if misconfigured.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'An attacker controlling a containerized process may have control of the networking,
    some or all of the storage, and potentially other containers in the pod. Containers
    generally assume other containers in the pod are friendly as they share resources,
    and we can consider the pod as a trust boundary for the processes inside. Init
    containers are an exception: they complete and shut down before the main containers
    in the pod start, and as they operate in isolation may have more security sensitivity.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: The container and pod isolation model relies on the Linux kernel and container
    runtime, both of which are generally robust when not misconfigured. Container
    breakout occurs more often through insecure configuration than kernel exploit,
    although zero-day kernel vulnerabilities are inevitably devastating to Linux systems
    without correctly configured LSMs (such as SELinux and AppArmor).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In [“Architecting Containerized Apps for Resilience”](ch04.xhtml#architecting-apps-resilience)
    we explore how the Linux DirtyCOW vulnerability could be used to break out of
    insecurely configured containers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'Container escape is rarely plain sailing, and any fresh vulnerabilities are
    often patched shortly after disclosure. Only occasionally does a kernel vulnerability
    result in an exploitable container breakout, and the opportunity to harden individually
    containerized processes with LSMs enables defenders to tightly constrain high-risk
    network-facing processes; it may entail one or more of:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Finding a zero-day in the runtime or kernel
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploiting excess privilege and escaping using legitimate commands
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evading misconfigured kernel security mechanisms
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introspection of other processes or filesystems for alternate escape routes
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sniffing network traffic for credentials
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attacking the underlying orchestrator or cloud environment
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Vulnerabilities in the underlying physical hardware often can’t be defended
    against in a container. For example, `Spectre` and `Meltdown` (CPU speculative
    execution attacks), and `rowhammer`, `TRRespass`, and `SPOILER` (DRAM memory attacks)
    bypass container isolation mechanisms as they cannot intercept the entire instruction
    stream that a CPU processes. Hypervisors suffer the same lack of possible protection.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Finding new kernel attacks is hard. Misconfigured security settings, exploiting
    published CVEs, and social engineering attacks are easier. But it’s important
    to understand the range of potential threats in order to decide your own risk
    tolerance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: We’ll go through a step-by-step security feature exploration to see a range
    of ways in which your systems may be attacked in [Appendix A](app01.xhtml#appendix-pod-attack).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on how the Kubernetes project manages CVEs, see Anne Bertucio
    and CJ Cullen’s blog post, [“Exploring Container Security: Vulnerability Management
    in Open-Source Kubernetes”](https://oreil.ly/wYvv6).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Pod Configuration and Threats
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve spoken generally about various parts of a pod, so let’s finish off by
    going into depth on a pod spec to call out any gotchas or potential footguns.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In order to secure a pod or container, the container runtime should be minimally
    viably secure; that is, not hosting sockets to unauthenticated connections (e.g.,
    Docker’s */var/run/docker.sock* and `tcp://127.0.0.1:2375`) as it [leads to host
    takeover](https://oreil.ly/jy8Ol).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'For the purpose of this example, we are using a `frontend` pod from the [`GoogleCloudPlatform/microservices-demo`
    application](https://oreil.ly/6WVwV), and it was deployed with the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have updated and added some extra configuration where relevant for demonstration
    purposes and will progress through these in the following sections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Pod Header
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pod header is the standard header of all Kubernetes resources we know and
    love, defining the type of entity this YAML defines, and its version:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Metadata and annotations may contain sensitive information like IP addresses
    or security hints (in this case, for Istio), although this is only useful if the
    attacker has read-only access:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It also historically holds the `seccomp`, `AppArmor`, and `SELinux` policies:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We look at how to use these annotations in [“Runtime Policies”](ch08.xhtml#policy-runtime-policies).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: After many years in limbo, `seccomp` in Kubernetes [progressed to General Availability
    in v1.19](https://oreil.ly/F7zOs).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: 'This [changes the syntax](https://oreil.ly/raOrF) from an annotation to a `securityContext`
    entry:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The [Kubernetes Security Profiles Operator](https://oreil.ly/Lrw5d) (SPO) can
    install `seccomp` profiles on your nodes (a prerequisite to their use by the container
    runtime), and record new profiles from workloads in the cluster with [oci-seccomp-bpf-hook](https://oreil.ly/A3Ub4).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: The SPO also supports SELinux via [selinuxd](https://oreil.ly/nYQOU), with plenty
    of details [in this blog post](https://oreil.ly/3ZFui).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: AppArmor is still in beta but annotations will be replaced with first-class
    fields like `seccomp` once it graduates to GA.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to a part of the pod spec that is not writable by the client but
    contains some important hints.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Uptime
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you dump a pod spec from the API server (using, for example, `kubectl
    get` `-o yaml`) it includes the pod’s start time:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Pods running for longer than a week or two are likely to be at higher risk of
    unpatched bugs. Sensitive workloads running for more than 30 days will be safer
    if they’re rebuilt in CI/CD to account for library or operating system patches.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Pipeline scanning the existing container image offline for CVEs can be used
    to inform rebuilds. The safest approach is to combine both: “repave” (that is,
    rebuild and redeploy containers) regularly, and rebuild through the CI/CD pipelines
    whenever a CVE is detected.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Labels in Kubernetes are not validated or strongly typed; they are metadata.
    But labels are targeted by things like services and controllers using selectors
    for referencing, and are also used for security features such as network policy.
    This makes them security-sensitive and easily susceptible to misconfiguration:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Typos in labels mean they do not match the intended selectors, and so can inadvertently
    introduce security issues such as:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Exclusions from expected network policy or admission control policy
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unexpected routing from service target selectors
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rogue pods that are not accurately targeted by operators or observability tooling
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managed Fields
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Managed fields were introduced in v1.18 and support [server-side apply](https://oreil.ly/UjXPY).
    They duplicate information from elsewhere in the pod spec but are of limited interest
    to us as we can read the entire spec from the API server. They look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pod Namespace and Owner
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We know the pod’s name and namespace from the API request we made to retrieve
    it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'If we used `--all-namespaces` to return all pod configurations, this shows
    us the namespace:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From within a pod it’s possible to infer the current namespace from the DNS
    resolver configuration in */etc/resolv.conf* (which is `secret-namespace` in this
    example):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Other less-robust options include the mounted service account (assuming it’s
    in the same namespace, which it may not be), or the cluster’s DNS resolver (if
    you can enumerate or scrape it).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Environment Variables
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now we’re getting into interesting configuration. We want to see the environment
    variables in a pod, partially because they may leak secret information (which
    should have been mounted as a file), and also because they may list which other
    services are available in the namespace and so suggest other network routes and
    applications to attack.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Passwords set in deployment and pod YAML are visible to the operator that deploys
    the YAML, the process at runtime and any other processes that can read its environment,
    and to anybody that can read from the Kubernetes or `kubelet` APIs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we see the container’s `PORT` (which is good practice and required by
    applications running in Knative, Google Cloud Run, and some other systems), the
    DNS names and ports of its coordinating services, some badly set database config
    and credentials, and finally a sensibly referenced Secret file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That wasn’t too bad, right? Let’s move on to container images.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Container Images
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The container image’s filesystem is of paramount importance, as it may hold
    vulnerabilities that assist in privilege escalation. If you’re not patching regularly,
    Captain Hashjack might get the same image from a public registry to scan it for
    vulnerabilities they may be able to exploit. Knowing what binaries and files are
    available also enables attack planning “offline,” so adversaries can be more stealthy
    and targeted when attacking the live system.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'The OCI registry specification allows arbitrary image layer storage: it’s a
    two-step process and the first step uploads the manifest, with the second uploading
    the blob. If an attacker only performs the second step they gain free arbitrary
    blob storage.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Most registries don’t index this automatically (with Harbour being the exception),
    and so they will store the “orphaned” layers forever, potentially hidden from
    view until manually garbage collected.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we see an image referenced by label, which means we can’t tell what the
    actual SHA256 hash digest of the container image is. The container tag could have
    been updated since this deployment as it’s not referenced by digest:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Instead of using image tags, we can use the SHA256 image digests to pull the
    image by its content address:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Images should always be referenced by SHA256 or use signed tags; otherwise,
    it’s impossible to know what’s running as the label may have been updated in the
    registry since the container start. You can validate what’s being run by inspecting
    the running container for its image’s SHA256.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to specify both a tag and an SHA256 digest in a Kubernetes `image:`
    key, in which case the tag is ignored and the image is retrieved by digest. This
    leads to potentially confusing image definitions including a tag and SHA256 such
    as the following being retrieved as the image matching the SHA rather than the
    tag:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_pod_level_resources_CO1-1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Container name, plus the ignored “latest” tag
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_pod_level_resources_CO1-2)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: Image SHA256, which overrides the “latest” tag defined in the previous line
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: being retrieved as the image matching the SHA rather than the tag.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'If an attacker can influence the local `kubelet` image cache, they can add
    malicious code to an image and relabel it on the worker node (note: to run this
    again, don’t forget to remove the `cidfile`):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_pod_level_resources_CO2-1)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Load a malicious shell backdoor and overwrite the container’s default command
    (`/bin/sh`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_pod_level_resources_CO2-2)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Commit the changed container using the same.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: While the compromise of a local registry cache may lead to this attack, container
    cache access probably comes by rooting the node, and so this may be the least
    of your worries.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The image pull policy of `Always` has a performance drawback in highly dynamic,
    “autoscaling from zero” environments such as Knative. When startup times are crucial,
    a potentially multisecond `imagePullPolicy` latency is unacceptable and image
    digests must be used.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'This attack on a local image cache can be mitigated with an image pull policy
    of `Always`, which will ensure the local tag matches what’s defined in the registry
    it’s pulled from. This is important and you should always be mindful of this setting:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Typos in container image names, or registry names, will deploy unexpected code
    if an adversary has “typosquatted” the image with a malicious container.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: This can be difficult to detect when only a single character changes—for example,
    `controlplan/hack` instead of `controlplane/hack`. Tools like Notary protect against
    this by checking for valid signatures from trusted parties. If a TLS-intercepting
    middleware box intercepts and rewrites an image tag, a spoofed image may be deployed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Again, TUF and Notary side-channel signing mitigates against this, as do other
    container signing approaches like `cosign`, as discussed in [Chapter 4](ch04.xhtml#ch-apps-supply-chain).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Pod Probes
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your liveness probes should be tuned to your application’s performance characteristics,
    and used to keep them alive in the stormy waters of your production environment.
    Probes inform Kubernetes if the application is incapable of fulfilling its specified
    purpose, perhaps through a crash or external system failure.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'The Kubernetes audit finding [TOB-K8S-024](https://oreil.ly/OWnq6) shows probes
    can be subverted by an attacker with the ability to schedule pods: without changing
    the pod’s `command` or `args` they have the power to make network requests and
    execute commands within the target container. This yields local network discovery
    to an attacker as the probes are executed by the `kubelet` on the host networking
    interface, and not from within the pod.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'A `host` header can be used here to enumerate the local network. The proof
    of concept exploit is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: CPU and Memory Limits and Requests
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Resource limits and requests which manage the pod’s `cgroups` prevent the exhaustion
    of finite memory and compute resources on the `kubelet` host, and defend from
    fork bombs and runaway processes. Networking bandwidth limits are not supported
    in the pod spec, but may be supported by your CNI implementation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '`cgroups` are a useful resource constraint. `cgroups` v2 offers more protection,
    but `cgroups` v1 are not a security boundary and [they can be escaped easily](https://oreil.ly/uDhso).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Limits restrict the potential cryptomining or resource exhaustion that a malicious
    container can execute. It also stops the host becoming overwhelmed by bad deployments.
    It has limited effectiveness against an adversary looking to further exploit the
    system unless they need to use a memory-hungry attack:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: DNS
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default Kubernetes DNS servers provide all records for services across the
    cluster, preventing namespace segregation unless deployed individually per-namespace
    or domain.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: CoreDNS supports policy plug-ins, including OPA, to restrict access to DNS records
    and defeat the following enumeration attacks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: The default Kubernetes CoreDNS installation leaks information about its services,
    and offers an attacker a view of all possible network endpoints (see [Figure 2-10](#tweet-rory-hard-dns)).
    Of course they may not all be accessible due to a network policy in place, as
    we will see in [“Traffic Flow Control”](ch05.xhtml#workload-network-policies).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'DNS enumeration can be performed against a default, unrestricted CoreDNS installation.
    To retrieve all services in the cluster namespace (output edited to fit):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![tweet-rory-hard-dns](Images/haku_0211.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: Figure 2-10\. The wisdom of Rory McCune on the difficulties of hard multitenancy
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'For all service endpoints and names do the following (output edited to fit):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To return an IPv4 address based on the query:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Kubernetes API server service IP information is mounted into the pod’s
    environment by default:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The response matches the API server’s `/version` endpoint.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can detect Kubernetes API servers with [this nmap script](https://oreil.ly/PAqte)
    and the following function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next up is an important runtime policy piece: the securityContext, initially
    introduced by Red Hat.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Pod securityContext
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pod is running with an empty `securityContext`, which means that without
    admission controllers mutating the configuration at deployment time, the container
    can run a root-owned process and has all capabilities available to it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exploiting the capability landscape involves an understanding of the kernel’s
    flags, and [Stefano Lanaro’s guide](https://oreil.ly/mtvCX) provides a comprehensive
    overview.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Different capabilities may have particular impact on a system, and `CAP_SYS_ADMIN`
    and `CAP_BPF` are particularly enticing to an attacker. Notable capabilities you
    should be cautious about granting include:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_DAC_OVERRIDE`, `CAP_CHOWN`, `CAP_DAC_READ_SEARCH`, `CAP_FORMER`, `CAP_SETFCAP`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Bypass filesystem permissions
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_SETUID`, `CAP_SETGID`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Become the root user
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_NET_RAW`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Read network traffic
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_SYS_ADMIN`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Filesystem mount permission
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_SYS_PTRACE`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: All-powerful debugging of other processes
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_SYS_MODULE`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Load kernel modules to bypass controls
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_PERFMON`, `CAP_BPF`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Access deep-hooking BPF systems
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: These are the precursors for many container breakouts. As [Brad Geesaman](https://oreil.ly/swfMU)
    points out in [Figure 2-11](#tweet-brad-not-a-container-escape), processes want
    to be free! And an adversary will take advantage of anything within the pod they
    can use to escape.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '![haku 0212](Images/haku_0212.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
- en: Figure 2-11\. Brad Geesaman’s evocative container freedom cry
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`CAP_NET_RAW` is enabled by default in `runc`, and enables UDP (which bypasses
    TCP service meshes like Istio), ICMP messages, and ARP poisoning attacks. [Aqua
    found DNS poisoning attacks](https://oreil.ly/ceARf) against Kubernetes DNS, and
    the `net.ipv4.ping_group_range` `sysctl` flag means [it should be dropped when
    needed for ICMP](https://oreil.ly/tJ7rQ).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: 'These are some container breakouts requiring `root` and/or `CAP_SYS_ADMIN`,
    `CAP_NET_RAW`, `CAP_BPF`, or `CAP_SYS_MODULE` to function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: Subpath volume mount traversal and */proc/self/exe* (both described in [Chapter 6](ch06.xhtml#ch-storage)).
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CVE-2016-5195](https://oreil.ly/ZdYJ8) is a read-only memory copy-on-write
    race condition, aka DirtyCow, and detailed in [“Architecting Containerized Apps
    for Resilience”](ch04.xhtml#architecting-apps-resilience).'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CVE-2020-14386](https://oreil.ly/Scrau) is an unprivileged memory corruption
    bug that requires `CAP_NET_RAW`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CVE-2021-30465](https://oreil.ly/QzkuG), `runc` mount destinations symlink-exchange
    swap to mount outside the `rootfs`, limited by use of unprivileged user.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CVE-2021-22555](https://oreil.ly/Zj1Rl) is a `Netfilter` heap out-of-bounds
    write that requires `CAP_NET_RAW`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[CVE-2021-31440](https://oreil.ly/VLeQK) is `eBPF` out-of-bounds access to
    the Linux kernel requiring root or `CAP_BPF`, and `CAPS_SYS_MODULE`.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[@andreyknvl](https://oreil.ly/wlzra) kernel bugs and [`core_pattern` escape](https://oreil.ly/RWlF0).'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When there’s no breakout, root capabilities are still required for a number
    of other attacks, such as [CVE-2020-10749](https://oreil.ly/XoxVW) which are Kubernetes
    CNI plug-in person-in-the-middle (PitM) attacks via IPv6 rogue router advertisements.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-323
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The excellent [“A Compendium of Container Escapes”](https://oreil.ly/LAGB9)
    goes into more detail on some of these attacks.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: We enumerate the options available in a `securityContext` for a pod to defend
    itself from hostile containers in [“Runtime Policies”](ch08.xhtml#policy-runtime-policies).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: Pod Service Accounts
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Service Accounts are JSON Web Tokens (JWTs) and are used by a pod for authentication
    and authorization to the API server. The default service account shouldn’t be
    given any permissions, and by default comes with no authorization.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: 'A pod’s `serviceAccount` configuration defines its access privileges with the
    API server; see [“Service accounts”](ch08.xhtml#service-accounts) for the details.
    The service account is mounted into all pod replicas, and which share the single
    “workload identity”:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Segregating duty in this way reduces the blast radius if a pod is compromised:
    limiting an attacker post-intrusion is a primary goal of policy controls.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: Scheduler and Tolerations
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scheduler is responsible for allocating a pod workload to a node. It looks
    as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A hostile scheduler could conceivably exfiltrate data or workloads from the
    cluster, but requires the cluster to be compromised in order to add it to the
    control plane. It would be easier to schedule a privileged container and root
    the control plane `kubelets`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Pod Volume Definitions
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here we are using a bound service account token, defined in YAML as a projected
    service account token (instead of a standard service account). The `kubelet` protects
    this against exfiltration by regularly rotating it (configured for every 3600
    seconds, or one hour), so it’s only of limited use if stolen. An attacker with
    persistence is still able to use this value, and can observe its value after it’s
    rotated, so this only protects the service account after the attack has completed:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Volumes are a rich source of potential data for an attacker, and you should
    ensure that standard security practices like discretionary access control (DAC,
    e.g., files and permissions) is correctly configured.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The downward API reflects Kubernetes-level values into the containers in the
    pod, and is useful to expose things like the pod’s name, namespace, UID, and labels
    and annotations into the container. It’s capabilities are [listed in the documentation](https://oreil.ly/UyC90).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: A container is just Linux, and will not protect its workload from incorrect
    configuration.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: Pod Network Status
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Network information about the pod is useful to debug containers without services,
    or that aren’t responding as they should, but an attacker might use this information
    to connect directly to a pod without scanning the network:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using the securityContext Correctly
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pod is more likely to be compromised if a `securityContext` is not configured,
    or is too permissive. The `securityContext` is your most effective tool to prevent
    container breakout.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: After gaining an RCE into a running pod, the `securityContext` is the first
    line of defensive configuration you have available. It has access to kernel switches
    that can be set individually. Additional Linux Security Modules can be configured
    with fine-grained policies that prevent hostile applications taking advantage
    of your systems.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker’s `containerd` has a default `seccomp` profile that has prevented some
    zero-day attacks against the container runtime by blocking system calls in the
    kernel. From Kubernetes v1.22 you should enable this by default for all runtimes
    with the `--seccomp-default` `kubelet` flag. In some cases workloads may not run
    with the default profile: observability or security tools may require low-level
    kernel access. These workloads should have custom `seccomp` profiles written (rather
    than resorting to running them `Unconfined`, which allows any system call).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a fine-grained `seccomp` profile loaded from the host’s
    filesystem under `/var/lib/kubelet/seccomp`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`seccomp` is for system calls, but SELinux and AppArmor can monitor and enforce
    policy in userspace too, protecting files, directories, and devices.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: SELinux configuration is able to block most container breakouts (excluding with
    a label-based approach to filesystem and process access) as it doesn’t allow containers
    to write anywhere but their own filesystem, nor to read other directories, and
    comes enabled on OpenShift and Red Hat Linuxes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'AppArmor can similarly monitor and prevent many attacks in Debian-derived Linuxes.
    If AppArmor is enabled, then `cat /sys/module/apparmor/parameters/enabled` returns
    `Y`, and it can be used in pod definitions:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `privileged` flag was quoted as being “the most dangerous flag in the history
    of computing” by Liz Rice, but why are privileged containers so dangerous? Because
    they leave the process namespace enabled to give the illusion of containerization,
    but actually disable all security features.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '“Privileged” is a specific `securityContext` configuration: all but the process
    namespace is disabled, virtual filesystems are unmasked, LSMs are disabled, and
    all capabilities are granted.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: 'Running as a nonroot user without capabilities, and setting `AllowPrivilegeEscalation`
    to `false` provides a robust protection against many privilege escalations:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The granularity of security contexts means each property of the configuration
    must be tested to ensure it is not set: as a defender by configuring admission
    control and testing YAML or as an attacker with a dynamic test (or [amicontained](https://oreil.ly/BIQCJ))
    at runtime.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-360
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We explore how to detect privileges inside a container later in this chapter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: Sharing namespaces with the host also reduces the isolation of the container
    and opens it to greater potential risk. Any mounted filesystems effectively add
    to the mount namespace.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: Ensure your pods’ `securityContext`s are correct and your systems will be safer
    against known attacks.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the securityContext with Kubesec
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Kubesec](https://kubesec.io) is a simple tool to validate the security of
    a Kubernetes resource.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'It returns a risk score for the resource, and advises on how to tighten the
    `securityContext` (note that we edited the output to fit):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Kubesec.io](https://kubesec.io) documents practical changes to make to your
    securityContext, and we’ll document some of them here.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-369
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Shopify’s excellent [kubeaudit](https://oreil.ly/LHy2P) provides similar functionality
    for all resources in a cluster.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: Hardened securityContext
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The NSA published [“Kubernetes Hardening Guidance”](https://oreil.ly/2riDP),
    which recommends a hardened set of `securityContext` standards. It recommends
    scanning for vulnerabilities and misconfigurations, least privilege, good RBAC
    and IAM, network firewalling and encryption, and “to periodically review all Kubernetes
    settings and use vulnerability scans to help ensure risks are appropriately accounted
    for and security patches are applied.”
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Assigning least privilege to a container in a pod is the responsibility of the
    `securityContext` (see details in [Table 2-2](#sec-context-fields)). Note that
    the PodSecurityPolicy resource discussed in [“Runtime Policies”](ch08.xhtml#policy-runtime-policies)
    maps onto the config flags available in `securityContext`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-2\. `securityContext fields`
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: '| Field name(s) | Usage | Recommendations |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
- en: '| `privileged` | Controls whether pods can run privileged containers. | Set
    to `false`. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
- en: '| `hostPID`, `hostIPC` | Controls whether containers can share host process
    namespaces. | Set to `false`. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
- en: '| `hostNetwork` | Controls whether containers can use the host network. | Set
    to `false`. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
- en: '| `allowedHostPaths` | Limits containers to specific paths of the host filesystem.
    | Use a “dummy” path name (such as `/foo` marked as read-only). Omitting this
    field results in no admission restrictions being placed on containers. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
- en: '| `readOnlyRootFilesystem` | Requires the use of a read only root filesystem.
    | Set to `true` when possible. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
- en: '| `runAsUser`, `runAsGroup`, `supplementalGroups`, `fsGroup` | Controls whether
    container applications can run with root privileges or with root group membership.
    | Set `runAsUser` to `MustRunAsNonRoot`.Set `runAsGroup` to `nonzero`.Set `supplementalGroups`
    to `nonzero`.Set `fsGroup` to `nonzero`. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
- en: '| `allowPrivilegeEscalation` | Restricts escalation to root privileges. | Set
    to `false`. This measure is required to effectively enforce `runAsUser: MustRunAsNonRoot`
    settings. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
- en: '| `SELinux` | Sets the SELinux context of the container. | If the environment
    supports SELinux, consider adding SELinux labeling to further harden the container.
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
- en: '| `AppArmor` annotations | Sets the AppArmor profile used by containers. |
    Where possible, harden containerized applications by employing AppArmor to constrain
    exploitation. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
- en: '| `seccomp` annotations | Sets the `seccomp` profile used to sandbox containers.
    | Where possible, use a `seccomp` auditing profile to identify required syscalls
    for running applications; then enable a `seccomp` profile to block all other syscalls.
    |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
- en: Let’s explore these in more detail using the `kubesec` static analysis tool,
    and the selectors it uses to interrogate your Kubernetes resources.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: containers[] .securityContext .privileged
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A privileged container running is potentially a bad day for your security team.
    Privileged containers disable namespaces (except `process`) and LSMs, grant all
    capabilities, expose the host’s devices through */dev*, and generally make things
    insecure by default. This is the first thing an attacker looks for in a newly
    compromised pod.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: .spec .hostPID
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`hostPID` allows traversal from the container to the host through the */proc*
    filesystem, which symlinks other processes’ root filesystems. To read from the
    host’s process namespace, `privileged` is needed as well:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](Images/1.png)](#co_pod_level_resources_CO3-1)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Start a privileged container and share the host process namespace.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](Images/2.png)](#co_pod_level_resources_CO3-2)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: As the root user in the container, check the container’s operating system version.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](Images/3.png)](#co_pod_level_resources_CO3-3)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Verify we’re in the host’s process namespace (we can see PID 1, and kernel helper
    processes).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](Images/4.png)](#co_pod_level_resources_CO3-4)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: Check the distribution version of the host, via the */proc* filesystem inside
    the containe. This is possible because the PID namespace is shared with the host.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Without `privileged`, the host process namespace is inaccessible to root in
    the container:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case the attacker is limited to searching the filesystem or memory as
    their UID allows, hunting for key material or sensitive data.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: .spec .hostNetwork
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Host networking access allows us to sniff traffic or send fake traffic over
    the host adapter (but only if we have permission to do so, enabled by `CAP_NET_RAW`
    or `CAP_NET_ADMIN`), and evade network policy (which depends on traffic originating
    from the expected source IP of the adapter in the pod’s network namespace).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: It also grants access to services bound to the host’s loopback adapter (`localhost`
    in the root network namespace) that traditionally was considered a security boundary.
    Server Side Request Forgery (SSRF) attacks have reduced the incidence of this
    pattern, but it may still exist (Kubernetes’ API server `--insecure-port` used
    this pattern until it was deprecated in v1.10 and finally removed in v1.20).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: .spec .hostAliases
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Permits pods to override their local */etc/hosts* files. This may have more
    operational implications (like not being updated in a timely manner and causing
    an outage) than security connotations.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: .spec .hostIPC
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gives the pod access to the host’s Interprocess Communication namespace, where
    it may be able to interfere with trusted processes on the host. It’s likely this
    will enable simple host compromise via */usr/bin/ipcs* or files in shared memory
    at */dev/shm*.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: containers[] .securityContext .runAsNonRoot
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The root user has special permissions in a Linux system, and although the permissions
    set is reduced within a container, the root user is still treated differently
    by lots of kernel code.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: Preventing root from owning the processes inside the container is a simple and
    effective security measure. It stops many of the container breakout attacks listed
    in this book, and adheres to standard and established Linux security practice.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: containers[] .securityContext .runAsUser > 10000
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In addition to preventing root running processes, enforcing high UIDs for containerized
    processes lowers the risk of breakout without user namespaces: if the user in
    the container (e.g., 12345) has an equivalent UID on the host (that is, also 12345),
    and the user in the container is able to reach them through mounted volume or
    shared namespace, then resources may accidentally be shared and allow container
    breakout (e.g., filesystem permissions and authorization checks).'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: containers[] .securityContext .readOnlyRootFilesystem
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Immutability is not a security boundary as code can be downloaded from the
    internet and run by an interpreter (such as Bash, PHP, and Java) without using
    the filesystem, as the `bashark` post-exploitation toolkit shows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Filesystem locations like */tmp* and */dev/shm* will probably always be writable
    to support application behavior, and so read-only filesystems cannot be relied
    upon as a security boundary. Immutability will prevent against some drive-by and
    automated attacks, but is not a robust security boundary.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
- en: Intrusion detection tools such as `falco` and `tracee` can detect new Bash shells
    spawned in a container (or any non-allowlisted applications). Additionally `tracee`
    can [detect in-memory execution](https://oreil.ly/Ur0wV) of malware that attempts
    to hide itself by observing */proc/pid/maps* for memory that was once writable
    but is now executable.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We look at Falco in more detail in [Chapter 9](ch09.xhtml#ch-intrusion-detection).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: containers[] .securityContext .capabilities .drop | index(“ALL”)
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should always drop all capabilities and only readd those that your application
    needs to operate.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: containers[] .securityContext .capabilities .add | index(“SYS_ADMIN”)
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The presence of this capability is a red flag: try to find another way to deploy
    any container that requires this, or deploy into a dedicated namespace with custom
    security rules to limit the impact of compromise.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: containers[] .resources .limits .cpu, .memory
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Limiting the total amount of memory available to a container prevents denial
    of service attacks taking out the host machine, as the container dies first.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: containers[] .resources .requests .cpu, .memory
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Requesting resources helps the scheduler to “bin pack” resources effectively.
    Over-requesting resources may be an adversary’s attempt to schedule new pods to
    another Node they control.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: .spec .volumes[] .hostPath .path
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A writable */var/run/docker.sock* host mount allows breakout to the host. Any
    filesystem that an attacker can write a symlink to is vulnerable, and an attacker
    can use that path to explore and exfiltrate from the host.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: Into the Eye of the Storm
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Captain and crew have had a fruitless raid, but this is not the last we
    will hear of their escapades.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through this book, we will see how Kubernetes pod components
    interact with the wider system, and we will witness Captain Hashjack’s efforts
    to exploit them.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple layers of configuration to secure for a pod to be used safely,
    and the workloads you run are the soft underbelly of Kubernetes security.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: The pod is the first line of defense and the most important part of a cluster
    to protect. Application code changes frequently and is likely to be a source of
    potentially exploitable bugs.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
- en: To extend the anchor and chain metaphor, a cluster is only a strong as its weakest
    link. In order to be provably secure, you must use robust configuration testing,
    preventative control and policy in the pipeline and admission control, and runtime
    intrusion detection—as nothing is infallible.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
