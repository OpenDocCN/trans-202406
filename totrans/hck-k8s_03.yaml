- en: Chapter 2\. Pod-Level Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章\. Pod 级资源
- en: 'This chapter concerns the atomic unit of Kubernetes deployment: a pod. Pods
    run apps, and an app may be one or more containers working together in one or
    more pods.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涉及 Kubernetes 部署的原子单位：Pod。Pod 运行应用程序，一个应用程序可以是一个或多个容器在一个或多个 Pod 中协作。
- en: We’ll consider what bad things can happen in and around a pod, and look at how
    you can mitigate the risk of getting attacked.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑 Pod 内外可能发生的不良情况，并探讨如何减少被攻击的风险。
- en: As with any sensible security effort, we’ll begin by defining a lightweight
    threat model for your system, identifying the threat actors it defends against,
    and highlighting the most dangerous threats. This gives you a solid basis to devise
    countermeasures and controls, and take defensive steps to protect your customer’s
    valuable data.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何合理的安全工作一样，我们将从为系统定义一个轻量级威胁模型开始，确定它所防范的威胁行为者，并强调最危险的威胁。这为您制定对策和控制措施，采取防御措施以保护客户的宝贵数据提供了坚实的基础。
- en: We’ll go deep into the security model of a pod and look at what is trusted by
    default, where we can tighten security with configuration, and what an attacker’s
    journey looks like.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将深入探讨 Pod 的安全模型，看看默认情况下哪些是可信的，我们可以通过配置加强安全性，以及攻击者的路径是什么样的。
- en: Defaults
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 默认设置
- en: Kubernetes has historically not been security hardened out of the box, and sometimes
    this may lead to privilege escalation or container breakout.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 在历史上并没有默认安全强化，有时这可能导致特权升级或容器突破。
- en: If we zoom in on the relationship between a single pod and the host in [Figure 2-1](#pod-diagram-temp),
    we can see the services offered to the container by the `kubelet` and potential
    security boundaries that may keep an adversary at bay.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们放大单个 Pod 与主机之间的关系，如 [图 2-1](#pod-diagram-temp) 所示，我们可以看到 `kubelet` 为容器提供的服务以及可能将对手阻挡在外的安全边界。
- en: By default much of this is sensibly configured with least privilege, but where
    user-supplied configuration is more common (pod YAML, cluster policy, container
    images) there are more opportunities for accidental or malicious misconfiguration.
    Most defaults are sane—in this chapter we will show you where they are not, and
    demonstrate how to test that your clusters and workloads are configured securely.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，大部分都以最低特权合理配置，但用户提供的配置更普遍时（如 Pod YAML、集群策略、容器镜像），就会有更多意外或恶意误配置的机会。大多数默认值是合理的——本章中我们将向您展示它们的不足，并演示如何测试您的集群和工作负载是否安全配置。
- en: '![Pod Architecture](Images/haku_0201.png)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Pod 架构](Images/haku_0201.png)'
- en: Figure 2-1\. Pod architecture
  id: totrans-10
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-1\. Pod 架构
- en: Threat Model
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 威胁模型
- en: 'We define a scope for each threat model. Here, you are threat modeling a pod.
    Let’s consider a simple group of Kubernetes threats to begin with:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为每个威胁模型定义一个范围。在这里，您正在对 Pod 进行威胁建模。让我们首先考虑 Kubernetes 威胁的一个简单组：
- en: '[Attacker on the network](https://oreil.ly/PoRXb)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[网络上的攻击者](https://oreil.ly/PoRXb)'
- en: Sensitive endpoints (such as the API server) can be attacked easily if public.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 敏感端点（如 API 服务器）如果公开，可以轻易遭受攻击。
- en: '[Compromised application leads to foothold in container](https://oreil.ly/CYG04)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[受损应用程序导致容器内的立足点](https://oreil.ly/CYG04)'
- en: A compromised application (remote code execution, supply chain compromise) is
    the start of an attack.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 被攻击的应用程序（远程代码执行、供应链妥协）是攻击的开始。
- en: '[Establish persistence](https://oreil.ly/zJGhK)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[建立持久性](https://oreil.ly/zJGhK)'
- en: Stealing credentials or gaining persistence resilient to pod, node, and/or container
    restarts.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 窃取凭据或获得对 Pod、节点和/或容器重启具有韧性的持久性。
- en: '[Malicious code execution](https://oreil.ly/POnQ9)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[恶意代码执行](https://oreil.ly/POnQ9)'
- en: Running exploits to pivot or escalate and enumerating endpoints.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 运行利用程序进行枢轴或升级并枚举端点。
- en: '[Access sensitive data](https://oreil.ly/agQ7E)'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '[访问敏感数据](https://oreil.ly/agQ7E)'
- en: Reading Secret data from the API server, attached storage, and network-accessible
    datastores.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 从 API 服务器、附加存储和可通过网络访问的数据存储读取机密数据。
- en: '[Denial of service](https://oreil.ly/nr7Cb)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[服务拒绝](https://oreil.ly/nr7Cb)'
- en: Rarely a good use of an attacker’s time. Denial of Wallet and cryptolocking
    are common variants.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 很少是攻击者的时间的好用法。钱包拒绝和加密锁定是常见的变体。
- en: Tip
  id: totrans-25
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The threat sources in [“Prior Art”](ch01.xhtml#PriorArt) have other negative
    outcomes to cross-reference with this list.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[“先前的艺术”](ch01.xhtml#PriorArt) 中的威胁源具有其他负面结果可供参考。'
- en: Anatomy of the Attack
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击解剖学
- en: '![captain](Images/haku_0000.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![captain](Images/haku_0000.png)'
- en: Captain Hashjack started their assault on your systems by enumerating BCTL’s
    DNS subdomains and S3 buckets. These could have offered an easy way into the organization’s
    systems, but there was nothing easily exploitable on this occasion.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Hashjack 船长通过枚举 BCTL 的 DNS 子域和 S3 存储桶开始了对您系统的攻击。这些可能为组织的系统提供了一个简单的入口，但在这个场合上，并没有什么容易被利用的。
- en: Undeterred, they create an account on the public website and log in, using a
    web application scanner like [zaproxy](https://www.zaproxy.org) (OWASP Zed Attack
    Proxy) to pry into API calls and application code for unexpected responses. They’re
    on the search for leaking web-server banner and version information (to learn
    which exploits might succeed) and are generally injecting and fuzzing APIs for
    poorly handled user input.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 他们不屈不挠地在公共网站上创建了一个帐户并登录，使用像[zaproxy](https://www.zaproxy.org)（OWASP Zed Attack
    Proxy）这样的 Web 应用程序扫描器来探查 API 调用和应用程序代码的意外响应。他们在寻找泄漏的 Web 服务器标语和版本信息（以了解可能成功的利用）以及通常注入和模糊
    API 以处理不当处理的用户输入。
- en: This is not a level of scrutiny that your poorly maintained codebase and systems
    are likely to withstand for long. Attackers may be searching for a needle in a
    haystack, but only the safest haystack has no needles at all.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这并非您的维护不善的代码库和系统能够长期经受的审查水平。攻击者可能在大海捞针，但只有最安全的干草堆根本没有针。
- en: Caution
  id: totrans-32
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Any computer should be resistant to this type of indiscriminate attack: a Kubernetes
    system should achieve “minimum viable security” through the capability to protect
    itself from casual attack with up-to-date software and hardened configuration.
    Kubernetes encourages regular updates by supporting the last three minor releases
    (e.g., 1.24, 1.23, and 1.22), which are released every 4 months and ensure a year
    of patch support. Older versions are unsupported and likely to be vulnerable.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 任何计算机都应该对这种不加选择的攻击类型保持抵抗力：一个 Kubernetes 系统应该通过能力来保护自己免受普通攻击，并使用最新的软件和加固的配置达到“最小可行安全性”。Kubernetes
    通过支持最后三个次要版本发布（例如，1.24、1.23 和 1.22），每 4 个月发布一次，确保一年的补丁支持，鼓励定期更新。旧版本不受支持，可能存在漏洞。
- en: Although many parts of an attack can be automated, this is an involved process.
    A casual attacker is more likely to scan widely for software paths that trigger
    published CVEs and run automated tools and scripts against large ranges of IPs
    (such as the ranges advertised by public cloud providers). These are noisy approaches.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管攻击的许多部分可以自动化进行，但这是一个复杂的过程。一个普通的攻击者更可能广泛扫描触发已发布 CVE 的软件路径，并对大范围的 IP 地址（如公共云提供商广告的范围）运行自动化工具和脚本。这些方法很喧闹。
- en: Remote Code Execution
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 远程代码执行
- en: 'If a vulnerability in your application can be used to run untrusted (and in
    this case, external) code, it is called a remote code execution (RCE). An adversary
    can use an RCE to spawn a remote control session into the application’s environment:
    here it is the container handling the network request, but if the RCE manages
    to pass untrusted input deeper into the system, it may exploit a different process,
    pod, or cluster.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序中存在漏洞可以用来运行不受信任的（在这种情况下，是外部的）代码，则称为远程代码执行（RCE）。对手可以使用 RCE 生成一个远程控制会话到应用程序的环境：在这里，是处理网络请求的容器，但如果
    RCE 成功将不受信任的输入传递到系统更深层，它可能利用不同的进程、Pod 或集群。
- en: Your first goal of Kubernetes and pod security should be to prevent RCE, which
    could be as simple as a `kubectl exec`, or as complex as a reverse shell, such
    as the one demonstrated in [Figure 2-2](#pods-reverse-shell).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 您在 Kubernetes 和 Pod 安全的首要目标应是防止 RCE，这可能就像一个 `kubectl exec` 那样简单，或者像反向 shell
    那样复杂，例如[图 2-2](#pods-reverse-shell)中演示的。
- en: '![haku 0202](Images/haku_0202.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![haku 0202](Images/haku_0202.png)'
- en: Figure 2-2\. Reverse shell into a Kubernetes pod
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-2\. 反向 shell 进入 Kubernetes Pod
- en: Application code changes frequently and may hide undiscovered bugs, so robust
    application security (AppSec) practices (including IDE and CI/CD integration of
    tooling and dedicated security requirements as task acceptance criteria) are essential
    to keep an attacker from compromising the processes running in a pod.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序代码经常发生变化，并可能隐藏未发现的错误，因此强大的应用程序安全（AppSec）实践（包括工具的IDE和CI/CD集成以及专用安全要求作为任务验收标准）对于防止攻击者威胁到运行在
    Pod 中的进程至关重要。
- en: Note
  id: totrans-41
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The Java framework Struts was one of the most widely deployed libraries to have
    suffered a remotely exploitable vulnerability (CVE-2017-5638), which contributed
    to the breach of Equifax customer data. To fix a supply chain vulnerability like
    this in a container, it is quickly rebuilt in CI with a patched library and redeployed,
    reducing the risk window of vulnerable libraries being exposed to the internet.
    We examine other ways to get remote code execution throughout the book.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Java 框架 Struts 是最广泛部署的库之一，曾经遭受过远程可利用的漏洞 (CVE-2017-5638)，这导致了 Equifax 客户数据的泄露。为了修复容器中这样的供应链漏洞，可以在
    CI 中快速重建并部署带有补丁的库，从而减少容易受到互联网攻击的脆弱库的风险窗口。我们在全书中探讨其他获得远程代码执行的方式。
- en: With that, let’s move on to the network aspects.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向网络方面。
- en: Network Attack Surface
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络攻击面
- en: The greatest attack surface of a Kubernetes cluster is its network interfaces
    and public-facing pods. Network-facing services such as web servers are the first
    line of defense in keeping your clusters secure, a topic we will dive into in
    [Chapter 5](ch05.xhtml#ch-networking).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 集群的最大攻击面是其网络接口和面向公众的 pod。网络接口服务，如 web 服务器，在保持集群安全性方面是第一道防线，这是我们将在
    [第五章](ch05.xhtml#ch-networking) 中深入探讨的话题。
- en: This is because unknown users coming in from across the network can scan network-facing
    applications for the exploitable signs of RCE. They can use automated network
    scanners to attempt to exploit known vulnerabilities and input-handling errors
    in network-facing code. If a process or system can be forced to run in an unexpected
    way, there is the possibility that it can be compromised through these untested
    logic paths.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为从网络跨界而来的未知用户可以扫描面向网络的应用程序，以查找远程代码执行的可利用迹象。他们可以使用自动化网络扫描工具尝试利用已知漏洞和输入处理错误在面向网络的代码中。如果一个进程或系统被迫以意外的方式运行，那么通过这些未经测试的逻辑路径可能会被攻击。
- en: To investigate how an attacker may establish a foothold in a remote system using
    only the humble, all-powerful Bash shell, see, for example, Chapter 16 of [*Cybersecurity
    Ops with bash*](https://oreil.ly/ZmILo) by Paul Troncone and Carl Albing (O’Reilly).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解攻击者如何仅仅通过谦逊而强大的 Bash shell 在远程系统中建立立足点的例子，请参见 Paul Troncone 和 Carl Albing
    的 [*Cybersecurity Ops with bash*](https://oreil.ly/ZmILo) 第 16 章。
- en: To defend against this, we must scan containers for operating system and application
    CVEs in the hope of updating them before they are exploited.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要抵御这种情况，我们必须扫描容器中的操作系统和应用程序 CVE，希望在它们被利用之前更新它们。
- en: If Captain Hashjack has an RCE into a pod, it’s a foothold to attack your system
    more deeply from the pod’s network position and permissions set. You should strive
    to limit what an attacker can do from this position, and customize your security
    configuration to a workload’s sensitivity. If your controls are too loose, this
    may be the beginning of an organization-wide breach for your employer, BCTL.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 Hashjack 队长能够在一个 pod 中实现 RCE，那么这是从 pod 的网络位置和权限设置更深入地攻击系统的立足点。您应该努力限制攻击者可以从此位置做的事情，并根据工作负载的敏感性定制您的安全配置。如果您的控制过于宽松，这可能是您雇主
    BCTL 组织范围内的一次漏洞起源。
- en: Tip
  id: totrans-50
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: For an example of spawning a shell via Struts with Metasploit, see [Sam Bowne’s
    guide](https://oreil.ly/nzsxP).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解通过 Struts 和 Metasploit 生成 shell 的示例，请参阅 [Sam Bowne 的指南](https://oreil.ly/nzsxP)。
- en: As Dread Pirate Hashjack has just discovered, we have also been running a vulnerable
    version of the Struts library. This offers an opportunity to start attacking the
    cluster from within.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 Dread Pirate Hashjack 刚刚发现的那样，我们还在运行一个容易受攻击的 Struts 库版本。这为从内部攻击集群提供了一个机会。
- en: Warning
  id: totrans-53
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'A simple Bash reverse shell like this one is a good reason to remove Bash from
    your containers. It uses Bash’s virtual */dev/tcp/* filesystem, and is not exploitable
    in `sh`, which doesn’t include this oft-abused feature:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 像这样一个简单的 Bash 反向 shell 是移除容器中 Bash 的一个好理由。它使用了 Bash 的虚拟 */dev/tcp/* 文件系统，并且在
    `sh` 中是不可利用的，因为它不包括这个经常被滥用的功能：
- en: '[PRE0]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As the attack begins, let’s take a look at where the pirates have landed: inside
    a Kubernetes pod.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 攻击开始时，让我们看看海盗们已经登陆的地方：在一个 Kubernetes pod 内部。
- en: 'Kubernetes Workloads: Apps in a Pod'
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 工作负载：Pod 中的应用程序
- en: Multiple cooperating containers can be logically grouped into a single pod,
    and every container Kubernetes runs must run inside a pod. Sometimes a pod is
    called a “workload,” which is one of many copies of the same execution environment.
    Each pod must run on a Node in your Kubernetes cluster as shown in [Figure 2-3](#pod-cluster-example).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: A pod is a single instance of your application, and to scale to demand, many
    identical pods are used to replicate the application by a workload resource (such
    as a Deployment, DaemonSet, or StatefulSet).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Your pods may include sidecar containers supporting monitoring, network, and
    security, and “init” containers for pod bootstrap, enabling you to deploy different
    application styles. These sidecars are likely to have elevated privileges and
    be of interest to an adversary.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: “Init” containers run in order (first to last) to set up a pod and can make
    security changes to the namespaces, like Istio’s init container that configures
    the pod’s *iptables* (in the kernel’s netfilter) so the runtime (non-init container)
    pods route traffic through a sidecar container. Sidecars run alongside the primary
    container in the pod, and all non-init containers in a pod start at the same time.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Cluster deployment example](Images/haku_0203.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-3\. Cluster deployment example; source: [Kubernetes documentation](https://oreil.ly/Co9Hx)'
  id: totrans-63
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: What’s inside a pod? Cloud native applications are often microservices, web
    servers, workers, and batch processes. Some pods run one-shot tasks (wrapped with
    a job, or maybe one single nonrestarting container), perhaps running multiple
    other pods to assist. All these pods present an opportunity to an attacker. Pods
    get hacked. Or, more often, a network-facing container process gets hacked.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: A pod is a trust boundary encompassing all the containers inside, including
    their identity and access. There is still separation between pods that you can
    enhance with policy configuration, but you should consider the entire contents
    of a pod when threat modeling it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Kubernetes is a distributed system, and ordering of actions (such as applying
    a multidoc YAML file) is eventually consistent, meaning that API calls don’t always
    complete in the order that you expect. Ordering depends on various factors and
    shouldn’t be relied upon. Tabitha Sable has a mechanically sympathetic definition
    of Kubernetes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![tabby sable](Images/haku_0204.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: What’s a Pod?
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A pod as depicted in [Figure 2-4](#pod-examples) is a Kubernetes invention.
    It’s an environment for multiple containers to run inside. The pod is the smallest
    deployable unit you can ask Kubernetes to run and all containers in it will be
    launched on the same node. A pod has its own IP address, can mount in storage,
    and its namespaces surround the containers created by the container runtime such
    as `containerd` or CRI-O.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '![Example pods](Images/haku_0205.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-4\. Example pods (source: [Kubernetes documentation](https://oreil.ly/YwBSv))'
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A container is a mini-Linux, and its processes are containerized with control
    groups (`cgroups`) to limit resource usage and namespaces to limit access. A variety
    of other controls can be applied to restrict a containerized process’s behavior,
    as we’ll see in this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是一个迷你 Linux，其进程通过控制组（`cgroups`）进行容器化以限制资源使用，并通过命名空间限制访问。我们将在本章中看到，可以应用各种其他控制来限制容器化进程的行为。
- en: The lifecycle of a pod is controlled by the `kubelet`, the Kubernetes API server’s
    deputy, deployed on each node in the cluster to manage and run containers. If
    the `kubelet` loses contact with the API server, it will continue to manage its
    workloads, restarting them if necessary. If the `kubelet` crashes, the container
    manager will also keep containers running in case they crash. The `kubelet` and
    container manager oversee your workloads.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 的生命周期由 `kubelet` 控制，它是 Kubernetes API 服务器的代理，部署在集群中的每个节点上以管理和运行容器。如果 `kubelet`
    与 API 服务器失去联系，它将继续管理其工作负载，并在必要时重新启动它们。如果 `kubelet` 崩溃，容器管理器也将保持容器运行，以防止它们崩溃。`kubelet`
    和容器管理器监督您的工作负载。
- en: The `kubelet` runs pods on worker nodes to instruct the container runtime and
    configuring network and storage. Each container in a pod is a collection of Linux
    namespaces, `cgroups`, capabilities, and Linux Security Modules (LSMs). As the
    container runtime builds a container, each namespace is created and configured
    individually before being combined into a container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubelet` 在工作节点上运行 pod，指导容器运行时并配置网络和存储。每个 pod 中的容器是 Linux 命名空间、`cgroups`、功能和
    Linux 安全模块（LSM）的集合。当容器运行时构建容器时，每个命名空间都会被单独创建和配置，然后组合成容器。'
- en: Tip
  id: totrans-76
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: Capabilities are individual switches for “special” root user operations such
    as changing any file’s permissions, loading modules into the kernel, accessing
    devices in raw mode (e.g., networks and I/O), BPF and performance monitoring,
    and every other operation.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 功能是“特殊”根用户操作的单独开关，例如更改任何文件的权限、将模块加载到内核中、以原始模式访问设备（例如网络和 I/O）、BPF 和性能监控，以及所有其他操作。
- en: The root user has all capabilities, and capabilities can be granted to any process
    or user (“ambient capabilities”). Excess capability grants may lead to container
    breakout, as we see later in this chapter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: root 用户拥有所有功能，并且功能可以授予任何进程或用户（“环境功能”）。过多的功能授予可能导致容器突破，正如本章后面所见。
- en: In Kubernetes, a newly created container is added to the pod by the container
    runtime, where it shares network and interprocess communication namespaces between
    pod containers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kubernetes 中，容器运行时将新创建的容器添加到 pod 中，其中它与 pod 容器之间共享网络和进程间通信命名空间。
- en: '[Figure 2-5](#node-examples) shows a `kubelet` running four individual pods
    on a single node.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2-5](#node-examples) 显示一个 `kubelet` 在单个节点上运行四个独立的 pod。'
- en: 'The container is the first line of defense against an adversary, and container
    images should be scanned for CVEs before being run. This simple step reduces the
    risk of running an outdated or malicious container and informs your risk-based
    deployment decisions: do you ship to production, or is there an exploitable CVE
    that needs patching first?'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是对抗敌人的第一道防线，应在运行之前扫描容器镜像中的 CVEs。这一简单步骤减少了运行过时或恶意容器的风险，并影响您基于风险的部署决策：您是否将其部署到生产环境，还是需要先修补可利用的
    CVE？
- en: '![Example pods on a node](Images/haku_0206.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![节点上的示例 pod](Images/haku_0206.png)'
- en: 'Figure 2-5\. Example pods on a node (source: [Kubernetes documentation](https://oreil.ly/ksFim))'
  id: totrans-83
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-5\. 节点上的示例 pod（来源：[Kubernetes 文档](https://oreil.ly/ksFim)）
- en: Tip
  id: totrans-84
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: “Official” container images in public registries have a greater likelihood of
    being up to date and well-patched, and Docker Hub signs all official images with
    Notary, as we’ll see in [Chapter 4](ch04.xhtml#ch-apps-supply-chain).
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 公共注册表中的“官方”容器镜像更有可能保持最新并得到良好的修补，Docker Hub 通过 Notary 签署所有官方镜像，如我们将在[第 4 章](ch04.xhtml#ch-apps-supply-chain)中看到的那样。
- en: Public container registries often host malicious images, so detecting them before
    production is essential. [Figure 2-6](#app-poison-container-registry) shows how
    this might happen.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 公共容器注册表通常托管恶意镜像，因此在生产之前检测它们至关重要。[图 2-6](#app-poison-container-registry) 显示了这种情况可能发生的方式。
- en: The `kubelet` attaches pods to a Container Network Interface (CNI). CNI network
    traffic is treated as layer 4 TCP/IP (although the underlying network technology
    used by the CNI plug-in may differ), and encryption is the job of the CNI plug-in,
    the application, a service mesh, or at a minimum, the underlay networking between
    the nodes. If traffic is unencrypted, it may be sniffed by a compromised pod or
    node.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubelet`将pod连接到容器网络接口 (CNI)。CNI网络流量被视为第4层TCP/IP（尽管CNI插件使用的底层网络技术可能不同），加密是CNI插件、应用程序、服务网格或最少是节点之间的底层网络的工作。如果流量未加密，可能会被受损的pod或节点嗅探到。'
- en: '![Poisoning a public container registry](Images/haku_0207.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![中毒公共容器注册表](Images/haku_0207.png)'
- en: Figure 2-6\. Poisoning a public container registry
  id: totrans-89
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-6\. 毒害公共容器注册表
- en: Warning
  id: totrans-90
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Although starting a malicious container under a correctly configured container
    runtime is usually safe, there have been attacks against the container bootstrap
    phase. We examine the */proc/self/exe* breakout CVE-2019-5736 later in this chapter.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在正确配置的容器运行时下启动恶意容器通常是安全的，但曾经发生过针对容器引导阶段的攻击。我们将在本章后面审查*/proc/self/exe*越狱CVE-2019-5736。
- en: Pods can also have storage attached by Kubernetes, using the ([Container Storage
    Interface (CSI)](https://oreil.ly/S8v3B)), which includes the PersistentVolumeClaim
    and StorageClass shown in [Figure 2-7](#pod-cluster-example-2). In [Chapter 6](ch06.xhtml#ch-storage)
    we will get deeper into the storage aspects.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Pod也可以通过Kubernetes附加存储，使用([容器存储接口 (CSI)](https://oreil.ly/S8v3B))，其中包括PersistentVolumeClaim和StorageClass，显示在[图 2-7](#pod-cluster-example-2)中。在[第6章](ch06.xhtml#ch-storage)中，我们将更深入地探讨存储方面的内容。
- en: 'In [Figure 2-7](#pod-cluster-example-2) you can see a view of the control plane
    and the API server’s central role in the cluster. The API server is responsible
    for interacting with the cluster datastore (`etcd`), hosting the cluster’s extensible
    API surface, and managing the `kubelet`s. If the API server or `etcd` instance
    is compromised, the attacker has complete control of the cluster: these are the
    most sensitive parts of the system.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 2-7](#pod-cluster-example-2)中，您可以看到控制平面的视图和API服务器在集群中的核心角色。API服务器负责与集群数据存储(`etcd`)交互，托管集群的可扩展API表面，并管理`kubelet`。如果API服务器或`etcd`实例受到
    compromisation，攻击者将完全控制集群：这些是系统中最敏感的部分。
- en: '![Cluster Example 2](Images/haku_0208.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![集群示例2](Images/haku_0208.png)'
- en: 'Figure 2-7\. Cluster example 2 (source: [Tsuyoshi Ushio](https://oreil.ly/szUug))'
  id: totrans-95
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: '图 2-7\. 集群示例2 (来源: [Tsuyoshi Ushio](https://oreil.ly/szUug))'
- en: Warning
  id: totrans-96
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Vulnerabilities have been found in many storage drivers, including CVE-2018-11235,
    which exposed a Git attack on the `gitrepo` storage volume, and CVE-2017-1002101,
    a subpath volume mount mishandling error. We will cover these in [Chapter 6](ch06.xhtml#ch-storage).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 存储驱动中发现了多个漏洞，包括暴露了对`gitrepo`存储卷的Git攻击的CVE-2018-11235，以及子路径卷挂载处理错误的CVE-2017-1002101。我们将在[第6章](ch06.xhtml#ch-storage)中详细讨论这些问题。
- en: For performance in larger clusters, the control plane should run on separate
    infrastructure to `etcd`, which requires high disk and network I/O to support
    reasonable response times for its distributed consensus algorithm, [Raft](https://oreil.ly/V5lbf).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对于较大集群的性能，控制平面应在单独的基础设施上运行`etcd`，这需要高磁盘和网络I/O以支持其分布式一致性算法[Raft](https://oreil.ly/V5lbf)的合理响应时间。
- en: 'As the API server is the `etcd` cluster’s only client, compromise of either
    effectively roots the cluster: due to the asynchronous scheduling, in Kubernetes
    the injection of malicious, unscheduled pods into `etcd` will trigger their scheduling
    to a `kubelet`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于API服务器是`etcd`集群的唯一客户端，因此任何一方的妥协都将有效地使集群受到限制：由于异步调度，在Kubernetes中，向`etcd`注入恶意的未调度的pod将触发它们的调度到一个`kubelet`。
- en: As with all fast-moving software, there have been vulnerabilities in most parts
    of the Kubernetes stack. The only solution to running modern software is a healthy
    continuous integration infrastructure capable of promptly redeploying vulnerable
    clusters upon a vulnerability announcement.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有快速移动的软件一样，Kubernetes堆栈的大部分部分都存在漏洞。对现代软件的唯一解决方案是健康的持续集成基础设施，能够在漏洞公告后及时重新部署受损的集群。
- en: Understanding Containers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解容器
- en: Okay, so we have a high-level view of a cluster. But at a low level, what is
    a “container”? It is a microcosm of Linux that gives a process the illusion of
    a dedicated kernel, network, and userspace. Software trickery fools the process
    inside your container into believing it is the only process running on the host
    machine. This is useful for isolation and migration of your existing workloads
    into Kubernetes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经对集群有了一个高层次的视图。但在低层次上，“容器”是什么？它是 Linux 的微观世界，为一个进程提供了一个专用内核、网络和用户空间的幻觉。软件技巧让容器内的进程相信它是在主机上唯一运行的进程。这对于隔离和将现有工作负载迁移到
    Kubernetes 中是有用的。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As [Christian Brauner](https://oreil.ly/lBByx) and [Stéphane Graber](https://oreil.ly/DsmkD)
    like [to say](https://oreil.ly/sTkqN) “(Linux) containers are a userspace fiction,”
    a collection of configurations that present an illusion of isolation to a process
    inside. Containers emerged from the primordial kernel soup, a child of evolution
    rather than intelligent design that has been morphed, refined, and coerced into
    shape so that we now have something usable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[Christian Brauner](https://oreil.ly/lBByx)和[Stéphane Graber](https://oreil.ly/DsmkD)喜欢[说的](https://oreil.ly/sTkqN)，“（Linux）容器是一个用户空间的虚构”，一个配置集合，向内部进程呈现隔离的幻觉。容器起源于原始的内核汤，是演化的产物，而不是智能设计的产物，已经被改变、完善和强迫成形，以至于我们现在有了可用的东西。
- en: Containers don’t exist as a single API, library, or kernel feature. They are
    merely the resultant bundling and isolation that’s left over once the kernel has
    started a collection of namespaces, configured some `cgroups` and capabilities,
    added Linux Security Modules like AppArmor and SELinux, and started our precious
    little process inside.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 容器并不是作为单一的 API、库或内核特性存在的。它们只是在内核启动一组命名空间、配置一些`cgroups`和功能、添加 Linux 安全模块如 AppArmor
    和 SELinux，并在内部启动我们珍贵的小进程后剩下的捆绑和隔离结果。
- en: A container is a process in a special environment with some combination of namespaces
    either enabled or shared with the host (or other containers). The process comes
    from a container image, a TAR file containing the container’s root filesystem,
    its application(s), and any dependencies. When the image is unpacked into a directory
    on the host and a special filesystem “pivot root” is created, a “container” is
    constructed around it, and its `ENTRYPOINT` is run from the filesystem within
    the container. This is roughly how a container starts, and each container in a
    pod must go through this process.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一个容器是一个在特殊环境中的进程，具有一些命名空间的组合，这些命名空间可以启用或与主机（或其他容器）共享。该进程来自一个容器镜像，一个包含容器根文件系统、其应用程序和任何依赖项的
    TAR 文件。当镜像被解压到主机上的一个目录中并创建一个特殊的文件系统“pivot root”时，一个“容器”就围绕它构建起来，并且从容器内的文件系统中运行其`ENTRYPOINT`。这大致是一个容器启动的方式，一个
    pod 中的每个容器都必须经历这个过程。
- en: 'Container security has two parts: the contents of the container image, and
    its runtime configuration and security context. An abstract risk rating of a container
    can be derived from the number of security primitives it enables and uses safely,
    avoiding host namespaces, limiting resource use with `cgroups`, dropping unneeded
    capabilities, tightening security module configuration for the process’s usage
    pattern, and minimizing process and filesystem ownership and contents. [Kubesec.io](https://kubesec.io)
    rates a pod configuration’s security on how well it enables these features at
    runtime.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 容器安全有两个部分：容器镜像的内容，以及其运行时配置和安全上下文。一个容器的抽象风险评级可以从它启用和安全使用的安全原语数量中得出，避免使用主机命名空间，通过`cgroups`限制资源使用，放弃不需要的功能，为进程的使用模式加强安全模块配置，并最小化进程和文件系统的所有权和内容。[Kubesec.io](https://kubesec.io)
    根据运行时如何有效地启用这些功能来评估 pod 配置的安全性。
- en: 'When the kernel detects a network namespace is empty, it will destroy the namespace,
    removing any IPs allocated to network adapters in it. For a pod with only a single
    container to hold the network namespace’s IP allocation, a crashed and restarting
    container would have a new network namespace created and so have a new IP assigned.
    This rapid churn of IPs would create unnecessary noise for your operators and
    security monitoring. Kubernetes uses the so-called pause container (see also [“Intra-Pod
    Networking”](ch05.xhtml#workload-networking-intra-pod)), to hold the pod’s shared
    network namespace open in the event of a crash-looping tenant container. From
    inside a worker node, the companion pause container in each pod looks as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This pause container is invisible via the Kubernetes API, but visible to the
    container runtime on the worker node.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-111
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'CRI-O dispenses with the pause container (unless absolutely necessary) by pinning
    namespaces, as described in the KubeCon talk [“CRI-O: Look Ma, No Pause”](https://oreil.ly/EqEwr).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Sharing Network and Storage
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A group of containers in a pod share a network namespace, so all your containers’
    ports are available on the same network adapter to every container in the pod.
    This gives an attacker in one container of the pod a chance to attack private
    sockets available on any network interface, including the loopback adapter `127.0.0.1`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-115
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We examine these concepts in greater detail in Chapters [5](ch05.xhtml#ch-networking)
    and [6](ch06.xhtml#ch-storage).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Each container runs in a root filesystem from its container image that is not
    shared between containers. Volumes must be mounted into each container in the
    pod configuration, but a pod’s volumes may be available to all containers if configured
    that way, as you saw in [Figure 2-4](#pod-examples).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 2-8](#pod-namespace-nested) shows some of the paths inside a container
    workload that an attacker may be interested in (note the `user` and `time` namespaces
    are not currently in use).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '![Nested Pod Namespaces](Images/haku_0209.png)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
- en: Figure 2-8\. Namespaces wrapping the containers in a pod ([inspired by Ian Lewis](https://oreil.ly/nH9y8))
  id: totrans-120
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'User namespaces are the ultimate kernel security frontier, and are generally
    not enabled due to historically being likely entry points for kernel attacks:
    everything in Linux is a file, and user namespace implementation cuts across the
    whole kernel, making it more difficult to secure than other namespaces.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The special virtual filesystems listed here are all possible paths of breakout
    if misconfigured and accessible inside the container: */dev* may give access to
    the host’s devices, */proc* can leak process information, or */sys* supports functionality
    like launching new containers.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: What’s the Worst That Could Happen?
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A CISO is responsible for the organization’s security. Your role as a CISO means
    you should consider worst-case scenarios, to ensure that you have appropriate
    defenses and mitigations in place. Attack trees help to model these negative outcomes,
    and one of the data sources you can use is the [threat matrix](https://oreil.ly/LyjsO)
    as shown in [Figure 2-9](#pod-threat-matrix).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 作为企业的安全首席信息安全官（CISO），您应负责组织的安全工作。作为 CISO，您应考虑最坏的情况，确保您拥有适当的防御措施和缓解措施。攻击树有助于建模这些负面结果，而您可以使用的数据源之一就是威胁矩阵，如
    [图2-9](#pod-threat-matrix) 所示。
- en: '![Microsoft Kubernetes Threat Matrix](Images/haku_0210.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![微软 Kubernetes 威胁矩阵](Images/haku_0210.png)'
- en: 'Figure 2-9\. Microsoft Kubernetes threat matrix; source: [“Secure Containerized
    Environments with Updated Threat Matrix for Kubernetes”](https://oreil.ly/JzdmV)'
  id: totrans-127
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图2-9\. 微软 Kubernetes 威胁矩阵；来源：[“为 Kubernetes 更新的威胁矩阵保护容器化环境”](https://oreil.ly/JzdmV)
- en: But there are some threats missing, and the community has added some (thanks
    to Alcide, and [Brad Geesaman](https://oreil.ly/Ll2de) and [Ian Coldwater](https://oreil.ly/NmidV)
    again), as shown in [Table 2-1](#table0201).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但是还有一些缺失的威胁，社区已经添加了一些（感谢 Alcide，[Brad Geesaman](https://oreil.ly/Ll2de) 和 [Ian
    Coldwater](https://oreil.ly/NmidV)），如 [表2-1](#table0201) 所示。
- en: Table 2-1\. Our enhanced Microsoft Kubernetes threat matrix
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-1\. 我们增强的微软 Kubernetes 威胁矩阵
- en: '| Initial access (popping a shell pt 1 - prep) | Execution (popping a shell
    pt 2 - exec) | Persistence (keeping the shell) | Privilege escalation (container
    breakout) | Defense evasion (assuming no IDS) | Credential access (juicy creds)
    | Discovery (enumerate possible pivots) | Lateral movement (pivot) | Command &
    control (C2 methods) | Impact (dangers) |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 初始访问（入侵 Shell 预备工作 - 部分 1） | 执行（入侵 Shell 执行 - 部分 2） | 持久性（保持 Shell） | 特权升级（容器突破）
    | 防御逃避（假设没有 IDS） | 凭据访问（重要凭据） | 发现（枚举可能的枢纽） | 横向移动（枢纽） | 命令和控制（C2 方法） | 影响（危险）
    |'
- en: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |'
- en: '| Using cloud credentials: service account keys, impersonation | Exec into
    container (bypass admission control policy) | Backdoor container (add a reverse
    shell to local or container registry image) | Privileged container (legitimate
    escalation to host) | Clear container logs (covering tracks after host breakout)
    | List K8s Secrets | List K8s API server (nmap, curl) | Access cloud resources
    (workload identity and cloud integrations) | Dynamic resolution (DNS tunneling)
    | Data destruction (datastores, files, NAS, ransomware…) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 使用云凭据：服务账号密钥，冒充 | 执行到容器中（绕过准入控制策略） | 后门容器（向本地或容器注册表镜像添加反向 shell） | 特权容器（合法升级到主机）
    | 清除容器日志（主机突破后覆盖轨迹） | 列出 K8s 机密 | 列出 K8s API 服务器（nmap，curl） | 访问云资源（工作负载标识和云集成）
    | 动态解析（DNS 隧道） | 数据销毁（数据存储，文件，NAS，勒索软件…） |'
- en: '| Compromised images in registry (supply chain unpatched or malicious) | BASH/CMD
    inside container (implant or trojan, RCE/reverse shell, malware, C2, DNS tunneling)
    | Writable host path mount (host mount breakout) | Cluster admin role binding
    (untested RBAC) | Delete K8s events (covering tracks after host breakout) | Mount
    service principal (Azure specific) | Access `kubelet` API | Container service
    account (API server) | App protocols (L7 protocols, TLS, …) | Resource hijacking
    (cryptojacking, malware C2/distribution, open relays, botnet membership) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 注册表中的受损镜像（供应链未修补或恶意） | 容器内的 BASH/CMD（植入物或特洛伊木马，RCE/反向 shell，恶意软件，C2，DNS 隧道）
    | 可写主机路径挂载（主机挂载突破） | 群集管理员角色绑定（未经测试的 RBAC） | 删除 K8s 事件（主机突破后覆盖轨迹） | 挂载服务主体（Azure
    特定） | 访问 `kubelet` API | 容器服务账户（API 服务器） | 应用协议（L7 协议，TLS，…） | 资源劫持（加密货币挖矿，恶意软件
    C2/分发，开放中继，僵尸网络成员） |'
- en: '| Application vulnerability (supply chain unpatched or malicious) | Start new
    container (with malicious payload: persistence, enumeration, observation, escalation)
    | K8s CronJob (reverse shell on a timer) | Access cloud resources (metadata attack
    via workload identity) | Connect from proxy server (to cover source IP, external
    to cluster) | Applications credentials in config files (key material) | Access
    K8s dashboard (UI requires service account credentials) | Cluster internal networking
    (attack neighboring pods or systems) | Botnet (k3d, or traditional) | Application
    DoS |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 应用程序漏洞（供应链未修补或恶意） | 启动新容器（带有恶意负载：持久性，枚举，观察，升级） | K8s CronJob（定时反向 shell）
    | 访问云资源（通过工作负载标识元数据攻击） | 从代理服务器连接（覆盖源 IP，外部到集群） | 应用程序配置文件中的应用程序凭证（密钥材料） | 访问
    K8s 仪表板（UI 需要服务账户凭据） | 群集内部网络（攻击相邻的 Pod 或系统） | 僵尸网络（k3d 或传统） | 应用程序 DoS |'
- en: '| kubeconfig file (exfiltrated, or uploaded to the wrong place) | Application
    exploit (RCE) | Static pods (reverse shell, shadow API server to read audit-log-only
    headers) | Pod `hostPath` mount (logs to container breakout) | Pod/container name
    similarity (visual evasion, CronJob attack) | Access container service account
    (RBAC lateral jumps) | Network mapping (nmap, curl) | Access container service
    account (RBAC lateral jumps) |  | Node scheduling DoS |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| kubeconfig file (exfiltrated, or uploaded to the wrong place) | Application
    exploit (RCE) | Static pods (reverse shell, shadow API server to read audit-log-only
    headers) | Pod `hostPath` mount (logs to container breakout) | Pod/container name
    similarity (visual evasion, CronJob attack) | Access container service account
    (RBAC lateral jumps) | Network mapping (nmap, curl) | Access container service
    account (RBAC lateral jumps) |  | Node scheduling DoS |'
- en: '| Compromise user endpoint (2FA and federating auth mitigate) | SSH server
    inside container (bad practice) | Injected sidecar containers (malicious mutating
    webhook) | Node to cluster escalation (stolen credentials, node label rebinding
    attack) | Dynamic resolution (DNS) (DNS tunneling/exfiltration) | Compromise admission
    controllers | Instance metadata API (workload identity) | Host writable volume
    mounts |  | Service discovery DoS |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| Compromise user endpoint (2FA and federating auth mitigate) | SSH server
    inside container (bad practice) | Injected sidecar containers (malicious mutating
    webhook) | Node to cluster escalation (stolen credentials, node label rebinding
    attack) | Dynamic resolution (DNS) (DNS tunneling/exfiltration) | Compromise admission
    controllers | Instance metadata API (workload identity) | Host writable volume
    mounts |  | Service discovery DoS |'
- en: '| K8s API server vulnerability (needs CVE and unpatched API server) | Container
    lifecycle hooks (`postStart` and `preStop` events in pod YAML) | Rewrite container
    lifecycle hooks (`postStart` and `preStop` events in pod YAML) | Control plane
    to cloud escalation (keys in Secrets, cloud or control plane credentials) | Shadow
    admission control or API server |  | Compromise K8s Operator (sensitive RBAC)
    | Access K8s dashboard |  | PII or IP exfiltration (cluster or cloud datastores,
    local accounts) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| K8s API server vulnerability (needs CVE and unpatched API server) | Container
    lifecycle hooks (`postStart` and `preStop` events in pod YAML) | Rewrite container
    lifecycle hooks (`postStart` and `preStop` events in pod YAML) | Control plane
    to cloud escalation (keys in Secrets, cloud or control plane credentials) | Shadow
    admission control or API server |  | Compromise K8s Operator (sensitive RBAC)
    | Access K8s dashboard |  | PII or IP exfiltration (cluster or cloud datastores,
    local accounts) |'
- en: '| Compromised host (credentials leak/stuffing, unpatched services, supply chain
    compromise) |  | Rewrite liveness probes (exec into and reverse shell in container)
    | Compromise admission controller (reconfigure and bypass to allow blocked image
    with flag) |  |  | Access host filesystem (host mounts) | Access tiller endpoint
    (Helm v3 negates this) |  | Container pull rate limit DoS (container registry)
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| Compromised host (credentials leak/stuffing, unpatched services, supply chain
    compromise) |  | Rewrite liveness probes (exec into and reverse shell in container)
    | Compromise admission controller (reconfigure and bypass to allow blocked image
    with flag) |  |  | Access host filesystem (host mounts) | Access tiller endpoint
    (Helm v3 negates this) |  | Container pull rate limit DoS (container registry)
    |'
- en: '| Compromised `etcd` (missing auth) |  | Shadow admission control or API server
    (privileged RBAC, reverse shell) | Compromise K8s Operator (compromise flux and
    read any Secrets) |  |  |  | Access K8s Operator |  | SOC/SIEM DoS (event/audit/log
    rate limit) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| Compromised `etcd` (missing auth) |  | Shadow admission control or API server
    (privileged RBAC, reverse shell) | Compromise K8s Operator (compromise flux and
    read any Secrets) |  |  |  | Access K8s Operator |  | SOC/SIEM DoS (event/audit/log
    rate limit) |'
- en: '|  |  | K3d botnet (secondary cluster running on compromised nodes) | Container
    breakout (kernel or runtime vulnerability e.g., DirtyCOW, `/proc/self/exe`, eBPF
    verifier bugs, Netfilter) |  |  |  |  |  |  |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  |  | K3d botnet (secondary cluster running on compromised nodes) | Container
    breakout (kernel or runtime vulnerability e.g., DirtyCOW, `/proc/self/exe`, eBPF
    verifier bugs, Netfilter) |  |  |  |  |  |  |'
- en: We’ll explore these threats in detail as we progress through the book. But the
    first threat, and the greatest risk to the isolation model of our systems, is
    an attacker breaking out of the container itself.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们在本书中的进展，我们将详细探讨这些威胁。但是第一个威胁，也是我们系统隔离模型的最大风险，是攻击者从容器本身越界攻击出来。
- en: Container Breakout
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器越界攻击
- en: A cluster admin’s worst fear is a container breakout; that is, a user or process
    inside a container that can run code outside of the container’s execution environment.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 集群管理员最大的恐惧是容器越界攻击；即容器内的用户或进程可以在容器执行环境之外运行代码。
- en: Note
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Speaking strictly, a container breakout should exploit the kernel, attacking
    the code a container is supposed to be constrained by. In the authors’ opinion,
    any avoidance of isolation mechanisms breaks the contract the container’s maintainer
    or operator thought they had with the process(es) inside. This means it should
    be considered equally threatening to the security of the host system and its data,
    so we define container breakout to include any evasion of isolation.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，容器越界应该利用内核，攻击容器应该受到限制的代码。在作者看来，任何规避隔离机制的行为都会破坏容器维护者或运营者与其内部进程（们）的约定。这意味着它应被视为对主机系统及其数据安全同样构成威胁，因此我们将容器越界定义为包括任何逃避隔离的行为。
- en: 'Container breakouts may occur in various ways:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 容器越界可能以多种方式发生：
- en: An *exploit* including against the kernel, network or storage stack, or container
    runtime
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括对内核、网络或存储堆栈的*利用*，或者容器运行时。
- en: A *pivot* such as attacking exposed local, cloud, or network services, or escalating
    privilege and abusing discovered or inherited credentials
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如攻击暴露的本地、云或网络服务，或升级权限并滥用发现或继承的凭据
- en: A *misconfiguration* that allows an attacker an easier or legitimate path to
    exploit or pivot (this is the most likely way)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许攻击者更容易或合法地利用或适应的*错误配置*（这是最有可能的方式）
- en: If the running process is owned by an unprivileged user (that is, one with no
    root capabilities), many breakouts are not possible. In that case the process
    or user must gain capabilities with a local privilege escalation inside the container
    before attempting to break out.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 如果运行的进程被非特权用户（即没有根权限能力的用户）拥有，许多越界是不可能的。在这种情况下，进程或用户必须在尝试越界之前通过容器内的本地特权升级获取能力。
- en: 'Once this is achieved, a breakout may start with a hostile root-owned process
    running in a poorly configured container. Access to the root user’s capabilities
    within a container is the precursor to most escapes: without root (and sometimes
    `CAP_SYS_ADMIN`), many breakouts are nullified.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实现了这一点，越界可能从在配置不佳的容器中运行的敌对的根用户进程开始。在容器内获取根用户的能力是大多数逃逸的先兆：没有根权限（有时没有`CAP_SYS_ADMIN`），许多越界都会无效。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The `securityContext` and LSM configurations are vital to constrain unexpected
    activity from zero-day vulnerabilities, or supply chain attacks (library code
    loaded into the container and exploited automatically at runtime).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`securityContext`和LSM配置对于限制来自零日漏洞或供应链攻击的意外活动至关重要（库代码在运行时自动加载到容器中并自动利用）。'
- en: 'You can define the active user, group, and filesystem group (set on mounted
    volumes for readability, gated by `fsGroupChangePolicy`) in your workloads’ security
    contexts, and enforce it with admission control (see [Chapter 8](ch08.xhtml#ch-policy)),
    as this [example from the docs](https://oreil.ly/YJNS6) shows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在工作负载的安全上下文中定义活动用户、组和文件系统组（设置在挂载卷上以便可读性，通过`fsGroupChangePolicy`进行限制），并通过准入控制强制执行，详见[第8章](ch08.xhtml#ch-policy)，正如此[文档示例](https://oreil.ly/YJNS6)所示：
- en: '[PRE2]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a container breakout scenario, if the user is root inside the container
    or has mount capabilities (granted by default under `CAP_SYS_ADMIN`, which root
    is granted unless dropped), they can interact with virtual and physical disks
    mounted into the container. If the container is privileged (which among other
    things disables masking of kernel paths in */dev*), it can see and mount the host
    filesystem:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器越界场景中，如果用户在容器内部具有根权限或挂载能力（默认由`CAP_SYS_ADMIN`授予，除非被禁用），他们可以与挂载到容器中的虚拟和物理磁盘进行交互。如果容器是特权的（其中包括禁用在*/dev*中的内核路径掩码），它可以看到并挂载主机文件系统：
- en: '[PRE3]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We look at `nsenter` privileged container breakouts, which escape more elegantly
    by entering the host’s namespaces, in [Chapter 6](ch06.xhtml#ch-storage).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨`nsenter`特权容器的越界，通过进入主机的命名空间来更加优雅地逃逸，在[第6章](ch06.xhtml#ch-storage)中。
- en: While you should prevent this attack easily by avoiding the root user and privilege
    mode, and enforcing that with admission control, it’s an indication of just how
    slim the container security boundary can be if misconfigured.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通过避免根用户和特权模式并通过准入控制来强制执行可以轻松防止此类攻击，但如果配置错误，这表明容器安全边界有多脆弱。
- en: Warning
  id: totrans-160
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: 'An attacker controlling a containerized process may have control of the networking,
    some or all of the storage, and potentially other containers in the pod. Containers
    generally assume other containers in the pod are friendly as they share resources,
    and we can consider the pod as a trust boundary for the processes inside. Init
    containers are an exception: they complete and shut down before the main containers
    in the pod start, and as they operate in isolation may have more security sensitivity.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 控制容器化进程的攻击者可能控制网络、部分或全部存储，并可能控制 pod 中的其他容器。通常情况下，容器假设 pod 中的其他容器是友好的，因为它们共享资源，我们可以将
    pod 视为进程内的信任边界。但是，初始化容器是个例外：它们在主容器启动之前完成并关闭，并且因为它们在隔离环境中运行，可能具有更高的安全敏感性。
- en: The container and pod isolation model relies on the Linux kernel and container
    runtime, both of which are generally robust when not misconfigured. Container
    breakout occurs more often through insecure configuration than kernel exploit,
    although zero-day kernel vulnerabilities are inevitably devastating to Linux systems
    without correctly configured LSMs (such as SELinux and AppArmor).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 容器和 pod 隔离模型依赖于 Linux 内核和容器运行时，通常情况下，当它们没有配置错误时是很强大的。容器越狱更多是由于不安全的配置而不是内核利用，尽管零日内核漏洞不可避免地对没有正确配置
    LSM（如 SELinux 和 AppArmor）的 Linux 系统造成重大破坏。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In [“Architecting Containerized Apps for Resilience”](ch04.xhtml#architecting-apps-resilience)
    we explore how the Linux DirtyCOW vulnerability could be used to break out of
    insecurely configured containers.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [“为了弹性架构化容器化应用程序”](ch04.xhtml#architecting-apps-resilience) 中，我们探讨了 Linux
    DirtyCOW 漏洞如何用于打破不安全配置的容器。
- en: 'Container escape is rarely plain sailing, and any fresh vulnerabilities are
    often patched shortly after disclosure. Only occasionally does a kernel vulnerability
    result in an exploitable container breakout, and the opportunity to harden individually
    containerized processes with LSMs enables defenders to tightly constrain high-risk
    network-facing processes; it may entail one or more of:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 容器越狱很少是一帆风顺的，任何新的漏洞通常会在披露后不久修复。仅有偶尔的内核漏洞会导致可利用的容器越狱，而利用 LSM 可以加固单独的容器化进程，使防御者能够严格限制高风险的面向网络的进程；这可能包括以下一个或多个：
- en: Finding a zero-day in the runtime or kernel
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现运行时或内核的零日漏洞
- en: Exploiting excess privilege and escaping using legitimate commands
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用过多权限并利用合法命令进行逃逸
- en: Evading misconfigured kernel security mechanisms
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避开配置错误的内核安全机制
- en: Introspection of other processes or filesystems for alternate escape routes
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查其他进程或文件系统以寻找备用逃逸路径
- en: Sniffing network traffic for credentials
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 捕获网络流量以获取凭证
- en: Attacking the underlying orchestrator or cloud environment
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 攻击底层编排器或云环境
- en: Warning
  id: totrans-172
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Vulnerabilities in the underlying physical hardware often can’t be defended
    against in a container. For example, `Spectre` and `Meltdown` (CPU speculative
    execution attacks), and `rowhammer`, `TRRespass`, and `SPOILER` (DRAM memory attacks)
    bypass container isolation mechanisms as they cannot intercept the entire instruction
    stream that a CPU processes. Hypervisors suffer the same lack of possible protection.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 底层物理硬件中的漏洞通常无法在容器中进行防御。例如，`Spectre` 和 `Meltdown`（CPU 的 speculative execution
    攻击）、`rowhammer`、`TRRespass` 和 `SPOILER`（DRAM 内存攻击）可以绕过容器隔离机制，因为它们无法截取 CPU 处理的整个指令流。虚拟化程序也面临同样的保护不足。
- en: Finding new kernel attacks is hard. Misconfigured security settings, exploiting
    published CVEs, and social engineering attacks are easier. But it’s important
    to understand the range of potential threats in order to decide your own risk
    tolerance.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 发现新的内核攻击是困难的。错误配置的安全设置、利用已发布的 CVE 和社会工程攻击更容易。但是，了解潜在威胁的范围以决定自己的风险承受能力是很重要的。
- en: We’ll go through a step-by-step security feature exploration to see a range
    of ways in which your systems may be attacked in [Appendix A](app01.xhtml#appendix-pod-attack).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐步进行安全特性探索，看看您的系统可能受到攻击的各种方式，详见[附录 A](app01.xhtml#appendix-pod-attack)。
- en: 'For more information on how the Kubernetes project manages CVEs, see Anne Bertucio
    and CJ Cullen’s blog post, [“Exploring Container Security: Vulnerability Management
    in Open-Source Kubernetes”](https://oreil.ly/wYvv6).'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Kubernetes 项目如何管理 CVE 的更多信息，请参阅 Anne Bertucio 和 CJ Cullen 的博文，[“探索容器安全：开源
    Kubernetes 中的漏洞管理”](https://oreil.ly/wYvv6)。
- en: Pod Configuration and Threats
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pod 配置和威胁
- en: We’ve spoken generally about various parts of a pod, so let’s finish off by
    going into depth on a pod spec to call out any gotchas or potential footguns.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经总体讨论了 Pod 的各个部分，因此让我们深入了解 Pod 规范以指出任何容易出错或潜在问题。
- en: Warning
  id: totrans-179
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: In order to secure a pod or container, the container runtime should be minimally
    viably secure; that is, not hosting sockets to unauthenticated connections (e.g.,
    Docker’s */var/run/docker.sock* and `tcp://127.0.0.1:2375`) as it [leads to host
    takeover](https://oreil.ly/jy8Ol).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护 Pod 或容器，容器运行时应最小化地安全；也就是说，不应托管到未经身份验证的连接（例如 Docker 的 */var/run/docker.sock*
    和 `tcp://127.0.0.1:2375`），因为它[可能导致主机接管](https://oreil.ly/jy8Ol)。
- en: 'For the purpose of this example, we are using a `frontend` pod from the [`GoogleCloudPlatform/microservices-demo`
    application](https://oreil.ly/6WVwV), and it was deployed with the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，我们使用了来自[`GoogleCloudPlatform/microservices-demo` 应用程序](https://oreil.ly/6WVwV)的
    `frontend` Pod，并使用以下命令进行部署：
- en: '[PRE4]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We have updated and added some extra configuration where relevant for demonstration
    purposes and will progress through these in the following sections.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已更新并添加了一些额外的配置，用于演示目的，并将在以下部分中逐步进行介绍。
- en: Pod Header
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 头部
- en: 'The pod header is the standard header of all Kubernetes resources we know and
    love, defining the type of entity this YAML defines, and its version:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 头部是我们所知并且喜爱的所有 Kubernetes 资源的标准头部，定义了此 YAML 定义的实体类型及其版本：
- en: '[PRE5]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Metadata and annotations may contain sensitive information like IP addresses
    or security hints (in this case, for Istio), although this is only useful if the
    attacker has read-only access:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据和注解可能包含诸如 IP 地址或安全提示（在此案例中用于 Istio），尽管这只有在攻击者具有只读访问权限时才有用：
- en: '[PRE6]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It also historically holds the `seccomp`, `AppArmor`, and `SELinux` policies:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它还历史性地持有了 `seccomp`、`AppArmor` 和 `SELinux` 策略：
- en: '[PRE7]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We look at how to use these annotations in [“Runtime Policies”](ch08.xhtml#policy-runtime-policies).
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看看如何在[“运行时策略”](ch08.xhtml#policy-runtime-policies)中使用这些注解。
- en: Note
  id: totrans-192
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: After many years in limbo, `seccomp` in Kubernetes [progressed to General Availability
    in v1.19](https://oreil.ly/F7zOs).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 经过多年的发展，Kubernetes 中的`seccomp`在 v1.19 版本中[进展到了一般可用性](https://oreil.ly/F7zOs)。
- en: 'This [changes the syntax](https://oreil.ly/raOrF) from an annotation to a `securityContext`
    entry:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这将从注解更改为 `securityContext` 条目的[语法变更](https://oreil.ly/raOrF)：
- en: '[PRE8]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The [Kubernetes Security Profiles Operator](https://oreil.ly/Lrw5d) (SPO) can
    install `seccomp` profiles on your nodes (a prerequisite to their use by the container
    runtime), and record new profiles from workloads in the cluster with [oci-seccomp-bpf-hook](https://oreil.ly/A3Ub4).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubernetes 安全配置文件操作器](https://oreil.ly/Lrw5d)（SPO）可以在您的节点上安装`seccomp`配置文件（这是容器运行时使用的先决条件），并使用[oci-seccomp-bpf-hook](https://oreil.ly/A3Ub4)从集群中的工作负载记录新的配置文件。'
- en: The SPO also supports SELinux via [selinuxd](https://oreil.ly/nYQOU), with plenty
    of details [in this blog post](https://oreil.ly/3ZFui).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: SPO 还通过[selinuxd](https://oreil.ly/nYQOU)支持 SELinux，并在[此博客文章](https://oreil.ly/3ZFui)中提供了大量细节。
- en: AppArmor is still in beta but annotations will be replaced with first-class
    fields like `seccomp` once it graduates to GA.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor 仍处于测试阶段，但一旦升级到 GA，注解将被像 `seccomp` 这样的一流字段替代。
- en: Let’s move on to a part of the pod spec that is not writable by the client but
    contains some important hints.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转向 Pod 规范的一个客户端不可写部分，但包含一些重要的提示。
- en: Reverse Uptime
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反向正常运行时间
- en: 'When you dump a pod spec from the API server (using, for example, `kubectl
    get` `-o yaml`) it includes the pod’s start time:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从 API 服务器转储一个 Pod 规范（例如，使用 `kubectl get -o yaml`）时，它包括 Pod 的启动时间：
- en: '[PRE9]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Pods running for longer than a week or two are likely to be at higher risk of
    unpatched bugs. Sensitive workloads running for more than 30 days will be safer
    if they’re rebuilt in CI/CD to account for library or operating system patches.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间超过一两周的 Pod 可能存在更高风险的未打补丁漏洞。如果敏感工作负载运行超过 30 天，则通过 CI/CD 重新构建以考虑库或操作系统补丁将更安全。
- en: 'Pipeline scanning the existing container image offline for CVEs can be used
    to inform rebuilds. The safest approach is to combine both: “repave” (that is,
    rebuild and redeploy containers) regularly, and rebuild through the CI/CD pipelines
    whenever a CVE is detected.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 离线扫描现有容器镜像中的 CVE 可用于通知重建。最安全的方法是结合两者：定期“重新铺设”（即，重新构建和重新部署容器），以及在检测到 CVE 时通过
    CI/CD 管道进行重建。
- en: Labels
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: 'Labels in Kubernetes are not validated or strongly typed; they are metadata.
    But labels are targeted by things like services and controllers using selectors
    for referencing, and are also used for security features such as network policy.
    This makes them security-sensitive and easily susceptible to misconfiguration:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的标签不经过验证或强类型化；它们是元数据。但标签可被服务和控制器通过选择器进行定位，还用于安全功能，如网络策略。这使得它们对安全性非常敏感，并且容易因配置错误而受到影响：
- en: '[PRE10]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Typos in labels mean they do not match the intended selectors, and so can inadvertently
    introduce security issues such as:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 标签中的拼写错误意味着它们与预期的选择器不匹配，因此可能会无意中引入安全问题，例如：
- en: Exclusions from expected network policy or admission control policy
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排除预期网络策略或准入控制策略
- en: Unexpected routing from service target selectors
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务目标选择器导致意外的路由
- en: Rogue pods that are not accurately targeted by operators or observability tooling
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不准确地被操作员或可观察性工具定位的流氓 Pod
- en: Managed Fields
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理字段
- en: 'Managed fields were introduced in v1.18 and support [server-side apply](https://oreil.ly/UjXPY).
    They duplicate information from elsewhere in the pod spec but are of limited interest
    to us as we can read the entire spec from the API server. They look like this:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 管理字段在 v1.18 中引入，并支持 [server-side apply](https://oreil.ly/UjXPY)。它们复制了 Pod 规范中其他地方的信息，但对我们来说并不太感兴趣，因为我们可以从
    API 服务器中读取整个规范。它们看起来像这样：
- en: '[PRE11]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Pod Namespace and Owner
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 的命名空间和所有者
- en: We know the pod’s name and namespace from the API request we made to retrieve
    it.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 API 请求来获取 Pod 时，已经知道 Pod 的名称和命名空间。
- en: 'If we used `--all-namespaces` to return all pod configurations, this shows
    us the namespace:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用 `--all-namespaces` 来返回所有 Pod 的配置，这会显示出命名空间：
- en: '[PRE12]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'From within a pod it’s possible to infer the current namespace from the DNS
    resolver configuration in */etc/resolv.conf* (which is `secret-namespace` in this
    example):'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Pod 内部，可以通过 */etc/resolv.conf* 中的 DNS 解析器配置推断出当前命名空间（例如在本例中为 `secret-namespace`）：
- en: '[PRE13]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Other less-robust options include the mounted service account (assuming it’s
    in the same namespace, which it may not be), or the cluster’s DNS resolver (if
    you can enumerate or scrape it).
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其他不够健壮的选项包括挂载的服务账户（假设它与同一命名空间中，但也可能不在其中），或者集群的 DNS 解析器（如果您可以列举或抓取它）。
- en: Environment Variables
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境变量
- en: Now we’re getting into interesting configuration. We want to see the environment
    variables in a pod, partially because they may leak secret information (which
    should have been mounted as a file), and also because they may list which other
    services are available in the namespace and so suggest other network routes and
    applications to attack.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们开始进入有趣的配置领域。我们想要查看 Pod 中的环境变量，部分原因是它们可能会泄露秘密信息（本应作为文件挂载），另一部分原因是它们可能会列出命名空间中可用的其他服务，从而暗示其他网络路由和可能被攻击的应用程序。
- en: Warning
  id: totrans-224
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Passwords set in deployment and pod YAML are visible to the operator that deploys
    the YAML, the process at runtime and any other processes that can read its environment,
    and to anybody that can read from the Kubernetes or `kubelet` APIs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署和 Pod YAML 中设置的密码对部署 YAML 的操作员、运行时进程以及任何其他能够读取其环境的进程可见，也对能够从 Kubernetes 或
    `kubelet` API 中读取的任何人可见。
- en: 'Here we see the container’s `PORT` (which is good practice and required by
    applications running in Knative, Google Cloud Run, and some other systems), the
    DNS names and ports of its coordinating services, some badly set database config
    and credentials, and finally a sensibly referenced Secret file:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们可以看到容器的 `PORT`（这是一种良好的实践，并且在运行在 Knative、Google Cloud Run 和其他一些系统中的应用程序中是必需的），其协调服务的
    DNS 名称和端口，一些设置不当的数据库配置和凭据，以及最后一个合理引用的 Secret 文件：
- en: '[PRE14]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: That wasn’t too bad, right? Let’s move on to container images.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这没那么糟糕，对吧？让我们继续讨论容器镜像。
- en: Container Images
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器镜像
- en: The container image’s filesystem is of paramount importance, as it may hold
    vulnerabilities that assist in privilege escalation. If you’re not patching regularly,
    Captain Hashjack might get the same image from a public registry to scan it for
    vulnerabilities they may be able to exploit. Knowing what binaries and files are
    available also enables attack planning “offline,” so adversaries can be more stealthy
    and targeted when attacking the live system.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像的文件系统至关重要，因为它可能存在漏洞，助长特权升级。如果不定期打补丁，Captain Hashjack 可能会从公共注册表中获取相同的镜像，并扫描可能被利用的漏洞。知道哪些二进制文件和文件可用也能够“离线”进行攻击计划，因此对手在攻击活动时更加隐蔽和有针对性。
- en: Tip
  id: totrans-231
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: 'The OCI registry specification allows arbitrary image layer storage: it’s a
    two-step process and the first step uploads the manifest, with the second uploading
    the blob. If an attacker only performs the second step they gain free arbitrary
    blob storage.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: OCI 注册表规范允许任意图像层存储：这是一个两步过程，第一步上传清单，第二步上传 blob。如果攻击者只执行第二步，则可以获得免费的任意 blob 存储。
- en: Most registries don’t index this automatically (with Harbour being the exception),
    and so they will store the “orphaned” layers forever, potentially hidden from
    view until manually garbage collected.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数注册表不会自动对此进行索引（Harbour 是个例外），因此它们将永久存储“孤立”的层，直到手动垃圾回收为止，这些层可能会被隐藏起来，无法看到。
- en: 'Here we see an image referenced by label, which means we can’t tell what the
    actual SHA256 hash digest of the container image is. The container tag could have
    been updated since this deployment as it’s not referenced by digest:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一个通过标签引用的镜像，这意味着我们无法确定容器镜像的实际 SHA256 散列摘要。由于它没有使用摘要引用，容器标签可能已在部署后更新：
- en: '[PRE15]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Instead of using image tags, we can use the SHA256 image digests to pull the
    image by its content address:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 SHA256 镜像摘要而不是镜像标签来拉取镜像，以其内容地址引用：
- en: '[PRE16]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Images should always be referenced by SHA256 or use signed tags; otherwise,
    it’s impossible to know what’s running as the label may have been updated in the
    registry since the container start. You can validate what’s being run by inspecting
    the running container for its image’s SHA256.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 应始终通过 SHA256 引用镜像或使用签名标签；否则，由于容器启动后可能已更新注册表中的标签，无法知道运行的是什么。可以通过检查运行中容器的镜像 SHA256
    来验证正在运行的内容。
- en: 'It’s possible to specify both a tag and an SHA256 digest in a Kubernetes `image:`
    key, in which case the tag is ignored and the image is retrieved by digest. This
    leads to potentially confusing image definitions including a tag and SHA256 such
    as the following being retrieved as the image matching the SHA rather than the
    tag:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在 Kubernetes 的 `image:` 键中同时指定标签和 SHA256 摘要，此时标签将被忽略，镜像将通过摘要检索。这会导致包含标签和 SHA256
    的可能令人困惑的镜像定义被检索为与 SHA 匹配的镜像而不是标签：
- en: '[PRE17]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[![1](Images/1.png)](#co_pod_level_resources_CO1-1)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_pod_level_resources_CO1-1)'
- en: Container name, plus the ignored “latest” tag
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 容器名称，以及被忽略的“latest”标签
- en: '[![2](Images/2.png)](#co_pod_level_resources_CO1-2)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_pod_level_resources_CO1-2)'
- en: Image SHA256, which overrides the “latest” tag defined in the previous line
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像 SHA256，覆盖了前一行中定义的“latest”标签
- en: being retrieved as the image matching the SHA rather than the tag.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 被检索为与标签不同而匹配 SHA 的镜像。
- en: 'If an attacker can influence the local `kubelet` image cache, they can add
    malicious code to an image and relabel it on the worker node (note: to run this
    again, don’t forget to remove the `cidfile`):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如果攻击者可以影响本地 `kubelet` 镜像缓存，他们可以向镜像添加恶意代码并在工作节点上重新标记它（注意：要再次运行此操作，请勿忘记删除 `cidfile`）：
- en: '[PRE18]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[![1](Images/1.png)](#co_pod_level_resources_CO2-1)'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_pod_level_resources_CO2-1)'
- en: Load a malicious shell backdoor and overwrite the container’s default command
    (`/bin/sh`).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 加载恶意的 shell 后门并覆盖容器的默认命令（`/bin/sh`）。
- en: '[![2](Images/2.png)](#co_pod_level_resources_CO2-2)'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_pod_level_resources_CO2-2)'
- en: Commit the changed container using the same.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更改后的容器使用相同的方法。
- en: While the compromise of a local registry cache may lead to this attack, container
    cache access probably comes by rooting the node, and so this may be the least
    of your worries.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管本地注册表缓存的妥协可能导致此类攻击，但容器缓存访问可能是通过对节点进行根权访问而来，因此这可能是您最不用担心的问题之一。
- en: Note
  id: totrans-253
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: The image pull policy of `Always` has a performance drawback in highly dynamic,
    “autoscaling from zero” environments such as Knative. When startup times are crucial,
    a potentially multisecond `imagePullPolicy` latency is unacceptable and image
    digests must be used.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在高度动态的“从零自动扩展”环境中，如 Knative，使用 `Always` 的镜像拉取策略会存在性能缺陷。当启动时间至关重要时，潜在的多秒级 `imagePullPolicy`
    延迟是不可接受的，必须使用镜像摘要。
- en: 'This attack on a local image cache can be mitigated with an image pull policy
    of `Always`, which will ensure the local tag matches what’s defined in the registry
    it’s pulled from. This is important and you should always be mindful of this setting:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 对本地镜像缓存的攻击可以通过 `Always` 的镜像拉取策略来减轻，这将确保本地标签与从中拉取的注册表中定义的标签匹配。这很重要，您应始终注意此设置：
- en: '[PRE19]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Typos in container image names, or registry names, will deploy unexpected code
    if an adversary has “typosquatted” the image with a malicious container.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 容器镜像名称或注册表名称的拼写错误，如果攻击者通过“typosquatting”方式制作恶意容器，则会部署意外的代码。
- en: This can be difficult to detect when only a single character changes—for example,
    `controlplan/hack` instead of `controlplane/hack`. Tools like Notary protect against
    this by checking for valid signatures from trusted parties. If a TLS-intercepting
    middleware box intercepts and rewrites an image tag, a spoofed image may be deployed.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 当只有一个字符更改时，这可能很难检测，例如 `controlplan/hack` 而不是 `controlplane/hack`。像 Notary 这样的工具通过检查来自受信任方的有效签名来防止这种情况。如果
    TLS 拦截中间件框拦截并重写图像标记，则可能部署伪造的图像。
- en: Again, TUF and Notary side-channel signing mitigates against this, as do other
    container signing approaches like `cosign`, as discussed in [Chapter 4](ch04.xhtml#ch-apps-supply-chain).
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，TUF 和 Notary 侧信道签名可以缓解这个问题，其他容器签名方法如 `cosign` 也可以，如 [第 4 章](ch04.xhtml#ch-apps-supply-chain)
    中讨论的那样。
- en: Pod Probes
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 探针
- en: Your liveness probes should be tuned to your application’s performance characteristics,
    and used to keep them alive in the stormy waters of your production environment.
    Probes inform Kubernetes if the application is incapable of fulfilling its specified
    purpose, perhaps through a crash or external system failure.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 您的活跃探针应根据应用程序的性能特征进行调整，并用于在生产环境的风云变幻中保持其活跃。探针通知 Kubernetes 应用程序是否无法实现其指定目的，可能是通过崩溃或外部系统故障。
- en: 'The Kubernetes audit finding [TOB-K8S-024](https://oreil.ly/OWnq6) shows probes
    can be subverted by an attacker with the ability to schedule pods: without changing
    the pod’s `command` or `args` they have the power to make network requests and
    execute commands within the target container. This yields local network discovery
    to an attacker as the probes are executed by the `kubelet` on the host networking
    interface, and not from within the pod.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 审计发现 [TOB-K8S-024](https://oreil.ly/OWnq6) 显示探针可以被具有调度 pod 能力的攻击者所破坏：即使不更改
    pod 的 `command` 或 `args`，他们也有权进行网络请求并在目标容器内执行命令。这使得攻击者可以通过在主机网络接口上执行探针来发现本地网络，而不是从
    pod 内部执行。
- en: 'A `host` header can be used here to enumerate the local network. The proof
    of concept exploit is as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`host` 头可以用于枚举本地网络。概念验证漏洞利用如下：'
- en: '[PRE20]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: CPU and Memory Limits and Requests
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CPU 和内存限制和请求
- en: Resource limits and requests which manage the pod’s `cgroups` prevent the exhaustion
    of finite memory and compute resources on the `kubelet` host, and defend from
    fork bombs and runaway processes. Networking bandwidth limits are not supported
    in the pod spec, but may be supported by your CNI implementation.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 资源限制和请求管理 pod 的 `cgroups`，防止在 `kubelet` 主机上耗尽有限的内存和计算资源，并防止 fork 炸弹和失控进程。网络带宽限制不在
    pod 规范中支持，但可能会被您的 CNI 实现支持。
- en: '`cgroups` are a useful resource constraint. `cgroups` v2 offers more protection,
    but `cgroups` v1 are not a security boundary and [they can be escaped easily](https://oreil.ly/uDhso).'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`cgroups` 是一个有用的资源约束。`cgroups` v2 提供更多保护，但 `cgroups` v1 不是安全边界，[很容易被绕过](https://oreil.ly/uDhso)。'
- en: 'Limits restrict the potential cryptomining or resource exhaustion that a malicious
    container can execute. It also stops the host becoming overwhelmed by bad deployments.
    It has limited effectiveness against an adversary looking to further exploit the
    system unless they need to use a memory-hungry attack:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 限制限制了恶意容器可能执行的加密挖矿或资源耗尽。它还阻止主机被糟糕的部署压倒。对于试图进一步利用系统的对手，除非他们需要使用占用大量内存的攻击，它的效果有限：
- en: '[PRE21]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: DNS
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DNS
- en: By default Kubernetes DNS servers provide all records for services across the
    cluster, preventing namespace segregation unless deployed individually per-namespace
    or domain.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes DNS 服务器为整个集群中的服务提供所有记录，除非每个命名空间或域单独部署，否则无法实现命名空间隔离。
- en: Tip
  id: totrans-272
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: CoreDNS supports policy plug-ins, including OPA, to restrict access to DNS records
    and defeat the following enumeration attacks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: CoreDNS 支持策略插件，包括 OPA，用于限制对 DNS 记录的访问，并防止以下枚举攻击。
- en: The default Kubernetes CoreDNS installation leaks information about its services,
    and offers an attacker a view of all possible network endpoints (see [Figure 2-10](#tweet-rory-hard-dns)).
    Of course they may not all be accessible due to a network policy in place, as
    we will see in [“Traffic Flow Control”](ch05.xhtml#workload-network-policies).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的 Kubernetes CoreDNS 安装泄漏有关其服务的信息，并为攻击者提供查看所有可能网络端点的视图（参见 [图 2-10](#tweet-rory-hard-dns)）。当然，由于存在网络策略，可能并非所有端点都可访问，正如我们将在
    [“流量流控”](ch05.xhtml#workload-network-policies) 中看到的那样。
- en: 'DNS enumeration can be performed against a default, unrestricted CoreDNS installation.
    To retrieve all services in the cluster namespace (output edited to fit):'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: DNS 枚举可以针对默认的、不受限制的 CoreDNS 安装执行。要检索集群命名空间中的所有服务（输出编辑以适应）：
- en: '[PRE22]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![tweet-rory-hard-dns](Images/haku_0211.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![tweet-rory-hard-dns](Images/haku_0211.png)'
- en: Figure 2-10\. The wisdom of Rory McCune on the difficulties of hard multitenancy
  id: totrans-278
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-10\. Rory McCune 对硬多租户难题的智慧
- en: 'For all service endpoints and names do the following (output edited to fit):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有服务端点和名称执行以下操作（输出编辑以适应）：
- en: '[PRE23]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To return an IPv4 address based on the query:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 根据查询返回 IPv4 地址：
- en: '[PRE24]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The Kubernetes API server service IP information is mounted into the pod’s
    environment by default:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes API 服务器服务 IP 信息默认挂载到 pod 的环境中：
- en: '[PRE25]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The response matches the API server’s `/version` endpoint.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 响应与 API 服务器的 `/version` 端点匹配。
- en: Tip
  id: totrans-286
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'You can detect Kubernetes API servers with [this nmap script](https://oreil.ly/PAqte)
    and the following function:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 [此 nmap 脚本](https://oreil.ly/PAqte) 和以下功能检测 Kubernetes API 服务器：
- en: '[PRE26]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next up is an important runtime policy piece: the securityContext, initially
    introduced by Red Hat.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的运行时策略片段是安全上下文，最初由红帽引入。
- en: Pod securityContext
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod securityContext
- en: 'This pod is running with an empty `securityContext`, which means that without
    admission controllers mutating the configuration at deployment time, the container
    can run a root-owned process and has all capabilities available to it:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 此 pod 使用空的 `securityContext` 运行，这意味着在部署时没有准入控制器对配置进行变异，容器可以运行一个属于 root 的进程，并对其拥有所有能力：
- en: '[PRE27]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Exploiting the capability landscape involves an understanding of the kernel’s
    flags, and [Stefano Lanaro’s guide](https://oreil.ly/mtvCX) provides a comprehensive
    overview.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 开发能力地形图涉及对内核标志的理解，[Stefano Lanaro 的指南](https://oreil.ly/mtvCX) 提供了全面的概述。
- en: 'Different capabilities may have particular impact on a system, and `CAP_SYS_ADMIN`
    and `CAP_BPF` are particularly enticing to an attacker. Notable capabilities you
    should be cautious about granting include:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的能力可能对系统产生特定影响，而 `CAP_SYS_ADMIN` 和 `CAP_BPF` 对攻击者尤为诱人。你应该谨慎授予的显著能力包括：
- en: '`CAP_DAC_OVERRIDE`, `CAP_CHOWN`, `CAP_DAC_READ_SEARCH`, `CAP_FORMER`, `CAP_SETFCAP`'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAP_DAC_OVERRIDE`, `CAP_CHOWN`, `CAP_DAC_READ_SEARCH`, `CAP_FORMER`, `CAP_SETFCAP`'
- en: Bypass filesystem permissions
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 绕过文件系统权限
- en: '`CAP_SETUID`, `CAP_SETGID`'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAP_SETUID`, `CAP_SETGID`'
- en: Become the root user
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 成为 root 用户
- en: '`CAP_NET_RAW`'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAP_NET_RAW`'
- en: Read network traffic
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 读取网络流量
- en: '`CAP_SYS_ADMIN`'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAP_SYS_ADMIN`'
- en: Filesystem mount permission
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统挂载权限
- en: '`CAP_SYS_PTRACE`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAP_SYS_PTRACE`'
- en: All-powerful debugging of other processes
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 所有进程的全能调试
- en: '`CAP_SYS_MODULE`'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAP_SYS_MODULE`'
- en: Load kernel modules to bypass controls
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 加载内核模块以绕过控制
- en: '`CAP_PERFMON`, `CAP_BPF`'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAP_PERFMON`, `CAP_BPF`'
- en: Access deep-hooking BPF systems
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 访问深度挂钩 BPF 系统
- en: These are the precursors for many container breakouts. As [Brad Geesaman](https://oreil.ly/swfMU)
    points out in [Figure 2-11](#tweet-brad-not-a-container-escape), processes want
    to be free! And an adversary will take advantage of anything within the pod they
    can use to escape.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是许多容器突破的先兆。正如 [Brad Geesaman](https://oreil.ly/swfMU) 在 [图 2-11](#tweet-brad-not-a-container-escape)
    中指出的，进程想要自由！攻击者会利用 pod 中任何可用于逃逸的东西。
- en: '![haku 0212](Images/haku_0212.png)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![haku 0212](Images/haku_0212.png)'
- en: Figure 2-11\. Brad Geesaman’s evocative container freedom cry
  id: totrans-311
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 2-11\. Brad Geesaman 对具有感染力的容器自由呼声
- en: Note
  id: totrans-312
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`CAP_NET_RAW` is enabled by default in `runc`, and enables UDP (which bypasses
    TCP service meshes like Istio), ICMP messages, and ARP poisoning attacks. [Aqua
    found DNS poisoning attacks](https://oreil.ly/ceARf) against Kubernetes DNS, and
    the `net.ipv4.ping_group_range` `sysctl` flag means [it should be dropped when
    needed for ICMP](https://oreil.ly/tJ7rQ).'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '`CAP_NET_RAW` 在 `runc` 中默认启用，并启用 UDP（绕过像 Istio 这样的 TCP 服务网格）、ICMP 消息和 ARP 毒化攻击。[Aqua
    发现 DNS 毒化攻击](https://oreil.ly/ceARf) 对 Kubernetes DNS 造成影响，而 `net.ipv4.ping_group_range`
    `sysctl` 标志意味着 [在需要 ICMP 时应将其丢弃](https://oreil.ly/tJ7rQ)。'
- en: 'These are some container breakouts requiring `root` and/or `CAP_SYS_ADMIN`,
    `CAP_NET_RAW`, `CAP_BPF`, or `CAP_SYS_MODULE` to function:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些需要 `root` 和/或 `CAP_SYS_ADMIN`、`CAP_NET_RAW`、`CAP_BPF` 或 `CAP_SYS_MODULE`
    才能运行的容器突破方式：
- en: Subpath volume mount traversal and */proc/self/exe* (both described in [Chapter 6](ch06.xhtml#ch-storage)).
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子路径卷挂载遍历和 */proc/self/exe*（详见[第 6 章](ch06.xhtml#ch-storage)）。
- en: '[CVE-2016-5195](https://oreil.ly/ZdYJ8) is a read-only memory copy-on-write
    race condition, aka DirtyCow, and detailed in [“Architecting Containerized Apps
    for Resilience”](ch04.xhtml#architecting-apps-resilience).'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CVE-2016-5195](https://oreil.ly/ZdYJ8) 是一个只读内存写时复制竞争条件，又称 DirtyCow，并在 [“Architecting
    Containerized Apps for Resilience”](ch04.xhtml#architecting-apps-resilience) 中有详细描述。'
- en: '[CVE-2020-14386](https://oreil.ly/Scrau) is an unprivileged memory corruption
    bug that requires `CAP_NET_RAW`.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CVE-2020-14386](https://oreil.ly/Scrau) 是一个无特权内存损坏漏洞，需要 `CAP_NET_RAW`。'
- en: '[CVE-2021-30465](https://oreil.ly/QzkuG), `runc` mount destinations symlink-exchange
    swap to mount outside the `rootfs`, limited by use of unprivileged user.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CVE-2021-30465](https://oreil.ly/QzkuG)，`runc` 挂载目的地符号链接交换以在 `rootfs` 外挂载，受非特权用户使用限制。'
- en: '[CVE-2021-22555](https://oreil.ly/Zj1Rl) is a `Netfilter` heap out-of-bounds
    write that requires `CAP_NET_RAW`.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CVE-2021-22555](https://oreil.ly/Zj1Rl) 是 `Netfilter` 堆外写入越界漏洞，需要 `CAP_NET_RAW`。'
- en: '[CVE-2021-31440](https://oreil.ly/VLeQK) is `eBPF` out-of-bounds access to
    the Linux kernel requiring root or `CAP_BPF`, and `CAPS_SYS_MODULE`.'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[CVE-2021-31440](https://oreil.ly/VLeQK) 是 `eBPF` 对 Linux 内核的越界访问，需要 root 或
    `CAP_BPF` 和 `CAP_SYS_MODULE`。'
- en: '[@andreyknvl](https://oreil.ly/wlzra) kernel bugs and [`core_pattern` escape](https://oreil.ly/RWlF0).'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[@andreyknvl](https://oreil.ly/wlzra) 内核漏洞和 [`core_pattern` 转义](https://oreil.ly/RWlF0)。'
- en: When there’s no breakout, root capabilities are still required for a number
    of other attacks, such as [CVE-2020-10749](https://oreil.ly/XoxVW) which are Kubernetes
    CNI plug-in person-in-the-middle (PitM) attacks via IPv6 rogue router advertisements.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有爆发时，仍然需要根权限来执行其他一些攻击，例如 [CVE-2020-10749](https://oreil.ly/XoxVW)，这是 Kubernetes
    CNI 插件 IPv6 通过恶意路由广告进行中间人攻击。
- en: Tip
  id: totrans-323
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: Tip
- en: The excellent [“A Compendium of Container Escapes”](https://oreil.ly/LAGB9)
    goes into more detail on some of these attacks.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 出色的 [“A Compendium of Container Escapes”](https://oreil.ly/LAGB9) 详细探讨了其中一些攻击。
- en: We enumerate the options available in a `securityContext` for a pod to defend
    itself from hostile containers in [“Runtime Policies”](ch08.xhtml#policy-runtime-policies).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [“Runtime Policies”](ch08.xhtml#policy-runtime-policies) 中列出了用于 Pod 的 `securityContext`
    的选项，以防范敌对容器。
- en: Pod Service Accounts
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod Service Accounts
- en: Service Accounts are JSON Web Tokens (JWTs) and are used by a pod for authentication
    and authorization to the API server. The default service account shouldn’t be
    given any permissions, and by default comes with no authorization.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Service Accounts 是 JSON Web Tokens (JWTs)，用于 Pod 对 API 服务器的身份验证和授权。默认服务账户不应该被赋予任何权限，并且默认情况下没有授权。
- en: 'A pod’s `serviceAccount` configuration defines its access privileges with the
    API server; see [“Service accounts”](ch08.xhtml#service-accounts) for the details.
    The service account is mounted into all pod replicas, and which share the single
    “workload identity”:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 的 `serviceAccount` 配置定义其与 API 服务器的访问权限；详见 [“Service accounts”](ch08.xhtml#service-accounts)。该服务账户被挂载到所有
    Pod 副本中，并共享单一的“工作负载身份”：
- en: '[PRE28]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Segregating duty in this way reduces the blast radius if a pod is compromised:
    limiting an attacker post-intrusion is a primary goal of policy controls.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式分离责任可减少 Pod 受损的影响范围：限制入侵后的攻击者活动是策略控制的主要目标。
- en: Scheduler and Tolerations
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Scheduler and Tolerations
- en: 'The scheduler is responsible for allocating a pod workload to a node. It looks
    as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 调度器负责将 Pod 工作负载分配到节点。它的工作如下：
- en: '[PRE29]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A hostile scheduler could conceivably exfiltrate data or workloads from the
    cluster, but requires the cluster to be compromised in order to add it to the
    control plane. It would be easier to schedule a privileged container and root
    the control plane `kubelets`.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 敌对调度器可能会从集群中窃取数据或工作负载，但需要将其添加到控制平面以实现对集群的攻击。更容易的是调度一个特权容器并控制平面的 `kubelets`。
- en: Pod Volume Definitions
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod Volume Definitions
- en: 'Here we are using a bound service account token, defined in YAML as a projected
    service account token (instead of a standard service account). The `kubelet` protects
    this against exfiltration by regularly rotating it (configured for every 3600
    seconds, or one hour), so it’s only of limited use if stolen. An attacker with
    persistence is still able to use this value, and can observe its value after it’s
    rotated, so this only protects the service account after the attack has completed:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个绑定的服务账户令牌，在 YAML 中定义为投影的服务账户令牌（而不是标准服务账户）。`kubelet` 通过定期轮换（配置为每3600秒或一小时）保护此令牌，所以如果被窃取，它只能被限制使用。持久化攻击者仍能够在令牌轮换后使用此值，所以此仅在攻击完成后保护服务账户：
- en: '[PRE30]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Volumes are a rich source of potential data for an attacker, and you should
    ensure that standard security practices like discretionary access control (DAC,
    e.g., files and permissions) is correctly configured.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 卷是攻击者潜在数据的丰富来源，您应确保像自由访问控制（DAC，例如文件和权限）这样的标准安全实践得到正确配置。
- en: Tip
  id: totrans-339
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: The downward API reflects Kubernetes-level values into the containers in the
    pod, and is useful to expose things like the pod’s name, namespace, UID, and labels
    and annotations into the container. It’s capabilities are [listed in the documentation](https://oreil.ly/UyC90).
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: Downward API 将 Kubernetes 级别的值反映到 pod 中的容器中，有助于公开诸如 pod 名称、命名空间、UID、标签和注释等内容。其功能在[文档中列出](https://oreil.ly/UyC90)。
- en: A container is just Linux, and will not protect its workload from incorrect
    configuration.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 容器只是 Linux，并不会保护其工作负载免受配置错误的影响。
- en: Pod Network Status
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pod 网络状态
- en: 'Network information about the pod is useful to debug containers without services,
    or that aren’t responding as they should, but an attacker might use this information
    to connect directly to a pod without scanning the network:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 pod 的网络信息对于调试没有服务的容器或不响应正常的容器非常有用，但攻击者可能利用这些信息直接连接到 pod，而无需扫描网络：
- en: '[PRE31]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Using the securityContext Correctly
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 正确使用 securityContext
- en: A pod is more likely to be compromised if a `securityContext` is not configured,
    or is too permissive. The `securityContext` is your most effective tool to prevent
    container breakout.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未配置或配置过于宽松，那么 pod 更有可能受到攻击。`securityContext` 是防止容器突破的最有效工具。
- en: After gaining an RCE into a running pod, the `securityContext` is the first
    line of defensive configuration you have available. It has access to kernel switches
    that can be set individually. Additional Linux Security Modules can be configured
    with fine-grained policies that prevent hostile applications taking advantage
    of your systems.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功获得运行中 pod 的 RCE 后，`securityContext` 是您可用的第一道防御配置。它可以访问可以单独设置的内核开关。还可以配置其他
    Linux 安全模块以防止敌意应用程序利用您的系统。
- en: 'Docker’s `containerd` has a default `seccomp` profile that has prevented some
    zero-day attacks against the container runtime by blocking system calls in the
    kernel. From Kubernetes v1.22 you should enable this by default for all runtimes
    with the `--seccomp-default` `kubelet` flag. In some cases workloads may not run
    with the default profile: observability or security tools may require low-level
    kernel access. These workloads should have custom `seccomp` profiles written (rather
    than resorting to running them `Unconfined`, which allows any system call).'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 的 `containerd` 具有默认的 `seccomp` 配置文件，通过阻止内核中的系统调用阻止了一些针对容器运行时的零日攻击。从 Kubernetes
    v1.22 开始，您应通过 `--seccomp-default` `kubelet` 标志默认启用此功能。在某些情况下，工作负载可能无法使用默认配置文件：可观察性或安全工具可能需要低级别的内核访问。这些工作负载应编写自定义
    `seccomp` 配置文件（而不是采用运行它们 `Unconfined` 的方法，该方法允许任何系统调用）。
- en: 'Here’s an example of a fine-grained `seccomp` profile loaded from the host’s
    filesystem under `/var/lib/kubelet/seccomp`:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个从主机文件系统中 `/var/lib/kubelet/seccomp` 加载的精细化 `seccomp` 配置文件的示例：
- en: '[PRE32]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`seccomp` is for system calls, but SELinux and AppArmor can monitor and enforce
    policy in userspace too, protecting files, directories, and devices.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '`seccomp` 用于系统调用，但 SELinux 和 AppArmor 也可以在用户空间监控和执行策略，保护文件、目录和设备。'
- en: SELinux configuration is able to block most container breakouts (excluding with
    a label-based approach to filesystem and process access) as it doesn’t allow containers
    to write anywhere but their own filesystem, nor to read other directories, and
    comes enabled on OpenShift and Red Hat Linuxes.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: SELinux 配置能够阻止大多数容器突破（除了基于标签的文件系统和进程访问方法），因为它不允许容器写入除了自己的文件系统之外的任何位置，也不允许读取其他目录，并且在
    OpenShift 和 Red Hat Linux 上启用。
- en: 'AppArmor can similarly monitor and prevent many attacks in Debian-derived Linuxes.
    If AppArmor is enabled, then `cat /sys/module/apparmor/parameters/enabled` returns
    `Y`, and it can be used in pod definitions:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: AppArmor 可以类似地监控和防止 Debian 派生的 Linux 中的许多攻击。如果启用了 AppArmor，则 `cat /sys/module/apparmor/parameters/enabled`
    返回 `Y`，并且可以在 pod 定义中使用：
- en: '[PRE33]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `privileged` flag was quoted as being “the most dangerous flag in the history
    of computing” by Liz Rice, but why are privileged containers so dangerous? Because
    they leave the process namespace enabled to give the illusion of containerization,
    but actually disable all security features.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Liz Rice曾称“privileged”标志是“计算历史上最危险的标志”，但为什么privileged容器如此危险？因为它们使进程命名空间保持启用，给人虚假的容器化错觉，但实际上禁用了所有安全功能。
- en: '“Privileged” is a specific `securityContext` configuration: all but the process
    namespace is disabled, virtual filesystems are unmasked, LSMs are disabled, and
    all capabilities are granted.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: “Privileged”是特定的`securityContext`配置：除了进程命名空间外，所有功能都被禁用，虚拟文件系统被取消掩码，LSM被禁用，并且授予所有功能。
- en: 'Running as a nonroot user without capabilities, and setting `AllowPrivilegeEscalation`
    to `false` provides a robust protection against many privilege escalations:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 以非root用户运行，并将`AllowPrivilegeEscalation`设置为`false`可有效防止许多特权升级：
- en: '[PRE34]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The granularity of security contexts means each property of the configuration
    must be tested to ensure it is not set: as a defender by configuring admission
    control and testing YAML or as an attacker with a dynamic test (or [amicontained](https://oreil.ly/BIQCJ))
    at runtime.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 安全上下文的粒度意味着必须测试配置的每个属性，以确保它没有设置：作为配置管理者通过配置入场控制和测试YAML，或作为运行时的攻击者使用动态测试（或[amicontained](https://oreil.ly/BIQCJ)）。
- en: Tip
  id: totrans-360
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: We explore how to detect privileges inside a container later in this chapter.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面探讨如何检测容器内的特权。
- en: Sharing namespaces with the host also reduces the isolation of the container
    and opens it to greater potential risk. Any mounted filesystems effectively add
    to the mount namespace.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 与主机共享命名空间还会降低容器的隔离性，并使其面临更大的潜在风险。任何挂载的文件系统实际上都会增加挂载命名空间。
- en: Ensure your pods’ `securityContext`s are correct and your systems will be safer
    against known attacks.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您的Pod的`securityContext`正确，并且您的系统将更安全地抵御已知攻击。
- en: Enhancing the securityContext with Kubesec
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Kubesec增强securityContext
- en: '[Kubesec](https://kubesec.io) is a simple tool to validate the security of
    a Kubernetes resource.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubesec](https://kubesec.io)是一款验证Kubernetes资源安全性的简单工具。'
- en: 'It returns a risk score for the resource, and advises on how to tighten the
    `securityContext` (note that we edited the output to fit):'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 它为资源返回一个风险评分，并建议如何加强`securityContext`（请注意，我们编辑了输出以适应）：
- en: '[PRE35]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[Kubesec.io](https://kubesec.io) documents practical changes to make to your
    securityContext, and we’ll document some of them here.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '[Kubesec.io](https://kubesec.io)记录了对您的securityContext进行的实际更改，我们将在此文档中记录其中一些。'
- en: Tip
  id: totrans-369
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 提示
- en: Shopify’s excellent [kubeaudit](https://oreil.ly/LHy2P) provides similar functionality
    for all resources in a cluster.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: Shopify出色的[kubeaudit](https://oreil.ly/LHy2P)为集群中的所有资源提供了类似的功能。
- en: Hardened securityContext
  id: totrans-371
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强化的securityContext
- en: The NSA published [“Kubernetes Hardening Guidance”](https://oreil.ly/2riDP),
    which recommends a hardened set of `securityContext` standards. It recommends
    scanning for vulnerabilities and misconfigurations, least privilege, good RBAC
    and IAM, network firewalling and encryption, and “to periodically review all Kubernetes
    settings and use vulnerability scans to help ensure risks are appropriately accounted
    for and security patches are applied.”
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: NSA发布了《“Kubernetes硬化指南”》（https://oreil.ly/2riDP），建议使用一套加固的`securityContext`标准。建议扫描漏洞和配置错误，最小权限，良好的RBAC和IAM，网络防火墙和加密，并“定期审查所有Kubernetes设置，并使用漏洞扫描来确保适当地考虑风险并应用安全补丁。”
- en: Assigning least privilege to a container in a pod is the responsibility of the
    `securityContext` (see details in [Table 2-2](#sec-context-fields)). Note that
    the PodSecurityPolicy resource discussed in [“Runtime Policies”](ch08.xhtml#policy-runtime-policies)
    maps onto the config flags available in `securityContext`.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在Pod中为容器分配最少权限是`securityContext`的责任（详细信息请参见[表2-2](#sec-context-fields)）。请注意，讨论的PodSecurityPolicy资源映射到`securityContext`中可用的配置标志。
- en: Table 2-2\. `securityContext fields`
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 表2-2 `securityContext字段`
- en: '| Field name(s) | Usage | Recommendations |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 字段名称 | 用法 | 建议 |'
- en: '| --- | --- | --- |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `privileged` | Controls whether pods can run privileged containers. | Set
    to `false`. |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| `privileged` | 控制是否可以运行特权容器。 | 设置为`false`。 |'
- en: '| `hostPID`, `hostIPC` | Controls whether containers can share host process
    namespaces. | Set to `false`. |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| `hostPID`，`hostIPC` | 控制容器是否可以共享主机进程命名空间。 | 设置为`false`。 |'
- en: '| `hostNetwork` | Controls whether containers can use the host network. | Set
    to `false`. |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| `hostNetwork` | 控制容器是否可以使用主机网络。 | 设置为`false`。 |'
- en: '| `allowedHostPaths` | Limits containers to specific paths of the host filesystem.
    | Use a “dummy” path name (such as `/foo` marked as read-only). Omitting this
    field results in no admission restrictions being placed on containers. |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '| `allowedHostPaths` | 限制容器访问主机文件系统的特定路径。 | 使用一个标记为只读的“虚拟”路径名（例如 `/foo`）。如果省略此字段，则不会对容器施加任何准入限制。
    |'
- en: '| `readOnlyRootFilesystem` | Requires the use of a read only root filesystem.
    | Set to `true` when possible. |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| `readOnlyRootFilesystem` | 要求使用只读根文件系统。 | 在可能的情况下设置为 `true`。 |'
- en: '| `runAsUser`, `runAsGroup`, `supplementalGroups`, `fsGroup` | Controls whether
    container applications can run with root privileges or with root group membership.
    | Set `runAsUser` to `MustRunAsNonRoot`.Set `runAsGroup` to `nonzero`.Set `supplementalGroups`
    to `nonzero`.Set `fsGroup` to `nonzero`. |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| `runAsUser`, `runAsGroup`, `supplementalGroups`, `fsGroup` | 控制容器应用程序是否可以以
    root 权限或以 root 组成员身份运行。 | 将 `runAsUser` 设置为 `MustRunAsNonRoot`。将 `runAsGroup`
    设置为非零值。将 `supplementalGroups` 设置为非零值。将 `fsGroup` 设置为非零值。 |'
- en: '| `allowPrivilegeEscalation` | Restricts escalation to root privileges. | Set
    to `false`. This measure is required to effectively enforce `runAsUser: MustRunAsNonRoot`
    settings. |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| `allowPrivilegeEscalation` | 限制提升至 root 权限。 | 设置为 `false`。这一措施是有效执行 `runAsUser:
    MustRunAsNonRoot` 设置的必要条件。 |'
- en: '| `SELinux` | Sets the SELinux context of the container. | If the environment
    supports SELinux, consider adding SELinux labeling to further harden the container.
    |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| `SELinux` | 设置容器的 SELinux 上下文。 | 如果环境支持 SELinux，请考虑添加 SELinux 标签以进一步增强容器的安全性。
    |'
- en: '| `AppArmor` annotations | Sets the AppArmor profile used by containers. |
    Where possible, harden containerized applications by employing AppArmor to constrain
    exploitation. |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| `AppArmor` 注解 | 设置容器使用的 AppArmor 配置文件。 | 在可能的情况下，通过使用 AppArmor 来限制容器化应用程序的利用。
    |'
- en: '| `seccomp` annotations | Sets the `seccomp` profile used to sandbox containers.
    | Where possible, use a `seccomp` auditing profile to identify required syscalls
    for running applications; then enable a `seccomp` profile to block all other syscalls.
    |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '| `seccomp` 注解 | 设置用于沙箱容器的 `seccomp` 配置文件。 | 在可能的情况下，使用 `seccomp` 审计配置文件识别运行应用程序所需的系统调用；然后启用
    `seccomp` 配置文件以阻止所有其他系统调用。 |'
- en: Let’s explore these in more detail using the `kubesec` static analysis tool,
    and the selectors it uses to interrogate your Kubernetes resources.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `kubesec` 静态分析工具详细探讨这些内容，并且它用于查询您的 Kubernetes 资源的选择器。
- en: containers[] .securityContext .privileged
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containers[] .securityContext .privileged
- en: A privileged container running is potentially a bad day for your security team.
    Privileged containers disable namespaces (except `process`) and LSMs, grant all
    capabilities, expose the host’s devices through */dev*, and generally make things
    insecure by default. This is the first thing an attacker looks for in a newly
    compromised pod.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 一个运行特权容器可能会对您的安全团队造成不良影响。特权容器禁用了除 `process` 外的所有命名空间和 LSMs，授予所有权限，通过 */dev*
    暴露主机设备，并且通常默认情况下是不安全的。这是攻击者在新受损 pod 中首先查找的内容。
- en: .spec .hostPID
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .spec .hostPID
- en: '`hostPID` allows traversal from the container to the host through the */proc*
    filesystem, which symlinks other processes’ root filesystems. To read from the
    host’s process namespace, `privileged` is needed as well:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '`hostPID` 允许通过 */proc* 文件系统从容器遍历到主机，该文件系统通过符号链接其他进程的根文件系统。要从主机的进程命名空间中读取，还需要
    `privileged`：'
- en: '[PRE36]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[![1](Images/1.png)](#co_pod_level_resources_CO3-1)'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '[![1](Images/1.png)](#co_pod_level_resources_CO3-1)'
- en: Start a privileged container and share the host process namespace.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个特权容器并共享主机进程命名空间。
- en: '[![2](Images/2.png)](#co_pod_level_resources_CO3-2)'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '[![2](Images/2.png)](#co_pod_level_resources_CO3-2)'
- en: As the root user in the container, check the container’s operating system version.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 作为容器中的 root 用户，检查容器的操作系统版本。
- en: '[![3](Images/3.png)](#co_pod_level_resources_CO3-3)'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '[![3](Images/3.png)](#co_pod_level_resources_CO3-3)'
- en: Verify we’re in the host’s process namespace (we can see PID 1, and kernel helper
    processes).
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 验证我们是否在主机的进程命名空间中（我们可以看到 PID 1 和内核辅助进程）。
- en: '[![4](Images/4.png)](#co_pod_level_resources_CO3-4)'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '[![4](Images/4.png)](#co_pod_level_resources_CO3-4)'
- en: Check the distribution version of the host, via the */proc* filesystem inside
    the containe. This is possible because the PID namespace is shared with the host.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 检查容器内部 */proc* 文件系统中的宿主分发版本。这是可能的，因为 PID 命名空间与主机共享。
- en: Note
  id: totrans-401
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: 'Without `privileged`, the host process namespace is inaccessible to root in
    the container:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有 `privileged`，则容器中的 root 无法访问宿主的进程命名空间：
- en: '[PRE37]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In this case the attacker is limited to searching the filesystem or memory as
    their UID allows, hunting for key material or sensitive data.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，攻击者受其UID限制，可以搜索文件系统或内存，寻找关键材料或敏感数据。
- en: .spec .hostNetwork
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .spec .hostNetwork
- en: Host networking access allows us to sniff traffic or send fake traffic over
    the host adapter (but only if we have permission to do so, enabled by `CAP_NET_RAW`
    or `CAP_NET_ADMIN`), and evade network policy (which depends on traffic originating
    from the expected source IP of the adapter in the pod’s network namespace).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 主机网络访问允许我们嗅探流量或在主机适配器上发送虚假流量（但仅当我们有权限执行时，通过`CAP_NET_RAW`或`CAP_NET_ADMIN`启用），并逃避依赖流量起源于Pod网络命名空间中预期源IP的网络策略。
- en: It also grants access to services bound to the host’s loopback adapter (`localhost`
    in the root network namespace) that traditionally was considered a security boundary.
    Server Side Request Forgery (SSRF) attacks have reduced the incidence of this
    pattern, but it may still exist (Kubernetes’ API server `--insecure-port` used
    this pattern until it was deprecated in v1.10 and finally removed in v1.20).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 还允许访问绑定到主机回环适配器（在根网络命名空间中为`localhost`）的服务，传统上被视为安全边界。服务器端请求伪造（SSRF）攻击减少了这种模式的发生，但仍可能存在（Kubernetes的API服务器`--insecure-port`在v1.10中使用了此模式，最终在v1.20中删除）。
- en: .spec .hostAliases
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .spec .hostAliases
- en: Permits pods to override their local */etc/hosts* files. This may have more
    operational implications (like not being updated in a timely manner and causing
    an outage) than security connotations.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Pod覆盖其本地*/etc/hosts*文件。这可能会带来更多的操作上的影响（例如无法及时更新导致故障），而非安全上的含义。
- en: .spec .hostIPC
  id: totrans-410
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .spec .hostIPC
- en: Gives the pod access to the host’s Interprocess Communication namespace, where
    it may be able to interfere with trusted processes on the host. It’s likely this
    will enable simple host compromise via */usr/bin/ipcs* or files in shared memory
    at */dev/shm*.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 允许Pod访问主机的进程间通信命名空间，可能会干扰主机上的受信任进程。这可能使得简单通过*/usr/bin/ipcs*或共享内存文件*/dev/shm*实现主机妥协。
- en: containers[] .securityContext .runAsNonRoot
  id: totrans-412
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containers[] .securityContext .runAsNonRoot
- en: The root user has special permissions in a Linux system, and although the permissions
    set is reduced within a container, the root user is still treated differently
    by lots of kernel code.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux系统中，根用户具有特殊权限，尽管在容器中设置权限较低，但根用户仍然被大量内核代码特殊对待。
- en: Preventing root from owning the processes inside the container is a simple and
    effective security measure. It stops many of the container breakout attacks listed
    in this book, and adheres to standard and established Linux security practice.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 防止根用户拥有容器内的进程是一种简单且有效的安全措施。它阻止了本书列出的许多容器逃逸攻击，并遵循标准和已建立的Linux安全实践。
- en: containers[] .securityContext .runAsUser > 10000
  id: totrans-415
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containers[] .securityContext .runAsUser > 10000
- en: 'In addition to preventing root running processes, enforcing high UIDs for containerized
    processes lowers the risk of breakout without user namespaces: if the user in
    the container (e.g., 12345) has an equivalent UID on the host (that is, also 12345),
    and the user in the container is able to reach them through mounted volume or
    shared namespace, then resources may accidentally be shared and allow container
    breakout (e.g., filesystem permissions and authorization checks).'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 除了防止根运行进程外，强制容器化进程的高UID降低了无用户命名空间的逃逸风险：如果容器中的用户（例如12345）在主机上有等效UID（也是12345），并且容器中的用户能够通过挂载卷或共享命名空间与它们联系，那么资源可能会意外地共享，并允许容器逃逸（例如，文件系统权限和授权检查）。
- en: containers[] .securityContext .readOnlyRootFilesystem
  id: totrans-417
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containers[] .securityContext .readOnlyRootFilesystem
- en: 'Immutability is not a security boundary as code can be downloaded from the
    internet and run by an interpreter (such as Bash, PHP, and Java) without using
    the filesystem, as the `bashark` post-exploitation toolkit shows:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变性不是安全边界，因为代码可以从互联网下载并由解释器（如Bash、PHP和Java）运行，而不使用文件系统，正如`bashark`后渗透工具所示：
- en: '[PRE38]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Filesystem locations like */tmp* and */dev/shm* will probably always be writable
    to support application behavior, and so read-only filesystems cannot be relied
    upon as a security boundary. Immutability will prevent against some drive-by and
    automated attacks, but is not a robust security boundary.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 文件系统位置像*/tmp*和*/dev/shm*可能会始终可写，以支持应用程序的行为，因此不能依赖只读文件系统作为安全边界。不可变性将防止某些随机和自动化攻击，但不是强大的安全边界。
- en: Intrusion detection tools such as `falco` and `tracee` can detect new Bash shells
    spawned in a container (or any non-allowlisted applications). Additionally `tracee`
    can [detect in-memory execution](https://oreil.ly/Ur0wV) of malware that attempts
    to hide itself by observing */proc/pid/maps* for memory that was once writable
    but is now executable.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 诸如 `falco` 和 `tracee` 的入侵检测工具可以检测到容器中产生的新的 Bash shell（或任何未列入白名单的应用程序）。此外，`tracee`
    还可以通过观察 */proc/pid/maps* 来检测试图通过内存中执行的恶意软件。
- en: Note
  id: totrans-422
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: We look at Falco in more detail in [Chapter 9](ch09.xhtml#ch-intrusion-detection).
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会在[第9章](ch09.xhtml#ch-intrusion-detection)详细讨论 Falco。
- en: containers[] .securityContext .capabilities .drop | index(“ALL”)
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containers[] .securityContext .capabilities .drop | index(“ALL”)
- en: You should always drop all capabilities and only readd those that your application
    needs to operate.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该总是删除所有的能力，只重新添加你的应用程序需要的那些。
- en: containers[] .securityContext .capabilities .add | index(“SYS_ADMIN”)
  id: totrans-426
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containers[] .securityContext .capabilities .add | index(“SYS_ADMIN”)
- en: 'The presence of this capability is a red flag: try to find another way to deploy
    any container that requires this, or deploy into a dedicated namespace with custom
    security rules to limit the impact of compromise.'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 这种能力的存在是一个警告信号：尽量找到部署任何需要它的容器的另一种方法，或者在具有自定义安全规则的专用命名空间中部署，以限制妥协的影响。
- en: containers[] .resources .limits .cpu, .memory
  id: totrans-428
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containers[] .resources .limits .cpu, .memory
- en: Limiting the total amount of memory available to a container prevents denial
    of service attacks taking out the host machine, as the container dies first.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 限制容器可用内存的总量可以防止拒绝服务攻击将主机机器挤垮，因为容器会首先死掉。
- en: containers[] .resources .requests .cpu, .memory
  id: totrans-430
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: containers[] .resources .requests .cpu, .memory
- en: Requesting resources helps the scheduler to “bin pack” resources effectively.
    Over-requesting resources may be an adversary’s attempt to schedule new pods to
    another Node they control.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 请求资源有助于调度器有效地“装箱”资源。过度请求资源可能是对手试图将新的 Pod 调度到他们控制的另一个节点的尝试。
- en: .spec .volumes[] .hostPath .path
  id: totrans-432
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .spec .volumes[] .hostPath .path
- en: A writable */var/run/docker.sock* host mount allows breakout to the host. Any
    filesystem that an attacker can write a symlink to is vulnerable, and an attacker
    can use that path to explore and exfiltrate from the host.
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 可写的 */var/run/docker.sock* 主机挂载允许突破到主机。任何攻击者可以写符号链接的文件系统都是有漏洞的，攻击者可以使用这条路径探索和从主机外泄。
- en: Into the Eye of the Storm
  id: totrans-434
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入风暴的眼眸
- en: The Captain and crew have had a fruitless raid, but this is not the last we
    will hear of their escapades.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 船长和船员进行了一次徒劳的袭击，但这并不是我们将听到的最后一次逃避行动。
- en: As we progress through this book, we will see how Kubernetes pod components
    interact with the wider system, and we will witness Captain Hashjack’s efforts
    to exploit them.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们阅读这本书的过程中，我们将看到 Kubernetes 容器组件如何与更广泛的系统交互，我们将见证 Hashjack 船长努力利用它们的过程。
- en: Conclusion
  id: totrans-437
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: There are multiple layers of configuration to secure for a pod to be used safely,
    and the workloads you run are the soft underbelly of Kubernetes security.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安全地使用一个 Pod，需要对多层配置进行限制，你运行的工作负载是 Kubernetes 安全的软肋。
- en: The pod is the first line of defense and the most important part of a cluster
    to protect. Application code changes frequently and is likely to be a source of
    potentially exploitable bugs.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 是保护集群的第一道防线，也是最重要的部分。应用程序代码经常更改，很可能是潜在的可利用漏洞的来源。
- en: To extend the anchor and chain metaphor, a cluster is only a strong as its weakest
    link. In order to be provably secure, you must use robust configuration testing,
    preventative control and policy in the pipeline and admission control, and runtime
    intrusion detection—as nothing is infallible.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展锚和链的比喻，一个集群只有其最薄弱环节才强大。为了可以被证明是安全的，你必须使用强大的配置测试、预防性控制和管道与准入控制中的策略，以及运行时入侵检测——因为没有什么是绝对无懈可击的。
