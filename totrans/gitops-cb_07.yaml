- en: Chapter 6\. Cloud Native CI/CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter you learned about Helm, a popular templating system
    for Kubernetes. All the recipes from previous chapters represent a common tooling
    for creating and managing containers for Kubernetes, and now it’s time to think
    about the automation on Kubernetes using such tools. Let’s move our focus to the
    cloud native continuous integration/continuous deployment (CI/CD).
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration is an automated process that takes new code created by
    a developer and builds, tests, and runs that code. The cloud native CI refers
    to the model where cloud computing and cloud services are involved in this process.
    The benefits from this model are many, such as portable and reproducible workloads
    across clouds for highly scalable and on-demand use cases. And it also represents
    the building blocks for GitOps workflows as it enables automation through actions
    performed via Git.
  prefs: []
  type: TYPE_NORMAL
- en: '[Tekton](https://tekton.dev) is a popular open source implementation of a cloud
    native CI/CD system on top of Kubernetes. In fact, Tekton installs and runs as
    an extension on a Kubernetes cluster and comprises a set of Kubernetes Custom
    Resources that define the building blocks you can create and reuse for your pipelines.^([1](ch06.xhtml#idm45120836250416))
    (See [Recipe 6.1](#recipe_6_1).)'
  prefs: []
  type: TYPE_NORMAL
- en: The Tekton engine lives inside a Kubernetes cluster and through its API objects
    represents a declarative way to define the actions to perform. The core components
    such as *Tasks* and *Pipelines* can be used to create a pipeline to generate artifacts
    and/or containers from a Git repository (see Recipes [6.2](#recipe_6_2), [6.3](#recipe_6_3),
    and [6.4](#recipe_6_4)).
  prefs: []
  type: TYPE_NORMAL
- en: Tekton also supports a mechanism for automating the start of a Pipeline with
    *Triggers*. These allow you to detect and extract information from events from
    a variety of sources, such as a webhook, and to start Tasks or Pipelines accordingly
    (see [Recipe 6.8](#recipe_6_8)).
  prefs: []
  type: TYPE_NORMAL
- en: Working with private Git repositories is a common use case that Tekton supports
    nicely (see [Recipe 6.4](#recipe_6_4)), and building artifacts and creating containers
    can be done in many ways such as with Buildah (see [Recipe 6.5](#recipe_6_5))
    or Shipwright, which we discussed in [Chapter 3](ch03.xhtml#ch_Containers). It
    is also possible to integrate Kustomize (see [Recipe 6.9](#rec_Kustomize)) and
    Helm (see [Recipe 6.10](#rec_Helm)) in order to make the CI part dynamic and take
    benefit of the rich ecosystem of Kubernetes tools.
  prefs: []
  type: TYPE_NORMAL
- en: Tekton is Kubernetes-native solution, thus it’s universal; however, it’s not
    the only cloud native CI/CD citizen in the market. Other good examples for GitOps-ready
    workloads are Drone ([Recipe 6.11](#rec_Drone)) and GitHub Actions ([Recipe 6.12](#rec_GitHub_Actions)).
  prefs: []
  type: TYPE_NORMAL
- en: 6.1 Install Tekton
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to install Tekton in order to have cloud native CI/CD on your Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tekton](https://tekton.dev) is a Kubernetes-native CI/CD solution that can
    be installed on top of any Kubernetes cluster. The installation brings you a set
    of [Kubernetes Custom Resources (CRDs)](https://oreil.ly/mv0cl) that you can use
    to compose your Pipelines, as shown in [Figure 6-1](#fig6-1):'
  prefs: []
  type: TYPE_NORMAL
- en: Task
  prefs: []
  type: TYPE_NORMAL
- en: A reusable, loosely coupled number of steps that perform a specific function
    (e.g., building a container image). Tasks get executed as Kubernetes pods, while
    steps in a Task map onto containers.
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: A list Tasks needed to build and/or deploy your apps.
  prefs: []
  type: TYPE_NORMAL
- en: TaskRun
  prefs: []
  type: TYPE_NORMAL
- en: The execution and result of running an instance of a Task.
  prefs: []
  type: TYPE_NORMAL
- en: PipelineRun
  prefs: []
  type: TYPE_NORMAL
- en: The execution and result of running an instance of a Pipeline, which includes
    a number of TaskRuns.
  prefs: []
  type: TYPE_NORMAL
- en: Trigger
  prefs: []
  type: TYPE_NORMAL
- en: Detects an event and connects to other CRDs to specify what happens when such
    an event occurs.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tekton Pipelines](assets/gocb_0601.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-1\. Tekton Pipelines
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: To install Tekton, you just need `kubectl` CLI and a Kubernetes cluster such
    as Minikube (see [Chapter 2](ch02.xhtml#ch_Requirements)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Tekton has a modular structure. You can install all components separately or
    all at once (e.g., with an Operator):'
  prefs: []
  type: TYPE_NORMAL
- en: Tekton Pipelines
  prefs: []
  type: TYPE_NORMAL
- en: Contains Tasks and Pipelines
  prefs: []
  type: TYPE_NORMAL
- en: Tekton Triggers
  prefs: []
  type: TYPE_NORMAL
- en: Contains Triggers and EventListeners
  prefs: []
  type: TYPE_NORMAL
- en: Tekton Dashboard
  prefs: []
  type: TYPE_NORMAL
- en: A convenient dashboard to visualize Pipelines and logs
  prefs: []
  type: TYPE_NORMAL
- en: Tekton CLI
  prefs: []
  type: TYPE_NORMAL
- en: A CLI to manage Tekton objects (start/stop Pipelines and Tasks, check logs)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also use a Kubernetes Operator to install and manage Tekton components
    on your cluster. See more details on how from [OperatorHub](https://oreil.ly/6UoU3).
  prefs: []
  type: TYPE_NORMAL
- en: 'First you need to install the [Tekton Pipelines](https://oreil.ly/o0L2V) component.
    At the time of writing this book, we are using version 0.37.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation will create a new Kubernetes namespace called `tekton-pipelines`
    and you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You can monitor and verify the installation with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The preceding command goes in watch mode, thus it remains appended. Press Ctrl+C
    in order to stop it when you see the controller and webhook pods in Running status.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can install [Tekton Triggers](https://oreil.ly/Vq32h). At the time
    of writing this book, we are using version 0.20.1:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can monitor and verify the installation with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see three new pods created and running—`tekton-triggers-controller`,
    `tekton-triggers-core-interceptors`, and `tekton-triggers-webhook`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After this you have a fully working Tekton installation on top of your Kubernetes
    cluster, supporting Pipelines and automation via event Triggers. In addition to
    that, you could install the [Tekton Dashboard](https://oreil.ly/Db56q) in order
    to visualize Tasks, Pipelines, and logs via a nice UI. At the time of writing
    this book, we are using version 0.28.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can monitor and verify the installation with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see a new pod created and running—`tekton-dashboard`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the Dashboard is not exposed outside the Kubernetes cluster. You
    can access it by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: There are several ways to expose internal services in Kubernetes; you could
    also create an [Ingress](https://oreil.ly/wwWcX) for that as shown in the Tekton
    Dashboard [documentation](https://oreil.ly/BeOlq).
  prefs: []
  type: TYPE_NORMAL
- en: You can now browse to *http://localhost:9097* to access your Dashboard, as shown
    in [Figure 6-2](#fig6-2).
  prefs: []
  type: TYPE_NORMAL
- en: You can download and install the [Tekton CLI](https://oreil.ly/U7FSt) for your
    OS to start creating Tasks and Pipelines from the command line. At the time of
    writing this book, we are using version 0.25.0.
  prefs: []
  type: TYPE_NORMAL
- en: '![Tekton Dashboard](assets/gocb_0602.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-2\. Tekton Dashboard
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Finally, verify that `tkn` and Tekton are configured correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tekton Getting Started](https://oreil.ly/7I7ev)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.2 Create a Hello World Task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to start using Tekton by exploring Tasks and creating a sample one.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Tekton, a Task defines a series of steps that run sequentially to perform
    logic that the Task requires. Every [Task](https://oreil.ly/5ldpn) runs as a pod
    on your Kubernetes cluster, with each step running in its own container. While
    steps within a Task are sequential, Tasks can be executed inside a Pipeline in
    parallel. Therefore, Tasks are the building blocks for running Pipelines with
    Tekton.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a Hello World Task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The API as an object of kind `Task`
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cloud_native_ci_cd_CO1-2)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the Task
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_cloud_native_ci_cd_CO1-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The list of steps contained within this Task, in this case just one
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_cloud_native_ci_cd_CO1-4)'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the step
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_cloud_native_ci_cd_CO1-5)'
  prefs: []
  type: TYPE_NORMAL
- en: The container image where the step starts
  prefs: []
  type: TYPE_NORMAL
- en: 'First you need to create this resource in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that the object has been created in your current Kubernetes
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can start your Tekton Task with `tkn` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: A TaskRun is the API representation of a running Task. See [Recipe 6.3](#recipe_6_3)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tekton Task documentation](https://oreil.ly/5ldpn)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.3 Create a Task to Compile and Package an App from Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to automate compiling and packaging an app from Git on Kubernetes with
    Tekton.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As seen in [Recipe 6.2](#recipe_6_2), Tekton Tasks have a flexible mechanism
    to add a list of sequential steps to automate actions. The idea is to create a
    list of Tasks with a chain of input/output that can be used to compose Pipelines.
    Therefore a Task can contain a series of optional fields for a better control
    over the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '`inputs`'
  prefs: []
  type: TYPE_NORMAL
- en: The resources ingested by the Task.
  prefs: []
  type: TYPE_NORMAL
- en: '`outputs`'
  prefs: []
  type: TYPE_NORMAL
- en: The resources produced by the Task.
  prefs: []
  type: TYPE_NORMAL
- en: '`params`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The parameters that will be used in the Task steps. Each parameter has:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs: []
  type: TYPE_NORMAL
- en: The name of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`description`'
  prefs: []
  type: TYPE_NORMAL
- en: The description of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`default`'
  prefs: []
  type: TYPE_NORMAL
- en: The default value of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: '`results`'
  prefs: []
  type: TYPE_NORMAL
- en: The names under which Tasks write execution results.
  prefs: []
  type: TYPE_NORMAL
- en: '`workspaces`'
  prefs: []
  type: TYPE_NORMAL
- en: The paths to volumes needed by the Task.
  prefs: []
  type: TYPE_NORMAL
- en: '`volumes`'
  prefs: []
  type: TYPE_NORMAL
- en: The Task can also mount external volumes using the `volumes` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: The following example, as illustrated in [Figure 6-3](#fig6-3), shows a Task
    named `build-app` that clones the sources using the `git` command and lists the
    source code in output.
  prefs: []
  type: TYPE_NORMAL
- en: '![Build App Task](assets/gocb_0603.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-3\. `build-app` Task
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO2-1)'
  prefs: []
  type: TYPE_NORMAL
- en: A Task step and Pipeline Task can share a common filesystem via a Tekton workspace.
    The workspace could be either backed by something like PersistentVolumeClaim (PVC)
    and a `ConfigMap`, or just ephemeral (`emptyDir`).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cloud_native_ci_cd_CO2-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A Task can have parameters; this feature makes the execution dynamic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the Task with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'You can verify that the object has been created in your current Kubernetes
    namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also list the Task with the `tkn` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'When you start a Task, a new [TaskRun](https://oreil.ly/MZ5DY) object is created.
    TaskRuns are the API representation of a running Task; thus you can create it
    with the `tkn` CLI using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: When parameters are used inside a Task or Pipeline, you will be prompted to
    add new values or confirm default ones, if any. In order to use the default values
    from the Task defintion without prompting for values, you can use the `--use-param-defaults`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can create a `TaskRun` object manually like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO3-1)'
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to specify a name for each `TaskRun`, you can use the `generateName`
    attribute to let Tekton pick a random one from the string you defined.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cloud_native_ci_cd_CO3-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you list the Task that the `TaskRun` is referring to.
  prefs: []
  type: TYPE_NORMAL
- en: 'And start it in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also verify it with the `tkn` CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can get the logs from the `TaskRun` by specifying the name of the `TaskRun`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Debugging a TaskRun](https://oreil.ly/PxRNG)'
  prefs: []
  type: TYPE_NORMAL
- en: 6.4 Create a Task to Compile and Package an App from Private Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use a private Git repository to automate compiling and packaging
    of an app on Kubernetes with Tekton.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [Recipe 6.3](#recipe_6_3) you saw how to compile and package a sample Java
    application using a public Git repository, but most of the time people deal with
    private repos at work, so how do you integrate them? Tekton supports the following
    authentication schemes for use with Git:'
  prefs: []
  type: TYPE_NORMAL
- en: Basic-auth
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSH
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With both options you can use a Kubernetes [Secret](https://oreil.ly/Oxj6W)
    to store your credentials and attach them to the [`ServiceAccount`](https://oreil.ly/6UC3O)
    running your Tekton Tasks or Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Tekton uses a default service account, however you can override it following
    the documentation [here](https://oreil.ly/ID6m0).
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a common example of basic authentication and a popular Git
    service such as GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: GitHub uses personal access tokens (PATs) as an alternative to using passwords
    for authentication. You can use a PAT instead of a clear-text password to enhance
    security.
  prefs: []
  type: TYPE_NORMAL
- en: 'First you need to create a Secret. You can do this by creating the following
    YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO4-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you specify the URL for which Tekton will use this Secret, in this case
    GitHub
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cloud_native_ci_cd_CO4-2)'
  prefs: []
  type: TYPE_NORMAL
- en: This is the type of Secret, in this case a basic authentication one
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_cloud_native_ci_cd_CO4-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Your Git user, in this case your GitHub user
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_cloud_native_ci_cd_CO4-4)'
  prefs: []
  type: TYPE_NORMAL
- en: You Git password, in this case your GitHub personal access token
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now create the Secret with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also avoid writing YAML and do everything with `kubectl` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'And then you just annotate the Secret as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Once you have created and annotated your Secret, you have to attach it to the
    `ServiceAccount` running your Tekton Tasks or Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new `ServiceAccount` for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO5-1)'
  prefs: []
  type: TYPE_NORMAL
- en: List of Secrets attached to this `ServiceAccount`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can create the `ServiceAccount` directly with `kubectl` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'and then patch it to add the secret reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Once credentials are set up and linked to the `ServiceAccount` running Tasks
    or Pipelines, you can just add the `--serviceaccount=<NAME>` option to your `tkn`
    command, using the [Recipe 6.3](#recipe_6_3) example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO6-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you specify the `ServiceAccount` to use; this will override the default
    one at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cloud_native_ci_cd_CO6-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you can override the default repository with one of your choice. In this
    example there’s a private repository that you cannot access, but you can create
    a private repository on your own and test it like this.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tekton Authentication](https://oreil.ly/6W9xF)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.5 Containerize an Application Using a Tekton Task and Buildah
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to compile, package, and containerize your app with a Tekton Task on
    Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automation is essential when adopting the cloud native approach, and if you
    decide to use Kubernetes for your CI/CD workloads, you need to provide a way to
    package and deploy your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, Kubernetes per se doesn’t have a built-in mechanism to build containers;
    it just relies on add-ons such as Tekton or external services for this purpose.
    That’s why in [Chapter 3](ch03.xhtml#ch_Containers) we did an overview on how
    to create containers for packaging applications with various open source tools.
    In [Recipe 3.3](ch03.xhtml#recipe_3_3) we used Buildah to create a container from
    a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Tekton’s extensible model, you can reuse the same Task defined in
    [Recipe 6.3](#recipe_6_3) to add a step to create a container using the outcomes
    from the previous steps, as shown in [Figure 6-4](#fig6-4).
  prefs: []
  type: TYPE_NORMAL
- en: '![Build Push app](assets/gocb_0604.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-4\. Build Push app
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The container can be pushed to a public container registry such as DockerHub
    or Quay.io, or to a private container registry. Similar to what we have seen in
    [Recipe 6.4](#recipe_6_4) for private Git repositories, pushing a container image
    to a container registry needs authentication. A Secret needs to be attached to
    the `ServiceAccount` running the Task as follows. See [Chapter 2](ch02.xhtml#ch_Requirements)
    for how to register and use a public registry.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify it is present and check that the Secret is of type `kubernetes.io/dockerconfigjson`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create a `ServiceAccount` for this Task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Then let’s add the previously generated Secret to this `ServiceAccount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s add a new step to create a container image and push it to a container
    registry. In the following example we use the book’s organization repos at Quay.io—`quay.io/gitops-cookbook/tekton-greeter:latest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create this Task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s start the Task with the Buildah step creating a container image and
    with a new parameter `destinationImage` to specify where to push the resulting
    container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO7-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Here you can place your registry; in this example we are using the book’s organization
    repos at Quay.io.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Buildah](https://buildah.io)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Docker Authentication for Tekton](https://oreil.ly/QJlVW)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.6 Deploy an Application to Kubernetes Using a Tekton Task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to deploy an application from a container image to Kubernetes with
    a Tekton Task.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While in Recipes [6.3](#recipe_6_3), [6.4](#recipe_6_4), and [6.5](#recipe_6_5)
    we have listed a Tekton Task that is useful for continuous integration (CI), in
    this recipe we’ll start having a look at the Continous Deployment (CD) part by
    deploying an existing container image to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can reuse the container image we created and pushed in [Recipe 6.5](#recipe_6_5),
    available at `quay.io/gitops-cookbook/tekton-greeter:latest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO8-1)'
  prefs: []
  type: TYPE_NORMAL
- en: For this example we are using `kubectl` from this container image, which also
    contains OpenShift CLI and it has an smaller size compared to `gcr.io/cloud-builders/kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create this Task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'As discussed in [Recipe 6.5](#recipe_6_5), Tekton uses a default `ServiceAccount`
    for running Tasks and Pipelines, unless a specific one is defined at runtime or
    overridden at a global scope. The best practice is always to create a specific
    `ServiceAccount` for a particular action, so let’s create one named `tekton-deployer-sa`
    for this use case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: A `ServiceAccount` needs permission to deploy an application to Kubernetes.
    [Roles and RoleBindings](https://oreil.ly/6ov6J) are API objects used to map a
    certain permission to a user or a `ServiceAccount`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You first define a Role named `pipeline-role` for the `ServiceAccount` running
    the Tekton Task with permissions to deploy apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you need to bind the Role to the `ServiceAccount`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you can create the two resources as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can define a TaskRun as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'And run it in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the logs to see the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds you should see the Deployment in Ready state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The first time might take a while due to the time it takes to pull the container
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check if the app is available, expose the Deployment, and forward Kubernetes
    traffic to your workstation to test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'In another terminal, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tekton Task](https://oreil.ly/YlIZI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.7 Create a Tekton Pipeline to Build and Deploy an App to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a Pipeline to compile, package, and deploy an app on Kubernetes
    with Tekton.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipes we have seen how to create Tasks to execute one or more
    steps sequentially to build apps. In this recipe we will discuss [Tekton Pipelines](https://oreil.ly/aN8lv),
    a collection of Tasks that you can define and compose in a specific order of execution,
    either sequentially or in parallel, as you can see in [Figure 6-5](#fig6-5).
  prefs: []
  type: TYPE_NORMAL
- en: '![Tekton Pipelines flows](assets/gocb_0605.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-5\. Tekton Pipelines flows
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Tekton Pipelines supports parameters and a mechanism to exchange outcomes between
    different Tasks. For instance, using the examples shown in Recipes [6.5](#recipe_6_5)
    and [6.6](#recipe_6_6):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO9-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline parameters
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cloud_native_ci_cd_CO9-2)'
  prefs: []
  type: TYPE_NORMAL
- en: A list of Tasks for the Pipeline
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_cloud_native_ci_cd_CO9-3)'
  prefs: []
  type: TYPE_NORMAL
- en: The exact name of the Task to use
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_cloud_native_ci_cd_CO9-4)'
  prefs: []
  type: TYPE_NORMAL
- en: You can decide the order with the `runAfter` field to indicate that a Task must
    execute after one or more other Tasks
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_cloud_native_ci_cd_CO9-5)'
  prefs: []
  type: TYPE_NORMAL
- en: One or more common Workspaces used to share data between Tasks
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the Pipeline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly to TaskRuns, you can run this Pipeline by creating a [PipelineRun](https://oreil.ly/N8K3a)
    resource as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'You can run the Pipeline by creating this PipelineRun object as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have seen how to reuse existing Tasks within a Pipeline, it’s a
    good time to introduce the [Tekton Hub](https://hub.tekton.dev), a web-based platform
    for developers to discover, share, and contribute Tasks and Pipelines for Tekton
    (see [Figure 6-6](#fig6-6)).
  prefs: []
  type: TYPE_NORMAL
- en: '![Tekton Hub](assets/gocb_0606.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-6\. Tekton Hub
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'You can implement the same Pipeline with Tasks already available in the Hub.
    In our case, we have:'
  prefs: []
  type: TYPE_NORMAL
- en: '[`git-clone`](https://oreil.ly/tVLAG)'
  prefs: []
  type: TYPE_NORMAL
- en: Task that clones a repo from the provided URL into the output Workspace.
  prefs: []
  type: TYPE_NORMAL
- en: '[`buildah`](https://oreil.ly/nTUkZ)'
  prefs: []
  type: TYPE_NORMAL
- en: Task that builds source into a container image and can push it to a container
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: '[`kubernetes-actions`](https://oreil.ly/A3Hui)'
  prefs: []
  type: TYPE_NORMAL
- en: The generic `kubectl` CLI task, which can be used to run all kinds of k8s commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'First let’s add them to our namespace as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following to confirm they are installed
    properly in your namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'You can cross-check it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Some Tekton installations like the one made with the Operator for [OpenShift
    Pipelines](https://oreil.ly/dAKhL) provide a common list of useful Tasks such
    as those just listed, provided as ClusterTasks. ClusterTasks are Tasks available
    for all namespaces within the Kubernetes cluster. Check if your installation already
    provides some with this command: `kubectl get clustertasks`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now the Pipeline has four Tasks, as you can see in [Figure 6-7](#fig6-7).
  prefs: []
  type: TYPE_NORMAL
- en: '![Pipeline](assets/gocb_0607.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-7\. Pipeline
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In this example you’ll see a [PersistentVolumeClaim](https://oreil.ly/Opio5)
    as a Workspace because here the data is shared among different Tasks so we need
    to persist it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, you can create the resource with `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In Minikube you have a default [StorageClass](https://oreil.ly/ZiPnA) that provides
    dynamic storage for the cluster. If you are using another Kubernetes cluster,
    please make sure you have a dynamic storage support.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pipeline definition now is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s create the resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: We are using the same Secret and `ServiceAccount` defined in [Recipe 6.5](#recipe_6_5)
    to log in against Quay.io in order to push the container image.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now start the Pipeline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can use the Tekton Dashboard to create and visualize your running Tasks
    and Pipelines as shown in [Figure 6-8](#fig6-7a).
  prefs: []
  type: TYPE_NORMAL
- en: '![Tekton Dashboard Pipelineruns](assets/gocb_0608.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-8\. Tekton Dashboard TaskRuns
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tekton Catalog](https://oreil.ly/bnUiR)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.8 Using Tekton Triggers to Compile and Package an Application Automatically
    When a Change Occurs on Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to automate your CI/CD Pipelines when a change on Git occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tekton Triggers](https://oreil.ly/zVcfe) is the Tekton component that brings
    automation for Tasks and Pipelines with Tekton. It is an interesting feature for
    a GitOps strategy for cloud native CI/CD as it supports external events from a
    large set of sources such as Git events (Git push or pull requests).'
  prefs: []
  type: TYPE_NORMAL
- en: Most Git repository servers support the concept of webhooks, calling to an external
    source via HTTP(S) when a change in the code repository happens. Tekton provides
    an API endpoint that supports receiving hooks from remote systems in order to
    trigger builds. By pointing the code repository’s hook at the Tekton resources,
    automated code/build/deploy pipelines can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: 'The installation of Tekton Triggers, which we discussed in [Recipe 6.1](#recipe_6_1),
    brings a set of CRDs to manage event handling for Tasks and Pipelines. In this
    recipe we will use the following, as illustrated also in [Figure 6-9](#fig6-8):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Tekton Triggers](assets/gocb_0609.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-9\. Tekton Triggers
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`TriggerTemplate`'
  prefs: []
  type: TYPE_NORMAL
- en: A template for newly created resources. It supports parameters to create specific
    `PipelineRuns`.
  prefs: []
  type: TYPE_NORMAL
- en: '`TriggerBinding`'
  prefs: []
  type: TYPE_NORMAL
- en: Validates events and extracts payload fields.
  prefs: []
  type: TYPE_NORMAL
- en: '`EventListener`'
  prefs: []
  type: TYPE_NORMAL
- en: Connects `TriggerBindings` and `TriggerTemplates` into an addressable endpoint
    (the event sink). It uses the extracted event parameters from each `Trigger​Bind⁠ing`
    (and any supplied static parameters) to create the resources specified in the
    corresponding `TriggerTemplate`. It also optionally allows an external service
    to preprocess the event payload via the interceptor field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating these resources, you need to set up permissions to let Tekton
    Triggers create Pipelines and Tasks. You can use the setup available from [the
    book’s repository](https://oreil.ly/fPTzU) with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a new `ServiceAccount` named `tekton-triggers-sa` that has
    the permissions needed to interact with the Tekton Pipelines component. As confirmation,
    from the previous command you should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add automation to your Pipelines like the one we defined in [Recipe
    6.7](#recipe_6_7) creating these three resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create the resources just listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: 'Contextually, a new pod is created representing the `EventListener`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EventListener` pod listens for events at a specified port, and it is bound
    to a Kubernetes Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: If you are running your Git server outside the cluster (e.g., GitHub or GitLab),
    you need to expose the Service, for example, with an [Ingress](https://oreil.ly/qAUhw).
    Afterwards you can configure webhooks on your Git server using the `EventListener`
    URL associated to your Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'With Minikube you can add support for Ingresses with this command: `minikube
    addons enable ingress`. Then you need to map a hostname for the Ingress.'
  prefs: []
  type: TYPE_NORMAL
- en: For the purpose of this book we can just simulate the webhook as it would come
    from the Git server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First you can map the `EventListener` Service to your local networking with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: Then you can invoke the Trigger by making an HTTP request to *http://localhost:8080*
    using `curl`. The HTTP request must be a POST request containing a JSON payload
    and it should contain the fields referenced via a `TriggerBinding`. In our case
    we mapped `body.repository.clone_url` and `body.after`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Check the documentation of your Git server to get the list of parameters that
    a webhook can generate. In this example we are using the [GitHub Webhooks reference](https://oreil.ly/4AUlu).
  prefs: []
  type: TYPE_NORMAL
- en: 'To test Triggers, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: 'A new Pipeline now is started and you can check it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see it in `Running` status as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Tekton Triggers examples](https://oreil.ly/Xr0ne)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Getting Started with Tekton Triggers](https://oreil.ly/gqKyz)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Securing webhooks with event listeners](https://oreil.ly/iIbXc)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.9 Update a Kubernetes Resource Using Kustomize and Push the Change to Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use Kustomize in your Tekton Pipelines in order to automate Kubernetes
    manifests updates.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we discussed in [Chapter 4](ch04.xhtml#ch_Kustomize), Kustomize is a powerful
    tool to manage Kubernetes manifests. Kustomize can add, remove, or patch configuration
    options without forking. In [Recipe 4.2](ch04.xhtml#recipe_4_2) you saw how to
    update a Kubernetes Deployment with a new container image hash using the `kustomize`
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you’ll see how to let Tekton update it using Kustomize. This
    is very useful for GitOps as it allows an automated update on Git to the manifests
    describing an application running on Kubernetes, favoring the interconnection
    with a GitOps tool such as Argo CD in order to sync resources (see [Chapter 7](ch07.xhtml#ch_Argo_CD)).
  prefs: []
  type: TYPE_NORMAL
- en: When adopting the GitOps approach, it’s common to have one or more repositories
    for the Kubernetes manifests and then one or more repositories for the apps as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus let’s introduce a Task that accepts the Kubernetes manifests repository
    as a parameter and can update the container image reference as seen in [Recipe
    4.2](ch04.xhtml#recipe_4_2):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'This Task is composed of three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git-clone`'
  prefs: []
  type: TYPE_NORMAL
- en: Clones the Kubernetes manifests repository
  prefs: []
  type: TYPE_NORMAL
- en: '`update-digest`'
  prefs: []
  type: TYPE_NORMAL
- en: Runs `kustomize` to update the Kubernetes Deployment with a container image
    hash given as a parameter
  prefs: []
  type: TYPE_NORMAL
- en: '`git-commit`'
  prefs: []
  type: TYPE_NORMAL
- en: Updates the Kubernetes manifest repo with the new container image hash
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create the Task with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now add this Task to a Pipeline similar to the one you saw in [Recipe
    6.7](#recipe_6_7) in order to automate the update of your manifests with Kustomize:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO10-1)'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this example, you can take a result of a previous Task as
    an input for the following one. In this case the hash of the container image generated
    by the `build-push-image` Task is used to update the manifests with Kustomize.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create the Pipeline with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: The `git-commit` step requires authentication to your Git server in order to
    push the updates to the repo. Since this example is on GitHub, we are using a
    GitHub Personal Access Token (see [Recipe 6.4](#recipe_6_4)) attached to the `ServiceAccount`
    `tekton-bot-sa`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure to add the repo and registry’s Kubernetes Secrets as described in
    Recipes [6.4](#recipe_6_4) and [6.5](#recipe_6_5):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Make sure you have created a PVC for the Pipeline as defined in [Recipe 6.7](#recipe_6_7).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you can start the Pipeline as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 6.10 Update a Kubernetes Resource Using Helm and Create a Pull Request
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to automate the deployment of Helm-packaged apps with a Tekton Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 5](ch05.xhtml#ch_Helm) we discussed Helm and how it can be used
    to manage applications on Kubernetes in a convenient way. In this recipe you’ll
    see how to automate Helm-powered deployments through a Pipeline in order to install
    or update an application running on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: As shown in [Recipe 6.7](#recipe_6_7), you can use Tekton Hub to find and install
    Tekton Tasks. In fact, you can use the [`helm-upgrade-from-repo`](https://oreil.ly/oR6GU)
    Task to have Helm support for your Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install it, run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'This Task can install a Helm Chart from a Helm repository. For this example,
    we provide a Helm repository in [this book’s repository](https://oreil.ly/lroxo)
    that you can add with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'You can install the Helm Chart with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'The app should be now deployed and running on Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let’s update the Deployment with a Tekton Task running a `helm upgrade`
    with the following `TaskRun`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO11-1)'
  prefs: []
  type: TYPE_NORMAL
- en: The `helm-upgrade-from-repo` Task needs permission to list objects in the working
    namespace, so you need a `ServiceAccount` with special permissions as seen in
    [Recipe 6.6](#recipe_6_6).
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cloud_native_ci_cd_CO11-2)'
  prefs: []
  type: TYPE_NORMAL
- en: You can override values in the Chart’s *values.yaml* file by adding them in
    this param. Here we are setting up two replicas for the Pac-Man game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Task with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'Check logs with `tkn` CLI and select the running Task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get output similar to the following, where you can see the Helm
    upgrade has been successfully performed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 6.11 Use Drone to Create a Pipeline for Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to create a CI/CD pipeline for Kubernetes with Drone.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Drone](https://www.drone.io) is an open source project for cloud native continuous
    integration (CI). It uses YAML build files to define and execute build pipelines
    inside containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It has two main components:'
  prefs: []
  type: TYPE_NORMAL
- en: Server
  prefs: []
  type: TYPE_NORMAL
- en: Integrates with popular SCMs such as GitHub, GitLab, or Gitea
  prefs: []
  type: TYPE_NORMAL
- en: Runner
  prefs: []
  type: TYPE_NORMAL
- en: Acts as an agent running on a certain platform
  prefs: []
  type: TYPE_NORMAL
- en: You can install the Server of your choice following the [documentation](https://oreil.ly/K1ZR2)
    and install the [Kubernetes Runner](https://oreil.ly/3vydl).
  prefs: []
  type: TYPE_NORMAL
- en: In this example you will create a Java Maven-based pipeline using the Pac-Man
    app. First, install the Drone CLI for your OS; you can get it from the official
    website [here](https://oreil.ly/cdI9Y).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'On macOS, `drone` is available through [Homebrew](https://brew.sh) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Then configure Drone, copy the `DRONE_TOKEN` from your instance under the Drone
    Account settings page, then create/update the file called *.envrc.local* and add
    the variables to override:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Ensure the token is loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Now activate the repo in Drone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: Similarly to Tekton, Drone’s pipeline will compile, test, and build the app.
    Then it will create and push the container image to a registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add credentials to your container registry as follows (here, we’re using Quay.io):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a file called *.drone.yaml* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You can also trigger the pipeline to start by pushing to your Git repo.
  prefs: []
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Example Maven Pipeline from Drone docs](https://oreil.ly/YzWcx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Complete Quarkus pipeline example in Drone](https://oreil.ly/eVT1T)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 6.12 Use GitHub Actions for CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You want to use GitHub Actions for CI in order to compile and package an app
    as a container image ready to be deployed in CD.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[GitHub Actions](https://oreil.ly/hCOUp) are event-driven automation tasks
    available for any GitHub repository. An event automatically triggers the workflow,
    which contains a job. The job then uses steps to control the order in which actions
    are run. These actions are the commands that automate software building, testing,
    and deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, you will add a GitHub Action for building the Pac-Man game container
    image, and pushing it to the [GitHub Container Registry](https://oreil.ly/Bzq7l).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As GitHub Actions are connected to repositories, you can fork the Pac-Man repository
    from this book’s code repositories to add your GitHub Actions. See the documentation
    about [forking repositories](https://oreil.ly/O6HtM) for more info on this topic.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions workflows run into [environments](https://oreil.ly/uXOQ7) and
    they can reference an environment to use the environment’s protection rules and
    secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'Workflows and jobs are defined with a YAML file containing all the needed steps.
    Inside your repository, you can create one with the path `.github/workflows/pacman-ci-action.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[![1](assets/1.png)](#co_cloud_native_ci_cd_CO12-1)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the Action.
  prefs: []
  type: TYPE_NORMAL
- en: '[![2](assets/2.png)](#co_cloud_native_ci_cd_CO12-2)'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables to be used in the workflow. This includes [default environment
    variables](https://oreil.ly/qNE6p) and the Secret you added to the environment.
  prefs: []
  type: TYPE_NORMAL
- en: '[![3](assets/3.png)](#co_cloud_native_ci_cd_CO12-3)'
  prefs: []
  type: TYPE_NORMAL
- en: Here’s where you define which type of trigger you want for this workflow. In
    this case, any change to the repository (Push) to the `master` branch will trigger
    the action to start. Check out the documentation for a [full list of triggers](https://oreil.ly/lGgAE)
    that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: '[![4](assets/4.png)](#co_cloud_native_ci_cd_CO12-4)'
  prefs: []
  type: TYPE_NORMAL
- en: Name of this Job.
  prefs: []
  type: TYPE_NORMAL
- en: '[![5](assets/5.png)](#co_cloud_native_ci_cd_CO12-5)'
  prefs: []
  type: TYPE_NORMAL
- en: List of steps; each step contains an action for the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: '[![6](assets/6.png)](#co_cloud_native_ci_cd_CO12-6)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Buildah Build](https://oreil.ly/IcyGC). This action builds container images
    using Buildah.'
  prefs: []
  type: TYPE_NORMAL
- en: '[![7](assets/7.png)](#co_cloud_native_ci_cd_CO12-7)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Push to Registry](https://oreil.ly/HcSUl). This action is used to push to
    the GitHub Registry using built-in credentials available for GitHub repository
    owners.'
  prefs: []
  type: TYPE_NORMAL
- en: After each Git push or pull request, a new run of the action is performed as
    shown in [Figure 6-10](#fig6-8a).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: GitHub offers its own container registry available at ghcr.io, and container
    images are referenced as part of the [GitHub Packages](https://oreil.ly/aPNi5).
    By default the images are public. See this [book’s repository](https://oreil.ly/EG1zx)
    as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: '![GitHub Actions Environments](assets/gocb_0610.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6-10\. GitHub Actions Jobs
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See Also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[GitHub Actions Jobs](https://oreil.ly/44Qt8)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Red Hat Actions](https://oreil.ly/hFcCd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Deploy to Kubernetes cluster Action](https://oreil.ly/7PaeU)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ^([1](ch06.xhtml#idm45120836250416-marker)) See the [Tekton documentation](https://oreil.ly/NxpqN).
  prefs: []
  type: TYPE_NORMAL
