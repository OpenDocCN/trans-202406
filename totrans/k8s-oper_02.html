<html><head></head><body><section data-pdf-bookmark="Chapter 2. Running Operators" data-type="chapter" epub:type="chapter"><div class="chapter" id="running_operators">&#13;
<h1><span class="label">Chapter 2. </span>Running Operators</h1>&#13;
&#13;
&#13;
<p>In the first section of this chapter we outline the requirements for running the examples in this book, and offer advice on how to establish access to a Kubernetes cluster that satisfies those requirements. In the second section, you’ll use that cluster to investigate what Operators do by installing and using one.</p>&#13;
&#13;
<p>By the end, you’ll have a Kubernetes cluster to use as an Operator test bed, and you’ll know how to deploy an existing Operator on it from a set of manifests. You’ll also have seen an Operator managing its application’s specific internal state in the face of changes and failures, informing your understanding of the Operator architecture and build tools presented in succeeding chapters.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Setting Up an Operator Lab" data-type="sect1"><div class="sect1" id="idm45261343276376">&#13;
<h1>Setting Up an Operator Lab</h1>&#13;
&#13;
<p>To build, test, and run Operators in the following chapters, you’ll need <code>cluster-admin</code> access to a cluster running Kubernetes version v1.11.0 or later. If you’ve already met these requirements, you can skip ahead to the next section. In this section we offer general advice to readers who need to set up a Kubernetes cluster, or who need a local environment for Operator development and testing.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cluster Version Requirements" data-type="sect2"><div class="sect2" id="idm45261343273976">&#13;
<h2>Cluster Version Requirements</h2>&#13;
&#13;
<p>We’ve tested the examples in this book with Kubernetes releases v1.11 up to v1.16. We will state when any feature or action we examine requires a release later than v1.11.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section class="less_space pagebreak-before" data-pdf-bookmark="Control plane extensibility" data-type="sect3"><div class="sect3" id="idm45261343272312">&#13;
<h3>Control plane extensibility</h3>&#13;
&#13;
<p>Kubernetes version 1.2 introduced the API extension mechanism known as the CRD in elemental form as the <em>third party resource</em> (TPR).<a data-primary="third party resources (TPRs)" data-type="indexterm" id="idm45261343269960"/> Since then, the components Operators build on have multiplied and matured, as illustrated in <a data-type="xref" href="#fig2-1">Figure 2-1</a>. CRDs were formalized with the Kubernetes version 1.7 release.</p>&#13;
&#13;
<figure><div class="figure" id="fig2-1">&#13;
<img alt="Figure 2-1: Extensibility Features per Kubernetes Release" src="assets/kuop_0201.png"/>&#13;
<h6><span class="label">Figure 2-1. </span>Extensibility features per Kubernetes release</h6>&#13;
</div></figure>&#13;
&#13;
<p>As you saw in <a data-type="xref" href="ch01.html#chapter_introduction">Chapter 1</a>, a CRD is the definition of a new, site-specific resource (or API endpoint) in the Kubernetes API of a particular cluster. CRDs are one of two essential building blocks for the most basic description of the Operator pattern: a custom controller managing CRs.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Authorization Requirements" data-type="sect2"><div class="sect2" id="idm45261343264248">&#13;
<h2>Authorization Requirements</h2>&#13;
&#13;
<p>Since Operators extend Kubernetes itself, you’ll need privileged, cluster-wide access to a Kubernetes cluster to deploy them, such as the common <code>cluster-admin</code> cluster role.<a data-primary="authorization" data-secondary="requirements for deploying Operators" data-type="indexterm" id="idm45261343262168"/><a data-primary="cluster-admin role" data-type="indexterm" id="idm45261343261144"/></p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Less privileged users can use the services and applications that Operators manage—the “operands.”</p>&#13;
</div>&#13;
&#13;
<p>While you should configure more granular<a data-primary="role-based access control (RBAC)" data-type="indexterm" id="idm45261343258840"/> Kubernetes Role-Based Access Control (RBAC) for production scenarios, having complete control of your cluster means you’ll be able to deploy CRDs and Operators immediately. You’ll also have the power to declare more detailed RBAC as you develop the roles, service accounts, and bindings for your Operators and the applications they manage.</p>&#13;
&#13;
<p>You can ask the Kubernetes API about the <code>cluster-admin</code> role to see if it exists on your cluster. The following shell excerpt shows how to get a summary of the role with the <code>kubectl</code>’s <code>describe</code> subcommand:</p>&#13;
<pre class="pagebreak-before less_space" data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>describe</code><code> </code><code>clusterrole</code><code> </code><code>cluster-admin</code></strong><code>&#13;
</code><code>Name:</code><code>         </code><code>cluster-admin</code><code>  </code><a class="co" href="#c01" id="comarker1"><img alt="1" src="assets/1.png"/></a><code>&#13;
</code><code>Labels:</code><code>       </code><code>kubernetes.io/bootstrapping</code><code class="o">=</code><code>rbac-defaults</code><code>&#13;
</code><code>PolicyRule:</code><code>&#13;
  </code><code>Resources</code><code>  </code><code>Non-Resource</code><code> </code><code>URLs</code><code>  </code><code>Resource</code><code> </code><code>Names</code><code>  </code><code>Verbs</code><code>&#13;
  </code><code>---------</code><code>  </code><code>-----------------</code><code>  </code><code>--------------</code><code>  </code><code>-----</code><code>&#13;
  </code><code>*.*</code><code>        </code><code class="o">[</code><code class="o">]</code><code>                 </code><code class="o">[</code><code class="o">]</code><code>              </code><code class="o">[</code><code>*</code><code class="o">]</code><code>&#13;
             </code><code class="o">[</code><code>*</code><code class="o">]</code><code>                </code><code class="o">[</code><code class="o">]</code><code>              </code><code class="o">[</code><code>*</code><code class="o">]</code><code>&#13;
</code></pre>&#13;
<dl class="calloutlist">&#13;
 <dt><a class="co" href="#comarker1" id="c01"><img alt="1" src="assets/1.png"/></a></dt>&#13;
  <dd><p>The RBAC <code>cluster-admin</code> ClusterRole: anything goes.</p></dd>&#13;
</dl>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Standard Tools and Techniques" data-type="sect2"><div class="sect2" id="idm45261343263944">&#13;
<h2>Standard Tools and Techniques</h2>&#13;
&#13;
<p>Operators aim to make the complex applications they manage first-class citizens of the Kubernetes API. We show what that means in the following chapters’ examples. At this stage, it means that a recent version of the command-line Kubernetes API tool, <code>kubectl</code>, is the only requirement for deploying and interacting with basic Operators on your cluster.<a data-primary="kubectl" data-secondary="installing or updating" data-type="indexterm" id="idm45261336228872"/></p>&#13;
&#13;
<p>Readers who need to install or update <code>kubectl</code> should consult the <a href="https://oreil.ly/ke6KM">current kubectl documentation</a>.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>Users of the Red Hat OpenShift Kubernetes distribution (described below) may optionally (and interchangeably) use the <code>oc</code> OpenShift API utility in place of <code>kubectl</code>.<a data-primary="oc API" data-type="indexterm" id="idm45261342364264"/></p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Suggested Cluster Configurations" data-type="sect2"><div class="sect2" id="idm45261342365944">&#13;
<h2>Suggested Cluster Configurations</h2>&#13;
&#13;
<p>There are many ways to run a Kubernetes cluster where you can deploy Operators. As mentioned previously, if you are already running a recent Kubernetes version, you can skip past this advice and on to <a data-type="xref" href="#running_a_simple_operator">“Running a Simple Operator”</a>. If you aren’t, we have tested the Kubernetes packagings or distributions described in this section enough to expect they will support the exercises in this book.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Minikube" data-type="sect3"><div class="sect3" id="idm45261341747208">&#13;
<h3>Minikube</h3>&#13;
&#13;
<p><a href="https://oreil.ly/dBPzK">Minikube v1.5.2</a> deploys Kubernetes v1.16.2. It runs a single-node Kubernetes cluster in a virtual machine (VM) on your local system’s hypervisor.<a data-primary="VirtualBox" data-type="indexterm" id="idm45261341745208"/><a data-primary="hypervisors, using with Minikube" data-type="indexterm" id="idm45261336237128"/> By default, Minikube expects to use VirtualBox because of its wide availability, but with a few extra steps it can also use your platform’s native hypervisor, like KVM on Linux, Hyper-V on Windows, or HyperKit and Hypervisor.framework on macOS. We avoid detailed installation instructions here, because they are better left to the <a href="https://oreil.ly/eRZpQ">Minikube documentation</a>.&#13;
We have tested the examples in this book most thoroughly with Minikube, and for reasons of convenience and cost we are recommending that you start your Operator experiments with a local environment like it, CodeReady Containers (see the next section), or with <a href="https://oreil.ly/2y6PD">Kubernetes in Docker (kind)</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Red Hat OpenShift" data-type="sect3"><div class="sect3" id="idm45261336234136">&#13;
<h3>Red Hat OpenShift</h3>&#13;
&#13;
<p>OpenShift is Red Hat’s distribution of Kubernetes.<a data-primary="Red Hat OpenShift" data-secondary="using in Operator lab" data-type="indexterm" id="idm45261336198168"/><a data-primary="OpenShift" data-see="Red Hat OpenShift" data-type="indexterm" id="idm45261336197192"/> Anything you can do on Kubernetes, you can do on OpenShift of an equivalent core version. (There are also OpenShift-specific features built atop Kubernetes, but those are beyond the scope of this book.) OpenShift version 4 provides a full-featured Kubernetes distribution that is itself designed, delivered, and managed using Operators. It’s a “self-hosted” Kubernetes, capable of performing in-place platform upgrades without incurring downtime for hosted workloads. OpenShift includes Operator Lifecycle Manager, described in <a data-type="xref" href="ch04.html#the_operator_framework">Chapter 4</a>, and a graphical interface to the Operator Catalog distribution mechanism out of the box.</p>&#13;
&#13;
<p>You can deploy a fully fledged OpenShift v4 cluster on Amazon Web Services (AWS), Microsoft Azure, or Google Cloud Platform with a free trial license by visiting Red Hat’s <a href="https://try.openshift.com"><em class="hyperlink">https://try.openshift.com</em></a>.</p>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>To run OpenShift<a data-primary="Red Hat CodeReady Containers" data-type="indexterm" id="idm45261336192024"/> on your laptop, take a look at Minikube’s equivalent, <a href="https://github.com/code-ready/crc">Red Hat CodeReady Containers</a>.</p>&#13;
</div>&#13;
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45261336157800">&#13;
<h5>OpenShift Learning Portal</h5>&#13;
<p>The OpenShift learning portal offers guided lessons, including access to a cluster with all the necessary privileges for installing, deploying, and managing Operators.<a data-primary="Red Hat OpenShift" data-secondary="learning portal" data-type="indexterm" id="idm45261336156488"/> Scenarios are available in your web browser, making it easy to keep learning beyond the examples in this book. An OpenShift cluster spins up for each session, and you’re given command-line and web GUI access to it.</p>&#13;
&#13;
<p>To check it out, visit <a href="https://learn.openshift.com"><em class="hyperlink">https://learn.openshift.com</em></a> and select the “Building Operators on OpenShift” group of topics.</p>&#13;
</div></aside>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Checking Your Cluster Version" data-type="sect2"><div class="sect2" id="idm45261336153448">&#13;
<h2>Checking Your Cluster Version</h2>&#13;
&#13;
<p>Verify that your cluster is running Kubernetes version v1.11 or later by running <code>kubectl version</code>. <a data-primary="kubectl command" data-secondary="version" data-type="indexterm" id="idm45261336151928"/>This command will return one API version string for your <code>kubectl</code> binary and a second version string for the cluster to which it is connecting:</p>&#13;
<pre class="pagebreak-before less_space" data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl version</strong>&#13;
<code>Client Version: version.Info{Major:"1", Minor:"16", GitVersion:"v1.16.2",&#13;
GitCommit:"c97fe5036ef3df2967d086711e6c0c405941e14b", GitTreeState:"clean",&#13;
BuildDate:"2019-10-15T19:18:23Z", GoVersion:"go1.12.10", Compiler:"gc",&#13;
Platform:"darwin/amd64"}&#13;
Server Version: version.Info{Major:"1", Minor:"16", GitVersion:"v1.16.2",&#13;
GitCommit:"c97fe5036ef3df2967d086711e6c0c405941e14b", GitTreeState:"clean",&#13;
BuildDate:"2019-10-15T19:09:08Z", GoVersion:"go1.12.10", Compiler:"gc",&#13;
Platform:"linux/amd64"}</code>&#13;
</pre>&#13;
&#13;
<p>In the preceding output, both client and server are running Kubernetes version 1.16.2. While <a href="https://oreil.ly/I7K1e">a <code>kubectl</code> client up to one release behind the server should work</a>, for simplicity, you should make sure your client and server minor versions match. If you have v1.11 or later, you’re ready to start experimenting with Operators.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Running a Simple Operator" data-type="sect1"><div class="sect1" id="running_a_simple_operator">&#13;
<h1>Running a Simple Operator</h1>&#13;
&#13;
<p>Once you’ve verified that you have privileged access to a Kubernetes cluster of a compatible version, you’re ready to deploy<a data-primary="Operators" data-secondary="running a simple Operator" data-type="indexterm" id="ix_Opsrun"/><a data-primary="etcd key-value store" data-secondary="running the etcd Operator" data-type="indexterm" id="ix_etcdop"/> an Operator and see what Operators can do. You’ll see the skeleton of this same procedure again later, when you deploy and test the Operator you build. The etcd Operator’s straightforward automation of recovery and upgrades shows the principles and goals of Kubernetes Operators in action.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="A Common Starting Point" data-type="sect2"><div class="sect2" id="idm45261336141560">&#13;
<h2>A Common Starting Point</h2>&#13;
&#13;
<p><a href="https://github.com/coreos/etcd">etcd</a> is a distributed key-value store with roots at <span class="keep-together">CoreOS</span>, now under the auspices of the Cloud Native Computing Foundation. It is the underlying data store at the core of Kubernetes, and a key piece of several distributed applications. etcd provides reliable storage by implementing a protocol called <a href="https://raft.github.io/">Raft</a> that guarantees consensus among a quorum of members.<a data-primary="Raft protocol (etcd)" data-type="indexterm" id="idm45261336138184"/></p>&#13;
&#13;
<p>The etcd Operator often serves as a kind of “Hello World” example of the value and mechanics of the Operator pattern, and we follow that tradition here. We return to it because the most basic use of etcd is not difficult to illustrate, but etcd cluster setup and administration require exactly the kind of application-specific know-how you can bake into an Operator.&#13;
To use etcd, you <em>put</em> keys and values in, and <em>get</em> them back out by name. Creating a reliable etcd cluster of the minimum three or more nodes requires configuration of endpoints, auth, and other concerns usually left to an etcd expert (or their collection of custom shell scripts). Keeping etcd running and upgraded over time requires continued administration. The etcd Operator knows how to do all of this.</p>&#13;
&#13;
<p>In the sections that follow, you’ll deploy the etcd Operator, then have it create an etcd cluster according to your specifications. You will have the Operator recover from <span class="keep-together">failures</span> and perform a version upgrade while the etcd API continues to service read and write requests, showing how an Operator automates the lifecycle of a piece of foundation software.</p>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>You can follow this example on a running OpenShift cluster without doing any setup at the <a href="https://oreil.ly/j-xKh">OpenShift learning portal</a>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Fetching the etcd Operator Manifests" data-type="sect2"><div class="sect2" id="idm45261336132392">&#13;
<h2>Fetching the etcd Operator Manifests</h2>&#13;
&#13;
<p>This <a data-primary="manifests" data-secondary="fetching etcd Operator manifests" data-type="indexterm" id="idm45261336131256"/>book provides an <a href="https://github.com/kubernetes-operators-book/chapters.git">accompanying Git repository</a> for each chapter’s example code. Grab the <em>chapters</em> repo and change into <a data-type="xref" href="ch03.html#operators_at_the_kubernetes_interface">Chapter 3</a>’s examples directory, as shown here:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>git</code><code> </code><code>clone</code><code> </code><code>https://github.com/kubernetes-operators-book/chapters.git</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code class="nb">cd </code><code>chapters/ch03</code></strong><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="CRs: Custom API Endpoints" data-type="sect2"><div class="sect2" id="idm45261336120824">&#13;
<h2>CRs: Custom API Endpoints</h2>&#13;
&#13;
<p>As with nearly everything in Kubernetes, a YAML manifest describes a CRD. A CR is a named endpoint in the Kubernetes API. A CRD named <code>etcdclusters.etcd.database.coreos.com</code> represents the new type of endpoint.</p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Creating a CRD" data-type="sect3"><div class="sect3" id="idm45261336118968">&#13;
<h3>Creating a CRD</h3>&#13;
&#13;
<p>A CRD defines the types and values within an instance of a CR. This example defines a new <em>kind</em> of resource, the EtcdCluster.<a data-primary="custom resource definitions (CRDs)" data-secondary="creating" data-type="indexterm" id="idm45261336116744"/></p>&#13;
&#13;
<p>Use <code>cat</code>, <code>less</code>, or your preferred pager to read the file named <em>etcd-operator-crd.yaml</em>. You’ll see something like the following, the YAML that specifies the EtcdCluster CRD:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">apiextensions.k8s.io/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">CustomResourceDefinition</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcdclusters.etcd.database.coreos.com</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">group</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd.database.coreos.com</code>&#13;
  <code class="nt">names</code><code class="p">:</code>&#13;
    <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">EtcdCluster</code>&#13;
    <code class="nt">listKind</code><code class="p">:</code> <code class="l-Scalar-Plain">EtcdClusterList</code>&#13;
    <code class="nt">plural</code><code class="p">:</code> <code class="l-Scalar-Plain">etcdclusters</code>&#13;
    <code class="nt">shortNames</code><code class="p">:</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">etcdclus</code>&#13;
    <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">etcd</code>&#13;
    <code class="nt">singular</code><code class="p">:</code> <code class="l-Scalar-Plain">etcdcluster</code>&#13;
  <code class="nt">scope</code><code class="p">:</code> <code class="l-Scalar-Plain">Namespaced</code>&#13;
  <code class="nt">versions</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">v1beta2</code>&#13;
    <code class="nt">served</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code>&#13;
    <code class="nt">storage</code><code class="p">:</code> <code class="l-Scalar-Plain">true</code></pre>&#13;
&#13;
<p>The CRD defines how the Kubernetes API should reference this new resource. The shortened nicknames that help you do a little less typing in <code>kubectl</code> are defined here, too.</p>&#13;
&#13;
<p>Create the CRD on your cluster:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>create</code><code> </code><code>-f</code><code> </code><code>etcd-operator-crd.yaml</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>A quick check shows the new CRD, <code>etcdclusters.etcd.database.coreos.com</code>:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>crd</code></strong><code>&#13;
</code><code>NAME</code><code>                                    </code><code>CREATED</code><code> </code><code>AT</code><code>&#13;
</code><code>etcdclusters.etcd.database.coreos.com</code><code>   </code><code>2019-11-15T02:50:14Z</code><code>&#13;
</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The CR’s group, version, and kind together form the fully qualified name of a Kubernetes resource type. That canonical name must be unique across a cluster. The CRD you created represents a resource in the <code>etcd.database.coreos.com</code> group, of version <code>v1beta2</code> and kind <code>EtcdCluster</code>.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Who Am I: Defining an Operator Service Account" data-type="sect2"><div class="sect2" id="idm45261335988584">&#13;
<h2>Who Am I: Defining an Operator Service Account</h2>&#13;
&#13;
<p>In <a data-type="xref" href="ch03.html#operators_at_the_kubernetes_interface">Chapter 3</a> we give an overview of Kubernetes authorization and define service accounts, roles, and other authorization concepts.<a data-primary="authorization" data-secondary="defining Operator service account" data-type="indexterm" id="idm45261335985896"/><a data-primary="service accounts" data-secondary="defining Operator service account" data-type="indexterm" id="idm45261335984984"/> For now, we just want to take a first look at basic declarations for a service account and the capabilities that account needs to run the etcd Operator.</p>&#13;
&#13;
<p>The file <em>etcd-operator-sa.yaml</em> defines<a data-primary="etcd-operator-sa.yaml file" data-type="indexterm" id="idm45261335982936"/> the service account:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator-sa</code></pre>&#13;
&#13;
<p>Create the<a data-primary="kubectl command" data-secondary="create" data-type="indexterm" id="idm45261335938440"/> service account by using <code>kubectl create</code>:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>create</code><code> </code><code>-f</code><code> </code><code>etcd-operator-sa.yaml</code></strong><code>&#13;
</code><code>serviceaccount/etcd-operator-sa</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
&#13;
<p>If you check the list of cluster service accounts, you’ll see that it appears:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get serviceaccounts</strong>&#13;
NAME               SECRETS   AGE&#13;
builder            <code>2</code>         2h&#13;
default            <code>3</code>         2h&#13;
deployer           <code>2</code>         2h&#13;
etcd-operator-sa   <strong><code>2</code></strong>         <strong>3s</strong>&#13;
[...]&#13;
</pre>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The role" data-type="sect3"><div class="sect3" id="idm45261335920392">&#13;
<h3>The role</h3>&#13;
&#13;
<p>The role governing the service account is defined in a file named <em>etcd-operator-role.yaml</em>. We’ll leave aside a detailed<a data-primary="role-based access control (RBAC)" data-secondary="defining etcd operator role" data-type="indexterm" id="idm45261335918152"/><a data-primary="etcd-operator-role.yaml file" data-type="indexterm" id="idm45261335917144"/> discussion of RBAC for later chapters and <a data-type="xref" href="app03.html#appendix_rbac">Appendix C</a>, but the key items are fairly visible in the role manifest. We give the role a name that we’ll use to reference it from other places: <code>etcd-operator-role</code>. The YAML goes on to list the kinds of resources the role may use, and what it can do with them, that is, what <code>verbs</code> it can say:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Role</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator-role</code>&#13;
<code class="nt">rules</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">etcd.database.coreos.com</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">etcdclusters</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">etcdbackups</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">etcdrestores</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="s">'*'</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="s">""</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">pods</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">services</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">endpoints</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">persistentvolumeclaims</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">events</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="s">'*'</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">apps</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">deployments</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="s">'*'</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">apiGroups</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="s">""</code>&#13;
  <code class="nt">resources</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">secrets</code>&#13;
  <code class="nt">verbs</code><code class="p">:</code>&#13;
  <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">get</code></pre>&#13;
&#13;
<p>As with the service account, <code>create</code> the role with <code>kubectl</code>:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>create</code><code> </code><code>-f</code><code> </code><code>etcd-operator-role.yaml</code></strong><code>&#13;
</code><code>role.rbac.authorization.k8s.io/etcd-operator-role</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Role binding" data-type="sect3"><div class="sect3" id="idm45261335780376">&#13;
<h3>Role binding</h3>&#13;
&#13;
<p>The last bit of RBAC configuration, RoleBinding, assigns the role to the service account for the etcd Operator. <a data-primary="role-based access control (RBAC)" data-secondary="binding etcd operator role to service account" data-type="indexterm" id="idm45261335778968"/><a data-primary="etcd-operator-rolebinding.yaml file" data-type="indexterm" id="idm45261335778104"/>It’s declared in the file <em>etcd-operator-rolebinding.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io/v1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">RoleBinding</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator-rolebinding</code>&#13;
<code class="nt">roleRef</code><code class="p">:</code>&#13;
  <code class="nt">apiGroup</code><code class="p">:</code> <code class="l-Scalar-Plain">rbac.authorization.k8s.io</code>&#13;
  <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Role</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator-role</code>&#13;
<code class="nt">subjects</code><code class="p">:</code>&#13;
<code class="p-Indicator">-</code> <code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">ServiceAccount</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator-sa</code>&#13;
  <code class="nt">namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code></pre>&#13;
&#13;
<p>Notice the last line. If you’re on a brand-new OpenShift cluster, like that provided by CodeReady Containers, by default your <code>kubectl</code> or <code>oc</code> commands will run in the namespace <code>myproject</code>.<a data-primary="namespaces" data-secondary="default, for Kubernetes clusters" data-type="indexterm" id="idm45261335743240"/> If you’re on a similarly unconfigured Kubernetes cluster, your context’s default will usually be the namespace <code>default</code>. Wherever you are, the <span class="keep-together"><code>namespace</code></span> value in this RoleBinding must match the namespace on the cluster where you are working.</p>&#13;
&#13;
<p>Create the binding now:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>create</code><code> </code><code>-f</code><code> </code><code>etcd-operator-rolebinding.yaml</code></strong><code>&#13;
</code><code>rolebinding.rbac.authorization.k8s.io/etcd-operator-rolebinding</code><code> </code><code>created</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Deploying the etcd Operator" data-type="sect2"><div class="sect2" id="idm45261335987928">&#13;
<h2>Deploying the etcd Operator</h2>&#13;
&#13;
<p>The Operator is a custom controller running in a pod, and it watches the EtcdCluster CR you defined earlier.<a data-primary="deployment" data-secondary="deploying etcd Operator" data-type="indexterm" id="idm45261335635384"/> The manifest file <em>etcd-operator-deployment.yaml</em> lays out the Operator pod’s specification, including the container image for the Operator you’re deploying. Notice that it does not define the spec for the etcd cluster. You’ll describe the desired etcd cluster to the deployed etcd Operator in a CR once the Operator is running:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">extensions/v1beta1</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Deployment</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">labels</code><code class="p">:</code>&#13;
    <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcdoperator</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">replicas</code><code class="p">:</code> <code class="l-Scalar-Plain">1</code>&#13;
  <code class="nt">selector</code><code class="p">:</code>&#13;
      <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator</code>&#13;
  <code class="nt">template</code><code class="p">:</code>&#13;
        <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator</code>&#13;
  <code class="-Error">  </code><code class="nt">spec</code><code class="p">:</code>&#13;
      <code class="nt">containers</code><code class="p">:</code>&#13;
      <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator</code>&#13;
        <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">quay.io/coreos/etcd-operator:v0.9.4</code>&#13;
        <code class="nt">command</code><code class="p">:</code>&#13;
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">etcd-operator</code>&#13;
        <code class="p-Indicator">-</code> <code class="l-Scalar-Plain">--create-crd=false</code>&#13;
        <code class="p-Indicator">[</code><code class="nv">...</code><code class="p-Indicator">]</code>&#13;
        <code class="nt">imagePullPolicy</code><code class="p">:</code> <code class="l-Scalar-Plain">IfNotPresent</code>&#13;
      <code class="nt">serviceAccountName</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd-operator-sa</code></pre>&#13;
&#13;
<p>The deployment provides labels and a name for your Operator. <a data-primary="container images, for etcd Operator deployment pods" data-type="indexterm" id="idm45261335660168"/>Some key items to note here are the container image to run in this deployment’s pods, <code>etcd-operator:v0.9.4</code>, and the service account the deployment’s resources should use to access the cluster’s Kubernetes API. The <code>etcd-operator</code> deployment uses the <code>etcd-operator-sa</code> service account created for it.</p>&#13;
&#13;
<p>As usual, you can create <a data-primary="manifests" data-secondary="creating etcd Operator from" data-type="indexterm" id="idm45261335536440"/>this resource on the cluster from the manifest:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl create -f etcd-operator-deployment.yaml</strong>&#13;
deployment.apps/etcd-operator created&#13;
$ <strong>kubectl get deployments</strong>&#13;
NAME            DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE&#13;
etcd-operator   <code>1</code>         <code>1</code>         <code>1</code>            <code>1</code>           <code>19s</code>&#13;
</pre>&#13;
&#13;
<p>The etcd Operator is itself a pod running in that deployment.<a data-primary="pods" data-secondary="etcd Operator pod" data-type="indexterm" id="idm45261335530792"/> Here you can see it starting up:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pods</strong>&#13;
NAME                             READY     STATUS              RESTARTS   AGE&#13;
etcd-operator-594fbd565f-4fm8k   0/1       ContainerCreating   <code>0</code>          4s&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Declaring an etcd Cluster" data-type="sect2"><div class="sect2" id="idm45261335527608">&#13;
<h2>Declaring an etcd Cluster</h2>&#13;
&#13;
<p>Earlier, you created a CRD defining a new kind of resource, an EtcdCluster. Now that you have an Operator watching EtcdCluster resources, you can declare an EtcdCluster with your desired state. To do so, provide the two <code>spec</code> elements the Operator recognizes: <code>size</code>, the number of etcd cluster members, and the <code>version</code> of etcd each of those members should run.<a data-primary="spec elements, for etcd cluster" data-type="indexterm" id="idm45261335524488"/></p>&#13;
&#13;
<p>You can see the <code>spec</code> stanza in the file <em>etcd-cluster-cr.yaml</em>:</p>&#13;
&#13;
<pre data-code-language="yaml" data-type="programlisting"><code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">etcd.database.coreos.com/v1beta2</code>&#13;
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">EtcdCluster</code>&#13;
<code class="nt">metadata</code><code class="p">:</code>&#13;
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">example-etcd-cluster</code>&#13;
<code class="nt">spec</code><code class="p">:</code>&#13;
  <code class="nt">size</code><code class="p">:</code> <code class="l-Scalar-Plain">3</code>&#13;
  <code class="nt">version</code><code class="p">:</code> <code class="l-Scalar-Plain">3.1.10</code></pre>&#13;
&#13;
<p>This brief manifest declares a desired state of three cluster members, each running version 3.1.10 of the etcd server. Create this etcd cluster using the familiar <code>kubectl</code> syntax:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl create -f etcd-cluster-cr.yaml</strong>&#13;
etcdcluster.etcd.database.coreos.com/example-etcd-cluster created&#13;
$ <strong>kubectl get pods -w</strong>&#13;
NAME                              READY   STATUS      RESTARTS   AGE&#13;
etcd-operator-594fbd565f-4fm8k    1/1     Running     <code>0</code>           3m&#13;
example-etcd-cluster-95gqrthjbz   1/1     Running     <code>2</code>           38s&#13;
example-etcd-cluster-m9ftnsk572   1/1     Running     <code>0</code>           34s&#13;
example-etcd-cluster-pjqhm8d4qj   1/1     Running     <code>0</code>           31s&#13;
</pre>&#13;
&#13;
<p>This example etcd cluster is a first-class citizen, an <code>EtcdCluster</code> in your cluster’s API. Since it’s an API resource, you can get the etcd cluster spec and status directly from Kubernetes. <a data-primary="kubectl command" data-secondary="describe" data-type="indexterm" id="idm45261335501416"/>Try <code>kubectl describe</code> to report on the size, etcd version, and status of your etcd cluster, as shown here:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>describe</code><code> </code><code>etcdcluster/example-etcd-cluster</code></strong><code>&#13;
</code><code>Name:</code><code>         </code><code>example-etcd-cluster</code><code>&#13;
</code><code>Namespace:</code><code>    </code><code>default</code><code>&#13;
</code><code>API</code><code> </code><code>Version:</code><code>  </code><code>etcd.database.coreos.com/v1beta2</code><code>&#13;
</code><code>Kind:</code><code>         </code><code>EtcdCluster</code><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code><code>Spec:</code><code>&#13;
  </code><code>Repository:</code><code>  </code><code>quay.io/coreos/etcd</code><code>&#13;
  </code><code>Size:</code><code>        </code><code>3</code><code>&#13;
  </code><code>Version:</code><code>     </code><code>3.1.10</code><code>&#13;
</code><code>Status:</code><code>&#13;
  </code><code>Client</code><code> </code><code>Port:</code><code>  </code><code>2379</code><code>&#13;
  </code><code>Conditions:</code><code>&#13;
    </code><code>Last</code><code> </code><code>Transition</code><code> </code><code>Time:</code><code>  </code><code>2019-11-15T02:52:04Z</code><code>&#13;
    </code><code>Reason:</code><code>                </code><code>Cluster</code><code> </code><code>available</code><code>&#13;
    </code><code>Status:</code><code>                </code><code>True</code><code>&#13;
    </code><code>Type:</code><code>                  </code><code>Available</code><code>&#13;
  </code><code>Current</code><code> </code><code>Version:</code><code>         </code><code>3.1.10</code><code>&#13;
  </code><code>Members:</code><code>&#13;
    </code><code>Ready:</code><code>&#13;
      </code><code>example-etcd-cluster-6pq7qn82g2</code><code>&#13;
      </code><code>example-etcd-cluster-dbwt7kr8lw</code><code>&#13;
      </code><code>example-etcd-cluster-t85hs2hwzb</code><code>&#13;
  </code><code>Phase:</code><code>           </code><code>Running</code><code>&#13;
  </code><code>Service</code><code> </code><code>Name:</code><code>    </code><code>example-etcd-cluster-client</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Exercising etcd" data-type="sect2"><div class="sect2" id="idm45261335244728">&#13;
<h2>Exercising etcd</h2>&#13;
&#13;
<p>You now have a running etcd cluster. The etcd Operator creates a Kubernetes <a href="https://oreil.ly/meXW_"><em>service</em></a> in the etcd cluster’s namespace.<a data-primary="services" data-secondary="creation for etcd Operator" data-type="indexterm" id="idm45261335247272"/> A service is an endpoint where clients can obtain access to a group of pods, even though the members of the group may change. A service by default has a DNS name visible in the cluster. The Operator constructs the name of the service used by clients of the etcd API by appending <code>-client</code> to the etcd cluster name defined in the CR. Here, the client service is named <code>example-etcd-cluster-client</code>, and it listens on the usual etcd client IP port, 2379. Kubectl can list the services associated with the etcd cluster:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>get</code><code> </code><code>services</code><code> </code><code>--selector</code><code> </code><code class="nv">etcd_cluster</code><code class="o">=</code><code>example-etcd-cluster</code></strong><code>&#13;
</code><code>NAME</code><code>                         </code><code>TYPE</code><code>       </code><code>CLUSTER-IP</code><code>    </code><code>...</code><code> </code><code>PORT</code><code class="o">(</code><code>S</code><code class="o">)</code><code>            </code><code>AGE</code><code>&#13;
</code><code>example-etcd-cluster</code><code>         </code><code>ClusterIP</code><code>  </code><code>None</code><code>          </code><code>...</code><code> </code><code>2379/TCP,2380/TCP</code><code>  </code><code>21h</code><code>&#13;
</code><code>example-etcd-cluster-client</code><code>  </code><code>ClusterIP</code><code>  </code><code>10.96.46.231</code><code>  </code><code>...</code><code> </code><code>2379/TCP</code><code>           </code><code>21h</code><code>&#13;
</code></pre>&#13;
<div data-type="note" epub:type="note"><h6>Note</h6>&#13;
<p>The other service created by the etcd Operator, <code>example-etcd-cluster</code>, is utilized by etcd cluster members rather than etcd API clients.</p>&#13;
</div>&#13;
&#13;
<p>You can run the etcd client on the cluster and use it to connect to the client service and interact with the etcd API. The following command lands you in the shell of an etcd container:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>run</code><code> </code><code>--rm</code><code> </code><code>-i</code><code> </code><code>--tty</code><code> </code><code>etcdctl</code><code> </code><code>--image</code><code> </code><code>quay.io/coreos/etcd</code></strong><code> </code><code class="se">\&#13;
</code><code>  </code><strong><code>--restart</code><code class="o">=</code><code>Never</code><code> </code><code>--</code><code> </code><code>/bin/sh</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>From the etcd container’s shell, create <a data-primary="etcdctl, put and get commands" data-type="indexterm" id="idm45261335320104"/>and read a key-value pair in etcd with <code>etcdctl</code>’s <code>put</code> and <code>get</code> verbs:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code class="nb">export </code><code class="nv">ETCDCTL_API</code><code class="o">=</code><code>3</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code class="nb">export </code><code class="nv">ETCDCSVC</code><code class="o">=</code><code>http://example-etcd-cluster-client:2379</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code>etcdctl</code><code> </code><code>--endpoints</code><code> </code><code class="nv">$ETCDCSVC</code><code> </code><code>put</code><code> </code><code>foo</code><code> </code><code>bar</code></strong><code>&#13;
</code><code class="nv">$ </code><strong><code>etcdctl</code><code> </code><code>--endpoints</code><code> </code><code class="nv">$ETCDCSVC</code><code> </code><code>get</code><code> </code><code>foo</code></strong><code>&#13;
</code><code>foo</code><code>&#13;
</code><code>bar</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Repeat these queries or run new <code>put</code> and <code>get</code> commands in an <code>etcdctl</code> shell after each of the changes you go on to make. You’ll see the continuing availability of the etcd API service as the etcd Operator grows the cluster, replaces members, and upgrades the version of etcd.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Scaling the etcd Cluster" data-type="sect2"><div class="sect2" id="idm45261335388472">&#13;
<h2>Scaling the etcd Cluster</h2>&#13;
&#13;
<p>You can grow the etcd cluster by <a data-primary="scaling" data-secondary="of etcd cluster" data-type="indexterm" id="idm45261335386776"/>changing the declared <code>size</code> specification. Edit <em>etcd-cluster-cr.yaml</em> and change <code>size</code> from <code>3</code> to <code>4</code> etcd members. Apply the changes to the EtcdCluster CR:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <code>kubectl apply -f etcd-cluster-cr.yaml</code>&#13;
</pre>&#13;
&#13;
<p>Checking the running pods shows the Operator adding a new etcd member to the etcd cluster:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pods</strong>&#13;
NAME                              READY   STATUS      RESTARTS   AGE&#13;
etcd-operator-594fbd565f-4fm8k    1/1     Running     <code>1</code>          16m&#13;
example-etcd-cluster-95gqrthjbz   1/1     Running     <code>2</code>          15m&#13;
example-etcd-cluster-m9ftnsk572   1/1     Running     <code>0</code>           15m&#13;
example-etcd-cluster-pjqhm8d4qj   1/1     Running     <code>0</code>           15m&#13;
example-etcd-cluster-w5l67llqq8   0/1     Init:0/1    <code>0</code>           3s&#13;
</pre>&#13;
<div data-type="tip"><h6>Tip</h6>&#13;
<p>You can also try <code>kubectl edit etcdcluster/example-etcd-cluster</code> to drop into an editor and make a live change to the cluster size.</p>&#13;
</div>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Failure and Automated Recovery" data-type="sect2"><div class="sect2" id="idm45261335392296">&#13;
<h2>Failure and Automated Recovery</h2>&#13;
&#13;
<p>You saw the etcd Operator replace a failed member back in <a data-type="xref" href="ch01.html#chapter_introduction">Chapter 1</a>. Before you<a data-primary="failure and automated recovery, for etcd cluster" data-type="indexterm" id="idm45261335370120"/> see it live, it’s worth reiterating the general steps you’d have to take to handle this manually. Unlike a stateless program, no etcd pod runs in a vacuum. Usually, a human etcd “operator” has to notice a member’s failure, execute a new copy, and provide it with configuration so it can join the etcd cluster with the remaining members. The etcd Operator understands etcd’s internal state and makes the recovery automatic.<a data-primary="recovery" data-seealso="failure and automated recovery" data-type="indexterm" id="idm45261335368872"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Recovering from a failed etcd member" data-type="sect3"><div class="sect3" id="idm45261335367832">&#13;
<h3>Recovering from a failed etcd member</h3>&#13;
&#13;
<p>Run a quick <code>kubectl get pods -l app=etc</code> to get a list of the pods in your etcd cluster. Pick one you don’t like the looks of, and tell Kubernetes to delete it:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl delete pod example-etcd-cluster-95gqrthjbz</strong>&#13;
<code>pod "example-etcd-cluster-95gqrthjbz" deleted</code>&#13;
</pre>&#13;
&#13;
<p>The Operator notices the difference between reality on the cluster and the desired state, and adds an etcd member to replace the one you deleted. You can see the new etcd cluster member in the <code>PodInitializing</code> state when retrieving the list of pods, as shown here:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pods -w</strong>&#13;
NAME                              READY   STATUS            RESTARTS   AGE&#13;
etcd-operator-594fbd565f-4fm8k    1/1     Running           <code>1</code>         18m&#13;
example-etcd-cluster-m9ftnsk572   1/1     Running           <code>0</code>         17m&#13;
example-etcd-cluster-pjqhm8d4qj   1/1     Running           <code>0</code>         17m&#13;
example-etcd-cluster-r6cb8g2qqw   0/1     PodInitializing   <code>0</code>         31s&#13;
</pre>&#13;
&#13;
<p>The <code>-w</code> switch tells <code>kubectl</code> to “watch” the list of pods and to print updates on its standard output with every change to the list. You can stop the watch and return to your shell prompt with Ctrl-C.<a data-primary="kubectl command" data-secondary="describe" data-type="indexterm" id="idm45261335357864"/></p>&#13;
&#13;
<p>You can check the <code>Events</code> to see the recovery actions logged in the <code>example-etcd-cluster</code> CR:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>describe</code><code> </code><code>etcdcluster/example-etcd-cluster</code></strong><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code><code>Events:</code><code>&#13;
  </code><code>Normal</code><code>  </code><code>Replacing</code><code> </code><code>Dead</code><code> </code><code>Member</code><code>  </code><code>4m</code><code>    </code><code>etcd-operator-589c65bd9f-hpkc6</code><code>&#13;
    </code><code>The</code><code> </code><code>dead</code><code> </code><code>member</code><code> </code><code>example-etcd-cluster-95gqrthjbz</code><code> </code><code>is</code><code> </code><code>being</code><code> </code><code>replaced</code><code>&#13;
  </code><code>Normal</code><code>  </code><code>Member</code><code> </code><code>Removed</code><code>         </code><code>4m</code><code>    </code><code>etcd-operator-589c65bd9f-hpkc6</code><code>&#13;
    </code><code>Existing</code><code> </code><code>member</code><code> </code><code>example-etcd-cluster-95gqrthjbz</code><code> </code><code>removed</code><code> </code><code>from</code><code> </code><code>the</code><code> </code><code>cluster</code><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code></pre>&#13;
&#13;
<p>Throughout the recovery process, if you fire up the etcd client pod again, you can make requests to the etcd cluster, including a check on its general health:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl run --rm -i --tty etcdctl --image quay.io/coreos/etcd \&#13;
  --restart=Never -- /bin/sh</strong>&#13;
If you don't see a command prompt, try pressing enter.&#13;
$ <strong>etcdctl --endpoints http://example-etcd-cluster-client:2379 cluster-health</strong>&#13;
member 5ee0dd47065a4f55 is healthy: got healthy result ...&#13;
member 70baca4290889c4a is healthy: got healthy result ...&#13;
member 76cd6c58798a7a4b is healthy: got healthy result ...&#13;
cluster is healthy&#13;
$ <strong>exit</strong>&#13;
pod <code>"etcdctl"</code> deleted&#13;
</pre>&#13;
&#13;
<p>The etcd Operator recovers from failures in its complex, stateful application the same way Kubernetes automates recoveries for stateless apps. That is conceptually simple but operationally powerful. Building on these concepts, Operators can perform more advanced tricks, like upgrading the software they manage. Automating upgrades can have a positive impact on security, just by making sure things stay up to date. When an Operator performs rolling upgrades of its application while maintaining service availability, it’s easier to keep software patched with the latest fixes.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Upgrading etcd Clusters" data-type="sect2"><div class="sect2" id="idm45261335106728">&#13;
<h2>Upgrading etcd Clusters</h2>&#13;
&#13;
<p>If you happen to be an etcd user already, you may have noticed we specified an older version, 3.1.10. We contrived this so we could explore the etcd Operator’s upgrade skills.<a data-primary="upgrades, for etcd clusters" data-type="indexterm" id="idm45261335104952"/></p>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Upgrading the hard way" data-type="sect3"><div class="sect3" id="idm45261335104440">&#13;
<h3>Upgrading the hard way</h3>&#13;
&#13;
<p>At this point, you have an etcd cluster running version 3.1.10. To upgrade to etcd 3.2.13, you need to perform a series of steps. Since this book is about Operators, and not etcd administration, we’ve condensed the process presented here, leaving aside networking and host-level concerns to outline the manual upgrade process. The steps to follow to upgrade manually are:</p>&#13;
<ol>&#13;
<li>&#13;
<p>Check the version and health of each etcd node.</p>&#13;
</li>&#13;
<li>&#13;
<p>Create a snapshot of the cluster state for disaster recovery.</p>&#13;
</li>&#13;
<li>&#13;
<p>Stop one etcd server. Replace the existing version with the v3.2.13 binary. Start the new version.</p>&#13;
</li>&#13;
<li>&#13;
<p>Repeat for each etcd cluster member—at least two more times in a three-member cluster.</p>&#13;
</li>&#13;
&#13;
</ol>&#13;
&#13;
<p>For the gory details, see the <a href="https://oreil.ly/II9Pn">etcd upgrade documentation</a>.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="The easy way: Let the Operator do it" data-type="sect3"><div class="sect3" id="idm45261335114232">&#13;
<h3>The easy way: Let the Operator do it</h3>&#13;
&#13;
<p>With a sense of the repetitive and error-prone process of a manual upgrade, it’s easier to see the power of encoding that etcd-specific knowledge in the etcd Operator. The Operator can manage the etcd version, and an upgrade becomes a matter of declaring a new desired version in an EtcdCluster resource.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Triggering etcd upgrades" data-type="sect3"><div class="sect3" id="idm45261335115416">&#13;
<h3>Triggering etcd upgrades</h3>&#13;
&#13;
<p>Get the version of the current etcd container image by querying some <code>etcd-cluster</code> pod, filtering the output to see just the version:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl get pod example-etcd-cluster-795649v9kq <code>\</code>&#13;
  -o yaml | grep <code>"image:"</code> | uniq</strong>&#13;
image: quay.io/coreos/etcd:v3.1.10&#13;
image: busybox:1.28.0-glibc&#13;
</pre>&#13;
&#13;
<p>Or, since you added an EtcdCluster resource to the Kubernetes API, you can instead summarize the Operator’s picture of <code>example-etcd-cluster</code> directly by using <code>kubectl describe</code> as you did earlier:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>describe</code><code> </code><code>etcdcluster/example-etcd-cluster</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>You’ll see the cluster is running etcd version 3.1.10, as specified in the file <em>etcd-cluster-cr.yaml</em> and the CR created from it.</p>&#13;
&#13;
<p>Edit <code>etcd-cluster-cr.yaml</code> and change the <code>version</code> spec from <code>3.1.10</code> to <code>3.2.13</code>. Then apply the new spec to the resource on the cluster:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>apply</code><code> </code><code>-f</code><code> </code><code>etcd-cluster-cr.yaml</code></strong><code>&#13;
</code></pre>&#13;
&#13;
<p>Use the <code>describe</code> command again and take a look at the current and target versions, as well as the member upgrade notices in the <code>Events</code> stanza:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
<code class="nv">$ </code><strong><code>kubectl</code><code> </code><code>describe</code><code> </code><code>etcdcluster/example-etcd-cluster</code></strong><code>&#13;
</code><code>Name:</code><code>         </code><code>example-etcd-cluster</code><code>&#13;
</code><code>Namespace:</code><code>    </code><code>default</code><code>&#13;
</code><code>API</code><code> </code><code>Version:</code><code>  </code><code>etcd.database.coreos.com/v1beta2</code><code>&#13;
</code><code>Kind:</code><code>         </code><code>EtcdCluster</code><code>&#13;
</code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
</code><code>Status:</code><code>&#13;
  </code><code>Conditions:</code><code>&#13;
    </code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
    </code><code>Message:</code><code>               </code><code>upgrading</code><code> </code><code>to</code><code> </code><code>3.2.13</code><code>&#13;
    </code><code>Reason:</code><code>                </code><code>Cluster</code><code> </code><code>upgrading</code><code>&#13;
    </code><code>Status:</code><code>                </code><code>True</code><code>&#13;
    </code><code>Type:</code><code>                  </code><code>Upgrading</code><code>&#13;
  </code><code>Current</code><code> </code><code>Version:</code><code>         </code><code>3.1.10</code><code>&#13;
  </code><code class="o">[</code><code>...</code><code class="o">]</code><code>&#13;
  </code><code>Size:</code><code>            </code><code>3</code><code>&#13;
  </code><code>Target</code><code> </code><code>Version:</code><code>  </code><code>3.2.13</code><code>&#13;
</code><code>Events:</code><code>&#13;
  </code><code>Type</code><code>    </code><code>Reason</code><code>           </code><code>Age</code><code>  </code><code>From</code><code>                           </code><code>...</code><code>&#13;
  </code><code>----</code><code>    </code><code>------</code><code>           </code><code>---</code><code>  </code><code>----</code><code>                           </code><code>---</code><code>&#13;
  </code><code>Normal</code><code>  </code><code>Member</code><code> </code><code>Upgraded</code><code>  </code><code>3s</code><code>   </code><code>etcd-operator-594fbd565f-4fm8k</code><code> </code><code>...</code><code>&#13;
  </code><code>Normal</code><code>  </code><code>Member</code><code> </code><code>Upgraded</code><code>  </code><code>5s</code><code>   </code><code>etcd-operator-594fbd565f-4fm8k</code><code> </code><code>...</code><code>&#13;
</code></pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Upgrade the upgrade" data-type="sect3"><div class="sect3" id="idm45261335120168">&#13;
<h3>Upgrade the upgrade</h3>&#13;
&#13;
<p>With some <code>kubectl</code> tricks, you can make the same edit directly through the Kubernetes API. This time, let’s upgrade from 3.2.13 to the latest minor version of etcd available<a data-primary="kubectl command" data-secondary="patch" data-type="indexterm" id="idm45261334842136"/> at the time of this writing, version 3.3.12:</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl patch etcdcluster example-etcd-cluster --type='json' \&#13;
  -p <code>'[{"op": "replace", "path": "/spec/version", "value":3.3.12}]'</code></strong>&#13;
</pre>&#13;
&#13;
<p>Remember you can always make this change in the etcd cluster’s CR manifest and then <code>apply</code> it with <code>kubectl</code>, as you did to trigger the first upgrade.<a data-primary="manifests" data-secondary="upgrading etcd clusters in" data-type="indexterm" id="idm45261334838232"/></p>&#13;
&#13;
<p>Consecutive <code>kubectl describe etcdcluster/example-etcd-cluster</code> commands will show the transition from the old version to a target version until that becomes the current version, at which point you’ll see <code>Current Version: 3.3.12</code>. The <code>Events</code> section records each of those upgrades:</p>&#13;
&#13;
<pre data-code-language="bash" data-type="programlisting">  Normal  Member Upgraded   1m    etcd-operator-594fbd565f-4fm8k&#13;
    Member example-etcd-cluster-pjqhm8d4qj upgraded from 3.1.10 to 3.2.23&#13;
  Normal  Member Upgraded   27s   etcd-operator-594fbd565f-4fm8k&#13;
    Member example-etcd-cluster-r6cb8g2qqw upgraded from 3.2.23 to 3.3.12</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Cleaning Up" data-type="sect2"><div class="sect2" id="idm45261334832472">&#13;
<h2>Cleaning Up</h2>&#13;
&#13;
<p>Before proceeding, it will be helpful if you remove the resources you created and manipulated to experiment with the etcd Operator. As shown in the following shell excerpt, you can remove resources with the manifests used to create them. First, ensure your current working directory is <em>ch03</em> inside the <em>chapters</em> Git repository you cloned earlier (<code>cd chapters/ch03</code>):</p>&#13;
<pre data-code-language="bash" data-type="programlisting">&#13;
$ <strong>kubectl delete -f etcd-operator-sa.yaml</strong>&#13;
$ <strong>kubectl delete -f etcd-operator-role.yaml</strong>&#13;
$ <strong>kubectl delete -f etcd-operator-rolebinding.yaml</strong>&#13;
$ <strong>kubectl delete -f etcd-operator-crd.yaml</strong>&#13;
$ <strong>kubectl delete -f etcd-operator-deployment.yaml</strong>&#13;
$ <strong>kubectl delete -f etcd-cluster-cr.yaml</strong>&#13;
<code>serviceaccount "etcd-operator-sa" deleted&#13;
role.rbac.authorization.k8s.io "etcd-operator-role" deleted&#13;
rolebinding.rbac.authorization.k8s.io "etcd-operator-rolebinding" deleted&#13;
customresourcedefinition.apiextensions.k8s.io \&#13;
  "etcdclusters.etcd.database.coreos.com" deleted&#13;
deployment.apps "etcd-operator" deleted&#13;
etcdcluster.etcd.database.coreos.com "example-etcd-cluster" deleted</code>&#13;
</pre>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
<section data-pdf-bookmark="Summary" data-type="sect1"><div class="sect1" id="idm45261336145656">&#13;
<h1>Summary</h1>&#13;
&#13;
<p>We use the etcd API here with the <code>etcdctl</code> tool for the sake of simplicity, but an<a data-primary="etcd key-value store" data-secondary="running the etcd Operator" data-startref="ix_etcdop" data-type="indexterm" id="idm45261334821976"/><a data-primary="Operators" data-secondary="running a simple Operator" data-startref="ix_Opsrun" data-type="indexterm" id="idm45261334820760"/> application uses etcd with the same API requests, storing, retrieving, and watching keys and ranges. The etcd Operator automates the etcd cluster part, making reliable key-value storage available to more applications.</p>&#13;
&#13;
<p>Operators get considerably more complex, managing a variety of concerns, as you would expect from application-specific extensions. Nevertheless, most Operators follow the basic pattern discernable in the etcd Operator: a CR specifies some desired state, such as the version of an application, and a custom controller watches the resource, maintaining the desired state on the cluster.</p>&#13;
&#13;
<p>You now have a Kubernetes cluster for working with Operators. You’ve seen how to deploy an Operator and triggered it to perform application-specific state reconciliation. Next, we’ll introduce the Kubernetes API elements on which Operators build before introducing the Operator Framework and SDK, the toolkit you’ll use to construct an Operator.</p>&#13;
</div></section>&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
</div></section></body></html>