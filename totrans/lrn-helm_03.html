<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Beyond the Basics with Helm"><div class="chapter" id="beyond_the_basics_with_helm">
<h1><span class="label">Chapter 3. </span>Beyond the Basics with Helm</h1>


<p>In the previous chapter, we looked at the most frequently used Helm commands. In this chapter we will explore other capabilities that the Helm tool provides. We will dive into commands that provide information about releases, that test installations, and that keep track of history. Finally, we will revisit installing and upgrading, this time covering advanced cases.</p>

<p>We will get started with some tools helpful for troubleshooting and debugging.</p>






<section data-type="sect1" data-pdf-bookmark="Templating and Dry Runs"><div class="sect1" id="idm46125999593688">
<h1>Templating and Dry Runs</h1>

<p>When Helm installs a release, the program steps through several phases.<a data-type="indexterm" data-primary="releases" data-secondary="chart installed into Kubernetes" data-tertiary="release installation process" id="idm46125999591960"/><a data-type="indexterm" data-primary="templates" data-secondary="chart installed into Kubernetes" data-tertiary="release installation process" id="idm46125999590552"/><a data-type="indexterm" data-primary="releases" data-secondary="templates" id="idm46125999589304"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="templates" id="idm46125999588360"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="templates" id="idm46125999587416"/> It loads the chart, parses the values passed to the program, reads the chart metadata, and so on. Near the middle of the process, Helm compiles all of the templates in the chart (all in one pass), and then renders them by passing in the values (like we saw in the previous chapter). During this middle portion, it executes all of the template directives. Once the templates are rendered into YAML, Helm verifies the structure of the YAML by parsing it into Kubernetes objects. Finally, Helm serializes those objects and sends them to the Kubernetes API server.</p>

<p>Roughly, then, the process is:</p>
<ol>
<li>
<p>Load the entire chart, including its dependencies.</p>
</li>
<li>
<p>Parse the values.</p>
</li>
<li>
<p>Execute the templates, generating YAML.</p>
</li>
<li>
<p>Parse the YAML into Kubernetes objects to verify the data.</p>
</li>
<li>
<p>Send it to Kubernetes.</p>
</li>

</ol>

<p class="pagebreak-before">For example, let’s look at one of the commands we issued in the previous chapter:</p>

<pre data-type="programlisting">$ helm install mysite bitnami/drupal --set drupalUsername=admin</pre>

<p>In the first phase, Helm will locate the chart named <code>bitnami/drupal</code> and load that chart.<a data-type="indexterm" data-primary="installation of charts" data-secondary="helm install command" data-tertiary="process of" id="idm46125999577816"/><a data-type="indexterm" data-primary="install command" data-secondary="process of" id="idm46125999576536"/> If the chart is local, it will be read off of disk. If a URL is given, it will be fetched from the remote location (possibly using a plugin to assist in fetching the chart).</p>

<p>Then it will transform <code>--set drupalUsername=admin</code> into a value that can be<a data-type="indexterm" data-primary="YAML" data-secondary="templates" data-seealso="templates" id="idm46125999574392"/><a data-type="indexterm" data-primary="values.yaml file" data-secondary="upgrading an installation" data-tertiary="templates" id="idm46125999573176"/> injected into the templates. This value will be combined with the default values in the chart’s <em>values.yaml</em> file. Helm does some basic checks against the data. If it has trouble parsing the user input, or if the default values are corrupt, it will exit with an error. Otherwise, it will build a single big values object that the template engine can use for substitutions.</p>

<p>The generated values object is created by loading all of the values of the chart file, overlaying any values loaded from files (that is, with the <code>-f</code> flag), and then overlaying any values set with the <code>--set</code> flag. In other words, <code>--set</code> values override settings from passed-in values files, which in turn override anything in the chart’s default <em>values.yaml</em> file.</p>

<p>At this point, Helm will read all of the templates in the Drupal chart, and then execute those templates, passing the merged values into the template engine. Malformed templates will cause errors. But there are a variety of other situations that may cause failure here. For example, if a required value is missing, it is at this phase that an error is returned.</p>

<p>It is important to note that, when executed, some Helm templates require information about Kubernetes.<a data-type="indexterm" data-primary="Kubernetes" data-secondary="API server" data-tertiary="templates" id="idm46125999567160"/> So during template rendering, Helm <em>may</em> contact the Kubernetes API server. This is an important topic that we will discuss in a moment.</p>

<p>The output of the preceding step is then parsed from YAML into Kubernetes objects. Helm will perform some schema-level validation at this point, making sure that the objects are well-formed. Then they will be serialized into the final YAML format for Kubernetes.</p>

<p>In the last phase, Helm sends the YAML data to the Kubernetes API server. This is the server that <code>kubectl</code> and other Kubernetes tools interact with.</p>

<p>The API server will run a series of checks on the submitted YAML. If Kubernetes accepts the YAML data, Helm will consider the deployment a success. But if Kubernetes rejects the YAML, Helm will exit with an error.</p>

<p>Later on, we’ll go into detail about what happens once the objects are sent to Kubernetes. In particular, we’ll cover how Helm associates the process described earlier with an installation and revisions. But right now, we have enough information about workflow to understand two related Helm features: the <code>--dry-run</code> flag and the <code>helm template</code> command.</p>








<section data-type="sect2" data-pdf-bookmark="The --dry-run Flag"><div class="sect2" id="idm46125999561224">
<h2>The --dry-run Flag</h2>

<p>Commands like <code>helm install</code> and <code>helm upgrade</code> provide a flag named <code>--dry-run</code>. When<a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="dry-run flag" id="idm46125999557576"/><a data-type="indexterm" data-primary="troubleshooting" data-see="debugging and troubleshooting" id="idm46125999556552"/><a data-type="indexterm" data-primary="dry-run flag" id="idm46125999555592"/><a data-type="indexterm" data-primary="releases" data-secondary="dry-run flag" id="idm46125999554920"/><a data-type="indexterm" data-primary="templates" data-secondary="debugging" data-tertiary="dry-run flag" id="idm46125999553976"/><a data-type="indexterm" data-primary="install command" data-secondary="dry-run flag" id="idm46125999552760"/><a data-type="indexterm" data-primary="upgrades" data-secondary="dry-run flag" id="idm46125999551816"/> you supply this flag, it will cause Helm to step through the first four phases (load the chart, determine the values, render the templates, format to YAML). But when the fourth phase is finished, Helm will dump a trove of information to standard output, including all of the rendered templates. Then it will exit without sending the objects to Kubernetes and without creating any release records.</p>

<p>For example, here is a version of our previous Drupal install with the <code>--dry-run</code> flag appended:<a data-type="indexterm" data-primary="Drupal charts" data-secondary="dry-run flag" id="idm46125999549576"/></p>

<pre data-type="programlisting">$ helm install mysite bitnami/drupal --values values.yaml --set \
drupalEmail=foo@example.com --dry-run</pre>

<p>At the top of the output, it will print some information about the release:</p>

<pre data-type="programlisting">NAME: mysite
LAST DEPLOYED: Tue Aug 11 11:42:05 2020
NAMESPACE: default
STATUS: pending-install
REVISION: 1
HOOKS:</pre>

<p>The preceding tells us what the name of the installation is, when it was last deployed (in this case, the current date and time), which namespace it would have been deployed into, what phase of the release it is in (<code>pending-install</code>), and the revision number. Since this is an install, the revision is <code>1</code>. On upgrade, it would be <code>2</code> or greater.</p>

<p>Finally, if this chart declared any hooks, they would be enumerated here. For more on hooks, see Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.xhtml#advanced_charts">6</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch07.xhtml#chart_repositories">7</a>.</p>

<p>At first glance, it might seem that this metadata entry has a lot of unnecessary data. After all, what good does <code>LAST DEPLOYED</code> do if we are not actually installing? In fact, this chunk of information is a standard set used throughout Helm. It is part of the <em>release record</em>: a set of information about a release. Commands like <code>helm get</code> use these same fields.</p>

<p>Next, after the informational block, all of the rendered templates are dumped to standard output:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="c1"># Source: drupal/charts/mariadb/templates/test-runner.yaml</code>
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Pod</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="s">"mysite-mariadb-test-afv3u"</code>
  <code class="nt">annotations</code><code class="p">:</code>
    <code class="s">"helm.sh/hook"</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">test-success</code>
<code class="nt">spec</code><code class="p">:</code>
  <code class="nt">initContainers</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="s">"test-framework"</code>
      <code class="nt">image</code><code class="p">:</code> <code class="l-Scalar-Plain">docker.io/dduportal/bats:0.4.0</code>
<code class="nn">...</code></pre>

<p>The rendered Drupal chart is thousands of lines, so the preceding just shows the first several lines of output.</p>

<p>Finally, at the bottom of the dry-run output, Helm prints the user-oriented release notes:</p>

<pre data-type="programlisting">NOTES:
*******************************************************************
*** PLEASE BE PATIENT: Drupal may take a few minutes to install ***
*******************************************************************

1. Get the Drupal URL:

  You should be able to access your new Drupal installation through

  http://drupal.local/
...</pre>

<p>The example is truncated for brevity.</p>

<p>This dry-run feature provides Helm users a way to debug the output of a chart before it is sent on to Kubernetes. With all of the templates rendered, you can inspect exactly what would have been submitted to your cluster. And with the release data, you can verify that the release would have been created as you expected.</p>

<p>The principal purpose of the <code>--dry-run</code> flag is to give people a chance to inspect and debug output before sending it on to Kubernetes. But soon after it was introduced, Helm maintainers noticed a trend among users. People wanted to use <code>--dry-run</code> to use Helm as a template engine, and then use other tools (like <code>kubectl</code>) to send the rendered output to Kubernetes.</p>

<p>But <code>--dry-run</code> wasn’t written with this use case in mind, and that caused a few 
<span class="keep-together">problems</span>:</p>
<ol>
<li>
<p><code>--dry-run</code> mixes non-YAML information with the rendered templates. This means the data has to be cleaned up before being sent to tools like <code>kubectl</code>.</p>
</li>
<li>
<p>A <code>--dry-run</code> on upgrade can produce different YAML output than a <code>--dry-run</code> on install, and this can be confusing.</p>
</li>
<li>
<p>It contacts the Kubernetes API server for validation, which means Helm has to have Kubernetes credentials even if it is just used to <code>--dry-run</code> a release.</p>
</li>
<li>
<p>It also inserts information into the template engine that is cluster-specific. Because of this, the output of some rendering processes may be cluster-specific.</p>
</li>

</ol>

<p>To remedy these problems, the Helm maintainers introduced a completely separate command: <code>helm template</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The helm template Command"><div class="sect2" id="idm46125999560248">
<h2>The helm template Command</h2>

<p>While <code>--dry-run</code> is designed for debugging, <code>helm template</code> is designed<a data-type="indexterm" data-primary="templates" data-secondary="helm template command" id="idm46125997781720"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="helm template command" id="idm46125997780712"/><a data-type="indexterm" data-primary="template command" id="idm46125997779704"/> to isolate the template rendering process of Helm from the installation or upgrade logic.</p>

<p>Earlier, we looked at the five phases of a Helm install or upgrade. The <code>template</code> command performs the first four phases (load the chart, determine the values, render the templates, format to YAML). But it does this with a few additional caveats:</p>

<ul>
<li>
<p>During <code>helm template</code>, Helm <em>never</em> contacts a remote Kubernetes server.<a data-type="indexterm" data-primary="template command" data-secondary="cluster not interrogated" id="idm46125997775864"/><a data-type="indexterm" data-primary="templates" data-secondary="helm template command" data-tertiary="cluster not interrogated" id="idm46125997774824"/></p>
</li>
<li>
<p>The <code>template</code> command always acts like an installation.</p>
</li>
<li>
<p>Template functions and directives that would normally require contacting a Kubernetes server will instead only return default data.</p>
</li>
<li>
<p>The chart only has access to default Kubernetes kinds.</p>
</li>
</ul>

<p>Regarding the last item, <code>helm template</code> makes a notable simplifying assumption. <a data-type="indexterm" data-primary="custom resource definitions (CRDs)" data-secondary="helm template command and" id="idm46125997769000"/><a data-type="indexterm" data-primary="CRDs" data-see="custom resource definitions" id="idm46125997767992"/><a data-type="indexterm" data-primary="resources" data-secondary="custom resource definitions" data-tertiary="helm template command and" id="idm46125997767032"/>Kubernetes servers support built-in kinds (<code>Pod</code>, <code>Service</code>, <code>ConfigMap</code>, and so on) as well as custom kinds generated by custom resource definitions (CRDs). When running an install or upgrade, Helm fetches those kinds from the Kubernetes server before processing the chart.</p>

<p>However, <code>helm template</code> does this step differently. When Helm is compiled, it is compiled against a particular version of Kubernetes. The Kubernetes libraries contain the list of built-in kinds for that release. Helm uses that built-in list instead of a list it fetches from the API server. For this reason, Helm does not have access to any CRDs during a <code>helm template</code> run, since CRDs are installed on the cluster and are not included in the Kubernetes libraries.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Running an old version of Helm against a chart that uses new kinds or versions<a data-type="indexterm" data-primary="versions of Helm" data-secondary="helm template command" id="idm46125997761464"/><a data-type="indexterm" data-primary="Helm" data-secondary="versions" data-tertiary="helm template command" id="idm46125997760488"/> can produce an error during <code>helm template</code> because Helm will not have the newest kinds or versions compiled into it.</p>
</div>

<p>As a result of these decisions, <code>helm template</code> produces consistent output run after run. <a data-type="indexterm" data-primary="CI (continuous integration) pipelines" data-secondary="helm template command" id="idm46125997757736"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="helm template command not needing" id="idm46125997756696"/><a data-type="indexterm" data-primary="YAML" data-secondary="capturing" data-tertiary="helm template command" id="idm46125997744312"/><a data-type="indexterm" data-primary="charts" data-secondary="YAML via" data-tertiary="helm template command" id="idm46125997743096"/>More importantly, it can be run in an environment that does not have access to a Kubernetes cluster, like a continuous integration (CI) pipeline.</p>

<p>The output is also different from <code>--dry-run</code>. Here’s an example command:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="l-Scalar-Plain">$ helm template mysite bitnami/drupal --values values.yaml --set \</code>
<code class="l-Scalar-Plain">drupalEmail=foo@example.com</code>
 <code class="l-Scalar-Plain">---</code>
<code class="l-Scalar-Plain"># Source</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">drupal/charts/mariadb/templates/secrets.yaml</code>
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Secret</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">mysite-mariadb</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="nt">app</code><code class="p">:</code> <code class="s">"mariadb"</code>
    <code class="nt">chart</code><code class="p">:</code> <code class="s">"mariadb-7.5.1"</code>
    <code class="nt">release</code><code class="p">:</code> <code class="s">"mysite"</code>
    <code class="nt">heritage</code><code class="p">:</code> <code class="s">"Helm"</code>
<code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Opaque</code>
<code class="c1"># ... LOTS removed from here</code>
  <code class="nt">volumes</code><code class="p">:</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">tests</code>
      <code class="nt">configMap</code><code class="p">:</code>
        <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">mysite-mariadb-tests</code>
    <code class="p-Indicator">-</code> <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">tools</code>
      <code class="nt">emptyDir</code><code class="p">:</code> <code class="p-Indicator">{}</code>
  <code class="nt">restartPolicy</code><code class="p">:</code> <code class="l-Scalar-Plain">Never</code></pre>

<p>The preceding is a greatly abridged version of the output, showing just the command and a sample of the beginning data and the end of the data. The important thing to note, though, is that <em>only</em> the YAML-formatted Kubernetes manifest is printed by default.</p>

<p>Because Helm does not contact a Kubernetes cluster during a <code>helm template</code> run, it does not do complete validation of the output. It is possible that Helm will not catch some errors in this case. You may choose to use the <code>--validate</code> flag if you want that behavior, but in this case Helm will need a valid <em>kubeconfig</em> file with credentials for a cluster.</p>

<p>The <code>helm template</code> command has a broad number of flags that mirror those in <code>helm install</code>. So in many cases, you can execute a <code>helm template</code> command just as you would a <code>helm install</code>, but then capture the YAML and use it with other tooling.</p>
<div data-type="tip"><h1>Using a Post-Render Instead of Helm Template</h1>
<p>Sometimes you want to intercept the YAML, modify it with your own tool, and then load it into Kubernetes.<a data-type="indexterm" data-primary="Kustomize tool and helm post-renderer flag" id="idm46125997673880"/><a data-type="indexterm" data-primary="YAML" data-secondary="capturing" data-tertiary="helm post-renderer flag" id="idm46125997673080"/><a data-type="indexterm" data-primary="charts" data-secondary="YAML via" data-tertiary="helm post-renderer flag" id="idm46125997671864"/> Helm provides a way to execute this external tool without having to resort to using <code>helm template</code>. The flag <code>--post-renderer</code> on the <code>install</code>, <code>upgrade</code>, <code>rollback</code>, and <code>template</code> will cause Helm to send the YAML data to the command, and then read the results back into Helm. This is a great way to work with tools like Kustomize.</p>
</div>

<p>To summarize, <code>helm template</code> is a tool for rendering Helm charts into YAML, and the <code>--dry-run</code> flag is a tool for debugging installation and upgrade commands without loading the data into Kubernetes.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Learning About a Release"><div class="sect1" id="idm46125999593192">
<h1>Learning About a Release</h1>

<p>In the previous chapter, we got a glimpse of the <code>helm get</code> command. At this point, we will take a deeper look into that command and others that provide us with information <em>about</em> Helm releases.</p>

<p>To start, let’s revisit the five phases of a Helm installation from the previous section. They were:</p>
<ol>
<li>
<p>Load the chart.</p>
</li>
<li>
<p>Parse the values.</p>
</li>
<li>
<p>Execute the templates.</p>
</li>
<li>
<p>Render the YAML.</p>
</li>
<li>
<p>Send it to Kubernetes.</p>
</li>

</ol>

<p>The first four phases are primarily concerned with a local representation of the data. That is, Helm is doing all of the processing on the same computer that the <code>helm</code> command is run on.</p>

<p>During the last phase, though, Helm sends that data to Kubernetes. And then the two communicate back and forth until the release is either accepted or rejected.</p>

<p>During that fifth phase, Helm must monitor the state of the release. Moreover, since many individuals may be working on the same copy of that particular application installation, Helm needs to monitor the state in such a way that <em>multiple users</em> can see that information.</p>

<p>Helm provides this feature with <em>release records</em>.</p>








<section data-type="sect2" data-pdf-bookmark="Release Records"><div class="sect2" id="idm46125997654408">
<h2>Release Records</h2>

<p>When we install a Helm chart (with <code>helm install</code>), the new installation is created in the namespace you specify, or the default namespace. We looked at this in the previous chapter.</p>

<p>At the end of that chapter, we also saw how <code>helm install</code> creates a special type of <a data-type="indexterm" data-primary="releases" data-secondary="information in release records" id="idm46125997650984"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="kubectl" data-tertiary="release information secrets" id="idm46125997649944"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="release information" id="idm46125997648712"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="release information" id="idm46125997647768"/><a data-type="indexterm" data-primary="information in release records" id="idm46125997646552"/>Kubernetes <code>Secret</code> that holds release information. We saw how we could inspect these <code>Secret</code>s with <code>kubectl</code>:</p>

<pre data-type="programlisting" class="pagebreak-before">$ kubectl get secret
NAME                           TYPE                                  DATA   AGE
default-token-g777k            kubernetes.io/service-account-token   3      6m
mysite-drupal                  Opaque                                1      2m20s
mysite-mariadb                 Opaque                                2      2m20s
sh.helm.release.v1.mysite.v1   helm.sh/release.v1                    1      2m20s</pre>

<p>Of particular note is that last <code>Secret</code>, <code>sh.helm.release.v1.mysite.v1</code>. Notice that it uses a special type (<code>helm.sh/release.v1</code>) to indicate that it is a Helm secret. Helm automatically generated this secret to track version 1 of our <code>mysite</code> installation (which is a Drupal site).</p>

<p>Each time we upgrade that <code>mysite</code> installation, a new <code>Secret</code> will be created to track each release. In other words, a release record tracks each <em>revision</em> of an <em>installation</em>:<a data-type="indexterm" data-primary="revisions of installations" data-secondary="release records containing" id="idm46125997638648"/></p>

<pre data-type="programlisting">$ helm upgrade mysite bitnami/drupal
# Output omitted
$ helm upgrade mysite bitnami/drupal
# Output omitted
$ kubectl get secrets
NAME                           TYPE                                  DATA   AGE
default-token-g777k            kubernetes.io/service-account-token   3      8m43s
mysite-drupal                  Opaque                                1      5m3s
mysite-mariadb                 Opaque                                2      5m3s
sh.helm.release.v1.mysite.v1   helm.sh/release.v1                    1      5m3s
sh.helm.release.v1.mysite.v2   helm.sh/release.v1                    1      20s
sh.helm.release.v1.mysite.v3   helm.sh/release.v1                    1      8s</pre>

<p>In the preceding example, we have upgraded a few times, and now we are at <code>v3</code> of <code>mysite</code>. By default, Helm tracks up to ten revisions of each installation. Once an installation exceeds ten releases, Helm deletes the oldest release records until no more than the maximum remain.</p>

<p>Each release record contains enough information to re-create the Kubernetes objects for that revision (an important thing for <code>helm rollback</code>). It also contains metadata about the release.</p>

<p>For example, if we looked at the release using <code>kubectl</code>, we would see something like this:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="nt">apiVersion</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">v1</code><code>
</code><code class="nt">data</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">release</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">SDRzSUFBQU...</code><code> </code><code class="c1"># Lots of Base64-encoded data removed</code><code>
</code><code class="nt">kind</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">Secret</code><code>
</code><code class="nt">metadata</code><code class="p">:</code><code>
</code><code>  </code><code class="nt">creationTimestamp</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">2020-08-11T18:37:26Z</code><code class="s">"</code><code>
</code><code>  </code><code class="nt">labels</code><code class="p">:</code><code> </code><a class="co" id="co_beyond_the_basics_with_helm_CO1-1" href="#callout_beyond_the_basics_with_helm_CO1-1"><img src="Images/1.png" alt="1"/></a><code>
</code><code>    </code><code class="nt">modifiedAt</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">1597171046</code><code class="s">"</code><code>
</code><code>    </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">mysite</code><code>
</code><code>    </code><code class="nt">owner</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">helm</code><code>
</code><code>    </code><code class="nt">status</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">deployed</code><code>
</code><code>    </code><code class="nt">version</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">3</code><code class="s">"</code><code>
</code><code>  </code><code class="nt">name</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">sh.helm.release.v1.mysite.v3</code><code>
</code><code>  </code><code class="nt">namespace</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">default</code><code>
</code><code>  </code><code class="nt">resourceVersion</code><code class="p">:</code><code> </code><code class="s">"</code><code class="s">1991</code><code class="s">"</code><code>
</code><code>  </code><code class="nt">selfLink</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">/api/v1/namespaces/default/secrets/sh.helm.release.v1.mysite.v3</code><code>
</code><code>  </code><code class="nt">uid</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">cbb8b457-e331-467b-aa78-1e20360b5be6</code><code>
</code><code class="nt">type</code><code class="p">:</code><code> </code><code class="l-Scalar-Plain">helm.sh/release.v1</code></pre>
<dl class="calloutlist">
<dt><a class="co" id="callout_beyond_the_basics_with_helm_CO1-1" href="#co_beyond_the_basics_with_helm_CO1-1"><img src="Images/1.png" alt="1" width="12" height="12"/></a></dt>
<dd><p>The labels contain Helm metadata</p></dd>
</dl>

<p>In this example, the giant Base64-encoded data has been removed along with a few other inessential fields. That blob contains a gzipped representation of the chart and release. But importantly, the <code>labels</code> section of the Kubernetes metadata contains information about this release.</p>

<p>We can see, for instance, that this data describes the release named <code>mysite</code>, that its current revision number is <code>3</code>, and the release is marked <code>deployed</code>. If we were to look at version <code>2</code>, we would see the release <code>status</code> is <code>superseded</code>, which means that it has been replaced by a later version.</p>

<p>In short, this secret is stored inside of Kubernetes so that different users of the same cluster have access to the same release information.</p>

<p>During the life cycle of a release, it can pass through several different statuses.<a data-type="indexterm" data-primary="releases" data-secondary="life cycle statuses" id="idm46125997630712"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="release life cycle statuses" id="idm46125997629736"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="release life cycle statuses" id="idm46125997628776"/> Here they are, approximately in the order you would likely see them:</p>
<dl>
<dt><code>pending-install</code></dt>
<dd>
<p>Before sending the manifests to Kubernetes, Helm claims the installation by creating a release (marked version 1) whose status is set to <code>pending-install</code>.</p>
</dd>
<dt><code>deployed</code></dt>
<dd>
<p>As soon as Kubernetes accepts the manifest from Helm, Helm updates the release record, marking it as deployed.</p>
</dd>
<dt><code>pending-upgrade</code></dt>
<dd>
<p>When a Helm upgrade is begun, a new release is created for an installation (e.g., <code>v2</code>), and its status is set to <code>pending-upgrade</code>.</p>
</dd>
<dt><code>superseded</code></dt>
<dd>
<p>When an upgrade is run, the last deployed release is updated, marked as <code>superseded</code>, and the newly upgraded release is changed from <code>pending-upgrade</code> to <code>deployed</code>.</p>
</dd>
<dt><code>pending-rollback</code></dt>
<dd>
<p>If a rollback is created, a new release (e.g., <code>v3</code>) is created, and its status is set to <code>pending-rollback</code> until Kubernetes accepts the release manifest. Then it is marked <code>deployed</code> and the last release is marked <code>superseded</code>.</p>
</dd>
<dt><code>uninstalling</code></dt>
<dd>
<p>When a <code>helm uninstall</code> is executed, the most recent release is read and then its status is changed to <code>uninstalling</code>.</p>
</dd>
<dt><code>uninstalled</code></dt>
<dd>
<p>If history is preserved during deletion, then when the 
<span class="keep-together"><code>helm uninstall</code></span> is complete, the last release’s status is changed to <code>uninstalled</code>.</p>
</dd>
<dt><code>failed</code></dt>
<dd>
<p>Finally, if during <em>any</em> operation, Kubernetes rejects a manifest submitted by Helm, Helm will mark that release <code>failed</code>.</p>
</dd>
</dl>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Listing Releases"><div class="sect2" id="idm46125997653880">
<h2>Listing Releases</h2>

<p>Status messages show up in a number of Helm commands. We already<a data-type="indexterm" data-primary="releases" data-secondary="listing releases" id="idm46125997511736"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="releases listed" id="idm46125997510760"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="releases listed" id="idm46125997509544"/> saw how <code>pending-install</code> appears in a <code>--dry-run</code>. In this section and the next, we’ll see a few more places where this appears.</p>

<p>In the previous chapter, we used <code>helm list</code> to see the charts we had installed.<a data-type="indexterm" data-primary="listing installations" data-secondary="release status check" id="idm46125997506680"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="listing installations" data-tertiary="release status check" id="idm46125997505704"/> Given our coverage of status, it is worth revisiting <code>helm list</code>. The <code>list</code> command is the best tool for quickly checking on the statuses of your releases.</p>

<p>For example, say we have a cluster with both the <code>drupal</code> and <code>wordpress</code> charts installed. Here is the output of <code>helm list</code>:</p>

<pre data-type="programlisting">NAME     	NAMESPACE REVISION  UPDATED       STATUS  	CHART           	APP V...
mysite   	default  	3         2020-08-11... deployed  drupal-7.0.0      9.0.0
wordpress default  	2         2020-08-12... deployed  wordpress-9.3.11  5.4.2</pre>

<p>To show the result of a failure, though, we can run an upgrade command that we know will break:</p>

<pre data-type="programlisting">$ helm upgrade wordpress bitnami/wordpress --set image.pullPolicy=NoSuchPolicy
Error: UPGRADE FAILED: cannot patch "wordpress" with kind Deployment:
Deployment.apps "wordpress" is invalid:
spec.template.spec.containers[0].imagePullPolicy: Unsupported value:
"NoSuchPolicy": supported values: "Always", "IfNotPresent", "Never"</pre>

<p>As the error message indicates, a pull policy cannot be set to <code>NoSuchPolicy</code>. This error came from the Kubernetes API server, which means Helm submitted the manifest, and Kubernetes rejected it. So our release should be in a failed state.</p>

<p>We can verify this by running <code>helm ls</code> again:</p>

<pre data-type="programlisting">$ helm ls
NAME      NAMESPACE REVISION  UPDATED     STATUS    CHART             APP VER...
mysite   	default  	3         2020-08-11  deployed  drupal-7.0.0      9.0.0
wordpress default  	3         2020-08-12  failed    wordpress-9.3.11  5.4.2</pre>

<p>It is worth noting again that the <code>REVISION</code> field for our newly failed <code>wordpress</code> installation has been incremented from <code>2</code> to <code>3</code>. <a data-type="indexterm" data-primary="revisions of installations" data-secondary="failed releases have revisions" id="idm46125997406056"/>Even failed releases have revisions attached to them. We’ll see why this is important in <a data-type="xref" href="#history_and_rollbacks">“History and Rollbacks”</a>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Find Details of a Release with helm get"><div class="sect2" id="idm46125997512792">
<h2>Find Details of a Release with helm get</h2>

<p>While <code>helm list</code> provides a summary view of installations, the <code>helm get</code> set of commands<a data-type="indexterm" data-primary="releases" data-secondary="information in release records" data-tertiary="helm get for details" id="ch03-get5"/><a data-type="indexterm" data-primary="get command" data-secondary="release details" id="ch03-get"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="helm get command" id="ch03-get3"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="helm get command for details" id="ch03-get2"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="helm get command for details" id="ch03-get4"/><a data-type="indexterm" data-primary="information in release records" data-secondary="helm get for details" id="ch03-get6"/> provide deeper information about a particular release.</p>

<p>There are five <code>helm get</code> subcommands (<code>hooks</code>, <code>manifests</code>, <code>notes</code>, <code>values</code>, and <code>all</code>). Each subcommand retrieves some portion of the information Helm tracks for a release.</p>










<section data-type="sect3" data-pdf-bookmark="Using helm get notes"><div class="sect3" id="idm46125997390392">
<h3>Using helm get notes</h3>

<p>The <code>helm get notes</code> subcommand prints the release notes:<a data-type="indexterm" data-primary="releases" data-secondary="release notes via helm get notes" id="idm46125997388616"/><a data-type="indexterm" data-primary="get command" data-secondary="release details" data-tertiary="release notes via get notes" id="idm46125997387624"/></p>

<pre data-type="programlisting">$ helm get notes mysite
NOTES:

*******************************************************************
*** PLEASE BE PATIENT: Drupal may take a few minutes to install ***
*******************************************************************

1. Get the Drupal URL:

  You should be able to access your new Drupal installation through

  http://drupal.local/
...</pre>

<p>This output should look familiar, as <code>helm install</code> and <code>helm upgrade</code> both print the release notes at the end of a successful operation. But <code>helm get notes</code> provides a convenient way to grab these notes on demand. That is useful in cases where you’ve forgotten what the URL is to your Drupal site.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Using helm get values"><div class="sect3" id="idm46125997383256">
<h3>Using helm get values</h3>

<p>One useful subcommand is <code>values</code>. You can use this to see which values were supplied during the last release. In the previous section, we upgraded a WordPress installation and caused it to fail. We can see what values caused it to fail using <code>helm get values</code>:</p>

<pre data-type="programlisting">$ helm get values wordpress
USER-SUPPLIED VALUES:
image:
  pullPolicy: NoSuchPolicy</pre>

<p>We know that revision 2 was successful, but revision 3 failed. So we can take a look at the earlier values to see what changed:</p>

<pre data-type="programlisting">$ helm get values wordpress --revision 2
USER-SUPPLIED VALUES:
image:
  tag: latest</pre>

<p>With this, we can see that one value was removed and one value was added. Features like this are designed to make it easier for Helm users to identify the source of errors.</p>

<p>This command is also useful for learning about the total state of a release’s configuration.<a data-type="indexterm" data-primary="configuration" data-secondary="values via helm get command" id="idm46125997377320"/><a data-type="indexterm" data-primary="get command" data-secondary="configuration values" id="idm46125997376280"/> We can use <code>helm get values</code> to see <em>all</em> of the values currently set for that release. To do this, we use the <code>--all</code> flag:</p>

<pre data-type="programlisting">$ helm get values wordpress --all
COMPUTED VALUES:
affinity: {}
allowEmptyPassword: true
allowOverrideNone: false
customHTAccessCM: null
customLivenessProbe: {}
customReadinessProbe: {}
externalDatabase:
  database: bitnami_wordpress
  host: localhost
  password: ""
  port: 3306
...</pre>

<p>When the <code>--all</code> flag is specified, Helm will get the complete computed set of values, sorted alphabetically. This is a great tool for seeing the exact state of configuration for the release.</p>
<div data-type="tip"><h1>Seeing Default Values</h1>
<p>Although <code>helm get values</code> does not have a way of showing you the default values,<a data-type="indexterm" data-primary="configuration" data-secondary="default values via helm inspect command" id="idm46125997369880"/><a data-type="indexterm" data-primary="inspect values command for default configuration" id="idm46125997368936"/> you can see those with <code>helm inspect values CHARTNAME</code>. This inspects the chart itself (not the release) and prints out the documented default <em>values.yaml</em> file. Thus, we could use <code>helm inspect values bitnami/wordpress</code> to see the default configuration for the WordPress chart.</p>
</div>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Using helm get manifest"><div class="sect3" id="idm46125997382632">
<h3>Using helm get manifest</h3>

<p>The last <code>helm get</code> subcommand that we will cover is <code>helm get manifest</code>. This <a data-type="indexterm" data-primary="get command" data-secondary="manifest retrieval" id="idm46125997363976"/><a data-type="indexterm" data-primary="manifests" data-secondary="helm get command to retrieve" id="idm46125997362968"/><a data-type="indexterm" data-primary="YAML" data-secondary="manifests for resources" data-tertiary="helm get command to retrieve" id="idm46125997362008"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="helm get command" data-tertiary="manifests" id="idm46125997360776"/><a data-type="indexterm" data-primary="resources" data-secondary="manifests" data-tertiary="helm get command to retrieve" id="idm46125997359544"/><a data-type="indexterm" data-primary="templates" data-secondary="debugging" data-tertiary="manifests" id="idm46125997358312"/>sub-command retrieves the exact YAML manifest that Helm produced using the Chart templates:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="l-Scalar-Plain">$ helm get manifest wordpress</code>
<code class="l-Scalar-Plain"># Source</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">wordpress/charts/mariadb/templates/secrets.yaml</code>
<code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Secret</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">name</code><code class="p">:</code> <code class="l-Scalar-Plain">wordpress-mariadb</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="nt">app</code><code class="p">:</code> <code class="s">"mariadb"</code>
    <code class="nt">chart</code><code class="p">:</code> <code class="s">"mariadb-7.5.1"</code>
    <code class="nt">release</code><code class="p">:</code> <code class="s">"wordpress"</code>
    <code class="nt">heritage</code><code class="p">:</code> <code class="s">"Helm"</code>
<code class="nt">type</code><code class="p">:</code> <code class="l-Scalar-Plain">Opaque</code>
<code class="nn">...</code></pre>

<p>One important detail about this command is that it does not return the <em>current state</em> of all of your resources. It returns <em>the manifest generated from the template</em>. <a data-type="indexterm" data-primary="Kubernetes" data-secondary="kubectl" data-tertiary="manifest secret metadata" id="idm46125997317816"/>In the preceding example, we see a <code>Secret</code> named <code>wordpress-mariadb</code>. If we query that <code>Secret</code> using <code>kubectl</code>, the <code>metadata</code> section looks like this:</p>

<pre data-type="programlisting" data-code-language="yaml"><code class="l-Scalar-Plain">$ kubectl get secret wordpress-mariadb -o yaml</code>
<code class="l-Scalar-Plain">apiVersion</code><code class="p-Indicator">:</code> <code class="l-Scalar-Plain">v1</code>
<code class="nt">kind</code><code class="p">:</code> <code class="l-Scalar-Plain">Secret</code>
<code class="nt">metadata</code><code class="p">:</code>
  <code class="nt">annotations</code><code class="p">:</code>
    <code class="nt">meta.helm.sh/release-name</code><code class="p">:</code> <code class="l-Scalar-Plain">wordpress</code>
    <code class="nt">meta.helm.sh/release-namespace</code><code class="p">:</code> <code class="l-Scalar-Plain">default</code>
  <code class="nt">creationTimestamp</code><code class="p">:</code> <code class="s">"2020-08-12T16:45:00Z"</code>
  <code class="nt">labels</code><code class="p">:</code>
    <code class="nt">app</code><code class="p">:</code> <code class="l-Scalar-Plain">mariadb</code>
    <code class="nt">app.kubernetes.io/managed-by</code><code class="p">:</code> <code class="l-Scalar-Plain">Helm</code>
    <code class="nt">chart</code><code class="p">:</code> <code class="l-Scalar-Plain">mariadb-7.5.1</code>
    <code class="nt">heritage</code><code class="p">:</code> <code class="l-Scalar-Plain">Helm</code>
    <code class="nt">release</code><code class="p">:</code> <code class="l-Scalar-Plain">wordpress</code>
  <code class="nt">managedFields</code><code class="p">:</code>
  <code class="p-Indicator">-</code> <code class="nt">apiVersion</code><code class="p">:</code> <code class="l-Scalar-Plain">v1</code>
    <code class="nt">fieldsType</code><code class="p">:</code> <code class="l-Scalar-Plain">FieldsV1</code>
<code class="nn">...</code></pre>

<p>The output of <code>kubectl</code> contains the record as it currently exists in Kubernetes. There are several fields that have been added since the template output. Some (like the annotations) are managed by Helm itself, and others (like <code>managedFields</code> and 
<span class="keep-together"><code>creationTimestamp</code></span>) are managed by Kubernetes.</p>

<p>Once again, Helm provides tools designed to ease debugging. Between <code>helm get manifest</code> and <code>kubectl get</code>, you have tools for comparing what Kubernetes thinks is the current object with what the chart produced. This is particularly helpful when a resource that should be managed by Helm was manually edited outside of Helm (e.g., using <code>kubectl edit</code>).</p>

<p>With <code>helm get</code>, we can closely inspect an individual release. But the next tool we will cover provides us a view of the progression of releases. In the next section, we will look at <code>helm history</code> and <code>helm rollback</code>.<a data-type="indexterm" data-startref="ch03-get" id="idm46125997239656"/><a data-type="indexterm" data-startref="ch03-get2" id="idm46125997238920"/><a data-type="indexterm" data-startref="ch03-get3" id="idm46125997238248"/><a data-type="indexterm" data-startref="ch03-get4" id="idm46125997237576"/><a data-type="indexterm" data-startref="ch03-get5" id="idm46125997236904"/><a data-type="indexterm" data-startref="ch03-get6" id="idm46125997236232"/></p>
</div></section>



</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="History and Rollbacks"><div class="sect1" id="history_and_rollbacks">
<h1>History and Rollbacks</h1>

<p>Throughout this book, we have distinguished between installations and revisions. <a data-type="indexterm" data-primary="history command" id="idm46125997233496"/><a data-type="indexterm" data-primary="releases" data-secondary="helm history command" id="idm46125997232792"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="helm history command" id="idm46125997231848"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="helm history command" id="idm46125997230632"/><a data-type="indexterm" data-primary="revisions of installations" data-secondary="helm history command" id="idm46125997229688"/>In this chapter, we have been working with an installation named <code>mysite</code> and another installation named <code>wordpress</code>. And when we ran <code>helm list</code> earlier, we saw that each installation had three releases. Moreover, we saw that <code>wordpress</code> was in a failed state:</p>

<pre data-type="programlisting">$ helm list
NAME     	NAMESPACE REVISION  UPDATED     STATUS    CHART             APP VER...
mysite    default  	3         2020-08-11  deployed  drupal-7.0.0      9.0.0
wordpress default  	3         2020-08-12  failed    wordpress-9.3.11  5.4.2</pre>

<p>We can investigate the release history of WordPress to see what happened. To do this, we will use <code>helm history</code>:</p>

<pre data-type="programlisting">$ helm history wordpress
REVISION UPDATED       STATUS     CHART             APP VER  DESCRIPTION
1        Wed Aug 12... superseded wordpress-9.3.11  5.4.2    Install complete
2        Wed Aug 12... deployed  	wordpress-9.3.11  5.4.2    Upgrade complete
3        Wed Aug 12... failed    	wordpress-9.3.11  5.4.2    Upgrade \
  "wordpress" failed: cannot patch "wordpress" with kind Deployment: \
  Deployment.apps "wordpress" is invalid: \
  spec.template.spec.containers[0].imagePullPolicy: Unsupported value: \
  "NoSuchPolicy": supported values: "Always", "IfNotPresent", "Never"</pre>

<p>The output of this command gives us a nice history of the <code>wordpress</code> release. First it was installed, and then it was upgraded and marked deployed (which means that it was a successful upgrade). But when it was upgraded again, that upgrade <code>failed</code>. The <code>helm history</code> command even gives us the error message that Kubernetes returned when marking the release <code>failed</code>.</p>

<p>From the error, we know that the release failed because we supplied an invalid image pull policy. So of course we could correct this by simply running another <code>helm upgrade</code>. But imagine a case where the cause of error was not readily available. Rather than leave the application in a failed state while diagnosing the problem, it would be nice to simply revert back to the release that worked before.</p>

<p>This is what <code>helm rollback</code> is for:<a data-type="indexterm" data-primary="rollback command" id="idm46125997219352"/><a data-type="indexterm" data-primary="revisions of installations" data-secondary="helm rollback command" id="idm46125997218616"/><a data-type="indexterm" data-primary="releases" data-secondary="helm rollback command" id="idm46125997217608"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="helm rollback command" id="idm46125997216664"/></p>

<pre data-type="programlisting">$ helm rollback wordpress 2
Rollback was a success! Happy Helming!</pre>

<p>This command tells Helm to fetch the <code>wordpress</code> version <code>2</code> release, and resubmit that manifest to Kubernetes. <a data-type="indexterm" data-primary="configuration" data-secondary="helm rollback command" id="idm46125997213768"/>A rollback does <em>not</em> restore to a previous snapshot of the cluster. Helm does not track enough information to do that. What it does is resubmit the previous configuration, and Kubernetes attempts to reset the resources to match.</p>

<p>Now we can once again use <code>helm history</code> to see what has happened:</p>

<pre data-type="programlisting">REVISION  UPDATED       STATUS      CHART             APP VER  DESCRIPTION
1         Wed Aug 12... superseded  wordpress-9.3.11  5.4.2    Install complete
2         Wed Aug 12... superseded  wordpress-9.3.11  5.4.2    Upgrade complete
3         Wed Aug 12... failed      wordpress-9.3.11  5.4.2    Upgrade \
  "wordpress" failed: cannot patch "wordpress" with kind Deployment: \
  Deployment.apps "wordpress" is invalid: \
  spec.template.spec.containers[0].imagePullPolicy: Unsupported value: \
  "NoSuchPolicy": supported values: "Always", "IfNotPresent", "Never"
4         Wed Aug 12... deployed    wordpress-9.3.11  5.4.2    Rollback to 2</pre>

<p>The rollback operation created a new revision (<code>4</code>). Since the rollback was successful (and Kubernetes accepted the alterations), the release is marked <code>deployed</code>. Note that revision <code>2</code> is now marked <code>superseded</code>, while the failed release <code>3</code> is still marked <code>failed</code>.</p>

<p>Because Helm has preserved the history, you can still examine the failed release after rolling back to a known-good configuration.</p>

<p>In most cases, <code>helm rollback</code> is a great way to recover from a catastrophe. <a data-type="indexterm" data-primary="resources" data-secondary="hand-editing and rollbacks" id="idm46125997205080"/>But if you hand-edit resources that are managed by Helm, an interesting problem may arise. Rollbacks can on occasion cause some unexpected behavior, especially if the Kubernetes resources have been hand-edited by users. Helm and Kubernetes will attempt to preserve those hand-edits if they do not conflict with the rollback.  Essentially, a rollback will generate a 3-way diff between the current state of the resources, the failed Helm release, and the Helm release that you roll back to. In some cases, the generated diff may result in rolling back handmade edits, while in other cases those discrepancies will be merged. In the worst case, some handmade edits may be overwritten while other related edits are merged, leading to an inconsistency in configuration. This is one of the many reasons Helm core maintainers recommend against hand-editing resources. If all edits are made through Helm, then you can use Helm tools effectively and with no guesswork.</p>








<section data-type="sect2" data-pdf-bookmark="Keeping History and Rolling Back"><div class="sect2" id="idm46125997202856">
<h2>Keeping History and Rolling Back</h2>

<p>In the previous chapter, we saw that the <code>helm uninstall</code> command has a flag called 
<span class="keep-together"><code>--keep-history</code></span>. <a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="uninstalling and keeping history" id="idm46125997199704"/><a data-type="indexterm" data-primary="charts" data-secondary="uninstalling" data-tertiary="keeping history" id="idm46125997198392"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="listing installations" data-tertiary="uninstalling and keeping history" id="idm46125997197176"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="uninstalling" data-tertiary="keeping history" id="idm46125997195928"/><a data-type="indexterm" data-primary="uninstalling charts" data-secondary="keeping history" id="idm46125997194712"/><a data-type="indexterm" data-primary="history command" data-secondary="uninstalling and keeping history" id="idm46125997155368"/><a data-type="indexterm" data-primary="rollback command" data-secondary="keeping history" id="idm46125997154408"/>Normally, a deletion event will destroy all release records associated with that installation. But when <code>--keep-history</code> is specified, you can see the history of an installation even after it has been deleted:</p>

<pre data-type="programlisting">$ helm uninstall wordpress --keep-history
release "wordpress" uninstalled</pre>

<pre data-type="programlisting">$ helm history wordpress
REVISION UPDATED       STATUS     	CHART             APP V  DESCRIPTION
1        Wed Aug 12... superseded 	wordpress-9.3.11  5.4.2  Install complete
2        Wed Aug 12... superseded 	wordpress-9.3.11  5.4.2  Upgrade complete
3        Wed Aug 12... failed     	wordpress-9.3.11  5.4.2  Upgrade \
  "wordpress" failed: cannot patch "wordpress" with kind Deployment: \
  Deployment.apps "wordpress" is invalid: \
  spec.template.spec.containers[0].imagePullPolicy: Unsupported value: \
  "NoSuchPolicy": supported values: "Always", "IfNotPresent", "Never"
4        Wed Aug 12... uninstalled  wordpress-9.3.11  5.4.2  Uninstall complete</pre>

<p>Note that the last release is now marked as <code>uninstalled</code>. When history is preserved, you can roll back a deleted installation:</p>

<pre data-type="programlisting">$ helm rollback wordpress 4
Rollback was a success! Happy Helming!</pre>

<p>And now we can see a newly deployed release <code>5</code>:</p>

<pre data-type="programlisting">$ helm history wordpress
REVISION UPDATED    STATUS      CHART             APP VER  DESCRIPTION
1        Wed Aug... superseded 	wordpress-9.3.11	5.4.2    Install complete
2        Wed Aug... superseded 	wordpress-9.3.11	5.4.2    Upgrade complete
3        Wed Aug... failed     	wordpress-9.3.11	5.4.2    Upgrade \
  "wordpress" failed: cannot patch "wordpress" with kind Deployment: \
  Deployment.apps "wordpress" is invalid: \
  spec.template.spec.containers[0].imagePullPolicy: Unsupported value: \
  "NoSuchPolicy": supported values: "Always", "IfNotPresent", "Never"
4        Wed Aug... uninstalled wordpress-9.3.11  5.4.2    Uninstall complete
5        Wed Aug... deployed   	wordpress-9.3.11  5.4.2    Rollback to 4</pre>

<p>But without the <code>--keep-history</code> flag, this will not work:</p>

<pre data-type="programlisting">$ helm uninstall wordpress
release "wordpress" uninstalled
$ helm history wordpress
Error: release: not found
$ helm rollback wordpress 4
Error: release: not found</pre>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="A Deep Dive into Installs and Upgrades"><div class="sect1" id="idm46125997235224">
<h1>A Deep Dive into Installs and Upgrades</h1>

<p>In <a data-type="xref" href="ch02.xhtml#Using_Helm">Chapter 2</a> we took a first look at installing and upgrading Helm packages, and throughout this chapter we have looked at tools that help us work with Helm installations. To close out this chapter, we will circle back to installation and upgrading and look at a few advanced features.</p>








<section data-type="sect2" data-pdf-bookmark="The --generate-name and --name-template Flags"><div class="sect2" id="idm46125997142520">
<h2>The --generate-name and --name-template Flags</h2>

<p>One of the subtle dangers of the way Kubernetes works has to do with naming. <a data-type="indexterm" data-primary="Kubernetes" data-secondary="namespace" data-tertiary="names unique within" id="idm46125997140632"/><a data-type="indexterm" data-primary="namespace (Kubernetes)" data-secondary="names unique within" id="idm46125997139384"/>Kubernetes assumes that names will have certain uniqueness properties. For example, a <code>Deployment</code> object must have a name unique within its namespace. That is, in the namespace <code>mynamespace</code> I cannot have two <code>Deployment</code>s named <code>myapp</code>. But I can have a <code>Deployment</code> and a <code>Pod</code> each named <code>myapp</code>.</p>

<p>This has made certain tasks a little more complicated. For example, a <a data-type="indexterm" data-primary="CI (continuous integration) pipelines" data-secondary="names unique within namespace" id="idm46125997134952"/>CI system that automatically deploys things must be able to ensure that the name it gives these things is unique within the namespace. One approach to dealing with this issue is for Helm to provide a tool for generating a unique name. (Another approach is to always overwrite a name if it already exits. See the next section for that approach.)</p>

<p>Helm provides the <code>--generate-name</code> flag for <code>helm install</code>:<a data-type="indexterm" data-primary="installation of charts" data-secondary="generate-name flag" id="idm46125997132120"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="generate-name flag" id="idm46125997131112"/><a data-type="indexterm" data-primary="generate-name flag" id="idm46125997129896"/><a data-type="indexterm" data-primary="install command" data-secondary="generate-name flag" id="idm46125997129224"/><a data-type="indexterm" data-primary="names" data-secondary="helm install command generate-name flag" id="idm46125997128280"/></p>

<pre data-type="programlisting">$ helm install bitnami/wordpress --generate-name
NAME: wordpress-1597689085
LAST DEPLOYED: Mon Aug 17 11:31:27 2020
NAMESPACE: default
STATUS: deployed
REVISION: 1</pre>

<p>With the <code>--generate-name</code> flag, we no longer need to provide a name as the first argument to <code>helm install</code>. Helm generates a name based on a combination of the chart name and a timestamp. In the preceding output, we can see the name that was generated for us: <code>wordpress-1597689085</code>.</p>

<p>In Helm 2, “friendly names” were generated using adjectives and animal names.<a data-type="indexterm" data-primary="versions of Helm" data-secondary="names generated" id="idm46125997124168"/><a data-type="indexterm" data-primary="Helm" data-secondary="versions" data-tertiary="names generated" id="idm46125997123192"/> That was removed in Helm 3 due to complaints that release names were unprofessional. There is currently no way to re-enable this feature.</p>

<p>However, there is an additional flag that allows you to specify a naming template.<a data-type="indexterm" data-primary="templates" data-secondary="name-template flag" id="idm46125997121304"/><a data-type="indexterm" data-primary="name-template flag" id="idm46125997120328"/> The <code>--name-template</code> flag allows you do to something like this:</p>

<pre data-type="programlisting">$ helm install bitnami/wordpress --generate-name \
  --name-template "foo-{{ randAlpha 9 | lower }}"
NAME: foo-yejpiyjmp
LAST DEPLOYED: Mon Aug 17 11:46:04 2020
NAMESPACE: default</pre>

<p>In this example, we used the name template <code>foo-{{ randAlpha 9 | lower }}</code>. This uses the Helm template engine to generate a name for you. We’ll cover the Helm template engine in the next few chapters. But here’s what the name template does: The <code>{{</code> and <code>}}</code> demarcate the beginning and end of a template. Inside of that template, we are calling the <code>randAlpha</code> function, asking for a <code>9</code>-character random string from the <code>a-z, A-Z</code> range of characters. Then we are “piping” the results through a second function (<code>lower</code>) that lowercases everything.</p>

<p>Looking at the output of the earlier example, the result of <code>{{ randAlpha 9 | lower }}</code> was <code>yejpiyjmp</code>. So the result of the entire name template was <code>foo-yejpiyjmp</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The --create-namespace Flag"><div class="sect2" id="idm46125997141928">
<h2>The --create-namespace Flag</h2>

<p>Another consideration with naming in Kubernetes has to do with namespaces. <a data-type="indexterm" data-primary="Kubernetes" data-secondary="namespace" data-tertiary="create-namespace flag" id="idm46125997110968"/><a data-type="indexterm" data-primary="namespace (Kubernetes)" data-secondary="create-namespace flag" id="idm46125997109720"/><a data-type="indexterm" data-primary="namespace (Kubernetes)" data-secondary="names unique within" data-tertiary="global names" id="idm46125997108776"/><a data-type="indexterm" data-primary="global names" id="idm46125997107560"/><a data-type="indexterm" data-primary="install command" data-secondary="create-namespace flag" id="idm46125997106888"/>Earlier, we saw that no two objects of the same kind <em>within the same namespace</em> can have the same name. But Kubernetes also has a concept of global names. CRDs and namespaces each have global names.</p>

<p>A namespace, therefore, must be unique cluster-wide.</p>

<p>Whenever Helm encounters globally unique names, it adopts a defensive posture. In later chapters, we’ll see how charts handle globally unique names. But here, it is worth pointing out that Helm 3 assumes by default that if you attempt to deploy a chart into a namespace, that namespace was already created.</p>

<p>For example, on a fresh cluster this will fail:</p>

<pre data-type="programlisting">$ helm install drupal bitnami/drupal --namespace mynamespace
Error: create: failed to create: namespaces "mynamespace" not found</pre>

<p>It fails because <code>mynamespace</code> has not already been created and <em>Helm won’t automatically create a namespace</em>. It won’t create one because namespaces are global, and the safe assumption is that when a namespace is created, it probably needs access controls (like RBACs) and other things assigned to it before it can be safely used in production. In short, it views silently creating a namespace as an opportunity for unintentionally creating a security hole.</p>

<p>However, Helm does let you override this consideration by explicitly stating that you want to create a namespace:</p>

<pre data-type="programlisting">$ helm install drupal bitnami/drupal --namespace mynamespace --create-namespace
NAME: drupal
LAST DEPLOYED: Mon Aug 17 11:59:29 2020
NAMESPACE: mynamespace
STATUS: deployed</pre>

<p>By adding <code>--create-namespace</code>, we have indicated to Helm that we <em>acknowledge</em> that there may not be a namespace with that name already, and we just want one to be created. Be sure, of course, that if you use this flag on a production instance, you have other mechanisms for enforcing security on this new namespace.</p>

<p>There is not an analogous <code>--delete-namespace</code> on <code>helm uninstall</code>. And the reason for this falls out of Helm’s defensiveness regarding global objects. Once a namespace is created, any number of objects may be put in the namespace, not all of them managed by Helm. And when a namespace is deleted, all of the objects inside of that namespace are also deleted. So Helm does not automatically delete namespaces that were created with <code>--create-namespace</code>. <a data-type="indexterm" data-primary="namespace (Kubernetes)" data-secondary="deleting with kubectl" id="idm46125997095784"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="kubectl" data-tertiary="delete namespace" id="idm46125997094776"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="namespace" data-tertiary="deleting with kubectl" id="idm46125997093560"/>To delete a namespace, use <code>kubectl delete namespace</code> (after making sure, of course, that no important objects exist in that namespace).</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Using helm upgrade --install"><div class="sect2" id="idm46125997112040">
<h2>Using helm upgrade --install</h2>

<p>Some systems, like CI pipelines, are employed to automatically install or upgrade a chart each time a significant event occurs.<a data-type="indexterm" data-primary="continuous integration pipelines" data-see="CI" id="idm46125997090216"/><a data-type="indexterm" data-primary="CI (continuous integration) pipelines" data-secondary="chart install or upgrade automated" id="idm46125997089176"/><a data-type="indexterm" data-primary="git tool" id="idm46125997088200"/> For example, many organizations have pipelines that trigger whenever new code is uploaded to a version control system (VCS) like Git. GitHub, a popular Git hosting service, even provides tools to automatically deploy whenever a code change is merged.</p>

<p>Systems like this often run rudimentary scripts on a stateless platform that does not have the means to query Kubernetes. <a data-type="indexterm" data-primary="upgrades" data-secondary="install flag for install or upgrade" id="idm46125997086600"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="install or upgrade via upgrade install flag" id="idm46125997085608"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="install or upgrade via upgrade install flag" id="idm46125997084632"/>Users of such systems requested a Helm feature that would allow “install or upgrade” support in a single command.</p>

<p>To facilitate this behavior, Helm maintainers added the <code>--install</code> flag to the <code>helm upgrade</code> command. The <code>helm upgrade --install</code> command will install a release if it does not exist already, or will upgrade a release if a release by that name is found. Underneath the hood, it works by querying Kubernetes for a release with the given name. If that release does not exist, it switches out of the upgrade logic and into the install logic.</p>

<p>For example, we can run an install and an upgrade in sequence using exactly the same command:</p>

<pre data-type="programlisting">$ helm upgrade --install wordpress bitnami/wordpress
Release "wordpress" does not exist. Installing it now.
NAME: wordpress
LAST DEPLOYED: Mon Aug 17 13:18:14 2020
NAMESPACE: default
STATUS: deployed
...
$ helm upgrade --install wordpress bitnami/wordpress
Release "wordpress" has been upgraded. Happy Helming!
NAME: wordpress
LAST DEPLOYED: Mon Aug 17 13:18:43 2020
NAMESPACE: default
STATUS: deployed</pre>

<p>As we can see in the first line of output, the first run of the command caused an install, while the second caused an upgrade.</p>

<p>This command does introduce some danger, though. Helm has no way of establishing whether the name of the installation you provide to <code>helm upgrade --install</code> belongs to the release you intend to upgrade or just <em>happens</em> to be the named the same thing as the thing you want to install. Careless use of this command could result in overwriting one installation with another. This is why it is not the default behavior for Helm.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="The --wait and --atomic Flags"><div class="sect2" id="idm46125997077176">
<h2>The --wait and --atomic Flags</h2>

<p>Another pair of significant flags for <code>helm install</code> and <code>helm upgrade</code> modify the success criteria for Helm operations.<a data-type="indexterm" data-primary="wait flag" id="idm46125997074392"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="wait flag" id="idm46125997073688"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="wait flag" id="idm46125997072472"/><a data-type="indexterm" data-primary="install command" data-secondary="wait flag" id="idm46125997071528"/> These are the <code>--wait</code> and <code>--atomic</code> flags.</p>

<p>The <code>--wait</code> flag modifies the behavior of the Helm client in a couple of ways. First, when Helm runs an installation, it remains active for a set window of time<a data-type="indexterm" data-primary="timeout flag" id="idm46125997068440"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="API server" data-tertiary="wait flag for Running status" id="idm46125997067736"/> (modifiable with the <code>--timeout</code> flag) during which it watches Kubernetes. It polls the Kubernetes API server for information about all pod-running objects that were created by the chart. For example, <code>DaemonSet</code>s, <code>Deployment</code>s, and <code>StatefulSet</code>s all create pods. So Helm with <code>--wait</code> will track such objects, waiting until the pods they create are marked as <code>Running</code> by Kubernetes.</p>

<p>In a normal install or upgrade, Helm marks a release as successful as soon as the <a data-type="indexterm" data-primary="manifests" data-secondary="release success determinant" id="idm46125997063304"/><a data-type="indexterm" data-primary="releases" data-secondary="success determination" id="idm46125997062312"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="API server" data-tertiary="release success determinant" id="idm46125997061368"/><a data-type="indexterm" data-primary="package managers" data-secondary="success determination" id="idm46125997060136"/>Kubernetes API server accepts the manifests. This is similar to package managers that consider a package successfully installed as soon as the package contents are written to the correct storage locations.</p>

<p>But with <code>--wait</code>, the success criteria for an installation is modified. A chart is not considered successfully installed unless (1) the Kubernetes API server accepts the manifest and (2) <a data-type="indexterm" data-primary="pods" data-secondary="Running state and wait flag" id="idm46125997057816"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="Running state and wait flag" id="idm46125997056824"/>all of the pods created by the chart reach the <code>Running</code> state before Helm’s timeout expires.</p>

<p>Thus, installs with <code>--wait</code> can fail for a wide variety of reasons, including<a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="installs with wait flag failing" id="idm46125997054088"/><a data-type="indexterm" data-primary="CI (continuous integration) pipelines" data-secondary="chart install or upgrade automated" data-tertiary="installs with wait flag failing" id="idm46125997053032"/> network latency, a slow scheduler, busy nodes, slow image pulls, and outright failure of a container to start.</p>

<p>This behavior is seen as a desirable outcome, and operators use <code>helm install --wait</code> to ensure that not only did the chart successfully install but that the resulting application correctly started. However, it does introduce some complicating factors when troubleshooting. Transient outages may result in Helm failures that are resolved by Kubernetes later. For example, a delayed image pull might result in a Helm release marked as failed, even though a few minutes later the image pull can complete and the application can be started.</p>

<p>With this in mind, though, <code>helm install --wait</code> is a good tool for making sure that the release is brought all the way to running. But when used in automated systems (like CI), it may cause spurious failures. <a data-type="indexterm" data-primary="CI (continuous integration) pipelines" data-secondary="chart install or upgrade automated" data-tertiary="timeout recommended" id="idm46125997049160"/>One recommendation for using <code>--wait</code> in CI is to use a long <code>--timeout</code> (five or ten minutes) to ensure that Kubernetes has time to resolve any transient failures.</p>

<p>A second strategy is to use the <code>--atomic</code> flag instead of the <code>--wait</code> flag. <a data-type="indexterm" data-primary="wait flag" data-secondary="atomic flag instead" id="idm46125997045240"/><a data-type="indexterm" data-primary="atomic flag" id="idm46125997044232"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="atomic flag" id="idm46125997043560"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="wait flag" data-tertiary="atomic flag instead" id="idm46125997042344"/><a data-type="indexterm" data-primary="installation of charts" data-secondary="atomic flag" id="idm46125997041128"/><a data-type="indexterm" data-primary="rollback command" data-secondary="atomic flag" id="idm46125997040184"/><a data-type="indexterm" data-primary="install command" data-secondary="wait flag" data-tertiary="atomic flag instead" id="idm46125997039240"/><a data-type="indexterm" data-primary="install command" data-secondary="atomic flag" id="idm46125997038024"/>This flag causes the same behavior as <code>--wait</code> unless the release fails. Then, instead of marking the release as <code>failed</code> and exiting, it performs an automatic rollback to the last successful release. In automated systems, the <code>--atomic</code> flag is more resistent to outages, since it is less likely to have a failure as its end result. (Keep in mind, though, that there is no assurance that a rollback will be successful.)</p>

<p>Just as <code>--wait</code> can mark a release as a failure for transitive reasons that may be resolved by Kubernetes itself, <code>--atomic</code> may trigger an unnecessary rollback for the same reasons. <a data-type="indexterm" data-primary="timeout flag" id="idm46125997033800"/><a data-type="indexterm" data-primary="CI (continuous integration) pipelines" data-secondary="chart install or upgrade automated" data-tertiary="timeout recommended" id="idm46125997033016"/>Thus, it is recommended to use longer <code>--timeout</code> durations for <code>--atomic</code>, especially when used with CI systems.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="Upgrading with --force and --cleanup-on-fail"><div class="sect2" id="idm46125997076552">
<h2>Upgrading with --force and --cleanup-on-fail</h2>

<p>The last two flags we will look at modify the way that Helm handles the nuances of upgrades.</p>

<p>The <code>--force</code> flag modifies the behavior of Helm when it upgrades a resource<a data-type="indexterm" data-primary="force flag" id="idm46125997028232"/><a data-type="indexterm" data-primary="pods" data-secondary="forcing restarts on update" id="idm46125997027448"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="pods" data-tertiary="forcing restarts on update" id="idm46125997026536"/> that manages pods (like <code>Pod</code>, <code>Deployment</code>, and <code>StatefulSet</code>). Normally, when Kubernetes receives a request to modify such objects, it determines whether it needs to restart the pods that this resource manages. For example, a <code>Deployment</code> may run five replicas of a pod. But if Kubernetes receives an update to the <code>Deployment</code> object, it will only restart those pods if certain fields are modified.</p>

<p>Sometimes, though, Helm users want to make sure that the pods are restarted. That’s where the <code>--force</code> flag comes in. Instead of modifying the <code>Deployment</code> (or similar object), it will delete and re-create it. <a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="downtime from force flag" id="idm46125997021352"/>This forces Kubernetes to delete the old pods and create new ones. By design, using <code>--force</code> will cause downtime. While it is often only seconds of downtime, it is downtime nonetheless. It is recommended to only use 
<span class="keep-together"><code>--force</code></span> when the situation clearly calls for it, not as a default option. For example, the <a data-type="indexterm" data-primary="CI (continuous integration) pipelines" data-secondary="force flag not for production" id="idm46125997018888"/>core maintainers do not recommend using <code>--force</code> in CI pipelines that deploy to production.</p>

<p>Another way to modify the behavior of an upgrade is to use the <code>--cleanup-on-fail</code> flag.<a data-type="indexterm" data-primary="installation of charts" data-secondary="cleanup-on-fail flag" id="idm46125997016488"/><a data-type="indexterm" data-primary="cleanup-on-fail flag" id="idm46125997015480"/><a data-type="indexterm" data-primary="charts" data-secondary="installation of" data-tertiary="cleanup-on-fail flag" id="idm46125997014808"/><a data-type="indexterm" data-primary="debugging and troubleshooting" data-secondary="cleanup-on-fail flag" id="idm46125997013592"/> Similarly to <code>--force</code>, this flag instructs Helm to do additional work.</p>

<p>Consider the case where you install a chart that creates one Kubernetes <code>Secret</code>. <a data-type="indexterm" data-primary="Secrets (Kubernetes)" data-secondary="release failure leaving hanging Secret" id="idm46125997011016"/><a data-type="indexterm" data-primary="Kubernetes" data-secondary="Secrets" data-tertiary="release failure leaving hanging Secret" id="idm46125997010040"/>A new version of the chart is created, and it creates a second <code>Secret</code>. But partway through the installation, Helm encounters an error and marks the release a failure. It is possible for the second <code>Secret</code> to be left hanging. This situation is more likely to arise if 
<span class="keep-together"><code>--wait</code></span> or <code>--atomic</code> are used, since those may fail after Kubernetes has accepted the manifests and created the resources.</p>

<p>The <code>--cleanup-on-fail</code> flag will attempt to fix this situation. On failure, it will request deletion on every object that was <em>newly created</em> during the upgrade. Using it may make it a little harder to debug (especially if the failure was a result of the newly created object), but it is useful if you do not want to risk having unused objects hanging around after a failure.</p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="idm46125997004536">
<h1>Conclusion</h1>

<p>The Helm command-line tool provides many useful commands. While the basic commands were introduced in the previous chapter, this chapter has focused on some of the other useful commands in Helm. Near the end, we also revisited the installation and upgrade commands, getting a taste of some of the more sophisticated features for working with those.</p>

<p>However, not all of the commands were discussed here. In coming chapters, we’ll take a look at commands for creating and packaging charts, commands for signing and verifying packages, and more commands for working with repositories.</p>
</div></section>







</div></section></div></body></html>