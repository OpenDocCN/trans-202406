- en: Chapter 5\. Values and Units
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章\. 值和单位
- en: 'In this chapter, we’ll tackle features that are the basis for almost everything
    you can do with CSS: the units that affect the colors, distances, and sizes of
    a whole host of properties, as well as the units that help define those values.
    Without units, you couldn’t declare that an image should have 10 pixels of blank
    space around it, or that a heading’s text should be a certain size. By understanding
    the concepts put forth here, you’ll be able to learn and use the rest of CSS much
    more quickly.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论几乎可以使用 CSS 做任何事情的基础特性：影响颜色、距离和大小的单位，以及帮助定义这些值的单位。如果没有单位，您将无法声明图像周围应有
    10 像素的空白，或者标题文本应该是某个特定大小。通过理解这里提出的概念，您将能够更快地学习和使用 CSS 的其余部分。
- en: Keywords, Strings, and Other Text Values
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关键词、字符串和其他文本值
- en: Everything in a stylesheet is text, but certain value types directly represent
    strings of text as opposed to, say, numbers or colors. Included in this category
    are URLs and, interestingly enough, images.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 样式表中的一切都是文本，但某些值类型直接表示文本字符串，而不是数字或颜色。这类别中包括 URL 和非常有趣的是，图像。
- en: Keywords
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关键词
- en: 'For those times when a value needs to be described with a word of some kind,
    CSS has *keywords*. A common example is the keyword `none`, which is distinct
    from `0` (zero). Thus, to remove the underline from links in an HTML document,
    you would write the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要用某种词描述一个值时，CSS 使用*关键词*。一个常见的例子是关键词 `none`，它与 `0`（零）不同。因此，要从 HTML 文档中的链接中移除下划线，您应编写以下内容：
- en: '[PRE0]'
  id: totrans-6
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Similarly, if you want to force underlines on the links, you would use the keyword
    `underline` instead of `none`.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，如果您想要强制链接显示下划线，您将使用关键词 `underline` 而不是 `none`。
- en: If a property accepts keywords, its keywords will be defined only for the scope
    of that property. If two properties use the same word as a keyword, the behavior
    of the keyword for one property will not necessarily be shared with the other.
    As an example, `normal`, as defined for `letter-spacing`, means something very
    different from the `normal` defined for `font-style`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果属性接受关键词，其关键词将仅在该属性的范围内定义。例如，`normal` 在 `letter-spacing` 中的定义与在 `font-style`
    中定义的 `normal` 意义完全不同。
- en: Global keywords
  id: totrans-9
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 全局关键词
- en: 'CSS defines five *global* keywords that are accepted by every property in the
    specification: `inherit`, `initial`, `unset`, `revert`, and `revert-layer`.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 定义了五个*全局*关键词，这些关键词被规范中的每个属性所接受：`inherit`、`initial`、`unset`、`revert` 和 `revert-layer`。
- en: inherit
  id: totrans-11
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: inherit
- en: The keyword `inherit` makes the value of a property on an element the same as
    the value of that property on its parent element. In other words, it forces inheritance
    to occur even in situations where it would not normally operate. In many cases,
    you don’t need to specify inheritance, since many properties inherit naturally.
    Nevertheless, `inherit` can still be useful.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关键词 `inherit` 使得元素上的属性值与其父元素上的属性值相同。换句话说，它强制执行继承，即使在通常不会操作继承的情况下也是如此。在许多情况下，您不需要指定继承，因为许多属性会自然继承。尽管如此，`inherit`
    仍然很有用。
- en: 'For example, consider the following styles and markup:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下样式和标记：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `<div>` itself will have a blue background and a white foreground, but the
    links will be styled according to the browser’s preference settings. They’ll most
    likely end up as blue text on a blue background, with white vertical bars between
    them.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`<div>` 本身将具有蓝色背景和白色前景，但链接将根据浏览器的偏好设置进行样式设置。它们很可能最终成为蓝色文本在蓝色背景上，并在它们之间使用白色垂直条。'
- en: 'You could write a rule that explicitly sets the links in the toolbar to be
    white, but you can make things a little more robust by using `inherit`. You just
    add the following rule to the stylesheet:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以编写一个规则，明确将工具栏中的链接设置为白色，但通过使用 `inherit` 可以使事情更加健壮。您只需将以下规则添加到样式表中：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will cause the links to use the inherited value of `color` in place of
    the user agent’s default styles.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致链接使用 `color` 的继承值，而不是用户代理的默认样式。
- en: Ordinarily, directly assigned styles override inherited styles, but `inherit`
    can undo that behavior. It might not always be a good idea—for example, here links
    might blend into surrounding text too much, and become a usability and accessibility
    concern—but it can be done.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，直接分配的样式会覆盖继承的样式，但 `inherit` 可以撤消这种行为。这可能并不总是一个好主意——例如，在这里链接可能会与周围的文本融为一体，成为可用性和可访问性的问题——但确实可以做到。
- en: 'Similarly, you can pull a property value down from a parent even if it wouldn’t
    happen normally. Take `border`, for example, which is (rightfully) not inherited.
    If you want a `<span>` to inherit the border of its parent, all you need is `span
    {border: inherit;}`. More likely, though, you just want the border on a `<span>`
    to use the same border color as its parent. In that case, `span {border-color:
    inherit;}` will do the trick.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '同样，即使通常不会发生，您也可以从父级中拉取属性值下来。例如，`border`是不会继承的（理所当然）。如果您希望`<span>`继承其父元素的边框，则只需`span
    {border: inherit;}`即可。不过更有可能的是，您只希望`<span>`的边框使用与其父元素相同的边框颜色。在这种情况下，`span {border-color:
    inherit;}`就能达到效果。'
- en: initial
  id: totrans-21
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: initial
- en: 'The keyword `initial` sets the value of a property to the defined initial value,
    which, in a way, means it “resets” the value. For example, the default value of
    `font-weight` is `normal`. Therefore, declaring `font-weight: initial` is the
    same as declaring `font-weight: normal`.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '关键字`initial`将属性的值设置为定义的初始值，这在某种程度上意味着它“重置”了该值。例如，`font-weight`的默认值为`normal`。因此，声明`font-weight:
    initial`与声明`font-weight: normal`是相同的。'
- en: 'This might seem a little bit silly until you consider that not all values have
    explicitly defined initial values. For example, the initial value for `color`
    “depends on user agent.” That’s not a funky keyword you should type! What it means
    is that the default value of `color` depends on things like the preference settings
    in a browser. While almost nobody changes the default text color setting from
    black, someone might set it to a dark gray or even a bright red. By declaring
    `color: initial;`, you’re telling the browser to set the color of the element
    to whatever the user’s default color is set to be.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '在您考虑并非所有值都有显式定义的初始值之前，这可能看起来有点愚蠢。例如，`color`的初始值“取决于用户代理”。这不是您应该键入的奇怪关键字！这意味着`color`的默认值取决于浏览器中的偏好设置之类的东西。虽然几乎没有人将默认文本颜色设置从黑色更改为其他颜色，但某人可能将其设置为深灰色甚至是鲜艳的红色。通过声明`color:
    initial;`，您告诉浏览器将元素的颜色设置为用户的默认颜色。'
- en: Another benefit of `initial` is that you can set a property back to its initial
    value without having to know that initial value. This can be especially useful
    when resetting a lot of properties all at once, either via JS or CSS.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个`initial`的好处是，您可以将属性设置回其初始值，而无需知道该初始值是什么。当您需要一次性重置大量属性时，通过JavaScript或CSS，这尤其有用。
- en: unset
  id: totrans-25
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: unset
- en: The keyword `unset` acts as a universal stand-in for both `inherit` and `initial`.
    If the property is inherited, `unset` has the same effect as if `inherit` were
    used. If the property is *not* inherited, `unset` has the same effect as if `initial`
    were used. This makes `unset` useful for resetting a property by canceling out
    any other styles that might be applied to it.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`unset`充当`inherit`和`initial`的通用替代。如果属性是继承的，则`unset`的效果与使用`inherit`相同。如果属性*不*是继承的，则`unset`的效果与使用`initial`相同。这使得`unset`在通过取消应用于属性的任何其他样式来重置属性时非常有用。
- en: revert
  id: totrans-27
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: revert
- en: The keyword `revert` sets the value of a property to the value the property
    would have had if no changes had been made by the current style origin. In effect,
    `revert` lets you say, “All property values for this element should be as if the
    author styles don’t exist, but user agent and user styles do exist.”
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字`revert`将属性的值设置为如果当前样式来源未进行任何更改，则该属性将具有的值。实际上，`revert`使您可以说：“此元素的所有属性值应如同作者样式不存在，但用户代理和用户样式存在。”
- en: 'Thus, given the following basic example, `p` elements will be rendered as gray
    text with a transparent background:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定以下基本示例，`p`元素将呈现为灰色文本，具有透明背景：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This does mean that any property whose value is inherited will be given the
    same value as that of its parent. The `revert` keyword is useful when you have
    a bunch of site-wide styles applying to an element, and you want to strip them
    all away so as to apply a set of one-off styles to just that element. Rather than
    having to override all those properties, you can revert them to defaults—and you
    can do it with a single property, `all`, which is the topic of the next section.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着任何值被继承的属性将与其父元素的值相同。当您希望去除元素上应用的大量全站样式，并且只想为该元素应用一组单独的样式时，`revert`关键字就非常有用。与其覆盖所有这些属性，您可以将它们恢复为默认值——您可以通过单个属性`all`来做到这一点，这是下一节的主题。
- en: revert-layer
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: revert-layer
- en: If you’re using cascade layers (see [“Sorting by Cascade Layer”](ch04.html#sorting_by_layer))
    and want to “undo” whatever styles might be applied by the current layer, the
    `revert-layer` value is here to help. The difference here is that `revert-layer`
    effectively means, “All property values for this element should be as if the author
    styles *in the current cascade layer* don’t exist, but other author cascade layers
    (including the default), user agent, and user styles do exist.”
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用级联层（参见[“按级联层排序”](ch04.html#sorting_by_layer)）并希望“撤消”当前层可能应用的任何样式，`revert-layer`值可以帮助。这里的区别在于，`revert-layer`实际上意味着“这个元素的所有属性值应该就像作者在当前级联层中的样式不存在一样，但其他作者级联层（包括默认层）、用户代理和用户样式存在。”
- en: 'Thus, given the following, paragraphs with a `class` containing the word `example`
    will be rendered as red text on a yellow background:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，考虑到以下情况，包含单词`example`的`class`的段落将呈现为红色文本在黄色背景上：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: For the background, the browser looks at the assigned values in previous cascade
    layers and picks the one with the highest weight. Only one layer (`system`) sets
    a background color, so that’s what’s used instead of `lime`. The same is done
    for the foreground color, and since a color is assigned in the default layer,
    and the default layer overrides all explicitly created layers, `red` is used instead
    of `gray`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于背景，浏览器查看前面级联层中的指定值，并选择权重最高的一个。只有一个层级（`system`）设置了背景颜色，因此使用它而不是`lime`。前景颜色也是如此，因为在默认层中分配了颜色，并且默认层会覆盖所有显式创建的层级，所以使用`red`而不是`gray`。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As of late 2023, only Firefox supports `revert-layer`, but we anticipate it
    being widely supported in the near future.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2023年末，只有Firefox支持`revert-layer`，但我们预计它在不久的将来将得到广泛支持。
- en: The all Property
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`all`属性'
- en: 'These global values are usable on all properties, but one special property
    accepts *only* the global keywords: `all`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些全局值可用于所有属性，但有一个特殊属性仅接受全局关键字：`all`。
- en: 'The `all` property is a stand-in for all properties *except* `direction`, `unicode-bidi`,
    and any custom properties (see [“Custom Properties”](#custom_properties)). Thus,
    if you declare `all: inherit` on an element, you’re saying that you want all properties
    except `direction`, `unicode-bidi`, and custom properties to inherit their values
    from the element’s parent. Consider the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`all`属性是所有属性的代表，*除了* `direction`、`unicode-bidi`和任何自定义属性（参见[“自定义属性”](#custom_properties)）。因此，如果你在元素上声明`all:
    inherit`，就表示你希望所有属性（除了`direction`、`unicode-bidi`和自定义属性）从元素的父级继承其值。考虑以下情况：'
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You might think this causes the `<div>` element to inherit the values of `color`,
    `background`, and `font-weight` from the `<section>` element. And it does do that,
    yes—but it will *also* force inheritance of the values of *every single other
    property in CSS* (minus the two exceptions) from the `<section>` element.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这会导致`<div>`元素从`<section>`元素继承`color`、`background`和`font-weight`的值。确实如此，但它还会*强制*继承CSS中*每一个其他属性的值*（除了两个例外）从`<section>`元素。
- en: 'Maybe that’s what you want, in which case, great. But if you just want to inherit
    the property values you wrote out for the `<section>` element, the CSS would need
    to look more like this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 或许这正是你想要的，如果是这样，那太好了。但如果你只是想继承为`<section>`元素编写的属性值，CSS应该更像这样：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Odds are that what you really want in these situations is `all: unset`, but
    your stylesheet may vary.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '在这些情况下，你真正想要的可能是`all: unset`，但你的样式表可能会有所不同。'
- en: Strings
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'A *string value* is an arbitrary sequence of characters wrapped in either single
    or double quotes, and is represented in value definitions with <*`string`*>. Here
    are two simple examples:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '*字符串值*是一个任意字符序列，用单引号或双引号括起来，在值定义中用<*`string`*>表示。这里有两个简单的例子：'
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note that the quotes balance, which is to say that you always start and end
    with the same kind of quotes. Getting this wrong can lead to all kinds of parsing
    problems, since starting with one kind of quote and trying to end with the other
    means the string won’t actually be terminated. You could accidentally incorporate
    subsequent rules into the string that way!
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意引号的平衡，也就是说，你总是以相同类型的引号开始和结束。如果搞错了，会导致各种解析问题，因为以一种引号开始并试图用另一种引号结束意味着字符串实际上不会被终止。你可能会意外地将后续规则合并到字符串中！
- en: 'If you want to put quote marks inside strings, that’s OK, as long as they’re
    either not the kind you used to enclose the string or are escaped using a backslash:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在字符串内部放置引号，那是可以的，只要它们不是用来封闭字符串的那种引号，或者使用反斜杠进行转义即可：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Note that the only acceptable string delimiters are `''` and `"`, sometimes
    called *straight quotes*. That means you can’t use *curly* or *smart* quotes to
    begin or end a string value. You can use them inside a string value, as in this
    code example, though, and they don’t have to be escaped:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意只有`'`和`"`这两种字符可以作为字符串的定界符，有时被称为*直引号*。这意味着你不能使用*卷曲*或*智能*引号来开始或结束字符串值。你可以在字符串值内部使用它们，就像这个代码示例中一样，并且它们不需要被转义：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This requires that you use Unicode encoding (using the [Unicode standard](http://www.unicode.org/standard/standard.html))
    for your documents, but you should be doing that regardless.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这要求你为文档使用Unicode编码（使用[Unicode标准](http://www.unicode.org/standard/standard.html)），但无论如何你都应该这样做。
- en: 'If you have some reason to include a newline in your string value, you can
    do that by escaping the newline itself. CSS will then remove it, making things
    as if it had never been there. Thus, the following two string values are identical
    from a CSS point of view:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有某种原因要在字符串值中包含换行符，可以通过转义换行符本身来实现。CSS会将其删除，使事情看起来好像从未存在过。因此，从CSS的角度看，以下两个字符串值是相同的：
- en: '[PRE11]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If, on the other hand, you actually want a string value that includes a newline
    character, use the Unicode reference `\A` where you want the newline to occur:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果确实需要一个包含换行符的字符串值，请在所需的换行位置使用Unicode参考`\A`：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Identifiers
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标识符
- en: One-word, case-sensitive strings that should not be quoted are known as *identifiers*,
    represented in the CSS syntax as <*`ident`*> or <*`custom-ident`*>, depending
    on the specification and context. Identifiers are used as animation names, grid-line
    names, and counter names, among others. In addition, <*`dashed-ident`*> is used
    for custom properties. Rules for creating a custom identifier include not starting
    the word with a number, a double hyphen, or a single hyphen followed by a number.
    Other than that, really any character is valid, including emojis, but if you use
    certain characters, including a space or a backslash, you need to escape them
    with a backslash.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 一词，区分大小写的字符串不应被引用，称为*标识符*，在CSS语法中表示为<*`ident`*>或<*`custom-ident`*>，具体取决于规范和上下文。标识符用于动画名称、网格线名称和计数器名称等。此外，<*`dashed-ident`*>
    用于自定义属性。创建自定义标识符的规则包括不以数字、双连字符或单连字符后跟数字开头。除此之外，几乎任何字符都是有效的，包括表情符号，但如果使用特定字符，如空格或反斜杠，则需要用反斜杠进行转义。
- en: Identifiers themselves are words and are case-sensitive; thus, `myID` and `MyID`
    are, as far as CSS is concerned, completely distinct and unrelated to each other.
    If a property accepts both an identifier and one or more keywords, the author
    should take care to never define an identifier that is identical to a valid keyword,
    including the global keywords `initial`, `inherit`, `unset`, and `revert`. Using
    `none` is also a really bad idea.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 标识符本身是单词并且区分大小写；因此，对于CSS而言，`myID`和`MyID`是完全不同且不相关的。如果属性接受标识符和一个或多个关键字，作者应该注意绝不定义与有效关键字相同的标识符，包括全局关键字`initial`、`inherit`、`unset`和`revert`。使用`none`也是一个非常糟糕的主意。
- en: URLs
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: URLs
- en: 'If you’ve written web pages, you’re almost certainly familiar with uniform
    resource locators (URLs). Whenever you need to refer to one—as in the `@import`
    statement, which is used when importing an external stylesheet—here is the general
    format:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你写过网页，几乎肯定熟悉统一资源定位符（URLs）。每当你需要引用一个时，例如在导入外部样式表时使用的`@import`语句，这里是一般的格式：
- en: '[PRE13]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This example defines an *absolute URL*. This URL will work no matter where
    (or rather, in what page) it’s found, because it defines an absolute location
    in web space. Let’s say that you have a server called *web.waffles.org*. On that
    server is a directory called *pix*, and in this directory is an image *waffle22.gif*.
    In this case, the absolute URL of that image would be as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子定义了一个*绝对URL*。无论它在何处（或者更确切地说，在哪个页面）找到，这个URL都有效，因为它在Web空间中定义了一个绝对位置。假设你有一个名为*web.waffles.org*的服务器。在该服务器上有一个名为*pix*的目录，在此目录中有一张名为*waffle22.gif*的图像。在这种情况下，该图像的绝对URL如下：
- en: '[PRE14]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This URL is valid no matter where it is written, whether the page containing
    it is located on the server *web.waffles.org* or *web.pancakes.com*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 无论写在何处，这个URL都是有效的，无论包含它的页面位于服务器*web.waffles.org*还是*web.pancakes.com*。
- en: 'The other type of URL is a *relative URL*, so named because it specifies a
    location that is relative to the document that uses it. If you’re referring to
    a relative location, such as a file in the same directory as your web page, the
    general format is as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种URL类型是*相对URL*，因为它指定的位置是相对于使用它的文档的位置。如果你引用相对位置，比如与网页相同目录中的文件，一般格式如下：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This works only if the image is on the same server as the page that contains
    the URL. For argument’s sake, assume that you have a web page located at *http://web.waffles.org/syrup.html*
    and that you want the image *waffle22.gif* to appear on this page. In that case,
    the URL would be the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这仅在图片位于包含URL的页面相同服务器上时有效。假设你有一个网页位于*http://web.waffles.org/syrup.html*，你希望图片*waffle22.gif*显示在此页面上。在这种情况下，URL将是以下内容：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This path works because the web browser knows it should start with the place
    it found the web document and then add the relative URL. In this case, the pathname
    *pix/waffle22.gif* added to the server name *http://web.waffles.org* equals *http://web.waffles.org/pix/waffle22.gif*.
    You can almost always use an absolute URL in place of a relative URL; it doesn’t
    matter which you use, as long as it defines a valid location.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此路径有效，因为Web浏览器知道应该从找到Web文档的地方开始，然后添加相对URL。在这种情况下，路径名*pix/waffle22.gif*加到服务器名*http://web.waffles.org*等于*http://web.waffles.org/pix/waffle22.gif*。你几乎总是可以在相对URL的位置使用绝对URL；使用哪种都可以，只要它定义了一个有效的位置。
- en: In CSS, relative URLs are relative to the stylesheet itself, not to the HTML
    document that uses the stylesheet. For example, you may have an external stylesheet
    that imports another stylesheet. If you use a relative URL to import the second
    stylesheet, it must be relative to the first stylesheet. In fact, if you have
    a URL in any imported stylesheet, it needs to be relative to the imported stylesheet.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，相对URL是相对于样式表本身而言，而不是使用样式表的HTML文档。例如，你可能有一个导入另一个样式表的外部样式表。如果你使用相对URL导入第二个样式表，它必须相对于第一个样式表。实际上，如果在任何导入的样式表中有URL，它都需要相对于导入的样式表。
- en: 'As an example, consider an HTML document at *http://web.waffles.org/toppings/tips.html*,
    which has a `<link>` to the stylesheet *http://web.waffles.org/styles/basic.css*:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑一个HTML文档位于*http://web.waffles.org/toppings/tips.html*，它有一个指向样式表*http://web.waffles.org/styles/basic.css*的`<link>`：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Inside the file *basic.css* is an `@import` statement referring to another
    stylesheet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件*basic.css*中有一个`@import`语句，指向另一个样式表：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This `@import` will cause the browser to look for the stylesheet at *http://web.waffles.org/styles/special/toppings.css*,
    not at *http://web.waffles.org/toppings/special/toppings.css*. If you have a stylesheet
    at the latter location, the `@import` in *basic.css* should read one of the two
    following ways:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`@import`将导致浏览器查找样式表*http://web.waffles.org/styles/special/toppings.css*，而不是*http://web.waffles.org/toppings/special/toppings.css*。如果你有一个位于后者位置的样式表，在*basic.css*中的`@import`应该以下面两种方式之一书写：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Note that there cannot be a space between the `url` and the opening parenthesis:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`url`和左括号之间不能有空格：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: If the space is present, the entire declaration will be invalidated and thus
    ignored.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在空格，则整个声明将无效，因此被忽略。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: As of late 2022, the CSS Working Group is planning to introduce a new function
    called `src()`, which will accept only strings and not unquoted URLs. This is
    meant to allow custom properties to be used inside `src()`, which will let authors
    define which file should be loaded based on the value of a custom property.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年末，CSS工作组计划引入一个名为`src()`的新函数，它将仅接受字符串而不接受未引用的URL。这旨在允许在`src()`内使用自定义属性，这将允许作者基于自定义属性的值定义应加载哪个文件。
- en: Images
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 图像
- en: An *image value* is a reference to an image, as you might have guessed. Its
    syntax representation is <*`image`*>.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '*image value*是对图像的引用，正如你可能猜到的那样。其语法表示是<*`image`*>。'
- en: 'At the most basic level of support, which is to say the one every CSS engine
    on the planet would understand, an <*`image`*> value is a <*`url`*> value. In
    more modern user agents, <*`image`*> stands for one of the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在支持的最基本级别，也就是说，地球上每个CSS引擎都能理解的级别上，一个<*`image`*>值是一个<*`url`*>值。在更现代的用户代理中，<*`image`*>代表以下之一：
- en: <*`url`*>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <*`url`*>
- en: A URL identifier of an external resource—in this case, the URL of an image.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 外部资源的URL标识符，例如图片的URL。
- en: <*`gradient`*>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <*`gradient`*>
- en: Refers to either a linear, radial, or conic gradient image, either singly or
    in a repeating pattern. Gradients are fairly complex and are covered in detail
    in [Chapter 9](ch09.html#gradients).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 可以是线性、径向或锥形渐变图像，单独或重复模式。渐变相当复杂，详细介绍见[第9章](ch09.html#gradients)。
- en: <*`image-set`*>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <*`image-set`*>
- en: A set of images, chosen based on a set of conditions embedded into the value,
    which is defined as `image-set()` but is more widely recognized with the `-webkit-`
    prefix. For example, `-webkit-image-set()` could specify that a larger image be
    used for desktop layouts, whereas a smaller image (both in pixel size and file
    size) be used for a mobile design. This value is intended to at least approximate
    the behavior of the `srcset` attribute for `<picture>` elements. As of early 2023,
    `-webkit-image-set` is basically universally supported, with most browsers other
    than Safari also accepting `image-set()` (without the prefix).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一组图像，根据嵌入到值中的一组条件选择，该值定义为`image-set()`，但更广泛地识别为带有`-webkit-`前缀。例如，`-webkit-image-set()`可以指定在桌面布局中使用较大的图像，而在移动设计中使用较小的图像（无论是像素大小还是文件大小）。该值旨在至少近似于`<picture>`元素的`srcset`属性的行为。截至2023年初，`-webkit-image-set`基本上被所有浏览器支持，除了Safari之外的大多数浏览器也接受`image-set()`（无前缀）。
- en: <*`cross-fade`*>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <*`cross-fade`*>
- en: Used to blend two (or more) images together, with a specific transparency given
    to each image. Use cases include blending two images together, blending an image
    with a gradient, and so on. As of early 2023, this is supported as `-webkit-cross-fade()`
    in Blink- and WebKit-based browsers, and not supported at all in the Firefox family,
    with or without the prefix.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 用于将两个（或更多）图像混合在一起，并给每个图像指定特定的透明度。用例包括将两个图像混合在一起，将图像与渐变混合等。截至2023年初，这在基于Blink和WebKit的浏览器中作为`-webkit-cross-fade()`支持，但在Firefox系列中无论是否带有前缀都不支持。
- en: There are also the `image()` and `element()` functions, but as of early 2023,
    neither is supported by any browser, except for a vendor-prefixed version of `element()`
    supported by Firefox. Finally, `paint()` refers to an image painted by CSS Houdini’s
    PaintWorklet. As of early 2023, this is supported in only a basic form by Blink-based
    browsers like Chrome.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`image()`和`element()`函数，但截至2023年初，除了Firefox支持的带有供应商前缀的`element()`版本外，任何浏览器都不支持。最后，`paint()`指的是由CSS
    Houdini的PaintWorklet绘制的图像。截至2023年初，这只在像Chrome这样的基于Blink的浏览器中以基本形式支持。
- en: Numbers and Percentages
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数字和百分比
- en: Numbers and percentages serve as the foundation for many other values types.
    For example, font sizes can be defined using the `em` unit (covered later in this
    chapter) preceded by a number. But what kind of number? Understanding the types
    of numbers here will help you better grasp defining other value types later.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 数字和百分比是许多其他值类型的基础。例如，可以使用`em`单位（本章后面讨论）前面带有数字来定义字体大小。但这里的数字是什么类型？理解这里的数字类型将帮助您更好地掌握定义其他值类型的方法。
- en: Integers
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整数
- en: 'An *integer value* is about as simple as it gets: one or more numbers, optionally
    prefixed by a `+` or `–` (plus or minus) sign to indicate a positive or negative
    value. That’s it. Integer values are represented in value syntax as <*`integer`*>.
    Examples include `712`, `13`, `−42`, and `1066`.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*整数值*就是这么简单：一个或多个数字，可选择地由`+`或`-`（正或负）符号前缀表示正数或负数值。就是这样。整数值在值语法中表示为<*`integer`*>。例如，`712`、`13`、`−42`和`1066`。'
- en: Some properties define a range of acceptable integer values. Integer values
    that fall outside a defined range are, by default, considered invalid and cause
    the entire declaration to be ignored. However, some properties define behavior
    that causes values outside the accepted range to be set to the accepted value
    closest to the declared value, known as *clamping*.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一些属性定义了可接受整数值范围。默认情况下，超出定义范围的整数值被视为无效，并导致整个声明被忽略。但是，某些属性定义了行为，使超出接受范围的值被设置为最接近声明值的接受值，称为*夹紧*。
- en: In cases (such as the property `z-index`) where there is no restricted range,
    user agents must support values up to ±1,073,741,824 (±2^(30)).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有限制范围的情况下（例如属性`z-index`），用户代理必须支持值范围达到±1,073,741,824（±2^(30)）。
- en: Numbers
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: A *number value* is either an <*`integer`*> or a real number, which is to say
    an integer followed by a dot and then some number of following integers. Additionally,
    it can be prefixed by either `+` or `-` to indicate positive or negative values.
    Number values are represented in value syntax as <*`number`*>. Examples include
    `5`, `2.7183`, `−3.1416`, `6.2832`, and `1.0218e29` (scientific notation).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字值* 可以是一个<*`integer`*>或者实数，即整数后跟一个点，然后是一些后续整数。此外，它可以由 `+` 或 `-` 前缀以指示正数或负数值。数字值在值语法中表示为<*`number`*>。例如，`5`，`2.7183`，`−3.1416`，`6.2832`
    和 `1.0218e29`（科学记数法）。'
- en: The reason a <*`number`*> can be an <*`integer`*> and yet they are separate
    value types is that some properties will accept only integers (e.g., `z-index`),
    whereas others will accept any real number (e.g., `flex-grow`).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*数字值* 可以是<*`integer`*>，但它们是不同的值类型，因为某些属性仅接受整数（例如 `z-index`），而其他属性接受任何实数（例如
    `flex-grow`）。'
- en: 'As with integer values, number values may have limits imposed on them by a
    property definition; for example, `opacity` restricts its value to be any valid
    <*`number`*> in the range `0` to `1`, inclusive. Some properties define behavior
    that causes values outside the accepted range to be clamped to an acceptable value
    closest to the declared value; e.g., `opacity: 1.7` would be clamped to `opacity:
    1`. For those that do not, number values that fall outside a defined range are
    considered invalid and cause the entire declaration to be ignored.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '与整数值一样，数字值可能受属性定义的限制；例如，`opacity` 限制其值为范围在 `0` 到 `1` 之间的任何有效<*`number`*>。一些属性定义了行为，使得超出接受范围的值被夹紧到最接近声明值的可接受值；例如，`opacity:
    1.7` 将被夹紧为 `opacity: 1`。对于不这样做的属性，超出定义范围的数字值被视为无效，并导致整个声明被忽略。'
- en: Percentages
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 百分比
- en: A *percentage value* is a <*`number`*> followed by a percentage sign (`%`),
    and is represented in value syntax as <*`percentage`*>. Examples include `50%`
    and `33.333%`. Percentage values are always relative to another value, which can
    be anything—the value of another property of the same element, a value inherited
    from the parent element, or a value of an ancestor element. Properties that accept
    percentage values will define any restrictions on the range of allowed percentage
    values, as well as the way in which the percentage is relatively calculated.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*百分比值* 是一个<*`number`*> 后跟百分号（`%`），在值语法中表示为<*`percentage`*>。例如，`50%` 和 `33.333%`。百分比值始终相对于另一个值，可以是任何值——同一元素的另一个属性的值，从父元素继承的值，或祖先元素的值。接受百分比值的属性将定义允许的百分比值范围以及相对计算百分比的方式。'
- en: Fractions
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分数
- en: A *fraction value* (or *flexible ratio*) is a <*`number`*> followed by the `fr`
    unit label. Thus, one fractional unit is `1fr`. The `fr` unit represents a fraction
    of the leftover space, if any, in a grid container.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*分数值*（或 *flexible ratio*）是一个<*`number`*> 后跟 `fr` 单位标签。因此，一个分数单位是 `1fr`。`fr`
    单位表示网格容器中剩余空间（如果有）的一部分。'
- en: As with all CSS dimensions, there is no space between the unit and the number.
    Fraction values are not lengths (nor are they compatible with <*`length`*> values,
    unlike some <*`percentage`*> values), so they cannot be used with other unit types
    in `calc()` functions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有 CSS 尺寸一样，单位和数字之间没有空格。分数值不是长度（与某些<*`percentage`*>值不兼容），因此不能与 `calc()` 函数中的其他单位类型一起使用。
- en: Note
  id: totrans-114
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Fraction values are mostly used in grid layout (see [Chapter 12](ch12.html#grid-layout)),
    but there are plans to use it in more contexts, such as the planned (as of early
    2023) `stripes()` function.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 分数值主要用于网格布局（参见 [第12章](ch12.html#grid-layout)），但计划将其用于更多上下文，例如计划中（截至2023年初）的
    `stripes()` 函数。
- en: Distances
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 距离
- en: Many CSS properties, such as margins, depend on length measurements to properly
    display various page elements. It’s likely no surprise, then, CSS provides multiple
    ways to measure length.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 CSS 属性，如边距，依赖于长度测量来正确显示各种页面元素。因此，毫不奇怪，CSS 提供了多种测量长度的方式。
- en: All length units can be expressed as either positive or negative numbers followed
    by a label, although note that some properties will accept only positive numbers.
    You can also use real numbers—that is, numbers with decimal fractions, such as
    10.5 or 4.561.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 所有长度单位都可以表示为正数或负数后跟标签，尽管某些属性仅接受正数。您还可以使用实数，即带有小数部分的数字，例如 10.5 或 4.561。
- en: All length units are followed by a short abbreviation that represents the actual
    unit of length being specified, such as `in` (inches) or `pt` (points). The only
    exception to this rule is a length of `0` (zero), which need not be followed by
    a unit when describing lengths.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: All length units are followed by a short abbreviation that represents the actual
    unit of length being specified, such as `in` (inches) or `pt` (points). The only
    exception to this rule is a length of `0` (zero), which need not be followed by
    a unit when describing lengths.
- en: 'These length units are divided into two types: *absolute length units* and
    *relative length units*.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这些长度单位分为两种类型：*绝对长度单位* 和 *相对长度单位*。
- en: Absolute Length Units
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绝对长度单位
- en: 'We’ll start with absolute units because they’re easiest to understand. The
    seven types of absolute units are as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 'We’ll start with absolute units because they’re easiest to understand. The
    seven types of absolute units are as follows:'
- en: '*Inches* (`in`)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*英寸* (`in`)'
- en: As you might expect, this notation refers to the inches you’d find on a ruler
    in the US. (The fact that this unit is in the specification, even though almost
    the entire world uses the metric system, is an interesting insight into the pervasiveness
    of US interests on the internet—but let’s not get into virtual sociopolitical
    theory right now.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所预期的那样，这个表示法指的是您在美国标尺上找到的英寸。尽管几乎整个世界使用公制系统，但这个单位在规范中的存在是对美国在互联网上普遍存在的一个有趣见解——但现在我们不要深入虚拟社会政治理论。
- en: '*Centimeters* (`cm`)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '*厘米* (`cm`)'
- en: Refers to the centimeters that you’d find on rulers the world over. There are
    2.54 centimeters to an inch, and one centimeter equals 0.394 inches.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 指的是您在全世界标尺上找到的厘米。一英寸等于2.54厘米，一厘米等于0.394英寸。
- en: '*Millimeters* (`mm`)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*毫米* (`mm`)'
- en: For those Americans who are metric challenged, 10 millimeters are in 1 centimeter,
    so an inch equals 25.4 millimeters, and a millimeter equals 0.0394 inches.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对公制系统不熟悉的美国人来说，1厘米等于10毫米，因此1英寸等于25.4毫米，而1毫米等于0.0394英寸。
- en: '*Quarter-millimeters* (`Q`)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '*四分之一毫米* (`Q`)'
- en: There are 40 Q units in a centimeter; thus, setting an element to be 1/10 of
    a centimeter wide—which is also a millimeter wide—would mean a value of `4Q`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一厘米中有40Q单位；因此，将一个元素设置为1/10厘米宽度（也就是1毫米宽度）将意味着一个值为`4Q`。
- en: '*Points* (`pt`)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '*点* (`pt`)'
- en: 'Points are standard typographical measurements that have been used by printers
    and typesetters for decades and by word processing programs for many years. Traditionally,
    there are 72 points to an inch. Therefore the capital letters of text set to 12
    points should be one-sixth of an inch tall. For example, `p {font-size`: `18pt;}`
    is equivalent to `p {font-size`: `0.25in;}`.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 'Points are standard typographical measurements that have been used by printers
    and typesetters for decades and by word processing programs for many years. Traditionally,
    there are 72 points to an inch. Therefore the capital letters of text set to 12
    points should be one-sixth of an inch tall. For example, `p {font-size`: `18pt;}`
    is equivalent to `p {font-size`: `0.25in;}`.'
- en: '*Picas* (`pc`)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*派卡* (`pc`)'
- en: 'A pica, which is another typographical term, is equivalent to 12 points, which
    means there are 6 picas to an inch. As just shown, the capital letters of text
    set to 1 pica should be one-sixth of an inch tall. For example, `p {font-size`:
    `1.5pc;}` would set text to the same size as the example declarations found in
    the definition of points.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '一派卡（pica）是另一个排版术语，等于12点，这意味着一英寸中有6派卡。正如刚才展示的那样，将文本设置为1派卡的大写字母应该是英寸高的六分之一。例如，`p
    {font-size`: `1.5pc;}` 将文本设置为与定义点示例中的示例声明相同的大小。'
- en: '*Pixels* (`px`)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*像素* (`px`)'
- en: A pixel is a small box onscreen, but CSS defines pixels more abstractly. In
    CSS terms, a pixel is defined to be the size required to yield 96 pixels per inch.
    Many user agents ignore this definition in favor of simply addressing the pixels
    on the screen. Scaling factors are brought into play when page zooming or printing,
    where an element `100px` wide can be rendered more than 100 device dots wide.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: A pixel is a small box onscreen, but CSS defines pixels more abstractly. In
    CSS terms, a pixel is defined to be the size required to yield 96 pixels per inch.
    Many user agents ignore this definition in favor of simply addressing the pixels
    on the screen. Scaling factors are brought into play when page zooming or printing,
    where an element `100px` wide can be rendered more than 100 device dots wide.
- en: These units are really useful only if the browser knows all the details of the
    screen on which your page is displayed, the printer you’re using, or whatever
    other user agent might apply. On a web browser, display is affected by the size
    of the screen and the resolution to which the screen is set; there isn’t much
    that you, as the author, can do about these factors. If nothing else, measurements
    should be consistent in relation to each other—that is, a setting of `1.0in` should
    be twice as large as `0.5in`, as shown in [Figure 5-1](#setting_absolute-length_left_margins).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单位仅在浏览器知道显示页面的屏幕所有详细信息、正在使用的打印机或其他可能应用的用户代理时才真正有用。在 Web 浏览器上，显示受屏幕大小和屏幕设置的分辨率影响；作为作者，您对这些因素无能为力。如果没有其他办法，测量应保持相对一致——即，`1.0in`
    的设置应比 `0.5in` 大一倍，如[图 5-1](#setting_absolute-length_left_margins)所示。
- en: '![css5 0501](assets/css5_0501.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0501](assets/css5_0501.png)'
- en: Figure 5-1\. Setting absolute-length left margins
  id: totrans-139
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-1\. 设置绝对长度的左边距
- en: 'Let’s make the (fairly suspect) assumption that your computer knows enough
    about its display system to accurately reproduce real-world measurements. You
    could make sure every paragraph has a top margin of half an inch by declaring
    `p {margin-top`: `0.5in;}` in that case.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们（相当可疑地）假设您的计算机足够了解其显示系统，以准确地再现现实世界的测量。在这种情况下，您可以通过声明 `p {margin-top`: `0.5in;}`
    来确保每个段落的顶部边距为半英寸。'
- en: Absolute units are much more useful in defining stylesheets for printed documents,
    where measuring things in terms of inches, points, and picas is common.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 绝对单位在定义样式表用于印刷文档时非常有用，这些单位通常以英寸、点和Picas为单位测量事物。
- en: Pixel lengths
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 像素长度
- en: 'On the face of things, pixels are straightforward. If you look at a screen
    closely enough, you can see that it’s broken into a grid of tiny little boxes.
    Each box is a pixel. Say you define an element to be a certain number of pixels
    tall and wide, as in the following markup:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，像素是直接的。如果你仔细看屏幕，你会发现它被划分成许多小方块的网格。每个方块就是一个像素。比如说，你定义一个元素是特定数量的像素高和宽，就像下面的标记中所示：
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Then it follows that the element will be that many screen elements tall and
    wide, as shown in [Figure 5-2](#using_pixel_lengths).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，该元素将显示在多少屏幕元素高和宽，如[图 5-2](#using_pixel_lengths)所示。
- en: '![css5 0502](assets/css5_0502.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0502](assets/css5_0502.png)'
- en: Figure 5-2\. Using pixel lengths
  id: totrans-147
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-2\. 使用像素长度
- en: The problem is, thanks to high-density displays like those found on mobile devices
    and modern laptops, the individual screen elements aren’t treated as pixels anymore.
    Instead, the pixels used in your CSS are translated into something that aligns
    with human expectations, which is covered in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，由于像移动设备和现代笔记本电脑上发现的高密度显示器，个体屏幕元素不再被视为像素。相反，CSS 中使用的像素被转换成符合人类期望的某种东西，这将在下一节中详细讨论。
- en: Pixel theory
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 像素理论
- en: In its discussion of pixels, the CSS specification recommends that, when a display’s
    resolution density is significantly different from 96 pixels per inch (ppi), user
    agents should scale pixel measurements to a reference pixel.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论像素时，CSS 规范建议，当显示的分辨率密度与 96 像素每英寸（ppi）显著不同时，用户代理应将像素测量缩放到参考像素。
- en: 'The [W3C](https://www.w3.org/TR/css-values-4/#reference-pixel) defines *reference
    pixel* as follows:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[W3C](https://www.w3.org/TR/css-values-4/#reference-pixel)将 *参考像素* 定义如下：'
- en: The visual angle of one pixel on a device with a device pixel density of 96dpi
    and a distance from the reader of an arm’s length. For a nominal arm’s length
    of 28 inches, the visual angle is therefore about 0.0213 degrees. For reading
    at arm’s length, 1px thus corresponds to about 0.26 mm (1/96 inch).
  id: totrans-152
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 具有设备像素密度为 96dpi 和读者距离为手臂长度的设备上的一个像素的视觉角。对于标称手臂长度为 28 英寸，因此视觉角约为 0.0213 度。对于手臂长度的阅读，1px
    相当于约 0.26 mm（1/96 英寸）。
- en: On most modern displays, the actual number of pixels per inch (ppi) is higher
    than 96—sometimes much higher. The Retina display on an iPhone 13, for example,
    is physically 326 ppi, and the display on the iPad Pro is physically 264 ppi.
    As long as a browser on one of those devices sets the reference pixel such that
    an element set to be `10px` tall appears to be 2.6 millimeters tall on the screen,
    the physical display density isn’t something you have to worry about, any more
    than having to worry about the number of dots per inch on a printout.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数现代显示器上，每英寸的实际像素数（ppi）比96更高——有时甚至更高。例如，iPhone 13的Retina显示屏物理上是326ppi，iPad
    Pro的显示屏物理上是264ppi。只要这些设备中的浏览器将参考像素设置为使设定为`10px`高的元素在屏幕上看起来高2.6毫米，物理显示密度就不是你需要担心的事情，就像不需要担心打印品的每英寸点数一样。
- en: Resolution Units
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分辨率单位
- en: 'Some unit types are based on display resolution:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一些单位类型基于显示分辨率：
- en: '*Dots per inch* (`dpi`)'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '*每英寸的点数* (`dpi`)'
- en: The number of display dots per linear inch. This can refer to the dots on a
    paper printer’s output, the physical pixels on an LED screen or other device,
    or the elements in an e-ink display such as that used by a Kindle.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每英寸线性显示点数。这可以是纸打印机输出上的点、LED屏幕或其他设备上的物理像素，或者电子墨水显示器（如Kindle）上的元素。
- en: '*Dots per centimeter* (`dpcm`)'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*每厘米的点数* (`dpcm`)'
- en: Same as `dpi`, except the linear measure is 1 centimeter instead of 1 inch.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 与`dpi`相同，不同之处在于线性测量是1厘米而不是1英寸。
- en: '*Dots per pixel unit* (`dppx`)'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*每像素单位的点数* (`dppx`)'
- en: The number of display dots per CSS `px` unit, with `1dppx` being equivalent
    to `96dpi` because CSS defines pixel units at that ratio. Just bear in mind that
    ratio could change in future versions of CSS.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 每个CSS `px`单位的显示点数，其中`1dppx`相当于`96dpi`，因为CSS以这个比例定义像素单位。只要记住，这个比例在CSS的未来版本中可能会发生变化。
- en: 'These units are most often used in the context of media queries. As an example,
    an author can create a media block to be used only on displays that have higher
    than 500 dpi:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单位最常用于媒体查询的上下文中。例如，作者可以创建一个媒体块，仅在具有高于500dpi的显示器上使用：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Again, it’s important to remember that CSS pixels are *not* device resolution
    pixels. Text with `font-size: 16px` will be a relatively consistent size whether
    the device has 96 dpi or 470 dpi. While a reference pixel is defined to appear
    to be 1/96th of an inch in size, when a device has more than 96 dpi, the content
    will not look smaller. Zooming is created by expanding CSS pixels as much as is
    needed; an image will appear larger, but the image size doesn’t actually change:
    rather, the width of the screen, in terms of reference pixels, gets smaller.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '再次强调，重要的是要记住CSS像素并非设备分辨率像素。设置`font-size: 16px`的文本在设备具有96dpi或470dpi时大小相对一致。当设备的dpi超过96时，通过扩展CSS像素来创建缩放，图像将会显得更大，但实际上图像的大小并没有改变：相反，参考像素的屏幕宽度变窄了。'
- en: Relative Length Units
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对长度单位
- en: Relative units are so called because they are measured in relation to other
    things. The actual (or absolute) distance they measure can change because of factors
    beyond their control, such as screen resolution, the width of the viewing area,
    the user’s preference settings, and a whole host of other things. In addition,
    for some relative units, their size is almost always relative to the element that
    uses them and will thus change from element to element.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 相对单位之所以被称为如此，是因为它们是相对于其他事物进行测量的。它们测量的实际（或绝对）距离可能会因为超出它们控制之外的因素而改变，比如屏幕分辨率、视区宽度、用户的偏好设置，以及其他一系列因素。另外，对于某些相对单位，它们的大小几乎总是相对于使用它们的元素，因此会随元素的变化而变化。
- en: First, let’s consider the character-based length units, including `em`, `ex`,
    and `ch`, which are closely related. Two other font-relative units, `cap` and
    `ic`, are discussed later in the chapter.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑基于字符的长度单位，包括`em`、`ex`和`ch`，它们是密切相关的。另外两个与字体相关的单位，`cap`和`ic`，在本章后面讨论。
- en: The em unit
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: em单位
- en: In CSS, `1em` is defined to be the value of `font-size` for a given font. If
    the `font-size` of an element is 14 pixels, then for that element, `1em` is equal
    to 14 pixels.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSS中，`1em`被定义为给定字体的`font-size`的值。如果一个元素的`font-size`是14像素，那么对于该元素，`1em`等于14像素。
- en: 'As you may suspect, this value can change from element to element. For example,
    let’s say you have an `<h1>` with a font size of 24 pixels, an `<h2>` element
    with a font size of 18 pixels, and a paragraph with a font size of 12 pixels.
    If you set the left margin of all three at `1em`, they will have left margins
    of 24 pixels, 18 pixels, and 12 pixels, respectively:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能猜到的那样，此值可以根据元素而变化。例如，假设你有一个字体大小为24像素的`<h1>`，一个字体大小为18像素的`<h2>`元素和一个字体大小为12像素的段落。如果你将它们的左边距都设置为`1em`，它们的左边距将分别为24像素、18像素和12像素：
- en: '[PRE23]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When setting the size of the font, on the other hand, the value of `em` is relative
    to the font size of the parent element, as illustrated in [Figure 5-3](#using_em_for_margins_and_font_sizing).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，在设置字体大小时，`em` 的值相对于父元素的字体大小，如[图 5-3](#using_em_for_margins_and_font_sizing)所示。
- en: '![css5 0503](assets/css5_0503.png)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0503](assets/css5_0503.png)'
- en: Figure 5-3\. Using `em` for margins and font sizing
  id: totrans-175
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-3\. 使用`em` 为边距和字体大小
- en: In theory, `1em` is equal to the width of a lowercase *m* in the font used—that’s
    where the name comes from, in fact. It’s an old typographer’s term. However, this
    is not assured in CSS.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，`1em` 等于所使用字体中小写字母*m*的宽度——实际上就是这个名称的来源。这是一个老排版工的术语。然而，在 CSS 中不能保证这一点。
- en: The ex unit
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`ex` 单位'
- en: The `ex` unit refers to the height of a lowercase *x* in the font being used.
    Therefore, if two paragraphs use text that is 24 points in size, but each paragraph
    uses a different font, then the value of `ex` could be different for each paragraph.
    This is because different fonts have different heights for *x*, as you can see
    in [Figure 5-4](#varying_x-heights). Even though the examples use 24-point text—and
    therefore each example’s `em` value is 24 points—the x-height for each is different.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`ex` 单位指的是所使用字体中小写字母*x*的高度。因此，如果两个段落使用的文本大小为24点，但每个段落使用不同的字体，则`ex` 的值可能对于每个段落都不同。这是因为不同的字体对于*x*的高度不同，正如你可以在[图 5-4](#varying_x-heights)中看到的那样。即使这些示例使用的是24点的文本——因此每个示例的`em`
    值为24点——每个段落的 x 高度也是不同的。'
- en: '![css5 0504](assets/css5_0504.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0504](assets/css5_0504.png)'
- en: Figure 5-4\. Varying x heights
  id: totrans-180
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-4\. 变化的 x 高度
- en: The ch unit
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: ch 单位
- en: 'The `ch` unit is broadly meant to represent *one character*. [CSS Values and
    Units Level 4](https://www.w3.org/TR/css-values-4/#ch) defines `ch` as follows:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`ch` 单位的广义含义是*一个字符*。[CSS Values and Units Level 4](https://www.w3.org/TR/css-values-4/#ch)
    对 `ch` 的定义如下：'
- en: Equal to the advance measure of the “0” (ZERO, U+0030) glyph found in the font
    used to render it.
  id: totrans-183
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 等于在用于渲染它的字体中找到的“0”（零，U+0030）字形的进距度。
- en: The term *advance measure* is a CSS-ism that corresponds to the term *advance
    width* in Western typography. CSS uses the term *measure* because some scripts
    are not right to left or left to right, but instead top to bottom or bottom to
    top, and so may have an advance height rather than an advance width.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: “进距度”这个术语是 CSS 的一个词汇，对应于西方排版术语中的“进距宽度”。CSS 使用“测量”一词，因为有些脚本不是从左到右或从右到左，而是从上到下或从下到上，因此可能有进高度而不是进宽度。
- en: Without getting into too many details, a character glyph’s advance width is
    the distance from the start of a character glyph to the start of the next. This
    generally corresponds to the width of the glyph itself plus any built-in spacing
    to the sides (although that built-in spacing can be either positive or negative).
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 不深入细节，字符字形的**进距**是从一个字符字形的起点到下一个字符字形的起点的距离。这通常对应于字形本身的宽度加上两侧的任何内置间距（尽管该内置间距可以是正的也可以是负的）。
- en: 'The easiest way to demonstrate the `ch` unit is to run a bunch of zeros together
    and then set an image to have a width with the same number of `ch` units as the
    number of zeros, as shown in [Figure 5-5](#character-relative_sizing):'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 演示 `ch` 单位的最简单方法是连续运行一堆零，然后设置一个图像的宽度，其单位数与零的数量相同的`ch` 单位，如[图 5-5](#character-relative_sizing)所示：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Given a monospace font like Courier, all characters are by definition `1ch`
    wide. In any proportional face type, which is what the vast majority of Western
    typefaces are, characters may be wider or narrower than the 0 and so cannot be
    assumed to be exactly `1ch` wide.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在像 Courier 这样的等宽字体中，所有字符根据定义都是`1ch` 宽。在任何比例面型字体中（这是绝大多数西方字体的类型），字符可能比0更宽或更窄，因此不能假定其宽度正好为`1ch`。
- en: '![css5 0505](assets/css5_0505.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0505](assets/css5_0505.png)'
- en: Figure 5-5\. Character-relative sizing
  id: totrans-190
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-5\. 字符相关大小
- en: Other relative length units
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他相对长度单位
- en: 'We have a few other relative length units to mention:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有几个其他相对长度单位要提到：
- en: '`ic`'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`ic`'
- en: The advance measure of 水 glyph (Chinese, Japanese, and Korean water ideograph,
    U+6C34) found in the first font that can render it. This is like `ch` in that
    it uses an advance measure, but defines a measure more useful for ideographic
    languages than the 0 character. If `ic` can’t be calculated for a given situation,
    it’s assumed to be equal to `1em`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 水字形（中、日、韩水象形文字 U+6C34）首次在能够呈现它的字体中找到。这类似于 `ch`，因为它使用了一个水字形的测量，但定义的测量比字符 `0`
    对象语言更有用。如果在特定情况下无法计算 `ic`，则假定它等于 `1em`。
- en: '`cap`'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`cap`'
- en: The cap-height is approximately equal to the height of a capital Latin letter,
    even in fonts that do not contain Latin letters. If it can’t be calculated for
    a given situation, it’s assumed to be equal to the font’s ascent height.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Cap 高度大约等于大写拉丁字母的高度，即使在不包含拉丁字母的字体中也是如此。如果在特定情况下无法计算，假定它等于字体的上升高度。
- en: '`lh`'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`lh`'
- en: Equal to the computed value of the `line-height` property of the element on
    which it is used.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 等于应用它的元素的 `line-height` 属性的计算值。
- en: At the time of this writing, only Firefox supports `cap`, and only Chromium-based
    browsers support `lh`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，只有 Firefox 支持 `cap`，而只有基于 Chromium 的浏览器支持 `lh`。
- en: Root-Relative Length Units
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根相对长度单位
- en: Most of the character-based length units discussed in the previous section have
    a corresponding root-relative value. A *root-relative value* is one that is calculated
    with respect to the root element of the document, and thus provides a uniform
    value no matter what context it’s used in. We will discuss the most widely supported
    such unit and then summarize the rest.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在前一节讨论的基于字符的长度单位都有对应的根相对值。根相对值是相对于文档的根元素计算的，因此无论在什么上下文中使用，它都提供统一的值。我们将讨论最广泛支持的此类单位，然后总结其余部分。
- en: The rem unit
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`rem` 单位'
- en: 'The `rem` unit is calculated using the font size of the document’s root element.
    In HTML, that’s the `<html>` element. Thus, declaring any element to have `font-size:
    1rem;` sets it to have the same font-size value as the root element of the document.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`rem` 单位是根据文档根元素的字体大小计算的。在 HTML 中，这是 `<html>` 元素。因此，声明任何元素具有 `font-size: 1rem;`
    将使其具有与文档根元素相同的字体大小值。'
- en: 'As an example, consider the following markup fragment. It will have the result
    shown in [Figure 5-6](#ems_versus_rems):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下标记片段。它将显示在 [Figure 5-6](#ems_versus_rems) 中所示的结果：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '![css5 0506](assets/css5_0506.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0506](assets/css5_0506.png)'
- en: Figure 5-6\. Using the `em` unit (middle sentence) versus the `rem` unit (bottom)
  id: totrans-207
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-6\. 使用 `em` 单位（中间句子）与 `rem` 单位（底部）
- en: 'In effect, `rem` acts as a reset for font size: no matter what relative font
    sizing has happened to the ancestors of an element, giving it `font-size: 1rem;`
    will put it right back where the root element is set. This will usually be the
    user’s default font size, unless you (or the user) have set the root element to
    a specific font size.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '实际上，`rem` 作为字体大小的重置作用：无论对元素的祖先应用了何种相对字体大小，给它 `font-size: 1rem;` 都会将其放回到根元素设置的位置。这通常是用户的默认字体大小，除非您（或用户）已将根元素设置为特定的字体大小。'
- en: 'For example, given this declaration, `1rem` will always be equivalent to `13px`:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，给定此声明，`1rem` 将始终等同于 `13px`：
- en: '[PRE27]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'However, given *this* declaration, `1rem` will always be equivalent to three-quarters
    the user’s default font size:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，给定 *此* 声明，`1rem` 将始终等同于用户默认字体大小的四分之三：
- en: '[PRE28]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this case, if the user’s default is 16 pixels, `1rem` will equal `12px`.
    If the user has set their default to 12 pixels—and yes, some people do this—then
    `1rem` will equal `9px`. If the default setting is 20 pixels, `1rem` equals `15px`.
    And so on.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果用户默认设置为 16 像素，`1rem` 将等于 `12px`。如果用户将其默认设置为 12 像素（是的，有些人这样做了），那么 `1rem`
    将等于 `9px`。如果默认设置为 20 像素，则 `1rem` 等于 `15px`。依此类推。
- en: 'You are not restricted to the value `1rem`. Any real number can be used, just
    as with the `em` unit, so you can do fun things like set all of your headings
    to be multiples of the root element’s font size:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 您不限于值 `1rem`。任何实数都可以使用，就像 `em` 单位一样，因此您可以像设置所有标题为根元素字体大小的倍数一样玩得开心：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-216
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: '`font-size: 1rem` is equivalent to `font-size: initial` as long as no font
    size is set for the root element.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '只要未为根元素设置字体大小，`font-size: 1rem` 等同于 `font-size: initial`。'
- en: Other root-relative units
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他根相对单位
- en: As mentioned previously, `rem` is not the only root-relative unit defined by
    CSS. [Table 5-1](#root-relative_equivalents) summarizes the other root-relative
    units.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`rem` 并非 CSS 定义的唯一根相对单位。 [Table 5-1](#root-relative_equivalents) 总结了其他根相对单位。
- en: Table 5-1\. Root-relative equivalent units
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 表格5-1。根相对等效单位
- en: '| Length | Root-relative unit | Relative to |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 长度 | 根相对单位 | 相对于 |'
- en: '| --- | --- | --- |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `em` | `rem` | Computed `font-size` |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| `em` | `rem` | 计算的`font-size` |'
- en: '| `ex` | `rex` | Computed x-height |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| `ex` | `rex` | 计算的x高度 |'
- en: '| `ch` | `rch` | Advance measure of the `0` character |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| `ch` | `rch` | `0`字符的进阶测量 |'
- en: '| `cap` | `rcap` | Height of a Roman capital letter |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| `cap` | `rcap` | 罗马大写字母的高度 |'
- en: '| `ic` | `ric` | Advance measure of the 水 ideograph |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '| `ic` | `ric` | 水字的进阶测量 |'
- en: '| `lh` | `rlh` | Computed `line-height` |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '| `lh` | `rlh` | 计算的`line-height` |'
- en: Of all the root-relative units, only `rem` is supported as of late 2022, but
    it is supported by essentially all browsers.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有的根相对单位中，截至2022年后，只有`rem`受到支持，但几乎所有浏览器都支持它。
- en: Viewport-Relative Units
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视口相对单位
- en: 'CSS provides six *viewport-relative size units*. These are calculated with
    respect to the size of the viewport—browser window, printable area, mobile device
    display, etc.:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: CSS提供了六个*视口相对大小单位*。这些单位是相对于视口的大小进行计算的——包括浏览器窗口、可打印区域、移动设备显示等：
- en: '*Viewport width unit* (`vw`)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '*视口宽度单位*（`vw`）'
- en: Equal to the viewport’s width divided by 100\. Therefore, if the viewport is
    937 pixels wide, `1vw` is equal to `9.37px`. If the viewport’s width changes (say,
    by dragging the browser window wider or narrower), the value of `vw` changes along
    with it.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 等于视口宽度除以100。因此，如果视口宽度为937像素，`1vw`等于`9.37px`。如果视口宽度变化（例如通过拖动浏览器窗口调整宽度），`vw`的值也会相应变化。
- en: '*Viewport height unit* (`vh`)'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*视口高度单位*（`vh`）'
- en: Equal to the viewport’s height divided by 100\. Therefore, if the viewport is
    650 pixels tall, `1vh` is equal to `6.5px`. If the viewport’s height changes (say,
    by dragging the browser window taller or shorter), the value of `vh` changes along
    with it.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 等于视口高度除以100。因此，如果视口高度为650像素，`1vh`等于`6.5px`。如果视口高度变化（例如通过拖动浏览器窗口调整高度），`vh`的值也会相应变化。
- en: '*Viewport block unit* (`vb`)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '*视口块单位*（`vb`）'
- en: Equal to the size of the viewport along the block axis, divided by 100\. The
    block axis is explained in [Chapter 6](ch06.html#basic-visual-formatting). In
    top-to-bottom languages like English or Arabic, `vb` will be equal to `vh` by
    default.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 等于视口沿着块轴的尺寸除以100。块轴在[第6章](ch06.html#basic-visual-formatting)中有解释。在从上到下书写的语言中，例如英语或阿拉伯语，`vb`默认与`vh`相等。
- en: '*Viewport inline unit* (`vi`)'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*视口内联单位*（`vi`）'
- en: Equal to the size of the viewport along the inline axis, divided by 100\. The
    inline axis is explained in [Chapter 6](ch06.html#basic-visual-formatting). In
    horizontally written languages like English or Arabic, `vi` will be equal to `vw`
    by default.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 等于视口沿着内联轴的尺寸除以100。内联轴在[第6章](ch06.html#basic-visual-formatting)中有解释。在水平书写的语言中，例如英语或阿拉伯语，`vi`默认与`vw`相等。
- en: '*Viewport minimum unit* (`vmin`)'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '*视口最小单位*（`vmin`）'
- en: Equal to 1/100th of the viewport’s width or height, whichever is *less*. Thus,
    given a viewport that is 937 pixels wide by 650 pixels tall, `1vmin` is equal
    to `6.5px`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 等于视口宽度或高度的1/100，以较小者为准。因此，如果视口宽度为937像素，高度为650像素，则`1vmin`等于`6.5px`。
- en: '*Viewport maximum unit* (`vmax`)'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '*视口最大单位*（`vmax`）'
- en: Equal to 1/100th of the viewport’s width or height, whichever is *greater*.
    Thus, given a viewport that is 937 pixels wide by 650 pixels tall, `1vmax` is
    equal to `9.37px`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 等于视口宽度或高度的1/100，以较大者为准。因此，如果视口宽度为937像素，高度为650像素，则`1vmax`等于`9.37px`。
- en: 'Because these are length units like any other, they can be used anywhere a
    length unit is permitted. You can scale the font size of a heading in terms of
    the viewport height, for example, with something like `h1 {font-size: 10vh;}`.
    This sets the font size to be 1/10th the height of the viewport—a technique potentially
    useful for article titles and the like.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '因为这些是像任何其他长度单位一样的长度单位，所以可以在任何允许长度单位的地方使用。例如，你可以通过类似`h1 {font-size: 10vh;}`的方法，按照视口高度的比例来调整标题的字体大小。这种技术对于文章标题等可能非常有用。'
- en: These units can be particularly handy for creating full-viewport interfaces,
    such as those we expect to find on a mobile device, because the units allow elements
    to be sized compared to the viewport and not to any of the elements within the
    document tree. It’s thus very simple to fill up the entire viewport, or at least
    major portions of it, and not have to worry about the precise dimensions of the
    actual viewport in any particular case.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单位特别适用于创建全视口界面，例如我们在移动设备上期望找到的界面，因为这些单位允许元素相对于视口而不是文档树中的任何元素进行大小调整。因此，非常简单地填充整个视口，或者至少填充其主要部分，而不必担心任何特定情况下实际视口的精确尺寸。
- en: 'A basic example of viewport-relative sizing is illustrated in [Figure 5-7](#viewport-relative_sizing):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 视口相对大小的基本示例如图[5-7](#viewport-relative_sizing)所示：
- en: '[PRE30]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'An interesting (though perhaps not useful) fact about these units is that they
    aren’t bound to their own primary axis. Thus, for example, you can declare `width:
    25vh;` to make an element as wide as one-quarter the height of the viewport.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '有趣的（虽然可能不实用）关于这些单位的事实是它们不限于自己的主轴。因此，例如，您可以声明`width: 25vh;`使元素的宽度等于视口高度的四分之一。'
- en: '![css5 0507](assets/css5_0507.png)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0507](assets/css5_0507.png)'
- en: Figure 5-7\. Viewport-relative sizing
  id: totrans-250
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-7\. 视口相对大小
- en: 'Variants of these units accommodate the vagaries of viewports and how they
    can be sized, particularly on devices where the UI may expand and contract based
    on user input. These variants are based on four viewport types:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单位的变体适应视口的变化和它们可能的大小调整，特别是在用户界面可能根据用户输入展开和收缩的设备上。这些变体基于四种视口类型：
- en: Default
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 默认
- en: The default viewport size, as defined by the user agent (browser). This viewport
    type is expected to correspond to the units `vw`, `vh`, `vb`, `vi`, `vmin`, and
    `vmax`. The default viewport may correspond to one of the other viewport types;
    e.g., the default viewport could be the same as the large viewport, but that’s
    up to each browser to decide.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 用户代理（浏览器）定义的默认视口大小。预期此视口类型对应于单位`vw`、`vh`、`vb`、`vi`、`vmin`和`vmax`。默认视口可能对应于其他视口类型之一；例如，默认视口可以与大视口相同，但这取决于每个浏览器的决定。
- en: Large
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 大
- en: The largest possible viewport after any user-agent interfaces are contracted
    to their fullest extent. For example, on a mobile device, the browser *chrome*
    (the browser’s address bar, navigation bar, and so on) may be minimized or hidden
    most of the time so that the maximum screen area can be used to show page content.
    This is the state described by the large viewport. If you want an element’s size
    to be determined by the full viewport area, even if that will lead to it being
    overlapped by the UI, the large-viewport units are the way to go. The units corresponding
    to this viewport type are `lvw`, `lvh`, `lvb`, `lvi`, `lvmin`, and `lvmax`.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何用户代理界面收缩到其最大程度后的最大可能视口。例如，在移动设备上，浏览器的*外壳*（浏览器的地址栏、导航栏等）可能大部分时间处于最小化或隐藏状态，以便最大化屏幕区域用于显示页面内容。这是大视口描述的状态。如果您希望元素的大小由整个视口区域决定，即使这样会导致它被界面重叠，大视口单位也是选择的方式。与此视口类型对应的单位包括`lvw`、`lvh`、`lvb`、`lvi`、`lvmin`和`lvmax`。
- en: Small
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 小
- en: The smallest possible viewport after any user-agent interfaces are expanded
    to their fullest extent. In this state, the browser’s chrome takes up as much
    screen space as it possibly can, leaving a minimum space for the page content.
    If you want to be sure an element’s sizing will take into account any possible
    interface actions, use these units. The units corresponding to this viewport type
    are `svw`, `svh`, `svb`, `svi`, `svmin`, and `svmax`.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何用户代理界面扩展到其最大程度后，视口的最小可能大小。在这种状态下，浏览器的外壳会尽可能占据屏幕空间，留下最小的页面内容空间。如果您希望确保元素的大小考虑到任何可能的界面操作，请使用这些单位。与此视口类型对应的单位包括`svw`、`svh`、`svb`、`svi`、`svmin`和`svmax`。
- en: Dynamic
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 动态
- en: The area in which content is visible, which can change as the UI expands or
    contracts. As an example, consider how the browser interface can appear or disappear
    on mobile devices, depending on how the content is scrolled or where on the screen
    the user taps. If you want to set lengths based on the size of the viewport at
    every moment, regardless of how it changes, these are the units for you. The units
    corresponding to this viewport type are `dvw`, `dvh`, `dvb`, `dvi`, `dvmin`, and
    `dvmax`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 内容可见区域，随着 UI 的扩展或收缩而变化。例如，考虑浏览器界面在移动设备上如何根据内容滚动或用户点击屏幕上的位置而显示或消失。如果您希望基于视口大小在每个时刻设置长度，无论其如何变化，那么这些单位就是您需要的。对应于此视口类型的单位包括`dvw`、`dvh`、`dvb`、`dvi`、`dvmin`和`dvmax`。
- en: As of late 2022, scrollbars (if any) are ignored for the purposes of calculating
    all of the previous units. Thus, the calculated size of `svw` or `dvw` will *not*
    change if scrollbars appear or disappear, or at least shouldn’t.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2022 年末，滚动条（如果有）在计算所有先前单位时将被忽略。因此，如果滚动条出现或消失，`svw` 或 `dvw` 的计算大小将*不会*改变，或者至少不应该改变。
- en: Function Values
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数值
- en: 'One of the more recent developments in CSS is an increase in the number of
    values that are effectively functions. These values can range from doing math
    calculations to clamping value ranges to pulling values out of HTML attributes.
    CSS has, in fact, a *lot* of these, listed here:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: CSS 中最近的一些发展之一是有效函数数量的增加。这些值可以从执行数学计算到限制值范围再到从 HTML 属性中提取值。CSS 实际上有*很多*这些功能，列在这里：
- en: '`abs()`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`abs()`'
- en: '`acos()`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`acos()`'
- en: '`annotation()`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`annotation()`'
- en: '`asin()`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`asin()`'
- en: '`atan()`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atan()`'
- en: '`atan2()`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atan2()`'
- en: '`attr()`'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr()`'
- en: '`blur()`'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`blur()`'
- en: '`brightness()`'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`brightness()`'
- en: '`calc()`'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`calc()`'
- en: '`character-variant()`'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`character-variant()`'
- en: '`circle()`'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`circle()`'
- en: '`clamp()`'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`clamp()`'
- en: '`color-contrast()`'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color-contrast()`'
- en: '`color-mix()`'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color-mix()`'
- en: '`color()`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`color()`'
- en: '`conic-gradient()`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conic-gradient()`'
- en: '`contrast()`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contrast()`'
- en: '`cos()`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cos()`'
- en: '`counter()`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counter()`'
- en: '`counters()`'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`counters()`'
- en: '`cross-fade()`'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cross-fade()`'
- en: '`device-cmyk()`'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device-cmyk()`'
- en: '`drop-shadow()`'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`drop-shadow()`'
- en: '`element()`'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`element()`'
- en: '`ellipse()`'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ellipse()`'
- en: '`env()`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env()`'
- en: '`exp()`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exp()`'
- en: '`fit-content()`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fit-content()`'
- en: '`grayscale()`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grayscale()`'
- en: '`hsl()`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hsl()`'
- en: '`hsla()`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hsla()`'
- en: '`hue-rotate()`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hue-rotate()`'
- en: '`hwb()`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hwb()`'
- en: '`hypot()`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hypot()`'
- en: '`image-set()`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image-set()`'
- en: '`image()`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image()`'
- en: '`inset()`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inset()`'
- en: '`invert()`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`invert()`'
- en: '`lab()`'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lab()`'
- en: '`lch()`'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lch()`'
- en: '`linear-gradient()`'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`linear-gradient()`'
- en: '`log()`'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`log()`'
- en: '`matrix()`'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix()`'
- en: '`matrix3d()`'
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`matrix3d()`'
- en: '`max()`'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`max()`'
- en: '`min()`'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`min()`'
- en: '`minmax()`'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`minmax()`'
- en: '`mod()`'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mod()`'
- en: '`oklab()`'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oklab()`'
- en: '`oklch()`'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`oklch()`'
- en: '`opacity()`'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`opacity()`'
- en: '`ornaments()`'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ornaments()`'
- en: '`paint()`'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paint()`'
- en: '`path()`'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path()`'
- en: '`perspective()`'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`perspective()`'
- en: '`polygon()`'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`polygon()`'
- en: '`pow()`'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pow()`'
- en: '`radial-gradient()`'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`radial-gradient()`'
- en: '`rem()`'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rem()`'
- en: '`repeat()`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat()`'
- en: '`repeat-conic-gradiant()`'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeat-conic-gradiant()`'
- en: '`repeating-linear-gradiant()`'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeating-linear-gradiant()`'
- en: '`repeating-radial-gradient()`'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`repeating-radial-gradient()`'
- en: '`rgb()`'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rgb()`'
- en: '`rgba()`'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rgba()`'
- en: '`rotate()`'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate()`'
- en: '`rotate3d()`'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotate3d()`'
- en: '`rotateX()`'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotateX()`'
- en: '`rotateY()`'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotateY()`'
- en: '`rotateZ()`'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rotateZ()`'
- en: '`round()`'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`round()`'
- en: '`saturate()`'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`saturate()`'
- en: '`scale()`'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale()`'
- en: '`scale3d()`'
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale3d()`'
- en: '`scaleX()`'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaleX()`'
- en: '`scaleY()`'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaleY()`'
- en: '`scaleZ()`'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scaleZ()`'
- en: '`sepia()`'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sepia()`'
- en: '`sign()`'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sign()`'
- en: '`sin()`'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sin()`'
- en: '`skew()`'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skew()`'
- en: '`skewX()`'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skewX()`'
- en: '`skewY()`'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skewY()`'
- en: '`sqrt()`'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqrt()`'
- en: '`styleset()`'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`styleset()`'
- en: '`stylistic()`'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stylistic()`'
- en: '`swash()`'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`swash()`'
- en: '`symbols()`'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`symbols()`'
- en: '`tan()`'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tan()`'
- en: '`translate()`'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translate()`'
- en: '`translate3d()`'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translate3d()`'
- en: '`translateX()`'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateX()`'
- en: '`translateY()`'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateY()`'
- en: '`translateZ()`'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`translateZ()`'
- en: '`url()`'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`url()`'
- en: '`var()`'
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var()`'
- en: That’s 97 different function values. We’ll cover some in the rest of this chapter.
    The rest are covered in other chapters, as appropriate for their topics (e.g.,
    the filter functions are described in [Chapter 20](ch20.html#filters-compositing)).
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 97 个不同的函数值。我们将在本章的其余部分中覆盖一些。其余部分根据其主题在其他章节中进行了描述（例如，过滤函数在[第 20 章](ch20.html#filters-compositing)中有详细说明）。
- en: Calculation Values
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算值
- en: When you need to do a little math, CSS provides a `calc()` value. Inside the
    parentheses, you can construct simple mathematical expressions. The permitted
    operators are `+` (addition), `-` (subtraction), `*` (multiplication), and `/`
    (division), as well as parentheses. These follow the traditional precedence order
    of parentheses, exponents, multiplication, division, addition, and subtraction
    (PEMDAS), although in this case it’s really just PMDAS since exponents are not
    permitted in `calc()`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 当您需要进行少量数学运算时，CSS 提供了 `calc()` 值。在括号内，您可以构建简单的数学表达式。允许的运算符包括`+`（加法）、`-`（减法）、`*`（乘法）和`/`（除法），以及括号。这些遵循传统的优先级顺序：括号、指数、乘法、除法、加法和减法（PEMDAS），尽管在这种情况下实际上只是
    PMDAS，因为 `calc()` 不允许指数。
- en: 'As an example, suppose you want your paragraphs to have a width that’s 2 em
    less than 90% the width of their parent element. Here’s how you express that with
    `calc()`:'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您希望段落的宽度比其父元素的宽度小 `2 em`，这是如何用 `calc()` 表示的：
- en: '[PRE31]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `calc()` value can be used with any property that permits one of the following
    value types: <*`length`*>, <*`frequency`*>, <*`angle`*>, <*`time`*>, <*`percentage`*>,
    <*`number`*>, or <*`integer`*>. You can also use all these unit types within a
    `calc()` value, though CSS has some limitations to keep in mind.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '`calc()` 值可与允许以下值类型之一的属性一起使用：<*`length`*>、<*`frequency`*>、<*`angle`*>、<*`time`*>、<*`percentage`*>、<*`number`*>
    或 <*`integer`*>。您还可以在 `calc()` 值中使用所有这些单位类型，尽管 CSS 有一些限制需要牢记。'
- en: 'The basic limitation is that `calc()` does basic type checking to make sure
    that units are, in effect, compatible. The checking works like this:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 基本限制是 `calc()` 进行基本类型检查，以确保单位在效果上是兼容的。检查的工作方式如下：
- en: To either side of a `+` or `–` sign, both values must have the same unit type,
    or be a <*`number`*> and <*`integer`*> (in which case, the result is a <*`number`*>).
    Thus, `5 + 2.7` is valid, and results in `7.7`. On the other hand, `5em + 2.7`
    is invalid, because one side has a length unit and the other does not. Note that
    `5em + 20px` *is* valid, because `em` and `px` are both length units.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `+` 或 `-` 符号的两侧，两个值必须具有相同的单位类型，或者一个是 <*`number`*>，另一个是 <*`integer`*>（此时结果为
    <*`number`*>）。因此，`5 + 2.7` 是有效的，并且结果是 `7.7`。另一方面，`5em + 2.7` 是无效的，因为一侧是长度单位，而另一侧不是。注意，`5em
    + 20px` *是*有效的，因为 `em` 和 `px` 都是长度单位。
- en: Given a `*`, one of the values involved must be a <*`number`*> (which, remember,
    includes integer values). So `2.5rem * 2` and `2 * 2.5rem` are both valid, and
    each results in `5rem`. On the flip side, `2.5rem * 2rem` is *not* valid, because
    the result would be `5rem²`, and length units cannot be area units.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定一个 `*`，参与的值中必须有一个是 <*`number`*>（请记住，这包括整数值）。因此 `2.5rem * 2` 和 `2 * 2.5rem`
    都是有效的，每个结果为 `5rem`。另一方面，`2.5rem * 2rem` *不*有效，因为结果将是 `5rem²`，而长度单位不能是面积单位。
- en: Given a `/`, the value on the *right* side must be a <*`number`*>. If the left
    side is an <*`integer`*>, the result is a <*`number`*>. Otherwise, the result
    is of the unit type used on the left side. This means that `30em / 2.75` is valid,
    but `30 / 2.75em` is not.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定 `/`，右侧的值必须是一个 <*`number`*>。如果左侧是一个 <*`integer`*>，则结果是一个 <*`number`*>。否则，结果是左侧使用的单位类型。这意味着
    `30em / 2.75` 是有效的，但 `30 / 2.75em` 是无效的。
- en: Furthermore, any circumstance that yields division by zero is invalid. This
    is easiest to see in a case like `30px/0`, but there are other ways to get there.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，任何导致除零的情况都是无效的。这在像 `30px/0` 这样的情况中最容易看出，但还有其他导致这种情况的方法。
- en: One more notable limitation is that whitespace is *required* on both sides of
    the `+` and `-` operators, while it is not for `*` and `/`. This was done to allow
    future development of `calc()` values to support keywords that contain hyphens
    (e.g., `max-content`).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个显著的限制是 `+` 和 `-` 运算符两侧都*需要*空白符，而对于 `*` 和 `/` 则不需要。这样做是为了允许未来开发 `calc()` 值以支持包含连字符的关键字（例如
    `max-content`）。
- en: 'Furthermore, it’s valid (and supported) to nest `calc()` functions inside each
    other. Thus you can say something like this:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，嵌套 `calc()` 函数是有效的（也受支持）。因此，您可以这样说：
- en: '[PRE32]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Beyond that, the CSS specification requires that user agents support a *minimum*
    of 20 terms inside any single `calc()` function, where a term is a number, percentage,
    or dimension (e.g., a length). If the number of terms somehow exceeds the user
    agent’s term limits, the entire function is treated as invalid.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 超出这个限制，CSS 规范要求用户代理支持任何单个 `calc()` 函数内的最少*20*个术语，其中术语可以是数字、百分比或维度（例如长度）。如果术语数量超过用户代理的限制，整个函数将被视为无效。
- en: Maximum Values
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最大值
- en: Calculation is nice, but sometimes you just want to make sure a property is
    set to one of a number of values, whichever is smallest. In those cases, the `min()`
    function value comes in very handy. Yes, this is confusing at first, but give
    us a minute and hopefully it will make sense.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 计算很好，但有时您只想确保属性设置为多个值中的最小值之一。在这些情况下，`min()` 函数值非常方便。是的，这一开始可能令人困惑，但请给我们一点时间，希望一切会有所理解。
- en: 'Suppose you want to make sure that an element is never wider than a certain
    amount; say, an image should be one-quarter the width of the viewport or 200 pixels
    wide, whichever is *smaller*. This allows it to be constrained to 200 pixels of
    width on wide viewports, but take up to a quarter the width of smaller viewports.
    For that, you’d say the following:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想确保某个元素永远不超过某个宽度；比如说，一张图像应该是视口宽度的四分之一或宽度为200像素中的*较小值*。这使得它在宽视口上被限制为200像素的宽度，但在较小视口上可以占据视口宽度的四分之一。为此，你可以这样说：
- en: '[PRE33]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The browser will compute the width of `25vw` and compare that to `200px`, and
    use whichever is smaller. If `200px` is smaller than 25% the width of the viewport,
    then `200px` will be used. Otherwise, the element will be 25% as wide as the viewport,
    which could easily be smaller than `1em`. Note that *smaller* in this case means
    closest to negative infinity, not closest to zero. Thus, if you compare two terms
    that compute to (say) `-1500px` and `-2px`, `min()` will pick `-1500px`.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器将计算`25vw`的宽度并将其与`200px`比较，并使用较小者。如果`200px`小于视口宽度的25%，那么将使用`200px`。否则，元素将宽度为视口宽度的25%，这可能比`1em`还要小。请注意，在这种情况下，*较小*意味着接近负无穷大，而不是接近零。因此，如果比较两个计算结果为（比如）`-1500px`和`-2px`，`min()`将选择`-1500px`。
- en: 'You can nest `min()` inside `min()`, or throw a mathematical expression in
    there for one of the values, without having to wrap it in `calc()`. For that matter,
    you can put in `max()` and `clamp()`, which we haven’t even discussed yet. You
    can supply as many terms as you like: if you want to compare four ways of measuring
    something and then pick the minimum, just separate them with commas. Here’s a
    slightly contrived example:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`min()`内嵌套`min()`，或为其中一个值放入数学表达式，而无需将其包装在`calc()`中。此外，你还可以加入`max()`和`clamp()`，即使我们还没有讨论它们。你可以提供尽可能多的项：如果你想比较四种方式来测量某些东西，然后选择最小值，只需用逗号分隔它们。这里有一个略显牵强的例子：
- en: '[PRE34]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Whichever of those values is computed to be the minimum (closest to negative
    infinity) will be used, thus defining a maximum for the `width` value. The order
    you list them in doesn’t matter, since the minimum value will always be picked
    regardless of where it appears in the function.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 这些值中计算出的最小值（接近负无穷大）将被使用，从而定义`width`值的最大值。无论你在函数中的哪个位置列出它们，都不重要，因为始终会选择最小值。
- en: In general, `min()` can be used in any property value that permits <*`length`*>,
    <*`frequency`*>, <*`angle`*>, <*`time`*>, <*`percentage`*>, <*`number`*>, or <*`integer`*>.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，`min()`可以在允许<*`length`*>, <*`frequency`*>, <*`angle`*>, <*`time`*>, <*`percentage`*>,
    <*`number`*>, 或 <*`integer`*>的任何属性值中使用。
- en: Warning
  id: totrans-384
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: Remember that setting a maximum value on font sizes is an accessibility concern.
    You should *never* set a maximum font size using pixels, because that would likely
    prevent text zooming by users. You probably shouldn’t use `min()` for font sizing
    in any case, but if you do, keep `px` lengths out of the values!
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，在设置字体大小的最大值时是一个辅助功能的考虑。你不应该使用像素来设置最大字体大小，因为这可能会阻止用户进行文本缩放。在任何情况下，你可能都不应该使用`min()`来设置字体大小，但如果你使用了，记住在值中不要使用`px`长度！
- en: Minimum Values
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小值
- en: The mirror image of `min()` is `max()`, which can be used to set a minimum value
    for a property. It can appear in the same places and can be nested in the same
    ways as `min()`, and is generally just the same except that it picks the largest
    (closest to positive infinity) value from among the alternatives given.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '`min()`的镜像是`max()`，它可以用于为属性设置最小值。它可以出现在相同的位置并以相同的方式嵌套在`min()`中，通常情况下与`min()`几乎相同，只是它选择给定选项中的最大值（接近正无穷大）。'
- en: 'As an example, perhaps the top of a page’s design should be a minimum of 100
    pixels tall, but it can be taller if conditions permit. In that case, you could
    use something like this:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，也许页面设计的顶部应该至少100像素高，但如果条件允许，它可以更高。在这种情况下，你可以使用类似于这样的东西：
- en: '[PRE35]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Whichever of the values is largest will be used. For a desktop browser window,
    that would probably be `15vh`, unless the base size text is really enormous. For
    a handheld display, it’s more likely that `5rem` or `100px` will be the largest
    value. In effect, this sets a minimum size of 100 pixels tall, since getting either
    `15vh` or `5rem` below that value is easily possible.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 无论这些值中哪个最大，都将被使用。对于桌面浏览器窗口来说，可能会是`15vh`，除非基本文本大小真的很大。对于手持设备显示，更可能是`5rem`或`100px`中的最大值。实际上，这设置了一个最小高度为100像素，因为将`15vh`或`5rem`调整到低于该值是很容易的。
- en: 'Remember that setting even a minimum value on font sizes can create an accessibility
    problem, since a too-small minimum is still too small. A good way to handle this
    is to always include `1rem` in your `max()` expressions for font sizes. Use something
    like this:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，即使在字体大小上设置了最小值，也可能会产生无障碍问题，因为太小的最小值仍然太小。处理这个问题的好方法是始终在字体大小的`max()`表达式中包含`1rem`。可以使用以下方法：
- en: '[PRE36]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Alternatively, you could not use `max()` for font sizing at all. It’s probably
    best left to box sizing and other such uses.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你完全可以不使用`max()`来设置字体大小。最好将其留给盒模型和其他类似用途。
- en: Clamping Values
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制数值
- en: 'If you’ve already been thinking about ways to nest `min()` and `max()` to set
    upper and lower bounds on a value, there’s a way to not only do that, but set
    an “ideal” value as well: `clamp()`. This function value takes three parameters
    representing, in order, the minimum allowed value, preferred value, and maximum
    allowed value.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经考虑过如何嵌套`min()`和`max()`来设置值的上下限，那么不仅可以这样做，还可以设置一个“理想”值：`clamp()`。这个函数接受三个参数，依次表示最小允许值、首选值和最大允许值。
- en: 'For example, consider some text you want to be about 5% the height of the viewport,
    while keeping its minimum the base font size and its maximum three times the text
    around it. That would be expressed like so:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一些文本，你希望其大小约为视口高度的5%，同时保持其最小为基本字体大小，最大为周围文本的三倍。可以这样表达：
- en: '[PRE37]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Given those styles and assuming the base font size is 16 pixels, as it is by
    default in most browsers, then the footer text will be equal to the base font
    size up to a viewport height of 800 pixels (16 divided by 0.02). If the viewport
    gets taller, the text will start to get bigger, unless doing so would make it
    bigger than `3em`. If the text ever gets to the same size as `3em`, it will stop
    growing. (This is fairly unlikely, but one never knows.)
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这些样式并假设基本字体大小为16像素，大多数浏览器默认设置为这个值，那么页脚文本将等于视口高度为800像素（16除以0.02）。如果视口变得更高，文本将开始变大，除非这样做会使其大于`3em`。如果文本的大小达到了`3em`，它将停止增长。（这种情况相对不太可能，但从未可知。）
- en: If the maximum value of a `clamp()` is ever computed to be smaller than the
    minimum value, the maximum is ignored and the minimum value is used instead.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`clamp()`的最大值计算结果小于最小值，则忽略最大值，改为使用最小值。
- en: 'You can use `clamp()` anywhere you can use `min()` and `max()`, including nesting
    them inside each other. For example:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在任何可以使用`min()`和`max()`的地方使用`clamp()`，包括在彼此嵌套的情况下。例如：
- en: '[PRE38]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This is basically the same as the previous example, except in this case the
    preferred value is either 2% the height of the viewport or 1.5 times the size
    of the parent element’s text, whichever is larger.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 这与先前的示例基本相同，只是在这种情况下，首选值要么是视口高度的2%或父元素文本大小的1.5倍，取两者中较大的值。
- en: Attribute Values
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性值
- en: In a few CSS properties, it’s possible to pull in the value of an HTML attribute
    defined for the element being styled. You do this with the `attr()` function.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些CSS属性中，可以使用`attr()`函数拉取为元素样式定义的HTML属性的值。
- en: 'For example, with generated content, you can insert the value of any attribute.
    It looks something like this (don’t worry about understanding the exact syntax,
    which we’ll explore in [Chapter 16](ch16.html#lists-and-generated-content)):'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在生成内容中，可以插入任何属性的值。它看起来像这样（不必担心理解确切的语法，我们将在[第16章](ch16.html#lists-and-generated-content)中探讨）：
- en: '[PRE39]'
  id: totrans-406
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'That expression would prefix any paragraph that has an `id` attribute with
    the value of that `id`, enclosed in square brackets. Therefore, applying the previous
    style to the following paragraphs would have the result shown in [Figure 5-8](#inserting_attribute_values):'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 该表达式将前缀应用于具有`id`属性的任何段落，该值在方括号中，表示该`id`的值。因此，将前述样式应用于以下段落将得到[图5-8](#inserting_attribute_values)中显示的结果：
- en: '[PRE40]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '![css5 0508](assets/css5_0508.png)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0508](assets/css5_0508.png)'
- en: Figure 5-8\. Inserting attribute values
  id: totrans-410
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-8\. 插入属性值
- en: While `attr()` is supported in the `content` property value, it isn’t parsed.
    In other words, if the `attr()` returns an image URL from an attribute value,
    the generated content will be the URL written out as text, and not the image that
    lives at that URL. This is true as of late 2022, anyway; there are plans for changes
    such that `attr()` can be parsed (and also be used for all properties, not just
    `content`).
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`attr()`在`content`属性值中受支持，但并不被解析。换句话说，如果`attr()`从属性值返回一个图像URL，生成的内容将是作为文本写出的URL，而不是该URL上存在的图像。至少在2022年末是这样的；已经有计划对`attr()`进行更改，使其可以被解析（并且可以用于所有属性，而不仅限于`content`）。
- en: Color
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色
- en: 'One of the first questions every starting web author asks is, “How do I set
    colors on my page?” Under HTML, you have two choices: you could use one of a large
    but limited number of colors with names, such as `red` or `purple`, or employ
    a vaguely cryptic method using hexadecimal codes. Both methods for describing
    colors remain in CSS, along with several—and, we think, more intuitive—methods.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者在创建网页时经常问的第一个问题是：“如何设置页面的颜色？”在HTML中，你有两种选择：可以使用一些具有名称的大量但有限的颜色之一，比如`红色`或`紫色`，或者使用十六进制代码这种稍微神秘的方法。这两种描述颜色的方法都在CSS中保留了，并且还有几种我们认为更直观的方法。
- en: Named Colors
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名颜色
- en: 'Over the years, CSS has added a set of 148 colors that are identified by human-readable
    names like `red` or `firebrickred`. CSS calls these, logically enough, *named
    colors*. In the early days, CSS used only the 16 basic color keywords defined
    in HTML 4.01:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，CSS添加了一组148种颜色，这些颜色由像`红色`或`火砖红`这样的人类可读名称标识。CSS称这些逻辑上是*命名颜色*。在早期，CSS仅使用HTML
    4.01中定义的16种基本颜色关键字：
- en: '`aqua`'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`水蓝`'
- en: '`gray`'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`灰色`'
- en: '`navy`'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`海军蓝`'
- en: '`silver`'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`银色`'
- en: '`black`'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`黑色`'
- en: '`green`'
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`绿色`'
- en: '`olive`'
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`橄榄色`'
- en: '`teal`'
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`水鸭蓝`'
- en: '`blue`'
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`蓝色`'
- en: '`lime`'
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`石灰色`'
- en: '`purple`'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`紫色`'
- en: '`white`'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`白色`'
- en: '`fuchsia`'
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`紫红色`'
- en: '`maroon`'
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`栗色`'
- en: '`red`'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`红色`'
- en: '`yellow`'
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`黄色`'
- en: 'So, let’s say you want all first-level headings to be maroon. The best declaration
    would be as follows:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，假设你想要所有一级标题都是栗色。最好的声明应该是：
- en: '[PRE41]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Simple enough, isn’t it? [Figure 5-9](#naming_colors) shows a few more examples:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 很简单，不是吗？[图5-9](#naming_colors)显示了更多示例：
- en: '[PRE42]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '![css5 0509](assets/css5_0509.png)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0509](assets/css5_0509.png)'
- en: Figure 5-9\. Named colors
  id: totrans-437
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-9。命名颜色
- en: You’ve probably seen (and maybe even used) color names other than the ones listed
    earlier. For example, you could say
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到（甚至使用过）除了之前列出的那些名称以外的颜色名称。例如，你可以说
- en: '[PRE43]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: and get a light-green (but not exactly lime) color applied to `<h1>` elements.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 并将淡绿色（但不完全是石灰色）应用于`<h1>`元素。
- en: The CSS color specification includes those original 16 named colors in a longer
    list of 148 color keywords. This extended list is based on the standard X11 RGB
    values that have been in use for decades and recognized by browsers for many years,
    with the addition of some color names from SVG (mostly involving variants of “gray”
    and “grey”) and a memorial color.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: CSS颜色规范在一个长列表中包括了最初的16个命名颜色和148个颜色关键字。这个扩展列表基于几十年来使用的标准X11 RGB值，并且被浏览器多年来认可，还添加了一些来自SVG的颜色名称（主要涉及“灰色”的变体）和一个纪念色。
- en: Color Keywords
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 颜色关键字
- en: 'CSS has two special keywords that can be used anywhere a color value is permitted:
    `transparent` and `currentcolor`.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: CSS有两个特殊关键字，可以在允许颜色值的任何地方使用：`透明`和`currentcolor`。
- en: As its name suggests, `transparent` defines a completely transparent color.
    The CSS Color Module defines it to be equivalent to `rgb(0 0 0 / 0%)`, and that’s
    its computed value. This keyword is not often used to set text color, for example,
    but it is the default value for element background colors. It can also be used
    to define element borders that take up space but are not visible, and is often
    used when defining gradients—​all topics we’ll cover in later chapters.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名称所示，`透明`定义了一种完全透明的颜色。CSS颜色模块将其定义为等同于`rgb(0 0 0 / 0%)`，这是其计算值。这个关键字通常不用于设置文本颜色，但它是元素背景颜色的默认值。它还可以用于定义占据空间但不可见的元素边框，并且在定义渐变时经常使用——这些都是我们后续章节将涵盖的话题。
- en: 'By contrast, `currentcolor` means “whatever the computed value of `color` is
    for this element.” Consider the following:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`currentcolor`意味着“对于该元素，`color`的计算值是什么就是什么”。考虑以下情况：
- en: '[PRE44]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The first declaration causes any `<main>` elements to have a foreground color
    of `gray`. The second declaration uses `currentcolor` to copy the computed value
    of `color`—in this case `gray`—and apply it to any borders the `<main>` elements
    might have. Incidentally, `currentcolor` is actually the default value for `border-color`,
    which we’ll cover in [Chapter 7](ch07.html#padding-borders-outlines-and-margins).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个声明导致任何 `<main>` 元素具有前景色为 `gray`。第二个声明使用 `currentcolor` 复制 `color` 的计算值——在本例中为
    `gray`——并将其应用于 `<main>` 元素可能具有的任何边框上。顺便说一句，`currentcolor` 实际上是 `border-color`
    的默认值，我们将在 [第7章](ch07.html#padding-borders-outlines-and-margins) 中详细讨论。
- en: As with all the named colors, these color names are case-insensitive. We show
    `currentcolor` with mixed capitalization because it is generally written that
    way for legibility.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 与所有命名颜色一样，这些颜色名称不区分大小写。我们以混合大小写显示 `currentcolor` 是因为通常为了可读性而这样写。
- en: Fortunately, CSS has more detailed and precise ways to specify colors. The advantage
    is that, with these methods, you can specify any color in the color spectrum,
    not just a limited list of named colors.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，CSS 有更详细和精确的方法来指定颜色。优点是，通过这些方法，您可以指定颜色谱中的任何颜色，而不仅仅是有限的命名颜色列表。
- en: Colors by RGB and RGBa
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RGB 和 RGBa 颜色
- en: Computers create colors by combining different levels of the primary colors
    red, green, and blue—a combination often referred to as *RGB color*. So, it makes
    sense that you should be able to specify your own combinations of these primary
    colors in CSS. That solution is a bit complex, but possible, and the payoffs are
    worth it because CSS has very few limits on which colors you can produce. You
    can produce color in this manner in four ways, detailed in this section.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机通过组合不同级别的红、绿和蓝三原色来创建颜色，这种组合通常称为 *RGB 颜色*。因此，您应该能够在 CSS 中指定这些主要颜色的自定义组合是有道理的。这个解决方案有点复杂，但是可能的，并且回报是值得的，因为
    CSS 对您可以生成的颜色几乎没有限制。您可以以四种方式以此方式生成颜色，本节详细介绍。
- en: Functional RGB colors
  id: totrans-452
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 功能性 RGB 颜色
- en: Two color value types use *functional RGB notation* as opposed to hexadecimal
    notation. The generic syntax for this type of color value is ``rgb(*`color`*)``,
    where *`color`* is expressed using a triplet of either percentages or numbers.
    The percentage values can be in the range `0%`–`100%`, and the integers can be
    in the range `0`–`255`.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 两种颜色值类型使用 *功能性 RGB 标记* 而不是十六进制标记。这种类型的颜色值的通用语法是 ``rgb(*`color`*)``，其中 *`color`*
    是用百分比或数字表示的三元组。百分比值可以在 `0%`–`100%` 范围内，整数可以在 `0`–`255` 范围内。
- en: 'Thus, to specify white and black, respectively, using percentage notation,
    the values would be as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用百分比表示，分别指定白色和黑色的值如下：
- en: '[PRE45]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Using the integer-triplet notation, the same colors would be represented as
    follows:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数三元组表示法，相同的颜色将表示如下：
- en: '[PRE46]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: An important thing to remember is that you can’t mix integers and percentages
    in the same color value. Thus, `rgb(255,66.67%,50%)` would be invalid and thus
    ignored.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 要记住的一点是，您不能在同一个颜色值中混合整数和百分比。因此，`rgb(255,66.67%,50%)` 将是无效的，并因此被忽略。
- en: Note
  id: totrans-459
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: In more recent browsers, the separating commas in RGB values can be replaced
    with simple whitespace. Thus, black can be represented as `rgb(0 0 0)` or `rgb(0%
    0% 0%)`. This is true of all the color values that allow commas that we’ll see
    throughout the chapter. Bear in mind that some of the newer color functions do
    not allow commas.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在较新的浏览器中，RGB 值中的逗号可以用简单的空格替换。因此，黑色可以表示为 `rgb(0 0 0)` 或 `rgb(0% 0% 0%)`。这对于本章中允许逗号的所有颜色值都是正确的。请注意，一些较新的颜色函数不允许逗号。
- en: 'Assume you want your `<h1>` elements to be a shade of red that lies between
    the values for red and maroon. The `red` value is equivalent to `rgb(100%,0%,0%)`,
    whereas `maroon` is equal to `(50%,0%,0%)`. To get a color between those two,
    you might try this:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您希望 `<h1>` 元素的颜色介于红色和褐红色之间。`red` 值相当于 `rgb(100%,0%,0%)`，而 `maroon` 相当于 `(50%,0%,0%)`。为了得到介于这两者之间的颜色，您可以尝试这样做：
- en: '[PRE47]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This makes the red component of the color lighter than `maroon`, but darker
    than `red`. If, on the other hand, you want to create a pale-red color, you would
    raise the green and blue levels:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得颜色的红色分量比 `maroon` 更浅，但比 `red` 更深。另一方面，如果您想创建一种淡红色，您可以提高绿色和蓝色水平：
- en: '[PRE48]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The closest equivalent color using integer-triplet notation is shown here:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 使用整数三元组表示的最接近等效颜色如下所示：
- en: '[PRE49]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The easiest way to visualize how these values correspond to color is to create
    a table of gray values. The result is shown in [Figure 5-10](#text_set_in_shades_of_gray):'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化这些值如何对应颜色的最简单方法是创建一个灰度值表。结果显示在[图 5-10](#text_set_in_shades_of_gray)中：
- en: '[PRE50]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '![css5 0510](assets/css5_0510.png)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0510](assets/css5_0510.png)'
- en: Figure 5-10\. Text set in shades of gray
  id: totrans-470
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-10\. 设置为灰色调的文本
- en: Since we’re dealing in shades of gray, all three RGB values are the same in
    each statement. If any one were different from the others, a color hue would start
    to emerge. If, for example, `rgb(50%,50%,50%)` were modified to be `rgb(50%,50%,60%)`,
    the result would be a medium-dark color with just a hint of blue.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理灰度，每个语句中的三个 RGB 值都相同。如果有任何一个与其他不同，就会开始出现颜色色调。例如，如果将`rgb(50%,50%,50%)`修改为`rgb(50%,50%,60%)`，则结果将是略带蓝色的中等暗色。
- en: 'You can use fractional numbers in percentage notation. You might, for some
    reason, want to specify that a color be exactly 25.5% red, 40% green, and 98.6%
    blue:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在百分比表示法中使用分数。出于某种原因，您可能希望指定颜色为确切的25.5%红色，40%绿色和98.6%蓝色：
- en: '[PRE51]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Values that fall outside the allowed range for each notation are *clipped*
    to the nearest range edge, meaning that a value that is greater than `100%` or
    less than `0%` will default to those allowed extremes. Thus, the following declarations
    would be treated as if they were the values indicated in the comments:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 超出每个表示法允许范围的值将被*剪辑*到最接近的范围边缘，这意味着大于`100%`或小于`0%`的值将默认为这些允许的极端值。因此，下列声明将被视为注释中指示的值：
- en: '[PRE52]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Conversion between percentages and integers may seem arbitrary, but there’s
    no need to guess at the integer you want—there’s a simple formula for calculating
    them. If you know the percentages for each of the RGB levels you want, you need
    only apply them to the number 255 to get the resulting values. Let’s say you have
    a color of 25% red, 37.5% green, and 60% blue. Multiply each of these percentages
    by 255, and you get 63.75, 95.625, and 153\. Round these values to the nearest
    integers, and voilà: `rgb(64,96,153)`.'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 百分比和整数之间的转换可能看起来是随意的，但没有必要猜测您想要的整数-有一个简单的公式可以计算它们。如果您知道每个 RGB 级别的百分比，只需将它们应用于数字255，即可得到结果值。假设您有一个颜色为25%红色，37.5%绿色和60%蓝色。将这些百分比乘以255，您将得到63.75、95.625和153。将这些值四舍五入到最接近的整数，就得到`rgb(64,96,153)`。
- en: If you already know the percentage values, there isn’t much point in converting
    them into integers. Integer notation is more useful for people who use programs
    such as Adobe Photoshop, which can display integer values in the Info dialog,
    or for those who are so familiar with the technical details of color generation
    that they normally think in values of 0–255.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经知道百分比值，将其转换为整数并没有多大意义。整数表示法对于使用像 Adobe Photoshop 这样的程序可以在信息对话框中显示整数值的人，或者对于那些对颜色生成技术细节非常熟悉的人更有用，他们通常考虑0-255的值。
- en: RGBa colors
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: RGBa 颜色
- en: RGB notations can include a fourth parameter defining the alphatransparency
    value. By adding an alpha value at the end of the RGB triplet, `rgb()` accepts
    a red-green-blue-alpha, or RGBa, value, with the alpha value being a measurent
    of opacity.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: RGB 表示法可以包括第四个参数定义 alpha 透明值。通过在 RGB 三元组末尾添加 alpha 值，`rgb()`接受红绿蓝-Alpha 或 RGBa
    值，其中 alpha 值是不透明度的度量。
- en: While the `rgb()` notation allows for three or four values, the alpha value
    must be present in the legacy `rgba()` function to be valid.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`rgb()`表示法允许三个或四个值，但在传统的`rgba()`函数中，Alpha 值必须存在才有效。
- en: 'For example, suppose you want an element’s text to be half-opaque white. That
    way, any background color behind the text would “shine through,” mixing with the
    half-transparent white. You could write one of the following two values:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设您希望元素的文本为半透明的白色。这样，文本后面的任何背景色都会“透过”，与半透明的白色混合。您可以写以下两个值之一：
- en: '[PRE53]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'To make a color completely transparent, you set the alpha value to `0`; to
    be completely opaque, the correct value is `1`. Thus `rgb(0,0,0)` and `rgba(0,0,0,1)`
    will yield precisely the same result (black). [Figure 5-11](#text_set_in_progressive_translucency)
    shows a series of paragraphs set in increasingly transparent black, which is the
    result of the following rules:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 要使颜色完全透明，您将 alpha 值设置为`0`；要完全不透明，正确的值是`1`。因此，`rgb(0,0,0)`和`rgba(0,0,0,1)`将产生完全相同的结果（黑色）。[图 5-11](#text_set_in_progressive_translucency)展示了一系列逐渐透明的黑色段落，这是以下规则的结果：
- en: '[PRE54]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '![css5 0512](assets/css5_0512.png)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0512](assets/css5_0512.png)'
- en: Figure 5-11\. Text set in progressive translucency
  id: totrans-486
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-11\. 设置为渐进透明的文本
- en: Alpha values are always real numbers in the range `0` to `1`, or percentages
    in the range `0%` to `100%`. Any value outside that range will either be ignored
    or reset to the nearest valid alpha value.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: Alpha值始终是在`0`到`1`的实数范围内，或者在`0%`到`100%`的百分比范围内。超出此范围的任何值都将被忽略或重设为最接近的有效Alpha值。
- en: Hexadecimal RGB colors
  id: totrans-488
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 十六进制RGB颜色
- en: 'CSS allows you to define a color using the same *hexadecimal color notation*
    so familiar to old-school HTML web authors:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: CSS允许您使用与老式HTML网页作者非常熟悉的*十六进制颜色表示法*定义颜色：
- en: '[PRE55]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Computers have been using hex notation for quite some time now, and programmers
    are typically either trained in its use or pick it up through experience. Their
    familiarity with hexadecimal notation likely led to its use in setting colors
    in HTML. That practice was carried over to CSS.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机已经使用十六进制表示法相当长一段时间了，程序员通常要么接受过相关培训，要么通过经验掌握它。他们对十六进制表示法的熟悉度可能导致其在HTML中设置颜色时的使用。这一做法延续到了CSS中。
- en: 'Here’s how it works: by stringing together three hexadecimal numbers in the
    range `00` through `FF`, you can set a color. The generic syntax for this notation
    is `#RRGGBB`. Note that there are no spaces, commas, or other separators between
    the three numbers.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 它的工作原理是这样的：通过将三个十六进制数在`00`到`FF`范围内串联起来，你可以设置一种颜色。这种表示法的通用语法是`#RRGGBB`。注意，这三个数字之间没有空格、逗号或其他分隔符。
- en: Hexadecimal notation is mathematically equivalent to integer-pair notation.
    For example, `rgb(255,255,255)` is precisely equivalent to `#FFFFFF`, and `rgb(51,102,128)`
    is the same as `#336680`. Feel free to use whichever notation you prefer—it will
    be rendered identically by most user agents. If you have a calculator that converts
    between decimal and hexadecimal, making the jump from one to the other should
    be pretty simple.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制表示法在数学上等效于整数对表示法。例如，`rgb(255,255,255)`与`#FFFFFF`完全等效，`rgb(51,102,128)`与`#336680`相同。您可以自由选择您喜欢的表示法，大多数用户代理程序都会以相同的方式呈现它们。如果您有一个可以在十进制和十六进制之间转换的计算器，那么从一种表示法跳转到另一种表示法应该是相当简单的。
- en: 'For hexadecimal numbers that are composed of three matched pairs of digits,
    CSS permits a shortened notation. The generic syntax of this notation is `#RGB`:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 对于由三对匹配的数字组成的十六进制数，CSS允许一种缩写表示法。这种表示法的通用语法是`#RGB`：
- en: '[PRE56]'
  id: totrans-495
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: As you can see from the markup, each color value has only three digits. However,
    since hexadecimal numbers between `00` and `FF` need two digits each, and you
    have only three total digits, how does this method work?
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您从标记中可以看到的那样，每个颜色值仅有三个数字。然而，由于十六进制数在`00`到`FF`之间需要每个两个数字，并且您仅有三个总共的数字，这种方法是如何工作的？
- en: The answer is that the browser takes each digit and replicates it. Therefore,
    `#F00` is equivalent to `#FF0000`, `#6FA` would be the same as `#66FFAA`, and
    `#FFF` would come out `#FFFFFF`, which is the same as `white`. Not every color
    can be represented in this manner. Medium gray, for example, would be written
    in standard hexadecimal notation as `#808080`. This cannot be expressed in shorthand;
    the closest equivalent would be `#888`, which is the same as `#888888`.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是浏览器取每个数字并复制它。因此，`#F00`等同于`#FF0000`，`#6FA`将等同于`#66FFAA`，而`#FFF`将变成`#FFFFFF`，与`白色`相同。并非所有颜色都可以用这种方式表示。例如，中灰色将按标准十六进制表示为`#808080`。这不能用简写表示；最接近的等价物将是`#888`，与`#888888`相同。
- en: Hexadecimal RGBa colors
  id: totrans-498
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 十六进制RGBA颜色
- en: 'Hexadecimal notation can have a fourth hex value to represent the alpha channel
    value. The following rules style the series of paragraphs in [Figure 5-12](#text_set_in_progressive_translucency_redux),
    which are set in increasingly transparent black, just as you saw in the previous
    section:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制表示法可以有第四个十六进制值来表示Alpha通道值。以下规则为设置在[图5-12](#text_set_in_progressive_translucency_redux)中的一系列段落样式，这些段落设置为越来越透明的黑色，就像你在前一节中看到的一样：
- en: '[PRE57]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '![css5 0512](assets/css5_0512.png)'
  id: totrans-501
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0512](assets/css5_0512.png)'
- en: Figure 5-12\. Text set in progressive translucency, redux
  id: totrans-502
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-12。采用渐进透明度设置的文本，重新归纳
- en: 'As with non-alpha hexadecimal values, you can shorten a value composed of matched
    pairs to a four-digit value. Thus, a value of `#663399AA` can be written as `#639A`.
    If the value has any pairs that are not repetitive, the entire eight-digit value
    must be written out: `#663399CA` cannot be shortened to `#639CA`.'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 与非Alpha十六进制值一样，您可以将由匹配对组成的值缩短为四位数值。因此，`#663399AA`的值可以写为`#639A`。如果值中有任何不重复的对，整个八位数值必须写出：`#663399CA`不能缩写为`#639CA`。
- en: HSL and HSLa Colors
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HSL和HSLa颜色
- en: Hue, saturation, and lightness (HSL) color notation is similar to hue, saturation,
    and brightness (HSB), the color system in image editing software like Photoshop,
    and just as intuitive. The hue is expressed as an angle value, saturation is a
    percentage value from 0% (no saturation) to 100% (full saturation), and lightness
    is a percentage value from 0% (completely dark) to 100% (completely light). If
    you’re intimately familiar with RGB, HSL may be confusing at first. (But then,
    RGB is confusing for people familiar with HSL.)
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 色相、饱和度和亮度（HSL）颜色标记类似于色相、饱和度和亮度（HSB），这是图像编辑软件（如Photoshop）中的颜色系统，同样直观。色相被表达为角度值，饱和度是从0%（无饱和度）到100%（完全饱和度）的百分比值，亮度是从0%（完全暗）到100%（完全亮）的百分比值。如果你非常熟悉RGB，刚开始时可能会觉得HSL有些困惑。（但是，对于熟悉HSL的人来说，RGB也是困惑的。）
- en: The *hue* angle is expressed in terms of a circle around which the full spectrum
    of colors progresses. It starts with red at 0 degrees and then proceeds through
    the rainbow until it comes to red again at 360 degrees. When the hue value is
    a unitless number, it is interpreted as degrees.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '*色相*角度是围绕一个圆圈表达的，沿着整个颜色光谱进行。从0度的红色开始，然后通过彩虹进行，直到在360度处再次到达红色。当色相值是一个无单位的数字时，它被解释为度数。'
- en: '*Saturation* measures the intensity of a color. A saturation of `0%` always
    yields a shade of gray, no matter what hue angle you have set, and a saturation
    of `100%` creates the most vivid possible shade of that hue (in the HSL color
    space) for a given lightness.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '*饱和度*衡量颜色的强度。无论设置了什么色相角度，`0%`的饱和度总是产生灰色阴影，而`100%`的饱和度则创建给定亮度下（在HSL颜色空间中）最生动的那种色相阴影。'
- en: Similarly, *lightness* defines how dark or light the color appears. A lightness
    of `0%` is always black, regardless of the other hue and saturation values, just
    as a lightness of `100%` always yields white. Consider the results of the following
    styles, illustrated on the left side of [Figure 5-13](#varying_lightness).
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，*亮度*定义了颜色看起来是多么暗或亮。无论设置了什么色相和饱和度值，`0%`的亮度总是黑色，而`100%`的亮度总是白色。考虑以下样式的结果，这在[图5-13](#varying_lightness)的左侧有所说明。
- en: '[PRE58]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note
  id: totrans-510
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that in more recent browsers, the commas in `hsl()` values can be replaced
    with whitespace.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在较新的浏览器中，`hsl()`值中的逗号可以用空格替换。
- en: 'The gray you see on the left side isn’t just a function of the limitations
    of print: every one of those paragraphs is a shade of gray, because every color
    value has `0%` in the saturation (middle) position. The degree of lightness or
    darkness is set by the lightness (third) position. In all seven examples, the
    hue angle changes, and in none of them does it matter.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 你在左侧看到的灰色并不仅仅是印刷的限制函数：每一个段落都是灰色的，因为每个颜色值在饱和度（中间）位置上都是`0%`。亮度或暗度由亮度（第三）位置设置。在所有七个例子中，色相角度都会改变，但都不会影响。
- en: '![css5 0513](assets/css5_0513.png)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0513](assets/css5_0513.png)'
- en: Figure 5-13\. Varying lightness and hues
  id: totrans-514
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-13\. 变化的亮度和色相
- en: But that’s only so long as the saturation remains at `0%`. If that value is
    raised to, say, `50%`, then the hue angle will become very important, because
    it will control what sort of color you see. Consider the same set of values that
    we saw before, but all set to `50%` saturation; this is illustrated on the right
    side of [Figure 5-13](#varying_lightness), although the color is not visible in
    the print version of this book.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 但这仅在饱和度保持在`0%`的情况下成立。如果该值提高到，比如说，`50%`，那么色相角度将变得非常重要，因为它将控制你看到的颜色类型。考虑之前看到的同一组值，但所有设定为`50%`饱和度；这在[图5-13](#varying_lightness)的右侧有所说明，尽管这本书的印刷版本中颜色不可见。
- en: 'Just as RGB has a legacy RGBa counterpart, HSL has an HSLa counterpart. This
    is an HSL triplet followed by an alpha value in the range 0–1\. The following
    HSLa values are all black with varying shades of transparency, just as in [“Hexadecimal
    RGBa colors”](#hexadecimal_rgba_colors) (and illustrated in [Figure 5-12](#text_set_in_progressive_translucency_redux)):'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 就像RGB有一个传统的RGBA对应物一样，HSL也有一个HSLA对应物。这是一个HSL三元组，后面跟着一个范围在0到1之间的alpha值。以下的HSLA值都是黑色，具有不同程度的透明度，就像在[“十六进制RGBA颜色”](#hexadecimal_rgba_colors)（并且在[图5-12](#text_set_in_progressive_translucency_redux)中说明）中所示：
- en: '[PRE59]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Colors with HWB
  id: totrans-518
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有HWB的颜色
- en: Colors can also be represented in terms of their *hue*, *white* level, and *black*
    level by using the `hwb()` functional value. This function value accepts hue values
    expressed as an angle value. After the hue angle, instead of lightness and saturation,
    whiteness and blackness values are specified as percentages.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 颜色也可以通过使用`hwb()`功能值来表示其*色调*、*白色*级别和*黑色*级别。该函数值接受色调值表示为角度值。在色调角度之后，不是亮度和饱和度，而是白度和黑度值被指定为百分比。
- en: 'Unlike HSL, however, there is no legacy `hwba()` function. Instead, the value
    syntax for `hwb()` allows an opacity to be defined after the HWB values, separated
    from them by a forward slash (`/`). The opacity can be expressed either as a percentage
    or as a real value from 0 to 1, inclusive. Also unlike HSL, commas are not supported:
    the HWB values can only be separated by whitespace.'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 与HSL不同的是，`hwba()`函数没有传统的遗留。相反，`hwb()`的值语法允许在HWB值后面定义一个不透明度，用斜杠（`/`）与它们分隔开。不透明度可以用百分比或从0到1（包括）的实数值表示。与HSL不同的是，逗号是不支持的：HWB值只能用空格分隔。
- en: 'Here are some examples of using HWB notation:'
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是使用HWB表示法的一些例子：
- en: '[PRE60]'
  id: totrans-522
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Lab Colors
  id: totrans-523
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Lab颜色
- en: Historically, all CSS colors were defined in the sRGB color space, which encompassed
    more colors than older display monitors could represent. Modern displays, on the
    other hand, can handle about 150% of the sRGB color space, which still isn’t the
    full range of color humans can perceive, but it’s a lot closer.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 历史上，所有的CSS颜色都是在sRGB颜色空间中定义的，这个空间包含比旧显示器能表示的颜色更多的颜色。然而，现代显示器可以处理大约sRGB颜色空间的150%，这仍然不是人类可以感知到的颜色范围的全部，但已经非常接近了。
- en: In 1931, the *Commission Internationale de l’Éclairage* (International Commission
    on Illumination, or CIE) defined a scientific system for defining colors created
    via light, as opposed to those created with paint or dyes. Now, almost a century
    later, CSS has brought the work of the CIE into its repertoire.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 1931年，国际照明委员会（Commission Internationale de l’Éclairage，简称CIE）定义了一个科学系统，用于定义通过光创建的颜色，而不是通过油漆或染料创建的颜色。现在，将近一个世纪后，CSS已经将CIE的工作引入了其技术手段。
- en: 'It does this using the `lab()` function value to express color in the CIE L*a*b*
    (hereafter shortened as *Lab*) color space. Lab is designed to represent the entire
    range of color that humans can see. The `lab()` function accepts three to four
    parameters: `lab(`*`L`* *`a`* *`b`* / *`A`*`)`. Similar to HWB, the parameters
    must be space-separated (no commas allowed) and a forward slash (`/`) precedes
    the alpha value, if provided.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用`lab()`函数值来在CIE L*a*b*（以下简称为Lab）颜色空间中表示颜色。Lab设计用于表示人类可以看到的整个颜色范围。`lab()`函数接受三到四个参数：`lab(`*`L`*
    *`a`* *`b`* / *`A`*`)`。与HWB类似，参数必须用空格分隔（不允许逗号），如果提供了alpha值，则斜杠（`/`）在其前面。
- en: The *`L`* (Lightness) component specifies the CIE lightness, and is a <*`percentage`*>
    from `0%` representing black to `100%` representing white, or a <*`number`*> from
    `0` to `1`. The second component, *`a`*, is the distance along the a-axis in the
    Lab color space. This axis runs from a purplish red in the positive direction
    to a shade of green in the negative direction. The third component, *`b`*, is
    the distance along the b-axis in the Lab color space. This axis runs from a yellow
    in the positive direction to a blue-violet in the negative direction.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '*`L`*（亮度）分量指定了CIE亮度，并且是从`0%`表示黑色到`100%`表示白色的*百分比*，或者从`0`到`1`的*数字*。第二个分量，*`a`*，是Lab颜色空间中沿a轴的距离。该轴从正方向的紫红色到负方向的绿色阴影。第三个分量，*`b`*，是Lab颜色空间中沿b轴的距离。该轴从正方向的黄色到负方向的蓝紫色。'
- en: The fourth, optional parameter is the opacity, with a value from 0 to 1 inclusive,
    or 0% to 100% inclusive. If omitted, the opacity defaults to 1 (100%), or full
    opacity.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个可选参数是不透明度，其值从0到1（包括），或者从0%到100%（包括）。如果省略，则不透明度默认为1（100%），即完全不透明。
- en: 'Here are some examples of Lab color expressed in CSS:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些在CSS中表示Lab颜色的例子：
- en: '[PRE61]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The main reason to bring Lab (and LCH, which we’ll discuss in a moment) colors
    into CSS is that they are systematically designed to be *perceptually uniform*:
    color values that share a given coordinate will seem consistent in terms of that
    coordinate. Two colors with different hues but the same lightness will appear
    to have similar lightnesses. Two colors with the same hue but different lightnesses
    will appear to be shades of a single hue. This is often not the case with RGB
    and HSL values, so Lab and LCH represent a big improvement.'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Lab（以及稍后我们将讨论的 LCH）颜色引入 CSS 的主要原因是它们被系统设计为 *感知均匀*：具有相同坐标的颜色在该坐标方面看起来是一致的。两个具有不同色调但相同亮度的颜色将看起来具有相似的亮度。具有相同色调但不同亮度的两个颜色将看起来是单一色调的不同阴影。而这在
    RGB 和 HSL 值中通常不是这样，因此 Lab 和 LCH 代表了一个重大改进。
- en: They’re also defined to be device independent, so you should be able to specify
    colors in these color spaces and get a visually consistent result from one device
    to another.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 它们还被定义为设备独立的，因此您应该能够在这些颜色空间中指定颜色，并从一个设备到另一个设备获得视觉上一致的结果。
- en: Warning
  id: totrans-533
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, only WebKit supports `lab()`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2022 年底，只有 WebKit 支持 `lab()`。
- en: LCH Colors
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LCH 颜色
- en: '*Lightness Chroma Hue (LCH)* is a version of Lab designed to represent the
    entire spectrum of human vision. It does this using a different notation: `lch(`*`L`*
    *`C`* *`H`* / *`A`*`)`. The main difference is that *`C`* and *`H`* are polar
    coordinates, rather than linear values along color axes.'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '*亮度色度色调（LCH）* 是设计来表示人类视觉整个光谱的 Lab 的一个版本。它使用不同的符号表示：`lch(`*`L`* *`C`* *`H`*
    / *`A`*`)`。其主要区别在于 *`C`* 和 *`H`* 是极坐标，而不是沿着颜色轴的线性值。'
- en: The *`L`* (Lightness) component is the same as the CIE Lightness, and is a *<percentage>*
    from `0%` representing black to `100%` representing white.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '*`L`*（亮度）组件与 CIE 亮度相同，是从 `0%` 表示黑色到 `100%` 表示白色的 *<percentage>*。'
- en: The *`C`* (Chroma amount) component roughly represents the amount of color.
    Its minimum value is `0`, and no maximum is defined. Negative `C` values are clamped
    to 0.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '*`C`*（色度量）组件大致表示颜色的数量。其最小值为 `0`，没有定义最大值。负值的 *`C`* 被夹紧到 `0`。'
- en: The *`H`* (Hue angle) component is essentially a combination of the *`a`* and
    *`b`* values in `lab()`. The value `0` points along the positive a-axis (toward
    purplish red), `90` points along the positive b-axis (toward mustard yellow),
    `180` points along the negative a-axis (toward greenish cyan), and `270` points
    along the negative b-axis (toward sky blue). This component loosely corresponds
    to HSL’s Hue, but the hue angles differ.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '*`H`*（色调角度）组件本质上是 `lab()` 中 *`a`* 和 *`b`* 值的组合。值 `0` 沿着正向 a 轴（朝紫红色）；`90` 沿着正向
    b 轴（朝芥末黄）；`180` 沿着负向 a 轴（朝青绿色）；`270` 沿着负向 b 轴（朝天蓝色）。此组件大致对应于 HSL 的色调，但色调角度不同。'
- en: 'The optional *`A`* (alpha) component can be a <*`number`*> from 0 to 1, or
    else a <*`percentage`*>, where the number 1 corresponds to 100% (full opacity).
    If present, it is preceded by a forward slash (`/`). Here are some examples:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的 *`A`*（alpha）组件可以是从 0 到 1 的 <*`number`*>，或者是 <*`percentage`*>，其中数字 1 对应于
    100%（完全不透明）。如果存在，它前面会有一个斜杠（`/`）。以下是一些示例：
- en: '[PRE62]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: To give an example of the capabilities of LCH, `lch(52% 132 8)` is a very bright
    magenta equivalent to `rgb(118.23% -46.78% 40.48%)`. Notice the large red value
    and the negative green value, which places the color outside the sRGB color space.
    If you supplied that RGB value to a browser, it would clamp the value to `rgb(100%
    0% 40.48%)`. This is within the sRGB color space, but it is visually quite distinct
    from the color that is defined by `lch(52% 132 8)`.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 为了举例说明 LCH 的能力，`lch(52% 132 8)` 是非常明亮的品红色，相当于 `rgb(118.23% -46.78% 40.48%)`。注意到大的红色值和负的绿色值，这使得颜色超出了
    sRGB 色彩空间。如果您将该 RGB 值提供给浏览器，它会将该值夹紧到 `rgb(100% 0% 40.48%)`。这是在 sRGB 色彩空间内的，但在视觉上与
    `lch(52% 132 8)` 定义的颜色非常不同。
- en: Warning
  id: totrans-543
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, only Safari supports `lch()` values.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 2022 年底，只有 Safari 支持 `lch()` 值。
- en: Oklab and Oklch
  id: totrans-545
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oklab 和 Oklch
- en: Improved versions of Lab and LCH, called *Oklab* and *Oklch*, will be supported
    by CSS via the `oklab()` and `oklch()` functional values. Oklab was developed
    by taking a large set of visually similar colors and performing a numerical optimization
    on them, yielding a color space with better hue linearity and uniformity, and
    better chroma uniformity, than the CIE color spaces. Oklch is a polar-coordinate
    version of Oklab, just as LCH is to Lab.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 改进的Lab和LCH版本，称为*Oklab*和*Oklch*，将通过`oklab()`和`oklch()`功能值在CSS中得到支持。Oklab通过对大量视觉上相似的颜色进行数值优化开发而来，提供了比CIE颜色空间更好的色调线性和统一性，以及更好的色度统一性。Oklch是Oklab的极坐标版本，就像LCH是Lab的一样。
- en: Because of this improved uniformity, Oklab and Oklch will be the default for
    color-interpolation calculations in CSS going forward. However, as of late 2022,
    only Safari supports the `oklab()` and `oklch()` CSS functional values.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种改进的统一性，Oklab和Oklch将成为CSS中颜色插值计算的默认值。然而，截至2022年末，只有Safari支持`oklab()`和`oklch()`
    CSS功能值。
- en: Using color()
  id: totrans-548
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`color()`
- en: The `color()` function value allows a color to be specified in a named color
    space rather than the implicit sRGB color space. It accepts four space-separated
    parameters, as well as an optional fifth opacity value preceded by a forward slash
    (*/*).
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '`color()`函数值允许在命名的颜色空间中指定颜色，而不是隐式的sRGB颜色空间。它接受四个以空格分隔的参数，以及一个可选的第五个不透明度值，该值前面带有斜线`/`。'
- en: The first parameter is a predefined, named color space. Possible values as of
    late 2022 include `srgb`, `srgb-linear`, `display-p3`, `a98-rgb`, `prophoto-rgb`,
    `rec2020`, `xyz`, `xyz-d50`, and `xyz-d65`. The three values that follow are specific
    to the color space declared in the first parameter. Some color spaces may allow
    these values to be percentages, while others may not.
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是预定义的命名颜色空间。截至2022年末，可能的值包括`srgb`、`srgb-linear`、`display-p3`、`a98-rgb`、`prophoto-rgb`、`rec2020`、`xyz`、`xyz-d50`和`xyz-d65`。其后的三个值特定于第一个参数声明的颜色空间。某些颜色空间可能允许这些值为百分比，而其他可能不允许。
- en: 'As an example, the following values should yield the same color:'
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，以下数值应该产生相同的颜色：
- en: '[PRE63]'
  id: totrans-552
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You could easily declare a color that lies outside the gamut of a given color
    space. For example, `color(display-p3 -0.6112 1.0079 -0.2192);` is outside the
    `display-p3` gamut. It’s still a valid color, just not one that can be expressed
    in that color space. When a color value is valid but outside the gamut, it will
    be mapped to the closest color that lies inside the color space’s gamut.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以轻松地声明一个超出给定颜色空间色域的颜色。例如，`color(display-p3 -0.6112 1.0079 -0.2192);`超出了`display-p3`色域。这仍然是一个有效的颜色，只是不能用该颜色空间来表示。当一个颜色值是有效的但超出色域时，它将被映射到该色空间色域内最接近的颜色。
- en: If a color’s value is straight-up invalid, opaque black is used.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个颜色值是完全无效的，不透明黑色将被使用。
- en: Warning
  id: totrans-555
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 警告
- en: As of late 2022, only Safari supports `color()`.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年末，只有Safari支持`color()`。
- en: Applying Color
  id: totrans-557
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用颜色
- en: 'Since we’ve just gone through all the possible color formats, let’s take a
    brief detour to talk about the property that uses color values the most often:
    `color`. This property sets the color of an element’s text and the value of `currentcolor`.'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们刚刚讨论了所有可能的颜色格式，让我们简要地谈一下最常使用颜色值的属性：`color`。这个属性设置元素文本的颜色和`currentcolor`的值。
- en: This property accepts as a value any valid color type, such as `#FFCC00` or
    `rgb(100% 80% 0% / 0.5)`.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性接受任何有效的颜色类型作为值，例如`#FFCC00`或`rgb(100% 80% 0% / 0.5)`。
- en: 'For nonreplaced elements like paragraphs or `<em>` elements, `color` sets the
    color of the text in the element. The following code results in [Figure 5-14](#cab_fig01):'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 对于像段落或`<em>`元素这样的不可替代元素，`color`设置元素中文本的颜色。以下代码将产生[图 5-14](#cab_fig01)：
- en: '[PRE64]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '![css5 0514](assets/css5_0514.png)'
  id: totrans-562
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0514](assets/css5_0514.png)'
- en: Figure 5-14\. Declared color versus default color
  id: totrans-563
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-14\. 声明的颜色与默认颜色
- en: In this example, the default foreground color is black. That doesn’t have to
    be the case, since the user might have set their browser (or other user agent)
    to use a different foreground (text) color. If the browser’s default text color
    was set to `green`, the second paragraph in the preceding example would be green,
    not black—but the first paragraph would still be gray.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，默认的前景色是黑色。这不一定是这样，因为用户可能已经设置他们的浏览器（或其他用户代理程序）来使用不同的前景（文本）颜色。如果浏览器的默认文本颜色设置为`green`，则前面例子中的第二段落将是绿色，而不是黑色，但第一段落仍将是灰色。
- en: 'You need not restrict yourself to such basic operations. There are plenty of
    ways to use `color`. You might have some paragraphs that contain text warning
    the user of a potential problem. To make this text stand out more than usual,
    you might decide to color it red. Just apply a class of `warn` to each paragraph
    that contains warning text (`<p class="warn">`) and the following rule:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 你不必局限于这些基本操作。有许多方法可以使用 `color`。你可能有一些段落包含警告用户潜在问题的文本。为了使这些文本比平常更加突出，你可能决定将其着色为红色。只需将
    `warn` 类应用于包含警告文本的每个段落（`<p class="warn">`），以及以下规则：
- en: '[PRE65]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'In the same document, you might decide that any unvisited hyperlinks within
    a warning paragraph should be green:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在同一文档中，你可能决定警告段落中的任何未访问超链接都应为绿色：
- en: '[PRE66]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Then you change your mind, deciding that warning text should be dark red, and
    that unvisited links in such text should be medium purple. The preceding rules
    need only be changed to reflect the new values. The following code results in
    [Figure 5-15](#cab_fig02):'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你改变主意，决定警告文本应为深红色，并且此类文本中的未访问链接应为中紫色。只需更改前面的规则以反映新值。以下代码导致 [图 5-15](#cab_fig02)：
- en: '[PRE67]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '![css5 0515](assets/css5_0515.png)'
  id: totrans-571
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0515](assets/css5_0515.png)'
- en: Figure 5-15\. Changing colors [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/05-values-and-units/changing-colors.html)
  id: totrans-572
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-15\. 改变颜色 [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/05-values-and-units/changing-colors.html)
- en: 'Another use for `color` is to draw attention to certain types of text. For
    example, boldfaced text is already fairly obvious, but you could give it a different
    color to make it stand out even further—let’s say, maroon:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: '`color` 的另一个用途是吸引注意力到某些类型的文本上。例如，加粗文本已经相当明显了，但你可以给它们赋予不同的颜色以进一步突出 —— 比如说，栗色：'
- en: '[PRE68]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Then you decide that you want all table cells with a class of `highlight` to
    contain light yellow text:'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你决定希望所有具有 `highlight` 类的表格单元格包含浅黄色文本：
- en: '[PRE69]'
  id: totrans-576
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: If you don’t set a background color for any of your text, you run the risk that
    a user’s setup won’t combine well with your own. For example, if a user has set
    their browser’s background to be a pale yellow, like `#FFC`, then the previous
    rule would generate light-yellow text on a pale-yellow background. Far more likely
    is that it’s still the default background of white, against which light yellow
    is still going to be hard to read. It’s therefore generally a good idea to set
    foreground and background colors together. (We’ll talk about background colors
    shortly.)
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为任何文本设置背景颜色，你可能会面临用户的设置与你自己的设置不匹配的风险。例如，如果用户将其浏览器的背景设置为淡黄色，如 `#FFC`，那么上述规则将生成浅黄色文本在淡黄色背景上。更可能的情况是，默认背景仍然是白色，浅黄色文本在白色背景上仍然很难阅读。因此，通常最好同时设置前景色和背景色（我们将很快讨论背景色）。
- en: Affecting Form Elements
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 影响表单元素
- en: 'Setting a value for `color` should (in theory, anyway) apply to form elements.
    Declaring `<select>` elements to have dark-gray text should be as simple as this:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `color` 的值应该（理论上来说）适用于表单元素。声明 `<select>` 元素具有深灰色文本应该像这样简单：
- en: '[PRE70]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: This might also set the color of the borders around the edge of the `<select>`
    element, or it might not. It all depends on the user agent and its default styles.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可能会设置 `<select>` 元素边缘周围的边框颜色，也可能不会。这完全取决于用户代理及其默认样式。
- en: 'You can also set the foreground color of input elements—although, as you can
    see in [Figure 5-16](#cab_fig05), doing so would apply that color to all inputs,
    from text to radio buttons to checkbox inputs:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以设置输入元素的前景色 —— 尽管，正如你在 [图 5-16](#cab_fig05) 中所看到的，这样做会将该颜色应用于从文本到单选按钮到复选框输入的所有输入：
- en: '[PRE71]'
  id: totrans-583
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '![css5 0516](assets/css5_0516.png)'
  id: totrans-584
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0516](assets/css5_0516.png)'
- en: Figure 5-16\. Changing form element foregrounds
  id: totrans-585
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-16\. 改变表单元素的前景色
- en: Note in [Figure 5-16](#cab_fig05) that the text color next to the checkboxes
    is still black. This is because the rules shown assign styles only to elements
    like `<input>` and `<select>`, not normal paragraph (or other) text.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在 [图 5-16](#cab_fig05) 中，复选框旁边的文本颜色仍然是黑色。这是因为所示的规则仅将样式分配给像 `<input>` 和 `<select>`
    这样的元素，而不是普通段落（或其他）文本。
- en: Also note that the checkmark in the checkbox is black. This is due to the way
    form elements are handled in some web browsers, which typically use the form widgets
    built into the base operating system. Thus, when you see a checkbox and checkmark,
    they really aren’t content in the HTML document—they’re UI widgets that have been
    inserted into the document, much as an image would be. In fact, form inputs are,
    like images, replaced elements. In theory, CSS does not style the contents of
    form elements (though this may change in the future).
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，复选框中的勾号是黑色的。这是由于某些网页浏览器处理表单元素的方式，它们通常使用基本操作系统内置的表单部件。因此，当您看到复选框和勾号时，它们实际上不是HTML文档中的内容，而是已插入文档中的UI部件，就像图像一样。事实上，表单输入框像图像一样是替换元素。理论上，CSS不会样式化表单元素的内容（尽管这可能会在未来发生变化）。
- en: In practice, the line is a lot blurrier than that, as [Figure 5-16](#cab_fig05)
    demonstrates. Some form inputs have the color of their text and even portions
    of their UI changed, while others do not. And since the rules aren’t explicitly
    defined, behavior is inconsistent across browsers. In short, form elements are
    deeply tricky to style and should be approached with extreme caution.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，这条线比这更模糊，正如[图 5-16](#cab_fig05) 所示。一些表单输入框具有其文本甚至UI的颜色部分改变，而其他表单输入框则没有。由于规则未明确定义，不同浏览器中的行为是不一致的。简言之，表单元素在样式上非常棘手，应谨慎对待。
- en: Inheriting Color
  id: totrans-589
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承颜色
- en: 'As the definition of `color` indicates, the property is inherited. This makes
    sense, since if you declare `p {color: gray;}`, you probably expect that any text
    within that paragraph will also be gray, even if it’s emphasized or boldfaced
    or whatever. If you *want* such elements to be different colors, that’s easy enough.
    The following code, for example, results in [Figure 5-17](#cab_fig06):'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: '正如`color`的定义所示，该属性是继承的。这是有道理的，因为如果你声明`p {color: gray;}`，你可能期望该段落中的任何文本都是灰色的，即使是强调或加粗的文本也是如此。如果*需要*使这些元素具有不同的颜色，这也很容易。例如，以下代码将产生[图 5-17](#cab_fig06)：'
- en: '[PRE72]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '![css5 0517](assets/css5_0517.png)'
  id: totrans-592
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0517](assets/css5_0517.png)'
- en: Figure 5-17\. Different colors for different elements
  id: totrans-593
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图 5-17\. 不同元素的不同颜色
- en: 'Since color is inherited, it’s theoretically possible to set all of the ordinary
    text in a document to a color, such as red, by declaring `body {color: red;}`.
    This should make all text that is not otherwise styled (such as anchors, which
    have their own color styles) red.'
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: '由于颜色是继承的，理论上可以通过声明`body {color: red;}`来将文档中所有普通文本设置为红色。这应该使得所有未经其他样式处理的文本（例如具有自己颜色样式的锚点）都变为红色。'
- en: Angles
  id: totrans-595
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角度
- en: 'Since we just recently finished talking about hue angles in a number of color
    value types, this is a good time to talk about angle units. Angles in general
    are represented as <*`angle`*>, which is a <*`number`*> followed by one of four
    unit types:'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们刚刚谈到了多种颜色值类型中的色相角度，现在是讨论角度单位的好时机。通常情况下，角度被表示为<*`angle`*>, 它是一个<*`number`*>后跟四种单位类型之一：
- en: '`deg`'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: '`deg`'
- en: Degrees, of which there are 360 in a full circle.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 度数，一个完整圆圈中有360度。
- en: '`grad`'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '`grad`'
- en: Gradians, of which there are 400 in a full circle. Also known as *grades* or
    *gons*.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 百分度，一个完整圆圈中有400。也称为*grades*或*gons*。
- en: '`rad`'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '`rad`'
- en: Radians, of which there are 2π (approximately 6.28) in a full circle.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 弧度，一个完整圆圈中有2π（约6.28）。
- en: '`turn`'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: '`turn`'
- en: Turns, of which there is one in a full circle. This unit is mostly useful when
    animating a rotation and you wish to have it turn multiple times, such as `10turn`
    to make it spin 10 times. (Sadly, the pluralization `turns` is invalid, at least
    as of early 2023, and will be ignored.)
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 转角，一个完整圆圈中有一个。这个单位在进行旋转动画时非常有用，例如`10turn`可以使其旋转10次。（遗憾的是，复数形式`turns`是无效的，至少到2023年初为止，将被忽略。）
- en: To help understand the relationships among these angle types, [Table 5-2](#angle_equivalents)
    shows how some angles are expressed in the various angle units. Unlike for length
    values, when including angles, the unit is always required, even if the value
    is `0deg`.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助理解这些角度类型之间的关系，[表格 5-2](#angle_equivalents) 显示了一些角度在不同单位下的表达方式。与长度值不同，包括角度时总是需要单位，即使数值是`0deg`。
- en: Table 5-2\. Angle equivalents
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 5-2\. 角度等效
- en: '| Degrees | Gradians | Radians | Turns |'
  id: totrans-607
  prefs: []
  type: TYPE_TB
  zh: '| 度 | 百分度 | 弧度 | 转角 |'
- en: '| --- | --- | --- | --- |'
  id: totrans-608
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- en: '| `0deg` | `0grad` | `0rad` | `0turn` |'
  id: totrans-609
  prefs: []
  type: TYPE_TB
  zh: '| `0deg` | `0grad` | `0rad` | `0turn` |'
- en: '| `45deg` | `50grad` | `0.785rad` | `0.125turn` |'
  id: totrans-610
  prefs: []
  type: TYPE_TB
  zh: '| `45deg` | `50grad` | `0.785rad` | `0.125turn` |'
- en: '| `90deg` | `100grad` | `1.571rad` | `0.25turn` |'
  id: totrans-611
  prefs: []
  type: TYPE_TB
  zh: '| `90deg` | `100grad` | `1.571rad` | `0.25turn` |'
- en: '| `180deg` | `200grad` | `3.142rad` | `0.5turn` |'
  id: totrans-612
  prefs: []
  type: TYPE_TB
  zh: '| `180deg` | `200grad` | `3.142rad` | `0.5turn` |'
- en: '| `270deg` | `300grad` | `4.712rad` | `0.75turn` |'
  id: totrans-613
  prefs: []
  type: TYPE_TB
  zh: '| `270deg` | `300grad` | `4.712rad` | `0.75turn` |'
- en: '| `360deg` | `400grad` | `6.283rad` | `1turn` |'
  id: totrans-614
  prefs: []
  type: TYPE_TB
  zh: '| `360deg` | `400grad` | `6.283rad` | `1turn` |'
- en: Time and Frequency
  id: totrans-615
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间和频率
- en: 'When a property needs to express a period of time, the value is represented
    as <*`time`*> and is a <*`number`*> followed by either `s` (seconds) or `ms` (milliseconds.)
    Time values are most often used in transitions and animations, either to define
    durations or delays. The following two declarations will have exactly the same
    result:'
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性需要表达时间段时，该值表示为<*`time`*>，是一个<*`number`*>后跟`s`（秒）或`ms`（毫秒）。时间值通常用于过渡和动画中，用于定义持续时间或延迟。以下两个声明将完全产生相同的结果：
- en: '[PRE73]'
  id: totrans-617
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Time values are also used in aural CSS, again to define durations or delays,
    but support for aural CSS is extremely limited as of this writing.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 时间值也用于声音 CSS 中，用于定义持续时间或延迟，但截至目前，对声音 CSS 的支持非常有限。
- en: 'Another value type historically used in aural CSS is <*`frequency`*>, which
    is a <*`number`*> followed by either `Hz` (hertz) or `kHz` (kilohertz). As usual,
    the unit identifiers are case-insensitive, so `Hz` and `hz` are equivalent. The
    following two declarations will have exactly the same result:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 声音 CSS 中历史上使用的另一种值类型是<*`frequency`*>，它是一个<*`number`*>后跟`Hz`（赫兹）或`kHz`（千赫）。与往常一样，单位标识符大小写不敏感，所以`Hz`和`hz`是等效的。以下两个声明将完全产生相同的结果：
- en: '[PRE74]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Unlike with length values, for time and frequency values the unit type is *always*
    required, even when the value is `0s` or `0hz`.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 与长度值不同，对于时间和频率值，单位类型*始终*是必需的，即使值为`0s`或`0hz`。
- en: Ratios
  id: totrans-622
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比率
- en: When you need to express a ratio of two numbers, you use a <*`ratio`*> value.
    These values are represented as two positive <*`number`*> values separated by
    a forward slash (`/`), plus optional whitespace.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要表示两个数字的比率时，你使用一个<*`ratio`*>值。这些值表示为两个正<*`number`*>值，它们用斜杠(`/`)分隔，可以带有可选的空白。
- en: The first integer refers to the width (inline size) of an element, and the second
    to the height (block size). Thus, to express a height-to-width ratio of 16 to
    9, you can write `16/9` or `16 / 9`.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个整数指的是元素的宽度（内联尺寸），第二个指的是高度（块尺寸）。因此，要表示高宽比为16比9，你可以写`16/9`或`16 / 9`。
- en: As of late 2022, there is no facility to express a ratio as a single real number
    (e.g., `1.777` instead of `16/9`), nor to use a colon separator instead of a forward
    slash (e.g., `16:9`).
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2022年末，还没有方法将比率表达为单个实数（例如，`1.777`代替`16/9`），也没有使用冒号分隔符而不是斜杠（例如，`16:9`）的设施。
- en: Position
  id: totrans-626
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位置
- en: 'You use a *position value*, represented as <*`position`*>, to specify the placement
    of an origin image in a background area. Its syntactical structure is rather complicated:'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用一个*位置值*，表示为<*`position`*>，来指定背景区域中原始图像的放置位置。它的语法结构相当复杂：
- en: '[PRE75]'
  id: totrans-628
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: That might seem a little nutty, but it’s all down to the subtly complex patterns
    that this value type has to allow.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来有点疯狂，但这一值类型要允许的微妙复杂模式就是这样。
- en: If you declare only one value, such as `left` or `25%`, the second value is
    set to `center`. Thus, `left` is the same as `left center`, and `25%` is the same
    as `25% center`.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 如果只声明一个值，如`left`或`25%`，第二个值被设为`center`。因此，`left`等同于`left center`，`25%`等同于`25%
    center`。
- en: If you declare two values (either implicitly, as in the previous example, or
    explicitly), and the first one is a <*`length`*> or <*`percentage`*>, then it
    is *always* considered to be the horizontal value. Therefore, given `25% 35px`,
    the `25%` is a horizontal distance and the `35px` is a vertical distance. If you
    swap them to say `35px 25%`, then `35px` is horizontal and `25%` is vertical.
    If you write `25% left` or `35px right`, the entire value is invalid because you
    have supplied two horizontal distances and no vertical distance. (Similarly, a
    value of `right left` or `top bottom` is invalid and will be ignored.) On the
    other hand, if you write `left 25%` or `right 35px`, there is no problem because
    you’ve given a horizontal distance (with the keyword) and a vertical distance
    (with the percentage or length).
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声明两个值（无论是隐式地，如前面的示例中，还是显式地），并且第一个是<*`length`*>或<*`percentage`*>，则始终视为水平值。因此，给定`25%
    35px`，`25%`是水平距离，`35px`是垂直距离。如果你交换它们变成`35px 25%`，那么`35px`是水平的，`25%`是垂直的。如果你写`25%
    left`或`35px right`，整个值都是无效的，因为你提供了两个水平距离而没有垂直距离。（类似地，`right left`或`top bottom`的值是无效的并将被忽略。）另一方面，如果你写`left
    25%`或`right 35px`，那就没有问题，因为你给出了一个水平距离（用关键字）和一个垂直距离（用百分比或长度）。
- en: If you declare four values (we’ll deal with three in just a moment), you must
    have two lengths or percentages, each of which is preceded by a keyword. In this
    case, each length or percentage specifies an offset distance, and each keyword
    defines the edge from which the offset is calculated. Thus, `right 10px bottom
    30px` means an offset of 10 pixels to the left of the right edge, and an offset
    of 30 pixels up from the bottom edge. Similarly, `top 50% left 35px` means a 50%
    offset from the top and a 35-pixels-to-the-right offset from the left.
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 如果声明了四个值（我们稍后处理三个），必须有两个长度或百分比，每个之前都有一个关键字。在这种情况下，每个长度或百分比指定一个偏移距离，每个关键字定义了偏移量计算的边缘。因此，`right
    10px bottom 30px`意味着距离右边缘左侧10像素，距离底边缘上方30像素的偏移量。类似地，`top 50% left 35px`意味着距离顶部50%的偏移量和距离左边缘右侧35像素的偏移量。
- en: You can declare only three position values with the `background-position` property.
    If you declare three values, the rules are the same as for four, except the fourth
    offset is set to be 0 (no offset). Thus `right 20px top` is the same as `right
    20px top 0`.
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`background-position`属性时，只能声明三个位置值。如果声明了三个值，则规则与四个值相同，只是第四个偏移量被设置为0（无偏移）。因此，`right
    20px top`与`right 20px top 0`相同。
- en: Custom Properties
  id: totrans-634
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义属性
- en: If you’ve used a preprocessor like Less or Sass, you’ve probably created variables
    to hold values. CSS itself has this capability as well. The technical term for
    this is *custom properties*, even though what these really do is create something
    like variables in your CSS.
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用过Less或Sass等预处理器，可能已经创建了用于保存值的变量。CSS本身也具有这种能力。这个技术术语称为*自定义属性*，尽管它们实际上创建的是类似于CSS中的变量。
- en: 'Here’s a basic example, with the result shown in [Figure 5-18](#val_css4_custom-values)
    (though color won’t be visible in the printed version):'
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个基本的示例，结果显示在[图5-18](#val_css4_custom-values)中（尽管颜色在打印版本中看不到）。
- en: '[PRE76]'
  id: totrans-637
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '![css5 0518](assets/css5_0518.png)'
  id: totrans-638
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0518](assets/css5_0518.png)'
- en: Figure 5-18\. Using custom values to color headings
  id: totrans-639
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-18\. 使用自定义值给标题上色
- en: 'There are two things to absorb here. The first is the definition of the custom
    values `--base-color` and `--highlight-color`. These are not some sort of special
    color types. They’re just names that we picked to describe what the values contain.
    We could just as easily have said this:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两件事需要吸收。第一是自定义值`--base-color`和`--highlight-color`的定义。这些并不是某种特殊的颜色类型。它们只是我们选定的名称，用来描述值的内容。我们也可以说成这样：
- en: '[PRE77]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You probably shouldn’t do that sort of thing, unless you’re literally defining
    colors that specifically correspond to people named Alison and David. (Perhaps
    on an “About Our Team” page.) It’s always better to define custom identifiers
    that are self-documenting—things like `main-color` or `accent-color` or `brand-font-face`.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能不应该做这种事情，除非你确实在定义与名为Alison和David的人名特定对应的颜色（也许在“关于我们的团队”页面上）。最好定义自文档化的自定义标识符，如`main-color`或`accent-color`或`brand-font-face`。
- en: The important point is that any custom identifier of this type begins with *two*
    hyphens (`--`). It can then be invoked later by using a `var()` value type. Note
    that these names are case-sensitive, so `--main-color` and `--Main-color` are
    completely separate identifiers.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是，这类自定义标识符始于*两个*连字符（`--`）。稍后可以通过`var()`值类型调用它们。请注意，这些名称区分大小写，因此`--main-color`和`--Main-color`是完全独立的标识符。
- en: 'These custom identifiers are often referred to as *CSS variables*, which explains
    the `var()` pattern. An interesting feature of custom properties is their ability
    to scope themselves to a given portion of the DOM. If that sentence made any sense
    to you, it probably gave a little thrill. If not, here’s an example to illustrate
    scoping, with the result shown in [Figure 5-19](#val_css4_custom-value-scoping):'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 这些自定义标识符通常称为*CSS变量*，这解释了`var()`模式。自定义属性的一个有趣特性是能够将自身限定到DOM的特定部分。如果这句话让你有点明白，那可能会让你感到一丝兴奋。如果不明白，下面有一个示例来说明作用域，结果显示在[图5-19](#val_css4_custom-value-scoping)中：
- en: '[PRE78]'
  id: totrans-645
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '![css5 0519](assets/css5_0519.png)'
  id: totrans-647
  prefs: []
  type: TYPE_IMG
  zh: '![css5 0519](assets/css5_0519.png)'
- en: Figure 5-19\. Scoping custom values to certain contexts
  id: totrans-648
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
  zh: 图5-19\. 将自定义值限定到特定上下文
- en: Notice that the headings are a dark gray outside the `<aside>` element and a
    light gray inside. That’s because the variable `--base-color` was updated for
    `<aside>` elements. The new custom value applies to any `<h1>` inside an `<aside>`
    element.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，标题在`<aside>`元素外部是深灰色，在内部是浅灰色。这是因为`--base-color`变量已经更新为`<aside>`元素的标题。新的自定义值适用于`<aside>`元素内的任何`<h1>`。
- en: 'A great many patterns are possible with CSS variables, even if they are confined
    to value replacement. Here’s an example suggested by Chriztian Steinmeier combining
    variables with the `calc()` function to create a regular set of indents for unordered
    lists:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 即使限制为值替换，CSS 变量也可以产生很多模式。这里是由 Chriztian Steinmeier 提出的一个示例，将变量与 `calc()` 函数结合起来创建无序列表的常规缩进集合：
- en: '[PRE80]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This particular example is basically the same as writing the following:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特定的例子基本上和写下面这个是一样的：
- en: '[PRE81]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: The difference is that with variables, it’s simple to update the `--gutter`
    multiplier in one place and have everything adjust automatically, rather than
    having to retype three values and make sure all the math is correct.
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 不同之处在于，使用变量时，可以在一个地方简单地更新 `--gutter` 的乘数，并使所有内容自动调整，而不必重新输入三个值并确保所有数学计算都是正确的。
- en: Custom Property Fallbacks
  id: totrans-655
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义属性回退
- en: 'When you’re setting a value by using `var()`, you can specify a fallback value.
    For example, you could say that if a custom property isn’t defined, you want a
    regular value used instead, like so:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 `var()` 设置一个值时，你可以指定一个回退值。例如，你可以说，如果一个自定义属性没有定义，你希望使用一个常规值，如下所示：
- en: '[PRE82]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Given that, if `--list-indent` isn’t defined, is determined to be invalid, or
    is explicitly set to `initial`, `2em` will be used instead. You get just the one
    fallback, and it can’t be another custom property name.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 鉴于此，如果 `--list-indent` 没有定义，被确定为无效，或者被明确设置为 `initial`，将使用 `2em` 代替。你只会得到一个回退值，并且不能是另一个自定义属性名称。
- en: 'That said, it *can* be another `var()` expression, and that nested `var()`
    can contain another `var()` as its fallback, and so on to infinity. So let’s say
    you’re using a pattern library that defines colors for various interface elements.
    If those aren’t available for some reason, you could fall back to a custom property
    value defined by your basic site stylesheet. Then, if that’s also not available,
    you could fall back to a plain color value. It would look something like this:'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，它 *可以* 是另一个 `var()` 表达式，而且嵌套的 `var()` 可能包含另一个 `var()` 作为其回退，依此类推。所以，假设你使用了一个定义了各种界面元素颜色的模式库。如果由于某种原因这些颜色不可用，你可以回退到基本站点样式表定义的自定义属性值。然后，如果这个值也不可用，你可以回退到一个普通的颜色值。它看起来像这样：
- en: '[PRE83]'
  id: totrans-660
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: The thing to watch out for here is that if you manage to create an invalid value,
    the whole thing gets blown up and the value is either inherited or set to its
    initial value, depending on whether the property in question is usually inherited
    or not, as if it were set to `unset` (see [“unset”](#unset)).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，如果你设法创建了一个无效的值，整个东西都会被炸掉，值要么被继承，要么被设置为它的初始值，具体取决于属性通常是继承的还是不继承的，就像被设置为
    `unset` 一样（参见 [“unset”](#unset)）。
- en: 'Suppose we wrote the following invalid `var()` values:'
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们写了以下无效的 `var()` 值：
- en: '[PRE84]'
  id: totrans-663
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: In the first case, the fallback is `--base-color, gray` as a single string,
    not something that’s parsed, so it’s invalid. Similarly, in the second case, the
    fallback `--left-indent` was never declared. In either case, if the first custom
    property is valid, the invalid fallback doesn’t matter, because the browser never
    gets to it. But if, say, `--list-indent` doesn’t have a value, the browser will
    go to the fallback, and here that’s invalid. So what happens next?
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，回退是 `--base-color, gray` 作为单个字符串，而不是一个被解析的东西，因此是无效的。类似地，在第二种情况下，回退 `--left-indent`
    从未声明过。无论哪种情况，如果第一个自定义属性有效，无效的回退就无关紧要，因为浏览器永远不会到达它。但是，如果，比如说，`--list-indent` 没有值，浏览器将会转向回退，这里是无效的。那么接下来会发生什么呢？
- en: For the color, since the property `color` is inherited, the list items will
    inherit their color from their parent, almost certainly an `<ol>` or `<ul>` element.
    If the parent’s `color` value is `fuchsia`, the list items will be fuchsia. For
    the left margin, the property `margin-left` is not inherited, so the left margins
    of the list items will be set to the initial value of `margin-left`, which is
    `0`. So the list items will have no left margin.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 对于颜色，因为属性 `color` 是继承的，列表项将从它们的父元素（几乎肯定是 `<ol>` 或 `<ul>` 元素）继承它们的颜色。如果父元素的 `color`
    值是 `fuchsia`，那么列表项将是紫红色的。对于左边距，属性 `margin-left` 不是继承的，所以列表项的左边距将被设置为 `margin-left`
    的初始值，即 `0`。因此，列表项将没有左边距。
- en: 'This also happens if you try to apply a value to a property that can’t accept
    those kinds of values. Consider the following:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你试图将一个不能接受这些类型值的值应用于一个属性，也会发生这种情况。考虑以下例子：
- en: '[PRE85]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Here, everything looks fine at first glance, except the `color` property is
    being given a length value, and the `margin-left` property is being given a color
    value. As a result, the fallbacks of `gray` and `2em` are not used. This is because
    the `var()` syntax is valid, so the result is the same as if we declared `color:
    5vw` and `margin-left: hsl(23, 25%, 50%)`, both of which are tossed out as invalid.'
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，乍看之下一切看起来都很好，只是 `color` 属性被赋予了一个长度值，而 `margin-left` 属性被赋予了一个颜色值。因此，`gray`
    和 `2em` 的回退值没有被使用。这是因为 `var()` 语法是有效的，所以结果与我们声明 `color: 5vw` 和 `margin-left: hsl(23,
    25%, 50%)` 相同，这两者都被视为无效而被丢弃。'
- en: 'This means the outcome will be the same as we saw before: the list items will
    inherit the color value from their parents, and their left margins will be set
    to the initial value of 0, just as if the given values were `unset`.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着结果与之前看到的相同：列表项将继承其父元素的颜色值，并且它们的左边距将被设置为初始值 0，就好像给定的值是 `unset` 一样。
- en: Summary
  id: totrans-670
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: As you’ve seen, CSS provides a wide range of value and unit types. These units
    can have advantages and drawbacks, depending on the circumstances in which they’re
    used. You’ve already seen some of those circumstances, and their nuances will
    be discussed throughout the rest of the book, as appropriate.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，CSS 提供了各种数值和单位类型。这些单位根据使用的具体情况可能有优势和缺点。你已经看到了一些情况，这些微妙之处将在本书的其余部分中适当地讨论。
