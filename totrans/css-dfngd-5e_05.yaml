- en: Chapter 5\. Values and Units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll tackle features that are the basis for almost everything
    you can do with CSS: the units that affect the colors, distances, and sizes of
    a whole host of properties, as well as the units that help define those values.
    Without units, you couldn’t declare that an image should have 10 pixels of blank
    space around it, or that a heading’s text should be a certain size. By understanding
    the concepts put forth here, you’ll be able to learn and use the rest of CSS much
    more quickly.'
  prefs: []
  type: TYPE_NORMAL
- en: Keywords, Strings, and Other Text Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Everything in a stylesheet is text, but certain value types directly represent
    strings of text as opposed to, say, numbers or colors. Included in this category
    are URLs and, interestingly enough, images.
  prefs: []
  type: TYPE_NORMAL
- en: Keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For those times when a value needs to be described with a word of some kind,
    CSS has *keywords*. A common example is the keyword `none`, which is distinct
    from `0` (zero). Thus, to remove the underline from links in an HTML document,
    you would write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, if you want to force underlines on the links, you would use the keyword
    `underline` instead of `none`.
  prefs: []
  type: TYPE_NORMAL
- en: If a property accepts keywords, its keywords will be defined only for the scope
    of that property. If two properties use the same word as a keyword, the behavior
    of the keyword for one property will not necessarily be shared with the other.
    As an example, `normal`, as defined for `letter-spacing`, means something very
    different from the `normal` defined for `font-style`.
  prefs: []
  type: TYPE_NORMAL
- en: Global keywords
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSS defines five *global* keywords that are accepted by every property in the
    specification: `inherit`, `initial`, `unset`, `revert`, and `revert-layer`.'
  prefs: []
  type: TYPE_NORMAL
- en: inherit
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The keyword `inherit` makes the value of a property on an element the same as
    the value of that property on its parent element. In other words, it forces inheritance
    to occur even in situations where it would not normally operate. In many cases,
    you don’t need to specify inheritance, since many properties inherit naturally.
    Nevertheless, `inherit` can still be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following styles and markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `<div>` itself will have a blue background and a white foreground, but the
    links will be styled according to the browser’s preference settings. They’ll most
    likely end up as blue text on a blue background, with white vertical bars between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could write a rule that explicitly sets the links in the toolbar to be
    white, but you can make things a little more robust by using `inherit`. You just
    add the following rule to the stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This will cause the links to use the inherited value of `color` in place of
    the user agent’s default styles.
  prefs: []
  type: TYPE_NORMAL
- en: Ordinarily, directly assigned styles override inherited styles, but `inherit`
    can undo that behavior. It might not always be a good idea—for example, here links
    might blend into surrounding text too much, and become a usability and accessibility
    concern—but it can be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can pull a property value down from a parent even if it wouldn’t
    happen normally. Take `border`, for example, which is (rightfully) not inherited.
    If you want a `<span>` to inherit the border of its parent, all you need is `span
    {border: inherit;}`. More likely, though, you just want the border on a `<span>`
    to use the same border color as its parent. In that case, `span {border-color:
    inherit;}` will do the trick.'
  prefs: []
  type: TYPE_NORMAL
- en: initial
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The keyword `initial` sets the value of a property to the defined initial value,
    which, in a way, means it “resets” the value. For example, the default value of
    `font-weight` is `normal`. Therefore, declaring `font-weight: initial` is the
    same as declaring `font-weight: normal`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This might seem a little bit silly until you consider that not all values have
    explicitly defined initial values. For example, the initial value for `color`
    “depends on user agent.” That’s not a funky keyword you should type! What it means
    is that the default value of `color` depends on things like the preference settings
    in a browser. While almost nobody changes the default text color setting from
    black, someone might set it to a dark gray or even a bright red. By declaring
    `color: initial;`, you’re telling the browser to set the color of the element
    to whatever the user’s default color is set to be.'
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of `initial` is that you can set a property back to its initial
    value without having to know that initial value. This can be especially useful
    when resetting a lot of properties all at once, either via JS or CSS.
  prefs: []
  type: TYPE_NORMAL
- en: unset
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The keyword `unset` acts as a universal stand-in for both `inherit` and `initial`.
    If the property is inherited, `unset` has the same effect as if `inherit` were
    used. If the property is *not* inherited, `unset` has the same effect as if `initial`
    were used. This makes `unset` useful for resetting a property by canceling out
    any other styles that might be applied to it.
  prefs: []
  type: TYPE_NORMAL
- en: revert
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The keyword `revert` sets the value of a property to the value the property
    would have had if no changes had been made by the current style origin. In effect,
    `revert` lets you say, “All property values for this element should be as if the
    author styles don’t exist, but user agent and user styles do exist.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, given the following basic example, `p` elements will be rendered as gray
    text with a transparent background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This does mean that any property whose value is inherited will be given the
    same value as that of its parent. The `revert` keyword is useful when you have
    a bunch of site-wide styles applying to an element, and you want to strip them
    all away so as to apply a set of one-off styles to just that element. Rather than
    having to override all those properties, you can revert them to defaults—and you
    can do it with a single property, `all`, which is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: revert-layer
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: If you’re using cascade layers (see [“Sorting by Cascade Layer”](ch04.html#sorting_by_layer))
    and want to “undo” whatever styles might be applied by the current layer, the
    `revert-layer` value is here to help. The difference here is that `revert-layer`
    effectively means, “All property values for this element should be as if the author
    styles *in the current cascade layer* don’t exist, but other author cascade layers
    (including the default), user agent, and user styles do exist.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, given the following, paragraphs with a `class` containing the word `example`
    will be rendered as red text on a yellow background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For the background, the browser looks at the assigned values in previous cascade
    layers and picks the one with the highest weight. Only one layer (`system`) sets
    a background color, so that’s what’s used instead of `lime`. The same is done
    for the foreground color, and since a color is assigned in the default layer,
    and the default layer overrides all explicitly created layers, `red` is used instead
    of `gray`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2023, only Firefox supports `revert-layer`, but we anticipate it
    being widely supported in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: The all Property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These global values are usable on all properties, but one special property
    accepts *only* the global keywords: `all`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `all` property is a stand-in for all properties *except* `direction`, `unicode-bidi`,
    and any custom properties (see [“Custom Properties”](#custom_properties)). Thus,
    if you declare `all: inherit` on an element, you’re saying that you want all properties
    except `direction`, `unicode-bidi`, and custom properties to inherit their values
    from the element’s parent. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You might think this causes the `<div>` element to inherit the values of `color`,
    `background`, and `font-weight` from the `<section>` element. And it does do that,
    yes—but it will *also* force inheritance of the values of *every single other
    property in CSS* (minus the two exceptions) from the `<section>` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maybe that’s what you want, in which case, great. But if you just want to inherit
    the property values you wrote out for the `<section>` element, the CSS would need
    to look more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Odds are that what you really want in these situations is `all: unset`, but
    your stylesheet may vary.'
  prefs: []
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A *string value* is an arbitrary sequence of characters wrapped in either single
    or double quotes, and is represented in value definitions with <*`string`*>. Here
    are two simple examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note that the quotes balance, which is to say that you always start and end
    with the same kind of quotes. Getting this wrong can lead to all kinds of parsing
    problems, since starting with one kind of quote and trying to end with the other
    means the string won’t actually be terminated. You could accidentally incorporate
    subsequent rules into the string that way!
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to put quote marks inside strings, that’s OK, as long as they’re
    either not the kind you used to enclose the string or are escaped using a backslash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the only acceptable string delimiters are `''` and `"`, sometimes
    called *straight quotes*. That means you can’t use *curly* or *smart* quotes to
    begin or end a string value. You can use them inside a string value, as in this
    code example, though, and they don’t have to be escaped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This requires that you use Unicode encoding (using the [Unicode standard](http://www.unicode.org/standard/standard.html))
    for your documents, but you should be doing that regardless.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have some reason to include a newline in your string value, you can
    do that by escaping the newline itself. CSS will then remove it, making things
    as if it had never been there. Thus, the following two string values are identical
    from a CSS point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, you actually want a string value that includes a newline
    character, use the Unicode reference `\A` where you want the newline to occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One-word, case-sensitive strings that should not be quoted are known as *identifiers*,
    represented in the CSS syntax as <*`ident`*> or <*`custom-ident`*>, depending
    on the specification and context. Identifiers are used as animation names, grid-line
    names, and counter names, among others. In addition, <*`dashed-ident`*> is used
    for custom properties. Rules for creating a custom identifier include not starting
    the word with a number, a double hyphen, or a single hyphen followed by a number.
    Other than that, really any character is valid, including emojis, but if you use
    certain characters, including a space or a backslash, you need to escape them
    with a backslash.
  prefs: []
  type: TYPE_NORMAL
- en: Identifiers themselves are words and are case-sensitive; thus, `myID` and `MyID`
    are, as far as CSS is concerned, completely distinct and unrelated to each other.
    If a property accepts both an identifier and one or more keywords, the author
    should take care to never define an identifier that is identical to a valid keyword,
    including the global keywords `initial`, `inherit`, `unset`, and `revert`. Using
    `none` is also a really bad idea.
  prefs: []
  type: TYPE_NORMAL
- en: URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve written web pages, you’re almost certainly familiar with uniform
    resource locators (URLs). Whenever you need to refer to one—as in the `@import`
    statement, which is used when importing an external stylesheet—here is the general
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This example defines an *absolute URL*. This URL will work no matter where
    (or rather, in what page) it’s found, because it defines an absolute location
    in web space. Let’s say that you have a server called *web.waffles.org*. On that
    server is a directory called *pix*, and in this directory is an image *waffle22.gif*.
    In this case, the absolute URL of that image would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This URL is valid no matter where it is written, whether the page containing
    it is located on the server *web.waffles.org* or *web.pancakes.com*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other type of URL is a *relative URL*, so named because it specifies a
    location that is relative to the document that uses it. If you’re referring to
    a relative location, such as a file in the same directory as your web page, the
    general format is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This works only if the image is on the same server as the page that contains
    the URL. For argument’s sake, assume that you have a web page located at *http://web.waffles.org/syrup.html*
    and that you want the image *waffle22.gif* to appear on this page. In that case,
    the URL would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This path works because the web browser knows it should start with the place
    it found the web document and then add the relative URL. In this case, the pathname
    *pix/waffle22.gif* added to the server name *http://web.waffles.org* equals *http://web.waffles.org/pix/waffle22.gif*.
    You can almost always use an absolute URL in place of a relative URL; it doesn’t
    matter which you use, as long as it defines a valid location.
  prefs: []
  type: TYPE_NORMAL
- en: In CSS, relative URLs are relative to the stylesheet itself, not to the HTML
    document that uses the stylesheet. For example, you may have an external stylesheet
    that imports another stylesheet. If you use a relative URL to import the second
    stylesheet, it must be relative to the first stylesheet. In fact, if you have
    a URL in any imported stylesheet, it needs to be relative to the imported stylesheet.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider an HTML document at *http://web.waffles.org/toppings/tips.html*,
    which has a `<link>` to the stylesheet *http://web.waffles.org/styles/basic.css*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the file *basic.css* is an `@import` statement referring to another
    stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This `@import` will cause the browser to look for the stylesheet at *http://web.waffles.org/styles/special/toppings.css*,
    not at *http://web.waffles.org/toppings/special/toppings.css*. If you have a stylesheet
    at the latter location, the `@import` in *basic.css* should read one of the two
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that there cannot be a space between the `url` and the opening parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: If the space is present, the entire declaration will be invalidated and thus
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, the CSS Working Group is planning to introduce a new function
    called `src()`, which will accept only strings and not unquoted URLs. This is
    meant to allow custom properties to be used inside `src()`, which will let authors
    define which file should be loaded based on the value of a custom property.
  prefs: []
  type: TYPE_NORMAL
- en: Images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An *image value* is a reference to an image, as you might have guessed. Its
    syntax representation is <*`image`*>.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the most basic level of support, which is to say the one every CSS engine
    on the planet would understand, an <*`image`*> value is a <*`url`*> value. In
    more modern user agents, <*`image`*> stands for one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: <*`url`*>
  prefs: []
  type: TYPE_NORMAL
- en: A URL identifier of an external resource—in this case, the URL of an image.
  prefs: []
  type: TYPE_NORMAL
- en: <*`gradient`*>
  prefs: []
  type: TYPE_NORMAL
- en: Refers to either a linear, radial, or conic gradient image, either singly or
    in a repeating pattern. Gradients are fairly complex and are covered in detail
    in [Chapter 9](ch09.html#gradients).
  prefs: []
  type: TYPE_NORMAL
- en: <*`image-set`*>
  prefs: []
  type: TYPE_NORMAL
- en: A set of images, chosen based on a set of conditions embedded into the value,
    which is defined as `image-set()` but is more widely recognized with the `-webkit-`
    prefix. For example, `-webkit-image-set()` could specify that a larger image be
    used for desktop layouts, whereas a smaller image (both in pixel size and file
    size) be used for a mobile design. This value is intended to at least approximate
    the behavior of the `srcset` attribute for `<picture>` elements. As of early 2023,
    `-webkit-image-set` is basically universally supported, with most browsers other
    than Safari also accepting `image-set()` (without the prefix).
  prefs: []
  type: TYPE_NORMAL
- en: <*`cross-fade`*>
  prefs: []
  type: TYPE_NORMAL
- en: Used to blend two (or more) images together, with a specific transparency given
    to each image. Use cases include blending two images together, blending an image
    with a gradient, and so on. As of early 2023, this is supported as `-webkit-cross-fade()`
    in Blink- and WebKit-based browsers, and not supported at all in the Firefox family,
    with or without the prefix.
  prefs: []
  type: TYPE_NORMAL
- en: There are also the `image()` and `element()` functions, but as of early 2023,
    neither is supported by any browser, except for a vendor-prefixed version of `element()`
    supported by Firefox. Finally, `paint()` refers to an image painted by CSS Houdini’s
    PaintWorklet. As of early 2023, this is supported in only a basic form by Blink-based
    browsers like Chrome.
  prefs: []
  type: TYPE_NORMAL
- en: Numbers and Percentages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Numbers and percentages serve as the foundation for many other values types.
    For example, font sizes can be defined using the `em` unit (covered later in this
    chapter) preceded by a number. But what kind of number? Understanding the types
    of numbers here will help you better grasp defining other value types later.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An *integer value* is about as simple as it gets: one or more numbers, optionally
    prefixed by a `+` or `–` (plus or minus) sign to indicate a positive or negative
    value. That’s it. Integer values are represented in value syntax as <*`integer`*>.
    Examples include `712`, `13`, `−42`, and `1066`.'
  prefs: []
  type: TYPE_NORMAL
- en: Some properties define a range of acceptable integer values. Integer values
    that fall outside a defined range are, by default, considered invalid and cause
    the entire declaration to be ignored. However, some properties define behavior
    that causes values outside the accepted range to be set to the accepted value
    closest to the declared value, known as *clamping*.
  prefs: []
  type: TYPE_NORMAL
- en: In cases (such as the property `z-index`) where there is no restricted range,
    user agents must support values up to ±1,073,741,824 (±2^(30)).
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *number value* is either an <*`integer`*> or a real number, which is to say
    an integer followed by a dot and then some number of following integers. Additionally,
    it can be prefixed by either `+` or `-` to indicate positive or negative values.
    Number values are represented in value syntax as <*`number`*>. Examples include
    `5`, `2.7183`, `−3.1416`, `6.2832`, and `1.0218e29` (scientific notation).
  prefs: []
  type: TYPE_NORMAL
- en: The reason a <*`number`*> can be an <*`integer`*> and yet they are separate
    value types is that some properties will accept only integers (e.g., `z-index`),
    whereas others will accept any real number (e.g., `flex-grow`).
  prefs: []
  type: TYPE_NORMAL
- en: 'As with integer values, number values may have limits imposed on them by a
    property definition; for example, `opacity` restricts its value to be any valid
    <*`number`*> in the range `0` to `1`, inclusive. Some properties define behavior
    that causes values outside the accepted range to be clamped to an acceptable value
    closest to the declared value; e.g., `opacity: 1.7` would be clamped to `opacity:
    1`. For those that do not, number values that fall outside a defined range are
    considered invalid and cause the entire declaration to be ignored.'
  prefs: []
  type: TYPE_NORMAL
- en: Percentages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *percentage value* is a <*`number`*> followed by a percentage sign (`%`),
    and is represented in value syntax as <*`percentage`*>. Examples include `50%`
    and `33.333%`. Percentage values are always relative to another value, which can
    be anything—the value of another property of the same element, a value inherited
    from the parent element, or a value of an ancestor element. Properties that accept
    percentage values will define any restrictions on the range of allowed percentage
    values, as well as the way in which the percentage is relatively calculated.
  prefs: []
  type: TYPE_NORMAL
- en: Fractions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A *fraction value* (or *flexible ratio*) is a <*`number`*> followed by the `fr`
    unit label. Thus, one fractional unit is `1fr`. The `fr` unit represents a fraction
    of the leftover space, if any, in a grid container.
  prefs: []
  type: TYPE_NORMAL
- en: As with all CSS dimensions, there is no space between the unit and the number.
    Fraction values are not lengths (nor are they compatible with <*`length`*> values,
    unlike some <*`percentage`*> values), so they cannot be used with other unit types
    in `calc()` functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Fraction values are mostly used in grid layout (see [Chapter 12](ch12.html#grid-layout)),
    but there are plans to use it in more contexts, such as the planned (as of early
    2023) `stripes()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Distances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many CSS properties, such as margins, depend on length measurements to properly
    display various page elements. It’s likely no surprise, then, CSS provides multiple
    ways to measure length.
  prefs: []
  type: TYPE_NORMAL
- en: All length units can be expressed as either positive or negative numbers followed
    by a label, although note that some properties will accept only positive numbers.
    You can also use real numbers—that is, numbers with decimal fractions, such as
    10.5 or 4.561.
  prefs: []
  type: TYPE_NORMAL
- en: All length units are followed by a short abbreviation that represents the actual
    unit of length being specified, such as `in` (inches) or `pt` (points). The only
    exception to this rule is a length of `0` (zero), which need not be followed by
    a unit when describing lengths.
  prefs: []
  type: TYPE_NORMAL
- en: 'These length units are divided into two types: *absolute length units* and
    *relative length units*.'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute Length Units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ll start with absolute units because they’re easiest to understand. The
    seven types of absolute units are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Inches* (`in`)'
  prefs: []
  type: TYPE_NORMAL
- en: As you might expect, this notation refers to the inches you’d find on a ruler
    in the US. (The fact that this unit is in the specification, even though almost
    the entire world uses the metric system, is an interesting insight into the pervasiveness
    of US interests on the internet—but let’s not get into virtual sociopolitical
    theory right now.)
  prefs: []
  type: TYPE_NORMAL
- en: '*Centimeters* (`cm`)'
  prefs: []
  type: TYPE_NORMAL
- en: Refers to the centimeters that you’d find on rulers the world over. There are
    2.54 centimeters to an inch, and one centimeter equals 0.394 inches.
  prefs: []
  type: TYPE_NORMAL
- en: '*Millimeters* (`mm`)'
  prefs: []
  type: TYPE_NORMAL
- en: For those Americans who are metric challenged, 10 millimeters are in 1 centimeter,
    so an inch equals 25.4 millimeters, and a millimeter equals 0.0394 inches.
  prefs: []
  type: TYPE_NORMAL
- en: '*Quarter-millimeters* (`Q`)'
  prefs: []
  type: TYPE_NORMAL
- en: There are 40 Q units in a centimeter; thus, setting an element to be 1/10 of
    a centimeter wide—which is also a millimeter wide—would mean a value of `4Q`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Points* (`pt`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Points are standard typographical measurements that have been used by printers
    and typesetters for decades and by word processing programs for many years. Traditionally,
    there are 72 points to an inch. Therefore the capital letters of text set to 12
    points should be one-sixth of an inch tall. For example, `p {font-size`: `18pt;}`
    is equivalent to `p {font-size`: `0.25in;}`.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Picas* (`pc`)'
  prefs: []
  type: TYPE_NORMAL
- en: 'A pica, which is another typographical term, is equivalent to 12 points, which
    means there are 6 picas to an inch. As just shown, the capital letters of text
    set to 1 pica should be one-sixth of an inch tall. For example, `p {font-size`:
    `1.5pc;}` would set text to the same size as the example declarations found in
    the definition of points.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Pixels* (`px`)'
  prefs: []
  type: TYPE_NORMAL
- en: A pixel is a small box onscreen, but CSS defines pixels more abstractly. In
    CSS terms, a pixel is defined to be the size required to yield 96 pixels per inch.
    Many user agents ignore this definition in favor of simply addressing the pixels
    on the screen. Scaling factors are brought into play when page zooming or printing,
    where an element `100px` wide can be rendered more than 100 device dots wide.
  prefs: []
  type: TYPE_NORMAL
- en: These units are really useful only if the browser knows all the details of the
    screen on which your page is displayed, the printer you’re using, or whatever
    other user agent might apply. On a web browser, display is affected by the size
    of the screen and the resolution to which the screen is set; there isn’t much
    that you, as the author, can do about these factors. If nothing else, measurements
    should be consistent in relation to each other—that is, a setting of `1.0in` should
    be twice as large as `0.5in`, as shown in [Figure 5-1](#setting_absolute-length_left_margins).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0501](assets/css5_0501.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-1\. Setting absolute-length left margins
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Let’s make the (fairly suspect) assumption that your computer knows enough
    about its display system to accurately reproduce real-world measurements. You
    could make sure every paragraph has a top margin of half an inch by declaring
    `p {margin-top`: `0.5in;}` in that case.'
  prefs: []
  type: TYPE_NORMAL
- en: Absolute units are much more useful in defining stylesheets for printed documents,
    where measuring things in terms of inches, points, and picas is common.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel lengths
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On the face of things, pixels are straightforward. If you look at a screen
    closely enough, you can see that it’s broken into a grid of tiny little boxes.
    Each box is a pixel. Say you define an element to be a certain number of pixels
    tall and wide, as in the following markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then it follows that the element will be that many screen elements tall and
    wide, as shown in [Figure 5-2](#using_pixel_lengths).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0502](assets/css5_0502.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-2\. Using pixel lengths
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The problem is, thanks to high-density displays like those found on mobile devices
    and modern laptops, the individual screen elements aren’t treated as pixels anymore.
    Instead, the pixels used in your CSS are translated into something that aligns
    with human expectations, which is covered in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel theory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In its discussion of pixels, the CSS specification recommends that, when a display’s
    resolution density is significantly different from 96 pixels per inch (ppi), user
    agents should scale pixel measurements to a reference pixel.
  prefs: []
  type: TYPE_NORMAL
- en: 'The [W3C](https://www.w3.org/TR/css-values-4/#reference-pixel) defines *reference
    pixel* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The visual angle of one pixel on a device with a device pixel density of 96dpi
    and a distance from the reader of an arm’s length. For a nominal arm’s length
    of 28 inches, the visual angle is therefore about 0.0213 degrees. For reading
    at arm’s length, 1px thus corresponds to about 0.26 mm (1/96 inch).
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: On most modern displays, the actual number of pixels per inch (ppi) is higher
    than 96—sometimes much higher. The Retina display on an iPhone 13, for example,
    is physically 326 ppi, and the display on the iPad Pro is physically 264 ppi.
    As long as a browser on one of those devices sets the reference pixel such that
    an element set to be `10px` tall appears to be 2.6 millimeters tall on the screen,
    the physical display density isn’t something you have to worry about, any more
    than having to worry about the number of dots per inch on a printout.
  prefs: []
  type: TYPE_NORMAL
- en: Resolution Units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some unit types are based on display resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Dots per inch* (`dpi`)'
  prefs: []
  type: TYPE_NORMAL
- en: The number of display dots per linear inch. This can refer to the dots on a
    paper printer’s output, the physical pixels on an LED screen or other device,
    or the elements in an e-ink display such as that used by a Kindle.
  prefs: []
  type: TYPE_NORMAL
- en: '*Dots per centimeter* (`dpcm`)'
  prefs: []
  type: TYPE_NORMAL
- en: Same as `dpi`, except the linear measure is 1 centimeter instead of 1 inch.
  prefs: []
  type: TYPE_NORMAL
- en: '*Dots per pixel unit* (`dppx`)'
  prefs: []
  type: TYPE_NORMAL
- en: The number of display dots per CSS `px` unit, with `1dppx` being equivalent
    to `96dpi` because CSS defines pixel units at that ratio. Just bear in mind that
    ratio could change in future versions of CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'These units are most often used in the context of media queries. As an example,
    an author can create a media block to be used only on displays that have higher
    than 500 dpi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, it’s important to remember that CSS pixels are *not* device resolution
    pixels. Text with `font-size: 16px` will be a relatively consistent size whether
    the device has 96 dpi or 470 dpi. While a reference pixel is defined to appear
    to be 1/96th of an inch in size, when a device has more than 96 dpi, the content
    will not look smaller. Zooming is created by expanding CSS pixels as much as is
    needed; an image will appear larger, but the image size doesn’t actually change:
    rather, the width of the screen, in terms of reference pixels, gets smaller.'
  prefs: []
  type: TYPE_NORMAL
- en: Relative Length Units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Relative units are so called because they are measured in relation to other
    things. The actual (or absolute) distance they measure can change because of factors
    beyond their control, such as screen resolution, the width of the viewing area,
    the user’s preference settings, and a whole host of other things. In addition,
    for some relative units, their size is almost always relative to the element that
    uses them and will thus change from element to element.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s consider the character-based length units, including `em`, `ex`,
    and `ch`, which are closely related. Two other font-relative units, `cap` and
    `ic`, are discussed later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The em unit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In CSS, `1em` is defined to be the value of `font-size` for a given font. If
    the `font-size` of an element is 14 pixels, then for that element, `1em` is equal
    to 14 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may suspect, this value can change from element to element. For example,
    let’s say you have an `<h1>` with a font size of 24 pixels, an `<h2>` element
    with a font size of 18 pixels, and a paragraph with a font size of 12 pixels.
    If you set the left margin of all three at `1em`, they will have left margins
    of 24 pixels, 18 pixels, and 12 pixels, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When setting the size of the font, on the other hand, the value of `em` is relative
    to the font size of the parent element, as illustrated in [Figure 5-3](#using_em_for_margins_and_font_sizing).
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0503](assets/css5_0503.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-3\. Using `em` for margins and font sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In theory, `1em` is equal to the width of a lowercase *m* in the font used—that’s
    where the name comes from, in fact. It’s an old typographer’s term. However, this
    is not assured in CSS.
  prefs: []
  type: TYPE_NORMAL
- en: The ex unit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `ex` unit refers to the height of a lowercase *x* in the font being used.
    Therefore, if two paragraphs use text that is 24 points in size, but each paragraph
    uses a different font, then the value of `ex` could be different for each paragraph.
    This is because different fonts have different heights for *x*, as you can see
    in [Figure 5-4](#varying_x-heights). Even though the examples use 24-point text—and
    therefore each example’s `em` value is 24 points—the x-height for each is different.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0504](assets/css5_0504.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-4\. Varying x heights
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: The ch unit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `ch` unit is broadly meant to represent *one character*. [CSS Values and
    Units Level 4](https://www.w3.org/TR/css-values-4/#ch) defines `ch` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to the advance measure of the “0” (ZERO, U+0030) glyph found in the font
    used to render it.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The term *advance measure* is a CSS-ism that corresponds to the term *advance
    width* in Western typography. CSS uses the term *measure* because some scripts
    are not right to left or left to right, but instead top to bottom or bottom to
    top, and so may have an advance height rather than an advance width.
  prefs: []
  type: TYPE_NORMAL
- en: Without getting into too many details, a character glyph’s advance width is
    the distance from the start of a character glyph to the start of the next. This
    generally corresponds to the width of the glyph itself plus any built-in spacing
    to the sides (although that built-in spacing can be either positive or negative).
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to demonstrate the `ch` unit is to run a bunch of zeros together
    and then set an image to have a width with the same number of `ch` units as the
    number of zeros, as shown in [Figure 5-5](#character-relative_sizing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Given a monospace font like Courier, all characters are by definition `1ch`
    wide. In any proportional face type, which is what the vast majority of Western
    typefaces are, characters may be wider or narrower than the 0 and so cannot be
    assumed to be exactly `1ch` wide.
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0505](assets/css5_0505.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-5\. Character-relative sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Other relative length units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have a few other relative length units to mention:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ic`'
  prefs: []
  type: TYPE_NORMAL
- en: The advance measure of 水 glyph (Chinese, Japanese, and Korean water ideograph,
    U+6C34) found in the first font that can render it. This is like `ch` in that
    it uses an advance measure, but defines a measure more useful for ideographic
    languages than the 0 character. If `ic` can’t be calculated for a given situation,
    it’s assumed to be equal to `1em`.
  prefs: []
  type: TYPE_NORMAL
- en: '`cap`'
  prefs: []
  type: TYPE_NORMAL
- en: The cap-height is approximately equal to the height of a capital Latin letter,
    even in fonts that do not contain Latin letters. If it can’t be calculated for
    a given situation, it’s assumed to be equal to the font’s ascent height.
  prefs: []
  type: TYPE_NORMAL
- en: '`lh`'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to the computed value of the `line-height` property of the element on
    which it is used.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of this writing, only Firefox supports `cap`, and only Chromium-based
    browsers support `lh`.
  prefs: []
  type: TYPE_NORMAL
- en: Root-Relative Length Units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the character-based length units discussed in the previous section have
    a corresponding root-relative value. A *root-relative value* is one that is calculated
    with respect to the root element of the document, and thus provides a uniform
    value no matter what context it’s used in. We will discuss the most widely supported
    such unit and then summarize the rest.
  prefs: []
  type: TYPE_NORMAL
- en: The rem unit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `rem` unit is calculated using the font size of the document’s root element.
    In HTML, that’s the `<html>` element. Thus, declaring any element to have `font-size:
    1rem;` sets it to have the same font-size value as the root element of the document.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, consider the following markup fragment. It will have the result
    shown in [Figure 5-6](#ems_versus_rems):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0506](assets/css5_0506.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-6\. Using the `em` unit (middle sentence) versus the `rem` unit (bottom)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In effect, `rem` acts as a reset for font size: no matter what relative font
    sizing has happened to the ancestors of an element, giving it `font-size: 1rem;`
    will put it right back where the root element is set. This will usually be the
    user’s default font size, unless you (or the user) have set the root element to
    a specific font size.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given this declaration, `1rem` will always be equivalent to `13px`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'However, given *this* declaration, `1rem` will always be equivalent to three-quarters
    the user’s default font size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this case, if the user’s default is 16 pixels, `1rem` will equal `12px`.
    If the user has set their default to 12 pixels—and yes, some people do this—then
    `1rem` will equal `9px`. If the default setting is 20 pixels, `1rem` equals `15px`.
    And so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are not restricted to the value `1rem`. Any real number can be used, just
    as with the `em` unit, so you can do fun things like set all of your headings
    to be multiples of the root element’s font size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`font-size: 1rem` is equivalent to `font-size: initial` as long as no font
    size is set for the root element.'
  prefs: []
  type: TYPE_NORMAL
- en: Other root-relative units
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned previously, `rem` is not the only root-relative unit defined by
    CSS. [Table 5-1](#root-relative_equivalents) summarizes the other root-relative
    units.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-1\. Root-relative equivalent units
  prefs: []
  type: TYPE_NORMAL
- en: '| Length | Root-relative unit | Relative to |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `em` | `rem` | Computed `font-size` |'
  prefs: []
  type: TYPE_TB
- en: '| `ex` | `rex` | Computed x-height |'
  prefs: []
  type: TYPE_TB
- en: '| `ch` | `rch` | Advance measure of the `0` character |'
  prefs: []
  type: TYPE_TB
- en: '| `cap` | `rcap` | Height of a Roman capital letter |'
  prefs: []
  type: TYPE_TB
- en: '| `ic` | `ric` | Advance measure of the 水 ideograph |'
  prefs: []
  type: TYPE_TB
- en: '| `lh` | `rlh` | Computed `line-height` |'
  prefs: []
  type: TYPE_TB
- en: Of all the root-relative units, only `rem` is supported as of late 2022, but
    it is supported by essentially all browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Viewport-Relative Units
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CSS provides six *viewport-relative size units*. These are calculated with
    respect to the size of the viewport—browser window, printable area, mobile device
    display, etc.:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Viewport width unit* (`vw`)'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to the viewport’s width divided by 100\. Therefore, if the viewport is
    937 pixels wide, `1vw` is equal to `9.37px`. If the viewport’s width changes (say,
    by dragging the browser window wider or narrower), the value of `vw` changes along
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Viewport height unit* (`vh`)'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to the viewport’s height divided by 100\. Therefore, if the viewport is
    650 pixels tall, `1vh` is equal to `6.5px`. If the viewport’s height changes (say,
    by dragging the browser window taller or shorter), the value of `vh` changes along
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Viewport block unit* (`vb`)'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to the size of the viewport along the block axis, divided by 100\. The
    block axis is explained in [Chapter 6](ch06.html#basic-visual-formatting). In
    top-to-bottom languages like English or Arabic, `vb` will be equal to `vh` by
    default.
  prefs: []
  type: TYPE_NORMAL
- en: '*Viewport inline unit* (`vi`)'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to the size of the viewport along the inline axis, divided by 100\. The
    inline axis is explained in [Chapter 6](ch06.html#basic-visual-formatting). In
    horizontally written languages like English or Arabic, `vi` will be equal to `vw`
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: '*Viewport minimum unit* (`vmin`)'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to 1/100th of the viewport’s width or height, whichever is *less*. Thus,
    given a viewport that is 937 pixels wide by 650 pixels tall, `1vmin` is equal
    to `6.5px`.
  prefs: []
  type: TYPE_NORMAL
- en: '*Viewport maximum unit* (`vmax`)'
  prefs: []
  type: TYPE_NORMAL
- en: Equal to 1/100th of the viewport’s width or height, whichever is *greater*.
    Thus, given a viewport that is 937 pixels wide by 650 pixels tall, `1vmax` is
    equal to `9.37px`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because these are length units like any other, they can be used anywhere a
    length unit is permitted. You can scale the font size of a heading in terms of
    the viewport height, for example, with something like `h1 {font-size: 10vh;}`.
    This sets the font size to be 1/10th the height of the viewport—a technique potentially
    useful for article titles and the like.'
  prefs: []
  type: TYPE_NORMAL
- en: These units can be particularly handy for creating full-viewport interfaces,
    such as those we expect to find on a mobile device, because the units allow elements
    to be sized compared to the viewport and not to any of the elements within the
    document tree. It’s thus very simple to fill up the entire viewport, or at least
    major portions of it, and not have to worry about the precise dimensions of the
    actual viewport in any particular case.
  prefs: []
  type: TYPE_NORMAL
- en: 'A basic example of viewport-relative sizing is illustrated in [Figure 5-7](#viewport-relative_sizing):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'An interesting (though perhaps not useful) fact about these units is that they
    aren’t bound to their own primary axis. Thus, for example, you can declare `width:
    25vh;` to make an element as wide as one-quarter the height of the viewport.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0507](assets/css5_0507.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-7\. Viewport-relative sizing
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Variants of these units accommodate the vagaries of viewports and how they
    can be sized, particularly on devices where the UI may expand and contract based
    on user input. These variants are based on four viewport types:'
  prefs: []
  type: TYPE_NORMAL
- en: Default
  prefs: []
  type: TYPE_NORMAL
- en: The default viewport size, as defined by the user agent (browser). This viewport
    type is expected to correspond to the units `vw`, `vh`, `vb`, `vi`, `vmin`, and
    `vmax`. The default viewport may correspond to one of the other viewport types;
    e.g., the default viewport could be the same as the large viewport, but that’s
    up to each browser to decide.
  prefs: []
  type: TYPE_NORMAL
- en: Large
  prefs: []
  type: TYPE_NORMAL
- en: The largest possible viewport after any user-agent interfaces are contracted
    to their fullest extent. For example, on a mobile device, the browser *chrome*
    (the browser’s address bar, navigation bar, and so on) may be minimized or hidden
    most of the time so that the maximum screen area can be used to show page content.
    This is the state described by the large viewport. If you want an element’s size
    to be determined by the full viewport area, even if that will lead to it being
    overlapped by the UI, the large-viewport units are the way to go. The units corresponding
    to this viewport type are `lvw`, `lvh`, `lvb`, `lvi`, `lvmin`, and `lvmax`.
  prefs: []
  type: TYPE_NORMAL
- en: Small
  prefs: []
  type: TYPE_NORMAL
- en: The smallest possible viewport after any user-agent interfaces are expanded
    to their fullest extent. In this state, the browser’s chrome takes up as much
    screen space as it possibly can, leaving a minimum space for the page content.
    If you want to be sure an element’s sizing will take into account any possible
    interface actions, use these units. The units corresponding to this viewport type
    are `svw`, `svh`, `svb`, `svi`, `svmin`, and `svmax`.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic
  prefs: []
  type: TYPE_NORMAL
- en: The area in which content is visible, which can change as the UI expands or
    contracts. As an example, consider how the browser interface can appear or disappear
    on mobile devices, depending on how the content is scrolled or where on the screen
    the user taps. If you want to set lengths based on the size of the viewport at
    every moment, regardless of how it changes, these are the units for you. The units
    corresponding to this viewport type are `dvw`, `dvh`, `dvb`, `dvi`, `dvmin`, and
    `dvmax`.
  prefs: []
  type: TYPE_NORMAL
- en: As of late 2022, scrollbars (if any) are ignored for the purposes of calculating
    all of the previous units. Thus, the calculated size of `svw` or `dvw` will *not*
    change if scrollbars appear or disappear, or at least shouldn’t.
  prefs: []
  type: TYPE_NORMAL
- en: Function Values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the more recent developments in CSS is an increase in the number of
    values that are effectively functions. These values can range from doing math
    calculations to clamping value ranges to pulling values out of HTML attributes.
    CSS has, in fact, a *lot* of these, listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`abs()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`acos()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`annotation()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`asin()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atan()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`atan2()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attr()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blur()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`brightness()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`calc()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`character-variant()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`circle()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clamp()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color-contrast()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color-mix()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`color()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`conic-gradient()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contrast()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cos()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`counter()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`counters()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cross-fade()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`device-cmyk()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`drop-shadow()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`element()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ellipse()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`env()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exp()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fit-content()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grayscale()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hsl()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hsla()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hue-rotate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hwb()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hypot()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image-set()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`image()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inset()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`invert()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lab()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lch()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`linear-gradient()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`log()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`matrix3d()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`max()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`min()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minmax()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mod()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oklab()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`oklch()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opacity()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ornaments()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paint()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`perspective()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`polygon()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pow()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`radial-gradient()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rem()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeat-conic-gradiant()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeating-linear-gradiant()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repeating-radial-gradient()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rgb()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rgba()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotate3d()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotateX()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotateY()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rotateZ()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`round()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`saturate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale3d()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scaleX()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scaleY()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scaleZ()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sepia()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sign()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sin()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skew()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skewX()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skewY()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqrt()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styleset()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stylistic()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`swash()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`symbols()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tan()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translate()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translate3d()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translateX()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translateY()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`translateZ()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`url()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That’s 97 different function values. We’ll cover some in the rest of this chapter.
    The rest are covered in other chapters, as appropriate for their topics (e.g.,
    the filter functions are described in [Chapter 20](ch20.html#filters-compositing)).
  prefs: []
  type: TYPE_NORMAL
- en: Calculation Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you need to do a little math, CSS provides a `calc()` value. Inside the
    parentheses, you can construct simple mathematical expressions. The permitted
    operators are `+` (addition), `-` (subtraction), `*` (multiplication), and `/`
    (division), as well as parentheses. These follow the traditional precedence order
    of parentheses, exponents, multiplication, division, addition, and subtraction
    (PEMDAS), although in this case it’s really just PMDAS since exponents are not
    permitted in `calc()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, suppose you want your paragraphs to have a width that’s 2 em
    less than 90% the width of their parent element. Here’s how you express that with
    `calc()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The `calc()` value can be used with any property that permits one of the following
    value types: <*`length`*>, <*`frequency`*>, <*`angle`*>, <*`time`*>, <*`percentage`*>,
    <*`number`*>, or <*`integer`*>. You can also use all these unit types within a
    `calc()` value, though CSS has some limitations to keep in mind.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic limitation is that `calc()` does basic type checking to make sure
    that units are, in effect, compatible. The checking works like this:'
  prefs: []
  type: TYPE_NORMAL
- en: To either side of a `+` or `–` sign, both values must have the same unit type,
    or be a <*`number`*> and <*`integer`*> (in which case, the result is a <*`number`*>).
    Thus, `5 + 2.7` is valid, and results in `7.7`. On the other hand, `5em + 2.7`
    is invalid, because one side has a length unit and the other does not. Note that
    `5em + 20px` *is* valid, because `em` and `px` are both length units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a `*`, one of the values involved must be a <*`number`*> (which, remember,
    includes integer values). So `2.5rem * 2` and `2 * 2.5rem` are both valid, and
    each results in `5rem`. On the flip side, `2.5rem * 2rem` is *not* valid, because
    the result would be `5rem²`, and length units cannot be area units.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a `/`, the value on the *right* side must be a <*`number`*>. If the left
    side is an <*`integer`*>, the result is a <*`number`*>. Otherwise, the result
    is of the unit type used on the left side. This means that `30em / 2.75` is valid,
    but `30 / 2.75em` is not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, any circumstance that yields division by zero is invalid. This
    is easiest to see in a case like `30px/0`, but there are other ways to get there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One more notable limitation is that whitespace is *required* on both sides of
    the `+` and `-` operators, while it is not for `*` and `/`. This was done to allow
    future development of `calc()` values to support keywords that contain hyphens
    (e.g., `max-content`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, it’s valid (and supported) to nest `calc()` functions inside each
    other. Thus you can say something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Beyond that, the CSS specification requires that user agents support a *minimum*
    of 20 terms inside any single `calc()` function, where a term is a number, percentage,
    or dimension (e.g., a length). If the number of terms somehow exceeds the user
    agent’s term limits, the entire function is treated as invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Maximum Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Calculation is nice, but sometimes you just want to make sure a property is
    set to one of a number of values, whichever is smallest. In those cases, the `min()`
    function value comes in very handy. Yes, this is confusing at first, but give
    us a minute and hopefully it will make sense.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to make sure that an element is never wider than a certain
    amount; say, an image should be one-quarter the width of the viewport or 200 pixels
    wide, whichever is *smaller*. This allows it to be constrained to 200 pixels of
    width on wide viewports, but take up to a quarter the width of smaller viewports.
    For that, you’d say the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The browser will compute the width of `25vw` and compare that to `200px`, and
    use whichever is smaller. If `200px` is smaller than 25% the width of the viewport,
    then `200px` will be used. Otherwise, the element will be 25% as wide as the viewport,
    which could easily be smaller than `1em`. Note that *smaller* in this case means
    closest to negative infinity, not closest to zero. Thus, if you compare two terms
    that compute to (say) `-1500px` and `-2px`, `min()` will pick `-1500px`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can nest `min()` inside `min()`, or throw a mathematical expression in
    there for one of the values, without having to wrap it in `calc()`. For that matter,
    you can put in `max()` and `clamp()`, which we haven’t even discussed yet. You
    can supply as many terms as you like: if you want to compare four ways of measuring
    something and then pick the minimum, just separate them with commas. Here’s a
    slightly contrived example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Whichever of those values is computed to be the minimum (closest to negative
    infinity) will be used, thus defining a maximum for the `width` value. The order
    you list them in doesn’t matter, since the minimum value will always be picked
    regardless of where it appears in the function.
  prefs: []
  type: TYPE_NORMAL
- en: In general, `min()` can be used in any property value that permits <*`length`*>,
    <*`frequency`*>, <*`angle`*>, <*`time`*>, <*`percentage`*>, <*`number`*>, or <*`integer`*>.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that setting a maximum value on font sizes is an accessibility concern.
    You should *never* set a maximum font size using pixels, because that would likely
    prevent text zooming by users. You probably shouldn’t use `min()` for font sizing
    in any case, but if you do, keep `px` lengths out of the values!
  prefs: []
  type: TYPE_NORMAL
- en: Minimum Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The mirror image of `min()` is `max()`, which can be used to set a minimum value
    for a property. It can appear in the same places and can be nested in the same
    ways as `min()`, and is generally just the same except that it picks the largest
    (closest to positive infinity) value from among the alternatives given.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, perhaps the top of a page’s design should be a minimum of 100
    pixels tall, but it can be taller if conditions permit. In that case, you could
    use something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Whichever of the values is largest will be used. For a desktop browser window,
    that would probably be `15vh`, unless the base size text is really enormous. For
    a handheld display, it’s more likely that `5rem` or `100px` will be the largest
    value. In effect, this sets a minimum size of 100 pixels tall, since getting either
    `15vh` or `5rem` below that value is easily possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that setting even a minimum value on font sizes can create an accessibility
    problem, since a too-small minimum is still too small. A good way to handle this
    is to always include `1rem` in your `max()` expressions for font sizes. Use something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you could not use `max()` for font sizing at all. It’s probably
    best left to box sizing and other such uses.
  prefs: []
  type: TYPE_NORMAL
- en: Clamping Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’ve already been thinking about ways to nest `min()` and `max()` to set
    upper and lower bounds on a value, there’s a way to not only do that, but set
    an “ideal” value as well: `clamp()`. This function value takes three parameters
    representing, in order, the minimum allowed value, preferred value, and maximum
    allowed value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider some text you want to be about 5% the height of the viewport,
    while keeping its minimum the base font size and its maximum three times the text
    around it. That would be expressed like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Given those styles and assuming the base font size is 16 pixels, as it is by
    default in most browsers, then the footer text will be equal to the base font
    size up to a viewport height of 800 pixels (16 divided by 0.02). If the viewport
    gets taller, the text will start to get bigger, unless doing so would make it
    bigger than `3em`. If the text ever gets to the same size as `3em`, it will stop
    growing. (This is fairly unlikely, but one never knows.)
  prefs: []
  type: TYPE_NORMAL
- en: If the maximum value of a `clamp()` is ever computed to be smaller than the
    minimum value, the maximum is ignored and the minimum value is used instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use `clamp()` anywhere you can use `min()` and `max()`, including nesting
    them inside each other. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This is basically the same as the previous example, except in this case the
    preferred value is either 2% the height of the viewport or 1.5 times the size
    of the parent element’s text, whichever is larger.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a few CSS properties, it’s possible to pull in the value of an HTML attribute
    defined for the element being styled. You do this with the `attr()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, with generated content, you can insert the value of any attribute.
    It looks something like this (don’t worry about understanding the exact syntax,
    which we’ll explore in [Chapter 16](ch16.html#lists-and-generated-content)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'That expression would prefix any paragraph that has an `id` attribute with
    the value of that `id`, enclosed in square brackets. Therefore, applying the previous
    style to the following paragraphs would have the result shown in [Figure 5-8](#inserting_attribute_values):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0508](assets/css5_0508.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-8\. Inserting attribute values
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: While `attr()` is supported in the `content` property value, it isn’t parsed.
    In other words, if the `attr()` returns an image URL from an attribute value,
    the generated content will be the URL written out as text, and not the image that
    lives at that URL. This is true as of late 2022, anyway; there are plans for changes
    such that `attr()` can be parsed (and also be used for all properties, not just
    `content`).
  prefs: []
  type: TYPE_NORMAL
- en: Color
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the first questions every starting web author asks is, “How do I set
    colors on my page?” Under HTML, you have two choices: you could use one of a large
    but limited number of colors with names, such as `red` or `purple`, or employ
    a vaguely cryptic method using hexadecimal codes. Both methods for describing
    colors remain in CSS, along with several—and, we think, more intuitive—methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Named Colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Over the years, CSS has added a set of 148 colors that are identified by human-readable
    names like `red` or `firebrickred`. CSS calls these, logically enough, *named
    colors*. In the early days, CSS used only the 16 basic color keywords defined
    in HTML 4.01:'
  prefs: []
  type: TYPE_NORMAL
- en: '`aqua`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gray`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navy`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`silver`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`black`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`green`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`olive`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`teal`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blue`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lime`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`purple`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`white`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fuchsia`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maroon`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`red`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yellow`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, let’s say you want all first-level headings to be maroon. The best declaration
    would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple enough, isn’t it? [Figure 5-9](#naming_colors) shows a few more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0509](assets/css5_0509.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-9\. Named colors
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: You’ve probably seen (and maybe even used) color names other than the ones listed
    earlier. For example, you could say
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: and get a light-green (but not exactly lime) color applied to `<h1>` elements.
  prefs: []
  type: TYPE_NORMAL
- en: The CSS color specification includes those original 16 named colors in a longer
    list of 148 color keywords. This extended list is based on the standard X11 RGB
    values that have been in use for decades and recognized by browsers for many years,
    with the addition of some color names from SVG (mostly involving variants of “gray”
    and “grey”) and a memorial color.
  prefs: []
  type: TYPE_NORMAL
- en: Color Keywords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CSS has two special keywords that can be used anywhere a color value is permitted:
    `transparent` and `currentcolor`.'
  prefs: []
  type: TYPE_NORMAL
- en: As its name suggests, `transparent` defines a completely transparent color.
    The CSS Color Module defines it to be equivalent to `rgb(0 0 0 / 0%)`, and that’s
    its computed value. This keyword is not often used to set text color, for example,
    but it is the default value for element background colors. It can also be used
    to define element borders that take up space but are not visible, and is often
    used when defining gradients—​all topics we’ll cover in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, `currentcolor` means “whatever the computed value of `color` is
    for this element.” Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The first declaration causes any `<main>` elements to have a foreground color
    of `gray`. The second declaration uses `currentcolor` to copy the computed value
    of `color`—in this case `gray`—and apply it to any borders the `<main>` elements
    might have. Incidentally, `currentcolor` is actually the default value for `border-color`,
    which we’ll cover in [Chapter 7](ch07.html#padding-borders-outlines-and-margins).
  prefs: []
  type: TYPE_NORMAL
- en: As with all the named colors, these color names are case-insensitive. We show
    `currentcolor` with mixed capitalization because it is generally written that
    way for legibility.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, CSS has more detailed and precise ways to specify colors. The advantage
    is that, with these methods, you can specify any color in the color spectrum,
    not just a limited list of named colors.
  prefs: []
  type: TYPE_NORMAL
- en: Colors by RGB and RGBa
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computers create colors by combining different levels of the primary colors
    red, green, and blue—a combination often referred to as *RGB color*. So, it makes
    sense that you should be able to specify your own combinations of these primary
    colors in CSS. That solution is a bit complex, but possible, and the payoffs are
    worth it because CSS has very few limits on which colors you can produce. You
    can produce color in this manner in four ways, detailed in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Functional RGB colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Two color value types use *functional RGB notation* as opposed to hexadecimal
    notation. The generic syntax for this type of color value is ``rgb(*`color`*)``,
    where *`color`* is expressed using a triplet of either percentages or numbers.
    The percentage values can be in the range `0%`–`100%`, and the integers can be
    in the range `0`–`255`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, to specify white and black, respectively, using percentage notation,
    the values would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the integer-triplet notation, the same colors would be represented as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: An important thing to remember is that you can’t mix integers and percentages
    in the same color value. Thus, `rgb(255,66.67%,50%)` would be invalid and thus
    ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In more recent browsers, the separating commas in RGB values can be replaced
    with simple whitespace. Thus, black can be represented as `rgb(0 0 0)` or `rgb(0%
    0% 0%)`. This is true of all the color values that allow commas that we’ll see
    throughout the chapter. Bear in mind that some of the newer color functions do
    not allow commas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume you want your `<h1>` elements to be a shade of red that lies between
    the values for red and maroon. The `red` value is equivalent to `rgb(100%,0%,0%)`,
    whereas `maroon` is equal to `(50%,0%,0%)`. To get a color between those two,
    you might try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes the red component of the color lighter than `maroon`, but darker
    than `red`. If, on the other hand, you want to create a pale-red color, you would
    raise the green and blue levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The closest equivalent color using integer-triplet notation is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The easiest way to visualize how these values correspond to color is to create
    a table of gray values. The result is shown in [Figure 5-10](#text_set_in_shades_of_gray):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0510](assets/css5_0510.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-10\. Text set in shades of gray
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Since we’re dealing in shades of gray, all three RGB values are the same in
    each statement. If any one were different from the others, a color hue would start
    to emerge. If, for example, `rgb(50%,50%,50%)` were modified to be `rgb(50%,50%,60%)`,
    the result would be a medium-dark color with just a hint of blue.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use fractional numbers in percentage notation. You might, for some
    reason, want to specify that a color be exactly 25.5% red, 40% green, and 98.6%
    blue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Values that fall outside the allowed range for each notation are *clipped*
    to the nearest range edge, meaning that a value that is greater than `100%` or
    less than `0%` will default to those allowed extremes. Thus, the following declarations
    would be treated as if they were the values indicated in the comments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversion between percentages and integers may seem arbitrary, but there’s
    no need to guess at the integer you want—there’s a simple formula for calculating
    them. If you know the percentages for each of the RGB levels you want, you need
    only apply them to the number 255 to get the resulting values. Let’s say you have
    a color of 25% red, 37.5% green, and 60% blue. Multiply each of these percentages
    by 255, and you get 63.75, 95.625, and 153\. Round these values to the nearest
    integers, and voilà: `rgb(64,96,153)`.'
  prefs: []
  type: TYPE_NORMAL
- en: If you already know the percentage values, there isn’t much point in converting
    them into integers. Integer notation is more useful for people who use programs
    such as Adobe Photoshop, which can display integer values in the Info dialog,
    or for those who are so familiar with the technical details of color generation
    that they normally think in values of 0–255.
  prefs: []
  type: TYPE_NORMAL
- en: RGBa colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RGB notations can include a fourth parameter defining the alphatransparency
    value. By adding an alpha value at the end of the RGB triplet, `rgb()` accepts
    a red-green-blue-alpha, or RGBa, value, with the alpha value being a measurent
    of opacity.
  prefs: []
  type: TYPE_NORMAL
- en: While the `rgb()` notation allows for three or four values, the alpha value
    must be present in the legacy `rgba()` function to be valid.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want an element’s text to be half-opaque white. That
    way, any background color behind the text would “shine through,” mixing with the
    half-transparent white. You could write one of the following two values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'To make a color completely transparent, you set the alpha value to `0`; to
    be completely opaque, the correct value is `1`. Thus `rgb(0,0,0)` and `rgba(0,0,0,1)`
    will yield precisely the same result (black). [Figure 5-11](#text_set_in_progressive_translucency)
    shows a series of paragraphs set in increasingly transparent black, which is the
    result of the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0512](assets/css5_0512.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-11\. Text set in progressive translucency
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Alpha values are always real numbers in the range `0` to `1`, or percentages
    in the range `0%` to `100%`. Any value outside that range will either be ignored
    or reset to the nearest valid alpha value.
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal RGB colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSS allows you to define a color using the same *hexadecimal color notation*
    so familiar to old-school HTML web authors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Computers have been using hex notation for quite some time now, and programmers
    are typically either trained in its use or pick it up through experience. Their
    familiarity with hexadecimal notation likely led to its use in setting colors
    in HTML. That practice was carried over to CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works: by stringing together three hexadecimal numbers in the
    range `00` through `FF`, you can set a color. The generic syntax for this notation
    is `#RRGGBB`. Note that there are no spaces, commas, or other separators between
    the three numbers.'
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal notation is mathematically equivalent to integer-pair notation.
    For example, `rgb(255,255,255)` is precisely equivalent to `#FFFFFF`, and `rgb(51,102,128)`
    is the same as `#336680`. Feel free to use whichever notation you prefer—it will
    be rendered identically by most user agents. If you have a calculator that converts
    between decimal and hexadecimal, making the jump from one to the other should
    be pretty simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'For hexadecimal numbers that are composed of three matched pairs of digits,
    CSS permits a shortened notation. The generic syntax of this notation is `#RGB`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the markup, each color value has only three digits. However,
    since hexadecimal numbers between `00` and `FF` need two digits each, and you
    have only three total digits, how does this method work?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is that the browser takes each digit and replicates it. Therefore,
    `#F00` is equivalent to `#FF0000`, `#6FA` would be the same as `#66FFAA`, and
    `#FFF` would come out `#FFFFFF`, which is the same as `white`. Not every color
    can be represented in this manner. Medium gray, for example, would be written
    in standard hexadecimal notation as `#808080`. This cannot be expressed in shorthand;
    the closest equivalent would be `#888`, which is the same as `#888888`.
  prefs: []
  type: TYPE_NORMAL
- en: Hexadecimal RGBa colors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hexadecimal notation can have a fourth hex value to represent the alpha channel
    value. The following rules style the series of paragraphs in [Figure 5-12](#text_set_in_progressive_translucency_redux),
    which are set in increasingly transparent black, just as you saw in the previous
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0512](assets/css5_0512.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-12\. Text set in progressive translucency, redux
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'As with non-alpha hexadecimal values, you can shorten a value composed of matched
    pairs to a four-digit value. Thus, a value of `#663399AA` can be written as `#639A`.
    If the value has any pairs that are not repetitive, the entire eight-digit value
    must be written out: `#663399CA` cannot be shortened to `#639CA`.'
  prefs: []
  type: TYPE_NORMAL
- en: HSL and HSLa Colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hue, saturation, and lightness (HSL) color notation is similar to hue, saturation,
    and brightness (HSB), the color system in image editing software like Photoshop,
    and just as intuitive. The hue is expressed as an angle value, saturation is a
    percentage value from 0% (no saturation) to 100% (full saturation), and lightness
    is a percentage value from 0% (completely dark) to 100% (completely light). If
    you’re intimately familiar with RGB, HSL may be confusing at first. (But then,
    RGB is confusing for people familiar with HSL.)
  prefs: []
  type: TYPE_NORMAL
- en: The *hue* angle is expressed in terms of a circle around which the full spectrum
    of colors progresses. It starts with red at 0 degrees and then proceeds through
    the rainbow until it comes to red again at 360 degrees. When the hue value is
    a unitless number, it is interpreted as degrees.
  prefs: []
  type: TYPE_NORMAL
- en: '*Saturation* measures the intensity of a color. A saturation of `0%` always
    yields a shade of gray, no matter what hue angle you have set, and a saturation
    of `100%` creates the most vivid possible shade of that hue (in the HSL color
    space) for a given lightness.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, *lightness* defines how dark or light the color appears. A lightness
    of `0%` is always black, regardless of the other hue and saturation values, just
    as a lightness of `100%` always yields white. Consider the results of the following
    styles, illustrated on the left side of [Figure 5-13](#varying_lightness).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember that in more recent browsers, the commas in `hsl()` values can be replaced
    with whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The gray you see on the left side isn’t just a function of the limitations
    of print: every one of those paragraphs is a shade of gray, because every color
    value has `0%` in the saturation (middle) position. The degree of lightness or
    darkness is set by the lightness (third) position. In all seven examples, the
    hue angle changes, and in none of them does it matter.'
  prefs: []
  type: TYPE_NORMAL
- en: '![css5 0513](assets/css5_0513.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-13\. Varying lightness and hues
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: But that’s only so long as the saturation remains at `0%`. If that value is
    raised to, say, `50%`, then the hue angle will become very important, because
    it will control what sort of color you see. Consider the same set of values that
    we saw before, but all set to `50%` saturation; this is illustrated on the right
    side of [Figure 5-13](#varying_lightness), although the color is not visible in
    the print version of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as RGB has a legacy RGBa counterpart, HSL has an HSLa counterpart. This
    is an HSL triplet followed by an alpha value in the range 0–1\. The following
    HSLa values are all black with varying shades of transparency, just as in [“Hexadecimal
    RGBa colors”](#hexadecimal_rgba_colors) (and illustrated in [Figure 5-12](#text_set_in_progressive_translucency_redux)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Colors with HWB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Colors can also be represented in terms of their *hue*, *white* level, and *black*
    level by using the `hwb()` functional value. This function value accepts hue values
    expressed as an angle value. After the hue angle, instead of lightness and saturation,
    whiteness and blackness values are specified as percentages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike HSL, however, there is no legacy `hwba()` function. Instead, the value
    syntax for `hwb()` allows an opacity to be defined after the HWB values, separated
    from them by a forward slash (`/`). The opacity can be expressed either as a percentage
    or as a real value from 0 to 1, inclusive. Also unlike HSL, commas are not supported:
    the HWB values can only be separated by whitespace.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of using HWB notation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Lab Colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Historically, all CSS colors were defined in the sRGB color space, which encompassed
    more colors than older display monitors could represent. Modern displays, on the
    other hand, can handle about 150% of the sRGB color space, which still isn’t the
    full range of color humans can perceive, but it’s a lot closer.
  prefs: []
  type: TYPE_NORMAL
- en: In 1931, the *Commission Internationale de l’Éclairage* (International Commission
    on Illumination, or CIE) defined a scientific system for defining colors created
    via light, as opposed to those created with paint or dyes. Now, almost a century
    later, CSS has brought the work of the CIE into its repertoire.
  prefs: []
  type: TYPE_NORMAL
- en: 'It does this using the `lab()` function value to express color in the CIE L*a*b*
    (hereafter shortened as *Lab*) color space. Lab is designed to represent the entire
    range of color that humans can see. The `lab()` function accepts three to four
    parameters: `lab(`*`L`* *`a`* *`b`* / *`A`*`)`. Similar to HWB, the parameters
    must be space-separated (no commas allowed) and a forward slash (`/`) precedes
    the alpha value, if provided.'
  prefs: []
  type: TYPE_NORMAL
- en: The *`L`* (Lightness) component specifies the CIE lightness, and is a <*`percentage`*>
    from `0%` representing black to `100%` representing white, or a <*`number`*> from
    `0` to `1`. The second component, *`a`*, is the distance along the a-axis in the
    Lab color space. This axis runs from a purplish red in the positive direction
    to a shade of green in the negative direction. The third component, *`b`*, is
    the distance along the b-axis in the Lab color space. This axis runs from a yellow
    in the positive direction to a blue-violet in the negative direction.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth, optional parameter is the opacity, with a value from 0 to 1 inclusive,
    or 0% to 100% inclusive. If omitted, the opacity defaults to 1 (100%), or full
    opacity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of Lab color expressed in CSS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The main reason to bring Lab (and LCH, which we’ll discuss in a moment) colors
    into CSS is that they are systematically designed to be *perceptually uniform*:
    color values that share a given coordinate will seem consistent in terms of that
    coordinate. Two colors with different hues but the same lightness will appear
    to have similar lightnesses. Two colors with the same hue but different lightnesses
    will appear to be shades of a single hue. This is often not the case with RGB
    and HSL values, so Lab and LCH represent a big improvement.'
  prefs: []
  type: TYPE_NORMAL
- en: They’re also defined to be device independent, so you should be able to specify
    colors in these color spaces and get a visually consistent result from one device
    to another.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, only WebKit supports `lab()`.
  prefs: []
  type: TYPE_NORMAL
- en: LCH Colors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Lightness Chroma Hue (LCH)* is a version of Lab designed to represent the
    entire spectrum of human vision. It does this using a different notation: `lch(`*`L`*
    *`C`* *`H`* / *`A`*`)`. The main difference is that *`C`* and *`H`* are polar
    coordinates, rather than linear values along color axes.'
  prefs: []
  type: TYPE_NORMAL
- en: The *`L`* (Lightness) component is the same as the CIE Lightness, and is a *<percentage>*
    from `0%` representing black to `100%` representing white.
  prefs: []
  type: TYPE_NORMAL
- en: The *`C`* (Chroma amount) component roughly represents the amount of color.
    Its minimum value is `0`, and no maximum is defined. Negative `C` values are clamped
    to 0.
  prefs: []
  type: TYPE_NORMAL
- en: The *`H`* (Hue angle) component is essentially a combination of the *`a`* and
    *`b`* values in `lab()`. The value `0` points along the positive a-axis (toward
    purplish red), `90` points along the positive b-axis (toward mustard yellow),
    `180` points along the negative a-axis (toward greenish cyan), and `270` points
    along the negative b-axis (toward sky blue). This component loosely corresponds
    to HSL’s Hue, but the hue angles differ.
  prefs: []
  type: TYPE_NORMAL
- en: 'The optional *`A`* (alpha) component can be a <*`number`*> from 0 to 1, or
    else a <*`percentage`*>, where the number 1 corresponds to 100% (full opacity).
    If present, it is preceded by a forward slash (`/`). Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: To give an example of the capabilities of LCH, `lch(52% 132 8)` is a very bright
    magenta equivalent to `rgb(118.23% -46.78% 40.48%)`. Notice the large red value
    and the negative green value, which places the color outside the sRGB color space.
    If you supplied that RGB value to a browser, it would clamp the value to `rgb(100%
    0% 40.48%)`. This is within the sRGB color space, but it is visually quite distinct
    from the color that is defined by `lch(52% 132 8)`.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, only Safari supports `lch()` values.
  prefs: []
  type: TYPE_NORMAL
- en: Oklab and Oklch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Improved versions of Lab and LCH, called *Oklab* and *Oklch*, will be supported
    by CSS via the `oklab()` and `oklch()` functional values. Oklab was developed
    by taking a large set of visually similar colors and performing a numerical optimization
    on them, yielding a color space with better hue linearity and uniformity, and
    better chroma uniformity, than the CIE color spaces. Oklch is a polar-coordinate
    version of Oklab, just as LCH is to Lab.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this improved uniformity, Oklab and Oklch will be the default for
    color-interpolation calculations in CSS going forward. However, as of late 2022,
    only Safari supports the `oklab()` and `oklch()` CSS functional values.
  prefs: []
  type: TYPE_NORMAL
- en: Using color()
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `color()` function value allows a color to be specified in a named color
    space rather than the implicit sRGB color space. It accepts four space-separated
    parameters, as well as an optional fifth opacity value preceded by a forward slash
    (*/*).
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter is a predefined, named color space. Possible values as of
    late 2022 include `srgb`, `srgb-linear`, `display-p3`, `a98-rgb`, `prophoto-rgb`,
    `rec2020`, `xyz`, `xyz-d50`, and `xyz-d65`. The three values that follow are specific
    to the color space declared in the first parameter. Some color spaces may allow
    these values to be percentages, while others may not.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following values should yield the same color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: You could easily declare a color that lies outside the gamut of a given color
    space. For example, `color(display-p3 -0.6112 1.0079 -0.2192);` is outside the
    `display-p3` gamut. It’s still a valid color, just not one that can be expressed
    in that color space. When a color value is valid but outside the gamut, it will
    be mapped to the closest color that lies inside the color space’s gamut.
  prefs: []
  type: TYPE_NORMAL
- en: If a color’s value is straight-up invalid, opaque black is used.
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As of late 2022, only Safari supports `color()`.
  prefs: []
  type: TYPE_NORMAL
- en: Applying Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we’ve just gone through all the possible color formats, let’s take a
    brief detour to talk about the property that uses color values the most often:
    `color`. This property sets the color of an element’s text and the value of `currentcolor`.'
  prefs: []
  type: TYPE_NORMAL
- en: This property accepts as a value any valid color type, such as `#FFCC00` or
    `rgb(100% 80% 0% / 0.5)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For nonreplaced elements like paragraphs or `<em>` elements, `color` sets the
    color of the text in the element. The following code results in [Figure 5-14](#cab_fig01):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0514](assets/css5_0514.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-14\. Declared color versus default color
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: In this example, the default foreground color is black. That doesn’t have to
    be the case, since the user might have set their browser (or other user agent)
    to use a different foreground (text) color. If the browser’s default text color
    was set to `green`, the second paragraph in the preceding example would be green,
    not black—but the first paragraph would still be gray.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need not restrict yourself to such basic operations. There are plenty of
    ways to use `color`. You might have some paragraphs that contain text warning
    the user of a potential problem. To make this text stand out more than usual,
    you might decide to color it red. Just apply a class of `warn` to each paragraph
    that contains warning text (`<p class="warn">`) and the following rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same document, you might decide that any unvisited hyperlinks within
    a warning paragraph should be green:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you change your mind, deciding that warning text should be dark red, and
    that unvisited links in such text should be medium purple. The preceding rules
    need only be changed to reflect the new values. The following code results in
    [Figure 5-15](#cab_fig02):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0515](assets/css5_0515.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-15\. Changing colors [![](assets/play-icon-round.png)](https://meyerweb.github.io/csstdg5figs/05-values-and-units/changing-colors.html)
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Another use for `color` is to draw attention to certain types of text. For
    example, boldfaced text is already fairly obvious, but you could give it a different
    color to make it stand out even further—let’s say, maroon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Then you decide that you want all table cells with a class of `highlight` to
    contain light yellow text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t set a background color for any of your text, you run the risk that
    a user’s setup won’t combine well with your own. For example, if a user has set
    their browser’s background to be a pale yellow, like `#FFC`, then the previous
    rule would generate light-yellow text on a pale-yellow background. Far more likely
    is that it’s still the default background of white, against which light yellow
    is still going to be hard to read. It’s therefore generally a good idea to set
    foreground and background colors together. (We’ll talk about background colors
    shortly.)
  prefs: []
  type: TYPE_NORMAL
- en: Affecting Form Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting a value for `color` should (in theory, anyway) apply to form elements.
    Declaring `<select>` elements to have dark-gray text should be as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: This might also set the color of the borders around the edge of the `<select>`
    element, or it might not. It all depends on the user agent and its default styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also set the foreground color of input elements—although, as you can
    see in [Figure 5-16](#cab_fig05), doing so would apply that color to all inputs,
    from text to radio buttons to checkbox inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0516](assets/css5_0516.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-16\. Changing form element foregrounds
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Note in [Figure 5-16](#cab_fig05) that the text color next to the checkboxes
    is still black. This is because the rules shown assign styles only to elements
    like `<input>` and `<select>`, not normal paragraph (or other) text.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that the checkmark in the checkbox is black. This is due to the way
    form elements are handled in some web browsers, which typically use the form widgets
    built into the base operating system. Thus, when you see a checkbox and checkmark,
    they really aren’t content in the HTML document—they’re UI widgets that have been
    inserted into the document, much as an image would be. In fact, form inputs are,
    like images, replaced elements. In theory, CSS does not style the contents of
    form elements (though this may change in the future).
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the line is a lot blurrier than that, as [Figure 5-16](#cab_fig05)
    demonstrates. Some form inputs have the color of their text and even portions
    of their UI changed, while others do not. And since the rules aren’t explicitly
    defined, behavior is inconsistent across browsers. In short, form elements are
    deeply tricky to style and should be approached with extreme caution.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting Color
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As the definition of `color` indicates, the property is inherited. This makes
    sense, since if you declare `p {color: gray;}`, you probably expect that any text
    within that paragraph will also be gray, even if it’s emphasized or boldfaced
    or whatever. If you *want* such elements to be different colors, that’s easy enough.
    The following code, for example, results in [Figure 5-17](#cab_fig06):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0517](assets/css5_0517.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-17\. Different colors for different elements
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'Since color is inherited, it’s theoretically possible to set all of the ordinary
    text in a document to a color, such as red, by declaring `body {color: red;}`.
    This should make all text that is not otherwise styled (such as anchors, which
    have their own color styles) red.'
  prefs: []
  type: TYPE_NORMAL
- en: Angles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we just recently finished talking about hue angles in a number of color
    value types, this is a good time to talk about angle units. Angles in general
    are represented as <*`angle`*>, which is a <*`number`*> followed by one of four
    unit types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`deg`'
  prefs: []
  type: TYPE_NORMAL
- en: Degrees, of which there are 360 in a full circle.
  prefs: []
  type: TYPE_NORMAL
- en: '`grad`'
  prefs: []
  type: TYPE_NORMAL
- en: Gradians, of which there are 400 in a full circle. Also known as *grades* or
    *gons*.
  prefs: []
  type: TYPE_NORMAL
- en: '`rad`'
  prefs: []
  type: TYPE_NORMAL
- en: Radians, of which there are 2π (approximately 6.28) in a full circle.
  prefs: []
  type: TYPE_NORMAL
- en: '`turn`'
  prefs: []
  type: TYPE_NORMAL
- en: Turns, of which there is one in a full circle. This unit is mostly useful when
    animating a rotation and you wish to have it turn multiple times, such as `10turn`
    to make it spin 10 times. (Sadly, the pluralization `turns` is invalid, at least
    as of early 2023, and will be ignored.)
  prefs: []
  type: TYPE_NORMAL
- en: To help understand the relationships among these angle types, [Table 5-2](#angle_equivalents)
    shows how some angles are expressed in the various angle units. Unlike for length
    values, when including angles, the unit is always required, even if the value
    is `0deg`.
  prefs: []
  type: TYPE_NORMAL
- en: Table 5-2\. Angle equivalents
  prefs: []
  type: TYPE_NORMAL
- en: '| Degrees | Gradians | Radians | Turns |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `0deg` | `0grad` | `0rad` | `0turn` |'
  prefs: []
  type: TYPE_TB
- en: '| `45deg` | `50grad` | `0.785rad` | `0.125turn` |'
  prefs: []
  type: TYPE_TB
- en: '| `90deg` | `100grad` | `1.571rad` | `0.25turn` |'
  prefs: []
  type: TYPE_TB
- en: '| `180deg` | `200grad` | `3.142rad` | `0.5turn` |'
  prefs: []
  type: TYPE_TB
- en: '| `270deg` | `300grad` | `4.712rad` | `0.75turn` |'
  prefs: []
  type: TYPE_TB
- en: '| `360deg` | `400grad` | `6.283rad` | `1turn` |'
  prefs: []
  type: TYPE_TB
- en: Time and Frequency
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a property needs to express a period of time, the value is represented
    as <*`time`*> and is a <*`number`*> followed by either `s` (seconds) or `ms` (milliseconds.)
    Time values are most often used in transitions and animations, either to define
    durations or delays. The following two declarations will have exactly the same
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Time values are also used in aural CSS, again to define durations or delays,
    but support for aural CSS is extremely limited as of this writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another value type historically used in aural CSS is <*`frequency`*>, which
    is a <*`number`*> followed by either `Hz` (hertz) or `kHz` (kilohertz). As usual,
    the unit identifiers are case-insensitive, so `Hz` and `hz` are equivalent. The
    following two declarations will have exactly the same result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Unlike with length values, for time and frequency values the unit type is *always*
    required, even when the value is `0s` or `0hz`.
  prefs: []
  type: TYPE_NORMAL
- en: Ratios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you need to express a ratio of two numbers, you use a <*`ratio`*> value.
    These values are represented as two positive <*`number`*> values separated by
    a forward slash (`/`), plus optional whitespace.
  prefs: []
  type: TYPE_NORMAL
- en: The first integer refers to the width (inline size) of an element, and the second
    to the height (block size). Thus, to express a height-to-width ratio of 16 to
    9, you can write `16/9` or `16 / 9`.
  prefs: []
  type: TYPE_NORMAL
- en: As of late 2022, there is no facility to express a ratio as a single real number
    (e.g., `1.777` instead of `16/9`), nor to use a colon separator instead of a forward
    slash (e.g., `16:9`).
  prefs: []
  type: TYPE_NORMAL
- en: Position
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You use a *position value*, represented as <*`position`*>, to specify the placement
    of an origin image in a background area. Its syntactical structure is rather complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: That might seem a little nutty, but it’s all down to the subtly complex patterns
    that this value type has to allow.
  prefs: []
  type: TYPE_NORMAL
- en: If you declare only one value, such as `left` or `25%`, the second value is
    set to `center`. Thus, `left` is the same as `left center`, and `25%` is the same
    as `25% center`.
  prefs: []
  type: TYPE_NORMAL
- en: If you declare two values (either implicitly, as in the previous example, or
    explicitly), and the first one is a <*`length`*> or <*`percentage`*>, then it
    is *always* considered to be the horizontal value. Therefore, given `25% 35px`,
    the `25%` is a horizontal distance and the `35px` is a vertical distance. If you
    swap them to say `35px 25%`, then `35px` is horizontal and `25%` is vertical.
    If you write `25% left` or `35px right`, the entire value is invalid because you
    have supplied two horizontal distances and no vertical distance. (Similarly, a
    value of `right left` or `top bottom` is invalid and will be ignored.) On the
    other hand, if you write `left 25%` or `right 35px`, there is no problem because
    you’ve given a horizontal distance (with the keyword) and a vertical distance
    (with the percentage or length).
  prefs: []
  type: TYPE_NORMAL
- en: If you declare four values (we’ll deal with three in just a moment), you must
    have two lengths or percentages, each of which is preceded by a keyword. In this
    case, each length or percentage specifies an offset distance, and each keyword
    defines the edge from which the offset is calculated. Thus, `right 10px bottom
    30px` means an offset of 10 pixels to the left of the right edge, and an offset
    of 30 pixels up from the bottom edge. Similarly, `top 50% left 35px` means a 50%
    offset from the top and a 35-pixels-to-the-right offset from the left.
  prefs: []
  type: TYPE_NORMAL
- en: You can declare only three position values with the `background-position` property.
    If you declare three values, the rules are the same as for four, except the fourth
    offset is set to be 0 (no offset). Thus `right 20px top` is the same as `right
    20px top 0`.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you’ve used a preprocessor like Less or Sass, you’ve probably created variables
    to hold values. CSS itself has this capability as well. The technical term for
    this is *custom properties*, even though what these really do is create something
    like variables in your CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a basic example, with the result shown in [Figure 5-18](#val_css4_custom-values)
    (though color won’t be visible in the printed version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0518](assets/css5_0518.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-18\. Using custom values to color headings
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'There are two things to absorb here. The first is the definition of the custom
    values `--base-color` and `--highlight-color`. These are not some sort of special
    color types. They’re just names that we picked to describe what the values contain.
    We could just as easily have said this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: You probably shouldn’t do that sort of thing, unless you’re literally defining
    colors that specifically correspond to people named Alison and David. (Perhaps
    on an “About Our Team” page.) It’s always better to define custom identifiers
    that are self-documenting—things like `main-color` or `accent-color` or `brand-font-face`.
  prefs: []
  type: TYPE_NORMAL
- en: The important point is that any custom identifier of this type begins with *two*
    hyphens (`--`). It can then be invoked later by using a `var()` value type. Note
    that these names are case-sensitive, so `--main-color` and `--Main-color` are
    completely separate identifiers.
  prefs: []
  type: TYPE_NORMAL
- en: 'These custom identifiers are often referred to as *CSS variables*, which explains
    the `var()` pattern. An interesting feature of custom properties is their ability
    to scope themselves to a given portion of the DOM. If that sentence made any sense
    to you, it probably gave a little thrill. If not, here’s an example to illustrate
    scoping, with the result shown in [Figure 5-19](#val_css4_custom-value-scoping):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '![css5 0519](assets/css5_0519.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5-19\. Scoping custom values to certain contexts
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Notice that the headings are a dark gray outside the `<aside>` element and a
    light gray inside. That’s because the variable `--base-color` was updated for
    `<aside>` elements. The new custom value applies to any `<h1>` inside an `<aside>`
    element.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great many patterns are possible with CSS variables, even if they are confined
    to value replacement. Here’s an example suggested by Chriztian Steinmeier combining
    variables with the `calc()` function to create a regular set of indents for unordered
    lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'This particular example is basically the same as writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: The difference is that with variables, it’s simple to update the `--gutter`
    multiplier in one place and have everything adjust automatically, rather than
    having to retype three values and make sure all the math is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Custom Property Fallbacks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you’re setting a value by using `var()`, you can specify a fallback value.
    For example, you could say that if a custom property isn’t defined, you want a
    regular value used instead, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Given that, if `--list-indent` isn’t defined, is determined to be invalid, or
    is explicitly set to `initial`, `2em` will be used instead. You get just the one
    fallback, and it can’t be another custom property name.
  prefs: []
  type: TYPE_NORMAL
- en: 'That said, it *can* be another `var()` expression, and that nested `var()`
    can contain another `var()` as its fallback, and so on to infinity. So let’s say
    you’re using a pattern library that defines colors for various interface elements.
    If those aren’t available for some reason, you could fall back to a custom property
    value defined by your basic site stylesheet. Then, if that’s also not available,
    you could fall back to a plain color value. It would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: The thing to watch out for here is that if you manage to create an invalid value,
    the whole thing gets blown up and the value is either inherited or set to its
    initial value, depending on whether the property in question is usually inherited
    or not, as if it were set to `unset` (see [“unset”](#unset)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose we wrote the following invalid `var()` values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: In the first case, the fallback is `--base-color, gray` as a single string,
    not something that’s parsed, so it’s invalid. Similarly, in the second case, the
    fallback `--left-indent` was never declared. In either case, if the first custom
    property is valid, the invalid fallback doesn’t matter, because the browser never
    gets to it. But if, say, `--list-indent` doesn’t have a value, the browser will
    go to the fallback, and here that’s invalid. So what happens next?
  prefs: []
  type: TYPE_NORMAL
- en: For the color, since the property `color` is inherited, the list items will
    inherit their color from their parent, almost certainly an `<ol>` or `<ul>` element.
    If the parent’s `color` value is `fuchsia`, the list items will be fuchsia. For
    the left margin, the property `margin-left` is not inherited, so the left margins
    of the list items will be set to the initial value of `margin-left`, which is
    `0`. So the list items will have no left margin.
  prefs: []
  type: TYPE_NORMAL
- en: 'This also happens if you try to apply a value to a property that can’t accept
    those kinds of values. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, everything looks fine at first glance, except the `color` property is
    being given a length value, and the `margin-left` property is being given a color
    value. As a result, the fallbacks of `gray` and `2em` are not used. This is because
    the `var()` syntax is valid, so the result is the same as if we declared `color:
    5vw` and `margin-left: hsl(23, 25%, 50%)`, both of which are tossed out as invalid.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This means the outcome will be the same as we saw before: the list items will
    inherit the color value from their parents, and their left margins will be set
    to the initial value of 0, just as if the given values were `unset`.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you’ve seen, CSS provides a wide range of value and unit types. These units
    can have advantages and drawbacks, depending on the circumstances in which they’re
    used. You’ve already seen some of those circumstances, and their nuances will
    be discussed throughout the rest of the book, as appropriate.
  prefs: []
  type: TYPE_NORMAL
