- en: Chapter 11\. Declaration Files
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Declaration files
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-2
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Have purely type system code
  id: totrans-3
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  id: totrans-4
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: No runtime constructs
  id: totrans-5
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Even though writing code in TypeScript is great and that’s all you want to do,
    you’ll need to be able to work with raw JavaScript files in your TypeScript projects.
    Many packages are written directly in JavaScript, not TypeScript. Even packages
    that are written in TypeScript are distributed as JavaScript files.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, TypeScript projects need a way to be told the type shapes of environment-specific
    features such as global variables and APIs. A project running in, say, Node.js
    might have access to built-in Node modules not available in browsers—and vice
    versa.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript allows declaring type shapes separately from their implementation.
    Type declarations are typically written in files whose names end with the *.d.ts*
    extension, known as *declaration files*. Declaration files are generally either
    written within a project, built and distributed with a project’s compiled npm
    package, or shared as a standalone “typings” package.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: Declaration Files
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A *.d.ts* declaration file generally works similarly to a *.ts* file, except
    with the notable constraint of not being allowed to include runtime code. *.d.ts*
    files contain only descriptions of available runtime values, interfaces, modules,
    and general types. They cannot contain any runtime code that could be compiled
    down to JavaScript.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Declaration files can be imported just like any other source TypeScript file.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: 'This *types.d.ts* file exports a `Character` interface used by an *index.ts*
    file:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Tip
  id: totrans-15
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Declaration files create what’s known as an *ambient context*, meaning an area
    of code where you can only declare types, not values.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is largely dedicated to declaration files and the most common forms
    of type declarations used within them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Declaring Runtime Values
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although definition files may not create runtime values such as functions or
    variables, they are able to declare that those constructs exist with the `declare`
    keyword. Doing so tells the type system that some external influence—such as a
    `<script>` tag in a web page—has created the value under that name with a particular
    type.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Declaring a variable with `declare` uses the same syntax as a normal variable
    declaration, except an initial value is not allowed.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: 'This snippet successfully declares a `declared` variable but receives a type
    error for trying to give a value to an `initializer` variable:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Functions and classes are also declared similarly to their normal forms, but
    without the bodies of functions or methods.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `canGrantWish` function and method are properly declared without
    a body, but the `grantWish` function and method are syntax errors for improperly
    attempting to set up a body:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Tip
  id: totrans-26
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: TypeScript’s implicit `any` rules work the same for functions and variables
    declared in ambient contexts as they do in normal source code. Because ambient
    contexts may not provide function bodies or initial variable values, explicit
    type annotations—including explicit return type annotations—are generally the
    only way to stop them from implicitly being type `any`.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Although type declarations using the `declare` keyword are most common in *.d.ts*
    definition files, the `declare` keyword can be used outside of declaration files
    as well. A module or script file can use `declare` as well. This can be useful
    when a globally available variable is only meant to be used in that file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a `myGlobalValue` variable is defined in an *index.ts* file, so it’s
    allowed to be used in that file:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note that while type shapes such as interfaces are allowed with or without
    a `declare` in *.d.ts* definition files, runtime constructs such as functions
    or variables will trigger a type complaint without a `declare`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Global Values
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Because TypeScript files that have no `import` or `export` statements are treated
    as *scripts* rather than *modules*, constructs—including types—declared in them
    are available globally. Definition files without any imports or exports can take
    advantage of that behavior to declare types globally. Global definition files
    are particularly useful for declaring global types or variables available across
    all files in an application.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a *globals.d.ts* file declares that a `const version: string` exists
    globally. A *version.ts* file is then able to refer to a global `version` variable
    despite not importing from *globals.d.ts*:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Globally declared values are most often used in browser applications that use
    global variables. Although most modern web frameworks generally use newer techniques
    such as ECMAScript modules, it can still be useful—especially in smaller projects—to
    be able to store variables globally.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-39
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If you find that you can’t automatically access global types declared in a *.d.ts*
    file, double-check that the *.d.ts* file isn’t importing and exporting anything.
    Even a single export will cause the whole file to no longer be available globally!
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Global Interface Merging
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables aren’t the only globals floating around in a TypeScript project’s
    type system. Many type declarations exist globally for global APIs and values.
    Because interfaces merge with other interfaces of the same name, declaring an
    interface in a global script context—such as a *.d.ts* declaration file without
    any `import` or `export` statements—augments that interface globally.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a web application that relies on a global variable set by the
    server might want to declare that as existing on the global `Window` interface.
    Interface merging would allow a file such as *types/window.d.ts* to declare a
    variable that exists on the global `window` variable of type `Window`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Global Augmentations
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s not always feasible to refrain from `import` or `export` statements in
    a *.d.ts* file that needs to also augment the global scope, such as when your
    global definitions are simplified greatly by importing a type defined elsewhere.
    Sometimes types declared in a module file are meant to be consumed globally.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'For those cases, TypeScript allows a syntax to `declare global` a block of
    code. Doing so marks the contents of that block as being in a global context even
    though their surroundings are not:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, a `types/data.d.ts` file exports a `Data` interface, which will later
    be imported by both `types/globals.d.ts` and the runtime *index.ts*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Additionally, `types/globals.d.ts` declares a variable of type `Data` globally
    inside a `declare global` block as well as a variable available only in that file:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '*index.ts* then has access to the `globallyDeclared` variable without an import,
    and still needs to import `Data`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Wrangling global and module declarations to play well together can be tricky.
    Proper usage of TypeScript’s `declare` and `global` keywords can describe which
    type definitions are meant to be available globally in projects.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: Built-In Declarations
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you’ve seen how declarations work, it’s time to unveil their hidden
    use in TypeScript: they’ve been powering its type checking the whole time! Global
    objects such as `Array`, `Function`, `Map`, and `Set` are examples of constructs
    that the type system needs to know about but aren’t declared in your code. They’re
    provided by whatever runtime(s) your code is meant to run in: Deno, Node, a web
    browser, etc.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: Library Declarations
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Built-in global objects such as `Array` and `Function` that exist in all JavaScript
    runtimes are declared in files with names like *lib.[target].d.ts*. *target* is
    the minimum support version of JavaScript targeted by your project, such as ES5,
    ES2020, or ESNext.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: 'The built-in library definition files, or “lib files,” are fairly large because
    they represent the entirety of JavaScript’s built-in APIs. For example, members
    on the built-in `Array` type are represented by a global `Array` interface that
    starts like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Lib files are distributed as part of the TypeScript npm package. You can find
    them inside the package at paths like *node_modules/typescript/lib/lib.es5.d.ts*.
    For IDEs such as VS Code that use their own packaged TypeScript versions to type
    check code, you can find the lib file being used by right-clicking on a built-in
    method such as an array’s `forEach` in your code and selecting an option like
    Go to Definition ([Figure 11-1](#lib_go_to_definition)).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Left: going to definition on a forEach; right: the resultant opened lib.es5.d.ts
    file.](Images/lets_1101.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11-1\. Left: going to definition on a `forEach`; right: the resultant
    opened lib.es5.d.ts file'
  id: totrans-66
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Library targets
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript by default will include the appropriate lib file based on the `target`
    setting provided to the `tsc` CLI and/or in your project’s *tsconfig.json* (by
    default, `"es5"`). Successive lib files for newer versions of JavaScript build
    on each other using interface merging.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, static `Number` members such as `EPSILON` and `isFinite` added
    in ES2015 are listed in *lib.es2015.d.ts*:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: TypeScript projects will include the lib files for all version targets of JavaScript
    up through their minimum target. For example, a project with a target of `"es2016"`
    would include *lib.es5.d.ts*, *lib.es2015.d.ts*, and *lib.es2016.d.ts*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Language features available only in newer versions of JavaScript than your target
    will not be available in the type system. For example, if your target is `"es5"`,
    language features from ES2015 or later such as `String.prototype.startsWith` will
    not be recognized.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Compiler options such as `target` are covered in more detail in [Chapter 13,
    “Configuration Options”](ch13.xhtml#configuration_options).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: DOM Declarations
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Outside of the JavaScript language itself, the most commonly referenced area
    of type declarations is for web browsers. Web browser types, generally referred
    to as “DOM” types, cover APIs such as `localStorage` and type shapes such as `HTMLElement`
    available primarily in web browsers. DOM types are stored in a *lib.dom.d.ts*
    file alongside the other *lib.*.d.ts* declaration files.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Global DOM types, like many built-in globals, are often described with global
    interfaces. For example, the `Storage` interface used for `localStorage` and `sessionStorage`
    and starts roughly like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: TypeScript includes DOM types by default in projects that don’t override the
    `lib` compiler option. That can sometimes be confusing for developers working
    on projects meant to be run in nonbrowser environments such as Node, as they shouldn’t
    be able to access the global APIs such as `document` and `localStorage` that the
    type system would then claim to exist. Compiler options such as `lib` are covered
    in more detail in [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Module Declarations
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One more important feature of declaration files is their ability to describe
    the shapes of modules. The `declare` keyword can be used before a string name
    of a module to inform the type system of the contents of that module.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, the `"my-example-lib"` module is declared as being in existence in a
    `modules.d.ts` declaration script file, then used in an *index.ts* file:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You shouldn’t have to use `declare module` often, if ever, in your own code.
    It’s mostly used with the following section’s wildcard module declarations and
    with package types covered later in this chapter. Additionally, see [Chapter 13,
    “Configuration Options”](ch13.xhtml#configuration_options) for information on
    `resolveJsonModule`, a compiler option that allows TypeScript to natively recognize
    imports from *.json* files.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Wildcard Module Declarations
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A common use of module declarations is to tell web applications that a particular
    non-JavaScript/TypeScript file extension is available to `import` into code. Module
    declarations may contain a single `*` wildcard to indicate that any module matching
    that pattern looks the same.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, many web projects such as those preconfigured in popular React
    starters such as create-react-app and create-next-app support CSS modules to import
    styles from CSS files as objects that can be used at runtime. They would define
    modules with a pattern such as `"*.module.css"` that default exports an object
    of type `{ [i: string]: string }`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Warning
  id: totrans-91
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Using wildcard modules to represent local files isn’t completely type safe.
    TypeScript does not provide a mechanism to ensure the imported module path matches
    a local file. Some projects use a build system such as Webpack and/or generate
    *.d.ts* files from local files to make sure imports match up.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: Package Types
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you’ve seen how to declare typings within a project, it’s time to cover
    consuming types between packages. Projects written in TypeScript still generally
    distribute packages containing compiled *.js* outputs. They typically use *.d.ts*
    files to declare the backing TypeScript type system shapes behind those JavaScript
    files.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: declaration
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript provides a `declaration` option to create *.d.ts* outputs for input
    files alongside JavaScript outputs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, given the following *index.ts* source file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Using `declaration`, a `module` of `"es2015"`, and a `target` of `"es2015"`,
    the following outputs would be generated:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Auto-generated *.d.ts* files are the best way for a project to create type definitions
    to be used by consumers. It’s generally recommended that most packages written
    in TypeScript that produce *.js* file outputs should also bundle *.d.ts* alongside
    those files.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Compiler options such as `declaration` are covered in more detail in [Chapter 13,
    “Configuration Options”](ch13.xhtml#configuration_options).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Package Types
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript is able to detect and utilize *.d.ts* files bundled inside a project’s
    `node_modules` dependencies. Those files will inform the type system about the
    type shapes exported by that package as if they were written inside the same project
    or declared with a `declare` module block.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical npm module that comes with its own *.d.ts* declaration files might
    have a file structure something like:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As an example, the ever-popular test runner Jest is written in TypeScript and
    provides its own bundled *.d.ts* files in its `jest` package. It has a dependency
    on the `@jest/globals` package that provides functions such as `describe` and
    `it`, which `jest` then makes available globally:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we were to re-create a very limited subset of the Jest typings packages
    from scratch, they might look some something like these files. The `@jest/globals`
    package exports the `describe` and `it` functions. Then, the `jest` package imports
    those functions and augments the global scope with `describe` and `it` variables
    of their corresponding function’s type:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This structure allows projects that use Jest to refer to global versions of
    `describe` and `it`. Projects can alternatively choose to import those functions
    from the `@jest/globals` package.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Package Types
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your project is meant to be distributed on npm and provide types for consumers,
    add a `"types"` field in the package’s *package.json* file to point to the root
    declaration file. The `types` field works similarly to the `main` field—and often
    will look the same but with the *.d.ts* extension instead of *.js*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in this `fictional` package file, the *./lib/index.js* main runtime
    file is paralleled by the *./lib/index.d.ts* types file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: TypeScript would then use the contents of the *./lib/index.d.ts* as what should
    be provided for consuming files that import from the `utilitarian` package.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-121
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: If the `types` field does not exist in a package’s *package.json*, TypeScript
    will assume a default value of *./index.d.ts*. This mirrors the default npm behavior
    of assuming an *./index.js* file as the `main` entry point for a package if not
    specified.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Most packages use TypeScript’s `declaration` compiler option to create *.d.ts*
    files alongside *.js* outputs from source files. Compiler options are covered
    in [Chapter 13, “Configuration Options”](ch13.xhtml#configuration_options).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: DefinitelyTyped
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sadly, not all projects are written in TypeScript. Some unfortunate developers
    are still writing their projects in plain old JavaScript without a type checker
    to aide them. Horrifying.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Our TypeScript projects still need to be informed of the type shapes of the
    modules from those packages. The TypeScript team and community created a giant
    repository called [DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped)
    to house community-authored definitions for packages. DefinitelyTyped, or DT for
    short, is one of the most active repositories on GitHub. It contains thousands
    of packages of *.d.ts* definitions, along with automation around reviewing change
    proposals and publishing updates.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: DT packages are published on npm under the `@types` scope with the same name
    as the package they provide types for. For example, as of 2022, `@types/react`
    provides type definitions for the `react` package.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-128
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: '`@types` are generally installed as either `dependencies` or `devDependencies`,
    though the distinction between those two has become blurred in recent years. In
    general, if your project is meant to be distributed as an npm package, it should
    use `dependencies` so consumers of the package also bring in the type definitions
    used within. If your project is a standalone application such as one built and
    run on a server, it should use `devDependencies` to convey that the types are
    just a development-time tool.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, for a utility package that relies on `lodash`—which as of 2022
    has a separate `@types/lodash` package—the *package.json* would contain lines
    similar to:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The *package.json* for a standalone app built on React might contain lines
    similar to:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that semantic versioning (“semver”) numbers do not necessarily match between
    `@types/` packages and the packages they represent. You may often find some that
    are off by a patch version as with React earlier, a minor version as with Lodash
    earlier, or even major versions.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Warning
  id: totrans-135
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: As these files are authored by the community, they may lag behind the parent
    project or have small inaccuracies. If your project compiles successfully yet
    you get runtime errors when calling libraries, investigate if the signatures of
    the APIs you are accessing have changed. This is less common, but still not unheard
    of, for mature projects with stable API surfaces.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Type Availability
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most popular JavaScript packages either ship with their own typings or have
    typings available via DefinitelyTyped.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’d like to get types for a package that doesn’t yet have types available,
    your three most common options would be:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Send a pull request to DefinitelyTyped to create its `@types/` package.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `declare module` syntax introduced earlier to write the types within
    your project.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disable `noImplicitAny` as covered—and strongly warned against—in [Chapter 13,
    “Configuration Options”](ch13.xhtml#configuration_options).
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I’d recommend contributing types to DefinitelyTyped if you have the time. Doing
    so helps out other TypeScript developers who may also want to use that package.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-144
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: See [aka.ms/types](https://aka.ms/types) to display whether a package has types
    bundled or via a separate `@types/` package.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you used declaration files and value declarations to inform
    TypeScript about modules and values not declared in your source code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Creating declaration files with *.d.ts*
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring types and values with the `declare` keyword
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing global types using global values, global interface merges, and global
    augmentations
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and using TypeScript’s built-in target, library, and DOM declarations
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declaring types of modules, including wildcard modules
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How TypeScript picks up types from packages
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using DefinitelyTyped to acquire types for packages that don’t include their
    own
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-155
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Now that you’ve finished reading this chapter, practice what you’ve learned
    on [*https://learningtypescript.com/declaration-files*](https://learningtypescript.com/declaration-files).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经完成阅读本章，可以在[*https://learningtypescript.com/declaration-files*](https://learningtypescript.com/declaration-files)上练习所学内容。
- en: What do TypeScript types say in the American South?
  id: totrans-157
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: TypeScript 的类型在美国南部说什么呢？
- en: ''
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: “Why, I do `declare`!”
  id: totrans-159
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “Why, I do `declare`!”
