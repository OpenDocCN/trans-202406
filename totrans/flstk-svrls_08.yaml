- en: Chapter 8\. AWS AppSync In-Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#ch3), we learned about GraphQL and created a basic
    GraphQL API. In this chapter, we’ll expand upon these concepts to create a music
    festival app using [AWS AppSync](https://github.com/dabit3/full-stack-serverless-code/tree/master/appsync-in-depth),
    from this book’s GitHub repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'This app will require the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Amazon DynamoDB tables will be used for shows and stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL API will be used for creating, reading, updating, deleting, and listing
    shows and stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only admins should be able to create, update, or delete a show or a stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All users should be able to view shows and stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Relationships should be enabled between shows and stages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users should be able to view all shows as well as navigate to view show details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Skills for GraphQL, AppSync API, and React Router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll cover how to model relationships between GraphQL types,
    how to implement authorization rules on GraphQL types and fields, how to enable
    multiple authorization modes for an AppSync API, and how to enable route parameters
    using React Router.
  prefs: []
  type: TYPE_NORMAL
- en: First we’ll briefly cover each of these topics, and when we start building out
    the app, we will get into them in greater depth.
  prefs: []
  type: TYPE_NORMAL
- en: Relationships Between GraphQL Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When creating a GraphQL API, or any API, modeling relationships between data
    becomes very important to understand. For example, the app that we are building
    will have the following two types:'
  prefs: []
  type: TYPE_NORMAL
- en: Stage
  prefs: []
  type: TYPE_NORMAL
- en: This type will hold the stage information for individual performances, including
    the stage name and stage ID. Each stage will have a number of performances that
    are associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs: []
  type: TYPE_NORMAL
- en: This type will hold the individual performance information, including the performer,
    the description, the stage of the performance, and the time of the performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this type of API, ideally you would want to have at least the following
    access patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: Query for a single stage and performances for the stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query for all stages and performances for each stage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query for an individual performance and the corresponding stage info
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Query for all performances and the corresponding stage info
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The question is now usually this: how can you enable these different relationships
    and access patterns? And in our case, how can we do this using a NoSQL database
    like DynamoDB? There are two ways to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern your data in DynamoDB in a way that enables all of these access patterns
    to be performed using a single table by taking advantage of a combination of primary
    keys, sort keys, and local secondary indexes. For this to work with AppSync, we
    would have to write and maintain all of the resolver logic by hand and from scratch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable these relationships directly at the resolver level. Because we are using
    GraphQL, and GraphQL enables per-field resolvers, this can be done. To understand
    this better let’s take a look at one of the types we will be working with.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stage type in GraphQL
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To better understand these concepts, let’s take a look at one of the types
    we will be working with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating a resolver, or resolvers, for this type, here is an example chain
    of actions that you could assume would happen when a request is made for stages
    and corresponding performances:'
  prefs: []
  type: TYPE_NORMAL
- en: The main `Stage` GraphQL resolver will use the stage ID to retrieve the stage
    information from the Stage table in the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The field of `performances` on the `Stage` type will have its own GraphQL resolver.
    This resolver should use the stage ID to retrieve the related performances by
    querying the database using a GSI, returning only the performances for that *stage*
    ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'GraphQL Transform: @connection'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#ch3), we used the `@model` directive of the GraphQL
    Transform library to scaffold out an entire backend, including resolvers, databases,
    and additional GraphQL schema. As a recap, the GraphQL Transform is a library
    of directives that allow us to “decorate” a GraphQL schema and add additional
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we’ll be introducing a couple of new directives, including `@connection`,
    which enables us to model these relationships and generate the necessary resolvers
    with only a few lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Authentication Types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.xhtml#ch3), we created a GraphQL API using the API key as
    the authentication type. This is fine for certain circumstances, like when you
    want to have a GraphQL query available to all users of your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'AppSync supports four main authentication methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The API key
  prefs: []
  type: TYPE_NORMAL
- en: The API key requires that, when making an HTTP request, you send the API key
    in the header in the form of `x-api-key` in some form or fashion. If you are using
    the Amplify client as we have done so far in this book, then this is automatically
    sent for you.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Cognito user pools
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Cognito, the managed authentication service we’ve used throughout this
    book, is one of the mechanisms we will be using in this chapter. Using Amazon
    Cognito, we can configure private and group access to the API itself and to GraphQL
    types and fields.
  prefs: []
  type: TYPE_NORMAL
- en: OpenID Connect
  prefs: []
  type: TYPE_NORMAL
- en: OpenID Connect enables you to bring your own authentication provider, so if
    you prefer another authentication service like Auth0, or your company has its
    own authentication implementation, you can still use it to authenticate against
    an AppSync API.
  prefs: []
  type: TYPE_NORMAL
- en: IAM
  prefs: []
  type: TYPE_NORMAL
- en: AWS IAM type enforces the AWS Signature Version 4 signing process on the GraphQL
    API. You can use an AWS IAM UnAuthenticated Role from Cognito identity pools for
    public access, allowing a more secure way to enable public access against your
    AppSync API versus an API key.
  prefs: []
  type: TYPE_NORMAL
- en: Here we will use a combination of the API key and Amazon Cognito to provide
    multiple authentication types for the API, enabling public read access and private
    read and write access.
  prefs: []
  type: TYPE_NORMAL
- en: Authorization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the GraphQL Transform library, we can also define different authorization
    rules for the API by using the `@auth` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `@auth`, we can define different types of rules, including (but not limited
    to) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Enable all users to create and read, but only the owner of the created item
    to update and delete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable only users of a certain group to be able to create, update, or delete.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable all users to read, but not perform any other actions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A combination of the preceding rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this instance, the app we will be building will support both private and
    public access, but we will need to also enable more control over these rules.
    We need to support the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Authenticated users who are part of the Amazon Cognito group named Admin will
    be able to perform all actions: create, read, update, and delete.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users who are not authenticated will have access, but will only be able to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom Data Access Patterns Using GSIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most powerful things about DynamoDB is that it allows (at the time
    of this writing) 20 additional GSIs per table. Using either a GSI or a combination
    of GSI + sort key (also think of this as a filter key), you are able to create
    extremely flexible and powerful data access patterns for your data. The GraphQL
    Transform library also has a directive, `@key`, that makes it simple to configure
    custom index structures for `@model` types.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the `@key` directive to create an access pattern that will allow us
    to query performances for a given stage ID by setting the stage ID as the GSI
    on the `Performance` table. Doing this will allow us to be able to request stages
    and their corresponding performances in a single GraphQL query.
  prefs: []
  type: TYPE_NORMAL
- en: That completes our skills overview; let’s get started building the app.
  prefs: []
  type: TYPE_NORMAL
- en: Starting to Build the App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To get started, we’ll again be walking through the steps of creating a new React
    project, installing dependencies, initializing a new Amplify app, and adding features
    via the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change into the directory where you would like the app to live, and create
    a new React project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Creating the Amplify App and Adding the Features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, initialize a new Amplify project in the root of the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, the Amplify project has been initialized and we can go ahead and start
    adding features.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first feature we will add is authentication. This app will need to have
    basic authentication but will also need to have the ability to add admin users
    dynamically via a Lambda post-confirmation trigger like we did in [Chapter 6](ch06.xhtml#ch6).
    To enable this, we will create the authentication service as well as a Lambda
    trigger that will allow us to add a predefined set of users into an Admin group
    as they sign up.
  prefs: []
  type: TYPE_NORMAL
- en: Authentication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add authentication with Cognito, we’ll again use the `auth` category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the function with the following code and configure the `adminEmails`
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the authentication service has been set up and we can continue on to the
    next step: creating the AppSync API.'
  prefs: []
  type: TYPE_NORMAL
- en: The AppSync API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we’ll create the AppSync GraphQL API. Remember that for this API, we will
    need to enable multiple authentication types for both public and protected access.
    This can all be enabled by the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the AppSync API, we’ll use the `api` category:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This should open the GraphQL schema, located at *amplify/backend/api/festivalapi/schema.graphql*,
    in your text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The schema we will be using has two main types, a `Stage` and a `Performance`.
    Use the following schema and continue (we will walk through how it works in the
    next step):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Let’s look at the directives we used and how they work.
  prefs: []
  type: TYPE_NORMAL
- en: '@auth'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, the `@auth` directive allows us to pass in an array of authorization
    rules. Each rule has an `allow` field (required) as well as other metadata (optional),
    including things like specifying the provider if it is different than the default
    authorization type.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Stage` and `Performance` type, we’ve used two authorization types, one
    for group access (`groups`) and another for public access (`public`). You’ll notice
    that for the public access, we’ve also set an array of operations. This array
    should contain a list of the operations we would like to enable on the API. If
    there are no operations listed, then by default all operations would be enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '@key'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `@key` directive enables us to add GSIs and sort keys to a DynamoDB table
    for custom data access patterns. In the preceding schema, we’ve created a `key`
    called `byStageId` that will allow us to query the Performance table for performances
    by stage ID using a field called `performanceStageId` (on the `Performance` table).
    The resolver for the `performances` field will then use the ID of the stage to
    query for performances by stage ID.
  prefs: []
  type: TYPE_NORMAL
- en: '@connection'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `@connection` directive allows us to model relationships between types.
    Types of relationships that can be created are belongs to, one to many, many to
    one, or many to many. In this example, we’ve created two relationships:'
  prefs: []
  type: TYPE_NORMAL
- en: A relationship between a stage and a performance (one stage has many performances)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A relationship between a performance and a stage (a performance belongs to a
    stage)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With all of the services configured, we’re ready to deploy the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The services have been deployed and we can begin writing the client code.
  prefs: []
  type: TYPE_NORMAL
- en: Building the Frontend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that the project has been created and configured and the backend has been
    deployed, we can start setting up the client!
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we will do is create the files we will need for this app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing we will need to do is open *src/index.js* to add the Amplify
    configuration, import the Ant Design styles, and replace the main component with
    the Router that we will be creating soon. Update the file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s create the `Container` component that will serve as a reusable component
    to add padding and styling for our views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Footer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we’ll create the `Footer` component that will serve as a reusable component
    to add a basic footer, as well as a link for admins to be able to sign up and
    sign in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Nav
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, open *src/Nav.js* to create the basic navigation. There will only be one
    link: a link back to the main view that will hold all of the shows and performances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Admin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Admin component we’ll create will only do three things for now: allow a
    user to sign up, sign in, and sign out. The idea for this component is to give
    admins a way to sign up so they can then create and manage the API as an admin.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Remember, when someone signs up, if their email is enabled in the Lambda trigger,
    they will be placed in the Admin group after signing up. They will then be able
    to perform mutations to create, update, and delete stages and performances.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you ever need to update your backend code like the GraphQL schema or Lambda
    function, you can make the changes locally, then run `amplify push` to deploy
    the changes to the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let’s create the Router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this component, we combine the router with the persistent UI components like
    the Container and Footer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The app has three routes:'
  prefs: []
  type: TYPE_NORMAL
- en: Home
  prefs: []
  type: TYPE_NORMAL
- en: This is the main route that will render the stages and performances.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs: []
  type: TYPE_NORMAL
- en: This is this is the route that will render an individual performance and details
    around the performance.
  prefs: []
  type: TYPE_NORMAL
- en: Admin
  prefs: []
  type: TYPE_NORMAL
- en: This is the route that will render the sign-up/sign-in page for admins.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Performance route, you will see that we are using a path that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Doing this allows us to have URL parameters, so if we hit a route like this,
    we will be able to easily extract the ID from the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Hitting a route with URL parameters will allow us to access them in the component
    itself. This is useful because we will be using the ID of the performance to fetch
    the performance details, and having them easily accessible in the route parameters
    enables this. It also enables you to easily build apps that support deep linking.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next, let’s create the `Performance` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The render method of this component is pretty basic; it’s just rendering the
    performance `performer`, `time`, and `description`. What is interesting about
    this component is how we get that information. We do so with the following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We create two pieces of state using the `useState` hook: `loading` (set to
    true) and `performance` (set to null). We also create a variable called `id` that
    uses the `useParams` helper from React Router to get the route parameter of `id`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the component loads, we use the `useEffect` hook to immediately call the
    `fetchPerformanceInfo` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `fetchPerformanceInfo` function will use the `id` from the route params
    to call the AppSync API. The API call here uses `API.graphql`, passing in the
    `variables`, `query`, and the `authMode`. By default, our API is using Cognito
    User Pools as the auth mode. Any time we would like to override this, like in
    this case to make a public API call, we need to specify the `authMode` in the
    API call itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the data is returned from the API, we call `setLoading` and `setPerformance`
    to update the UI and render the data coming back from the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Home
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s create the last component, the `Home` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The logic in this component is actually very similar to what we did in the
    `Performance` component:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two main pieces of state using the `useState` hook: `stages` (set to
    an empty array), and `loading` (set to `true`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the app loads, we use the `API` class with a custom `authMode` of `API_KEY`
    to call the AppSync API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the data comes back from the API, set the state for the stages and set
    loading to false.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, the app is finished, but there’s just one more thing. Because we have
    created a custom access pattern for the performances resolver, we need to update
    the `listStages` query definition to also return the performances. To do this,
    update the `listStages` query with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the app is completed and we can populate some data. Start the app and
    sign up with an admin user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Click the `Admins` link in the footer to sign up. Once you’ve signed up, open
    the AppSync console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the Queries panel of the console, you will need to click Login with User
    Pools to sign in using the username and password of the user you just created.
    When prompted for the ClientID, use the `aws_user_pools_web_client_id` located
    in the *aws-exports.js* file of your local project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create at least one stage and one performance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now, our database has some data, and we should be able to view it in our app
    and navigate between the main view and the detail view for each performance!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few things to keep in mind from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The GraphQL Transform directive enables you to add powerful features to your
    GraphQL API like authorization rules, relationships, and custom indexes for additional
    data access patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@auth` directive allows you to pass in an array of rules to define authorization
    rules on types and fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@connection` directive enables you to model relationships between GraphQL
    types.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `@key` directive enables you to define custom indexes for custom data access
    patterns and to enhance existing relationships.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating an API with multiple authorization types, you will have a `Primary`
    authorization type that will be the default when making API calls. Whenever you
    need to override the `Primary` authorization type, you must pass in the `authMode`
    parameter to the `API` class defining the authorization type you would like to
    use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
