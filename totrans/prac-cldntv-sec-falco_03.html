<html><head></head><body><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Getting Started with Falco on Your Local Machine"><div class="chapter" id="getting_started_with_falco">
<h1><span class="label">Chapter 2. </span>Getting Started with Falco <span class="keep-together">on Your Local Machine</span></h1>
<p><a contenteditable="false" data-primary="Falco (generally)" data-secondary="installing/running on local machine" data-type="indexterm" id="ch02.html0"/>Now that you’re acquainted with the possibilities that Falco offers, what better way to familiarize yourself with it than to try it? In this chapter, you will discover how easy it is to install and run Falco on a local machine. We’ll walk you through the process step-by-step, introducing and analyzing the core concepts and functions. We will generate an event that Falco will detect for us by simulating a malicious action, and show you how to read Falco’s notification output. We’ll finish the chapter by presenting some manageable approaches to customizing your installation.</p>
<section data-type="sect1" data-pdf-bookmark="Running Falco on Your Local Machine"><div class="sect1" id="running_falco_on_your_local_machine">
<h1>Running Falco on Your Local Machine</h1>
<p><a contenteditable="false" data-primary="local machine, running Falco on" data-type="indexterm" id="ch02.html1"/>Although Falco is not a typical application, installing and running it on a local machine is quite simple—all you need is a Linux host or a virtual machine and a terminal. There are two components to install: the user space program (named <em>falco</em>) and a driver. The driver is needed to collect system calls, which are one possible data source for Falco. For simplicity, we will focus only on system call capture in this chapter.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>You will learn more about the available drivers and why we need them to instrument the system in <a data-type="xref" href="ch03.xhtml#understanding_falcoapostr">Chapter 3</a> and explore alternative data sources in <a data-type="xref" href="ch04.xhtml#data_source">Chapter 4</a>. For the moment, you only need to know that the default driver, which is implemented as a Linux kernel module, is enough to collect system calls and start using Falco.</p>
</div>
<p>Several methods are available to install these components, as you will see in <a data-type="xref" href="ch08.xhtml#the_output_framework">Chapter 8</a>. However, in this chapter we’ve opted to use the binary package. It works with almost any Linux distribution and has no automation: you can touch its components with your hands. The binary package includes the <em>falco</em> program, the <em>falco-driver-loader</em> script (a utility to help you install the driver), and many other required files. You can download this package from the official website of <a href="https://falco.org">The Falco Project</a>, where you’ll also find comprehensive information about installing it. So, let’s get to it!</p>
<section data-type="sect2" data-pdf-bookmark="Downloading and Installing the Binary Package"><div class="sect2" id="downloading_and_installing_the_binary_p">
<h2>Downloading and Installing the Binary Package</h2>
<p><a contenteditable="false" data-primary="binary package, downloading/installing" data-type="indexterm" id="idm45324240097680"/>Falco’s binary package is distributed as a single tarball compressed with GNU zip (gzip). The tarball file is named <em>falco-&lt;x.y.z&gt;-&lt;arch&gt;.tar.gz</em>, where <em>&lt;x.y.z&gt;</em> is the version of a Falco release and <em>&lt;arch&gt;</em> is the intended architecture (e.g., <em>x86_64</em>) for the package.</p>
<p>All the available packages are listed on Falco’s <a href="https://oreil.ly/Hx6Dy">“Download” page</a>. You can grab the URL of the binary package and download it locally, for example using <code>curl</code>:</p>
<pre data-type="programlisting">$ <strong>curl -L -O \</strong>
<strong>    https://download.falco.org/packages/bin/x86_64/falco-0.32.0-x86_64.tar.gz</strong></pre>
<p>After downloading the tarball, uncompressing and untarring it is quite simple:</p>
<pre data-type="programlisting">$ <strong>tar -xvf falco-0.32.0-x86_64.tar.gz</strong></pre>
<p>The tarball content, which you’ve just extracted, is intended to be copied directly to the local filesystem’s root (i.e., <em>/</em>), without any special installation procedure. To copy it, run this command as root:</p>
<pre data-type="programlisting">$ <strong>sudo cp -R falco-0.32.0-x86_64/* /</strong></pre>
<p>Now you’re ready to install the driver.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Installing the Driver"><div class="sect2" id="installing_the_driver">
<h2>Installing the Driver</h2>
<p><a contenteditable="false" data-primary="drivers" data-secondary="installing" data-type="indexterm" id="idm45324240086192"/>System calls are Falco’s default data source. To instrument the Linux kernel and collect these system calls, it needs a driver: either a Linux kernel module or an eBPF probe. The driver needs to be built for the specific version and configuration of the kernel on which Falco will run. Fortunately, The Falco Project provides literally thousands of prebuilt drivers for the vast majority of the most common Linux distributions, with various kernel versions available for download. If a prebuilt driver for your distribution and kernel version is not yet available, the files you installed in the previous section include the source code of both the kernel module and the eBPF probe, so it is also possible to build the driver locally.</p>
<p class="pagebreak-after">This might sound like a lot, but the <em>falco-driver-loader</em> script you’ve just installed can do all these steps. All you need to do before using the script is install a few necessary dependencies:</p>
<ul class="less_space">
<li><p>Dynamic Kernel Module Support (dkms)</p></li>
<li><p>GNU make</p></li>
<li><p>The Linux kernel headers</p></li>
</ul>
<p>Depending on the package manager you’re using, the actual package names can vary; however, they aren’t difficult to find. Once you’ve installed these packages, you’re ready to run the <em>falco-driver-loader</em> script as root. If everything goes well, the script output should look something like this:</p>
<pre data-type="programlisting">$ <strong>sudo falco-driver-loader</strong>
* Running falco-driver-loader for: falco version=0.32.0, driver version=39ae...
* Running falco-driver-loader with: driver=module, compile=yes, download=yes
...
* Looking for a falco module locally (kernel 5.18.1-arch1-1)
* Trying to download a prebuilt falco module from https://download.falco.org/...
curl: (22) The requested URL returned error: 404
Unable to find a prebuilt falco module
* Trying to dkms install falco module with GCC /usr/bin/gcc</pre>
<p>This output contains some useful information. The first line reports the versions of Falco and the driver that are being installed. The subsequent line tells us that the script will try to download a prebuilt driver so it can install a kernel module. If the prebuilt driver is not available, Falco will try to build it locally. The rest of the output shows the process of building and installing the module via DKMS, and finally that the module has been installed and loaded.</p>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Starting Falco"><div class="sect2" id="starting_falco">
<h2>Starting Falco</h2>
<p><a contenteditable="false" data-primary="Falco (generally)" data-secondary="starting" data-type="indexterm" id="idm45324238802064"/><a contenteditable="false" data-primary="starting Falco" data-type="indexterm" id="idm45324238800688"/>To start Falco, you just have to run it as root:<sup><a data-type="noteref" id="ch01fn1-marker" href="ch02.xhtml#ch01fn1">1</a></sup></p>
<pre data-type="programlisting">$ <strong>sudo falco</strong>
Mon Jun  6 16:08:29 2022: Falco version 0.32.0 (driver version 39ae7d404967...
Mon Jun  6 16:08:29 2022: Falco initialized with configuration file /etc/fa...
Mon Jun  6 16:08:29 2022: Loading rules from file /etc/falco/falco_rules.yaml:
Mon Jun  6 16:08:29 2022: Loading rules from file /etc/falco/falco_rules.loc...
Mon Jun  6 16:08:29 2022: Starting internal webserver, listening on port 8765</pre>
<p>Note the configuration and rules files’ paths. We’ll look at these in more detail in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.xhtml#installing_falco">9</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch13.xhtml#writing_falco_rules">13</a>. Finally, in the last line, we can see that a web server has been started; this is done because Falco exposes a health check endpoint that you can use to test that it’s up and running.</p>
<div data-type="tip"><h6>Tip</h6>
<p>In this chapter, to get you used to it, we have simply run Falco as an interactive shell process; therefore, a simple Ctrl-C is enough to end the process. Throughout the book, we will show you different and more sophisticated ways to install and run it.</p>
</div>
<p>Once Falco prints this startup information, it is ready to issue a notification whenever a condition in the loaded ruleset is met. Right now, you probably won’t see any notifications (assuming nothing malicious is running on your system). In the next section, we will generate a suspicious event.<a contenteditable="false" data-primary="" data-startref="ch02.html1" data-type="indexterm" id="idm45324238792256"/></p>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Generating Events"><div class="sect1" id="generating_events">
<h1>Generating Events</h1>
<p><a contenteditable="false" data-primary="events" data-secondary="generating" data-type="indexterm" id="ch02.html2"/><a contenteditable="false" data-primary="Falco (generally)" data-secondary="generating events" data-type="indexterm" id="ch02.html3"/>There are millions of ways to generate events. In the case of system calls, in reality, many events happen continuously as soon as processes are running. However, to see Falco in action, we must focus on events that can trigger an alert. As you’ll recall, Falco comes preloaded with an out-of-the-box set of rules that cover the most common security scenarios. It uses rules to express unwanted behaviors, so we need to pick a rule as our target and then trigger it by simulating a malicious action within our system.</p>
<p>In the course of the book, and particularly in <a data-type="xref" href="ch13.xhtml#writing_falco_rules">Chapter 13</a>, you will learn about the complete anatomy of a rule, how to interpret and write a condition using Falco’s rule syntax, and which fields are supported in the conditions and outputs. For the moment, let’s briefly recall what a rule is and explain its structure by considering a real example:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Write below binary dir</code><code class="w"/>
<code class="w">  </code><code class="nt">desc</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">an attempt to write to any file below a set of binary directories</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">bin_dir and evt.dir = &lt; and open_write</code><code class="w"/>
<code class="w">  </code><code class="nt">output</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">File below a known binary directory opened for writing</code><code class="w"/>
<code class="w">    </code><code class="no">(user=%user.name user_loginuid=%user.lo command=%proc.cmdline</code><code class="w"/>
<code class="w">    </code><code class="no">file=%fd.name parent=%proc.pname pcmdline=%proc.pcmdline</code><code class="w"/>
<code class="w">    </code><code class="no">gparent=%proc.aname[2] container_id=%container.id</code><code class="w"/>
<code class="w">    </code><code class="no">image=%container.image.repository)</code><code class="w"/>
<code class="w">  </code><code class="nt">priority</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">ERROR</code><code class="w"/>
<code class="w">  </code><code class="nt">source</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">syscall</code><code class="w"/></pre>
<p><a contenteditable="false" data-primary="rule declaration" data-type="indexterm" id="idm45324238772496"/>A rule declaration is a YAML object with several keys. The first key, <code>rule</code>, uniquely identifies the rule within a <a contenteditable="false" data-primary="rulesets" data-secondary="defined" data-type="indexterm" id="idm45324238757904"/><em>ruleset</em> (one or more YAML files containing rule definitions). <a contenteditable="false" data-primary="desc key" data-type="indexterm" id="idm45324238756224"/>The second key, <code>desc</code>, allows the rule’s author to briefly describe what the rule will detect. <a contenteditable="false" data-primary="condition key" data-type="indexterm" id="idm45324238754544"/>The <code>condition</code> key, arguably the most important one, allows expressing a security assertion using some straightforward syntax. <a contenteditable="false" data-primary="fields" data-type="indexterm" id="idm45324238752736"/>Various Boolean and comparison operators can be combined with <em>fields</em> (which hold the collected data) to filter only relevant events. In this example rule, <code>evt.dir</code> is a field used for filtering. Supported fields and filters are covered in more detail in <a data-type="xref" href="ch06.xhtml#fields_and_filters">Chapter 6</a>.</p>
<p>As long as the condition is false, nothing will happen. The assertion is met when the condition is true, and then an alert will be fired immediately. The alert will contain an informative message, as defined by the rule’s author using the <code>output</code> key of the rule declaration. The value of the <code>priority</code> key will be reported too. The content of an alert is covered in more detail in the next section.</p>
<p>The <code>condition</code>’s syntax can also make use of a few more constructs, like <code>list</code> and <code>macro</code>, that can be defined in the ruleset alongside rules. <a contenteditable="false" data-primary="lists" data-secondary="defined" data-type="indexterm" id="idm45324238746528"/>As the name suggests, a <em>list</em> is a list of items that can be reused across different rules. <a contenteditable="false" data-primary="macros" data-secondary="defined" data-type="indexterm" id="idm45324238677488"/>Similarly, <em>macros</em> are reusable pieces of conditions. For completeness, here are the two macros (<code>bin_dir</code> and <code>open_write</code>) utilized in the <code>condition</code> key of the <em>Write below binary dir</em> rule:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">macro</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">bin_dir</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">fd.directory in (/bin, /sbin, /usr/bin, /usr/sbin)</code><code class="w"/>
<code class="w">  </code>
<code class="p-Indicator">-</code><code class="w"> </code><code class="nt">macro</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">open_write</code><code class="w"/>
<code class="w">  </code><code class="nt">condition</code><code class="p">:</code><code class="w"> </code><code class="p-Indicator">&gt;</code><code class="w"/>
<code class="w">    </code><code class="no">evt.type in (open,openat,openat2) </code><code class="w"/>
<code class="w">    </code><code class="no">and evt.is_open_write=true </code><code class="w"/>
<code class="w">    </code><code class="no">and fd.typechar='f' </code><code class="w"/>
<code class="w">    </code><code class="no">and fd.num&gt;=0</code><code class="w"/></pre>
<p>At runtime, when rules are loaded, macros expand. Consequently, we can imagine the final rule condition will be similar to:</p>
<pre data-type="programlisting">    evt.type in (open,openat,openat2) 
    and evt.is_open_write=true 
    and fd.typechar='f' 
    and fd.num&gt;=0
    and evt.dir = &lt;
    and fd.directory in (/bin, /sbin, /usr/bin, /usr/sbin)</pre>
<p><a contenteditable="false" data-primary="conditions" data-secondary="fields and" data-type="indexterm" id="idm45324238664768"/><a contenteditable="false" data-primary="fields" data-secondary="conditions and" data-type="indexterm" id="idm45324238652448"/>Conditions make extensive use of fields. In this example, you can easily recognize which parts of the condition are fields (<code>evt.type</code>, <code>evt.is_open_write</code>, <code>fd.typechar</code>, <code>evt.dir</code>, <code>fd.num</code>, and <code>fd.directory</code>) since they are followed by a comparison operator (e.g., <code>=</code>, <code>&gt;=</code>, <code>in</code>). Field names contain a dot (<code>.</code>) because fields with a similar context are grouped together in <em>classes</em>. The part before the dot represents the class (for example, <code>evt</code> and <code>fd</code> are classes).</p>
<p class="pagebreak-after">Although you might not thoroughly understand the condition’s syntax yet, you don’t need to at the moment. All you need to know is that creating a file (which implies opening a file for writing) under one of the directories listed within the condition (like <em>/bin</em>) should be enough to trigger the rule’s condition. Let’s try it.</p>
<p>First, start Falco with our target rule loaded. The <em>Write below binary dir</em> rule is included in <em>/etc/falco/falco_rules.yaml</em>, which is loaded by default when starting Falco, so you don’t need to copy it manually. Just open a terminal and run:</p>
<pre data-type="programlisting">$ <strong>sudo falco</strong></pre>
<p>Second, trigger the rule by creating a file in the <em>/bin</em> directory. A straightforward way to do this is by opening another terminal window and typing:</p>
<pre data-type="programlisting">$ <strong>sudo touch /bin/surprise</strong></pre>
<p>Now, if you return to the first terminal with Falco running, you should find a line in the log (that is, an alert emitted by Falco) that looks like the following:</p>
<pre data-type="programlisting">16:52:09.350818073: Error File below a known binary directory opened for writing
  (user=root user_loginuid=1000 command=touch /bin/surprise file=/bin/surprise 
  parent=sudo pcmdline=sudo touch /bin/surprise gparent=zsh container_id=host 
  image=&lt;NA&gt;)</pre>
<p>Falco caught us! Fortunately, that’s exactly what we wanted to happen. (We’ll look at this output in more detail in the next section.)</p>
<p>Rules let us tell Falco which security policies we want to observe (expressed by the <code>condition</code> key) and which information we want to receive (specified by the <code>output</code> key) if a policy has been violated. Falco emits an alert (outputs a line of text) whenever an event meets the condition defined by a rule, so if you run the same command again, a new alert will fire.</p>
<p>After trying out this example, why not test some other rules by yourself? <a contenteditable="false" data-primary="event-generator tool" data-type="indexterm" id="idm45324239474352"/>To facilitate this, the Falcosecurity organization offers a tool called <em>event-generator</em>. It’s a simple command-line tool that does not require any special installation steps. You can <a href="https://oreil.ly/CZGpM">download the latest release</a> and uncompress it wherever you prefer. It comes with a collection of events that match many of the rules included in the default Falco ruleset. For example, to generate an event that meets the condition expressed by the <em>Read sensitive file untrusted</em> rule, you can type the following in a terminal window:</p>
<pre data-type="programlisting">$ <strong>./event-generator run syscall.ReadSensitiveFileUntrusted</strong></pre>
<div data-type="warning" epub:type="warning"><h6>Warning</h6>
<p>Be aware that this tool might alter your system. For example, since the tool’s purpose is to reproduce real malicious behavior, some actions modify files and directories such as <em>/bin</em>, <em>/etc</em>, and <em><span class="keep-together">/dev</span></em>. Make sure you fully understand the purpose of this tool and its options before using it. As the <a href="https://oreil.ly/dL8gV">online documentation</a> recommends, running event-generator in a container is safer.<a contenteditable="false" data-primary="" data-startref="ch02.html3" data-type="indexterm" id="idm45324239466448"/><a contenteditable="false" data-primary="" data-startref="ch02.html2" data-type="indexterm" id="idm45324239465072"/></p>
</div>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Interpreting Falco’s Output"><div class="sect1" id="interpreting_falcoapostrophes_output">
<h1>Interpreting Falco’s Output</h1>
<p><a contenteditable="false" data-primary="Falco (generally)" data-secondary="interpreting output" data-type="indexterm" id="ch02.html4"/><a contenteditable="false" data-primary="outputs" data-secondary="interpreting" data-type="indexterm" id="ch02.html5"/>Let’s take a closer look at the alert notification our experiment produced to see what important information it contains:</p>
<pre data-type="programlisting">16:52:09.350818073: Error File below a known binary directory opened for writing 
  (user=root user_loginuid=1000 command=touch /bin/surprise file=/bin/surprise 
  parent=sudo pcmdline=sudo touch /bin/surprise gparent=zsh container_id=host 
  image=&lt;NA&gt;)</pre>
<p>This apparently complex line is actually composed of only three main elements separated by whitespace: a timestamp, severity level, and message. Let’s examine each of these:</p>
<dl>
<dt>Timestamp</dt>
<dd><p><a contenteditable="false" data-primary="timestamps" data-type="indexterm" id="idm45324239455200"/>Intuitively, the first element is the timestamp (followed by a colon: <code>16:52:09.350818073:</code>). That’s when the event was generated. By default, it’s displayed in the local time zone and includes nanoseconds. You can, if you like,  configure Falco to display times in ISO 8601 format, including the date, nanoseconds, and timezone offset (in UTC).</p></dd>
<dt>Severity</dt>
<dd><p><a contenteditable="false" data-primary="severity level, in alter notifications" data-type="indexterm" id="idm45324239452416"/>The second element indicates the severity (e.g., <code>Error</code>) of the alert, as specified by the <code>priority</code> key in the rule. It can assume one of the following values (ordered from the most to the least severe): <code>Emergency</code>, <code>Alert</code>, <code>Critical</code>, <code>Error</code>, <code>Warning</code>, <code>Notice</code>, <code>Informational</code>, or <code>Debug</code>. Falco allows us to filter out those alerts that are not important to us and thus reduce the noisiness of the output by specifying the minimum severity level we want to get alerts about. The default is <code>debug</code>, meaning all severity levels are included by default, but we can change this by altering the value of the <code>priority</code> parameter in the <em>/etc/falco/falco.yaml</em> configuration file. For example, if we change the value of this parameter to <code>notice</code>, then we will not receive alerts about rules with <code>priority</code> equal to <code>INFORMATIONAL</code> or <code>DEBUG</code>.</p></dd>
<dt>Message</dt>
<dd><p><a contenteditable="false" data-primary="message, in alert notifications" data-type="indexterm" id="idm45324239442560"/>The last and the most essential element is the message. This is a string produced according to the format specified by the <code>output</code> key. Its peculiarity lies in using placeholders, which the Falco engine replaces with the event data, as we will see in a moment.</p>
<p>Normally, the <code>output</code> key of a rule begins with a brief text description to facilitate identifying the type of problem (e.g., <code>File below a known binary directory opened for writing</code>). Then it includes some placeholders (e.g., <code>%user.name</code>), which will be populated with actual values (e.g., <code>root</code>) when outputted. You can easily recognize placeholders since they start with a <code>%</code> symbol followed by one of the event’s supported fields. These fields can be used in both the <code>condition</code> key and the <code>output</code> key of a Falco rule.</p></dd>
</dl>
<p>The beauty of this feature is that you can have a different output format for each security policy. This immediately gives you the most relevant information related to the violation, without having to navigate hundreds of fields.</p>
<p>Although this textual format likely includes all the information you need and is suitable for consumption by many other programs, it’s not the only option for output—you can instruct Falco to output notifications in JSON format by simply changing a configuration parameter. The JSON output format has the advantage of being easily parsable by consumers. When enabled, Falco will emit as output a JSON line for each alert that will look like the following, which we’ve pretty-printed to improve readability:</p>
<pre data-type="programlisting" data-code-language="json"><code class="p">{</code><code class="w"/>
<code class="w">  </code><code class="nt">"output"</code><code class="p">:</code><code class="w"> </code><code class="s2">"11:55:33.844042146: Error File below a known binary directory..."</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"priority"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Error"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"rule"</code><code class="p">:</code><code class="w"> </code><code class="s2">"Write below binary dir"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"time"</code><code class="p">:</code><code class="w"> </code><code class="s2">"2021-09-13T09:55:33.844042146Z"</code><code class="p">,</code><code class="w"/>
<code class="w">  </code><code class="nt">"output_fields"</code><code class="p">:</code><code class="w"> </code><code class="p">{</code><code class="w"/>
<code class="w">    </code><code class="nt">"container.id"</code><code class="p">:</code><code class="w"> </code><code class="s2">"host"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"container.image.repository"</code><code class="p">:</code><code class="w"> </code><code class="kc">null</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"evt.time"</code><code class="p">:</code><code class="w"> </code><code class="mi">1631526933844042146</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"fd.name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"/bin/surprise"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"proc.aname[2]"</code><code class="p">:</code><code class="w"> </code><code class="s2">"zsh"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"proc.cmdline"</code><code class="p">:</code><code class="w"> </code><code class="s2">"touch /bin/surprise"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"proc.pcmdline"</code><code class="p">:</code><code class="w"> </code><code class="s2">"sudo touch /bin/surprise"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"proc.pname"</code><code class="p">:</code><code class="w"> </code><code class="s2">"sudo"</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"user.loginuid"</code><code class="p">:</code><code class="w"> </code><code class="mi">1000</code><code class="p">,</code><code class="w"/>
<code class="w">    </code><code class="nt">"user.name"</code><code class="p">:</code><code class="w"> </code><code class="s2">"root"</code><code class="w"/>
<code class="w">  </code><code class="p">}</code><code class="w"/>
<code class="p">}</code><code class="w"/></pre>
<p>This output format reports the same text message as before. Additionally, each piece of information is separated into distinct JSON properties. You may also have noticed some extra data: for example, the rule identifier is present this time (<code>"rule": "Write below binary dir"</code>).</p>
<p>To try it right now, when starting Falco, simply pass the following flag as a command-line argument to override the default configuration:</p>
<pre data-type="programlisting">$ <strong>sudo falco -o json_output=true</strong></pre>
<p>Alternatively, you can edit <em>/etc/falco/falco.yaml</em> and set <code>json_output</code> to <code>true</code>. This will enable the JSON format every time Falco starts, without the flag.<a contenteditable="false" data-primary="" data-startref="ch02.html5" data-type="indexterm" id="idm45324228631616"/><a contenteditable="false" data-primary="" data-startref="ch02.html4" data-type="indexterm" id="idm45324228630240"/></p>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Customizing Your Falco Instance"><div class="sect1" id="customizing_your_falco_instance">
<h1>Customizing Your Falco Instance</h1>
<p><a contenteditable="false" data-primary="Falco (generally)" data-secondary="customizing instances" data-type="indexterm" id="ch02.html6"/><a contenteditable="false" data-primary="instances, customizing" data-type="indexterm" id="ch02.html7"/>When you start Falco, it loads several files. In particular, it first loads the main (and only) configuration file, as the startup log shows:</p>
<pre data-type="programlisting">Falco initialized with configuration file /etc/falco/falco.yaml</pre>
<p>Falco looks for its configuration file at <em>/etc/falco/falco.yaml</em>, by default. That’s where the provided configuration file is installed. If desired, you can specify another configuration file path using the <code>-c</code> command-line argument when running Falco. Whatever file location you prefer, the configuration must be a YAML file mainly containing a collection of key/value pairs. Let’s take a look at some of the available configuration options.</p>
<section data-type="sect2" data-pdf-bookmark="Rules Files"><div class="sect2" id="rules_files">
<h2>Rules Files</h2>
<p><a contenteditable="false" data-primary="instances, customizing" data-secondary="rules files" data-type="indexterm" id="idm45324228571776"/><a contenteditable="false" data-primary="rules files" data-type="indexterm" id="idm45324228570560"/>One of the most essential options, and the first you’ll find in the provided configuration file, is the list of rules files to be loaded:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">rules_file</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/falco/falco_rules.yaml</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/falco/falco_rules.local.yaml</code><code class="w"/>
<code class="w">  </code><code class="p-Indicator">-</code><code class="w"> </code><code class="l-Scalar-Plain">/etc/falco/rules.d</code><code class="w"/></pre>
<p>Despite the naming (for backward compatibility), <code>rules_file</code> allows you to specify multiple entries, each of which can be either a rules file or a directory containing rules files. If the entry is a file, Falco reads it directly. In the case of a directory, Falco will read every file in that directory.</p>
<p>The order matters here. The files are loaded in the presented order (files within a directory are loaded in alphabetical order). Users can customize predefined rules by simply overriding them in files that appear later in the list. For example, say you want to turn off the <em>Write below binary dir</em> rule, which is included in <em>/etc/falco/falco_rules.yaml</em>. All you need to do is edit <em>/etc/falco/falco_rules.local.yaml</em> (which appears below that file in the list and is intended to add local overrides) and write:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="p-Indicator">-</code><code class="w"> </code><code class="nt">rule</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">Write below binary dir</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/></pre>
</div></section>
<section data-type="sect2" data-pdf-bookmark="Output Channels"><div class="sect2" id="output_channels">
<h2>Output Channels</h2>
<p class="pagebreak-after"><a contenteditable="false" data-primary="instances, customizing" data-secondary="output channels" data-type="indexterm" id="idm45324228539792"/><a contenteditable="false" data-primary="output channels" data-type="indexterm" id="idm45324228538416"/>There is a group of options that control Falco’s available <em>output channels</em>, allowing you to specify where the security notifications should go. Furthermore, you can enable more than one simultaneously. You can easily recognize them within the configuration file (<em>/etc/falco/falco.yaml</em>) since their keys are suffixed with <code>_output</code>.</p>
<p>By default, the only two enabled output channels are <code>stdout_output</code>, which instructs Falco to send alert messages to the standard output, and <code>syslog_output</code>, which sends them to the system logging daemon. Their configurations are:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">stdout_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/>
<code class="w">  </code>
<code class="nt">syslog_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">true</code><code class="w"/></pre>
<p>Falco provides several other advanced built-in output channels. For example:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">file_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">keep_alive</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">filename</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">./events.txt</code><code class="w"/></pre>
<p>When <code>file_output</code> is enabled, Falco will also write its alerts to the file specified by the subkey <code>filename</code>.</p>
<p>Other output channels allow you to consume alerts in sophisticated ways and integrate with third parties. For instance, if you want to pass the Falco output to a local program, you can use:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">program_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">keep_alive</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">program</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">mail -s "Falco Notification" someone@example.com</code><code class="w"/></pre>
<p>Once you enable this, Falco will execute the program for each alert and write its content to the program’s standard output. You can set the <code>program</code> subkey to any valid shell command, so this is an excellent opportunity to show off your favorite one-liners.</p>
<p>If you simply need to integrate with a webhook, a more convenient option is to use the <code>http_output</code> output channel:</p>
<pre data-type="programlisting" data-code-language="yaml"><code class="nt">http_output</code><code class="p">:</code><code class="w"/>
<code class="w">  </code><code class="nt">enabled</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">false</code><code class="w"/>
<code class="w">  </code><code class="nt">url</code><code class="p">:</code><code class="w"> </code><code class="l-Scalar-Plain">http://some.url</code><code class="w"/></pre>
<p>A simple HTTP POST request will be sent to the specified <code>url</code> for each alert. That makes it really easy to connect Falco to other tools, like Falcosidekick, which will forward alerts to Slack, Teams, Discord, Elasticsearch, and many other destinations.</p>
<p><a contenteditable="false" data-primary="gRPC API" data-type="indexterm" id="idm45324228367744"/>Last but not least, Falco comes with a gRPC API and a corresponding output, <code>grpc_output</code>. Enabling the gRPC API and gRPC output channel allows you to connect Falco to falco-exporter<em>,</em> which, in turn, will export metrics to Prometheus.</p>
<div data-type="note" epub:type="note"><h6>Note</h6>
<p>Falcosidekick and falco-exporter are open source projects you can find under the <a href="https://oreil.ly/CF0Bk">Falcosecurity GitHub organization</a>. In <a data-type="xref" href="ch12.xhtml#consuming_falco_events">Chapter 12</a>, you will meet these tools again and learn how to work with <span class="keep-together">outputs.</span><a contenteditable="false" data-primary="" data-startref="ch02.html7" data-type="indexterm" id="idm45324228325568"/><a contenteditable="false" data-primary="" data-startref="ch02.html6" data-type="indexterm" id="idm45324228324192"/></p>
</div>
</div></section>
</div></section>
<section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion-id000001">
<h1>Conclusion</h1>
<p>This chapter showed you how to install and run Falco on your local machine as a playground. You saw some simple ways to generate events and learned how to decode the output. We then looked at how to use the configuration file to customize Falco’s behavior. Loading and extending rules are the primary ways to instruct Falco on what to protect. Likewise, configuring the output channels empowers us to consume notifications in ways that meet our needs.</p>
<p>Armed with this knowledge, you can start experimenting with Falco confidently. The rest of this book will expand on you’ve learned here and eventually help you master Falco completely.<a contenteditable="false" data-primary="" data-startref="ch02.html0" data-type="indexterm" id="idm45324228320704"/></p>
</div></section>
<div data-type="footnotes"><p data-type="footnote" id="ch01fn1"><sup><a href="ch02.xhtml#ch01fn1-marker">1</a></sup> Falco needs to run with root privileges to operate the driver that in turn collects system calls. However, alternative approaches are possible. For example, you can learn from Falco’s <a href="https://oreil.ly/6VD67">“Running” page</a> how to run Falco in a container with the principle of least privilege.</p></div></div></section></div></body></html>