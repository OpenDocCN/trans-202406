- en: Chapter 8\. Running Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have a tough question that you can’t answer, start by tackling a simpler
    question that you can’t answer.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Max Tegmark
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In previous chapters, we’ve focused mostly on the operational aspects of Kubernetes:
    where to get your clusters, how to maintain them, and how to manage your cluster
    resources. Let’s turn now to the most fundamental Kubernetes object: the *container*.
    We’ll look at how containers work on a technical level, how they relate to Pods,
    and how to deploy container images to Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll also cover the important topic of container security,
    and how to use the security features in Kubernetes to deploy your applications
    in a secure way, according to best practices. Finally, we’ll look at how to mount
    disk volumes on Pods, allowing containers to share and persist data.
  prefs: []
  type: TYPE_NORMAL
- en: Containers and Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We’ve already introduced Pods in [Chapter 2](ch02.html#firststeps), and talked
    about how Deployments use ReplicaSets to maintain a set of replica Pods, but we
    haven’t really looked at Pods themselves in much detail. Pods are the unit of
    scheduling in Kubernetes. A Pod object represents a container or group of containers,
    and everything that runs in Kubernetes does so by means of a Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: A Pod represents a collection of application containers and volumes running
    in the same execution environment. Pods, not containers, are the smallest deployable
    artifact in a Kubernetes cluster. This means all of the containers in a Pod always
    land on the same machine.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kelsey Hightower et al., *Kubernetes Up & Running*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'So far in this book the terms *Pod* and *container* have been used more or
    less interchangeably: the demo application Pod only has one container in it. In
    more complex applications, though, it’s quite likely that a Pod will include two
    or more containers. So let’s look at how that works, and see when and why you
    might want to group containers together in Pods.'
  prefs: []
  type: TYPE_NORMAL
- en: What Is a Container?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before asking why you might want to have multiple containers in a Pod, let’s
    take a moment to revisit what a container actually is.
  prefs: []
  type: TYPE_NORMAL
- en: 'You know from [“The Coming of Containers”](ch01.html#containers-intro) that
    a container is a standardized package that contains a piece of software together
    with its dependencies, configuration, data, and so on: everything it needs to
    run. How does that actually work, though?'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux, and most other operating systems, everything that runs on a machine
    does so by means of a *process*. A process represents the binary code and memory
    state of a running application, such as Chrome, `top`, or Visual Studio Code.
    All processes exist in the same global namespace: they can all see and interact
    with each other, they all share the same pool of resources, such as CPU, memory,
    and filesystem. (A Linux namespace is a bit like a Kubernetes namespace, though
    not the same thing technically.)'
  prefs: []
  type: TYPE_NORMAL
- en: From the operating system’s point of view, a container represents an isolated
    process (or group of processes) that exists in its own namespace. Processes inside
    the container can’t see processes outside it, and vice versa. A container can’t
    access resources belonging to another container, or processes outside of a container.
    The container boundary is like a ring-fence that stops processes running wild
    and using up each other’s resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'As far as the process inside the container is concerned, it’s running on its
    own machine, with complete access to all its resources, and there are no other
    processes running. You can see this if you run a few commands inside a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Normally, the `ps ax` command will list all processes running on the machine,
    and there are usually a lot of them (a few hundred on a typical Linux server).
    But there are only two processes shown here: `/bin/sh`, and `ps ax`. The only
    processes visible inside the container, therefore, are the ones actually running
    in the container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the `hostname` command, which would normally show the name of the
    host machine, returns `busybox`: in fact, this is the name of the container. So
    it looks to the `busybox` container as if it’s running on a machine called `busybox`,
    and it has the whole machine to itself. This is true for each of the containers
    running on the same machine.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: It’s a fun exercise to create a container yourself, without the benefit of a
    container runtime like Docker. Liz Rice’s excellent talk on [“What is a Container,
    Really?”](https://oreil.ly/KRMP7) shows how to do this from scratch in a Go program.
  prefs: []
  type: TYPE_NORMAL
- en: Container Runtimes in Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned in [Chapter 3](ch03.html#gettingk8s), Docker is not the only
    way to run containers. In fact, in December 2020, the maintainers [announced](https://oreil.ly/D8jVd)
    that the Docker runtime in Kubernetes will be deprecated and replaced with alternatives
    that use the [Container Runtime Interface (CRI)](https://oreil.ly/K5qJw). This
    does not mean that Docker containers will no longer work in Kubernetes in the
    future, nor does it mean that Docker will cease to be a useful tool for interacting
    with containers outside of the context of Kubernetes. As long as a container conforms
    to the standards defined by the [Open Container Initiative (OCI)](https://oreil.ly/OXs0C)
    then it should run in Kubernetes, and containers built using Docker do meet these
    standards. You can read more about this change, and the impact, in [“Dockershim
    Removal FAQ” on the Kubernetes blog](https://oreil.ly/PMTXH).
  prefs: []
  type: TYPE_NORMAL
- en: What Belongs in a Container?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There’s no technical reason why you can’t run as many processes as you want
    to inside a container: you could run a complete Linux distribution, with multiple
    running applications, network services, and so on, all inside the same container.
    This is why you sometimes hear containers referred to as *lightweight virtual
    machines*. But this isn’t the best way to use containers, because then you don’t
    get the benefits of resource isolation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If processes don’t need to know about each other, then they don’t need to run
    in the same container. A good rule of thumb with a container is that it should
    *do one thing*. For example, our demo application container listens on a network
    port, and sends the string `Hello, 世界` to anyone who connects to it. That’s a
    simple, self-contained service: it doesn’t rely on any other programs or services,
    and in turn, nothing relies on it. It’s a perfect candidate for having its own
    container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A container also has an *entrypoint*: a command that is run when the container
    starts. That usually results in the creation of a single process to run the command,
    though some applications often start a few subprocesses to act as helpers or workers.
    To start multiple separate processes in a container, you’d need to write a wrapper
    script to act as the entrypoint, which would in turn start the processes you want.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Each container should run just one main process. If you’re running a large group
    of unrelated processes in a container, you’re not taking full advantage of the
    power of containers, and you should think about splitting your application up
    into multiple, communicating containers.
  prefs: []
  type: TYPE_NORMAL
- en: What Belongs in a Pod?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know what a container is, you can see why it’s useful to group
    them together in Pods. A Pod represents a group of containers that need to communicate
    and share data with each other; they need to be scheduled together, they need
    to be started and stopped together, and they need to run on the same physical
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good example of this is an application that stores data in a local cache,
    such as [Memcached](https://memcached.org/about). You’ll need to run two processes:
    your application, and the `memcached` server process that handles storing and
    retrieving data. Although you could run both processes inside a single container,
    that’s unnecessary—they only need to communicate via a network socket. Better
    to split them into two separate containers, each of which only needs to worry
    about building and running its own process.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use a public Memcached container image, [available from Docker Hub](https://hub.docker.com/_/memcached),
    which is already set up to work as part of a Pod with another container.
  prefs: []
  type: TYPE_NORMAL
- en: 'So you create a Pod with two containers: Memcached, and your application. The
    application can talk to Memcached by making a network connection, and because
    the two containers are in the same Pod, that connection will always be local:
    the two containers will always run on the same node.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, imagine a web application, which consists of a web server container,
    such as NGINX, and a blog application that generates HTML webpages, files, images,
    and so on. The blog container writes data to disk, and because containers in a
    Pod can share a disk volume, the data can also be available to the NGINX container
    to serve over HTTP. You can find such an example on the [Kubernetes docs site](https://oreil.ly/Jpueo).
  prefs: []
  type: TYPE_NORMAL
- en: In general, the right question to ask yourself when designing Pods is, “Will
    these containers work correctly if they land on different machines?” If the answer
    is “no,” a Pod is the correct grouping for the containers. If the answer is “yes,”
    multiple Pods is the probably the correct solution.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Kelsey Hightower et al., *Kubernetes Up & Running*
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'The containers in a Pod should all be working together to do one job. If you
    only need one container to do that job, fine: use one container. If you need two
    or three, that’s OK. If you have more than that, you might want to think about
    whether the containers could actually be split into separate Pods.'
  prefs: []
  type: TYPE_NORMAL
- en: Container Manifests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve outlined what containers are, what should go in a container, and when
    containers should be grouped together in Pods. So how do we actually run a container
    in Kubernetes?
  prefs: []
  type: TYPE_NORMAL
- en: 'When you created your first Deployment, in [“Deployment Manifests”](ch04.html#deploymentmanifests),
    it contained a `template.spec` section specifying the container to run (only one
    container, in that example):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of what the `template.spec` section for a Deployment with
    two containers would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The only required fields in each container’s spec are the `name` and `image`:
    a container has to have a name, so that other resources can refer to it, and you
    have to tell Kubernetes what image to run in the container.'
  prefs: []
  type: TYPE_NORMAL
- en: Image Identifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve already used some different container image identifiers so far in this
    book; for example, `cloudnatived/demo:hello`, `alpine` and `busybox:1.28`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are actually four different parts to an image identifier: the *registry
    hostname*, the *repository namespace*, the *image repository*, and the *tag*.
    All but the image name are optional. An image identifier using all of those parts
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker.io/cloudnatived/demo:hello`'
  prefs: []
  type: TYPE_NORMAL
- en: The registry hostname in this example is `docker.io`; in fact, that’s the default
    for Docker images, so we don’t need to specify it. If your image is stored in
    another registry, though, you’ll need to give its hostname. For example, Google
    Container Registry images are prefixed by `gcr.io`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The repository namespace is `cloudnatived`: that’s us (hello!). If you don’t
    specify the repository namespace, then the default namespace (called `library`)
    is used. This is a set of [official images](https://oreil.ly/nCHJn), which are
    approved and maintained by Docker, Inc. Popular official images include OS base
    images (`alpine`, `ubuntu`, `debian`, `centos`), language environments (`golang`,
    `python`, `ruby`, `php`, `java`), and widely used software (`mongo`, `mysql`,
    `nginx`, `redis`).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The image repository is `demo`, which identifies a particular container image
    within the registry and namespace. (See also [“Container Digests”](#digests).)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tag is `hello`. Tags identify different versions of the same image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It’s up to you what tags to put on a container: some common choices include:'
  prefs: []
  type: TYPE_NORMAL
- en: A semantic version tag, like `v1.3.0`. This usually refers to the version of
    the application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Git SHA tag, like `5ba6bfd...`. This identifies the specific commit in the
    source repo that was used to build the container (see [“Git SHA Tags”](ch14.html#gitshatags)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The environment it represents, such as `staging` or `production`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add as many tags as you want to a given image.
  prefs: []
  type: TYPE_NORMAL
- en: The latest Tag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you don’t specify a tag when pulling an image, the default tag for Docker
    images is `latest`. For example, when you run an `alpine` image with no tag specified,
    you’ll get `alpine:latest`.
  prefs: []
  type: TYPE_NORMAL
- en: The `latest` tag is a default tag that’s added to an image when you build or
    push it without specifying a tag. It doesn’t necessarily identify the most recent
    image, just the most recent image that wasn’t explicitly tagged. This makes `latest`
    [rather unhelpful](https://oreil.ly/cVp7N) as an identifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s why it’s important to always use a specific tag when deploying production
    containers to Kubernetes. When you’re just running a quick one-off container for
    troubleshooting or experimentation, like the `alpine` container, it’s fine to
    omit the tag and get the latest image. For real applications, though, you want
    to make sure that if you deploy the Pod tomorrow, you’ll get the exact same container
    image as when you deployed it today:'
  prefs: []
  type: TYPE_NORMAL
- en: You should avoid using the `latest` tag when deploying containers in production
    as it is harder to track which version of the image is running, and more difficult
    to roll back properly.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[The Kubernetes documentation](https://oreil.ly/ZmTBp)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Container Digests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we’ve seen, the `latest` tag doesn’t always mean what you think it will,
    and even a semantic version or Git SHA tag doesn’t uniquely and permanently identify
    a particular container image. If the maintainer decides to push a different image
    with the same tag, the next time you deploy, you’ll get that updated image. In
    technical terms, a tag is *nondeterministic*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes it’s desirable to have *deterministic* deployments: in other words,
    to guarantee that a deployment will always reference the exact container image
    you specified. You can do this using the container’s *digest*: a cryptographic
    hash of the image’s contents that immutably identifies that image.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Images can have many tags, but only one digest. This means that if your container
    manifest specifies the image digest, you can guarantee deterministic deployments.
    An image identifier with a digest looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`cloudnatived/demo@sha256:aeae1e551a6cbd60bcfd56c3b4ffec732c45b8012b7cb758c6c4a34...`'
  prefs: []
  type: TYPE_NORMAL
- en: Base Image Tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you reference a base image in a Dockerfile, if you do not specify a tag,
    you will get `latest`, just as you do when running a container. This can be confusing
    if one day your builds stop working and you find out that the `latest` image you
    were using now points to a different version of the image that introduces some
    breaking change to your application.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, you may want to use a more specific tag for the base images
    on your `FROM` lines in your Dockerfile. But which tag should you use? Or should
    you use an exact digest? This largely depends on your development situation and
    preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s use the [official Python image](https://oreil.ly/VOII3) on Docker Hub
    as an example. You have the option of using `python:3`, `python:3.9`, `python:3.9.7`,
    or many other variations of version tags, and also different base operating systems
    like Windows, Alpine, and Debian.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of using a less-specific tag, such as `python:3`, is that you
    will automatically be pulling in any updates and security patches, along with
    whichever is the newest minor release version of Python 3 every time you build
    a new image. The downside is that sometimes these updates could cause issues if
    something like a system package gets renamed or removed. Your application may
    work perfectly fine on Python 3.9, but then start failing from changes introduced
    in a new 3.10 release if you build a new image and do not realize that your base
    image `python:3` actually moved from 3.9 to 3.10.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a more specific tag, such as `python:3.9.7`, your base image is less
    likely to change unexpectedly. However, you will need to pay attention and manually
    update your Dockerfile when there is a new version available so that you can pull
    in those important security and bug fixes. You may prefer this style of development
    where you have greater control of your builds, but it is important to regularly
    check for updates to your base images so that they do not lag behind, as they
    will be missing security fixes that have been pushed up by the maintainers.
  prefs: []
  type: TYPE_NORMAL
- en: The image tag you use will largely depend on your team preferences, release
    cadence, and development style. You should weigh the pros and cons of whichever
    tag system you choose and check in regularly to ensure that you have a process
    that provides reasonably reliable builds with regular updates at a sustainable
    pace.
  prefs: []
  type: TYPE_NORMAL
- en: Ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You’ve already seen the `ports` field used with our demo application back in
    [“Service Resources”](ch04.html#services). It specifies the network port numbers
    the application will listen on, and can be matched up with, a [Service](https://oreil.ly/N3EvV)
    for routing requests to the container.
  prefs: []
  type: TYPE_NORMAL
- en: Resource Requests and Limits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already covered resource requests and limits for containers in detail,
    in [Chapter 5](ch05.html#resources), so a brief recap here will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each container can supply one or more of the following as part of its spec:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources.requests.cpu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.requests.memory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.limits.cpu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`resources.limits.memory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although requests and limits are specified on individual containers, we usually
    talk in terms of the Pod’s total resource requests and limits. A Pod’s resource
    request is the sum of the resource requests for all containers in that Pod, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Image Pull Policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before a container can be run on a node, the image has to be *pulled*, or downloaded,
    from the appropriate container registry. The `imagePullPolicy` field on a container
    governs how often Kubernetes will do this. It can take one of three values: `Always`,
    `IfNotPresent`, or `Never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Always` will pull the image every time the container is started. Assuming
    that you specify a tag—which you should (see [“The latest Tag”](#latesttag))—then
    this is probably unnecessary, and could be wasting time and bandwidth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IfNotPresent`, the default, is correct for most situations. If the image is
    not already present on the node, it will be downloaded. After that, unless you
    change the image spec, the saved image will be used every time the container starts,
    and Kubernetes will not attempt to redownload it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Never` will never update the image at all. With this policy, Kubernetes will
    never fetch the image from a registry: if it’s already present on the node, it
    will be used, but if it’s not, the container will fail to start. You’re unlikely
    to want this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you run into strange problems (for example, a Pod not updating when you’ve
    pushed a new container image), check your image pull policy.
  prefs: []
  type: TYPE_NORMAL
- en: Environment Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Environment variables are a common, if limited, way to pass information to
    containers at runtime. Common, because all Linux executables have access to environment
    variables, and even programs that were written long before containers existed
    can use their environment for configuration. Limited, because environment variables
    can only be string values: no arrays, no keys and values, no structured data in
    general. The total size of a process’s environment is also limited to 32 KiB,
    so you can’t pass large data files in the environment.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To set an environment variable, list it in the container’s `env` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: If the container image itself specifies environment variables (set in the Dockerfile,
    for example), then the Kubernetes `env` settings will override them. This can
    be useful for altering the default configuration of a container.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'A more flexible way of passing configuration data to containers is to use a
    Kubernetes ConfigMap or Secret object: see [Chapter 10](ch10.html#config) for
    more about these.'
  prefs: []
  type: TYPE_NORMAL
- en: Container Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might have noticed in [“What Is a Container?”](#whatsacontainer) that when
    we looked at the process list in the container with the `ps ax` command, the processes
    were all running as the root user. In Linux and other Unix-derived operating systems,
    `root` is the superuser, which has privileges to read any data, modify any file,
    and perform any operation on the system.
  prefs: []
  type: TYPE_NORMAL
- en: While on a full Linux system some processes need to run as `root` (for example
    `init`, which manages all other processes), that’s not usually the case with a
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, running processes as the root user when you don’t need to is a bad idea.
    It contravenes the [*principle of least privilege*](https://oreil.ly/Q5h79). This
    says that a program should only be able to access the information and resources
    that it actually needs to do its job.
  prefs: []
  type: TYPE_NORMAL
- en: Programs have bugs—this is a fact of life apparent to anyone who’s written one.
    Some bugs allow malicious users to hijack the program to do things it’s not supposed
    to, like read secret data or execute arbitrary code. To mitigate this, it’s important
    to run containers with the minimum possible privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'This starts with not allowing them to run as `root`, but instead assigning
    them an *ordinary* user: one that has no special privileges, such as reading other
    users’ files:'
  prefs: []
  type: TYPE_NORMAL
- en: Just like you wouldn’t (or shouldn’t) run anything as root on your server, you
    shouldn’t run anything as root in a container on your server. Running binaries
    that were created elsewhere requires a significant amount of trust, and the same
    is true for binaries in containers.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '[Marc Campbell](https://oreil.ly/RlmNm)'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: It’s also possible for attackers to exploit bugs in the container runtime to
    “escape” from the container, and get the same powers and privileges on the host
    machine that they did in the container.
  prefs: []
  type: TYPE_NORMAL
- en: Running Containers as a Non-Root User
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here’s an example of a container spec that tells Kubernetes to run the container
    as a specific user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The value for `runAsUser` is a *UID* (a numerical user identifier). On many
    Linux systems, UID 1000 is assigned to the first non-root user created on the
    system, so it’s generally safe to choose values of 1000 or above for container
    UIDs. It doesn’t matter whether or not a Unix user with that UID *exists* in the
    container, or even if there is an operating system in the container; this works
    just as well with scratch containers.
  prefs: []
  type: TYPE_NORMAL
- en: If a `runAsUser` UID is specified, it will override any user configured in the
    container image. If there is no `runAsUser`, but the container specifies a user,
    Kubernetes will run it as that user. If no user is specified either in the manifest
    or the image, the container will run as `root` (which, as we’ve seen, is a bad
    idea).
  prefs: []
  type: TYPE_NORMAL
- en: For maximum security, you should choose a different UID for each container.
    That way, if a container should be compromised somehow, or accidentally overwrite
    data, it only has permission to access its own data, and not that of other containers.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, if you want two or more containers to be able to access the
    same data (via a mounted volume, for example), you should assign them the same
    UID.
  prefs: []
  type: TYPE_NORMAL
- en: Blocking Root Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help prevent this situation, Kubernetes allows you to block containers from
    running if they would run as the root user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `runAsNonRoot: true` setting will do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: When Kubernetes runs this container, it will check to see if the container wants
    to run as root. If so, it will refuse to start it. This will protect you against
    forgetting to set a non-root user in your containers, or running third-party containers
    that are configured to run as root.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this happens, you’ll see the Pod status shown as `CreateContainerConfigError`,
    and when you `kubectl describe` the Pod, you’ll see this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Best Practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Run containers as non-root users, and block root containers from running, using
    the `runAsNonRoot: true` setting.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting a Read-Only Filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another useful security context setting is `readOnlyRootFilesystem`, which
    will prevent the container from writing to its own filesystem. It’s possible to
    imagine a container taking advantage of a bug in Docker or Kubernetes, for example,
    where writing to its filesystem could affect files on the host node. If its filesystem
    is read-only, that can’t happen; the container will get an I/O error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Many containers don’t need to write anything to their own filesystem, so this
    setting won’t interfere with them. It’s [good practice](https://oreil.ly/JGiKP)
    to always set `readOnlyRootFilesystem` unless the container really does need to
    write to files.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling Privilege Escalation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Normally, Linux binaries run with the same privileges as the user that executes
    them. There is an exception, though: binaries that use the `setuid` mechanism
    can temporarily gain the privileges of the user that *owns* the binary (usually
    `root`).'
  prefs: []
  type: TYPE_NORMAL
- en: This is a potential problem in containers, since even if the container is running
    as a regular user (UID 1000, for example), if it contains a `setuid` binary, that
    binary can gain root privileges by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this, set the `allowPrivilegeEscalation` field of the container’s
    security policy to `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Modern Linux programs don’t need `setuid`; they can use a more flexible and
    fine-grained privilege mechanism called *capabilities* to achieve the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: Capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, Unix programs had two levels of privileges: *normal* and *superuser*.
    Normal programs have no more privileges than the user who runs them, while superuser
    programs can do anything, bypassing all kernel security checks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Linux capabilities mechanism improves on this by defining various specific
    things that a program can do: load kernel modules, perform direct network I/O
    operations, access system devices, and so on. Any program that needs a specific
    privilege can be granted it, but no others.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, a web server that listens on port 80 would normally need to run
    as `root` to do this; port numbers below 1024 are considered privileged *system*
    ports. Instead, the program can be granted the `NET_BIND_SERVICE` capability,
    which allows it to bind to any port, but gives it no other special privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default set of capabilities for Docker containers is fairly generous. This
    is a pragmatic decision based on a trade-off of security against usability: giving
    containers *no* capabilities by default would require operators to set capabilities
    on many containers in order for them to run.'
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the principle of least privilege says that a container should
    have no capabilities it doesn’t need. Kubernetes security contexts allow you to
    drop any capabilities from the default set and add ones as they’re needed, like
    this example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The container will have the `CHOWN`, `NET_RAW`, and `SETPCAP` capabilities removed,
    and the `NET_ADMIN` capability added.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker [documentation](https://oreil.ly/TOz3a) lists all the capabilities
    that are set on containers by default, and that can be added as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'For maximum security, you should drop all capabilities for every container
    and only add specific capabilities if they’re needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The capability mechanism puts a hard limit on what processes inside the container
    can do, even if they’re running as root. Once a capability has been dropped at
    the container level, it can’t be regained, even by a malicious process with maximum
    privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Pod Security Contexts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve covered security context settings at the level of individual containers,
    but you can also set some of them at the Pod level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: These settings will apply to all containers in the Pod, unless the container
    overrides a given setting in its own security context.
  prefs: []
  type: TYPE_NORMAL
- en: Pod Service Accounts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pods run with the permissions of the default service account for the namespace,
    unless you specify otherwise (see [“Applications and Deployment”](ch11.html#rbac-apps)).
    If you need to grant extra permissions for some reason (such as viewing Pods in
    other namespaces), create a dedicated service account for the app, bind it to
    the required roles, and configure the Pod to use the new service account.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, set the `serviceAccountName` field in the Pod spec to the name
    of the service account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may recall, each container has its own filesystem, which is accessible
    only to that container, and is *ephemeral*: any data that is not part of the container
    image will be lost when the container is restarted.'
  prefs: []
  type: TYPE_NORMAL
- en: Often, this is fine; the demo application, for example, is a stateless server
    which therefore needs no persistent storage. Nor does it need to share files with
    any other container.
  prefs: []
  type: TYPE_NORMAL
- en: More complex applications, though, may need both the ability to share data with
    other containers in the same Pod and to have it persist across restarts. A Kubernetes
    Volume object can provide both of these.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different types of Volume that you can attach to a Pod. Whatever
    the underlying storage medium, a Volume mounted on a Pod is accessible to all
    the containers in the Pod. Containers that need to communicate by sharing files
    can do so using a Volume of one kind or another. We’ll look at some of the more
    important types in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: emptyDir Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest Volume type is `emptyDir`. This is a piece of ephemeral storage
    that starts out empty—hence the name—and stores its data on the node (either in
    memory, or on the node’s disk). It persists only as long as the Pod is running
    on that node.
  prefs: []
  type: TYPE_NORMAL
- en: An `emptyDir` is useful when you want to provision some extra storage for a
    container, but it’s not critical to have the data persist forever or move with
    the container if it should be scheduled on another node. Some examples include
    caching downloaded files or generated content, or using a scratch workspace for
    data processing jobs.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you just want to share files between containers in a Pod, but
    don’t need to keep the data around for a long time, an `emptyDir` Volume is ideal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a Pod that creates an `emptyDir` Volume and mounts it
    on a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'First, in the `volumes` section of the Pod spec, we create an `emptyDir` Volume
    named `cache-volume`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the `cache-volume` Volume is available for any container in the Pod to
    mount and use. To do that, we list it in the `volumeMounts` section of the `demo`
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The container doesn’t have to do anything special to use the new storage: anything
    it writes to the path `/cache` will be written to the Volume, and will be visible
    to other containers that mount the same Volume. All containers mounting the Volume
    can read and write to it.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: Be careful writing to shared Volumes. Kubernetes doesn’t enforce any locking
    on disk writes. If two containers try to write to the same file at once, data
    corruption can result. To avoid this, either implement your own write-lock mechanism,
    or use a Volume type that supports locking, such as `nfs` or `glusterfs`.
  prefs: []
  type: TYPE_NORMAL
- en: Persistent Volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While an ephemeral `emptyDir` Volume is ideal for cache and temporary file
    sharing, some applications need to store persistent data; for example, any kind
    of database. In general, we don’t recommend that you start out trying to run databases
    in Kubernetes. You’re almost always better served by using a cloud service instead:
    for example, most cloud providers have managed solutions for relational databases
    such as MySQL and PostgreSQL, as well as key-value (NoSQL) stores.'
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in [“Kubernetes Is Not a Panacea”](ch01.html#nodbsink8s), Kubernetes
    is best at managing stateless applications, which means no persistent data. Storing
    persistent data significantly complicates the Kubernetes configuration for your
    app. You’ll need to ensure that your persistent storage is reliable, performant,
    secure, and backed up.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to use persistent volumes with Kubernetes, the PersistentVolume
    resource is what you’re looking for. We won’t go into great detail about that
    here, because the details tend to be specific to your cloud provider; you can
    read more about PersistentVolumes in the Kubernetes [documentation](https://oreil.ly/FQvRN).
  prefs: []
  type: TYPE_NORMAL
- en: The most flexible way to use PersistentVolumes in Kubernetes is to create a
    PersistentVolumeClaim object. This represents a request for a particular type
    and size of PersistentVolume; for example, a 10 GiB Volume of high-speed, read-write
    storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Pod can then add this PersistentVolumeClaim as a Volume, where it will
    be available for containers to mount and use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create a pool of PersistentVolumes in your cluster to be claimed by
    Pods in this way. Alternatively, you can set up [*dynamic provisioning*](https://oreil.ly/4VNTz):
    when a PersistentVolumeClaim like this is mounted, a suitable chunk of storage
    will be automatically provisioned and connected to the Pod.'
  prefs: []
  type: TYPE_NORMAL
- en: We will cover this more in [“StatefulSets”](ch09.html#statefulsets).
  prefs: []
  type: TYPE_NORMAL
- en: Restart Policies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We saw in [“Running Containers for Troubleshooting”](ch07.html#runningcxrs)
    that Kubernetes always restarts a Pod when it exits, unless you tell it otherwise.
    The default restart policy is thus `Always`, but you can change this to `OnFailure`
    (restart only if the container exited with a nonzero status), or `Never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you want to run a Pod to completion and then have it exit, rather than being
    restarted, you can use a Job resource to do this (see [“Jobs”](ch09.html#jobs)).
  prefs: []
  type: TYPE_NORMAL
- en: Image Pull Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes will download your specified image from the container registry if
    it isn’t already present on the node. However, what if you’re using a private
    registry? How can you give Kubernetes the credentials to authenticate to the registry?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `imagePullSecrets` field on a Pod allows you to configure this. First,
    you need to store the registry credentials in a Secret object (see [“Kubernetes
    Secrets”](ch10.html#secrets) for more about this). Now you can tell Kubernetes
    to use this Secret when pulling any containers in the Pod. For example, if your
    Secret is named `registry-creds`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The exact format of the registry credentials data is described in the Kubernetes
    [documentation](https://oreil.ly/AfdOF).
  prefs: []
  type: TYPE_NORMAL
- en: You can also attach `imagePullSecrets` to a service account (see [“Pod Service
    Accounts”](#serviceaccounts)). Any Pods created using this service account will
    automatically have the attached registry credentials available.
  prefs: []
  type: TYPE_NORMAL
- en: Init Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you find yourself in a situation where you need to run a container prior
    to running your main applications, you can use an [Init container](https://oreil.ly/Obo5B).
  prefs: []
  type: TYPE_NORMAL
- en: 'Init containers are defined in the Pod spec and work mostly the same as regular
    containers, but they do not use liveness or readiness probes. Instead init containers
    must run and exit successfully before other containers in the Pod are started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: These can be useful for doing pre-flight checks before starting your app, or
    running any sort of bootstrap script needed to get things ready for your app.
    One common use-case for an init container is grabbing Secrets from an external
    Secret store and mounting them into your application with a Volume before startup.
    Just make sure that your init containers are idempotent and can be safely retried
    if you decide to use them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand Kubernetes, you first need to understand containers.
    In this chapter, we’ve outlined the basic idea of what a container is, how they
    work together in Pods, and what options are available for you to control how containers
    run in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bare essentials:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux container, at the kernel level, is an isolated set of processes, with
    ring-fenced resources. From inside a container, it looks as though the container
    has a Linux machine to itself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers are not virtual machines. Each container should run one primary process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Pod usually contains one container that runs a primary application, plus optional
    *helper* containers that support it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container image specifications can include a registry hostname, a repository
    namespace, an image repository, and a tag; for example, `docker.io/cloudnatived/demo:hello`.
    Only the image name is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For reproducible deployments, always specify a tag for the container image.
    Otherwise, you’ll get whatever happens to be `latest`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programs in containers should not run as the root user. Instead, assign them
    an ordinary user.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can set the `runAsNonRoot: true` field on a container to block any container
    that wants to run as `root`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other useful security settings on containers include `readOnlyRootFilesystem:
    true` and `allowPrivilegeEscalation: false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux capabilities provide a fine-grained privilege control mechanism, but the
    default capabilities for containers may be too generous. You can lock down your
    Pods by dropping all capabilities for containers, then granting specific capabilities
    if a container needs them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers in the same Pod can share data by reading and writing a mounted Volume.
    The simplest Volume is of type `emptyDir`, which starts out empty and preserves
    its contents only as long as the Pod is running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A PersistentVolume, on the other hand, preserves its contents as long as needed.
    Pods can dynamically provision new PersistentVolumes using PersistentVolumeClaims.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Init containers can be useful for doing inital setup before your application
    is started in a Pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
