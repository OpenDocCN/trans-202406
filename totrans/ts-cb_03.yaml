- en: Chapter 2\. Basic Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you are all set up, it’s time to write some TypeScript! Starting out
    should be easy, but you will soon run into situations where you’re unsure if you’re
    doing the right thing. Should you use interfaces or type aliases? Should you annotate
    or let type inference do its magic? What about `any` and `unknown`: are they safe
    to use? Some people on the internet said you should never use them, so why are
    they part of TypeScript?'
  prefs: []
  type: TYPE_NORMAL
- en: All these questions will be answered in this chapter. We will look at the basic
    types that make TypeScript and learn how an experienced TypeScript developer will
    use them. You can use this as a foundation for the upcoming chapters, so you get
    a feel for how the TypeScript compiler gets to its types and how it interprets
    your annotations.
  prefs: []
  type: TYPE_NORMAL
- en: This is about the interaction between your code, the editor, and the compiler.
    And it’s about going up and down the type hierarchy, as we will see in [Recipe
    2.3](#ch02_item_objects). Whether you’re an experienced TypeScript developer or
    just starting out, you’ll find useful information in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 2.1 Annotating Effectively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotating types is cumbersome and boring.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotate only when you want your types checked.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A type annotation is a way to explicitly tell which types to expect. You know,
    the prominent stuff in other programming languages, where the verbosity of `StringBuilder
    stringBuilder = new StringBuilder()` makes sure that you’re really, really dealing
    with a `StringBuilder`. The opposite is type inference, where TypeScript tries
    to figure out the type for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Type annotations are also the most obvious and visible syntax difference between
    TypeScript and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: When you start learning TypeScript, you might want to annotate everything to
    express the types you’d expect. This might feel like the obvious choice, but you
    can also use annotations sparingly and let TypeScript figure out types for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'A type annotation is a way for you to express where contracts have to be checked.
    If you add a type annotation to a variable declaration, you tell the compiler
    to check if types match during the assignment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If `createPerson` returns something that isn’t compatible with `Person`, TypeScript
    will throw an error. Do this if you really want to be sure you’re dealing with
    the right type.
  prefs: []
  type: TYPE_NORMAL
- en: Also, from this moment on, `me` is of type `Person`, and TypeScript will treat
    it as a `Person`. If there are more properties in `me`—for example, a `profession`—TypeScript
    won’t allow you to access them. It’s not defined in `Person`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add a type annotation to a function signature’s return value, you tell
    the compiler to check if types match the moment you return that value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you return something that doesn’t match `Person`, TypeScript will throw an
    error. Do this if you want to be completely sure that you return the correct type.
    This especially comes in handy if you are working with functions that construct
    big objects from various sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you add a type annotation to a function signature’s parameters, you tell
    the compiler to check if types match the moment you pass along arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In my opinion this is the most important and unavoidable type annotation. Everything
    else can be inferred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You can use inferred object types where you expect an annotation because TypeScript
    has a *structural type system*. In a structural type system, the compiler will
    only take into account the members (properties) of a type, not the actual name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types are compatible if all members of the type to check against are available
    in the type of the value. We also say that the *shape* or *structure* of a type
    has to match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`User` has more properties than `Person`, but all properties that are in `Person`
    are also in `User`, and they have the same type. This is why it’s possible to
    pass `User` objects to `printPerson`, even though the types don’t have any explicit
    connection.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you pass a literal, TypeScript will complain that there are excess
    properties that should not be there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This makes sure that you didn’t expect properties to be present in this type
    and then wonder why changing them has no effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'With a structural type system, you can create interesting patterns with carrier
    variables with the type inferred, and you can reuse the same variable in different
    parts of your software, with no similar connection to each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`Student`, `Person`, and `Studying` have some overlap but are unrelated to
    each other. `createPerson` returns something that is compatible with all three
    types. If you have annotated too much, you would need to create a lot more types
    and a lot more checks than necessary, without any benefit.'
  prefs: []
  type: TYPE_NORMAL
- en: So annotate wherever you want to have your types checked, at least for function
    arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 2.2 Working with any and unknown
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are two top types in TypeScript, `any` and `unknown`. Which one should
    you use?
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `any` if you effectively want to deactivate typing; use `unknown` when you
    need to be cautious.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Both `any` and `unknown` are top types, which means that every value is compatible
    with `any` or `unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `any` is a type every value is compatible with, you can access any property
    without restriction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`any` is also compatible with every subtype, except `never`. This means you
    can narrow the set of possible values by assigning a new type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Being so permissive, `any` can be a constant source of potential errors and
    pitfalls since you effectively deactivate type-checking.
  prefs: []
  type: TYPE_NORMAL
- en: 'While everybody seems to agree that you shouldn’t use `any` in your codebases,
    there are some situations where `any` is really useful:'
  prefs: []
  type: TYPE_NORMAL
- en: Migration
  prefs: []
  type: TYPE_NORMAL
- en: When you go from JavaScript to TypeScript, chances are that you already have
    a large codebase with a lot of implicit information on how your data structures
    and objects work. It might be a chore to get everything spelled out in one go.
    `any` can help you migrate to a safer codebase incrementally.
  prefs: []
  type: TYPE_NORMAL
- en: Untyped third-party dependencies
  prefs: []
  type: TYPE_NORMAL
- en: 'You might have a JavaScript dependency that still refuses to use TypeScript
    (or something similar). Or even worse: there are no up-to-date types for it. Definitely
    Typed is a great resource, but it’s also maintained by volunteers. It’s a formalization
    of something that exists in JavaScript but is not directly derived from it. There
    might be errors (even in such popular type definitions like React’s), or they
    just might not be up to date!'
  prefs: []
  type: TYPE_NORMAL
- en: This is where `any` can help you. When you know how the library works, if the
    documentation is good enough to get you going, and if you use it sparingly, `any`
    can be an option instead of fighting types.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript prototyping
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript works a bit differently from JavaScript and needs to make a lot
    of trade-offs to ensure that you don’t run into edge cases. This also means that
    if you write certain things that would work in JavaScript, you’d get errors in
    TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Find out why this is an error in [Recipe 9.1](ch09.html#ch09_working_with_object_keys).
    In cases like this, `any` can help you to switch off type-checking for a moment
    because you know what you’re doing. And since you can go from every type to `any`,
    but also back to every other type, you have little, explicit unsafe blocks throughout
    your code where you are in charge of what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you know this part of your code works, you can start adding the right
    types, work around TypeScript’s restrictions, and type assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Whenever you use `any`, make sure you activate the `noImplicitAny` flag in your
    *tsconfig.json*; it is activated by default in `strict` mode. TypeScript needs
    you to explicitly annotate `any` when you don’t have a type through inference
    or annotation. This helps find potentially problematic situations later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative to `any` is `unknown`. It allows for the same values, but the
    things you can do with it are very different. Where `any` allows you to do everything,
    `unknown` allows you to do nothing. All you can do is pass values around; the
    moment you want to call a function or make the type more specific, you first need
    to do type-checks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Type-checks and control flow analysis help you do more with `unknown`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: If your apps work with a lot of different types, `unknown` is great for making
    sure that you can carry values throughout your code but don’t run into any safety
    problems because of `any`’s permissiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 2.3 Choosing the Right Object Type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You want to allow for values that are JavaScript objects, but there are three
    different object types: `object`, `Object`, and `{}`. Which one should you use?'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use `object` for compound types like objects, functions, and arrays. Use `{}`
    for everything that has a value.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript divides its types into two branches. The first branch, *primitive
    types*, includes `number`, `boolean`, `string`, `symbol`, `bigint`, and some subtypes.
    The second branch, *compound types*, includes everything that is a subtype of
    an object and is ultimately composed of other compound types or primitive types.
    [Figure 2-1](#img-type-hierarchy) provides an overview.
  prefs: []
  type: TYPE_NORMAL
- en: '![tscb 0201](assets/tscb_0201.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2-1\. The type hierarchy in TypeScript
  prefs:
  - PREF_H6
  type: TYPE_NORMAL
- en: 'In some situations you want to target values that are *compound types*, either
    because you want to modify certain properties or because you just want to be safe
    that you don’t pass any primitive values. For example `Object.create` creates
    a new object and takes its prototype as the first argument. This can only be a
    *compound type*; otherwise, your runtime JavaScript code would crash:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In TypeScript, three types seem to do the same thing: The empty object type
    `{}`, the uppercase O `Object` interface, and the lowercase O `object` type. Which
    one do you use for compound types?'
  prefs: []
  type: TYPE_NORMAL
- en: '`{}` and `Object` allow for roughly the same values, which are everything but
    `null` or `undefined` (given that `strict` mode or `strictNullChecks` is activated):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `Object` interface is compatible with all values that have the `Object`
    prototype, which is every value from every primitive and compound type.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, `Object` is a defined interface in TypeScript, and it has some requirements
    for certain functions. For example, the `toString` method, which is `toString()
    => string` and part of any non-nullish value, is part of the `Object` prototype.
    If you assign a value with a different `tostring` method, TypeScript will error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '`Object` can cause some confusion due to this behavior, so in most cases, you’re
    good with `{}`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript also has a *lowercase* `object` type. This is more the type you’re
    looking for, as it allows for any compound type but no primitive types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you want a type that excludes functions, regexes, arrays, and the like, see
    [Chapter 5](ch05.html#ch05), where we create one on our own.
  prefs: []
  type: TYPE_NORMAL
- en: 2.4 Working with Tuple Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are using JavaScript arrays to organize your data. The order is important,
    and so are the types at each position. But TypeScript’s type inference makes it
    really cumbersome to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Annotate with tuple types.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like objects, JavaScript arrays are a popular way to organize data in a complex
    object. Instead of writing a typical `Person` object as we did in other recipes,
    you can store entries element by element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The benefit of using arrays over objects is that array elements don’t have
    property names. When you assign each element to variables using destructuring,
    it becomes really easy to assign custom names:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: For APIs where you need to assign new names constantly, using arrays is very
    comfortable, as explained in [Chapter 10](ch10.html#ch10).
  prefs: []
  type: TYPE_NORMAL
- en: 'When using TypeScript and relying on type inference, however, this pattern
    can cause some issues. By default, TypeScript infers the array type from an assignment.
    Arrays are open-ended collections with the same element in each position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'So TypeScript thinks that `person` is an array, where each element can be either
    a string or a number, and it allows for plenty of elements after the original
    two. This means when you’re destructuring, each element is also of type `string`
    or `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: That makes a comfortable pattern in JavaScript really cumbersome in Typescript.
    You would need to do control flow checks to narrow the type to the actual one,
    where it should be clear from the assignment that this is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you think you need to do extra work in JavaScript just to satisfy TypeScript,
    there’s usually a better way. In that case, you can use tuple types to be more
    specific about how your array should be interpreted.
  prefs: []
  type: TYPE_NORMAL
- en: Tuple types are a sibling of array types that work on a different semantic.
    While arrays can be potentially endless in size and each element is of the same
    type (no matter how broad), tuple types have a fixed size, and each element has
    a distinct type.
  prefs: []
  type: TYPE_NORMAL
- en: 'All you need to do to get tuple types is to explicitly annotate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Fantastic! Tuple types have a fixed length; this means the length is also encoded
    in the type. So assignments that go out of bounds are not possible; TypeScript
    will throw an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript also allows you to add labels to tuple types. This is just metainformation
    for editors and compiler feedback, but it allows you to be clearer about what
    to expect from each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This will help you and your colleagues to understand what to expect, just like
    with object types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tuple types can also be used to annotate function arguments. This function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'can also be written with tuple types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can be very flexible in defining it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'These are also known as *rest* elements, something that we have in JavaScript
    that allow you to define functions with an almost limitless argument list; when
    it is the last element, the *rest* element sucks all excess arguments in. When
    you need to collect arguments in your code, you can use a tuple before you apply
    them to your function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Tuple types are useful for many scenarios. For more information about tuple
    types, see Chapters [7](ch07.html#ch07) and [10](ch10.html#ch10).
  prefs: []
  type: TYPE_NORMAL
- en: 2.5 Understanding Interfaces Versus Type Aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'TypeScript declares object types in two ways: interfaces and type aliases.
    Which one should you use?'
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use type aliases for types within your project’s boundary, and use interfaces
    for contracts that are meant to be consumed by others.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both approaches to defining object types have been the subject of many blog
    articles over the years. And all of them became outdated over time. As of this
    writing there is little difference between type aliases and interfaces. And everything
    that *was* different has been gradually aligned.
  prefs: []
  type: TYPE_NORMAL
- en: 'Syntactically, the difference between interfaces and type aliases is nuanced:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use interfaces and type aliases for the same things, in the same scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: In an implements declaration for classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a type annotation for object literals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For recursive type structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there is one important difference that can cause side effects you
    usually don’t want to deal with: interfaces allow for declaration merging, but
    type aliases don’t. Declaration merging allows for adding properties to an interface
    even after it has been declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript often uses this technique in *lib.d.ts* files, making it possible
    to just add deltas of new JavaScript APIs based on ECMAScript versions. This is
    a great feature if you want to extend, for example, `Window`, but it can backfire
    in other scenarios, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: So, where does the `entries()` method come from? It’s a DOM API! `FormData`
    is one of the interfaces provided by browser APIs, and there are a lot of them.
    They are globally available, and nothing keeps you from extending those interfaces.
    And you get no notification if you do.
  prefs: []
  type: TYPE_NORMAL
- en: You can of course argue about proper naming, but the problem persists for all
    interfaces that you make available globally, maybe from some dependency where
    you aren’t even aware they add an interface to the global space.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing this interface to a type alias immediately makes you aware of this
    problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaration merging is a fantastic feature if you are creating a library that
    is consumed by other parts in your project, maybe even other projects written
    entirely by other teams. It allows you to define an interface that describes your
    application but allows your users to adapt it to reality. Think of a plug-in system,
    where loading new modules enhances functionality: declaration merging is a feature
    that you do not want to miss.'
  prefs: []
  type: TYPE_NORMAL
- en: Within your module’s boundaries, however, using type aliases prevents you from
    accidentally reusing or extending already declared types. Use type aliases when
    you don’t expect others to consume them.
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using type aliases over interfaces has sparked some discussion, as interfaces
    have been considered much more performant in their evaluation than type aliases,
    even resulting in a performance recommendation on the official [TypeScript wiki](https://oreil.ly/8Y0hP).
    This recommendation should be taken with a grain of salt.
  prefs: []
  type: TYPE_NORMAL
- en: 'On creation, simple type aliases may perform faster than interfaces because
    interfaces are never closed and might be merged with other declarations. But interfaces
    may perform faster in other places because they’re known ahead of time to be object
    types. Ryan Canavaugh from the TypeScript team expects performance differences
    to be measurable with an extraordinary number of interfaces or type aliases to
    be declared: around five thousand according to [this tweet](https://oreil.ly/Y_2oS).'
  prefs: []
  type: TYPE_NORMAL
- en: If your TypeScript code base doesn’t perform well, it’s not because you declared
    too many type aliases instead of interfaces, or vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 2.6 Defining Function Overloads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your function’s API is very flexible and allows for arguments of various types,
    where context is important. This is hard to type in just a single function signature.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use function overloads.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript is very flexible when it comes to function arguments. You can pass
    basically any parameters, of any length. As long as the function body treats the
    input correctly, you’re good. This allows for very ergonomic APIs, but it’s also
    very tough to type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of a conceptual task runner. With a `task` function you define new tasks
    by name and either pass a callback or pass a list of other tasks to be executed.
    Or both—a list of tasks that needs to be executed *before* the callback runs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you’re thinking, “this looks a lot like Gulp six years ago,” you’re right.
    Its flexible API where you couldn’t do much wrong was also one of the reasons
    Gulp was so popular.
  prefs: []
  type: TYPE_NORMAL
- en: Typing functions like this can be a nightmare. Optional arguments, different
    types at the same position—this is tough to do even if you use union types:^([1](ch02.html#id500))
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This catches all variations from the preceding example, but it’s also wrong,
    as it allows for combinations that don’t make any sense:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Thankfully, TypeScript has a way to solve problems like this: function overloads.
    Its name hints at similar concepts from other programming languages: the same
    defintion but with different behavior. The biggest difference in TypeScript, as
    opposed to other programming languages, is that function overloads work only on
    a type system level and have no effect on the actual implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The idea is that you define every possible scenario as its own function signature.
    The last function signature is the actual implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: A couple of things are important to note here.
  prefs: []
  type: TYPE_NORMAL
- en: First, TypeScript only picks up the declarations before the actual implementation
    as possible types. If the actual implementation signature is also relevant, duplicate
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Also, the actual implementation function signature can’t be anything. TypeScript
    checks if the overloads can be implemented with the implementation signature.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have different return types, it is your responsibility to make sure
    that inputs and outputs match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The implementation signature usually works with a very broad type, which means
    you have to do a lot of checks that you would need to do in JavaScript anyway.
    This is good as it urges you to be extra careful.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you need overloaded functions as their own type, to use them in annotations
    and assign multiple implementations, you can always create a type alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you only need the type system overloads, not the actual implementation
    definition.
  prefs: []
  type: TYPE_NORMAL
- en: 2.7 Defining this Parameter Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are writing callback functions that make assumptions about `this`, but you
    don’t know how to define `this` when writing the function standalone.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Define a `this` parameter type at the beginning of a function signature.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One source of confusion for aspiring JavaScript developers is the ever-changing
    nature of the `this` object pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes when writing JavaScript, I want to shout, “This is ridiculous!” But
    then I never know what *this* refers to.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Unknown JavaScript developer
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The preceding statement is true especially if your background is a class-based
    object-oriented programming language, where `this` always refers to an instance
    of a class. `this` in JavaScript is entirely different but not necessarily harder
    to understand. What’s more, TypeScript can greatly help get more closure about
    `this` in usage.
  prefs: []
  type: TYPE_NORMAL
- en: '`this` lives within the scope of a function, and that points to an object or
    value bound to that function. In regular objects, `this` is pretty straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'But functions are values in JavaScript, and they can be bound to a different
    context, effectively changing the value of `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'It doesn’t help that the semantics of `this` change again if you use arrow
    functions instead of regular functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: With TypeScript, we can get more information on what `this` is and, more importantly,
    what it’s supposed to be through `this` parameter types.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following example. We access a button element via DOM APIs
    and bind an event listener to it. Within the callback function, `this` is of type
    `HT⁠ML⁠Bu⁠tt⁠on​El⁠em⁠ent⁠`, which means you can access properties like `classList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The information on `this` is provided by the `addEventListener` function. If
    you extract your function in a refactoring step, you retain the functionality,
    but TypeScript will error, as it loses context for `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The trick is to tell TypeScript that `this` is supposed to be a specific type.
    You can do this by adding a parameter at the very first position in your function
    signature named `this`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This argument gets removed once compiled. TypeScript now has all the information
    it needs to make sure `this` needs to be of type `HTMLButtonElement`, which also
    means that you get errors once you use `handleToggle` in a different context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'You can make `handleToggle` even more useful if you define `this` to be `HTMLElement`,
    a supertype of `HTMLButtonElement`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'When working with `this` parameter types, you might want to use two helper
    types that can either extract or remove `this` parameters from your function type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: There are more helper types for `this` in classes and objects. See more in Recipes
    [4.8](ch04.html#ch04_this_type) and [11.8](ch11.html#ch11_this_return).
  prefs: []
  type: TYPE_NORMAL
- en: 2.8 Working with Symbols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You see the type `symbol` popping up in some error messages, but you don’t know
    what symbols mean or how you can use them.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create symbols for object properties you want to be unique and not iterable.
    They’re great for storing and accessing sensitive information.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`symbol` is a primitive data type in JavaScript and TypeScript, which, among
    other things, can be used for object properties. Compared to `number` and `string`,
    symbols have some unique features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Symbols can be created using the `Symbol()` factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '`Symbol` has no constructor function. The parameter is an optional description.
    By calling the factory function, `TITLE` is assigned the unique value of this
    freshly created symbol. This symbol is now unique and distinguishable from all
    other symbols, and it doesn’t clash with any other symbols that have the same
    description:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'The description helps you to get info on the symbol during development time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Symbols are great if you want to have comparable values that are exclusive
    and unique. For runtime switches or mode comparisons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Symbols also work as property keys but are not iterable, which is great for
    serialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'A global symbols registry allows you to access tokens across your whole application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The first call to `Symbol.for` creates a symbol, and the second call uses the
    same symbol. If you store the symbol value in a variable and want to know the
    key, you can use `Symbol.keyFor()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Nifty!
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript has full support for symbols, and they are prime citizens in the
    type system. `symbol` itself is a data type annotation for all possible symbols.
    See the `ex⁠ten⁠d​Ob⁠je⁠ct` function in the preceding code block. To allow for
    all symbols to extend our object, we can use the `symbol` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: There’s also the subtype `unique symbol`. A `unique symbol` is closely tied
    to the declaration, allowed only in `const` declarations, and referencing this
    exact symbol and nothing else.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a nominal type in TypeScript for a very nominal value in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get to the type of `unique symbol`, you need to use the `typeof` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: At the time of writing, the only possible nominal type is TypeScript’s structural
    type system.
  prefs: []
  type: TYPE_NORMAL
- en: Symbols stand at the intersection between nominal and opaque types in TypeScript
    and JavaScript. They are the closest things we get to nominal type-checks at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 2.9 Understanding Value and Type Namespaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s confusing that you can use certain names as type annotations and not others.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Learn about type and value namespaces, and which names contribute to what.
  prefs: []
  type: TYPE_NORMAL
- en: Discussion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript is a superset of JavaScript, which means it adds more things to an
    already existing and defined language. Over time you learn to spot which parts
    are JavaScript and which parts are TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: It really helps to see TypeScript as this additional layer of types upon regular
    JavaScript, a thin layer of metainformation that will be peeled off before your
    JavaScript code runs in one of the available runtimes. Some people even speak
    about TypeScript code “erasing to JavaScript” once compiled.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript being this layer on top of JavaScript also means that different
    syntax contributes to different layers. While a `function` or `const` creates
    a name in the JavaScript part, a `type` declaration or an `interface` contributes
    a name in the TypeScript layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We also say that declarations contribute a name to either the *type namespace*
    or the *value namespace*. Since the type layer is on top of the value layer, it’s
    possible to consume values in the type layer, but not vice versa. We also have
    explicit keywords for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '`typeof` creates a name available in the type layer from the value layer below.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It gets irritating when there are declaration types that create both types
    and values. Classes, for instance, can be used in the TypeScript layer as a type
    as well as in JavaScript as a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: And naming conventions can trick you. Usually, we define classes, types, interfaces,
    enums, and so on with a capital first letter. And even if they may contribute
    values, they for sure contribute types. Well, until you write uppercase functions
    for your React app, as the convention dictates.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you’re used to using names as types and values, you’re going to scratch
    your head if you suddenly get a good old “TS2749: *YourType* refers to a value,
    but is being used as a type” error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: This is where TypeScript can get really confusing. What is a type, what is a
    value, why do we need to separate them, and why doesn’t this work like in other
    programming languages? Suddenly, you are confronted with `typeof` calls or even
    the `InstanceType` helper type, because you realize that classes actually contribute
    two types (see [Chapter 11](ch11.html#ch11)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Classes contribute a name to the type namespace, and since TypeScript is a
    structural type system, they allow values that have the same shape as an instance
    of a certain class. So this is allowed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'However, `instanceof` checks, which are working entirely in the value namespace
    and just have implications in the type namespace, would fail, as objects with
    the same shape may have the same properties but are not an actual *instance* of
    a class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: So it’s useful to understand what contributes types and what contributes value.
    [Table 2-1](#table2_1), adapted from the TypeScript docs, sums it up nicely.
  prefs: []
  type: TYPE_NORMAL
- en: Table 2-1\. Type and value namespaces
  prefs: []
  type: TYPE_NORMAL
- en: '| Declaration type | Type | Value |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Class | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| Enum | X | X |'
  prefs: []
  type: TYPE_TB
- en: '| Interface | X |  |'
  prefs: []
  type: TYPE_TB
- en: '| Type Alias | X |  |'
  prefs: []
  type: TYPE_TB
- en: '| Function |  | X |'
  prefs: []
  type: TYPE_TB
- en: '| Variable |  | X |'
  prefs: []
  type: TYPE_TB
- en: If you stick with functions, interfaces (or type aliases, see [Recipe 2.5](#ch02_item_interfaces_vs_types)),
    and variables at the beginning, you will get a feel for what you can use where.
    If you work with classes, think about the implications a bit longer.
  prefs: []
  type: TYPE_NORMAL
- en: ^([1](ch02.html#id500-marker)) Union types are a way to combine two different
    types into one (see more in [Chapter 3](ch03.html#ch03)).
  prefs: []
  type: TYPE_NORMAL
